- en: Chapter 1. Meet Tkinter
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。认识Tkinter
- en: Welcome to the exciting world of GUI programming with Tkinter. This project
    aims at getting you acquainted with Tkinter, the built-in **graphical user interface**
    (**GUI**) interface for all standard Python distributions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到Tkinter的激动人心的GUI编程世界。本项目旨在让您熟悉Tkinter，这是所有标准Python发行版内置的**图形用户界面**（**GUI**）接口。
- en: '**Tkinter** (pronounced tea-kay-inter) is the Python interface to Tk, the GUI
    toolkit for Tcl/Tk.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**Tkinter**（发音为“tea-kay-inter”）是Python对Tk的接口，Tk是Tcl/Tk的GUI工具包。'
- en: '**Tcl** (pronounced "tickle" and is an acronym for **Tool Command Language**)
    is a popular scripting language in the domains of embedded applications, testing,
    prototyping, and GUI development. Tk on the other hand is an open source, multiplatform
    widget toolkit that is used by many different languages for building GUI programs.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**Tcl**（发音为“tickle”，是**工具命令语言**的缩写）是在嵌入式应用、测试、原型设计和GUI开发领域流行的脚本语言。另一方面，Tk是一个开源的多平台小部件工具包，被许多不同的语言用于构建GUI程序。'
- en: The Tkinter interface is implemented as a Python module, `Tkinter.py`, which
    is just a wrapper around a C-extension that uses Tcl/Tk libraries.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter接口作为Python模块`Tkinter.py`实现，它只是围绕使用Tcl/Tk库的C扩展的包装器。
- en: Tkinter is suited for application to a wide variety of areas ranging from small
    desktop applications, to use in scientific modeling and research endeavors across
    various disciplines.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter适用于广泛应用于各种领域的应用，从小型桌面应用程序到跨多个学科的科学建模和研究工作。
- en: We believe that the concepts you will develop here will enable you to apply
    and develop GUI applications in your area of interest. Let's get started!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们相信，您在这里将开发的概念将使您能够将GUI应用程序应用于您感兴趣的领域。让我们开始吧！
- en: Mission Briefing
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务简报
- en: The purpose of this project is to make you comfortable with Tkinter. It aims
    at introducing you to various components of GUI programming with Tkinter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的目的是让您对Tkinter感到舒适。它旨在向您介绍Tkinter的GUI编程的各种组件。
- en: 'By the end of this project, you will have developed several partly functional
    dummy applications such as the one shown as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个项目结束时，您将开发出几个部分功能性的模拟应用程序，如下所示：
- en: '![Mission Briefing](img/7941_01_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![任务简报](img/7941_01_01.jpg)'
- en: The applications developed in this project are "dummy applications" because
    they are not fully functional. In fact, the purpose of each small dummy application
    is to introduce you to some specific aspects of programming with Tkinter. This
    will set up the context for developing some fun and fully functional project ideas
    from [Project 2](ch02.html "Chapter 2. Making a Text Editor like Notepad"), *Making
    a Text Editor*, onwards.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目中开发的应用程序是“模拟应用程序”，因为它们不是完全功能性的。实际上，每个小型模拟应用程序的目的是向您介绍Tkinter编程的一些特定方面。这将为您从[项目2](ch02.html
    "第2章。制作类似记事本的文本编辑器")、“制作文本编辑器”开始的一些有趣且完全功能性的项目想法奠定基础。
- en: Why Is It Awesome?
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么它如此出色？
- en: The ability to program a GUI application (as opposed to a simple console application)
    opens a whole world of possibilities for a programmer. It shifts the focus of
    the program from the programmer to the end user, enabling the programmer to reach
    out to a wider audience.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 编程GUI应用程序的能力（与简单的控制台应用程序相比）为程序员打开了一个全新的世界。它将程序的焦点从程序员转移到最终用户，使程序员能够接触到更广泛的受众。
- en: When a person learning Python needs to graduate to GUI programming, Tkinter
    seems to be the easiest and fastest way to get the work done. Tkinter is a great
    tool for programming GUI applications in Python.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当学习Python的人需要过渡到GUI编程时，Tkinter似乎是最简单、最快完成任务的方式。Tkinter是Python中编程GUI应用程序的出色工具。
- en: 'The features that make Tkinter a great choice for GUI programming include:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使Tkinter成为GUI编程优秀选择的特性包括：
- en: It is simple to learn (simpler than any other GUI package for Python)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它易于学习（比任何其他Python GUI包都简单）
- en: Relatively little code can produce powerful GUI applications
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相对少量的代码可以产生强大的GUI应用程序
- en: Layered design ensures that it is easy to grasp
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分层设计确保了它易于掌握
- en: It is portable across all operating systems
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以在所有操作系统上运行
- en: It is easily accessible as it comes pre-installed with standard Python distribution
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它易于访问，因为它随标准Python发行版预安装
- en: None of the other GUI toolkits has all of these features at the same time.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 没有其他GUI工具包同时具备所有这些功能。
- en: Your Hotshot Objectives
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 您的热门目标
- en: 'The key concepts that we want you to take from this project include:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望您从这个项目中吸取的关键概念包括：
- en: Understanding the concept of root window and main loop
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解根窗口和主循环的概念
- en: Understanding widgets—the building blocks for your programs
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解小部件——您程序的构建块
- en: Acquainting yourself with a list of available widgets
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉可用的小部件列表
- en: 'Developing layouts using three geometry managers: pack, grid, and place'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用三个几何管理器：pack、grid和place来开发布局
- en: Learning to apply events and callbacks to make your program functional
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何应用事件和回调使您的程序功能化
- en: Styling your widgets with styling options and configuring the root widget
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用样式选项对您的部件进行样式设置并配置根部件
- en: Mission Checklist
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务清单
- en: An elementary knowledge of data structures, syntax, and semantics of Python
    is assumed. To work along with this project, you must have a working copy of Python
    2.7.3 installed on your computer.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您对Python的数据结构、语法和语义有基本了解。为了与本项目一起工作，您必须在您的计算机上安装一个可工作的Python 2.7.3副本。
- en: The Python download package and instructions for downloading for different platforms
    are available at [http://www.Python.org/getit/releases/2.7.3/](http://www.Python.org/getit/releases/2.7.3/).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Python下载包和不同平台的下载说明可在[http://www.Python.org/getit/releases/2.7.3/](http://www.Python.org/getit/releases/2.7.3/)找到。
- en: We will develop our application on the Windows 7 platform. However, since Tkinter
    is truly cross-platform, you can follow along on Mac or Linux distributions without
    any modifications to our code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Windows 7平台上开发我们的应用程序。然而，由于Tkinter真正是跨平台的，您可以在Mac或Linux发行版上跟随，而无需对我们的代码进行任何修改。
- en: 'After the installation, open the IDLE window and type:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，打开IDLE窗口并输入：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you have installed Python 2.7, this shell command should execute without
    any errors.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已安装Python 2.7，此shell命令应无错误执行。
- en: If there are no error messages the Tkinter module is installed in your Python
    distribution. When working with examples from this book, we do not support any
    other Python version except for Python 2.7, which comes bundled with Tkinter Tcl/Tk
    Version 8.5.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误消息，Tkinter模块已安装到您的Python发行版中。当使用本书中的示例时，我们不支持除Python 2.7以外的任何Python版本，Python
    2.7捆绑了Tkinter Tcl/Tk版本8.5。
- en: 'To test if you have the correct Tkinter version on your Python installation,
    type the following commands in your IDLE or interactive shell:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试您的Python安装中是否有正确的Tkinter版本，请在您的IDLE或交互式shell中输入以下命令：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This should pop up a window where the first line in the window reads **This
    is Tcl/Tk version 8.5**. Make sure it is not 8.4 or any earlier version, as Version
    8.5 is a vast improvement over its previous versions.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会弹出一个窗口，窗口中的第一行显示**这是Tcl/Tk版本8.5**。请确保它不是8.4或任何更早的版本，因为版本8.5在其先前版本上有了很大的改进。
- en: You are ready to code your Tkinter GUI applications if your version test confirms
    it as Tcl/Tk version 8.5\. Let's get started!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的版本测试确认它是Tcl/Tk版本8.5，那么您就可以开始编写Tkinter GUI应用程序了。让我们开始吧！
- en: The root window – your drawing board
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根窗口 – 您的绘图板
- en: GUI programming is an art, and like all art, you need a drawing board to capture
    your ideas. The drawing board you will use is called the **root window**. Our
    first goal is to get the root window ready.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: GUI编程是一门艺术，就像所有艺术一样，您需要一个画板来捕捉您的想法。您将使用的画板被称为**根窗口**。我们的第一个目标是准备好根窗口。
- en: Engage Thrusters
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Engage Thrusters
- en: 'The following screenshot depicts the root window we are going to create:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了我们将要创建的根窗口：
- en: '![Engage Thrusters](img/7941_01_02.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![Engage Thrusters](img/7941_01_02.jpg)'
- en: 'Drawing the root window is easy. You just need the following three lines of
    code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制根窗口很简单。您只需要以下三行代码：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Save this with the `.py` file extension or check out the code `1.01.py`. Open
    it in the IDLE window and run the program from the **Run** menu (*F5* in IDLE).
    Running this program should generate a blank root window as shown in the preceding
    screenshot. This window is furnished with functional minimize, maximize, and close
    buttons, and a blank frame.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 将其保存为`.py`文件扩展名或查看代码`1.01.py`。在IDLE窗口中打开它，并从**运行**菜单（IDLE中的*F5*）运行程序。运行此程序应生成一个如前截图所示的空白根窗口。此窗口配备了功能化的最小化、最大化和关闭按钮，以及一个空白框架。
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你购买的所有Packt书籍的账户中下载示例代码文件。[http://www.packtpub.com](http://www.packtpub.com)。如果你在其他地方购买了这本书，你可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给你。
- en: 'The description of the code is as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: The first line imports all (`*`) classes, attributes, and methods of Tkinter
    into the current workspace.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行将Tkinter的所有（`*`）类、属性和方法导入当前工作区。
- en: The second line creates an instance of the class `Tkinter.Tk`. This creates
    what is called the "root" window that you see in the screenshot provided. By convention,
    the root window in Tkinter is usually called "root", but you are free to call
    it by any other name.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二行创建了一个`Tkinter.Tk`类的实例。这创建了你在提供的截图中所看到的“根”窗口。按照惯例，Tkinter中的根窗口通常被称为“root”，但你也可以用任何其他名字来调用它。
- en: The third line executes the `mainloop` (that is, the event loop) method of the
    `root` object. The `mainloop` method is what keeps the root window visible. If
    you remove the third line, the window created in line 2 will disappear immediately
    as the script stops running. This will happen so fast that you will not even see
    the window appearing on your screen. Keeping the mainloop running also lets you
    keep the program running until you press the close button, which exits the main
    loop.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三行执行了`root`对象的`mainloop`（即事件循环）方法。`mainloop`方法使根窗口保持可见。如果你删除第三行，第2行创建的窗口将立即消失，因为脚本停止运行。这会发生得如此之快，以至于你甚至看不到窗口出现在你的屏幕上。保持`mainloop`运行还让你能够保持程序运行，直到你按下关闭按钮，这将退出主循环。
- en: Objective Complete – Mini Debriefing
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 简短回顾
- en: Congratulations! You have completed your first objective, which was to draw
    the root window. You have now prepared your drawing canvas (root window). Now
    get ready to paint it with your imagination!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经完成了第一个目标，即绘制根窗口。你现在已经准备好了你的绘图画布（根窗口）。现在准备好用你的想象力来绘制它吧！
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Commit the three lines of code (shown in *code 1.01.py*) to memory. These three
    lines generate your root window, which will accommodate all other graphical components.
    These lines constitute the skeleton of any GUI application that you will develop
    in Tkinter. All code that will make your GUI application functional will go between
    line 2 (new object creation) and line 3 (`mainloop`) of this code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下三行代码（如*code 1.01.py*所示）记住。这三行代码生成了你的根窗口，它将容纳所有其他图形组件。这些行构成了你将在Tkinter中开发的任何GUI应用程序的骨架。所有使你的GUI应用程序功能化的代码都将位于此代码的第2行（新对象创建）和第3行（`mainloop`）之间。
- en: Classified Intel
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分类情报
- en: This section describes the different styles of importing Tkinter modules.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了导入Tkinter模块的不同方式。
- en: 'In the preceding example, we imported Tkinter using the following command:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用以下命令导入Tkinter：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This method of import eases the handling of methods defined in the module. That
    is to say, you can simply access the methods directly. Generally, it is considered
    a bad practice to import all (`*`) methods of a module like we did here. This
    is because if you import all methods from some other module with a common method
    name, it would lead to the overwriting of methods.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这种导入方法简化了模块中定义的方法的处理。也就是说，你可以直接访问这些方法。通常，被认为是不好的做法像我们这里这样做，导入模块的所有（`*`）方法。这是因为如果你从其他模块导入具有相同方法名的所有方法，会导致方法的覆盖。
- en: 'There are several ways to import Tkinter in which this overlapping can be avoided,
    a common one being:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种导入Tkinter的方法可以避免这种重叠，其中一种常见的方法是：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This style of importing does not pollute the namespace with a list of all methods
    defined within Tkinter. However, every method within Tkinter will now have to
    be called using the format `Tkinter.methodA` instead of directly calling the method.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种导入方式不会将Tkinter内部定义的所有方法列表污染命名空间。然而，现在Tkinter中的每个方法都必须使用格式`Tkinter.methodA`来调用，而不是直接调用方法。
- en: 'Another commonly used import style is as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常用的导入方式如下：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here too, you do not pollute the current namespace with all Tkinter methods
    and now you can access methods such as `Tk.methodA`. "Tk" is a convenient, easy-to-type
    alias commonly used by many developers for importing Tkinter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你也不应该将所有Tkinter方法都污染当前命名空间，现在你可以访问如`Tk.methodA`这样的方法。"Tk"是一个方便、易于输入的别名，许多开发者常用它来导入Tkinter。
- en: The big picture
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整体情况
- en: 'As a GUI programmer, you will generally be responsible for deciding three aspects
    of your program:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 作为GUI程序员，你通常需要决定你程序的三方面：
- en: '**What components should appear on screen?**: This involves choosing the components
    that make the user interface. Typical components include things such as buttons,
    entry fields, checkboxes, radio buttons, scroll bars, and the like. In Tkinter,
    the components that you add to your GUI are called widgets.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**屏幕上应该显示哪些组件？**：这涉及到选择构成用户界面的组件。典型组件包括按钮、输入字段、复选框、单选按钮、滚动条等。在Tkinter中，你添加到GUI的组件被称为小部件。'
- en: '**Where should the components go?**: This involves deciding the positioning
    or placement of each component in the overall design structure. This includes
    decisions to be made on issues of positioning and the structural layout of various
    components. In Tkinter, this is referred to as **geometry management**.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件应该放在哪里？**：这涉及到决定每个组件在整体设计结构中的位置或放置。这包括对位置和各个组件的结构布局问题所做的决定。在Tkinter中，这被称为**几何管理**。'
- en: '**How do components interact and behave?**: This involves adding functionality
    to each component. Each component or widget does some work. For example, a button,
    when clicked on, does something in response; a scrollbar handles scrolling; and
    checkboxes and radio buttons enable the user to make some choices. In Tkinter,
    the functionality of various widgets is managed by `command` binding or `event`
    binding using **callback functions**.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件如何交互和表现？**：这涉及到为每个组件添加功能。每个组件或小部件都执行一些工作。例如，按钮在被点击时做出响应；滚动条处理滚动；复选框和单选按钮使用户能够做出一些选择。在Tkinter中，各种小部件的功能是通过`command`绑定或使用**回调函数**的`event`绑定来管理的。'
- en: Let us delve deeper into each of these three components in the context of Tkinter.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨Tkinter中的这三个组件。
- en: Widgets – building blocks for your GUI program
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小部件——你的GUI程序的基本构建块
- en: Now that we have our Toplevel window ready, it is time to think over the question,
    what components should appear in the window? In Tkinter jargon, these components
    are called **widgets** .
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了Toplevel窗口，是时候思考问题，窗口中应该出现哪些组件？在Tkinter术语中，这些组件被称为**小部件**。
- en: Engage Thrusters
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'The syntax for adding a widget is as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 添加小部件的语法如下：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the following example (refer to the code `01.02.py`), we add two widgets,
    a label and a button, to the root frame. Notice how all widgets are added in between
    the skeleton code we defined in the first example.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例（参考代码`01.02.py`）中，我们向根框架添加了两个小部件，一个标签和一个按钮。注意所有小部件是如何添加到我们在第一个示例中定义的骨架代码之间的。
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The description of the code is listed as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: This code adds a new instance, `mylabel`, for the **Label** widget. The first
    parameter defines `root` as its parent or container. The second parameter configures
    its text option as `"I am a label widget"`.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段代码为**标签**小部件添加了一个新的实例，`mylabel`。第一个参数定义`root`为其父或容器。第二个参数配置其文本选项为`"I am a
    label widget"`。
- en: We similarly define an instance of a **Button** widget. This is also bound to
    the root window as its parent.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们同样定义了一个**按钮**小部件的实例。这也绑定到根窗口作为其父。
- en: We use the `pack()` method, which is essentially required to position the label
    and button widgets within the window. We will discuss the `pack()` method and
    several other related concepts under the Geometry management task. However, you
    must note that some sort of geometry specification is essential for the widgets
    to display within the Toplevel window.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`pack()`方法，这是在窗口中定位标签和按钮小部件的基本要求。我们将在“几何管理任务”下讨论`pack()`方法和几个其他相关概念。然而，你必须注意，某种形式的几何规范对于小部件在Toplevel窗口中显示是必不可少的。
- en: Running this code will generate a window as shown in the following screenshot.
    It will have a custom label and a custom button:![Engage Thrusters](img/7941_01_03.jpg)
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行此代码将生成以下截图所示的窗口。它将有一个自定义标签和一个自定义按钮：![启动推进器](img/7941_01_03.jpg)
- en: Objective Complete – Mini Debriefing
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 简短回顾
- en: 'In this iteration, we have learned the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次迭代中，我们学习了以下内容：
- en: What widgets are.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小部件是什么。
- en: How widgets are instantiated and displayed within a container window frame.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在容器窗口框架内实例化和显示widget。
- en: How to set options for the widgets at the time of instantiation.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在实例化时设置widget的选项。
- en: The importance of specifying a geometry option such as `pack()` to display a
    widget. We will discuss more about this in a subsequent task.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定几何选项（如`pack()`）以显示widget的重要性。我们将在后续任务中进一步讨论这一点。
- en: Classified Intel
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分类情报
- en: All widgets are actually objects derived from their respective **widget class**.
    So, a statement such as `mybutton = Button(myContainer)`, actually creates the
    button instance from the `Button` class.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有widget实际上都是它们各自**widget类**的派生对象。因此，`mybutton = Button(myContainer)`这样的语句实际上是从`Button`类创建按钮实例。
- en: Each widget has a set of options that decides its behavior and appearance. This
    includes attributes such as text labels, colors, font size, and many more. For
    example, the Button widget has attributes to manage its label, control its size,
    change its foreground and background colors, change the size of the border, and
    so on.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个widget都有一组选项，决定了其行为和外观。这包括文本标签、颜色、字体大小等属性。例如，按钮widget有管理其标签、控制其大小、更改前景色和背景色、更改边框大小等属性。
- en: To set these attributes, you can set the values directly at the time of creation
    of the widget as we have done in the preceding example. Alternatively, you can
    later set or change the options of the widget by using the `.config()` or `.configure()`
    method. Note that the `.config()` or `.configure()` method are interchangeable
    and provide the same functionality.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要设置这些属性，你可以在创建widget时直接设置值，就像我们在前面的例子中所做的那样。或者，你可以稍后通过使用`.config()`或`.configure()`方法设置或更改widget的选项。请注意，`.config()`或`.configure()`方法是可互换的，并提供相同的功能。
- en: Tip
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'You can also add the `pack()` method on the same line in which you create a
    new instance of the widget. For example, consider the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在创建widget的新实例时在同一行添加`pack()`方法。例如，考虑以下代码：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you are instantiating the widget directly, you can write both the lines
    together as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你直接实例化widget，你可以将这两行代码一起写，如下所示：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You may keep a reference to the widget created (as in the first example, `mylabel`)
    or you can create a widget without keeping any reference to it (as in the second
    example).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以保留创建的widget的引用（如第一个例子中的`mylabel`），或者你可以创建一个没有保留任何引用的widget（如第二个例子）。
- en: You should ideally keep the reference if the widget content is likely to be
    modified by some action at a later stage in the program. If the widget state is
    to remain static after its creation, you need not keep a reference for the widget.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果widget的内容可能在程序的稍后阶段被某些操作修改，理想情况下你应该保留引用。如果widget的状态在创建后保持静态，你不需要保留widget的引用。
- en: 'Also, note that calls to `pack()` (or other geometry managers) always returns
    `None`. So, consider you create a widget keeping a reference to it and add the
    geometry manager (say `pack()`) on the same line as shown:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，调用`pack()`（或其他几何管理器）总是返回`None`。因此，考虑你创建一个widget并保留对其的引用，并在同一行添加几何管理器（例如`pack()`），如下所示：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this case, you are actually not creating a reference to the widget but instead
    creating a `None` type object for the variable `mylabel`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你实际上并没有创建widget的引用，而是为变量`mylabel`创建了一个`None`类型对象。
- en: So, when you later try to modify the widget through the reference, you get an
    error as you are actually trying to work on a `None` type object.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当你稍后尝试通过引用修改widget时，你会得到一个错误，因为你实际上正在尝试对一个`None`类型对象进行操作。
- en: This is one of the most common errors committed by beginners.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最常见的初学者错误之一。
- en: Getting to know core Tkinter widgets
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解核心Tkinter widget
- en: In this iteration, we will get to know all core Tkinter widgets. We have already
    seen two of them in the previous example—the Label and Button widgets. Let's now
    see all other core Tkinter widgets.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次迭代中，我们将了解所有核心Tkinter widget。在前面的例子中，我们已经看到了其中的两个——标签和按钮widget。现在让我们看看所有其他核心Tkinter
    widget。
- en: Prepare for Lift Off
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备起飞
- en: 'Tkinter includes 21 core widgets. These are as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter包括21个核心widget。具体如下：
- en: '| Toplevel widget | Label widget | Button widget |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| Toplevel widget | Label widget | Button widget |'
- en: '| Canvas widget | Checkbutton widget | Entry widget |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| Canvas widget | Checkbutton widget | Entry widget |'
- en: '| Frame widget | LabelFrame widget | Listbox widget |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| Frame widget | LabelFrame widget | Listbox widget |'
- en: '| Menu widget | Menubutton widget | Message widget |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 菜单widget | Menubutton widget | 消息widget |'
- en: '| OptionMenu widget | PanedWindow widget | Radiobutton widget |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| OptionMenu widget | PanedWindow widget | Radiobutton widget |'
- en: '| Scale widget | Scrollbar widget | Spinbox widget |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 滑块小部件 | 滚动条小部件 | 滚动框小部件 |'
- en: '| Text widget | Bitmap Class widget | Image Class widget |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 文本小部件 | 位图类小部件 | 图像类小部件 |'
- en: Let's write a program to include these widgets on our root window.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个程序，将这些小部件包含在我们的根窗口中。
- en: Engage Thrusters
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'The format for adding widgets is the same as we discussed in the previous task.
    To give you a flavor, here''s some sample code for adding some common widgets:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 添加小部件的格式与我们之前讨论的任务中相同。为了给你一个感觉，这里有一些添加一些常见小部件的示例代码：
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Can you spot the pattern common to each widget? Can you spot the differences?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你能发现每个小部件的共同模式吗？你能发现差异吗？
- en: 'As a reminder, the syntax for adding a widget is:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，添加小部件的语法是：
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tip
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The method for creating all the previously mentioned widgets is the same. Most
    of the configuration options will also be similar. However, a few configuration
    options vary from widget to widget.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 创建所有之前提到的小部件的方法是相同的。大多数配置选项也将相似。然而，一些配置选项会根据小部件的不同而有所变化。
- en: For example, the Button and Label widgets will have an option to configure their
    text, but scrollbars do not have a text-configuration option.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，按钮和标签小部件将有一个配置文本的选项，但滚动条没有文本配置选项。
- en: Using the same pattern, let's now add all the 21 core Tkinter widgets into a
    dummy application (code `01.03.py`).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的模式，现在让我们将所有21个核心Tkinter小部件添加到一个虚拟应用程序（代码`01.03.py`）中。
- en: Tip
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Do not be intimidated by the size of the program. Instead look for a common
    pattern that is used to initialize and display all the widgets. To reiterate,
    the syntax for adding a widget is:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 不要因为程序的大小而感到害怕。相反，寻找用于初始化和显示所有小部件的共同模式。为了重申，添加小部件的语法是：
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice how the configuration options for each widget differ slightly from each
    other depending on the type of widget being initialized.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到每个小部件的配置选项如何根据初始化的小部件类型略有不同。
- en: 'Refer to the code `1.03.py` for a demo of all Tkinter widgets. A summarized
    code description for `1.03.py` is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考代码`1.03.py`以查看所有Tkinter小部件的演示。`1.03.py`的代码摘要如下：
- en: We create a Toplevel window and create a main loop as seen in the earlier examples.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个顶层窗口并创建了一个主循环，就像之前示例中看到的那样。
- en: 'We add a Frame widget that we named `menubar`. Note that Frame widgets are
    just holder widgets that hold other widgets. Frame widgets are great for grouping
    widgets together. The syntax for adding a frame is the same as that of all other
    widgets:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个名为`menubar`的框架小部件。请注意，框架小部件只是持有其他小部件的容器小部件。框架小部件非常适合将小部件分组在一起。添加框架的语法与其他所有小部件的语法相同：
- en: '[PRE14]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Keeping the `menubar` frame as the container, we add two widgets to it, the
    Menubutton and Menu widgets.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`menubar`框架作为容器，我们向其中添加了两个小部件，菜单按钮和菜单小部件。
- en: 'We create another frame and name it `myframe1`. Keeping `myframe1` as the container/parent
    widget, we add seven widgets to it:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个新的框架并命名为`myframe1`。将`myframe1`作为容器/父小部件，我们向其中添加了七个小部件：
- en: The Label, Entry, Button, Checkbutton, Radiobutton, OptionMenu, and Bitmap Class
    widgets.
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签、输入框、按钮、复选框、单选按钮、选项菜单和位图类小部件。
- en: 'We then proceed to create `myframe2`, another Frame widget. We add six more
    widgets to it:'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们继续创建`myframe2`，另一个框架小部件。我们向其中添加了六个更多的小部件：
- en: The Image Class, Listbox, Spinbox, Scale, LabelFrame, and Message widgets.
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像类、列表框、滚动框、滑块、标签框架和信息小部件。
- en: We then create `myframe3`, another Frame widget. We add two more widgets to
    it, the Text and Scrollbar widgets.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们接着创建`myframe3`，另一个框架小部件。我们向其中添加了两个更多的小部件，文本和滚动条小部件。
- en: Finally we create the last frame, `myframe4`, another Frame widget. We add two
    more widgets to it, the Canvas and PanedWindow widgets.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们创建了最后一个框架`myframe4`，另一个框架小部件。我们向其中添加了两个更多的小部件，画布和分割窗口小部件。
- en: All these widgets constitute the 21 core widgets of Tkinter.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些小部件构成了Tkinter的21个核心小部件。
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Read through the code explanation, and find the corresponding piece of code
    in the example code `01.03.py`. Look at how each widget is created. Try to identify
    each widget's class name as used in Tkinter. Look what remains the same in all
    widgets, and what changes between one widget and another?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细阅读代码解释，并在示例代码`01.03.py`中找到相应的代码片段。观察每个小部件是如何创建的。尝试识别每个小部件在Tkinter中使用的类名。看看所有小部件中哪些是相同的，以及不同的小部件之间有哪些变化？
- en: A few minutes spent reading and understanding the code in `1.03.py` will really
    help you appreciate the simplicity and overall structure of a Tkinter program.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在`1.03.py`中花几分钟阅读和理解代码，将真正帮助你欣赏Tkinter程序的简洁性和整体结构。
- en: Finally, note that we have used `.pack()` on each widget to display it inside
    its container frame. We discuss `.pack()` in the next task. However, for now just
    note that we have used something called `pack()`, without which the widgets would
    not have displayed at all.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，我们已经在每个部件上使用了`.pack()`来显示它在其容器框架内。我们将在下一个任务中讨论`.pack()`。然而，现在只需注意，我们已经使用了名为`pack()`的东西，没有它，部件根本不会显示。
- en: Objective Complete – Mini Debriefing
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 简短总结
- en: You have reached a major milestone in your GUI programming effort.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你在GUI编程工作中已经达到了一个重要的里程碑。
- en: You now know all the 21 core widgets of Tkinter. You can identify them by their
    class names, and you can create them on a root frame or on a subframe within the
    root. You now know how to configure options of widgets.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经了解了Tkinter的所有21个核心部件。你可以通过它们的类名来识别它们，你可以在根框架或根框架内的子框架中创建它们。你现在知道如何配置部件的选项。
- en: With this you have now seen the first and the most important building block
    of a Tkinter program. You have mastered Tkinter widgets.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，你现在已经看到了Tkinter程序的第一块也是最重要的构建块。你已经掌握了Tkinter部件。
- en: Classified Intel
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分类情报
- en: 'Widget options can be set at instantiation time as we have done in the examples
    so far. Alternatively, the options can be configured after instantiation using
    the following syntax:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们迄今为止的示例一样，部件选项可以在实例化时设置。或者，可以使用以下语法在实例化后配置选项：
- en: '[PRE15]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is a very handy tool that lets you change widget options dynamically after
    the widget has been created. We will be using this very often in all our projects.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常实用的工具，它允许你在创建部件后动态地更改部件选项。我们将在所有项目中非常频繁地使用它。
- en: For common widget configuration options, refer to the *Options common to widgets*
    section in [Appendix B](apb.html "Appendix B. Quick Reference Sheets"), *Quick
    Reference Sheets*.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于常见的部件配置选项，请参阅[附录B](apb.html "附录 B. 快速参考表")中的*部件的通用选项*部分，*快速参考表*。
- en: Geometry management
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 几何管理
- en: Having seen all the core Tkinter widgets, let us now turn our attention to the
    second component of GUI programming—the question of where to place those widgets.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了所有核心Tkinter部件之后，现在让我们将注意力转向GUI编程的第二个组成部分——放置这些部件的问题。
- en: This is taken care of by the geometry manager options of Tkinter. This component
    of GUI programming involves deciding the position of the widget, overall layout,
    and relative placement of various widgets on the screen.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由Tkinter的几何管理器选项处理的。GUI编程的这部分涉及决定部件的位置、整体布局以及各种部件在屏幕上的相对位置。
- en: Prepare for Lift Off
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备起飞
- en: Recall that we used the `pack()` method for adding widgets to the dummy application
    we developed in the previous section. `pack()` is an example of geometry management
    in Tkinter.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们使用了`pack()`方法来向上一节中开发的虚拟应用程序添加部件。`pack()`是Tkinter中几何管理的一个例子。
- en: '`pack()` is not the only way you can manage the geometry in your interface.
    In fact, there are three geometry managers in Tkinter that let you specify the
    position of widgets inside a Toplevel or parent window.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`pack()`不是管理界面几何形状的唯一方法。事实上，Tkinter中有三个几何管理器允许你指定Toplevel或父窗口内部件的位置。'
- en: 'The geometry managers are as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 几何管理器如下：
- en: '`pack`: This is the one we have used so far. Simple to use for simpler layouts
    but may get very complex for slightly complex layouts.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pack`：这是我们迄今为止使用过的。对于简单的布局来说很简单，但对于稍微复杂的布局可能会变得非常复杂。'
- en: '`grid`: This is the most commonly used geometry manager that provides a table-like
    layout of management features for easy layout management.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grid`：这是最常用的几何管理器，它提供了一种类似于表格的布局管理功能，便于布局管理。'
- en: '`place`: This is least popular, but provides the best control for absolute
    positioning of widgets.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`place`：这是最不受欢迎的，但提供了对部件绝对定位的最佳控制。'
- en: Engage Thrusters
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: Let us now see examples of all three geometry managers in action.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看所有三种几何管理器在实际操作中的例子。
- en: The pack geometry manager
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`pack`几何管理器'
- en: The `pack` geometry derives its name from the fact that it literally packs widgets
    on a first-come-first-serve basis in the space available in the master frame in
    which widgets are pushed.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`pack`几何管理器的名称来源于它实际上是在主框架中按先来先服务的原则将部件打包到可用的空间中。'
- en: 'The `pack` geometry manager fits "slave widgets" into "parent spaces". When
    packing the slave widgets, the `pack` manager distinguishes between three kinds
    of spaces:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`pack`几何管理器将“从属部件”放入“父空间”。在打包从属部件时，`pack`管理器区分三种空间：'
- en: The unclaimed space
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未声明的空间
- en: The claimed but unused space
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声称但未使用的空间
- en: The claimed and used space
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声称和使用的空间
- en: 'The most commonly used options in `pack()` include:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pack()`中最常用的选项包括：
- en: '`side`: `LEFT`, `TOP`, `RIGHT`, and `BOTTOM` (these decide the alignment of
    the widget)'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`side`: `LEFT`, `TOP`, `RIGHT`, 和 `BOTTOM`（这些决定了小部件的对齐方式）'
- en: '`fill`: `X`, `Y`, `BOTH`, and `NONE` (these decide whether the widget can grow
    in size)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fill`: `X`，`Y`，`BOTH`，和 `NONE`（这些决定了小部件是否可以增长尺寸）'
- en: '`expand` :`1`/`0` or `Yes`/`No` (corresponding to values respectively)'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expand` :`1`/`0` 或 `Yes`/`No`（对应于相应的值）'
- en: '`anchor`: `NW`, `N`, `NE`, `E`, `SE`, `S`, `SW`, `W`, and `CENTER` (corresponding
    to the cardinal directions)'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`anchor`: `NW`, `N`, `NE`, `E`, `SE`, `S`, `SW`, `W`, 和 `CENTER`（对应于基本方向）'
- en: Internal padding (`ipadx` and `ipady`) and external padding (`padx` and `pady`),
    which all defaulted to a value of zero
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部填充（`ipadx`和`ipady`）和外部填充（`padx`和`pady`），它们都默认为0值
- en: 'Let''s take a look at some demo code that illustrates some of the `pack` features.
    Here''s the code snippet (code `1.04.py`) that generates a GUI like the following
    screenshot:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些演示代码，这些代码说明了`pack`的一些功能。以下是一个代码片段（代码`1.04.py`），它生成一个类似于以下屏幕截图的GUI：
- en: '![The pack geometry manager](img/7941_01_04.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![pack几何管理器](img/7941_01_04.jpg)'
- en: '[PRE16]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The description of the code is listed as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下所示：
- en: When you insert button **A** in the `root` frame, it captures the left-most
    area of the frame, it expands, and fills the *Y* dimension. Because expand and
    fill options are specified in affirmative, it claims all the area it wants and
    fills the *Y* dimension. If you increase the size of the root window pulling it
    down, you will notice that the button **A** expands in the downward direction
    (along the *Y* coordinate) but a side-wise increase in the window does not result
    in a horizontal increase in the size of button **A**.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你在`root`框架中插入按钮**A**时，它捕获框架的最左侧区域，它扩展并填充了*Y*维度。因为扩展和填充选项被指定为肯定，它声称它想要的全部区域并填充了*Y*维度。如果你通过向下拖动根窗口来增加其大小，你会注意到按钮**A**在向下方向（沿着*Y*坐标）扩展，但窗口的侧向增加并不会导致按钮**A**的横向尺寸增加。
- en: When you insert the next button, **B**, into the root window, it picks up space
    from the remaining area but aligns itself to `TOP`, expand-fills the available
    area, and fills both *X* and *Y* coordinates of the available space.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你在根窗口中插入下一个按钮**B**时，它会从剩余区域中获取空间，但将其自身对齐到`TOP`，扩展填充可用区域，并填充可用空间的*X*和*Y*坐标。
- en: The third button, **C**, adjusts to the right-hand side of the remaining space.
    But because fill is specified as `NONE`, it takes up only that much space as is
    required to accommodate the text inside the button. If you expand the root window,
    the button **C** will not change its size.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个按钮**C**调整到剩余空间的右侧。但由于填充被指定为`NONE`，它只占用容纳按钮内文本所需的空间。如果你扩展根窗口，按钮**C**的大小不会改变。
- en: 'The `anchor` attribute used in some lines provides a means to position a widget
    relative to a reference point. If the `anchor` attribute is not specified, the
    `pack` manager places the widget in the center of the available space or the **packing
    box**. Other allowed options include the four cardinal directions (`N`, `S`, `E`,
    and `W`) and a combination of any two directions. Therefore, valid values for
    the `anchor` attribute are: `CENTER` (default), `N`, `S`, `E`, `W`, `NW`, `NE`,
    `SW`, and `SE`.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些行中使用的`anchor`属性提供了一种将小部件相对于参考点定位的方法。如果没有指定`anchor`属性，`pack`管理器将小部件放置在可用空间或**填充框**的中心。其他允许的选项包括四个基本方向（`N`，`S`，`E`和`W`）以及任意两个方向的组合。因此，`anchor`属性的合法值包括：`CENTER`（默认），`N`，`S`，`E`，`W`，`NW`，`NE`，`SW`和`SE`。
- en: The description for the rest of the lines is left as an exercise for you to
    explore. The best way to study this piece of code would be to comment out all
    lines of code and introduce each successive button one after another. At each
    step, try to resize the window to see the effect it has on various buttons.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 其余行的描述留给你作为练习去探索。研究这段代码的最佳方式是注释掉所有代码行，然后逐个引入每个连续的按钮。在每一步，尝试调整窗口大小以查看它对各种按钮的影响。
- en: '![The pack geometry manager](img/7941_01_05.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![pack几何管理器](img/7941_01_05.jpg)'
- en: We will use the `pack` geometry manager in some of our projects, so it would
    be a worthwhile exercise to get acquainted with `pack` and its options.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的项目中使用`pack`几何管理器，因此熟悉`pack`及其选项将是一项值得做的练习。
- en: Note
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the value for most of the Tkinter geometry manager attributes can
    either be specified in capital letters without quotes (like `side=TOP`, `anchor=SE`)
    or in small letters but within quotes (like `side='top'`, `anchor='se'`).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，大多数Tkinter几何管理器属性的值可以是大写字母（无需引号，如`side=TOP`，`anchor=SE`）或小写字母（但需在引号内，如`side='top'`，`anchor='se'`）。
- en: For a complete `pack` manager reference refer to the *The pack manager* section
    in [Appendix B](apb.html "Appendix B. Quick Reference Sheets"), *Quick Reference
    Sheets*.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取完整的`pack`管理器参考，请参阅[附录B](apb.html "附录 B. 快速参考表")中的*《pack管理器》*部分，*快速参考表*。
- en: Tip
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Where should you use the pack() geometry manager?**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**你应该在哪里使用`pack()`几何管理器？**'
- en: 'Using the `pack` manager is somewhat complicated compared to the `grid` method
    that we will discuss next, but it is a great choice in situations such as:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们接下来要讨论的`grid`方法相比，使用`pack`管理器稍微复杂一些，但在以下情况下它是一个很好的选择：
- en: Having a widget fill the complete container frame
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使小部件填充完整的容器框架
- en: Placing several widgets on top of each other or in a side by side position (as
    in the previous screenshot). See code `1.05.py`.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多个小部件堆叠或并排放置（如前一个屏幕截图所示）。请参阅代码`1.05.py`。
- en: While you can create complicated layouts by nesting widgets in multiple frames,
    you can find the `grid` geometry manager more suitable for most of the complex
    layouts.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以通过在多个框架中嵌套小部件来创建复杂的布局，但您会发现`grid`几何管理器更适合大多数复杂布局。
- en: The grid geometry manager
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网格几何管理器
- en: The `grid` geometry manager is most easy to understand and, perhaps, the most
    useful geometry manager in Tkinter. The central idea of the `grid` geometry manager
    is to divide the container frame into a two-dimensional table divided into a number
    of rows and columns. Each cell in the table can then be targeted to hold a widget.
    In this context, a **cell** is an intersection of imaginary rows and columns.
    Note that in the `grid` method, each cell can hold only one widget. However, widgets
    can be made to span multiple cells.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`grid`几何管理器是最容易理解，也许也是Tkinter中最有用的几何管理器。`grid`几何管理器的核心思想是将容器框架划分为一个二维表格，该表格由多个行和列组成。然后，表中的每个单元格都可以用来放置小部件。在这种情况下，**单元格**是虚拟行和列的交点。请注意，在`grid`方法中，每个单元格只能放置一个小部件。然而，小部件可以被设置为跨越多个单元格。'
- en: Within each cell you can further align the position of the widget using the
    `STICKY` option. The `sticky` option decides how the widget is expanded, if its
    container cell is larger than the size of the widget it contains. The `sticky`
    option can be specified using one or more of the `N`, `S`, `E`, and `W`, or `NW`,
    `NE`, `SW`, and `SE` options.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个单元格内，您可以使用`STICKY`选项进一步对齐小部件的位置。`sticky`选项决定了当其容器单元格大于包含的小部件大小时，小部件如何扩展。`sticky`选项可以使用一个或多个`N`、`S`、`E`和`W`，或`NW`、`NE`、`SW`和`SE`选项来指定。
- en: Not specifying stickiness defaults to stickiness to the center of the widget
    in the cell.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 未指定粘性则默认为将小部件粘附在单元格中心。
- en: 'Let us now see a demo code that illustrates some of the features of the `grid`
    geometry manager. The code in `1.06.py` generates a GUI-like figure as shown:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个演示代码，它展示了`grid`几何管理器的一些功能。`1.06.py`中的代码生成一个类似于GUI的图形，如图所示：
- en: '![The grid geometry manager](img/7941_01_06.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![网格几何管理器](img/7941_01_06.jpg)'
- en: '[PRE17]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The description of the code is listed as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: Take a look at the grid position defined in terms of rows and column positions
    for an imaginary grid table spanning the entire frame. See how the use of `sticky=W`
    on both labels makes them stick to the west or left-hand side, resulting in a
    clean layout.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看在表示整个框架的虚拟网格表中按行和列位置定义的网格位置。看看`sticky=W`在两个标签上的使用如何使它们粘附在西部或左侧，从而实现整洁的布局。
- en: The width of each column (or height of each row) is automatically decided by
    the height or width of the widgets contained in the cell. Therefore, you need
    not worry about specifying the row or column width as equal. You may specify the
    width for widgets, if you need that extra bit of control.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每列的宽度（或每行的长度）自动由单元格中包含的小部件的高度或宽度决定。因此，您无需担心指定行或列的宽度相等。如果您需要额外的控制，可以指定小部件的宽度。
- en: You can use the argument `sticky=N+S+E+W` to make the widget expandable to fill
    the entire cell of the grid.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用参数`sticky=N+S+E+W`使小部件可扩展以填充整个网格单元格。
- en: In a more complex scenario, your widgets may span across multiple cells in the
    grid. To enable a grid to span multiple cells, the `grid` method offers very handy
    options such as `rowspan` and `columnspan`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在更复杂的场景中，您的部件可能跨越网格中的多个单元格。为了使网格跨越多个单元格，`grid`方法提供了非常方便的选项，如`rowspan`和`columnspan`。
- en: Furthermore, you may often need to provide some padding between cells in the
    grid. The `grid` manager provides `padx` and `pady` options to provide padding
    to place around the widget in a cell.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可能经常需要在网格单元格之间提供一些填充。`grid`管理器提供了`padx`和`pady`选项，以在单元格中为部件提供填充。
- en: Similarly, there are `ipadx` and `ipady` options for internal padding. The default
    value of external and internal padding is `0`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，还有`ipadx`和`ipady`选项用于内部填充。外部和内部填充的默认值是`0`。
- en: Let us see an example of the `grid` manager, where we use most of the common
    arguments to the `grid` method such as `row`, `column`, `padx`, `pady`, `rowspan`,
    and `columnspan` in action.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`grid`管理器的例子，其中我们使用了`grid`方法的大部分常见参数，如`row`、`column`、`padx`、`pady`、`rowspan`和`columnspan`的实际应用。
- en: 'The code `1.08.py` is a demonstration of `grid()` geometry manager options:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`1.08.py`代码是`grid()`几何管理器选项的演示：'
- en: '[PRE18]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Notice how just 14 lines of core `grid` manager code generates a complex layout
    such as the one shown in the following screenshot. In contrast, developing this
    with the `pack` manager would have been much more tedious:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，仅仅14行核心`grid`管理器代码就能生成如以下截图所示的复杂布局。相比之下，使用`pack`管理器开发将会更加繁琐：
- en: '![The grid geometry manager](img/7941_01_07.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![网格几何管理器](img/7941_01_07.jpg)'
- en: Another `grid` option that you can sometimes use is the `widget.grid_forget()`
    method. This method can be used to hide the widget from the screen. When you use
    this option, the widget exists in its place but becomes invisible. The hidden
    widget may be made visible again but any `grid` options that you had originally
    assigned to the widget will be lost.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个您有时可以使用的`grid`选项是`widget.grid_forget()`方法。此方法可以用来从屏幕上隐藏部件。当您使用此选项时，部件仍然存在于其位置，但变得不可见。隐藏的部件可以再次变得可见，但您最初分配给部件的任何`grid`选项都将丢失。
- en: Similarly, there is a `widget.grid_remove()` method that removes the widget,
    except that in this case when you make the widget visible again, all its `grid`
    options will be restored.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，还有一个`widget.grid_remove()`方法可以移除部件，但在这个情况下，当您再次使部件可见时，所有其`grid`选项都将被恢复。
- en: For a complete `grid()` reference, refer to the the *The grid manager* section
    in [Appendix B](apb.html "Appendix B. Quick Reference Sheets"), *Quick Reference
    Sheets*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 对于完整的`grid()`参考，请参阅[附录B](apb.html "附录 B. 快速参考表")中的*“网格管理器”*部分，*快速参考表*。
- en: Tip
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Where should you use the grid() geometry manager?**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**您应该在何处使用`grid()`几何管理器？**'
- en: The `grid` manager is a great tool for developing complex layouts. Complex structures
    can be easily achieved by breaking the container widget into grids of rows and
    columns and then placing the widgets in grids where they are wanted.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`grid`管理器是开发复杂布局的强大工具。通过将容器部件分解成行和列的网格，然后将部件放置在所需的网格中，可以轻松实现复杂结构。'
- en: It is also commonly used in developing different kinds of dialog boxes.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 它也常用于开发不同类型的对话框。
- en: Now we will delve into configuring grid column and row sizes.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将深入了解配置网格列和行的尺寸。
- en: Different widgets have different heights and widths. So when you specify the
    position of a widget in terms of rows and columns, the cell automatically expands
    to accommodate the widget.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的部件有不同的高度和宽度。因此，当您以行和列的术语指定部件的位置时，单元格会自动扩展以容纳部件。
- en: Normally the height of all grid rows is automatically adjusted to be the height
    of its tallest cell. Similarly, the width of all grid columns is adjusted to be
    equal to the width of the widest widget cell.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，所有网格行的自动调整高度以适应其最高的单元格。同样，所有网格列的宽度会调整到最宽部件单元格的宽度。
- en: If you then want a smaller widget to fill a larger cell or to stay at any one
    side of the cell, you use the `sticky` attribute on the widget to control that.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要一个更小的部件填充更大的单元格或保持在单元格的任何一边，您可以使用部件上的`sticky`属性来控制这一点。
- en: 'You can, however, override this automatic sizing of columns and rows using
    the following code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可以使用以下代码来覆盖列和行的自动尺寸：
- en: '[PRE19]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Use these to configure the options for a given widget, `w`, in the column, `n`,
    specifying values for the options, `minsize`, `pad`, and `weight`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些选项来配置给定的小部件`w`在列`n`中的选项，指定`minsize`、`pad`和`weight`的值。
- en: 'The options available here are as mentioned in the following table:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可用的选项如以下表格中所述：
- en: '| Options | Description |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 描述 |'
- en: '| --- | --- |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `minsize` | The minimum size of column or row in pixels. If there is no widget
    in the given column or row, the cell does not appear despite this `minsize` specification.
    |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `minsize` | 列或行的最小像素大小。如果给定列或行中没有小部件，则即使有此 `minsize` 指定，单元格也不会出现。|'
- en: '| `pad` | External padding in pixels that will be added to the specified column
    or row over the size of largest cell. |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `pad` | 在指定列或行的大小之外，添加到最大单元格大小的像素外部填充。|'
- en: '| `weight` | This specifies the relative weight of the row or column, then
    distributes the extra space. This enables making the row or column stretchable.For
    example, the following code distributes two-fifths of the extra space to the first
    column and three-fifths to the second column:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '| `weight` | 这指定了行或列的相对权重，然后分配额外的空间。这允许使行或列可伸缩。例如，以下代码将五分之二的额外空间分配给第一列，将五分之三分配给第二列：'
- en: '[PRE20]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '|'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The `columnconfigure()` and `rowconfigure()` methods are often used to implement
    dynamic resizing of widgets, especially on resizing the root window.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`columnconfigure()` 和 `rowconfigure()` 方法通常用于实现小部件的动态调整大小，尤其是在调整根窗口时。'
- en: Note
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You cannot use `grid` and `pack` methods together in the same container window.
    If you try doing that, your program will enter into an infinite negotiation loop.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能在同一个容器窗口中使用 `grid` 和 `pack` 方法。如果你尝试这样做，你的程序将进入无限协商循环。
- en: The place geometry manager
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`place` 几何管理器'
- en: The `place` geometry manager is the most rarely used geometry manager in Tkinter.
    Nevertheless, it has its uses in that it lets you precisely position widgets within
    its parent frame using the *X*-*Y* coordinate system.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`place` 几何管理器是 Tkinter 中最不常用的几何管理器。尽管如此，它在某些情况下有其用途，因为它允许你使用 *X*-*Y* 坐标系精确地在父框架内定位小部件。'
- en: The `place` manager can be assessed using the `place()` method on all standard
    widgets.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `place()` 方法对所有标准小部件进行 `place` 管理器的评估。
- en: 'The important options for `place` geometry include:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`place` 几何管理器的重要选项包括：'
- en: Absolute positioning (specified in terms of `x=N` or `y=N`)
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绝对定位（以 `x=N` 或 `y=N` 的形式指定）
- en: Relative positioning (key options include `relx`, `rely`, `relwidth`, and `relheight`)
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相对定位（关键选项包括 `relx`、`rely`、`relwidth` 和 `relheight`）
- en: 'Other options commonly used with `place()` include `width` and `anchor` (the
    default is `NW`). Refer to the code in `1.09.py` for a demonstration of the common
    `place` option:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `place()` 常一起使用的其他选项包括 `width` 和 `anchor`（默认为 `NW`）。请参考 `1.09.py` 中的代码以演示常见的
    `place` 选项：
- en: '[PRE21]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You may not see much of a difference between absolute and relative positions
    simply by looking at the code or the window frame. If, however, you try resizing
    the window, you will notice that the button placed absolutely does not change
    its coordinates, while the relative button changes its coordinates and size to
    fit the new size of the root window.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过查看代码或窗口框架，你可能看不到绝对位置和相对位置之间太大的区别。然而，如果你尝试调整窗口大小，你会注意到绝对定位的按钮不会改变其坐标，而相对定位的按钮会改变其坐标和大小以适应根窗口的新大小。
- en: '![The place geometry manager](img/7941_01_08.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![The place geometry manager](img/7941_01_08.jpg)'
- en: For a complete `place()` reference, check out the *The place manager* section
    in [Appendix B](apb.html "Appendix B. Quick Reference Sheets"), *Quick Reference
    Sheets*.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 对于完整的 `place()` 参考，请查看 [附录 B](apb.html "附录 B. 快速参考表") 中的 *`place` 管理器* 部分，*快速参考表*。
- en: Tip
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**When should you use the place manager?**'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**你应该在什么情况下使用 `place` 管理器？**'
- en: The `place` manager is useful in situations where you have to implement the
    custom geometry managers where the widget placement is decided by the end user.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要实现自定义几何管理器且小部件位置由最终用户决定的情况下，`place` 管理器非常有用。
- en: While `pack()` and `grid()` managers cannot be used together in the same frame,
    the `place()` manager can be used with any other geometry manager within the same
    container frame.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `pack()` 和 `grid()` 管理器不能在同一个框架中一起使用，但 `place()` 管理器可以与同一容器框架内的任何其他几何管理器一起使用。
- en: The `place` manager is rarely used. This is because if you use it you have to
    worry about the exact coordinates. If say you make a minor change for one widget,
    it is very likely that you will have to change the *X*-*Y* values for other widgets
    as well, which can be very cumbersome.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`place` 管理器很少被使用。这是因为如果你使用它，你必须担心确切的坐标。比如说，如果你对一个小部件进行了一些小的修改，那么你很可能还需要更改其他小部件的
    *X*-*Y* 值，这可能会非常繁琐。'
- en: We will not use the `place` manager in our projects. However, knowing that options
    for coordinate-based placement exist can be helpful in certain situations.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在我们的项目中使用`place`管理器。然而，了解基于坐标定位的选项存在可以在某些情况下有所帮助。
- en: Objective Complete – Mini Debriefing
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 – 简短总结
- en: This concludes our discussion on geometry management in Tkinter.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对Tkinter中几何管理的讨论。
- en: In this section you implemented examples of `pack`, `grid`, and `place` geometry
    managers. You also understood the strength and weaknesses of each geometry manager.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你实现了`pack`、`grid`和`place`几何管理器的示例。你还了解了每个几何管理器的优点和缺点。
- en: You learned that `pack` is best for a simple side-wise or top-down widget placement.
    You also saw that the `grid` manager is best suited for handling complex layouts.
    You saw examples of the `place` geometry manager and the reasons why it is rarely
    used.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你了解到`pack`最适合简单的侧向或自上而下的小部件定位。你还看到`grid`管理器最适合处理复杂布局。你看到了`place`几何管理器的示例以及为什么它很少使用的原因。
- en: You should now be in a position to plan and execute different layouts for your
    programs using these geometry managers of Tkinter.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够使用Tkinter的这些几何管理器来规划和执行你程序的不同布局。
- en: Events and callbacks – adding life to programs
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件和回调——为程序注入活力
- en: Now that we have learned how to add widgets to our screen and how to position
    them where we want, let's turn our attention to the third component of GUI programming.
    This addresses the question of how to make the widgets functional.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何将小部件添加到屏幕上以及如何将它们定位在我们想要的位置，让我们将注意力转向GUI编程的第三个组成部分。这解决了如何使小部件具有功能的问题。
- en: Making the widgets functional involves making them responsive to events such
    as the pressing of buttons, the pressing keys on keyboards, mouse clicks, and
    the like. This requires associating callbacks to specific events.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 使小部件具有功能涉及使它们对按钮按下、键盘上的按键、鼠标点击等事件做出响应。这需要将回调函数与特定事件关联起来。
- en: Engage Thrusters
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: Callbacks are normally associated with specific widget events using the `command`
    binding the rules, which is elaborated on in the following section.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 回调通常与特定的小部件事件相关联，使用`command`绑定规则，这将在下一节中详细说明。
- en: Command binding
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令绑定
- en: The simplest way to add functionality to a button is called `command` binding,
    whereby the callback function is mentioned in the form of `command = some_callback`
    in the widget option.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 向按钮添加功能的最简单方法称为`command`绑定，其中回调函数以`command = some_callback`的形式在小部件选项中提及。
- en: 'Take a look at the following sample code:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的示例代码：
- en: '[PRE22]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that `my_callback` is called without parentheses `()` from within the widget
    `command` option. This is because when the callback functions are set, it is necessary
    to pass a reference to a function rather than actually calling it.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`my_callback`是在小部件的`command`选项中不带括号`()`调用的。这是因为当回调函数被设置时，必须传递一个函数的引用而不是实际调用它。
- en: Passing arguments to the callback
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向回调传递参数
- en: 'If the callback does not take any argument, it can be handled with a simple
    function like the one we just used. However, if the callback needs to take some
    arguments, we can use the `lambda` function as shown in the following code snippet:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果回调函数不接受任何参数，它可以像我们刚才使用的那样用简单的函数处理。然而，如果回调函数需要接受一些参数，我们可以使用下面的代码片段中展示的`lambda`函数：
- en: '[PRE23]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Python borrows syntax from a functional program called the `lambda` function.
    The `lambda` function lets you define a single-line, nameless function on the
    fly.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Python从名为`lambda`的功能性程序中借用语法。`lambda`函数允许你动态定义一个单行、无名的函数。
- en: 'The format for using `lambda` is `lambda arg: #do something with arg in a single
    line`, for instance:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '使用`lambda`的格式是`lambda arg: #do something with arg in a single line`，例如：'
- en: '[PRE24]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that the `command` option available with the Button widget is really
    an alternative function to ease programming the Button event. Many other widgets
    do not provide any equivalent `command` binding option.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与按钮小部件一起提供的`command`选项实际上是一个替代函数，用于简化按钮事件的编程。许多其他小部件不提供任何等效的`command`绑定选项。
- en: The command button binds by default to the left mouse click and the Space bar.
    It does not bind to the Return key. Therefore, if you bind a button using the
    `command` function, it will react to the Space bar and not the Return key. This
    is counter-intuitive to many Windows users. What's worse is you cannot change
    this binding of the `command` function. The moral is that `command` binding, though
    a very handy tool, does not provide you the the independence to decide your own
    bindings.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，命令按钮绑定到左键点击和空格键。它不会绑定到回车键。因此，如果你使用 `command` 函数绑定按钮，它将响应空格键而不是回车键。这对许多Windows用户来说可能不太直观。更糟糕的是，你不能改变
    `command` 函数的这个绑定。教训是，尽管 `command` 绑定是一个非常方便的工具，但它并不提供让你自己决定绑定的独立性。
- en: Event binding
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件绑定
- en: 'Fortunately, Tkinter provides an alternative form of event binding mechanism
    called `bind()` to let you deal with different events. The standard syntax for
    binding an event is as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Tkinter 提供了一种名为 `bind()` 的替代事件绑定机制，让你可以处理不同的事件。绑定事件的常规语法如下：
- en: '[PRE25]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When an event corresponding to the event description occurs in the widget, it
    calls the associated handle passing an instance of the event object as the argument,
    with the event details.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当与事件描述相对应的事件在控件中发生时，它会调用相关处理程序，并将事件对象的实例及其详细信息作为参数传递。
- en: 'Let us look at an example of the `bind()` method (refer to the code file `1.10.py`):'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `bind()` 方法的示例（参考代码文件 `1.10.py`）：
- en: '[PRE26]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The description of the code is listed as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: We bind the Frame widget to the event, `<Button-1>`, which corresponds to left-click
    of the mouse. On the occurrence of this event, it calls the function `mycallback`,
    passing along an object instance as its argument.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将 Frame 小部件绑定到事件 `<Button-1>`，这对应于鼠标的左键点击。当这个事件发生时，它会调用函数 `mycallback`，并将一个对象实例作为其参数传递。
- en: We define the function `mycallback(event)`. Notice that it takes the event object
    generated by the event as the argument.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义了函数 `mycallback(event)`。注意，它将事件对象作为参数。
- en: 'We inspect the event object using `dir(event)`, which returns a sorted list
    of attribute names for the event object passed to it. This prints the list:'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `dir(event)` 来检查事件对象，它返回传递给它的事件对象的属性名称的排序列表。这会打印出列表：
- en: '`[''__doc__'', ''__module__'', ''char'', ''delta'', ''height'', ''keycode'',
    ''keysym'', ''keysym_num'', ''num'', ''send_event'', ''serial'', ''state'', ''time'',
    ''type'', ''widget'', ''width'', ''x'', ''x_root'', ''y'', ''y_root'']`.'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[''__doc__'', ''__module__'', ''char'', ''delta'', ''height'', ''keycode'',
    ''keysym'', ''keysym_num'', ''num'', ''send_event'', ''serial'', ''state'', ''time'',
    ''type'', ''widget'', ''width'', ''x'', ''x_root'', ''y'', ''y_root'']`。'
- en: Out of the attributes list generated by the object, we use two attributes, `event.x`
    and `event.y`, to print the coordinates of the point of click.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从对象生成的属性列表中，我们使用了两个属性，`event.x` 和 `event.y`，来打印点击点的坐标。
- en: 'When you run this code, it produces a window like the one shown. When you left-click
    anywhere in the frame, it outputs messages to the console. A sample message passed
    to the console is as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行此代码时，它会生成一个类似于图中所示的窗口。当你在此框架的任何地方左键点击时，它会向控制台输出消息。传递给控制台的一个示例消息如下：
- en: '![Event binding](img/7941_01_09.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![事件绑定](img/7941_01_09.jpg)'
- en: '[PRE27]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Event pattern
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件模式
- en: In the previous example, you saw how we used the event `<Button-1>` to denote
    the left-click of a mouse. This is a built-in pattern in Tkinter that maps it
    to the mouse's left-click event. Tkinter has an exhaustive mapping scheme that
    exactly identifies events such as this one.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，你看到了我们如何使用事件 `<Button-1>` 来表示鼠标的左键点击。这是 Tkinter 中的一个内置模式，将其映射到鼠标的左键点击事件。Tkinter
    有一个详尽的映射方案，可以精确地识别此类事件。
- en: 'Here are some examples to give you an idea of event patterns:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些示例，以给你一个关于事件模式的概念：
- en: '| Event pattern | Associated Event |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| 事件模式 | 关联事件 |'
- en: '| --- | --- |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `<Button-1>` | Left-click of the mouse button |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `<Button-1>` | 鼠标左键点击 |'
- en: '| `<KeyPress-B>` | Keyboard press of the key *B* |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| `<KeyPress-B>` | 按键 *B* 的键盘按下 |'
- en: '| `<Alt-Control-KeyPress- KP_Delete>` | Keyboard press of *Alt* + *Ctrl* +
    *Delete* |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| `<Alt-Control-KeyPress- KP_Delete>` | 按下 *Alt* + *Ctrl* + *Delete* 的键盘 |'
- en: 'In general, the mapping pattern takes the following form:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，映射模式具有以下形式：
- en: '[PRE28]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Typically an event pattern will comprise of:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，事件模式将包括：
- en: '**An event type** (required): Some common event types include `Button`, `ButtonRelease`,
    `KeyRelease`, `Keypress`, `FocusIn`, `FocusOut`, `Leave` (mouse leaves the widget),
    and `MouseWheel`. For a complete list of event types, refer to the *The event
    types* section in [Appendix B](apb.html "Appendix B. Quick Reference Sheets"),
    *Quick Reference Sheets*.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件类型**（必需）：一些常见的事件类型包括`Button`、`ButtonRelease`、`KeyRelease`、`Keypress`、`FocusIn`、`FocusOut`、`Leave`（鼠标离开小部件）和`MouseWheel`。对于事件类型的完整列表，请参阅[附录B](apb.html
    "附录 B. 快速参考表")中的*事件类型*部分，*快速参考表*。'
- en: '**An event modifier** (optional): Some common event modifiers include `Alt`,
    `Any` (used like in `<Any-KeyPress>`), `Control`, `Double` (used like in `<Double-Button-1>`
    to denote a double-click of the left mouse button), `Lock`, and `Shift`. For a
    complete list of event modifiers, refer to the *The event modifiers* section in
    [Appendix B](apb.html "Appendix B. Quick Reference Sheets"), *Quick Reference
    Sheets*.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件修饰符**（可选）：一些常见的事件修饰符包括`Alt`、`Any`（如 `<Any-KeyPress>` 中使用）、`Control`、`Double`（如
    `<Double-Button-1>` 表示左鼠标按钮的双击）、`Lock`和`Shift`。对于事件修饰符的完整列表，请参阅[附录B](apb.html
    "附录 B. 快速参考表")中的*事件修饰符*部分，*快速参考表*。'
- en: '**The event detail** (optional): The mouse event detail is captured by number
    `1` for a left-click and number `2` for a right-click. Similarly, each keyboard
    keypress is either represented by the key letter itself (say *B* in `<KeyPress-B>`)
    or using a key symbol abbreviated as **keysym**. For example, the up arrow key
    on the keyboard is represented by the `keysym` value of `KP_Up`. For a complete
    `keysym` mapping, refer to the *The event details* section in [Appendix B](apb.html
    "Appendix B. Quick Reference Sheets"), *Quick Reference Sheets*.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件细节**（可选）：鼠标事件细节通过数字`1`表示左键点击，数字`2`表示右键点击。同样，每个键盘按键通过键字母本身（例如 `<KeyPress-B>`
    中的 *B*）或使用缩写为**keysym**的键符号来表示。例如，键盘上的上箭头键由`keysym`值`KP_Up`表示。对于完整的`keysym`映射，请参阅[附录B](apb.html
    "附录 B. 快速参考表")中的*事件细节*部分，*快速参考表*。'
- en: '![Event pattern](img/7941_01_10.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![事件模式](img/7941_01_10.jpg)'
- en: 'Let''s take a look at a practical example of the `event` binding on widgets.
    (See the code in `1.11.py` for the complete working example). The following is
    a modified snippet of code to give you a flavor of the commonly used the `event`
    bindings:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个关于小部件上`event`绑定的实际例子。（完整的示例代码请参考`1.11.py`）。以下是对常用`event`绑定的代码片段的修改，以供参考：
- en: '[PRE29]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Rather than binding an event to a particular widget, you can also bind it to
    the Toplevel window. The syntax remains the same except that now you call it on
    the root instance of the root window like `root.bind()`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是将事件绑定到特定的小部件，你也可以将其绑定到Toplevel窗口。语法保持不变，但现在你需要在根窗口的根实例上调用它，如`root.bind()`。
- en: Levels of binding
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绑定级别
- en: In the previous section, you saw how to bind an event to an instance of a widget.
    This can be called **instance level binding**.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你看到了如何将事件绑定到小部件的实例。这可以称为**实例级绑定**。
- en: 'However, there might be times when you need to bind events to the entire application.
    At other times you may want to bind the event to a particular class of widget.
    Tkinter provides different levels of binding options for this:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时你可能需要将事件绑定到整个应用程序。在其他时候，你可能希望将事件绑定到特定类的小部件。Tkinter为此提供了不同级别的绑定选项：
- en: '**An application-level binding**: Application-level bindings will let you use
    the same binding across all windows and widgets of the application, as long as
    any one window of the application is in focus.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用级绑定**：应用级绑定将允许你在应用程序的所有窗口和控件中使用相同的绑定，只要应用程序中的任何一个窗口处于焦点状态。'
- en: 'The syntax for application-level bindings is:'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应用级绑定的语法如下：
- en: '[PRE30]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The typical usage pattern is as follows:'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 典型的使用模式如下：
- en: '[PRE31]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: An application-level binding here means that no matter what widget is under
    the current focus, a press of the *F1* key will always trigger the `show_help`
    callback as long as the application is under active focus.
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，应用级绑定意味着无论当前焦点下的哪个小部件被选中，只要应用程序处于活动焦点状态，按下*F1*键总是会触发`show_help`回调函数。
- en: '**A class-level binding**: You can also bind events at a particular class level.
    This is normally used to set the same behavior of all instances of a particular
    widget class.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类级绑定**：你还可以在特定类级别绑定事件。这通常用于设置特定小部件类的所有实例的相同行为。'
- en: 'This syntax for class level binding is as follows:'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类级绑定的语法如下：
- en: '[PRE32]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The typical usage pattern is as follows:'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 典型的使用模式如下：
- en: '[PRE33]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding example, all entry widgets will be bound to the `<Control-V>`
    event that would call a method called `'paste (event)'`.
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的示例中，所有输入小部件都将绑定到 `<Control-V>` 事件，该事件将调用名为 `'paste (event)'` 的方法。
- en: Note
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Event propagation**'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件传播**'
- en: Most of the keyboard events and mouse events occur at the operating system level.
    It propagates from the source of the event, hierarchically up, until it finds
    a window that has a corresponding binding. The event propagation does not stop
    there. It propagates itself upwards looking for other bindings from other widgets
    until it reaches the root window. If it does reach the root window and no bindings
    are discovered by it, the event is disregarded.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数键盘事件和鼠标事件在操作系统级别发生。它从事件源向上级联，直到找到一个具有相应绑定的事件窗口。事件传播不会在这里停止。它会向上传播，寻找其他小部件的其他绑定，直到达到根窗口。如果它达到了根窗口并且没有发现绑定，则该事件将被忽略。
- en: Handling widget-specific variables
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理特定小部件的变量
- en: You need variables with a wide variety of widgets. You likely need a string
    variable to track what the user enters into the entry widget or text widget. You
    most probably need Boolean variables to track whether the user has checked the
    Checkbox widget. You need integer variables to track the value entered in a Spinbox
    or Slider widget.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要与各种小部件一起使用变量。你可能需要一个字符串变量来跟踪用户输入到输入小部件或文本小部件中的内容。你很可能需要一个布尔变量来跟踪用户是否选中了复选框小部件。你需要整数变量来跟踪在
    Spinbox 或滑块小部件中输入的值。
- en: In order to respond to changes in widget-specific variables, Tkinter offers
    its own variable class. The variable that you use to track widget-specific values
    must be subclassed from this Tkinter variable class. Tkinter offers some commonly
    used predefined variables. They are `StringVar`, `IntVar`, `BooleanVar`, and `DoubleVar`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 为了响应特定小部件变量的变化，Tkinter 提供了自己的变量类。你用来跟踪特定小部件值的变量必须从这个 Tkinter 变量类中派生。Tkinter
    提供了一些常用的预定义变量。它们是 `StringVar`、`IntVar`、`BooleanVar` 和 `DoubleVar`。
- en: You can use these variables to capture and play with changes in the value of
    variables from within your callback functions. You can also define your own variable
    type, if required.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些变量在回调函数内部捕获和操作变量值的更改。如果需要，你也可以定义自己的变量类型。
- en: 'Creating a Tkinter variable is simple. You simply call the required constructor:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 Tkinter 变量很简单。你只需调用所需的构造函数：
- en: '[PRE34]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Once the variable is created, you can use it as a widget option, as follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 变量创建后，你可以将其用作小部件选项，如下所示：
- en: '[PRE35]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Additionally, Tkinter provides access to the value of variables using `set()`
    and `get()` methods:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Tkinter 通过 `set()` 和 `get()` 方法提供对变量值的访问：
- en: '[PRE36]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'A demonstration of the Tkinter variable class is available in the code file
    `1.12.py`. The code generates a window like the following screenshot:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter 变量类的演示可以在代码文件 `1.12.py` 中找到。该代码生成一个类似于以下截图的窗口：
- en: '![Handling widget-specific variables](img/7941_01_11.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![处理特定小部件的变量](img/7941_01_11.jpg)'
- en: Objective Complete – Mini Debriefing
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 简短回顾
- en: 'In this lesson, you learned:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你学习了：
- en: The `command` binding to bind simple widgets to certain functions
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将简单小部件绑定到特定函数的 `command` 绑定
- en: Use of the `lambda` function, if you need to process arguments
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `lambda` 函数，如果你需要处理参数
- en: The `event` binding using the `widget.bind(event, callback)` method to bind
    keyboard and mouse events to your widgets and to invoke callbacks on the occurrence
    of some events
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `widget.bind(event, callback)` 方法绑定键盘和鼠标事件到你的小部件，并在某些事件发生时调用回调函数
- en: How to pass extra arguments to a callback
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何向回调传递额外的参数
- en: How to bind events to an entire application or to a particular class of widget
    using `bind_all()` and `bind_class()`
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 `bind_all()` 和 `bind_class()` 将事件绑定到整个应用程序或特定类的小部件
- en: How to use the Tkinter variable class to set and get values of widget specific
    variables
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Tkinter 变量类设置和获取特定小部件变量的值
- en: In short you now know how to make your GUI program functional!
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，你现在知道如何让你的 GUI 程序变得功能齐全！
- en: Classified Intel
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分类英特尔
- en: 'In addition to the `bind` method we previously saw, you might find these two
    event-related options useful in certain cases:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们之前看到的 `bind` 方法之外，你可能会在某些情况下发现这两个与事件相关的选项很有用：
- en: '`unbind`: Tkinter provides the `unbind` options to undo the effect of an earlier
    binding. The syntax is as follows:'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unbind`：Tkinter 提供了 `unbind` 选项来撤销之前绑定的效果。语法如下：'
- en: '[PRE37]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following are some examples of its usage:'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是一些使用示例：
- en: '[PRE38]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '**Virtual events**: Tkinter also lets you create your own events. You can give
    these virtual events any name you want.'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚拟事件**：Tkinter还允许你创建自己的事件。你可以给这些虚拟事件起任何你想要的名字。'
- en: 'For example, imagine you want to create a new event called `<<commit>>`, which
    is triggered by the *F9* key. To create this virtual event on a given widget,
    use the syntax:'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，假设你想创建一个名为`<<commit>>`的新事件，该事件由*F9*键触发。要在给定的小部件上创建这个虚拟事件，请使用以下语法：
- en: '[PRE39]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can then bind `<<commit>>` to any callback using a normal `bind()` method
    like:'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，你可以使用正常的`bind()`方法将`<<commit>>`绑定到任何回调函数上：
- en: '[PRE40]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Other event-related methods are listed in the *Other event-related methods*
    section in [Appendix B](apb.html "Appendix B. Quick Reference Sheets"), *Quick
    Reference Sheets*.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 其他与事件相关的方法列在[附录B](apb.html "附录 B. 快速参考表")的*其他与事件相关的方法*部分，*快速参考表*。
- en: Now that you are ready to dive into real application development with Tkinter,
    let's spend some time exploring a few custom styling options that Tkinter offers.
    We will also see some of the configuration options commonly used with the root
    window.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好使用Tkinter进行实际的应用程序开发，让我们花些时间探索Tkinter提供的几个自定义样式选项。我们还将查看一些与根窗口一起常用的配置选项。
- en: Doing it in style
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做得有风格
- en: So far, we have have relied on Tkinter to provide specific platform-based styling
    for our widgets. However, you can specify your own styling of widgets in terms
    of their color, font size, border width, and relief. A brief introduction of styling
    features available in Tkinter is covered in the following task.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直依赖Tkinter为我们的小部件提供特定平台的基础样式。然而，你可以根据自己的需求指定小部件的样式，包括颜色、字体大小、边框宽度和浮雕效果。Tkinter中可用的样式功能将在以下任务中进行简要介绍。
- en: Prepare for Lift Off
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备起飞
- en: 'Recall that we could specify widget options at the time of its instantiation
    as shown:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们可以在小部件实例化时指定小部件选项，如下所示：
- en: '[PRE41]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Alternatively, you could specify widget options using `configure ()`:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以使用`configure()`函数来指定小部件选项：
- en: '[PRE42]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Styling options are also specified as options to the widgets, either at the
    time of instantiation or later using the configure option.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 样式选项也可以作为小部件的选项指定，无论是在实例化时还是在之后使用configure选项。
- en: Engage Thrusters
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: Under the purview of styling, we will cover how to apply different colors, fonts,
    border width, relief, cursor, and bitmap icons to our widgets. We will also look
    at some of the root configurations later in the section.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在样式的范畴内，我们将介绍如何将不同的颜色、字体、边框宽度、浮雕效果、光标和位图图标应用到我们的小部件上。我们还将在本节稍后查看一些根配置。
- en: 'Let''s first see how to specify color options for a widget. You can specify
    two types of color for most of the widgets:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看如何指定小部件的颜色选项。对于大多数小部件，你可以指定两种类型的颜色：
- en: Background color
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 背景颜色
- en: Foreground color
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前景颜色
- en: You can specify the color using hexadecimal color codes using the proportion
    of red, green, and blue. Commonly used representations are `#rgb` (4 bits), `#rrggbb`
    (8 bits), and `#rrrgggbbb` (12 bits).
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用红色、绿色和蓝色的比例使用十六进制颜色代码来指定颜色。常用的表示方式有`#rgb`（4位）、`#rrggbb`（8位）和`#rrrgggbbb`（12位）。
- en: For example, `#fff` is white, `#000000` is black, and `#fff000000` is red.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`#fff`是白色，`#000000`是黑色，`#fff000000`是红色。
- en: Alternatively, Tkinter provides mapping for standard color names. For a list
    of predefined colors, open the program titled `pynche` in the `Tools` folder within
    your Python installation directory (in my case, `C:\Python27\Tools\pynche`). Within
    the program click on **View** | **Color list Window**.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，Tkinter提供了标准颜色名称的映射。要查看预定义的颜色列表，请打开Python安装目录（在我的情况下，是`C:\Python27\Tools\pynche`）中的`Tools`文件夹内的名为`pynche`的程序。在程序中点击**查看**
    | **颜色列表窗口**。
- en: 'Next, the easiest and the most common way to specify a font is to represent
    it as a tuple. The standard representation is as follows:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，指定字体最简单和最常见的方式是将它表示为一个元组。标准的表示方式如下：
- en: '[PRE43]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here are some examples to illustrate the method for specifying fonts:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些示例，用于说明指定字体的方法：
- en: '[PRE44]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note
  id: totrans-397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you set a Tkinter dimension in a plain integer, the measurements takes place
    in units of pixel. Alternatively, Tkinter accepts four other measurement units
    which are: m (millimeters), c (centimeters), i (inches), and p (printer''s points,
    which is about 1/72").'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将Tkinter的尺寸设置为纯整数，则测量单位为像素。或者，Tkinter接受四种其他测量单位：m（毫米）、c（厘米）、i（英寸）和p（打印点，大约是1/72"）。
- en: 'The default border width for most Tkinter widgets is 2 pixels. You can change
    the border width of the widgets by specifying it explicitly, as shown in the following
    line:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Tkinter 小部件的默认边框宽度为 2 像素。您可以通过明确指定来更改小部件的边框宽度，如下所示：
- en: '[PRE45]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The relief style of a widget refers to the difference between the highest and
    lowest elevations in a widget. Tkinter offers five possible relief styles: `flat`,
    `raised`, `sunken`, `groove`, and `ridge`.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件的浮雕样式指的是小部件中最高和最低海拔之间的差异。Tkinter 提供了五种可能的浮雕样式：`flat`、`raised`、`sunken`、`groove`
    和 `ridge`。
- en: '[PRE46]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Tkinter lets you change the style of mouse cursor when you hover over a particular
    widget. This is done using the option cursor as in the following example:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter 允许您在悬停在特定小部件上时更改鼠标光标的样式。这可以通过使用选项光标来完成，如下例所示：
- en: '[PRE47]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: For a complete list of available cursors, refer to the *List of available cursors*
    section in [Appendix B](apb.html "Appendix B. Quick Reference Sheets"), *Quick
    Reference Sheets*.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可用光标的完整列表，请参阅 [附录 B](apb.html "附录 B. 快速参考表") 中的 *可用光标列表* 部分，*快速参考表*。
- en: 'While you can specify styling options at each widget level, sometimes it may
    be cumbersome to do so individually for each widget. Widget-specific styling has
    several disadvantages:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以在每个小部件级别指定样式选项，但有时为每个小部件单独这样做可能会很繁琐。特定小部件的样式有几个缺点：
- en: It mixes logic and presentation into one file making the code bulky and difficult
    to manage
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将逻辑和展示混合在一个文件中，使得代码庞大且难以管理
- en: Any change in styling is to be applied to each widget individually
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何样式上的更改都应应用于每个小部件单独
- en: It violates the **don't repeat yourself** (**DRY**) principle of effective coding
    as you keep specifying the same style for a large number of widgets
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于您为大量小部件指定相同的样式，这违反了有效编码的 **不要重复自己**（**DRY**）原则
- en: Fortunately, Tkinter now offers a way to separate presentation from the logic
    and to specify styles in what is called the external "option database". This is
    nothing but a text file where you can specify the common styling options.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Tkinter 现在提供了一种将展示与逻辑分离并指定称为外部“选项数据库”中的样式的方法。这仅仅是一个文本文件，您可以在其中指定通用样式选项。
- en: 'A typical option database text file may look like the following:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的选项数据库文本文件可能看起来如下：
- en: '[PRE48]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The asterisk (`*`) symbol here means that the particular style applies to all
    instances of the given widget.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的星号 (`*`) 符号表示特定的样式适用于给定小部件的所有实例。
- en: 'These entries are placed in an external text `(.txt)` file. To apply this styling
    to a particular piece of code, you simply call it using the `option_readfile()`
    call early in your code, as shown here:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这些条目放置在外部文本 `(.txt)` 文件中。要将此样式应用于特定的代码片段，您只需在代码早期使用 `option_readfile()` 调用即可，如下所示：
- en: '[PRE49]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now that we are done discussing styling options, let us wrap up with a discussion
    on some commonly used options for the root window:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了样式选项，让我们以一些常用的根窗口选项的讨论来结束：
- en: '| Method | Description |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE50]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '| Specifying the title for the Title bar |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '| 指定标题栏的标题 |'
- en: '|'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE51]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '| You can specify the size and location of a root window using a string of
    the form `widthxheight` + `xoffset` + `yoffset` |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '| 您可以使用 `widthxheight` + `xoffset` + `yoffset` 形式的字符串来指定根窗口的大小和位置 |'
- en: '|'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE52]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: or
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE53]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '| Changing the Title bar icon to something different from the default Tk icon
    |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '| 将标题栏图标更改为与默认 Tk 图标不同的图标 |'
- en: '|'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE54]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '| Removing the root border frame |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '| 移除根边框框架 |'
- en: 'Now let''s take a look at an example where we apply all the styling options
    and root window options as discussed previously (see the code `01.13.py`):'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看一个例子，其中我们应用了之前讨论的所有样式选项和根窗口选项（参见代码 `01.13.py`）：
- en: '[PRE55]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The description of the preceding code is listed as follows:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的描述如下：
- en: The first segment of code uses some important root methods to define the geometry,
    title of the program, icon for the program, and method to remove the border of
    the root window.
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码的第一部分使用一些重要的根方法来定义几何形状、程序标题、程序图标以及移除根窗口边框的方法。
- en: The code then connects to an external styling file called `optionDB.txt` that
    defines common styling for the widgets.
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码随后连接到一个名为 `optionDB.txt` 的外部样式文件，该文件定义了小部件的通用样式。
- en: The next segment of code creates a Text widget and specifies styling on the
    widget level.
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一部分代码创建了一个 Text 小部件，并在小部件级别指定了样式。
- en: The next segment of code has several buttons, all of which derive their styling
    from the centralized `optionDb.txt` file. One of the buttons also defines a custom
    cursor.
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一段代码有几个按钮，所有这些按钮的风格都源自集中的`optionDb.txt`文件。其中一个按钮还定义了一个自定义光标。
- en: The last segment of code styles some buttons using built-in bitmap images.
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码的最后一段使用内置的位图图像样式了一些按钮。
- en: 'Running this program would produce a window like the following screenshot:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个程序会产生如下截图所示的窗口：
- en: '![Engage Thrusters](img/7941_01_12.jpg)'
  id: totrans-442
  prefs: []
  type: TYPE_IMG
  zh: '![启动推进器](img/7941_01_12.jpg)'
- en: Objective Complete – Mini Debriefing
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 简短总结
- en: In this task, we explored how to use styling options to modify the default styling
    of Tkinter. We saw how to specify custom colors, fonts, reliefs, and cursors for
    our GUI programs. We also saw how to separate styling from the logic using the
    option database. Finally, we explored some of the common options for configuring
    our root window.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们探讨了如何使用样式选项来修改Tkinter的默认样式。我们看到了如何为我们的GUI程序指定自定义颜色、字体、浮雕效果和光标。我们还看到了如何使用选项数据库将样式与逻辑分离。最后，我们探索了一些配置我们的根窗口的常见选项。
- en: Mission Accomplished
  id: totrans-445
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务完成
- en: 'This brings us to end of [Project 1](ch01.html "Chapter 1. Meet Tkinter"),
    *Meet Tkinter*. This project aimed to provide a high-level overview of Tkinter.
    We have worked our way through all the important concepts that drive a Tkinter
    program. We now know:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们到达了[项目1](ch01.html "第1章。认识Tkinter")，“认识Tkinter”的结尾。该项目旨在提供一个Tkinter的高级概述。我们已经逐步了解了驱动Tkinter程序的所有重要概念。现在我们知道了：
- en: What a root window is and how to set it up
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根窗口是什么以及如何设置它
- en: What the 21 core Tkinter widgets are and how to set them up
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 21个核心Tkinter小部件是什么以及如何设置它们
- en: How to layout our programs using `pack`, `grid`, and `place` geometry managers
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`pack`、`grid`和`place`布局管理器来布局我们的程序
- en: How to make our programs functional using events and callbacks
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用事件和回调使我们的程序功能化
- en: How to apply custom styles to our GUI programs
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将自定义样式应用到我们的GUI程序中
- en: To summarize, we can now start thinking of making interesting, functional, and
    stylish GUI programs with Tkinter!
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们现在可以开始考虑使用Tkinter制作有趣、功能性强且风格独特的GUI程序了！
- en: A Hotshot Challenge
  id: totrans-453
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 热身挑战
- en: Time for your first Hotshot challenge! Your task is to build a simple calculator
    (or if you are ambitious, a scientific calculator). It should be fully functional
    and should have custom-styled buttons and a screen. Try to make it look as close
    to real physical calculators as you can.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候接受你的第一个Hotshot挑战了！你的任务是构建一个简单的计算器（如果你有雄心，可以是一个科学计算器）。它应该是完全功能性的，并且应该有自定义样式的按钮和屏幕。尽量让它看起来尽可能接近真实的物理计算器。
- en: When you are done, we invite you to search in your computer for complex GUI
    programs. These can range from your operating system programs such as the search
    bar, to some simple dialog-based widgets. Try to replicate any chosen GUIs using
    Tkinter.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成时，我们邀请你搜索你电脑上的复杂GUI程序。这些可以从你的操作系统程序，如搜索栏，到一些基于简单对话框的小部件。尝试使用Tkinter复制任何选定的GUI。
