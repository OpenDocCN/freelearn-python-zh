- en: Web Framework for Automation Triggers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于自动化触发的 Web 框架
- en: 'As we move on and get better at understanding the coding techniques and Python,
    the next step is to ensure that scripts are executed without the end users actually
    running the code locally, and ensure a platform or OS independent approach in
    code execution. This chapter focuses on putting our scripts on a web platform.
    We will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续前进并提高对编码技术和 Python 的理解，下一步是确保脚本在没有最终用户实际在本地运行代码的情况下执行，并确保代码执行的平台或操作系统独立的方法。本章重点是将我们的脚本放在
    Web 平台上。我们将涵盖以下主题：
- en: Creating a web accessible script with examples
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可访问 Web 的脚本示例
- en: Accessing the script from HTML/dynamic HTML
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 HTML/动态 HTML 访问脚本
- en: Understanding and configuring the environment for the web framework using IIS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 IIS 理解和配置 Web 框架的环境
- en: The basics of APIs and creating a sample API using C#
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 的基本原理以及使用 C# 创建示例 API
- en: Using the API in Python
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Python 中使用 API
- en: Creating a task to understand the full end-to-end functionality of a web framework
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建任务以理解 Web 框架的完整端到端功能
- en: Why create web-based scripts/frameworks?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么创建基于 Web 的脚本/框架？
- en: A **web framework** is a collection of scripts, hosted on a web platform such
    as **Internet Information Services** (**IIS**) (on Windows) or Apache (on Linux),
    and calling the same script using front-end web-based languages such as HTML.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**Web 框架** 是一组脚本集合，托管在 Web 平台（如 **Internet Information Services**（IIS）**（在
    Windows 上）或 Apache（在 Linux 上））上，并使用前端基于 Web 的语言（如 HTML）调用相同的脚本。'
- en: There are times when people ask why we want to migrate our current scripts or
    create scripts on a web framework. The answer is very simple. A web framework
    ensures that our scripts are used by multiple end users using just the browser.
    This gives the programmer the independence to code the script on their preferred
    platform (such as Windows or Linux), and people can use the scripts on their choice
    of browser. They don't need to understand how you have written the code, or what
    you are calling or using in the back-end, and of course, this ensures that you
    prevent your code from being directly visible to end users.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候人们会问为什么我们要迁移我们当前的脚本或创建 Web 框架上的脚本。答案非常简单。Web 框架确保我们的脚本仅通过浏览器就能被多个最终用户使用。这给了程序员在他们的首选平台（如
    Windows 或 Linux）上编写脚本的独立性，人们可以在他们选择的浏览器上使用这些脚本。他们不需要理解你如何编写代码，或者你在后端调用或使用什么，当然，这也确保了你的代码不会被最终用户直接看到。
- en: Let's say  you have written a script that calls four or five libraries for specific
    tasks. There are general libraries, but as we have seen in previous chapters,
    some specific libraries need to be installed for the tasks. In this case, if you
    want to ensure that end users can execute your script, they need to install the
    same libraries on their machines. Also, they need to be running a Python environment
    on their machines, without which the scripts would not run. So, to run a small
    script of let's say five lines, users need to customize their environment by installing
    Python, installing libraries, and so on.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经编写了一个调用四个或五个库以执行特定任务的脚本。虽然有一些通用库，但正如我们在前面的章节中看到的，某些特定库需要安装以执行这些任务。在这种情况下，如果你想确保最终用户能够执行你的脚本，他们需要在他们的机器上安装相同的库。此外，他们需要在他们的机器上运行
    Python 环境，没有这个环境脚本将无法运行。因此，为了运行一个五行的简单脚本，用户需要通过安装 Python、安装库等方式来定制他们的环境。
- en: This might not be feasible for a lot of users because of restrictions on their
    machines (such as installation not being allowed), so even though there is a requirement
    to run the scripts for those users, they would be unable to use the scripts, which
    would effectively lower efficiency. But the same users, if given the option, could
    easily open the browser of their choice and use those scripts like opening any
    other web page, which would ensure that our scripts bring greater efficiency to
    the tasks.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于机器上的限制（例如不允许安装），这可能对许多用户来说并不可行，因此尽管有运行这些脚本的需求，但用户将无法使用这些脚本，这实际上会降低效率。但是，如果给这些用户提供选择，他们可以轻松地打开他们选择的浏览器并像打开任何其他网页一样使用这些脚本，这将确保我们的脚本为任务带来更高的效率。
- en: Understanding and configuring IIS for web framework
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解和配置 IIS 以用于 Web 框架
- en: Here we are going to focus on what IIS is and how to configure it, to ensure
    our Python scripts are executed by harnessing the power of a web server framework.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将关注 IIS 是什么以及如何配置它，以确保我们的 Python 脚本能够通过利用 Web 服务器框架的力量来执行。
- en: Understanding IIS
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 IIS
- en: IIS is a tool available on Windows that is used to host web services. In other
    words, if we install IIS we ensure that the machine on which it is installed is
    now acting as a web server. IIS is a fully functional program that is available
    from Add or Remove Programs in Windows. It supports the machine becoming a web
    server, an FTP server, and other things as well.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: IIS 是 Windows 上可用的一个工具，用于托管网络服务。换句话说，如果我们安装了 IIS，我们确保安装了它的机器现在正在充当网络服务器。IIS
    是一个完全功能的程序，可在 Windows 的“添加或删除程序”中找到。它支持机器成为网络服务器、FTP 服务器以及其他一些功能。
- en: 'The following screenshot shows the first screen that appears after IIS is installed
    and opened using the IIS icon in Windows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在 Windows 中使用 IIS 图标安装并打开 IIS 后出现的第一个屏幕：
- en: '![](img/833bb345-30ef-4b22-9066-4bad30036fb0.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/833bb345-30ef-4b22-9066-4bad30036fb0.jpg)'
- en: As we can see in the screenshot, the left side of the application indicates
    the server name, and the right side shows the properties that we can configure
    for different purposes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如截图所示，应用程序的左侧表示服务器名称，右侧显示我们可以为不同目的配置的属性。
- en: It is important to select **Common Gateway Interface** (**CGI**) support when
    installing IIS from the Windows Add or Remove Programs. After selecting IIS, Windows
    gives us the option to select specific sub-items in IIS, from which CGI and CGI
    support is an option. If this option is not selected during installation, the
    Python scripts will fail to run from the web server.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装 IIS 时选择 **通用网关接口**（**CGI**）支持是很重要的。在 Windows 的“添加或删除程序”中安装 IIS 后，Windows
    会给我们选择 IIS 中特定子项的选项，其中 CGI 和 CGI 支持是一个选项。如果在安装过程中没有选择此选项，Python 脚本将无法从网络服务器上运行。
- en: Configuring IIS for Python script support
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 IIS 以支持 Python 脚本
- en: 'Now, let us configure IIS to ensure it supports execution of Python scripts
    on the web server itself, and allows end users to directly run Python scripts
    by calling the web URLs from the web server. The following are the steps to do
    this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们配置 IIS，以确保它支持在 Web 服务器本身上执行 Python 脚本，并允许最终用户通过从 Web 服务器调用 Web URL 来直接运行
    Python 脚本。以下是要执行此操作的步骤：
- en: 'As we expand the properties on the left, we see the Default Web Site option.
    If you right-click on this, there is a section called Add Application. Click on
    it to see the following screenshot:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们展开左侧的属性时，我们看到默认网站选项。如果你右键单击它，有一个名为添加应用程序的章节。点击它以查看以下截图：
- en: '![](img/a632887a-93aa-431a-a134-863091026f53.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a632887a-93aa-431a-a134-863091026f53.jpg)'
- en: 'In this screen, we have to enter two specific values:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个屏幕上，我们必须输入两个特定的值：
- en: 'Alias: This is a value that is part of our web URL. For example, `http://<servername>/test`
    will be the URL if our selected Alias is `test`.'
  id: totrans-26
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 别名：这是我们 Web URL 的一部分值。例如，如果我们的选择别名是 `test`，则 `http://<servername>/test` 将是 URL。
- en: 'Physical Path:This is the the actual physical directory mapping on which our
    scripts will reside. For example, our script, `testscript.py`, has the following
    path. To call it from the URL we will type the following in our browser:'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理路径：这是我们脚本实际物理目录映射的位置。例如，我们的脚本 `testscript.py` 的路径如下。要从 URL 调用它，我们将在浏览器中输入以下内容：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once we have these values, we click on OK and our website reference is created.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这些值，我们点击“确定”，我们的网站引用就创建完成了。
- en: 'Now we need to map our Python scripts to use the Python interpreter while being
    executed. Once we create the website, we see an option called Handler Mappings
    in the right panel. Click on it and open the section as shown in the following
    screenshot. To add the Python reference, click on `Add Script Map...` as shown
    on the right-hand side of the screenshot:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要将我们的 Python 脚本映射到在执行时使用 Python 解释器。一旦我们创建了网站，我们会在右侧面板看到一个名为处理器映射（Handler
    Mappings）的选项。点击它并打开如下截图所示的章节。要添加 Python 引用，请点击截图右侧的“添加脚本映射...”：
- en: '![](img/9732acee-d630-4921-a62b-951693957c23.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9732acee-d630-4921-a62b-951693957c23.jpg)'
- en: 'In this section, we fill in three values:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个部分，我们需要填写三个值：
- en: Request path: This is always `*.py`, because any script we call will have the
    extension `.py`.
  id: totrans-33
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求路径：这始终是 `*.py`，因为我们调用的任何脚本都将具有 `.py` 扩展名。
- en: 'Executable: This is an important section where we reference the actual location
    of `python.exe`. The full path of `python.exe` is needed. In addition to the path,
    we need to add `%s`twice after the executable file path, because this is interpreted
    to take arguments passed from IIS. For example, if our path to Python is `C:\Python`,
    then we would add the following:'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可执行文件：这是一个重要的部分，其中我们引用了`python.exe`的实际位置。需要`python.exe`的完整路径。除了路径之外，我们还需要在可执行文件路径后添加两次`%s`，因为这被解释为从IIS传递的参数。例如，如果我们的Python路径是`C:\Python`，那么我们会添加以下内容：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Name:This is simple reference name for the current settings that we have configured.
    It can be any name of your choice.
  id: totrans-36
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称：这是对当前配置的简单引用名称。可以是任何你喜欢的名称。
- en: 'There is a button called Request Restrictions inside the Add Script Map section.
    We need to click on that button, and under Access, select the Execute option and
    click OK:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“添加脚本映射”部分中有一个名为“请求限制”的按钮。我们需要点击该按钮，然后在“访问”下选择“执行”选项并点击确定：
- en: '![](img/8d339304-5b45-41b0-a4ec-16f5ca543352.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8d339304-5b45-41b0-a4ec-16f5ca543352.jpg)'
- en: 'Once we click OK, a prompt comes from IIS to allow the extension. We need to
    select Yes for the settings to be effective:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们点击确定，IIS会弹出一个提示，允许扩展。我们需要选择是，以便设置生效：
- en: '![](img/d5069e66-3b7c-40bc-baae-90772fb95514.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d5069e66-3b7c-40bc-baae-90772fb95514.jpg)'
- en: 'As the final step, we select the newly created script map (`Python` in our
    case) and click on Edit Feature Permissions... on the right-hand side. In the
    dialog box, select the Execute option and click OK:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一步，我们选择新创建的脚本映射（在我们的例子中是`Python`），然后在右侧点击“编辑功能权限...”。在对话框中，选择“执行”选项并点击确定：
- en: '![](img/1761816f-aec0-48b2-aaa9-716a39051761.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1761816f-aec0-48b2-aaa9-716a39051761.jpg)'
- en: Once all of the preceding steps are followed, we have a running environment
    that supports the execution of Python scripts from a web browser.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦遵循所有前面的步骤，我们就有一个运行环境，支持从Web浏览器执行Python脚本。
- en: Once the web server is running, you can test to ensure that it is configured
    correctly by invoking the default page on the web server itself. This is done
    using the `http://localhost` URL from the browser, which should show the Welcome
    IIS page. If this does not show up, then we need to go back and validate the web
    server installation because it means that web server is not up and running.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Web服务器启动，你可以通过在Web服务器本身调用默认页面来测试以确保其配置正确。这可以通过浏览器中的`http://localhost` URL来完成，它应该显示欢迎IIS页面。如果它没有显示出来，那么我们需要回到并验证Web服务器的安装，因为这意味着Web服务器没有启动和运行。
- en: Creating web-specific scripts
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建特定于Web的脚本
- en: 'Now that we have a running environment that''s ready to run our scripts, let''s
    create a very basic script to take a look at how it works:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个运行环境，可以运行我们的脚本，让我们创建一个非常基本的脚本来看看它是如何工作的：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: On IDLE, we type the preceding code and save it as a Python file (such as `testscript.py`).
    Now, as we discussed earlier, for our web reference we mapped a physical directory
    or location in IIS. The newly created `testscript.py` needs to be in that folder
    to be accessible from the web.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在IDLE中，我们输入前面的代码并将其保存为Python文件（例如`testscript.py`）。现在，正如我们之前讨论的，对于我们的Web引用，我们在IIS中映射了一个物理目录或位置。新创建的`testscript.py`需要在该文件夹中才能从Web访问。
- en: 'The output of the web based URL call for Python script is as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Web的URL调用Python脚本的输出如下：
- en: '![](img/b0d4ddad-b535-4b70-b4ba-3cc5f13c3347.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b0d4ddad-b535-4b70-b4ba-3cc5f13c3347.jpg)'
- en: As we can see in the preceding screenshot, the script is now called from the
    browser using the localhost URL. The output is a simple `Hello, world !` that
    was called to be printed in script code.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前述截图所示，脚本现在是通过浏览器使用localhost URL调用的。输出是一个简单的`Hello, world !`，这是在脚本代码中调用来打印的。
- en: 'Additionally, the value `Content-Type: text/plain` specifies that the return
    values from Python will be simple text that the browser will interpret as plain
    text rather than HTML.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '此外，值`Content-Type: text/plain`指定Python的返回值将是简单的文本，浏览器将其解释为纯文本而不是HTML。'
- en: 'Now let''s look at an example of modifying it to HTML:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何将其修改为HTML的示例：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output of the URL with modified values is as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 修改值后的URL输出如下：
- en: '![](img/91fbb29c-60d4-4b4e-9cfc-5a081ebbd892.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/91fbb29c-60d4-4b4e-9cfc-5a081ebbd892.jpg)'
- en: 'As we can see, the first line of the code has been modified to `Content-Type:
    text/html`**. **This ensures that the text now being returned from the script
    is HTML, and hence the last print statement, with `font color` as `red` and `world!`
    in bold html tag is being interpreted correctly in the browser. In real-life scenarios,
    if we want to print a pass, fail, or any other specific message or output from
    our scripts, we should return the values in HTML color-coded and bold formats
    so that they are clearly readable in the browser.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '如我们所见，代码的第一行已被修改为`Content-Type: text/html`**。** 这确保了现在从脚本返回的文本是HTML，因此最后的打印语句，带有`font
    color`为`red`和`world!`在粗体HTML标签中的内容，现在在浏览器中被正确解释。在现实场景中，如果我们想从我们的脚本中打印通过、失败或其他任何特定的消息或输出，我们应该以HTML颜色编码和粗体格式返回值，以便在浏览器中清晰可读。'
- en: 'Let''s see an example of printing a table of 5 in a tabular format in HTML:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在HTML中以表格格式打印5的示例：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/c73f060b-6bab-4460-8286-dcd3f5e65891.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c73f060b-6bab-4460-8286-dcd3f5e65891.jpg)'
- en: As we can see, the first line indicates the return type as HTML. In the next
    few lines, we take a variable named `value` with a value of `5`. Using a `for`
    loop, we create the HTML table and its values (for each row and cell) in a `tval` variable.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如我们所见，第一行指示返回类型为HTML。在接下来的几行中，我们使用名为`value`的变量，其值为`5`。使用`for`循环，我们在`tval`变量中创建HTML表格及其值（对于每一行和单元格）。
- en: The final statement returns the value of the `tval` variable to the browser
    where we called the script.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一条语句将`tval`变量的值返回到调用脚本的浏览器。
- en: 'Getting deeper into this example, now let''s create the same table, but the
    number needs to be provided by the web user in the URL. In other words, rather
    than sticking to the static value of `5` in our example, the table needs to be
    generated for the value that is entered by the user in the URL:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 深入这个示例，现在让我们创建相同的表格，但数字需要由Web用户在URL中提供。换句话说，而不是在我们的示例中坚持静态值`5`，表格需要为用户在URL中输入的值生成：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/eed90d41-a775-4220-8ea1-287aafa9d825.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eed90d41-a775-4220-8ea1-287aafa9d825.jpg)'
- en: As we can see in the change in the URL, we pass the number using the enhanced
    URL `http://localhost/test/testscript.py?number=8`. The value specified after
    the question mark, which is referenced as the value passed to the parameter number,
    is now taken as an input in the script. The code now imports a specific inbuilt
    library called `cgi` to read the parameters passed to itself from the browser.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如我们在URL变化中看到的那样，我们使用增强的URL `http://localhost/test/testscript.py?number=8`传递数字。问号后面的指定值，即作为传递给参数`number`的值，现在被作为脚本中的输入。代码现在导入一个特定的内置库`cgi`，以读取从浏览器传递给自身的参数。
- en: 'These are next two lines:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是这两行：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: They are used to take a reference of the form as returned from the browser,
    and from the form, the specific parameter named `number`**.** The parameter returned
    is always in string format, so we need to ensure it is converted to our specific
    datatype depending on our usage.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 它们用于获取从浏览器返回的表单的引用，并且从表单中获取名为`number`的特定参数**。** 返回的参数始终以字符串格式，因此我们需要确保将其转换为我们的特定数据类型，具体取决于我们的使用。
- en: The `value` variable now has the number that we passed from the browser, and
    the rest of the script is executed in the same manner given in previous examples.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`变量现在有了我们从浏览器传递的数字，其余的脚本以与前面示例中给出相同的方式进行执行。'
- en: As we can see in the preceding examples, the end user is now only calling the
    script with specific values based upon their needs, and is not concerned about
    the back-end logic or program. For the developer, if there is a bug identified
    in the script, the fix can be done on the main web server as soon as the end users
    start getting correct results. This also saves a lot of effort compared to users
    downloading the new fixed script from a specific location on their machines and
    then running it on their own. Sometimes, even calling the script from the browser
    with parameters becomes a bit tough. In this case, we use form tags in HTML to
    pass values to scripts to fetch outputs.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述示例所示，最终用户现在只根据他们的需求调用脚本，而不关心后端逻辑或程序。对于开发者来说，如果在脚本中发现了错误，一旦最终用户开始获得正确的结果，就可以在主Web服务器上立即修复。与用户从他们的机器上的特定位置下载新的修复脚本然后自行运行相比，这也节省了大量精力。有时，甚至从浏览器中调用带有参数的脚本也变得有点困难。在这种情况下，我们使用HTML中的表单标签将值传递给脚本以获取输出。
- en: 'For example, ask the user for their name, the number for which the table needs
    to be generated, and output the generated table in a friendly manner with the
    caller''s name in the output. Here''s the HTML code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要求用户输入他们的名字，需要生成表格的数字，并以友好的方式输出生成的表格，其中包含呼叫者的名字。以下是 HTML 代码：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here''s the Python code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Python 代码：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/1355169a-d721-4d70-a1db-54967b7c7e42.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1355169a-d721-4d70-a1db-54967b7c7e42.jpg)'
- en: HTML Page
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 页面
- en: 'Using the HTML code, we create a form that takes the input needed for our script.
    In this case, it asks for a name and the number from which the table needs to
    be generated. Once the user enters this information, the Submit button needs to
    be clicked for the values to be passed to the script:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 HTML 代码，我们创建了一个表单，该表单需要我们脚本所需的输入。在这种情况下，它要求输入一个名字和需要生成表格的数字。一旦用户输入这些信息，就需要点击提交按钮，以便将值传递到脚本中：
- en: '![](img/df0bc049-3729-4bde-a55a-e3eb6f13d59b.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/df0bc049-3729-4bde-a55a-e3eb6f13d59b.jpg)'
- en: Script Output
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本输出
- en: As the user clicks on the Submit button, the values are passed to the script.
    In the code, we get the values using the same `form.getvalue()` method for each
    of the HTML elements. Once the script has the values fetched from the browser,
    the script logic takes care of what needs to be returned. In our case, as we can
    see in the example, the username has been displayed in the browser, along with
    the table that the user wanted to see as the output.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击提交按钮时，值会被传递到脚本中。在代码中，我们使用相同的 `form.getvalue()` 方法获取每个 HTML 元素的值。一旦脚本从浏览器中获取了值，脚本逻辑就会处理需要返回的内容。在我们的例子中，正如我们所看到的，用户名已经在浏览器中显示，同时还有用户想要看到的输出表格。
- en: 'Let''s take an example in which we type in the IP address of a device and the
    command that we want to see from the device, using the form and browser output.
    Here''s the HTML code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个例子来说明，我们输入设备的 IP 地址和我们想从设备中看到的命令，使用表单和浏览器输出。以下是 HTML 代码：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this code, the only difference is that now we are calling the `getweboutput.py` script, into
    which we are sending the parameters of the device IP address (for the device from
    which we want the output), and the actual command. Here''s the Python code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，唯一的区别是我们现在正在调用 `getweboutput.py` 脚本，我们将设备 IP 地址（我们想要输出信息的设备）和实际命令作为参数发送到该脚本。以下是
    Python 代码：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The Python code is now taking the input parameter of `ipaddress` for the device
    IP, and `cmd` for the actual command that needs to be sent to the router. It again
    uses Netmiko, as in [Chapter 2](463dbdd3-1fde-4886-b582-f6de051b1440.xhtml), *Python
    for Network Engineers*, to fetch the information and return it using the `getoutput()` function:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的 Python 代码正在获取设备的 IP 地址的输入参数 `ipaddress`，以及需要发送到路由器的实际命令 `cmd`。它再次使用 Netmiko，正如在[第
    2 章](463dbdd3-1fde-4886-b582-f6de051b1440.xhtml)中提到的，*《网络工程师的 Python》*，来获取信息并使用
    `getoutput()` 函数返回信息：
- en: '**Sample 1**: **We provide the IP address and the command show clock**:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例 1**：**我们提供 IP 地址和 show clock 命令**：'
- en: '![](img/438a3e32-d3e2-454e-ab2b-841678717512.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/438a3e32-d3e2-454e-ab2b-841678717512.jpg)'
- en: Landing page
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 登录页面
- en: 'Click on the Submit button:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 点击提交按钮：
- en: '![](img/8cd167fa-51a4-47c1-a7df-532c627e2d9a.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8cd167fa-51a4-47c1-a7df-532c627e2d9a.jpg)'
- en: '**Sample 2**: **For the same script with different parameters provided**:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例 2**：**对于提供不同参数的相同脚本**：'
- en: '![](img/020a64cf-bb7e-438b-8183-c377a31907c7.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/020a64cf-bb7e-438b-8183-c377a31907c7.jpg)'
- en: Landing Page
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 登录页面
- en: 'This is the output when the Submit button is clicked:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是点击提交按钮时的输出：
- en: '![](img/104c3097-f2db-4f7e-a998-0534eb9b2a04.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/104c3097-f2db-4f7e-a998-0534eb9b2a04.jpg)'
- en: As we saw, we can create a web-based query tool to fetch information from devices
    with specified commands, which can act as a quick reference for device validations.
    Additionally, with this methodology we are also hiding our username and password
    (`cisco`:`cisco` in this case) without exposing the device credentials to end
    users. The end user is only providing inputs on the web page, and is unaware of
    the code that is being executed at the back-end, which has the device credentials.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，我们可以创建一个基于 Web 的查询工具，用于从具有指定命令的设备中获取信息，这可以作为设备验证的快速参考。此外，使用这种方法，我们还隐藏了用户名和密码（在这个例子中是
    `cisco`:`cisco`），而没有将设备凭据暴露给最终用户。最终用户只需在网页上提供输入，而不会意识到后端正在执行的代码，该代码包含设备凭据。
- en: We can even have additional checks to ensure that users can only run `show`
    commands and display appropriate messages depending on the various commands users
    will try to call on the web page.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以进行额外的检查，以确保用户只能运行`show`命令，并根据用户尝试在网页上调用的各种命令显示适当的消息。
- en: Accessing a script from dynamic HTML
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从动态HTML访问脚本
- en: There are times when we run a Python script to create dynamic HTML pages (which
    are based upon certain triggers that we put in the script). These pages can be
    enhanced to add additional URLs to invoke other scripts when we click on those
    pages.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们运行Python脚本来创建动态HTML页面（这些页面基于我们在脚本中设置的某些触发器）。这些页面可以增强，以添加额外的URL，当我们点击这些页面时，可以调用其他脚本。
- en: As an example, let's say we need to find out how many models of devices are
    in our network. For this we create a script, schedule it to run every hour with
    the task scheduler, and after each run a dynamic HTML page is created to show
    the updated stats or inventory. In a BYODscenario, this also plays an important
    role, because each hour we can monitor what devices are on our network, and if
    we click on any of the discovered devices, we can get additional information such
    as a detailed show version.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们需要找出我们网络中有多少种设备型号。为此，我们创建一个脚本，使用任务计划程序将其安排为每小时运行一次，并在每次运行后创建一个动态HTML页面来显示更新的统计数据或库存。在BYOD场景中，这也扮演着重要的角色，因为每小时我们都可以监控我们的网络上有哪些设备，如果我们点击任何发现的设备，我们可以获取额外的信息，例如详细的show版本。
- en: 'Here''s the Python code to create the dynamic HTML:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建动态HTML的Python代码：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/7bfb5a1b-c5c0-4e1b-95b5-d1431e487dc4.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7bfb5a1b-c5c0-4e1b-95b5-d1431e487dc4.jpg)'
- en: 'The preceding code creates the dynamic HTML shown in the previous screenshot.
    It queries the vendor from SNMP for the given IP addresses, and creates the table
    based upon the values. The blue color in the IP addresses denotes the hyperlink,
    which, when clicked, will result in the output as shown here:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了之前截图所示的动态HTML。它从SNMP查询给定的IP地址的供应商，并根据这些值创建表格。IP地址中的蓝色表示超链接，点击后会产生如下所示的输出：
- en: '![](img/bdbe3530-7fd8-48e2-807d-dcd480392933.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bdbe3530-7fd8-48e2-807d-dcd480392933.jpg)'
- en: 'Here''s the Python code for the output of show version:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是show版本输出的Python代码：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As we can see in the URL, when the user clicked on the main dynamic HTML page,
    it invoked another script (the one that was listed earlier) that takes the input
    parameter of the IP address from the URL and, using Netmiko, fetches the version
    of the device.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在URL中看到的，当用户点击主动态HTML页面时，它调用了另一个脚本（之前列出的那个），该脚本从URL中获取IP地址的输入参数，并使用Netmiko获取设备的版本。
- en: Similarly, we can gather other stats, such as CPU, memory, a routing summary,
    and other tasks for each of the devices quickly using the web framework approach.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用Web框架方法快速收集其他统计数据，例如CPU、内存、路由摘要以及其他每个设备的任务。
- en: Creating the backend API in C#
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C#中创建后端API
- en: As we move ahead, there are times when as a developer we not only need to consume
    APIs, but create our own APIs for others to use. Even if we find recurring usage
    of some functions, keeping in mind web framework strategy, we need to ensure that
    instead of simply creating functions for that task, we need to convert them to
    APIs. A big advantage of that is that the usage of our function or task will then
    not be limited only to Python, but it can be used in any scripting language or
    web language.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续前进，有时作为开发者，我们不仅需要消费API，还需要为他人创建自己的API。即使我们发现某些函数有重复的使用，考虑到Web框架策略，我们仍需要确保，而不是简单地创建用于该任务的函数，我们需要将它们转换为API。这样做的重大优势是，我们的函数或任务的使用将不再仅限于Python，它可以在任何脚本语言或Web语言中使用。
- en: Here we will see a very basic approach to creating a functional API to say `Hello
    World` in C#. As a prerequisite, we will need IIS to run the web services, and
    Visual Studio (Community edition is free to use) to create our own API. Later
    on, we will see how to consume that API in Python.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将看到创建一个功能性的C# `Hello World` API的非常基本的方法。作为先决条件，我们需要IIS来运行Web服务，以及Visual
    Studio（社区版免费使用）来创建我们自己的API。稍后，我们将看到如何使用Python来消费该API。
- en: Additionally, we will ensure that the return value is in the JSON format, which
    is the industry standard for API communication, replacing XML.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将确保返回值是JSON格式，这是API通信的行业标准，取代了XML。
- en: 'Invoke the C# Web project in Visual Studio:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中调用C# Web项目：
- en: '![](img/7f523e58-f1f1-4bb3-9127-e1fdc1e0a99a.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7f523e58-f1f1-4bb3-9127-e1fdc1e0a99a.jpg)'
- en: 'Select the Web API checkbox in the next screen shown as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个屏幕上选择Web API复选框，如下所示：
- en: '![](img/b1a0df4e-d93b-4eed-9c24-6cce40f0bca8.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b1a0df4e-d93b-4eed-9c24-6cce40f0bca8.jpg)'
- en: 'Add the Controller (this is the main component that will ensure the API framework
    is active):'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加控制器（这是确保API框架激活的主要组件）：
- en: '![](img/ba348a19-b854-4eca-85bc-50f0607cc120.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ba348a19-b854-4eca-85bc-50f0607cc120.jpg)'
- en: 'Give a meaningful name to the controller. Note, the name must be followed by
    the word `Controller` (example `testController`), otherwise the controller will
    not function and the API framework will be broken:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给控制器一个有意义的名称。注意，名称后面必须跟有单词`Controller`（例如`testController`），否则控制器将无法工作，API框架将损坏：
- en: '![](img/9d249e72-4e1f-4416-bf5d-a8a49cc7b1e2.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9d249e72-4e1f-4416-bf5d-a8a49cc7b1e2.jpg)'
- en: 'Once the controller is added, under the `WebApiConfig.cs` file add the new
    `JsonMediaTypeFormatter()` config, as shown in the next screenshot. This ensures
    that every output returned from the API will be in JSON format:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制器添加后，在`WebApiConfig.cs`文件中添加新的`JsonMediaTypeFormatter()`配置，如下所示。这确保了API返回的每个输出都将以JSON格式呈现：
- en: '![](img/64018700-c1fb-49d1-8962-a58fc2e0bf12.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/64018700-c1fb-49d1-8962-a58fc2e0bf12.jpg)'
- en: 'In the main `apitestController.cs` program, return the value `Hello World`
    once the `Get` method is called:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主`apitestController.cs`程序中，一旦调用`Get`方法，返回值`Hello World`：
- en: '![](img/73d860b4-94a2-4cb8-a07d-0bda4ef3d515.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/73d860b4-94a2-4cb8-a07d-0bda4ef3d515.jpg)'
- en: 'Once done, click on the `Run` button that is available in the Visual Studio
    application. A screen similar to the following screenshot will be opened, which
    ensures that the local IIS server is being invoked and the application is initialized
    for testing:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，点击Visual Studio应用程序中可用的`运行`按钮。将打开一个类似于以下屏幕截图的窗口，这确保了本地IIS服务器正在被调用，并且应用程序已初始化以进行测试：
- en: '![](img/7900d45b-f90a-44ca-8bc5-1546018e295d.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7900d45b-f90a-44ca-8bc5-1546018e295d.jpg)'
- en: 'Once the application is loaded, a URL similar to the following will confirm
    our API is working fine. Note that, at this point, the local IIS Express is being
    used and the API is still not published for external use:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦应用程序加载，将出现类似于以下URL的链接，以确认我们的API运行正常。请注意，此时正在使用本地的IIS Express，API尚未对外发布：
- en: '![](img/fa52c019-c5c0-452b-b48e-3e5e97060756.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fa52c019-c5c0-452b-b48e-3e5e97060756.jpg)'
- en: 'Once validated, now we need to publish this to our IIS. Similar to what we
    did earlier, we create a new application in IIS (named `apitest` in our case):'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证完成后，现在我们需要将此发布到我们的IIS中。类似于我们之前所做的那样，我们在IIS中创建一个新的应用程序（在我们的例子中命名为`apitest`）：
- en: '![](img/878f8386-6690-4df3-980d-ed644acd7e21.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/878f8386-6690-4df3-980d-ed644acd7e21.jpg)'
- en: 'Once the IIS mapping has been done, we use Visual Studio to publish our API
    project to this web folder:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成IIS映射，我们使用Visual Studio将我们的API项目发布到这个Web文件夹：
- en: '![](img/2a5873a4-3849-4176-a523-62b4058a119d.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2a5873a4-3849-4176-a523-62b4058a119d.jpg)'
- en: 'We create a web Publish profile, and publish it to the local folder that we
    mapped to our IIS:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个Web发布配置文件，并将其发布到我们映射到IIS的本地文件夹：
- en: '![](img/e525a06b-13ec-4923-b118-c373b2b13435.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e525a06b-13ec-4923-b118-c373b2b13435.jpg)'
- en: 'Our API is ready to be used. We can validate it by going to `http://localhost`
    on our browser:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的API已准备好使用。我们可以通过在浏览器中访问`http://localhost`来验证它：
- en: '![](img/a15ccb68-ce3f-4993-89f2-515685693803.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a15ccb68-ce3f-4993-89f2-515685693803.jpg)'
- en: Consuming the API in Python
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Python中消费API
- en: Now, as we have the API created, let us see how to consume the API in Python.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，既然我们已经创建了API，让我们看看如何在Python中消费API。
- en: 'The code is as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '[PRE13]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output for the preceding code is as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/a0dfd313-d468-4755-acb2-3f2febe8eba4.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a0dfd313-d468-4755-acb2-3f2febe8eba4.jpg)'
- en: For API interaction, we use the `requests` library in Python. When we perform
    a call to the API, the API returns the string in JSON format. The `r.json()`method
    converts the returned JSON to extract the text value and displays the output as
    `Hello World`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于API交互，我们在Python中使用`requests`库。当我们对API进行调用时，API以JSON格式返回字符串。`r.json()`方法将返回的JSON转换为提取文本值，并将输出显示为`Hello
    World`。
- en: In a similar way, we can use the requests library to fetch API results from
    various web-based API calls. The result is generally in XML or JSON format, with
    JSON being the preferred return method for the API calls.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，我们可以使用requests库从各种基于Web的API调用中获取API结果。结果通常是XML或JSON格式，其中JSON是API调用的首选返回方法。
- en: 'Let us see another example to fetch some more JSON from GitHub:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再举一个例子，从GitHub获取更多JSON数据：
- en: '[PRE14]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output for the preceding code is as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/e64ff339-7c8f-4d71-b47a-5664b533ab01.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e64ff339-7c8f-4d71-b47a-5664b533ab01.jpg)'
- en: As we now call the GitHub API, we get the JSON value as shown previously. As
    we can see, the return value is like a dictionary in the JSON return data of the
    API call, so we can explicitly get the text inside the `message` dictionary key.
    In the preceding output, the first output is the raw JSON return value, and the
    next output is the extracted text from the `message` key.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们调用GitHub API，我们得到了之前显示的JSON值。正如我们所见，返回值类似于API调用JSON返回数据中的字典，因此我们可以明确地获取`message`字典键内的文本。在前面的输出中，第一个输出是原始的JSON返回值，下一个输出是从`message`键中提取的文本。
- en: 'In addition to calling the standard APIs, there are times when we need to pass
    credentials to the API to fetch information. In other words, there needs to be
    an authentication in place for the APIs to respond with requested data. In our
    API, let us now enable basic authentication from IIS:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 除了调用标准API之外，有时我们需要将凭据传递给API以获取信息。换句话说，API需要有一个认证机制来响应请求的数据。在我们的API中，现在让我们从IIS中启用基本认证：
- en: 'In the IIS, select your website (`apitest` in our case), and under the Authentication
    section, select Basic Authentication:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在IIS中，选择你的网站（在我们的例子中是`apitest`），然后在认证部分选择基本认证：
- en: '![](img/7c4bd726-2d81-4a5d-9d5b-d2d8dea242fc.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7c4bd726-2d81-4a5d-9d5b-d2d8dea242fc.jpg)'
- en: This ensures that any request that calls this API needs to have basic authentication
    (a username and a password) to access the content. Additionally, we create a simple
    user `testuser` with a password `testpassword` in the Users application on a Windows
    machine.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了任何调用此API的请求都需要基本认证（用户名和密码）来访问内容。此外，我们在Windows机器上的用户应用程序中创建了一个简单的用户`testuser`，密码为`testpassword`。
- en: 'Since authentication is now enabled, let us see what we get if no credentials
    are passed:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于现在已启用认证，让我们看看如果没有传递凭据我们会得到什么：
- en: '[PRE15]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output for the preceding code is as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/833d1d8d-18fe-4d0a-97f1-ca48b78c6c9c.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/833d1d8d-18fe-4d0a-97f1-ca48b78c6c9c.jpg)'
- en: We get a Response [401], which means *unauthorized* access in a HTTP call. In
    other words, the API call is unauthorized and hence no output will be given back.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了一个响应[401]，这意味着HTTP调用中的*未授权*访问。换句话说，API调用未授权，因此不会返回任何输出。
- en: 'Next, we see the same call, but this time with authentication:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们看到相同的调用，但这次带有认证：
- en: '[PRE16]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output for the preceding code is as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/ad4bf86f-8630-4fc8-95ee-d600411f7982.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ad4bf86f-8630-4fc8-95ee-d600411f7982.jpg)'
- en: In this case, we call the authentication method `HTTPBasicAuth`, and pass the
    username and password in the `requests.get` call. As we have provided the correct
    credentials, we get back a Response [200], which is OK in HTTP, and in the last
    line we print the output of the returned value, which in our case is `Hello World`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们调用认证方法`HTTPBasicAuth`，并在`requests.get`调用中传递用户名和密码。因为我们提供了正确的凭据，所以我们得到了一个响应[200]，这在HTTP中是OK的，在最后一行我们打印了返回值的输出，在我们的例子中是`Hello
    World`。
- en: Sample summary task
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样本总结任务
- en: 'As we are now familiar with the web framework, let us perform a task that covers
    all the aspects that we saw earlier:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经熟悉了Web框架，让我们执行一个涵盖我们之前看到的所有方面的任务：
- en: We write a HTML page that asks for the username and password from the user.
    Those values will be passed into a Python script which will call the API that
    we created earlier to authenticate. If the return value is authorized, then we
    display the IP addresses of the devices that we want to view the additional information
    for on another web page.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们编写一个HTML页面，要求用户输入用户名和密码。这些值将被传递到一个Python脚本中，该脚本将调用我们之前创建的API进行认证。如果返回值是授权的，那么我们将显示我们想要在另一个网页上查看额外信息的设备的IP地址。
- en: 'Next, the user can click on any of the IP addresses to view the `show ip int
    brief` output. If the authorization fails, the script returns the message Not
    Authorized and will not display the IP addresses. For reference (valid set of
    username and password):'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，用户可以点击任何IP地址来查看`show ip int brief`的输出。如果授权失败，脚本将返回“未授权”的消息，并且不会显示IP地址。以下为参考（有效的用户名和密码）：
- en: '**Username**: `Abhishek`'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户名**：`Abhishek`'
- en: '**Password**: `password`'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密码**：`password`'
- en: 'HTML Code is as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: HTML代码如下：
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We have used the `POST` method in this case, since the password will be shown
    in clear text on the browser URL if we use the default `GET` method. In the `POST` method,
    there is a separate connection made at the back-end, and the URL does not show
    the values that are being passed on to the script.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用了`POST`方法，因为如果我们使用默认的`GET`方法，密码将在浏览器URL中以明文形式显示。在`POST`方法中，后端会建立单独的连接，并且URL不会显示传递给脚本的值。
- en: 'The Python code is as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Python代码如下：
- en: '[PRE18]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In case of incorrect credentials (credentials that are not valid, like dummy
    credentials) being provided:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果提供的凭证不正确（无效的凭证，如示例凭证）：
- en: '![](img/c6aacd4b-9466-440d-8345-75a2731f76c7.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c6aacd4b-9466-440d-8345-75a2731f76c7.jpg)'
- en: 'When we click on Submit button, it will display the message as shown in the
    following screenshot:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击“提交”按钮时，它将显示如下截图所示的消息：
- en: '![](img/06309a5b-bfac-4185-835b-50727c2161aa.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/06309a5b-bfac-4185-835b-50727c2161aa.jpg)'
- en: 'In case of correct credentials (that are correct and authenticated successfully
    at web server):'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果凭证正确（在Web服务器上正确且成功认证）：
- en: '![](img/2857b776-ace6-4a8f-8aad-e248b6072ecf.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2857b776-ace6-4a8f-8aad-e248b6072ecf.jpg)'
- en: 'When we click on Submit button:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击“提交”按钮：
- en: '![](img/f9568740-10fc-4180-9561-e7b39b47cfa6.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f9568740-10fc-4180-9561-e7b39b47cfa6.jpg)'
- en: 'Next, we see the IP addresses, which we can now use to get the output. We select
    the IP address that we want to use and click on Select IPaddress:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们看到IP地址，我们现在可以使用这些地址来获取输出。我们选择我们想要使用的IP地址，然后点击“选择IP地址”：
- en: '![](img/52320f4e-56fa-46ea-a102-27fd7471a40f.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/52320f4e-56fa-46ea-a102-27fd7471a40f.jpg)'
- en: 'Once we click on Submit (or the Select IPaddress button), we get the following
    output:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们点击“提交”（或“选择IP地址”按钮），我们将得到以下输出：
- en: '![](img/d96ed8d1-af13-428d-851c-490d4070b36b.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d96ed8d1-af13-428d-851c-490d4070b36b.jpg)'
- en: Again, if we look at the preceding output URL, since we used the `POST` method
    for this selection, we only see the script but not the parameters that were passed
    in the URL. This ensures that people need to go from the landing page (in our
    case, `main.html`), and cannot directly call any URL with parameters that could
    have been given if we were using the `GET` method.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，如果我们查看前面的输出URL，由于我们为这个选择使用了`POST`方法，所以我们只看到脚本，而没有看到在URL中传递的参数。这确保了人们需要从着陆页（在我们的案例中是`main.html`）开始，不能直接调用任何可能使用`GET`方法给出的带有参数的URL。
- en: By doing this, we are also ensuring that end users executing this follow a step-by-step
    selection, and are not jumping from one URL to the other without performing the
    sequential steps.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们还确保了执行此操作的最终用户遵循逐步选择，而不是在不执行顺序步骤的情况下从一个URL跳转到另一个URL。
- en: In a similar manner, end users can create their own APIs to fetch information
    such as bulk device names and IP addresses, and can use that information in their
    script to create front-end, back-end, or web-enabled scenarios quickly accessible
    from any browser without the need for any end user installations.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，最终用户可以创建他们自己的API来获取诸如大量设备名称和IP地址等信息，并可以在他们的脚本中使用这些信息来快速创建前端、后端或Web启用场景，无需任何最终用户安装。
- en: Summary
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have now understood the web framework and with relevant examples, the usage
    of APIs. This includes how to create an API, access APIs, and even work with authentication
    on APIs. Using this knowledge, we will now be able to develop web based tools
    for end users. The IIS functionality has also been introduced, which helps developers
    to customize various web-based settings such as authentications, authorizations,
    and creating websites.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经了解了Web框架，以及相关的示例，API的使用。这包括如何创建API、访问API，甚至在与API进行认证。使用这些知识，我们现在将能够为最终用户开发基于Web的工具。IIS功能也已介绍，这有助于开发者自定义各种基于Web的设置，如认证、授权和创建网站。
- en: Additionally, with a fully functional example of a given scenario, readers can
    quickly build web-based Python scripts, which remove the need for any end user
    installations of Python and customized libraries. This makes support and bug fixing
    much easier, owing to having a single machine to fix. A fix done on the server
    will ensure that all end users will now be using the fixed or enhanced functions
    of the script, rather than downloading a local copy on their machines to get the
    fixed or enhanced script.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过一个给定场景的完整功能示例，读者可以快速构建基于Web的Python脚本，这消除了对Python和定制库的任何最终用户安装的需求。由于只需在一台机器上进行修复，这使得支持和错误修复变得更加容易。在服务器上进行的修复将确保所有最终用户现在都将使用修复或增强的脚本功能，而不是在自己的机器上下载本地副本以获取修复或增强的脚本。
- en: In the next chapter, we will introduce the use of Ansible, which is a popular
    open source automation platform.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍Ansible的使用，它是一个流行的开源自动化平台。
