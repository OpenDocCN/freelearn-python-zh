- en: Chapter 9. Expanding your Toolset
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章. 扩展您的工具集
- en: This chapter is less about rendering and more about making life easier for the
    day-to-day use of Blender by extending its functionality. It uses some external
    libraries that need to be installed, and at some point the Python scripting used
    is perhaps a little bit harder to read for a novice. Also, from an artist's point
    of view, it might be a little less visually pleasing as these scripts don't lend
    themselves to pretty illustrations. Nevertheless, these scripts do add genuine
    useful functionality, especially for a script developer, so please read on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章更多地是关于如何通过扩展Blender的功能来简化日常使用，而不是渲染。它使用了一些需要安装的外部库，并且在某些时候，所使用的Python脚本可能对新手来说读起来有些困难。此外，从艺术家的角度来看，这些脚本可能视觉上不那么吸引人，因为这些脚本不适合制作精美的插图。尽管如此，这些脚本确实增加了真正的有用功能，特别是对于脚本开发者来说，所以请继续阅读。
- en: '![Expanding your Toolset](img/0400-09-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![扩展您的工具集](img/0400-09-01.jpg)'
- en: 'In this chapter, we will learn how to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何：
- en: List and archive assets such as image maps
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出并归档如图像映射等资源
- en: Publish a rendered image automatically with FTP
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用FTP自动发布渲染图像
- en: Extend the functionality of the built-in editor with regular expression searches
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正则表达式搜索扩展内置编辑器的功能
- en: Speed up computations by using Psyco—a just-in-time compiler
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Psyco即时编译器加速计算
- en: Add version control to your scripts with Subversion
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Subversion为您的脚本添加版本控制
- en: To the Web and beyond—publish a finished render with FTP
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布到网络及更远——使用FTP发布完成的渲染
- en: We can save a rendered image to any location as long as it is visible in the
    filesystem, but not all platforms offer the possibility to make a remote FTP server
    accessible via a local directory (folder). This script offers us a simple option
    to store a rendered image on a remote FTP server and remembers the server name,
    the username, and (optionally) the password for later reuse.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 只要渲染图像在文件系统中可见，我们就可以将其保存到任何位置，但并非所有平台都提供通过本地目录（文件夹）使远程FTP服务器可访问的可能性。这个脚本为我们提供了一个简单选项，可以将渲染图像存储在远程FTP服务器上，并记住服务器名称、用户名和（可选）密码，以便以后重用。
- en: The **File** **Transfer** **Protocol** (**FTP)** that we will be using is somewhat
    more complicated than, for instance, the `HTTP` protocol as it uses more than
    one connection. Fortunately for us, all the intricacies of an FTP client are nicely
    encapsulated in the standard Python module `ftplib`. We not only import this module's
    `FTP` class but a number of other standard Python modules as well, notably those
    for pathname manipulation (`os.path`) and for reading the standard `.netrc` file
    (which enables us to store passwords outside our script if we need passwords to
    log in to the FTP server). We will discuss each module where necessary.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的**文件传输协议**（FTP）比例如`HTTP`协议要复杂一些，因为它使用了多个连接。幸运的是，对于FTP客户端的所有复杂性，Python标准模块`ftplib`都很好地封装了。我们不仅导入了这个模块的`FTP`类，还导入了其他一些标准Python模块，特别是用于路径名操作的`os.path`模块和用于读取标准`.netrc`文件（这使我们能够在需要时将密码存储在脚本之外，以便登录FTP服务器）。在需要的地方，我们将讨论每个模块。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Python is almost as platform independent as it gets, but of course, sometimes
    there are intricacies that are not fully covered. For example, we want to use
    usernames and passwords stored in a `.netrc` file that is commonly used by FTP
    programs (and others) and the FTP client expects this file to reside in the user's
    home directory, which it hopes to find in an environment variable `HOME`. On Windows,
    however, the concept of a home directory isn't that well defined and different
    schemes exist to store data that is restricted to a single user; not every implementation
    of Python resolves this in the same way.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Python几乎达到了平台无关性的极限，但当然，有时也有一些没有完全覆盖的复杂性。例如，我们想要使用FTP程序（和其他程序）常用的`.netrc`文件中存储的用户名和密码，FTP客户端期望这个文件位于用户的家目录中，它希望能在环境变量`HOME`中找到。然而，在Windows上，家目录的概念并没有那么明确，存在不同的方案来存储仅限于单个用户的数据；并非每个Python实现都以相同的方式解决这个问题。
- en: 'We, therefore, define a small utility function that checks if there is a `HOME`
    variable present in the environment (always the case on Unix-like operating systems
    and on some versions of Windows). If not, it checks whether the `USERPROFILE`
    variable is present (present on most versions of Windows including XP where it
    typically points to a directory `C:\Documents and Settings\<yourusername>`). If
    it is present it sets the `HOME` variable to the contents of this `USERPROFILE`
    variable:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们定义了一个小的实用函数来检查环境中是否存在`HOME`变量（在Unix-like操作系统和一些Windows版本中总是存在）。如果没有，它会检查是否存在`USERPROFILE`变量（在包括XP在内的大多数Windows版本中都存在，通常指向目录`C:\Documents
    and Settings\<yourusername>`）。如果存在，它将`HOME`变量设置为这个`USERPROFILE`变量的内容：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Our next task is to find out which FTP server the user wants to upload the rendered
    result to. We store this in a Blender registry key so that we don't have to bother
    the user with a prompt each time he wants to upload a render. The `getftphost()`
    function takes an argument `reuse` that may be used to clear this key if set to
    `False` (to allow for the possibility of choosing a different FTP server), but
    rewriting the user interface to offer the user such an option is left as an exercise
    to the reader.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的任务是找出用户想要将渲染结果上传到哪个FTP服务器。我们将这个信息存储在Blender注册表键中，这样每次用户想要上传渲染时，我们就不需要打扰用户进行提示。`getftphost()`函数接受一个名为`reuse`的参数，如果设置为`False`，则可以用来清除这个键（允许选择不同的FTP服务器），但将用户界面重写以提供这样的选项留给读者作为练习。
- en: The actual code starts with retrieving the key from the registry (from disk
    if necessary, hence the `True` argument, highlighted). If there isn't a key present
    or it doesn't contain a host entry, we prompt the user for the name of the FTP
    server with a pop up. If the user does not specify, one we bail out by raising
    an exception. Otherwise, we store the hostname in the host entry—first create
    the dictionary if it is not present and store this dictionary in Blender's registry.
    Finally, we return the stored hostname.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的代码从从注册表中检索密钥开始（如果需要从磁盘检索，因此使用`True`参数，已高亮显示）。如果没有密钥存在或者它不包含主机条目，我们会通过弹出窗口提示用户输入FTP服务器的名称。如果用户没有指定，我们会通过抛出异常来退出。否则，我们将主机名存储在主机条目中——首先创建字典（如果不存在）并将此字典存储在Blender的注册表中。最后，我们返回存储的主机名。
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We need another utility function to make sure that a Blender image is stored
    on disk as the last rendered image is present as an image with the name `Render`
    `Result`, but this image isn''t written to disk automatically. The function `imagefilename()`
    takes a Blender image as an argument and first checks if it has a valid filename
    associated with it (highlighted). If not, it creates a filename from the name
    of the image by appending a `.tga` extension (images can be saved as TARGA files
    only). The full path is then constructed from this filename and the path of the
    `temp` directory. Now when there is a valid filename present it is saved to call
    the `save()` method and return the filename:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要另一个实用函数来确保Blender图像作为最后渲染的图像存储在磁盘上，因为以`Render Result`命名的图像已经作为一个图像存在，但这个图像并没有自动写入磁盘。`imagefilename()`函数接受一个Blender图像作为参数，首先检查它是否有一个与之关联的有效文件名（已高亮显示）。如果没有，它会从图像的名称创建一个文件名，通过添加`.tga`扩展名（图像只能保存为TARGA文件）。然后从这个文件名和`temp`目录的路径构造完整的路径。现在，当存在一个有效的文件名时，它会保存并调用`save()`方法来返回文件名：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When we upload a file to an FTP server we want to make sure that we do not overwrite
    any existing file. If we do find that a file with a given name is already present
    we'd like to have a function that creates a new filename in a predictable fashion—much
    like the way Blender behaves when creating names for Blender objects. We'd like
    to preserve the extension of the filename so we cannot simply stick to a numerical
    suffix. The `nextfile()` function, therefore, starts by splitting the pathname
    and extension parts of the filename. It uses the `split()` and `splitext()` functions
    from the `os.path` module to leave us with the bare `name`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将文件上传到FTP服务器时，我们想要确保我们不覆盖任何现有的文件。如果我们发现已经存在一个具有给定名称的文件，我们希望有一个函数可以以可预测的方式创建一个新的文件名——就像Blender在创建Blender对象名称时的行为。我们希望保留文件名的扩展名，所以我们不能简单地使用数字后缀。因此，`nextfile()`函数首先将文件名的路径名和扩展名部分分开。它使用`os.path`模块中的`split()`和`splitext()`函数来留下一个裸露的`name`。
- en: If the name already ends in a suffix consisting of a dot and some number (for
    example, `.42`) we'd like to increment this number. This is exactly what the rather
    daunting highlighted lines accomplish. The `sub()` function of Python's `re` module
    takes a regular expression as a first argument (we use a raw string here so we
    don't have to escape any backslashes) and checks whether this regular expression
    matches its third argument (`name` in this case). The regular expression used
    here (`\.(\d+)$`) matches a dot followed by one or more decimal digits if and
    only if these digits are the last characters. If this pattern does match it is
    replaced by the second argument of the `sub()` function. In this case the replacement
    is not a simple string but a `lambda` (that is, unnamed) function that will be
    passed a `match` object and is expected to return a string.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果名称已经以一个由点和一些数字组成的后缀结尾（例如，`.42`），我们希望增加这个数字。这正是下面那些令人敬畏的高亮行所完成的。Python 的 `re`
    模块的 `sub()` 函数接受一个正则表达式作为第一个参数（我们在这里使用原始字符串，这样我们就不需要转义任何反斜杠了），并检查这个正则表达式是否与其第三个参数（在这种情况下是
    `name`）匹配。这里使用的正则表达式（`\.(\d+)$`）匹配一个点后跟一个或多个十进制数字，前提是这些数字是最后一个字符。如果这个模式匹配，它将被
    `sub()` 函数的第二个参数替换。在这种情况下，替换不是一个简单的字符串，而是一个 `lambda`（即未命名的）函数，它将被传递一个 `match`
    对象，并期望返回一个字符串。
- en: As we surrounded the digits part of our regular expression with parentheses,
    we can retrieve just these digits—without the leading dot—with a call to the `match`
    object's `group()` method. We pass it a `1` as argument, as the first opening
    parenthesis marks the first group (group 0 would be the whole pattern). We convert
    this string of digits to an integer by using the built-in `int()` function, add
    1 to it, and convert it back again to a string with the `str()` function. Before
    this result is automatically returned from the `lambda` function we prepend a
    dot again to conform to our desired pattern.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在正则表达式的数字部分周围添加了括号，我们可以通过调用 `match` 对象的 `group()` 方法来检索这些数字——不带前面的点。我们传递一个
    `1` 作为参数，因为第一个开括号标记了第一个组（组 0 将是整个模式）。我们使用内置的 `int()` 函数将这个数字字符串转换为整数，然后加 1，并使用
    `str()` 函数将其再次转换为字符串。在 `lambda` 函数自动返回这个结果之前，我们再次在前面添加一个点，以符合我们想要的模式。
- en: 'We finish by checking if the resulting name is different from the original
    one. If they are the same the original name did not match our pattern and we just
    append `.1` to the name. Finally, we reconstruct the full filename by adding the
    extension and calling the `join()` function from `os.path` to add the path in
    a platform-independent way:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过检查生成的名称是否与原始名称不同来完成工作。如果它们相同，原始名称没有匹配我们的模式，我们只需将 `.1` 追加到名称上。最后，我们通过添加扩展名并调用
    `os.path` 中的 `join()` 函数以平台无关的方式添加路径来重建完整的文件名：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we are all set to do the real work of uploading a file to an FTP server.
    First, we make sure that our environment has a suitable `HOME` variable by calling
    the `sethome()` function . Then, we retrieve the hostname of the FTP server we
    want to upload to (it is perfectly valid, by the way, to enter an IP address instead
    of a hostname):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好进行真正的上传文件到 FTP 服务器的操作。首先，我们通过调用 `sethome()` 函数确保我们的环境有一个合适的 `HOME`
    变量。然后，我们检索我们想要上传到的 FTP 服务器的主机名（顺便说一句，输入 IP 地址而不是主机名是完全有效的）：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we retrieve the user''s credentials for the selected host from the `.netrc`
    file if there is one present (highlighted). This may fail for various reasons
    (there might not be a **.**`netrc` file or the given host has no entry in this
    file); in which case an exception will be raised. If this happens we inform the
    user and ask for a username and password instead with suitable pop ups:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果存在 `.netrc` 文件，我们将从该文件中检索所选主机的用户凭据（高亮显示）。这可能会因为各种原因失败（可能没有 `.netrc` 文件，或者给定的主机没有在这个文件中的条目）；在这种情况下，将引发异常。如果发生这种情况，我们将通知用户，并通过合适的弹出窗口请求用户名和密码：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The rendered image will have been stored as a Blender `Image` object with the
    name `Render` `Result`. The next thing we do is retrieve a reference to this image
    and make sure it is stored on disk. The `imagefilename()` function that we defined
    earlier will return the filename of the stored image.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染后的图像将被存储为一个名为 `Render Result` 的 Blender `Image` 对象。接下来我们要做的是获取对这个图像的引用并确保它已存储在磁盘上。我们之前定义的
    `imagefilename()` 函数将返回存储图像的文件名。
- en: 'The next step is to connect to the FTP server by using the hostname and credentials
    we retrieved earlier (highlighted). Once the connection is established we retrieve
    a list of filenames with the `nlst()` method:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是通过使用我们之前获取的主机名和凭据（已突出显示）连接到FTP服务器。一旦建立连接，我们就使用`nlst()`方法检索文件名列表：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Because we want to make sure that we do not overwrite any files on the FTP server,
    we strip the path from the filename of our stored image with the `basename()`
    function and compare the result to the list of filenames retrieved from the server
    (highlighted). If the filename is already present we generate a new filename with
    the `nextfile()` function and check again and keep on doing that until we finally
    have a filename that isn't used yet on the FTP server.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想确保不覆盖FTP服务器上的任何文件，我们使用`basename()`函数从存储的图像文件名中删除路径，并将结果与从服务器检索到的文件名列表进行比较（已突出显示）。如果文件名已经存在，我们使用`nextfile()`函数生成一个新的文件名，并再次检查，一直这样做，直到我们最终得到一个在FTP服务器上尚未使用的文件名。
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we upload our image file by calling the `storbinary()` method. This method
    will take the destination filename prefixed with `STOR` as the first argument
    and an open file descriptor as the second argument. We provide the latter by calling
    Python''s built-in `open()` function with the name of our image file as the single
    argument. (For more details on the rather outlandish behavior of the `ftplib`
    module, refer to its documentation on [http://docs.python.org/library/ftplib.html.](http://docs.python.org/library/ftplib.html.))
    We gracefully end the connection to the FTP server by calling the `quit()` method
    and inform the user about the completion of the task by showing a message that
    mentions the destination filename as this might be different than expected if
    a similarly named file exists:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过调用`storbinary()`方法上传我们的图像文件。此方法将`STOR`前缀的文件名作为第一个参数，一个打开的文件描述符作为第二个参数。我们通过调用Python的内置`open()`函数，并将我们的图像文件名作为单个参数来提供后者。（有关`ftplib`模块相当奇特行为的更多详细信息，请参阅其[http://docs.python.org/library/ftplib.html](http://docs.python.org/library/ftplib.html)上的文档。）
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The full code is available as `ftp.py` in `ftp.blend`. It may be run from the
    text editor but in this case it is certainly far more convenient to put `ftp.py`
    in Blender's `scripts` directory. The script is configured to make itself available
    in the **File | Export** menu.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码作为`ftp.py`文件位于`ftp.blend`中。它可以从文本编辑器中运行，但在这个例子中，将`ftp.py`放入Blender的`scripts`目录中肯定更加方便。该脚本配置为在**文件
    | 导出**菜单中提供自身。
- en: Spring cleaning—archive unused images
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 春季大扫除——存档未使用的图像
- en: After a while, any long-running project gathers a lot of cruft. For example,
    texture images that were tried once but were discarded in favor of better ones.
    This script will help us retain a bit of order by finding all files in a selected
    directory that are not referenced by our `.blend` file and packing them into a
    **ZIP** **archive**.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一段时间，任何长期运行的项目都会积累很多无用之物。例如，尝试过但被丢弃以换取更好的纹理图像。此脚本将帮助我们通过找到所选目录中所有未被`.blend`文件引用的文件并将它们打包到**ZIP**
    **存档**中来保持一定的秩序。
- en: We will take care not to move any `.blend` files to the ZIP archive (after all,
    those we normally want to be able to render) nor the ZIP archive itself (to prevent
    endless recursion). Any file that we archive we subsequently try to remove, and
    if removing a file leaves an empty directory, we remove that directory as well
    unless it is the directory our `.blend` file resides in.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将注意不要将任何`.blend`文件移动到ZIP存档中（毕竟，我们通常希望能够渲染它们）以及ZIP存档本身（以防止无限递归）。我们将尝试删除我们存档的任何文件，如果删除文件留下一个空目录，我们也会删除该目录，除非它是`.blend`文件所在的目录。
- en: 'The file manipulation functions are provided by Python''s `os` and `os.path`
    modules and ZIP files that can be used both on Windows and open platforms can
    be manipulated with the use of the `zipfile` module. The `zipfile` that we move
    the unused files to we will name `Attic.zip`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 文件操作函数由Python的`os`和`os.path`模块提供，并且可以使用`zipfile`模块在Windows和开放平台上操作ZIP文件。我们将把未使用的文件移动到的`zipfile`命名为`Attic.zip`：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first challenge is to generate a list of all files in the directory where
    our `.blend` file sits. The function `listfiles()` uses the `walk()` function
    from Python's `os` module to recursively descend into the tree of directories
    and produces a list of files along the way.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个挑战是生成一个列表，列出我们`.blend`文件所在的目录中的所有文件。`listfiles()`函数使用Python的`os`模块中的`walk()`函数递归地遍历目录树，并在过程中生成文件列表。
- en: By default, the `walk()` function traverses the directory tree's depth first
    that allows us to alter the list of directories on the fly. This feature is used
    here to remove any directories that start with a dot (highlighted). This isn't
    necessary for the current and parent directories (represented by **..** and **.**
    respectively) because `walk()` already filters them out, but this allows us, for
    example, to also filter out any `.svn` directories that we may encounter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`walk()`函数以深度优先的方式遍历目录树，这允许我们动态地更改目录列表。这里使用此功能来删除任何以点开头的目录（高亮显示）。对于当前目录和父目录（分别由**..**和**.**表示）来说，这不是必要的，因为`walk()`已经过滤掉了它们，但这允许我们，例如，过滤掉我们可能遇到的任何`.svn`目录。
- en: 'The line containing the `yield` statement returns the results one file at a
    time so our function may be used as an iterator. (For more on iterators, refer
    to the online documentation at [http://docs.python.org/reference/simple_stmts.html#yield](http://docs.python.org/reference/simple_stmts.html#yield))
    We join the filename proper and the path to form a complete filename and normalize
    it (that is, remove double path separators and the like); although normalizing
    here isn''t strictly necessary because `walk()` is expected to return any paths
    in normalized form:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 包含`yield`语句的行一次返回一个文件的结果，因此我们的函数可以用作迭代器。（有关迭代器的更多信息，请参阅[http://docs.python.org/reference/simple_stmts.html#yield](http://docs.python.org/reference/simple_stmts.html#yield)在线文档）我们将正确的文件名和路径连接起来，形成一个完整的文件名，并对其进行标准化（即，删除双路径分隔符等）；尽管在这里进行标准化不是严格必要的，因为`walk()`预期会以标准化的形式返回任何路径：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Before we can compare the list of files our `.blend` file uses to the list
    of files present in the directory, we make sure any packed file is unpacked to
    its original file location. This isn''t strictly necessary but ensures that we
    don''t move any files to the archive that are not directly used but do have a
    copy inside the `.blend` file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够将`.blend`文件使用的文件列表与目录中现有的文件列表进行比较之前，我们确保任何打包的文件都解压到其原始文件位置。这虽然不是严格必要的，但确保我们不会将任何未直接使用但`.blend`文件中存在副本的文件移动到存档中：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `GetPaths()` function from the Blender module produces a list of all files
    used by the `.blend` file (except for the `.blend` file itself). We pass it an
    absolute argument set to `True` to retrieve filenames with a full path instead
    of paths relative to the current directory in order to compare these properly
    with the list produced by the `listfiles()` function.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Blender模块中的`GetPaths()`函数生成一个由`.blend`文件使用的所有文件列表（除了`.blend`文件本身）。我们传递一个设置为`True`的绝对参数，以检索带有完整路径的文件名，而不是相对于当前目录的路径，以便正确地与`listfiles()`函数生成的列表进行比较。
- en: 'Again, we normalize these filenames as well. The highlighted line shows how
    we retrieve the absolute path of the current directory by passing the shorthand
    for the current Bender directory ( `//` ) to the `expandpath()` function:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们也对这些文件名进行了标准化。高亮行显示了如何通过传递当前Bender目录的缩写（`//`）到`expandpath()`函数来检索当前目录的绝对路径：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next we create a `ZipFile` object in *write* mode. This will truncate any existing
    archive with the same name and enables us to add files to the archive. The full
    name of the archive is constructed by joining the current Blender directory and
    the name we want to use for the archive. The use of the `join()` function from
    the `os.path` module ensures that we construct the full name in a platform-independent
    way. We set the `debug` argument of the `ZipFile` object to `3` to report anything
    unusual to the console when creating the archive:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们以*写入*模式创建一个`ZipFile`对象。这将截断任何具有相同名称的现有存档，并允许我们向存档中添加文件。存档的完整名称是通过连接当前Blender目录和我们想要使用的存档名称来构建的。使用`os.path`模块中的`join()`函数确保我们以平台无关的方式构建完整名称。我们将`ZipFile`对象的`debug`参数设置为`3`，以便在创建存档时将任何异常报告到控制台：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `removefiles` variable will record the names of the files we want to remove
    after we have constructed the archive. We can only safely remove files and directories
    after we have created the archive or we might refer to directories that no longer
    exist.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`removefiles` 变量将在我们构建存档后记录我们想要删除的文件名。我们只能在创建存档后安全地删除文件和目录，否则我们可能会引用不再存在的目录。'
- en: 'The archive is constructed by looping over the list of all the files in the
    current Blender directory and comparing them to the list of files used by our
    `.blend` file. Any file with an extension such as `.blend` or `.blend1` is skipped
    (highlighted) as is the archive itself. The files are added to the ZIP file using
    the `write()` method, which accepts as a parameter, the filename with a path relative
    to the archive (and hence the current directory). That way it is easier to unpack
    the archive in a new location. Any references to files outside the current directory
    tree are unaffected by the `relpath()` function. Any file we add to the archive
    is marked for removal by adding it to the `removefiles` list. Finally, we close
    the archive—an important step because omitting it may leave us with a corrupted
    archive:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 存档是通过遍历当前 Blender 目录中所有文件的列表并比较它们与我们的 `.blend` 文件使用的文件列表来构建的。任何具有 `.blend` 或
    `.blend1` 等扩展名的文件都会被跳过（突出显示），存档本身也是如此。文件是通过 `write()` 方法添加到 ZIP 文件的，该方法接受一个参数，即相对于存档（因此是当前目录）的文件名。这样，在新位置解压缩存档就更容易了。任何指向当前目录树外文件的引用都不会受
    `relpath()` 函数的影响。我们添加到存档的任何文件都会通过将其添加到 `removefiles` 列表来标记为删除。最后，我们关闭存档——这是一个重要的步骤，因为省略它可能会导致我们得到一个损坏的存档：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The last task left is to remove the files we moved to the archive. The `remove()`
    function from Python's `os` module will accomplish that but we also want to remove
    any directory that ends up empty after removing the files. Therefore, for each
    file we remove we determine the name of its directory. We also check if this directory
    doesn't point to the current directory because we want to make absolutely sure
    we do not remove it as this is where our `.blend` files reside. Although an unlikely
    scenario, it is possible to open a `.blend` file in Blender and remove the `.blend`
    file itself that might leave an empty directory. If we remove this directory any
    subsequent (auto) save would fail. The `relpath()` function will return a dot
    if the directory passed as its first argument points to the same directory as
    the directory passed as its second argument. (The `samefile()` function is more
    robust and direct but not available on Windows.)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的最后任务是删除我们移动到存档中的文件。Python 的 `os` 模块中的 `remove()` 函数将完成这项任务，但我们还希望删除在删除文件后变得空余的任何目录。因此，对于每个我们删除的文件，我们确定其目录的名称。我们还检查这个目录是否不指向当前目录，因为我们想确保我们不会删除它，因为这是我们的
    `.blend` 文件所在的位置。尽管这种情况不太可能发生，但在 Blender 中打开 `.blend` 文件并删除该 `.blend` 文件本身可能会留下一个空目录。如果我们删除这个目录，任何随后的（自动）保存都会失败。`relpath()`
    函数如果其第一个参数指向的目录与第二个参数指向的目录相同，将返回一个点。（`samefile()` 函数更健壮且直接，但在 Windows 上不可用。）
- en: 'If we made certain we are not referring to the current directory we use the
    `removedirs()` function to remove the directory. If the directory is not empty
    this will fail with an `OSError` exception (that is, the file we removed was not
    the last file in the directory), which we ignore. The `removedirs()` function
    will also remove all parent directories leading to the directory iff they are
    empty, which is exactly what we want:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们确定我们没有引用当前目录，我们使用 `removedirs()` 函数来删除目录。如果目录不为空，这将失败并抛出 `OSError` 异常（即我们删除的文件不是目录中的最后一个文件），我们忽略这个异常。`removedirs()`
    函数还会删除通向目录的所有父目录，如果它们为空，这正是我们想要的：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The full code is available as `zip.py` in `attic.blend`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码作为 `zip.py` 文件存放在 `attic.blend` 中。
- en: Extending the editor—searching with regular expressions
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展编辑器——使用正则表达式进行搜索
- en: The **editor** already provides basic search and replace functionality but if
    you are used to other editors you might miss the possibility to search using **regular
    expressions**. This plug-in provides this functionality.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**编辑器**已经提供了基本的搜索和替换功能，但如果你习惯了其他编辑器，你可能会错过使用**正则表达式**进行搜索的可能性。此插件提供了这一功能。'
- en: 'Regular expressions are very powerful and many programmers love their versatility
    (and many others loathe their poor readability). Whether you love or hate them,
    they are very expressive: matching any decimal number can simply be expressed
    as `\d+` for example (one or more digits). If you are looking for a word that
    is spelled differently in British or American English, such as colour/color, you
    can match any of them with the expression `colou?r` (color with an optional *u*).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式非常强大，许多程序员喜欢它们的灵活性（而许多人则讨厌它们糟糕的可读性）。无论你爱它还是恨它，它们都非常具有表现力：匹配任何十进制数字可以简单地表示为
    `\d+`（例如，一个或多个数字）。如果你在寻找一个在英式英语或美式英语中拼写不同的单词，例如 colour/color，你可以使用表达式 `colou?r`（带有可选的
    *u*）来匹配任何一个。
- en: The following code will show that Blender's built-in editor can be equipped
    with this useful search tool with just a few lines of code. The script provided
    should be installed in Blender's `scripts` directory and can then be invoked from
    the text editor menu as **Text | Text Plugins | Regular Expression Search** or
    by a hot key *Alt + Ctrl + R*. It will pop up a small input widget where the user
    may enter a regular expression (this pop up will remember the last regular expression
    entered) and if the user clicks on the **OK** button or hits *Enter* the cursor
    will be positioned at the first occurrence that matches the regular expression,
    highlighting the extent of the match.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将展示 Blender 内置的编辑器只需几行代码就可以配备这个有用的搜索工具。提供的脚本应安装在 Blender 的 `scripts` 目录中，然后可以从文本编辑器菜单作为
    **文本 | 文本插件 | 正则表达式搜索** 或通过快捷键 *Alt + Ctrl + R* 调用。它将弹出一个小的输入小部件，用户可以在其中输入正则表达式（此弹出窗口将记住最后输入的正则表达式），如果用户点击
    **确定** 按钮或按 *Enter* 键，光标将定位到第一个匹配正则表达式的位置，并突出显示匹配的范围。
- en: '![Extending the editor—searching with regular expressions](img/0400-09-02.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![扩展编辑器——使用正则表达式搜索](img/0400-09-02.jpg)'
- en: 'To register the script as a text plug-in with the designated hot key the first
    lines of the script consist of the customary headers augmented with a `Shortcut:`
    entry (highlighted below):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要将脚本注册为具有指定快捷键的文本插件，脚本的前几行包含常规标题，并增加了一个 `Shortcut:` 条目（如下所示突出显示）：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The next step is to import the necessary modules. Python supplies us with a
    standard `re` module, which is well documented (the online docs are sufficient
    even for novice users unfamiliar with regular expressions), and we import Blender''s
    `bpy` module. In this book we do not often use this module as it is marked as
    experimental, but in this case we need it to find out which text buffer is the
    active one:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是导入必要的模块。Python 为我们提供了一个标准的 `re` 模块，该模块有很好的文档（即使是对于不熟悉正则表达式的初学者，在线文档也足够了），我们导入
    Blender 的 `bpy` 模块。在这本书中，我们很少使用这个模块，因为它被标记为实验性的，但在这个例子中，我们需要它来找出哪个文本缓冲区是活动的：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To signal any error conditions, such as an illegal regular expression or when
    nothing matches, we define a simple `popup()` function:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了指示任何错误条件，例如非法的正则表达式或没有匹配项，我们定义了一个简单的 `popup()` 函数：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Because we want to remember the last regular expression the user entered we
    will be using Blender''s registry and, therefore, we define a key to use:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们想记住用户输入的最后一个正则表达式，所以我们将使用 Blender 的注册表，因此我们定义了一个键来使用：
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `run()` function ties all functionality together; it retrieves the active
    text buffer and bails out if there isn''t one:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`run()` 函数将所有功能结合起来；它检索活动文本缓冲区，如果没有活动缓冲区则退出：'
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Subsequently, it retrieves the cursor position within this buffer:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，它检索此缓冲区内的光标位置：
- en: '[PRE22]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Before presenting the user with a pop up to enter a regular expression we check
    if we stored one earlier in the registry. We simply retrieve it and if it fails
    we set the default expression to the empty string (highlighted). Note that we
    do not pass any extra parameters to the `GetKey()` function because we do want
    to store any information on disk in this case. If the user enters an empty string
    we simply return without searching:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在向用户提供弹出窗口以输入正则表达式之前，我们检查是否在注册表中存储了一个之前的正则表达式。我们简单地检索它，如果失败，则将默认表达式设置为空字符串（突出显示）。请注意，我们不会向
    `GetKey()` 函数传递任何额外的参数，因为我们不希望在磁盘上存储任何信息。如果用户输入一个空字符串，我们只需返回而不进行搜索：
- en: '[PRE23]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We compile the regular expression to see if it''s valid and if this fails we
    show a message and return:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编译正则表达式以查看其是否有效，如果失败，则显示一条消息并返回：
- en: '[PRE24]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now that we know the regular expression is correct, we iterate over all lines
    of the text buffer starting at the line the cursor is on (highlighted). For each
    line we match our compiled regular expression to the string (or the part after
    the cursor if it is the first line).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道正则表达式是正确的，我们从光标所在的行（高亮显示）开始遍历文本缓冲区的所有行。对于每一行，我们将编译的正则表达式与字符串（或如果它是第一行，则是光标后的部分）进行匹配。
- en: '[PRE25]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If there is a match we note the start of the match within the line and the length
    of the match (suitably set off if it's the first line) and set the cursor position
    to the current line and the start of the match (highlighted). We also set the
    "select position" to the position of the match plus the length of the match so
    our match will be highlighted and then returned. If there is no match within the
    line we increment the row index and continue the iteration.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有匹配项，我们会在行内记录匹配的开始位置和匹配的长度（如果是第一行，则适当分隔），并将光标位置设置为当前行和匹配的开始位置（高亮显示）。我们还设置“选择位置”为匹配位置加上匹配长度，以便我们的匹配项被高亮显示并返回。如果行内没有匹配项，我们增加行索引并继续迭代。
- en: 'If there is nothing left to iterate over, we signal the user that we did not
    find any match. In all cases, we store the regular expression in the registry
    for reuse:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有更多可迭代的项，我们向用户发出信号，表示我们没有找到任何匹配项。在所有情况下，我们将正则表达式存储在注册表中以供重用：
- en: '[PRE26]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The full code is available as `regex.py` in `regex.blend` but should be installed
    in Blender's `scripts` directory with a suitable name, such as `textplugin_regex.py`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码作为 `regex.py` 存放在 `regex.blend` 中，但应该安装到 Blender 的 `scripts` 目录中，并使用合适的名称，例如
    `textplugin_regex.py`。
- en: Extending the editor—interacting with Subversion
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展编辑器——与 Subversion 交互
- en: W hen actively developing scripts it can be difficult to keep track of changes
    or to revert to previous versions. This is not unique to writing Python scripts
    in Blender and over the years a number of **version control** systems have evolved.
    One of the better known, and widely used ones is **Subversion** ([http://subversion.tigris.org](http://subversion.tigris.org)).
    In this section, we show how the editor can be augmented to commit or update a
    text file from a repository.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当积极开发脚本时，跟踪更改或回滚到先前版本可能会很困难。这不仅仅是在 Blender 中编写 Python 脚本时的问题，而且多年来已经发展了许多 **版本控制系统**。其中之一是广为人知且广泛使用的
    **Subversion** ([http://subversion.tigris.org](http://subversion.tigris.org))。在本节中，我们展示了如何增强编辑器以提交或更新来自仓库的文本文件。
- en: Interaction with a Subversion repository is not provided by a bundled Python
    module so we have to get that from somewhere else. The **Downloads** section of
    [http://pysvn.tigris.org](http://pysvn.tigris.org) contains both source and binary
    distributions for many platforms. Be sure to get the right one since both the
    supported version of Subversion and the version of Python may differ. The scripts
    we develop here are tested against Subversion 1.6.x and Python 2.6.x but should
    work with earlier versions of Subversion as well.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Subversion 仓库的交互不是由捆绑的 Python 模块提供的，因此我们必须从其他地方获取它。在 [http://pysvn.tigris.org](http://pysvn.tigris.org)
    的 **下载** 部分包含了多个平台的源代码和二进制分发。请确保获取正确的版本，因为支持的 Subversion 版本和 Python 版本可能不同。我们在这里开发的脚本针对
    Subversion 1.6.x 和 Python 2.6.x 进行了测试，但应该也能与更早版本的 Subversion 一起工作。
- en: We will be implementing the functionality to commit a text file to a repository
    and to update a file (that is, get the latest revision from the repository). If
    we try to commit a file that is not part of the repository yet we will add it,
    but we will not implement tools to create a repository or check out a working
    copy. A tool such as **TortoiseSVN** on Windows ([http://tortoisesvn.tigris.org/](http://tortoisesvn.tigris.org/))
    or any number of tools for open platforms are far better equipped for that. We
    just assume a checked-out working directory where we store our Blender text files.
    (This working directory might be completely different from your Blender project
    directory.)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现将文本文件提交到仓库以及更新文件（即从仓库获取最新修订版）的功能。如果我们尝试提交尚未成为仓库一部分的文件，我们会将其添加，但我们将不会实现创建仓库或检出工作副本的工具。例如，Windows
    上的 **TortoiseSVN** ([http://tortoisesvn.tigris.org/](http://tortoisesvn.tigris.org/))
    或任何数量的开放平台工具都更适合这项工作。我们假设有一个检出的工作目录，我们将 Blender 文本文件存储在这里。（这个工作目录可能与你的 Blender
    项目目录完全不同。）
- en: Committing a file to the repository
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将文件提交到仓库
- en: Committing a text buffer to the repository is a two-step process. First, we
    have to save the contents of the text buffer to a file and then we commit this
    file to the repository. We have to check whether the text block has an associated
    filename and prompt the user to save the file first if it hasn't got one yet.
    The user must save the file to a checked out directory in order to commit the
    file to a repository.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将文本缓冲区提交到仓库是一个两步过程。首先，我们必须将文本缓冲区的内容保存到文件中，然后我们将这个文件提交到仓库。我们必须检查文本块是否有关联的文件名，如果没有，则提示用户先保存文件。用户必须将文件保存到已签出的目录中，以便将文件提交到仓库。
- en: 'Just like the extension that allowed us to search with regular expressions,
    this one starts with a suitable header to identify it as a text editor plug-in
    and to assign a keyboard shortcut. We define the mnemonic *Ctrl + Alt + C* for
    committing (highlighted) as we will define *Ctrl + Alt + U* for updating in its
    companion script. We also import the necessary modules, notably the `pysvn` module:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 就像允许我们使用正则表达式进行搜索的扩展一样，这个扩展以一个合适的标题开始，以标识它作为一个文本编辑插件，并分配一个键盘快捷键。我们为提交（高亮显示）定义了
    *Ctrl + Alt + C* 作为快捷键，正如我们将在其伴随脚本中为更新定义 *Ctrl + Alt + U* 一样。我们还导入了必要的模块，特别是 `pysvn`
    模块：
- en: '[PRE27]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `run()` function first tries to get the active text buffer and will return
    without a croak if there isn't one. Then it checks if there is a filename defined
    for this text buffer (highlighted). If not, it reminds the user to save the file
    first (thus defining a filename and placing the file in a checked out directory)
    and returns.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`run()` 函数首先尝试获取活动文本缓冲区，如果没有找到，则不会抛出异常并返回。然后它检查是否为这个文本缓冲区定义了文件名（高亮显示）。如果没有，它会提醒用户先保存文件（从而定义一个文件名并将文件放置在已签出的目录中）然后返回。'
- en: '[PRE28]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The next step is to create a `pysvn` client object that will enable us to interact
    with a repository. Its `info()` method allows us to retrieve information about
    the repository status of a file (highlighted). If there is no information the
    file will not have been added to the repository yet—a situation that we correct
    by calling the `add()` method:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个 `pysvn` 客户端对象，这将使我们能够与仓库交互。它的 `info()` 方法允许我们检索有关文件仓库状态的详细信息（高亮显示）。如果没有信息，则表示该文件尚未添加到仓库中——这种情况我们可以通过调用
    `add()` 方法来纠正：
- en: '[PRE29]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we write out the current contents of the text buffer by joining all the
    lines in it to a single chunk of data and writing that to the file object we opened
    on the filename associated with the buffer:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将文本缓冲区的当前内容写出来，通过将其中所有行连接成一个单一的数据块，并将其写入我们为与缓冲区关联的文件名打开的文件对象中：
- en: '[PRE30]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This file will be committed to the repository with the `checkin()` method to
    which we pass a rather uninformative commit message. It might be a good idea to
    prompt the user for a more sensible message. Finally, we inform the user of the
    resulting revision.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件将通过 `checkin()` 方法提交到仓库，我们传递一个相当不具信息量的提交信息。可能提示用户输入一个更合理的消息是个好主意。最后，我们通知用户结果版本号。
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that Subversion revision numbers are not associated with a file but with
    a repository, so this number may differ by more than one from the previous file
    commit if meanwhile other files were committed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Subversion 版本号不是与文件相关联，而是与仓库相关联，因此如果在此期间其他文件已被提交，这个数字可能比上一个文件提交的数字多一个以上。
- en: '[PRE31]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The full code is available as `textplugin_commit` in `svn.blend` but should
    be installed in Blender's `scripts` directory.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 完整代码作为 `textplugin_commit` 在 `svn.blend` 中可用，但应安装在 Blender 的 `scripts` 目录中。
- en: Updating a file from the repository
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从仓库更新文件
- en: The whole purpose of a repository is being able to collaborate, which means
    that others may change the files we are working on as well and we must be able
    to retrieve those committed changes. This is called updating a file and means
    that we copy the latest version that resides in the repository to our working
    directory.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库的全部目的在于能够协作，这意味着其他人也可能更改我们正在工作的文件，我们必须能够检索这些提交的更改。这被称为更新文件，意味着我们将存储在仓库中的最新版本复制到我们的工作目录中。
- en: Besides checking whether the text buffer is saved and the file is already added
    to the repository, we must also check whether our current version is newer or
    altered from the version in the repository. If so, we offer the user the choice
    of discarding these changes and reverting to the version in the repository or
    to commit the version residing in the text buffer. (A third option, merging the
    differences is not provided here; although Subversion is certainly able to do
    that, at least for text files, but this is better left to more versatile tools
    such as TortoiseSVN.)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 除了检查文本缓冲区是否已保存以及文件是否已添加到版本库中，我们还必须检查我们的当前版本是否比版本库中的版本更新或已更改。如果是这样，我们向用户提供选择，是放弃这些更改并恢复到版本库中的版本，还是提交文本缓冲区中的版本。（这里没有提供合并差异的第三个选项；尽管Subversion当然能够做到这一点，至少对于文本文件来说是这样，但最好留给更通用的工具，如TortoiseSVN。）
- en: 'The first part of the script is very similar to the commit script. The main
    difference is a different shortcut key:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的第一部分与提交脚本非常相似。主要区别是不同的快捷键：
- en: '[PRE32]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `run()` function also starts off quite similar as it retrieves the active
    text buffer (if any) and checks whether the text buffer has an associated filename
    (highlighted). It also checks if the filename was already added to the repository
    and if not, corrects this by calling the `add()` method and informs the user with
    a pop up:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`run()`函数也以类似的方式开始，它检索活动文本缓冲区（如果有）并检查文本缓冲区是否有相关文件名（突出显示）。它还检查文件名是否已添加到版本库中，如果没有，则通过调用`add()`方法进行纠正，并通过弹出窗口通知用户：'
- en: '[PRE33]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After writing the contents of the text buffer to its associated file it calls
    the `status()` method to see if the file we have written (and therefore the contents
    of the text buffer) is modified compared to the version in the repository (highlighted).
    The `status()` method may be passed a *list* of filenames as well and always returns
    a list of results, even when we pass it just a single filename—hence the `[0]`
    index. If our text buffer is modified we inform the user and offer a choice: either
    discard the changes and retrieve the version stored in the repository or commit
    the current version. It is also possible to cancel the action altogether by clicking
    outside the menu, in which case `PupMenu()` will return `-1`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在将文本缓冲区的内容写入其相关文件后，它调用`status()`方法来查看我们写入的文件（因此是文本缓冲区的内容）与版本库中的版本相比是否已修改（突出显示）。`status()`方法也可以传递一个*列表*的文件名，并且总是返回一个结果列表，即使我们只传递一个文件名——因此有`[0]`索引。如果我们的文本缓冲区已修改，我们通知用户并提供选择：要么放弃更改并检索存储在版本库中的版本，要么提交当前版本。还可能通过点击菜单外取消整个操作，在这种情况下`PupMenu()`将返回`-1`：
- en: '[PRE34]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After retrieving the version from the repository we refresh the contents of
    our text buffer:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本库检索版本后，我们刷新文本缓冲区的内容：
- en: '[PRE35]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, we inform the user with a pop up what the revision number is of the
    content in the text buffer by calling the `status()` method again and fetching
    the `commit_revision` field:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过再次调用`status()`方法并获取`commit_revision`字段来通知用户文本缓冲区内容的修订号：
- en: '[PRE36]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The full code is available as `textplugin_svnupdate` in `svn.blend`, and like
    its commit counterpart it should be installed in Blender's `scripts` directory.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 完整代码作为`textplugin_svnupdate`在`svn.blend`中可用，并且像其提交对应版本一样，应该安装在Blender的`scripts`目录中。
- en: Working with a repository
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与版本库一起工作
- en: Although a full tutorial on working with Subversion is out of scope of this
    book, it might be useful to sketch a workflow for a Blender project where scripted
    components are versioned.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管关于使用Subversion的完整教程超出了本书的范围，但为Blender项目中的脚本版本控制流程勾勒一个轮廓可能是有用的。
- en: It is important to understand that a Blender project itself does not have to
    be under version control. We may organize our Blender project in any way that
    makes sense and have a `scripts` directory within it that is under version control.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，Blender项目本身不必置于版本控制之下。我们可以以任何有意义的任何方式组织我们的Blender项目，并在其中有一个受版本控制的`scripts`目录。
- en: 'Say we have created a repository for scripts on a network storage device and
    created a Blender project directory on our local machine. In order to bring our
    scripts under version control we have to perform the following steps:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在网络存储设备上创建了一个脚本版本库，并在我们的本地机器上创建了一个Blender项目目录。为了将我们的脚本置于版本控制之下，我们必须执行以下步骤：
- en: Check out the script's repository within our Blender project directory (this
    is called the **working copy** of the repository).
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的Blender项目目录内检出脚本版本库（这被称为版本库的**工作副本**）。
- en: Create a script within our `.blend` file with the built-in editor.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用内置编辑器在我们的 `.blend` 文件中创建一个脚本。
- en: Save this script to the working copy.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此脚本保存到工作副本中。
- en: Every time we change something, we press *Ctrl + Alt + C* to commit our changes.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次我们更改任何内容时，我们都按下 *Ctrl + Alt + C* 来提交我们的更改。
- en: Every time we start working on our script again we press *Ctrl + Alt + U* first
    to see if someone else has changed anything.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次我们再次开始编写脚本时，首先按下 *Ctrl + Alt + U* 来查看是否有人更改了任何内容。
- en: Note that there is nothing against bringing all assets, such as textures or
    `.blend` files that act as libraries under version control but we have to use
    a separate client to commit changes. It would be an interesting exercise to create
    some scripts that commit or update all files in the current Blender directory.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们并不反对将所有资产，如纹理或作为版本控制库使用的 `.blend` 文件等全部带入，但我们必须使用单独的客户端来提交更改。创建一些提交或更新当前
    Blender 目录中所有文件的脚本将是一项有趣的练习。
- en: The need for speed—using Psyco
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对速度的需求——使用 Psyco
- en: 'Python is an interpreted language: all instructions in a script are interpreted
    and executed again and again when they are encountered. This may sound inefficient
    but for a developer of a program the advantage of being able to quickly develop
    and test a program may outweigh the disadvantage of a slower running program.
    And interpreting might be inefficient but that is not identical to slow. Python
    is a very high-level language so a single language element might be equivalent
    to a lot of low-level instructions. Besides, given modern hardware even a slow
    script might be finished faster than a user expects a result.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种解释型语言：脚本中的所有指令都会在遇到时被解释并重新执行。这听起来可能效率不高，但对于程序的开发者来说，能够快速开发和测试程序的优势可能超过了程序运行较慢的劣势。而且，解释可能效率不高，但这并不等同于慢。Python
    是一种非常高级的语言，所以单个语言元素可能相当于许多低级指令。此外，考虑到现代硬件，即使是慢速的脚本也可能比用户预期的结果更快地完成。
- en: Nevertheless, there are situations where any speed increase is welcome. From
    all the examples we have seen in this book Pynodes are probably the most computationally
    intensive as the instructions are run for every visible pixel in a texture or
    shader and often even many more times per pixel if oversampling is taken into
    account. Saving a few milliseconds from a script that takes less than a second
    to execute doesn't amount to much, but saving 20% of the rendering time amounts
    to a significant amount of time saved when rendering a 500 frame shot.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在任何情况下，任何速度的提升都是受欢迎的。从本书中我们看到的所有示例来看，Pynodes 可能是计算量最大的，因为指令会在纹理或着色器中的每个可见像素上运行，并且如果考虑超采样，每个像素可能还会运行许多更多次。从执行时间不到一秒的脚本中节省几毫秒并不算什么，但节省20%的渲染时间，在渲染500帧的镜头时，可以节省相当多的时间。
- en: '**Enter** **Psyco**: Psyco is a Python extension that tries to speed up the
    execution of a script by compiling frequently used parts of a script to machine
    instructions and storing them for reuse. This process is often called **just-in-time
    compilation** and is akin to just-in-time compilation in other languages such
    as Java. (The implementation is similar in concept but quite different in implementation
    due to Python''s dynamic typing. This is of no concern to developers of Python
    scripts.) What matters is that Psyco may be used in any script without any changes
    in the code except for adding a few lines.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**进入** **Psyco**：Psyco 是一个 Python 扩展，它试图通过将脚本中频繁使用的部分编译成机器指令并存储起来以供重用，来加速脚本的执行。这个过程通常被称为
    **即时编译**，类似于其他语言（如 Java）中的即时编译。（在概念上相似，但在实现上由于 Python 的动态类型而相当不同。这对于 Python 脚本的开发者来说并不重要。）重要的是，Psyco
    可以在任何脚本中使用，而无需对代码进行任何更改，只需添加几行即可。'
- en: 'Psyco is available as a binary package for Windows and can be compiled from
    source on other platforms. Full instructions are available on the Psyco website:
    [http://psyco.sourceforge.net/](http://psyco.sourceforge.net/).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Psyco 作为 Windows 的二进制包可用，并且可以在其他平台上从源代码编译。完整说明可在 Psyco 网站上找到：[http://psyco.sourceforge.net/](http://psyco.sourceforge.net/)。
- en: Do verify that you install the version that fits your Python installation because
    although the site states that the version compiled for Python 2.5 should work
    for 2.6 as well, it still might fail, so rather use the version specifically compiled
    for 2.6\. Now, what speed increase might we expect? That is difficult to estimate
    but easy enough to measure! Just render a frame and note the time it took, then
    import psyco in your code, render again, and note the difference. If it is significant
    leave the code in, otherwise you might remove it again.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保您安装的版本与您的Python安装兼容，因为尽管网站声明为Python 2.5编译的版本也应该适用于2.6，但它仍然可能会失败，所以最好使用专门为2.6编译的版本。现在，我们可能期望的速度提升是多少？这很难估计，但很容易测量！只需渲染一帧，并注意它花费的时间，然后导入代码中的psyco，再次渲染，并注意差异。如果差异显著，请保留代码，否则您可能再次删除它。
- en: 'In the following table some results are listed for the test scene provided
    in `pysco.blend` but your mileage may vary. Also note that the test scene is a
    rather optimistic scenario as most of the render is covered by a texture generated
    by a Pynode. If this were less, the gain in speed would be less, but this does
    give an estimate of what is possible with Psyco. A factor two for the relevant
    code is readily achievable. The following table lists some illustrating sample
    timings:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下表格中，列出了`pysco.blend`提供的测试场景的一些结果，但您的实际效果可能会有所不同。请注意，测试场景是一个相当乐观的情景，因为大多数渲染都被一个由Pynode生成的纹理覆盖。如果这个覆盖更少，速度的提升也会更少，但这确实给出了使用Psyco可能实现的效果。相关代码的速度提升可以达到两倍。以下表格列出了一些说明性的样本时间：
- en: '| Time in seconds | Without Psyco | With Psyco |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 时间（秒） | 没有Psyco | 有Psyco |'
- en: '| --- | --- | --- |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Netbook | 52.7 | 26.3 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 净书本 | 52.7 | 26.3 |'
- en: '| Desktop | 14.01 | 6.98 |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 桌面 | 14.01 | 6.98 |'
- en: Enabling Psyco
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用Psyco
- en: The following code shows the additional lines needed to enable psyco on our
    previously encountered `raindrops` Pynode. Changes are indicated in bold.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了在之前遇到的`raindrops` Pynode上启用Psyco所需的附加行。变更以粗体表示。
- en: '[PRE37]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: So basically, only a few lines are added after the definition of the Pynode.
    Make sure to click on the **Update** button on the Pynode otherwise the code will
    not be recompiled and changes will not be visible.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 所以基本上，在Pynode的定义之后只添加了几行。确保在Pynode上点击**更新**按钮，否则代码将不会被重新编译，更改将不会可见。
- en: The previous code just tries to import the `psyco` module. If this fails (for
    any reason) an informative message is printed on the console but the code will
    run correctly, nevertheless. If it is imported we instruct Psyco to optimize the
    `__call__()` method by calling the `bind()` function with a reference to this
    `__call__` method as an argument and inform the user on the console that we successfully
    configured Psyco.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码只是尝试导入`psyco`模块。如果导入失败（任何原因），控制台将打印出一条信息性消息，但代码仍然可以正常运行。如果成功导入，我们指导Psyco通过调用`bind()`函数并传递一个指向此`__call__`方法的引用来优化`__call__()`方法，并在控制台上通知用户我们已成功配置Psyco。
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter we looked beyond 3D and rendering and saw how to make life
    happier for a Python developer and artist alike by providing some scripts to help
    in some common housekeeping tasks by extending the functionality of the built-in
    editor with regular expression searches and version control and showed how to
    save valuable rendering time in some situations by using Psyco. Specifically,
    we learned:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不仅探讨了3D和渲染，还展示了如何通过提供一些脚本帮助处理一些常见的维护任务，通过扩展内置编辑器的正则表达式搜索和版本控制功能，以及如何通过使用Psyco在某些情况下节省宝贵的渲染时间。具体来说，我们学习了：
- en: How to list and archive assets such as image maps
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何列出和存档资产，如图像映射
- en: How to publish a rendered image automatically with FTP
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用FTP自动发布渲染图像
- en: How to extend the functionality of the built-in editor with regular expression
    searches
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用正则表达式搜索扩展内置编辑器的功能
- en: How to speed up computations using Psyco—a just-in-time compiler
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用即时编译器Psyco加速计算
- en: How to add version control to your scripts with Subversion
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Subversion给你的脚本添加版本控制
