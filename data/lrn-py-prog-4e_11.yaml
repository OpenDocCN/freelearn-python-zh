- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Debugging and Profiling
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试和性能分析
- en: ”If debugging is the process of removing software bugs, then programming must
    be the process of putting them in.”
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “如果调试是移除软件错误的过程，那么编程就必须是引入错误的过程。”
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: – Edsger W. Dijkstra
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ——埃德加·W·迪杰斯特拉
- en: In the life of a professional coder, debugging and troubleshooting take up a
    significant amount of time. All but the most trivial software is guaranteed to
    have bugs. Humans are not perfect; we make mistakes. Therefore, the code we produce
    is also not perfect. As developers, we spend a large portion of our time reading
    code that was written by other people. In our opinion, a good software developer
    is someone who keeps an eye out for potential bugs, even when they are reading
    code that is not reported to be wrong or buggy.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在专业程序员的生涯中，调试和故障排除占据了大量的时间。除了最简单的软件，所有软件都几乎肯定会存在错误。人类并不完美；我们会犯错误。因此，我们编写的代码也不完美。作为开发者，我们花费大量时间阅读其他开发者编写的代码。在我们看来，一个好的软件开发者是在阅读代码时也会留心潜在错误的开发者，即使这些代码并未报告为错误或有缺陷。
- en: Being able to debug code efficiently and quickly is a skill that every coder
    needs to keep improving. Like testing, debugging is a skill that is best learned
    through experience. There are guidelines you can follow, but there is no book
    that will teach you everything you need to know to become good at this.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 能够高效快速地调试代码是每个程序员需要不断改进的技能。就像测试一样，调试是一项最好通过经验来学习的技能。你可以遵循一些指南，但没有一本书能教你成为调试高手所需知道的一切。
- en: We feel that on this subject, we have learned the most from our colleagues.
    It amazes us to observe someone who is very skilled attacking a problem. We enjoy
    seeing the steps they take, the things they verify to exclude potential causes,
    and how they select the path that eventually leads them to a solution.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们觉得在这个问题上，我们从同事那里学到了最多的东西。我们惊讶地观察到有人非常擅长解决问题。我们喜欢看到他们采取的步骤，他们验证以排除潜在原因的事情，以及他们如何选择最终引导他们找到解决方案的路径。
- en: Every colleague we work with can teach us something or surprise us with a fantastic
    guess that turns out to be the right one. When that happens, do not just remain
    in wonderment (or worse, in envy), but seize the moment and ask them how they
    got to that guess and why. The answer will allow you to see whether there is something
    you can study in depth later so that, next time, you will be the one who finds
    the bug.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们与之共事的每一位同事都能教会我们一些东西，或者用他们出色的猜测来让我们感到惊讶，而这些猜测最终被证明是正确的。当这种情况发生时，不要只是停留在惊奇（或者更糟，嫉妒）之中，而要抓住这个机会，询问他们是如何得出这个猜测的，为什么会有这样的想法。这个答案将帮助你判断是否有什么东西你可以深入研究，以便下次你能找到错误。
- en: Some bugs are easy to spot. They come out of mistakes and, once you see the
    effects of those mistakes, it is easy to find a solution to the problem. But there
    are other bugs that are much more subtle and require true expertise and a great
    deal of creativity and out-of-the-box thinking to be dealt with. The worst bugs
    of all are the non-deterministic ones. These sometimes happen, and sometimes do
    not. Some happen only in a particular environment but not in another seemingly
    identical environment.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 有些错误很容易被发现。它们来自错误，一旦你看到这些错误的效果，就很容易找到解决问题的方法。但还有一些错误更为微妙，需要真正的专业知识以及大量的创造性和跳出思维来处理。最糟糕的错误是非确定性的错误。这些错误有时会发生，有时不会。有些错误只会在特定的环境中发生，而在看似相同的环境中则不会发生。
- en: In a professional setting, we often need to debug our code in highly stressful
    situations. If a website is down, or customers are upset, the business is losing
    money. As a result, there is often a lot of pressure on developers to find and
    fix the problem immediately. In such situations, it is crucial to be able to keep
    calm. That’s the most important skill to have if you want to be able to fight
    bugs effectively. Stress negatively impacts the creative thinking and problem-solving
    abilities that we need to find and fix bugs. So, take a deep breath, sit properly,
    and focus.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在专业环境中，我们经常需要在高度紧张的情况下调试代码。如果一个网站宕机，或者客户感到不满，业务就会损失金钱。因此，通常会对开发者施加很大的压力，要求他们立即找到并修复问题。在这种情况下，能够保持冷静至关重要。如果你想要有效地与错误作斗争，这是最重要的技能。压力会负面影响我们寻找和修复错误所需的创造性思维和解决问题的能力。所以，深呼吸，坐好，集中注意力。
- en: In this chapter, we will try to demonstrate some useful techniques that you
    can employ according to the severity of the bug, and a few suggestions that will
    hopefully boost your weapons against bugs and issues.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将尝试展示一些有用的技术，您可以根据错误的严重程度来使用这些技术，以及一些希望有助于增强您对抗错误和问题的武器的建议。
- en: 'Specifically, we are going to look at the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将关注以下内容：
- en: Debugging techniques
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试技术
- en: Troubleshooting guidelines
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障排除指南
- en: Profiling
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能分析
- en: Debugging techniques
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试技术
- en: In this part, we will introduce you to some of the techniques we use most often.
    This is not an exhaustive list, but it should give you some useful ideas for where
    to start when debugging your own Python code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们将向您介绍我们最常用的几种技术。这不是一个详尽的列表，但它应该能给您一些有用的想法，告诉您在调试自己的Python代码时从哪里开始。
- en: Debugging with print
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用打印进行调试
- en: The key to understanding any bug is to understand what your code is doing at
    the point where the bug occurs. For this reason, we will be looking at a few different
    techniques for inspecting the state of a program while it is running.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 理解任何错误的关键是理解错误发生时您的代码正在做什么。因此，我们将探讨一些不同的技术，用于在程序运行时检查程序的状态。
- en: The easiest technique of all is to add `print()` calls at various points in
    your code. This allows you to easily see which parts of your code are executed,
    and what the values of key variables are at different points during execution.
    For example, if you are developing a Django website and what happens on a page
    is not what you would expect, you can fill the view with prints and keep an eye
    on the console while you reload the page.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所有技术中最简单的一种是在代码的各个位置添加`print()`调用。这允许您轻松地看到哪些部分的代码被执行，以及在执行过程中的关键变量的值。例如，如果您正在开发一个Django网站，页面上的行为不是您预期的，您可以在视图中添加打印语句，并在重新加载页面时关注控制台。
- en: There are several drawbacks and limitations to using `print()` for debugging.
    To use this technique, you need to be able to modify the source code and run it
    in a terminal where you can see the output of your `print()` function calls. This
    is not a problem in your development environment on your own machine, but it does
    limit the usefulness of this technique in other environments.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`print()`进行调试有几个缺点和局限性。要使用这种技术，您需要能够修改源代码并在终端中运行它，以便您可以看到`print()`函数调用的输出。在您自己的机器上的开发环境中，这不成问题，但它确实限制了这种技术在其他环境中的有用性。
- en: When you scatter calls to `print()` in your code, you can easily end up duplicating
    a lot of debugging code. For example, you may want to print timestamps (like we
    did when we were measuring how fast list comprehensions and generators were),
    or somehow build up a string with the information that you want to display. Another
    disadvantage of this technique is that it is easy to forget calls to `print()`
    in your code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在代码中分散`print()`调用时，您可能会无意中重复大量的调试代码。例如，您可能想打印时间戳（就像我们在测量列表推导和生成器速度时做的那样），或者以某种方式构建一个包含您想要显示的信息的字符串。这种技术的另一个缺点是，很容易忘记代码中的`print()`调用。
- en: For these reasons, we sometimes prefer to use a custom debugging function rather
    than just bare calls to `print()` . Let us see how.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，我们有时更喜欢使用自定义调试函数，而不是仅仅使用裸露的`print()`调用。让我们看看如何做。
- en: Debugging with a custom function
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义函数进行调试
- en: Having a custom debugging function saved in a file somewhere that you can quickly
    grab and paste into the code can be particularly useful. If you are fast, you
    can also code one on the fly. The important thing is to write it in such a way
    that it will not leave anything behind when you eventually remove the calls and
    their definitions. Therefore, *it is important to code it in a way that is completely
    self-contained* . Another good reason for this requirement is that it will avoid
    potential name clashes with the rest of the code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个地方保存一个自定义调试函数，以便您可以快速抓取并粘贴到代码中，这特别有用。如果您动作快，您也可以现场编写一个。重要的是要编写它，以便在最终删除调用及其定义时不会留下任何东西。因此，*重要的是要以完全自包含的方式编写它*。这个要求的好另一个原因是，它将避免与代码中其他部分的潜在名称冲突。
- en: 'Let us see an example of such a function:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个这样的函数的例子：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this case, we are using a keyword-only argument to be able to print a separator,
    which is a line of 40 dashes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用关键字参数来能够打印一个分隔符，即一条由40个破折号组成的线。
- en: 'The function just passes whatever is in `msg` to a call to `print()` and, if
    `print_separator` is `True` , it prints a line separator. Running the code will
    show the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数只是将`msg`中的内容传递给`print()`的调用，如果`print_separator`为`True`，它将打印一个行分隔符。运行代码将显示以下内容：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, there is no separator after the last line.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，最后一行后面没有分隔符。
- en: 'This is just one easy way to augment a simple call to the `print()` function.
    Let us see how we can calculate a time difference between calls, using one of
    Python’s tricky features to our advantage:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是增强简单`print()`函数调用的一种简单方法。让我们看看我们如何利用Python的一个巧妙特性来计算调用之间的时间差：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is a bit more complicated. First, notice that we used an `import` statement
    *inside* the `debug()` function to import the `time()` function from the `time`
    module. This allows us to avoid having to add that `import` outside the function
    and risk forgetting to remove it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点复杂。首先，注意我们在`debug()`函数内部使用了`import`语句来从`time`模块导入`time()`函数。这样做可以避免在函数外部添加`import`语句，从而降低忘记移除它的风险。
- en: Look at how we defined `timestamp` . It is a function parameter with a list
    as its default value. In *Chapter 4* , *Functions, the Building Blocks of Code*
    , we warned against using mutable defaults for parameters because the default
    value is initialized when Python parses the function, and the same object persists
    across different calls to the function. Most of the time, this is not the behavior
    you want. In this case, however, we are taking advantage of this feature to store
    a timestamp from the previous call to the function, without having to use an external
    global variable. We borrowed this trick from our studies on **closures** , a technique
    that we encourage you to read about.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们是如何定义`timestamp`的。它是一个带有列表作为默认值的函数参数。在*第4章*，*函数，代码的构建块*中，我们警告过不要为参数使用可变默认值，因为默认值是在Python解析函数时初始化的，并且相同的对象会在函数的不同调用中持续存在。大多数情况下，这不是你想要的行为。然而，在这种情况下，我们正是利用这一特性来存储函数上一次调用的时间戳，而不必使用外部全局变量。我们是从对**闭包**的研究中借用这个技巧的，这是一个我们鼓励你阅读的技巧。
- en: After printing the message, we inspect the content of the only item in `timestamp`
    . If it is `None` , we have no previous timestamp, so we set the value to the
    current time ( `#1` ). On the other hand, if we have a previous timestamp, we
    can calculate a difference (which we neatly format to three decimal digits), and
    finally, we put the current time in `timestamp` ( `#2` ).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在打印消息后，我们检查`timestamp`中的唯一项的内容。如果它是`None`，那么我们没有先前的时戳，因此我们将值设置为当前时间（`#1`）。另一方面，如果我们有一个先前的时戳，我们可以计算一个差值（我们将其格式化为三位小数），最后，我们将当前时间放入`timestamp`（`#2`）。
- en: 'Running this code outputs the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码会输出以下内容：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using a custom debug function solves some of the problems associated with just
    using `print()` . It reduces duplication of debugging code and makes it easier
    to remove all your debugging code when you no longer need it. However, it still
    requires modifying the code and running it in a console where you can inspect
    the output. Later in this chapter, we will see how we can overcome those difficulties
    by adding logging to our code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义的调试函数解决了仅使用`print()`时的一些问题。它减少了调试代码的重复，并在你不再需要时更容易移除所有调试代码。然而，它仍然需要修改代码并在可以检查输出的控制台中运行它。在本章的后面部分，我们将看到如何通过向代码中添加日志记录来克服这些困难。
- en: Using the Python debugger
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Python调试器
- en: Another effective way of debugging Python is to use an interactive debugger.
    The Python standard library module `pdb` provides such a debugger; however, we
    usually prefer to use the third-party `pdbpp` package. `pdbpp` is a drop-in replacement
    for `pdb` , with a somewhat friendlier user interface and some handy additional
    tools, our favorite of which is *sticky mode* , which allows you to see a whole
    function while you step through its instructions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种有效的调试Python的方法是使用交互式调试器。Python标准库模块`pdb`提供了一个这样的调试器；然而，我们通常更喜欢使用第三方`pdbpp`包。`pdbpp`是`pdb`的替代品，拥有一个相对友好的用户界面和一些实用的额外工具，我们最喜欢的是*粘性模式*，它允许你在单步执行指令时看到整个函数。
- en: There are a few different ways to activate the debugger (if you have the `pdbpp`
    package installed, it will be loaded instead of the standard `pdb` debugger).
    The most common approach is to add a call invoking the debugger to your code.
    This is known as adding a **breakpoint** to the code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 激活调试器（如果你已经安装了`pdbpp`包，它将代替标准的`pdb`调试器）有几种不同的方法。最常见的方法是在你的代码中添加一个调用调试器的调用。这被称为在代码中添加**断点**。
- en: When the code is run and the interpreter reaches the breakpoint, execution is
    suspended, and you get console access to an interactive debugger session. You
    can then inspect all the names in the current scope, and step through the program
    one line at a time. You can also alter data on the fly to change the flow of the
    program.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码运行并且解释器达到断点时，执行会暂停，你将获得对交互式调试会话的控制台访问权限。然后你可以检查当前作用域中的所有名称，并逐行执行程序。你还可以实时更改数据以改变程序的流程。
- en: 'As a toy example, suppose we have a program that receives a dictionary and
    a tuple of keys as input. It then processes the dictionary items with the given
    keys. The program is raising a `KeyError` because one of the keys is missing from
    the dictionary. Suppose we cannot control the input (perhaps it comes from a third-party
    API), but we want to get past the error so that we can verify that our program
    would behave correctly on valid input. Let us see how we could use the debugger
    to interrupt the program, inspect and fix the data, and then allow execution to
    proceed:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 作为玩具示例，假设我们有一个程序，该程序接收一个字典和一个键的元组作为输入。然后它使用给定的键处理字典项。程序正在引发`KeyError`，因为其中一个键在字典中缺失。假设我们无法控制输入（可能来自第三方API），但我们想绕过错误，以便我们可以验证我们的程序在有效输入上是否表现正确。让我们看看我们如何可以使用调试器中断程序，检查并修复数据，然后允许执行继续：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see, this code will break when `key` gets the value `"third"` ,
    which is missing from the dictionary. Remember, we’re pretending that both `d`
    and `keys` come from an input source that we cannot control. If we run the code
    as it is, we get the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当`key`获得值为`"third"`时，这个值在字典中缺失，代码会中断。记住，我们假装`d`和`keys`都来自我们无法控制的输入源。如果我们按原样运行代码，我们会得到以下结果：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We see that that `key` is missing from the dictionary, but since every time
    we run this code, we may get a different dictionary or `keys` tuple, this information
    does not really help us. We want to inspect and modify the data while the program
    is running, so let us insert a breakpoint just before the `for` loop. In modern
    versions of Python, the simplest way of doing this is to call the built-in `breakpoint()`
    function:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现字典中缺少了`key`，但由于每次运行此代码时，我们可能会得到不同的字典或`keys`元组，这个信息实际上并没有真正帮助我们。我们希望在程序运行时检查和修改数据，因此让我们在`for`循环之前插入一个断点。在Python的现代版本中，这样做最简单的方法是调用内置的`breakpoint()`函数：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Before Python 3.7, you would have needed to import the `pdb` module and call
    the `pdb.set_trace()` function:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3.7之前，你需要导入`pdb`模块并调用`pdb.set_trace()`函数：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that we have used a semi-colon to separate multiple statements on the same
    line. PEP 8 discourages this, but it is quite common when setting a breakpoint
    like this, as there are fewer lines to remove when you no longer need the breakpoint.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用分号来分隔同一行上的多个语句。PEP 8不鼓励这样做，但在设置此类断点时相当常见，因为当你不再需要断点时，要删除的行更少。
- en: The `breakpoint()` function calls `sys.breakpointhook()` , which, in turn, calls
    `pdb.set_trace()` . You can override the default behavior of `sys.breakpointhook()`
    by setting the `PYTHONBREAKPOINT` environment variable to point to an alternative
    function to import and call instead of `pdb.set_trace()` .
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`breakpoint()`函数调用`sys.breakpointhook()`，它反过来调用`pdb.set_trace()`。你可以通过将`PYTHONBREAKPOINT`环境变量设置为指向一个替代函数来覆盖`sys.breakpointhook()`的默认行为，而不是调用`pdb.set_trace()`。'
- en: 'The code for this example is in the `pdebugger_pdb.py` module. If we now run
    this code, things get interesting (note that your output may vary a little and
    that all the comments in this output were added by us):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的代码位于`pdebugger_pdb.py`模块中。如果我们现在运行此代码，事情会变得有趣（注意你的输出可能略有不同，并且此输出中的所有注释都是我们添加的）：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: First, note that when you reach a breakpoint, you are served a console that
    tells you where you are (the Python module) and which line is the next one to
    be executed. You can, at this point, perform some exploratory actions, such as
    inspecting the code before and after the next line, printing a stack trace, and
    interacting with the objects. In our case, we first inspect the `keys` tuple.
    We also inspect the keys of `d` . We see that `'third'` is missing, so we put
    it in ourselves (could this be dangerous? Think about it.). Finally, now that
    all the keys are in, we type `c` to continue normal execution.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意，当你达到断点时，你会看到一个控制台，它会告诉你你在哪里（Python 模块）以及下一行将要执行的代码。在这个时候，你可以执行一些探索性操作，例如检查下一行之前和之后的代码，打印堆栈跟踪，以及与对象交互。在我们的例子中，我们首先检查
    `keys` 元组。我们还检查了 `d` 的键。我们发现 `'third'` 缺失，所以我们自己添加了它（这会危险吗？想想看）。最后，现在所有的键都已经添加完毕，我们输入
    `c` 来继续正常执行。
- en: The debugger also gives you the ability to execute your code one line at a time
    using the `n` command (for next). You can use the `s` command to step into a function
    for deeper analysis or set additional breakpoints with the `b` command. For a
    complete list of commands, please refer to the documentation (which you can find
    at [https://docs.python.org/3.12/library/pdb.html](https://docs.python.org/3.12/library/pdb.html)
    ) or type `h` (for help) in the debugger console.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器还允许你使用 `n` 命令（对于下一个）逐行执行你的代码。你可以使用 `s` 命令进入函数以进行更深入的分析，或者使用 `b` 命令设置额外的断点。有关命令的完整列表，请参阅文档（您可以在
    [https://docs.python.org/3.12/library/pdb.html](https://docs.python.org/3.12/library/pdb.html)
    找到）或在使用调试器控制台时输入 `h`（对于帮助）。
- en: You can see, from the output of the preceding run, that we could finally get
    to the end of the validation.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的运行输出中，你可以看到我们最终到达了验证的末尾。
- en: '`pdb` (or `pdbpp` ) is an invaluable tool that we use every day. So, please
    experiment with it. Set a breakpoint somewhere and try to inspect it, follow the
    official documentation, and try the commands in your code to see their effect
    and learn them well.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`pdb`（或 `pdbpp`）是我们每天都会使用的无价工具。所以，请尝试使用它。在某个地方设置一个断点并尝试检查它，遵循官方文档，并在你的代码中尝试命令以查看它们的效果并熟练掌握它们。'
- en: Notice that, in this example, we have assumed you installed `pdbpp` . If that
    is not the case, then you might find that some commands behave a bit differently
    in plain `pdb` . One example is the letter *d* , which `pdb` interprets as the
    *down* command. To get around that, you would have to add an `!` in front of `d`
    to tell `pdb` that it is meant to be interpreted literally, and not as a command.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个例子中，我们假设你已经安装了 `pdbpp`。如果情况不是这样，你可能会发现一些命令在普通的 `pdb` 中表现略有不同。一个例子是字母 *d*，`pdb`
    将其解释为 *down* 命令。为了解决这个问题，你需要在 `d` 前面加上一个 `!` 来告诉 `pdb` 它应该被字面地解释，而不是作为一个命令。
- en: Inspecting logs
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查日志
- en: Another way of debugging a misbehaving application is to inspect its logs. A
    **log** is an ordered list of events that occurred or actions that were taken
    during the running of an application. If a log is written to a file on disk, it
    is known as a **log file** .
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种调试表现不佳的应用程序的方法是检查其日志。**日志**是按顺序排列的事件列表，这些事件是在应用程序运行期间发生或采取的动作。如果日志被写入磁盘上的文件，它就被称为**日志文件**。
- en: Using logs for debugging is, in some ways, similar to adding `print()` calls
    or using a custom debug function. The key difference is that we typically add
    logging to our code from the start to aid future debugging, rather than adding
    it during debugging and then removing it again. Another difference is that logging
    can easily be configured to output to a file or a network location. These two
    aspects make logging ideal for debugging code that is running on a remote machine
    that you might not have direct access to.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用日志进行调试在某些方面与添加 `print()` 调用或使用自定义调试函数相似。关键区别在于，我们通常从一开始就在代码中添加日志以帮助未来的调试，而不是在调试期间添加它然后再移除。另一个区别是，日志可以轻松地配置为输出到文件或网络位置。这两个方面使得日志非常适合调试可能无法直接访问的远程机器上运行的代码。
- en: The fact that logging is usually added to the code before a bug has occurred
    does pose the challenge of deciding what to log. We would typically expect to
    find entries in the logs corresponding to the start and completion (and potentially
    also intermediate steps) of any important process that takes place within the
    application. The values of important variables should be included in these log
    entries. Errors also need to be logged so that if a problem occurs, we can inspect
    the logs to find out what went wrong.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 事实是，日志记录通常是在发生错误之前添加到代码中的，这确实提出了决定记录什么内容的挑战。我们通常会期望在日志中找到与应用程序内发生的任何重要过程的开始、完成（以及可能的中途步骤）相对应的条目。重要变量的值应包含在这些日志条目中。错误也需要被记录，这样如果出现问题，我们可以检查日志以找出出了什么问题。
- en: 'Nearly every aspect of logging in Python can be configured in various ways.
    This gives us a lot of power, as we can change where logs are output to, which
    log messages are output, and how log messages are formatted, simply by changing
    the logging configuration and without changing any other code. The four main types
    of objects involved in logging in Python are:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的日志记录几乎各个方面都可以以各种方式配置。这赋予我们很大的权力，因为我们可以通过更改日志配置来改变日志输出的位置、输出的日志消息以及日志消息的格式，而无需更改任何其他代码。在Python中涉及日志记录的四个主要类型的对象是：
- en: '**Loggers** : Expose the interface that the application code uses directly'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志记录器**：暴露应用程序代码直接使用的接口'
- en: '**Handlers** : Send the log records (created by loggers) to the appropriate
    destination'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理器**：将日志记录（由日志记录器创建）发送到适当的目的地'
- en: '**Filters** : Provide a finer-grained facility for determining which log records
    to output'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过滤器**：提供了一种更细粒度的设施来决定要输出哪些日志记录'
- en: '**Formatters** : Specify the layout of the log records in the final output'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**格式化器**：指定最终输出中日志记录的布局'
- en: Logging is performed by calling methods on instances of the `Logger` class.
    Each line you log has a severity level associated with it. The most commonly used
    levels are `DEBUG` , `INFO` , `WARNING` , `ERROR` , and `CRITICAL` . Loggers use
    these levels to determine which log messages to output. Anything below the logger’s
    level will be ignored. This means that you must take care to log at the appropriate
    level. If you log everything at the `DEBUG` level, you will need to configure
    your logger at (or below) the `DEBUG` level to see any of your messages. This
    can quickly result in your log files becoming extremely large. A similar problem
    occurs if you log everything at the `CRITICAL` level.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录是通过调用`Logger`类实例的方法来执行的。你记录的每一行都与一个严重级别相关联。最常用的级别是`DEBUG`、`INFO`、`WARNING`、`ERROR`和`CRITICAL`。日志记录器使用这些级别来确定要输出哪些日志消息。低于日志记录器级别的任何内容都将被忽略。这意味着你必须小心地以适当的级别进行日志记录。如果你以`DEBUG`级别记录一切，你需要将你的日志记录器配置在`DEBUG`级别或以下，才能看到任何消息。这可能会迅速导致你的日志文件变得非常大。如果你以`CRITICAL`级别记录一切，也会出现类似的问题。
- en: Python gives you several choices of where to log to. You can log to a file,
    a network location, a queue, a console, your operating system’s logging facilities,
    and so on. Where you send your logs will typically depend very much on the context.
    For example, when you run your code in your development environment, you will
    typically log to your terminal. If your application runs on a single machine,
    you might log to a file or send your logs to the operating system’s logging facilities.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Python为你提供了多个选择来记录日志。你可以将日志记录到文件、网络位置、队列、控制台、操作系统的日志设施等。你发送日志的位置通常非常依赖于上下文。例如，当你在你开发环境中运行你的代码时，你通常会记录到你的终端。如果你的应用程序在单个机器上运行，你可能将日志记录到文件或将日志发送到操作系统的日志设施。
- en: On the other hand, if your application uses a distributed architecture that
    spans multiple machines (such as in the case of service-oriented or microservice
    architectures), it is better to implement a centralized solution for logging so
    that all log messages coming from each service can be stored and investigated
    in a single place. This makes debugging much easier because trying to correlate
    giant files from multiple sources to figure out what went wrong can become truly
    challenging.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你的应用程序使用跨越多个机器的分布式架构（例如在面向服务的或微服务架构的情况下），那么实现一个集中式的日志记录解决方案会更好，这样每个服务的所有日志消息都可以存储和调查在一个地方。这使得调试变得容易得多，因为试图将来自多个来源的巨大文件关联起来以找出出了什么问题，可能会变得真正具有挑战性。
- en: A **service-oriented architecture** ( **SOA** ) is an architectural pattern
    in software design in which application components provide services to other components
    via a communications protocol, typically over a network. The beauty of this system
    is that, when coded properly, each service can be written in the most appropriate
    language to serve its purpose. The only thing that matters is the communication
    with the other services, which needs to happen via a common format so that data
    exchange can be done.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向服务的架构**（**SOA**）是软件设计中的一个架构模式，其中应用程序组件通过通信协议（通常是网络）向其他组件提供服务。这个系统的美妙之处在于，当代码编写得当，每个服务都可以用最合适的语言来编写，以实现其目的。唯一重要的是与其他服务的通信，这需要通过一个公共格式来实现，以便进行数据交换。'
- en: '**Microservice architectures** are an evolution of SOAs but follow a different
    set of architectural patterns.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**微服务架构**是SOA的演变，但遵循不同的架构模式。'
- en: 'The downside of the configurability of Python’s logging is that the logging
    machinery is somewhat complex. Fortunately, the defaults are often sufficient,
    and you only need to override settings when you have a specific need for customization.
    Let us see a simple example of logging a few messages to a file:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Python的日志记录的可配置性的缺点是日志机制相对复杂。幸运的是，默认设置通常足够，你只有在有特定定制需求时才需要覆盖设置。让我们看看将几条消息记录到文件中的简单示例：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: First, we import the `logging` module, then we set up a basic configuration.
    We specify a filename, configure the logger to output any log messages with the
    level `DEBUG` or higher, and set the message format. We want to log the date and
    time information, the level, and the message.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入`logging`模块，然后设置基本配置。我们指定一个文件名，配置记录器以输出任何级别为`DEBUG`或更高的日志消息，并设置消息格式。我们希望记录日期和时间信息、级别和消息。
- en: With the configuration in place, we can start logging. We start by logging an
    `info` message that tells us we are about to process our list. Inside the loop,
    we will log the value at each position (we use the `debug()` function to log at
    the `DEBUG` level). We use `debug()` here so that we can filter out these logs
    in the future (by configuring the logger’s `level` to `logging.INFO` or more)
    because we might have to handle large lists, and we do not want to always log
    all the values.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置到位后，我们可以开始记录日志。我们首先记录一条`info`消息，告诉我们我们即将处理我们的列表。在循环内部，我们将记录每个位置上的值（我们使用`debug()`函数在`DEBUG`级别记录）。我们在这里使用`debug()`是为了将来能够过滤掉这些日志（通过配置记录器的`level`为`logging.INFO`或更高），因为我们可能需要处理大型列表，我们不希望总是记录所有值。
- en: If we get `IndexError` (and we do, since we are looping over `range(4)` ), we
    call `logging.exception()` , which logs at the `ERROR` level, but also outputs
    the exception traceback.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遇到`IndexError`（我们确实遇到了，因为我们正在遍历`range(4)`），我们调用`logging.exception()`，它在`ERROR`级别记录，但也会输出异常回溯。
- en: 'At the end of the code, we log another `info` message to say that we are done.
    After running this code, we will have a new `ch11.log` file with the following
    content:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的末尾，我们记录了一条另一个`info`消息，表示我们已经完成。运行此代码后，我们将有一个新的`ch11.log`文件，其中包含以下内容：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is precisely what we need to be able to debug an application that is running
    on a remote machine, rather than our own development environment. We can see what
    our code did, the traceback of any exception raised, and so on.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们能够调试运行在远程机器上的应用程序而不是我们自己的开发环境所需要的东西。我们可以看到我们的代码做了什么，任何抛出的异常的回溯，等等。
- en: Feel free to modify the logging levels in the previous example, both the code
    and the configuration. This way, you’ll be able to see how the output changes
    according to your setup.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 随意修改前一个示例中的日志级别，包括代码和配置。这样，你将能够看到输出如何根据你的设置而变化。
- en: 'The example presented here only scratches the surface of logging. For a more
    in-depth explanation, you can find information in the *Python HOWTOs* section
    of the official Python documentation: *Logging HOWTO* and *Logging Cookbook* .'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供的示例只是对日志记录的表面了解。对于更深入的解释，你可以在官方Python文档的*Python HOWTOs*部分找到信息：*Logging HOWTO*和*Logging
    Cookbook*。
- en: Logging is an art. You need to find a good balance between logging everything
    and logging nothing. Ideally, you should log anything that you need to make sure
    your application is working correctly, and possibly all errors or exceptions.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 记录日志是一种艺术。你需要找到一个在记录一切和记录什么都不记录之间的良好平衡。理想情况下，你应该记录任何你需要确保应用程序正确运行的事情，以及可能的所有错误或异常。
- en: Other techniques
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他技术
- en: We will end this section on debugging by briefly mentioning a couple of other
    techniques that you may find useful.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简要提及一些其他可能对您有用的调试技术来结束本节的调试部分。
- en: Reading tracebacks
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阅读跟踪信息
- en: Bugs often manifest as unhandled exceptions. The ability to interpret an exception
    traceback is therefore a crucial skill for successful debugging. Make sure that
    you have read and understood the section on tracebacks in *Chapter 7* , *Exceptions
    and Context Managers* . If you are trying to understand why an exception happened,
    it is often useful to inspect the state of your program (using the techniques
    we discussed above) at the lines mentioned in the traceback.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 错误通常表现为未处理的异常。因此，解释异常跟踪信息是成功调试的关键技能。请确保您已经阅读并理解了*第7章*，*异常和上下文管理器*中关于跟踪信息的部分。如果您试图了解异常发生的原因，检查程序在跟踪信息中提到的行所表示的状态（使用我们上面讨论的技术）通常很有用。
- en: Assertions
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 断言
- en: 'Bugs are often the result of incorrect assumptions in our code. Assertions
    can be helpful for validating those assumptions. If our assumptions are valid,
    the assertions pass and execution proceeds normally. If they are not, we get an
    exception telling us which of our assumptions are incorrect. Sometimes, instead
    of inspecting with a debugger or `print()` statements, it is quicker to drop a
    couple of assertions in the code just to exclude possibilities. Let us see an
    example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 错误通常是我们代码中不正确假设的结果。断言可以帮助验证这些假设。如果我们的假设是有效的，断言通过并正常执行。如果它们不是，我们会得到一个异常，告诉我们哪些假设是不正确的。有时，与其使用调试器或
    `print()` 语句进行检查，不如在代码中添加几个断言来排除可能性更快。让我们看一个例子：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this example, we pretend that `mylist` comes from some external source that
    we do not control (maybe user input). The `for` loop assumes that `mylist` has
    four elements and we have added an assertion to validate that assumption. When
    we run the code, the result is this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们假设 `mylist` 来自一些外部来源，我们无法控制（可能是用户输入）。`for` 循环假设 `mylist` 有四个元素，我们添加了一个断言来验证这个假设。当我们运行代码时，结果是这个：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This tells us exactly where the problem is.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们问题确实在哪里。
- en: Running a program with the `-O` flag active will cause Python to ignore all
    assertions. This is something to keep in mind if our code depends on assertions
    to work.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当激活 `-O` 标志运行程序时，Python 将忽略所有断言。如果我们的代码依赖于断言来工作，这一点需要记住。
- en: 'Assertions also allow for a longer format that includes a second expression,
    such as:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 断言还允许更长的格式，包括第二个表达式，例如：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The second expression is passed to the `AssertionError` exception raised by
    the statement. It is typically a string with an error message. For example, if
    we changed the assertion in the last example to the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个表达式传递给由语句引发的 `AssertionError` 异常。它通常是一个包含错误信息的字符串。例如，如果我们将上一个例子中的断言更改为以下内容：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'the result would be:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Where to find information
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信息查找位置
- en: The official Python documentation contains a section dedicated to debugging
    and profiling. There, you can read about the `bdb` debugger framework and about
    modules such as `faulthandler` , `timeit` , `trace` , `tracemalloc` , and `pdb`
    .
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 官方 Python 文档包含一个专门用于调试和性能分析的章节。在那里，您可以阅读关于 `bdb` 调试框架以及 `faulthandler`、`timeit`、`trace`、`tracemalloc`
    和 `pdb` 等模块的信息。
- en: Let us now explore some troubleshooting guidelines.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在探索一些故障排除指南。
- en: Troubleshooting guidelines
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除指南
- en: In this short section, we would like to give you a few tips that come from our
    troubleshooting experience.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节简短的部分，我们想向您提供一些来自我们故障排除经验的技巧。
- en: Where to inspect
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查位置
- en: Our first suggestion concerns where to place your debugging breakpoints. Regardless
    of whether you are using `print()` , a custom function, `pdb` , or logging, you
    still have to choose where to place the calls that provide you with the information.
    Some places are definitely better than others, and there are ways to handle the
    debugging progression that are better than others.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一些建议是关于在哪里放置您的调试断点。无论您是使用 `print()`、自定义函数、`pdb` 还是日志记录，您仍然必须选择放置提供信息的调用位置。有些地方肯定比其他地方好，而且有一些处理调试进度的方法比其他方法更好。
- en: We normally avoid placing a breakpoint inside an `if` clause. If the branch
    containing the breakpoint is not executed, we lose the chance to get the information
    we want. Sometimes, it can be difficult to reproduce a bug, or it may take a while
    for your code to reach the breakpoint, so think carefully before placing them.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常避免在`if`子句内放置断点。如果包含断点的分支没有被执行，我们就失去了获取我们想要的信息的机会。有时，重现一个错误可能很困难，或者你的代码可能需要一段时间才能到达断点，所以在放置它们之前要仔细思考。
- en: Another important thing is where to start. Imagine that you have 100 lines of
    code that handle your data. Data comes in at line 1, and somehow, it is wrong
    at line 100. You do not know where the bug is, so what do you do? You can place
    a breakpoint at line 1 and patiently step through all 100 lines, checking your
    data at every step. In the worst-case scenario, 99 lines (and many cups of coffee)
    later, you spot the bug. So, consider using a different approach.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的事情是确定从哪里开始。想象一下，你有100行代码来处理你的数据。数据从第1行开始输入，不知何故，在第100行出现了错误。你不知道错误在哪里，那么你该怎么办？你可以在第1行设置一个断点，并耐心地逐行检查所有100行，检查每一步的数据。在最坏的情况下，经过99行（以及许多杯咖啡）后，你发现了错误。所以，考虑使用不同的方法。
- en: Start at line 50 and inspect. If the data is good, it means the bug happens
    later, in which case you place your next breakpoint at line 75. If the data at
    line 50 is already bad, you go on by placing a breakpoint at line 25. Then, you
    repeat. Each time, you move either backward or forward, by half the jump you did
    last time.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从第50行开始检查。如果数据是好的，这意味着错误发生在后面，在这种情况下，你将下一个断点设置在第75行。如果第50行的数据已经不好，你继续通过在第25行设置断点。然后，你重复这个过程。每次，你要么向后移动，要么向前移动，移动的距离是上一次跳跃距离的一半。
- en: In our worst-case scenario, your debugging would go from 1, 2, 3, ..., 99, in
    a linear fashion, to a series of jumps such as 50, 75, 87, 93, 96, ..., 99, which
    is much faster. In fact, it is logarithmic. This searching technique is called
    **binary search** ; it is based on a divide-and-conquer approach, and it is highly
    effective, so try to master it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们最坏的情况下，你的调试将从1, 2, 3, ..., 99，以线性方式，转变为一系列跳跃，如50, 75, 87, 93, 96, ..., 99，这要快得多。实际上，这是一种对数搜索技术。这种搜索技术被称为**二分搜索**；它基于分而治之的方法，并且非常有效，所以尽量掌握它。
- en: Using tests to debug
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用测试进行调试
- en: In *Chapter 10* , *Testing* , we briefly introduced you to **test-driven development**
    ( **TDD** ). One TDD practice that you really should adopt, even if you do not
    subscribe to TDD as a whole, is writing tests that reproduce a bug before you
    start changing your code to fix the bug. There are several reasons for this. If
    you have a bug and all tests are passing, it means something is wrong or missing
    in your test code base.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在第10章的*测试*部分，我们简要地向你介绍了**测试驱动开发**（**TDD**）。即使你并不完全接受TDD，你也应该采纳的一个TDD实践是在开始修改代码以修复错误之前，编写重现错误的测试。这样做有几个原因。如果你有一个错误，并且所有测试都通过了，这意味着你的测试代码库中可能存在错误或遗漏。
- en: 'Adding these tests will help you ensure that you really do fix the bug: the
    tests should only pass if the bug is gone. Finally, having these tests will protect
    you from inadvertently reintroducing the same bug again.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这些测试将帮助你确保你真正修复了错误：只有当错误消失时，测试才能通过。最后，拥有这些测试将保护你免得意外地再次引入相同的错误。
- en: Monitoring
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监控
- en: Monitoring is also important. Software applications can sometimes behave in
    unexpected ways in edge-case situations, such as the network being down, a queue
    being full, or an external component being unresponsive. In these cases, it is
    important to have an idea of what the big picture was when the problem occurred
    and be able to correlate it to something related to it in a subtle, perhaps mysterious,
    way.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 监控同样重要。软件应用程序有时在边缘情况下可能会表现出意外的行为，例如网络中断、队列满或外部组件无响应。在这些情况下，了解问题发生时的大致情况，并将其与相关联的微妙、甚至神秘的事物联系起来，这一点很重要。
- en: You can monitor API endpoints, processes, web pages’ availability and load times,
    and everything that you can code. In general, when starting an application from
    scratch, it can be helpful to think about how you want to monitor it from the
    earliest design stages.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以监控API端点、进程、网页的可用性和加载时间，以及你可以编码的一切。一般来说，当你从头开始启动一个应用程序时，从最早的设计阶段开始考虑你想要如何监控它可能会有所帮助。
- en: Now, let us move on to see how we can profile Python code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续看看我们如何对Python代码进行性能分析。
- en: Profiling Python
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python性能分析
- en: Profiling means having the application run while keeping track of several different
    parameters, such as the number of times a function is called, and the amount of
    time spent inside it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 分析意味着在运行应用程序的同时跟踪几个不同的参数，例如函数被调用的次数以及在其中花费的时间量。
- en: Profiling is closely related to debugging. Although the tools and processes
    used are quite different, both activities involve probing and analyzing your code
    to understand where the root of a problem lies, and then making changes to fix
    it. The difference is that instead of incorrect output or crashing, the problem
    we are trying to solve is poor performance.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 分析与调试密切相关。尽管使用的工具和过程相当不同，但这两项活动都涉及探测和分析您的代码，以了解问题的根源，然后进行更改以修复它。区别在于，我们试图解决的问题不是错误的输出或崩溃，而是性能不佳。
- en: Sometimes, profiling will point to where the performance bottleneck is, at which
    point you will need to use the debugging techniques we discussed earlier in this
    chapter to understand why a particular piece of code does not perform as well
    as it should. For example, faulty logic in a database query might result in loading
    thousands of rows from a table instead of just hundreds. Profiling might show
    you that a particular function is called many more times than expected, at which
    point you would need to use your debugging skills to work out why that is and
    address the problem.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，分析会指向性能瓶颈所在的位置，此时您需要使用本章前面讨论的调试技术来了解为什么某个特定的代码片段没有像预期的那样表现良好。例如，数据库查询中的错误逻辑可能会导致从表中加载数千行而不是数百行。分析可能会显示某个特定函数被调用的次数比预期多得多，此时您需要使用您的调试技能来找出原因并解决问题。
- en: 'There are a few ways to profile a Python application. If you look at the Profiling
    section in the standard library official documentation, you will see that there
    are two different implementations of the same profiling interface, `profile` and
    `cProfile` :'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以分析Python应用程序。如果您查看标准库官方文档中的分析部分，您将看到有两种不同的分析接口实现，`profile`和`cProfile`：
- en: '`cProfile` is written in C and adds comparatively little overhead, which makes
    it suitable for profiling long-running programs.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cProfile`是用C语言编写的，并且相对较少地增加了开销，这使得它适合分析长时间运行的程序。'
- en: '`profile` is implemented in pure Python and, as a result, adds significant
    overhead to profiled programs.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`profile`是用纯Python实现的，因此为被分析的程序增加了显著的开销。'
- en: This interface does **deterministic profiling** , which means that all function
    calls, function returns, and exception events are monitored, and precise timings
    are made for the intervals between these events. Another approach, called **statistical
    profiling** , randomly samples the program’s call stack at regular intervals and
    deduces where time is being spent.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口执行**确定性分析**，这意味着所有函数调用、函数返回和异常事件都被监控，并在这些事件之间的间隔中进行精确计时。另一种方法称为**统计分析**，在固定的时间间隔内随机采样程序的调用堆栈，并推断时间花费在哪里。
- en: The latter usually involves less overhead but provides only approximate results.
    Moreover, because of the way the Python interpreter runs the code, deterministic
    profiling does not add as much overhead as one would think, so we will show you
    a simple example using `cProfile` from the command line.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 后者通常涉及较少的开销，但只提供近似的结果。此外，由于Python解释器运行代码的方式，确定性分析并不像人们想象的那样增加很多开销，因此我们将向您展示一个使用命令行中的`cProfile`的简单示例。
- en: There are situations where even the relatively low overhead of `cProfile` is
    not acceptable, for example, if you need to profile code on a live production
    web server because you cannot reproduce the performance problem in your development
    environment. For such cases, you really do need a statistical profiler. If you
    are interested in statistical profiling for Python, we suggest you look at `py-spy`
    ( [https://github.com/benfred/py-spy](https://github.com/benfred/py-spy) ).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，即使是相对较低的开销的`cProfile`也不可接受，例如，如果您需要在实时生产Web服务器上分析代码，因为您无法在开发环境中重现性能问题。在这种情况下，您确实需要一个统计分析器。如果您对Python的统计分析感兴趣，我们建议您查看`py-spy`（[https://github.com/benfred/py-spy](https://github.com/benfred/py-spy)）。
- en: 'We are going to calculate Pythagorean triples again, using the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用以下代码计算毕达哥拉斯三元组：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The script is simple; we iterate over the interval `[1,` `mx]` with `a` and
    `b` (avoiding repetition of pairs by setting `b >= a` ) and we check whether they
    belong to a right triangle. We use `calc_hypotenuse()` to get `hypotenuse` for
    `a` and `b` , and then, with `is_int()` , we check whether it is an integer, which
    means `(a, b, hypotenuse)` is a Pythagorean triple.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本很简单；我们用`a`和`b`遍历区间`[1, mx]`（通过设置`b >= a`避免重复的配对）并检查它们是否属于直角三角形。我们使用`calc_hypotenuse()`来获取`a`和`b`的斜边，然后，使用`is_int()`检查它是否为整数，这意味着`(a,
    b, 斜边)`是一个毕达哥拉斯三元组。
- en: 'When we profile this script, we get information in a tabular form. The columns
    are `ncalls` (the number of calls to the function), `tottime` (the total time
    spent in each function), `percall` (the average time spent in each function per
    call), `cumtime` (the cumulative time spent in a function plus all functions it
    calls), `percall` (the average cumulative time spent per call), and `filename:lineno(function)`
    . Here is the result we got (to save space, we are omitting the two `percall`
    columns):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对这个脚本进行性能分析时，我们以表格形式获得信息。列包括`ncalls`（函数调用的次数）、`tottime`（每个函数花费的总时间）、`percall`（每次调用每个函数的平均时间）、`cumtime`（函数及其调用的所有函数的累积时间）、`percall`（每次调用的平均累积时间）和`filename:lineno(function)`。以下是我们的结果（为了节省空间，我们省略了两个`percall`列）：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Even with this limited amount of data, we can still infer some useful information
    about this code. First, we can see that the time complexity of the algorithm we
    have chosen grows with the square of the input size. The number of calls to `calc_hypotenuse()`
    is exactly *mx (mx + 1) / 2* . We ran the script with `mx = 1000,` and we got
    exactly 500,500 calls. Three main things happen inside the loop: we call `calc_hypotenuse()`
    , we call `is_int()` , and, if the condition is met, we append it to the `triples`
    list.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 即使只有这么有限的数据，我们仍然可以从中推断出一些关于这段代码的有用信息。首先，我们可以看到我们选择的算法的时间复杂度随着输入大小的平方增长。`calc_hypotenuse()`函数的调用次数正好是*m*x
    (m*x + 1) / 2*。我们用`mx = 1000`运行脚本，得到了正好500,500次调用。循环内部发生的三件事是：我们调用`calc_hypotenuse()`，调用`is_int()`，如果条件满足，就将它添加到`triples`列表中。
- en: Taking a look at the cumulative times in the profiling report, we notice that
    the program spent 0.147 seconds inside `is_int()` , compared to 0.102 seconds
    spent inside `calc_hypotenuse()` . These functions were called the same number
    of times, so our first target for optimization should be the more expensive `is_int()`
    .
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析性能报告中的累积时间时，我们注意到程序在`is_int()`函数内部花费了0.147秒，而`calc_hypotenuse()`函数内部则花费了0.102秒。这两个函数被调用的次数相同，因此我们优化的首要目标应该是成本更高的`is_int()`函数。
- en: If we look at the `tottime` column, we see that the program spent 0.087 seconds
    `in` `is_int()` . This excludes the 0.060 seconds spent in calls from `is_int()`
    to the `is_integer()` method of `float` objects. However, `is_int()` does not
    do anything other than call the `is_integer()` method of its parameter `n` . This
    means that just the additional function call adds an overhead of 87 milliseconds.
    In this program, there is not much benefit to having the `is_int()` function,
    so we can gain 87 milliseconds by just calling `hypotenuse.is_integer()` directly
    instead.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`tottime`列，我们会看到程序在`is_int()`中花费了0.087秒。这排除了在`is_int()`调用`float`对象的`is_integer()`方法中花费的0.060秒。然而，`is_int()`除了调用其参数`n`的`is_integer()`方法外，没有做任何事情。这意味着仅仅额外的函数调用就增加了87毫秒的开销。在这个程序中，`is_int()`函数并没有带来太多好处，因此我们可以通过直接调用`hypotenuse.is_integer()`来节省87毫秒。
- en: 'If we rerun the profiling, we see that we now spend more time in `calc_hypotenuse()`
    than in the `is_integer()` method. Let us see if we can improve that as well.
    As we mentioned in *Chapter 5* , *Comprehensions and Generators* , using the `**`
    power operator to calculate the square of a number is more expensive than multiplying
    it by itself. With that in mind, we can try to improve performance by changing
    `calc_hypotenuse()` to the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新运行性能分析，我们会看到现在我们在`calc_hypotenuse()`中花费的时间比在`is_integer()`方法中更多。正如我们在*第五章*
    *理解与生成器*中提到的，使用`**`幂运算符来计算一个数的平方比将其自身相乘要昂贵。考虑到这一点，我们可以尝试通过将`calc_hypotenuse()`更改为以下内容来提高性能：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After rerunning the profiling again, we find that the program now spends 0.084
    seconds in the `calc_hypotenuse()` function. We have gained only 18 milliseconds.
    We could potentially gain more by eliminating the overhead of the call to `calc_hypotenuse()`
    and calculating the hypotenuse directly:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行性能分析后，我们发现程序现在在`calc_hypotenuse()`函数中花费了0.084秒。我们只获得了18毫秒的改进。我们可以通过消除对`calc_hypotenuse()`函数调用的开销并直接计算斜边来获得更多的改进：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Profiling this version shows that we can gain up to 100 milliseconds in this
    way. However, we think that, in this case, the benefits of readability, maintainability,
    and testability that the function gives us outweigh the performance improvement
    of removing it.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个版本进行性能分析显示，我们可以通过这种方式获得高达100毫秒的改进。然而，我们认为，在这种情况下，函数提供的可读性、可维护性和可测试性的好处超过了移除它所带来的性能提升。
- en: You will find all four versions of this program in the source code for the book.
    We encourage you to run the profiling yourself and experiment with other changes
    to the code to see what impact they have on performance (for example, you could
    try to convert `calc_triples()` into a generator function).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本书的源代码中找到这个程序的四个版本。我们鼓励你自己运行性能分析，并尝试对代码进行其他更改以查看它们对性能的影响（例如，你可以尝试将`calc_triples()`转换为生成器函数）。
- en: This example was trivial, of course, but enough to show you how you could profile
    an application. Having the number of calls that are made to a function helps us
    better understand the time complexity of our algorithms. For example, many coders
    fail to see that those two `for` loops run proportionally to the square of the
    input size.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个例子很简单，但足以展示你如何对应用程序进行性能分析。了解对函数调用的次数可以帮助我们更好地理解算法的时间复杂度。例如，许多程序员未能意识到那两个`for`循环是与输入大小的平方成比例运行的。
- en: We have seen profiling of functions, but it is also possible to go to an even
    higher level of granularity and profile each line of a piece of code, if necessary.
    The average Python programmer will not need to do much profiling in their career,
    but it might happen, so it is good to know the options we have.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了函数的性能分析，但如果需要，也可以达到更高的粒度级别，对代码的每一行进行性能分析。平均而言，Python程序员在其职业生涯中可能不需要进行太多的性能分析，但这种情况可能会发生，因此了解我们拥有的选项是很好的。
- en: 'One thing to mention: the results of profiling will quite likely differ depending
    on what system you are running on. Therefore, it is important to be able to profile
    software on a system that is as close as possible to the one the software is deployed
    on, if not actually on it.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个需要提到的事情：性能分析的结果很可能因你所运行的系统而异。因此，如果可能的话，在尽可能接近软件部署的系统上进行软件的性能分析是很重要的，如果不是在它上面的话。
- en: In this section, we have focused on profiling and optimizing the running time
    of a program. Profiling can also be used to analyze and optimize memory usage.
    One of the most popular tools for memory profiling in Python is memray. You can
    read more about it at [https://bloomberg.github.io/memray/](https://bloomberg.github.io/memray/)
    .
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们专注于性能分析和优化程序的运行时间。性能分析也可以用来分析和优化内存使用。Python中用于内存分析的最受欢迎的工具之一是memray。你可以在[https://bloomberg.github.io/memray/](https://bloomberg.github.io/memray/)了解更多信息。
- en: When to profile
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时进行性能分析
- en: It is important to know when it is appropriate to profile, and what to do with
    the results we get. Donald Knuth once said, “ *Premature optimization is the root
    of all evil* ,” and, although we wouldn’t have put it quite so strongly, we do
    agree with him. For example, it is seldom worth sacrificing readability or maintainability
    for the sake of gaining a few milliseconds in speed.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 了解何时进行性能分析以及如何处理我们得到的结果是很重要的。唐纳德·克努特曾经说过，“*过早的优化是所有邪恶的根源*”，虽然我们不会说得这么绝对，但我们确实同意他的观点。例如，为了获得几毫秒的速度提升而牺牲可读性或可维护性通常是不值得的。
- en: Your primary concern should always be *correctness* . You want your code to
    deliver the correct results, therefore write tests, find edge cases, and stress
    your code in every way you think makes sense. Do not be protective; do not put
    things in the back of your brain for later because you think they are not likely
    to happen. Be thorough.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你的首要关注点始终应该是*正确性*。你希望你的代码能够输出正确的结果，因此编写测试，寻找边缘情况，并以你认为合理的方式对代码进行压力测试。不要过于保护；不要将事情放在大脑的后面，因为你认为它们不太可能发生。要全面考虑。
- en: 'Second, take care of coding *best practices* . Remember the following: readability,
    extensibility, loose coupling, modularity, and design. Apply OOP principles: encapsulation,
    abstraction, single responsibility, open/closed, and so on. Read up on these concepts.
    They will open horizons for you, and they will expand the way you think about
    code.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，注意编码*最佳实践*。记住以下几点：可读性、可扩展性、松散耦合、模块化、设计。应用面向对象编程（OOP）原则：封装、抽象、单一职责、开闭原则等。了解这些概念。它们将为你的视野打开新的天地，并扩展你对代码的思考方式。
- en: 'Third, *refactor* . The Boy Scouts rule says:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，*重构*。童子军规则说：
- en: Always leave the campground cleaner than you found it.
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 总是保持露营地的清洁，比找到它时更干净。
- en: Apply this rule to your code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 将此规则应用到你的代码中。
- en: Finally, when all of this has been taken care of, then and only then take care
    of optimizing and profiling.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当所有这些都已经处理完毕后，然后，并且只有然后，才开始优化和性能分析。
- en: Run your profiler and identify bottlenecks. When analyzing the profiling results,
    focus on the functions that were called the most. As we mentioned in *Chapter
    5* , *Comprehensions and Generators* , you will often gain more from even a small
    improvement to a function that is called a million times than from trying to improve
    a function that is only called a few times. When you have an idea of the bottlenecks
    you need to address, start with the worst one first. Sometimes, fixing a bottleneck
    causes a ripple effect that will expand and change the way the rest of the code
    works. Sometimes, this is only a little, and sometimes, it is a bit more, depending
    on how your code was designed and implemented. Therefore, start with the biggest
    issue first.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 运行你的分析器并识别瓶颈。在分析分析结果时，关注被调用次数最多的函数。正如我们在*第五章*，*列表推导式和生成器*中提到的，你甚至可以从对被调用一百万次的函数的微小改进中获得比尝试改进只被调用几次的函数更多的收益。当你对需要解决的瓶颈有了概念后，从最严重的一个开始。有时，修复一个瓶颈会引起连锁反应，从而改变其余代码的工作方式。有时，这种影响可能只是微小的，有时，可能更多一些，这取决于你的代码是如何设计和实现的。因此，从最大的问题开始。
- en: One of the reasons Python is so popular is that it is possible to extend it
    with modules written in faster, compiled languages like C or C++. So, if you have
    some critical piece of code and you simply cannot achieve the performance you
    need in pure Python, you always have the option of rewriting part of it in C.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Python之所以如此受欢迎，其中一个原因是它可以使用用更快、编译语言（如C或C++）编写的模块来扩展。所以，如果你有一些关键的代码，你无法在纯Python中达到所需的性能，你总是可以选择将其部分重写为C。
- en: Measuring execution time
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测量执行时间
- en: Before we finish this chapter, we want to briefly touch on the topic of measuring
    the execution time of code. Sometimes, it is helpful to measure the performance
    of small pieces of code to compare their performance. For example, if you have
    different ways of implementing some operation and you really need the fastest
    version, you may want to compare their performance without profiling your entire
    application.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成本章之前，我们想简要地讨论一下测量代码执行时间的话题。有时，测量小块代码的性能以比较它们之间的性能是有帮助的。例如，如果你有几种实现某些操作的方法，并且你真的需要最快的版本，你可能想在不分析整个应用程序的情况下比较它们的性能。
- en: We have already seen some examples of measuring and comparing execution times
    earlier in this book, for example, in *Chapter 5* , *Comprehensions and Generators*
    , when we compared the performance of `for` loops, list comprehensions, and the
    `map()` function. At this point, we would like to introduce you to a better approach,
    using the `timeit` module. This module uses techniques such as timing many repeated
    executions of the code to improve measurement accuracy.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章前面已经看到了一些测量和比较执行时间的例子，例如，在*第五章*，*列表推导式和生成器*中，当我们比较`for`循环、列表推导式和`map()`函数的性能时。在此阶段，我们想向您介绍一种更好的方法，即使用`timeit`模块。此模块使用诸如多次重复执行代码以改进测量精度等技术。
- en: 'The `timeit` module can be a bit tricky to use. We recommend that you read
    about it in the official Python documentation and experiment with the examples
    there until you understand how to use it. Here, we will just give a brief demonstration
    of using the command-line interface to time our two different versions of `calc_hypotenuse()`
    from the previous example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeit`模块可能有点难以使用。我们建议你在官方Python文档中阅读有关内容，并在那里尝试示例，直到你理解如何使用它。在这里，我们只简要演示如何使用命令行界面来测量上一个例子中`calc_hypotenuse()`的两个不同版本的执行时间：'
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, we are running the `timeit` module, initializing variables `a = 2` and
    `b = 3` , before timing the execution of `(a**2 + b**2) ** .5` . In the output,
    we can see that `timeit` ran 5 repetitions timing 5,000,000 loop iterations executing
    our calculation. Out of those 5 repetitions, the best average execution time over
    5,000,000 iterations was 91 nanoseconds. Let us see how the alternative calculation,
    `(a*a + b*b) ** .5` , performs:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在运行`timeit`模块，初始化变量`a = 2`和`b = 3`，然后在执行`(a**2 + b**2) ** .5`之前计时。在输出中，我们可以看到`timeit`运行了5次重复，每次重复计时5,000,000次循环迭代执行我们的计算。在这5次重复中，5,000,000次迭代中的最佳平均执行时间为91纳秒。让我们看看替代计算`(a*a
    + b*b) ** .5`的表现：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This time, we get an average of 72.8 nanoseconds per loop. This confirms again
    that the second version is slightly faster.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们每循环的平均时间为72.8纳秒。这再次证实了第二个版本稍微快一点。
- en: The `timeit` module automatically chooses the number of iterations to ensure
    the total running time is at least 0.2 seconds. This helps to improve accuracy
    by reducing the relative impact of measurement overhead.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeit`模块会自动选择迭代次数，以确保总运行时间至少为0.2秒。这有助于通过减少测量开销的相对影响来提高准确性。'
- en: For further information about measuring Python performance, make sure you check
    out `pyperf` ( [https://github.com/psf/pyperf](https://github.com/psf/pyperf)
    ) and `pyperformance` ( [https://github.com/python/pyperformance](https://github.com/python/pyperformance)
    ).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 关于测量Python性能的更多信息，请确保查看`pyperf` ([https://github.com/psf/pyperf](https://github.com/psf/pyperf))
    和 `pyperformance` ([https://github.com/python/pyperformance](https://github.com/python/pyperformance))。
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this short chapter, we looked at different techniques and suggestions for
    debugging, troubleshooting, and profiling our code. Debugging is an activity that
    is always part of a software developer’s work, so it is important to be good at
    it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的章节中，我们探讨了调试、故障排除和代码性能分析的不同技术和建议。调试是软件开发者工作的一部分，因此掌握它很重要。
- en: If approached with the correct attitude, it can be fun and rewarding.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以正确的心态去面对，这可以是一件有趣且有益的事情。
- en: We explored techniques to inspect our code using custom functions, logging,
    debuggers, traceback information, profiling, and assertions. We saw simple examples
    of most of them. We also discussed some guidelines that will help when it comes
    to facing the fire.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了使用自定义函数、日志记录、调试器、跟踪信息、性能分析和断言来检查我们的代码的技术。我们看到了其中大多数的简单示例。我们还讨论了一些有助于应对挑战的指导方针。
- en: Remember always to *stay calm and focused* , and debugging will be much easier.
    This, too, is a skill that needs to be learned and it is the most important. An
    agitated and stressed mind cannot work properly, logically, and creatively. Therefore,
    if you do not strengthen it, it will be difficult for you to put all your knowledge
    to good use. So, when facing a difficult bug, if you have the opportunity, make
    sure you go for a short walk or take a power nap—relax. Often, the solution presents
    itself after a good break.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 总是记得要*保持冷静和专注*，这样调试将会容易得多。这也是一种需要学习并且最重要的技能。一个焦躁和紧张的大脑无法正常、逻辑和创造性地工作。因此，如果你不加强它，你将很难充分利用你的知识。所以，当你面对一个棘手的bug时，如果你有机会，确保你进行短暂的散步或小憩——放松。通常，在良好的休息之后，解决方案就会显现出来。
- en: In the next chapter, we are going to explore type hinting and the use of static
    type checkers, which can be useful for reducing the likelihood of certain types
    of bugs.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨类型提示和静态类型检查器的使用，这有助于减少某些类型错误的可能性。
- en: Join our community on Discord
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的社区Discord
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的社区Discord空间，与作者和其他读者进行讨论：
- en: '[https://discord.com/invite/uaKmaz7FEC](Chapter_11.xhtml)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[加入我们的Discord社区](https://discord.com/invite/uaKmaz7FEC)'
- en: '![img](img/QR_Code119001106417026468.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/QR_Code119001106417026468.png)'
