- en: '*Chapter 15*: The Global Interpreter Lock'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第15章*: 全局解释器锁'
- en: One of the major players in Python concurrent programming is the **Global Interpreter
    Lock** (**GIL**). In this chapter, we will cover a definition and the purposes
    of the GIL and how it affects concurrent Python applications. The problems that
    the GIL poses for Python concurrent systems and the controversy around its implementation
    will also be discussed. Finally, we will mention some thoughts on how Python programmers
    and developers should think about, and interact with, the GIL.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python并发编程的主要参与者之一是**全局解释器锁**（**GIL**）。在本章中，我们将介绍GIL的定义和目的，以及它如何影响Python的并发应用程序。我们还将讨论GIL对Python并发系统造成的问题以及其实现周围的争议。最后，我们将提及一些关于Python程序员和开发者应该如何思考和与GIL互动的想法。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introducing the GIL
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入GIL
- en: The potential removal of the GIL from Python
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Python中移除GIL的可能性
- en: Working with the GIL
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与GIL协同工作
- en: While our discussions in this chapter will mostly be theoretical, we will be
    able to gain a deep insight into the ecosystem of concurrent programming in Python.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本章的讨论将主要侧重于理论，但我们仍能深入了解Python并发编程的生态系统。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code for this chapter can be found in the following GitHub repository:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下GitHub仓库中找到：
- en: '[https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter15](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter15)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter15](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter15)'
- en: Introducing the GIL
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入GIL
- en: The GIL is quite popular in the Python concurrent programming community. Designed
    as a lock that will only allow one thread to access and control the Python interpreter
    at any given time, the GIL in Python is often known as *the infamous GIL* that
    prevents multithreaded programs from reaching their fully optimized speed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: GIL在Python并发编程社区中相当流行。它被设计为一个锁，在任何给定时间只允许一个线程访问和控制Python解释器，Python中的GIL通常被称为*臭名昭著的GIL*，它阻止了多线程程序达到其完全优化的速度。
- en: 'In this section, we will discuss the concept behind the GIL, as well as its
    purpose: why it was designed and implemented and how it affects multithreaded
    programming in Python.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论GIL背后的概念，以及其目的：为什么它被设计和实现，以及它如何影响Python中的多线程编程。
- en: Analyzing memory management in Python
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析Python中的内存管理
- en: Before we jump into the specifics of the GIL and its effects, let's consider
    the problems that Python core developers encountered during the early days of
    Python that gave rise to a need for the GIL. Specifically, there is a significant
    difference between Python programming and programming in other popular languages,
    in terms of managing objects in the memory space.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨GIL及其影响的具体细节之前，让我们考虑一下Python核心开发者在Python早期遇到的问题，这些问题导致了GIL的需求。具体来说，在内存空间中管理对象方面，Python编程与其他流行语言编程之间存在显著差异。
- en: For example, in the programming language C++, a variable is actually a location
    in the memory space where a value will be written. This setup leads to the fact
    that, when a non-pointer variable is assigned with a specific value, the programming
    language will effectively copy that specific value to the memory location (that
    is, the **variable**). Additionally, when a variable is assigned with another
    variable (that is not a pointer), the memory location of the latter will be copied
    to that of the former; no further connection between these two variables will
    be maintained after the assignment.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在C++编程语言中，一个变量实际上是在内存空间中的一个位置，值将被写入该位置。这种设置导致，当一个非指针变量被赋予一个特定的值时，编程语言将有效地将那个特定的值复制到内存位置（即，**变量**）。此外，当一个变量被赋予另一个变量（不是指针）时，后者的内存位置将被复制到前者；在赋值之后，这两个变量之间将不再保持任何进一步的连接。
- en: On the other hand, Python considers a variable as simply a name, while the actual
    values of its variables are isolated in another region in the memory space. When
    a value is assigned to a variable, the variable is effectively given a reference
    to the location in the memory space of the value (even though the term *referencing*
    is not used in the same sense as C++ referencing). Memory management in Python
    is, therefore, fundamentally different from the model of putting a value into
    a memory space that we see in C++.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Python将变量视为一个简单的名称，而其实际的变量值被隔离在内存空间中的另一个区域。当一个值被分配给变量时，变量实际上被赋予了指向该值在内存空间中位置的引用（即使术语*引用*在C++引用的同一意义上并未使用）。因此，Python的内存管理在本质上与我们在C++中看到的将值放入内存空间的模型不同。
- en: This means that when an assignment instruction is executed, Python simply interacts
    with references and switches them around—not the actual values themselves. Also,
    for this reason, multiple variables can be referenced by the same value, and the
    changes made by one variable will be reflected throughout all of the other associated
    variables.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当执行赋值指令时，Python只是与引用交互并交换它们——而不是实际的值本身。也因为如此，多个变量可以引用同一个值，一个变量的更改将反映在所有其他相关联的变量上。
- en: 'Let''s analyze this feature in Python. If you have already downloaded the code
    for this book from the GitHub page, go ahead and navigate to the `Chapter15` folder.
    Let''s take a look at the `Chapter15/example1.py` file here:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析Python中的这一特性。如果您已经从GitHub页面下载了本书的代码，请继续导航到`Chapter15`文件夹。让我们在这里查看`Chapter15/example1.py`文件：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this example, we are looking at the management of the value `[7]` (a list
    of one element: the integer `7`). We mentioned that values in Python are stored
    independently of variables, and value management in Python simply references variables
    to the appropriate values. The `sys.getrefcount()` method in Python takes in an
    object and returns the counter of all references that the value associated with
    that object has. Here, we are calling `sys.getrefcount()` three times: on the
    actual value, `[7]`; the variable `a` that is assigned the value; and finally,
    the variable `b` that is assigned with the variable `a`.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在查看值`[7]`（一个包含一个元素：整数`7`）的管理。我们提到Python中的值是独立于变量存储的，Python中的值管理只是将变量引用到适当的值。Python中的`sys.getrefcount()`方法接受一个对象，并返回与该对象相关联的值的所有引用计数器。在这里，我们三次调用`sys.getrefcount()`：在真实值`[7]`上；分配值的变量`a`；最后，分配变量的变量`b`。
- en: 'Additionally, we are exploring the process of mutating the value by using a
    variable referenced with it and the resulting values of all of the variables associated
    with that value. Specifically, we are mutating the first element of the list via
    variable `a`, and printing out the values of both `a` and `b`. Run the script,
    and your output should be similar to this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们正在探索通过使用引用该变量的变量来更改值的过程以及所有与该值相关的变量的结果值。具体来说，我们通过变量`a`更改列表的第一个元素，并打印出`a`和`b`的值。运行脚本，您的输出应该类似于以下内容：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, this output is consistent with what we discussed as the following
    ways:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个输出与我们讨论的以下方式一致：
- en: For the first `sys.getrefcount()` function call, there is only one reference
    count for the value `[7]`, which is created when we directly reference it.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第一个`sys.getrefcount()`函数调用，值`[7]`只有一个引用计数，这是当我们直接引用它时创建的。
- en: When we assign the list to variable `a`, the value has two references, since
    `a` is now associated with the value.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们将列表分配给变量`a`时，该值有两个引用，因为`a`现在与该值相关联。
- en: Finally, when `a` is assigned to `b`, `[7]` is additionally referenced by `b`,
    and the reference count is now `3`.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当`a`被分配给`b`时，`[7]`被`b`额外引用，引用计数现在是`3`。
- en: In the output of the second part of the program, we can see that when we changed
    the value of the variable that `a` references, `[7]` was mutated instead of variable
    `a`. As a result, variable `b`, which was referencing the same value as `a`, also
    had its value changed.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在程序第二部分的输出中，我们可以看到当我们改变变量`a`所引用的值时，是`[7]`发生了变化，而不是变量`a`本身。因此，引用与`a`相同值的变量`b`的值也发生了改变。
- en: 'The following diagram illustrates this process:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图解说明了这一过程：
- en: '![Figure 15.1 – Diagram of Python''s referencing scheme ](img/Figure_15.1_B17499.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图15.1 – Python引用方案的示意图](img/Figure_15.1_B17499.jpg)'
- en: Figure 15.1 – Diagram of Python's referencing scheme
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1 – Python引用方案的示意图
- en: Overall, in Python programs, variables simply make references to the actual
    values (objects), and an assignment statement between two variables makes the
    two variables reference the same object, as opposed to copying the actual value
    to another memory location, as in C++.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，在Python程序中，变量只是对实际值（对象）的引用，两个变量之间的赋值语句使得这两个变量引用同一个对象，而不是像C++那样将实际值复制到另一个内存位置。
- en: The problem that the GIL addresses
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GIL解决的问题
- en: Keeping Python's implementation of memory and variable management in mind, we
    can see references to a given value in Python are constantly changing in a program,
    and keeping track of the reference count for a value is therefore highly important.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到Python对内存和变量管理的实现，我们可以看到在Python程序中，对给定值的引用是不断变化的，因此跟踪值的引用计数非常重要。
- en: Now, applying what you learned in [*Chapter 14*](B17499_14_Final_SS_ePub.xhtml#_idTextAnchor244),
    *Race Conditions*, you should know that in a Python concurrent program, this reference
    count is a shared resource that needs protection from race conditions. In other
    words, this reference count is a critical section that, if handled carelessly,
    will result in an incorrect interpretation of how many variables are referencing
    a particular value. This will cause memory leaks that will make Python programs
    significantly inefficient and may even release a memory that is actually being
    referenced by some variables, losing that value forever.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，应用你在[*第14章*](B17499_14_Final_SS_ePub.xhtml#_idTextAnchor244)“竞争条件”中学到的知识，你应该知道在Python并发程序中，这个引用计数是一个共享资源，需要防止竞争条件。换句话说，这个引用计数是一个关键部分，如果处理不当，将导致对特定值引用的变量数量的错误解释。这会导致内存泄漏，使Python程序效率显著降低，甚至可能释放一些变量实际正在引用的内存，导致该值永远丢失。
- en: As you learned in the previous chapter, a solution to making sure that race
    conditions will not occur with regard to a particular shared resource is to place
    a lock on that resource, effectively allowing one thread, at the most, to access
    the resource at any given time within a concurrent program. We also discussed
    that if enough locks are placed in a concurrent program, that program will become
    entirely sequential, and no additional speed will be gained by implementing concurrency.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上一章中学到的，确保特定共享资源不会发生竞争条件的一种解决方案是在该资源上放置一个锁，有效地允许在并发程序中最多只有一个线程在任何给定时间访问该资源。我们还讨论了，如果在并发程序中放置足够的锁，那么该程序将完全变为顺序执行，实现并发不会带来额外的速度提升。
- en: The GIL is a solution to the combination of the two preceding problems, being
    one single lock on the entire execution of Python. The GIL must first be acquired
    by any Python instruction that wants to be executed (**central processing unit**
    (**CPU**)-bound tasks), preventing a race condition from occurring for any reference
    count.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: GIL是针对前两个问题的解决方案，它是对Python整个执行过程的一个单一锁。任何想要执行的Python指令（**中央处理器**（**CPU**）密集型任务）必须首先获取GIL，以防止任何引用计数发生竞争条件。
- en: In the early days of the development of the Python language, other solutions
    to the problem described here were also proposed, but the GIL was the most efficient
    and simple to implement, by far. Since the GIL is a lightweight, overarching lock
    for the entire execution of Python, no other lock needs to be implemented to guarantee
    the integrity of other critical sections, keeping the performance overhead of
    Python programs at a minimum.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python语言发展的早期，针对此处描述的问题也提出了其他解决方案，但GIL（全局解释器锁）因其高效和易于实现而成为迄今为止最有效的方案。由于GIL是Python整个执行过程中的一个轻量级、全局的锁，因此无需实现其他锁来保证其他关键部分的完整性，从而将Python程序的性能开销保持在最低。
- en: Problems raised by the GIL
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GIL引起的问题
- en: 'Intuitively, with a lock guarding all CPU-bound tasks in Python, a concurrent
    program will not be able to become fully multithreading. The GIL effectively prevents
    CPU-bound tasks from being executed in parallel across multiple threads. To understand
    the effect of this feature of the GIL, let''s consider an example in Python. Navigate
    to `Chapter15/example2.py`, which has the following content:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 直观地说，由于Python中所有CPU密集型任务都受到锁的保护，并发程序将无法完全多线程化。GIL有效地防止了CPU密集型任务在多个线程之间并行执行。为了理解GIL这一特性的影响，让我们考虑一个Python的例子。导航到`Chapter15/example2.py`，该文件包含以下内容：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, we are comparing the speed of executing a particular program
    in Python sequentially and concurrently, via multithreading. Specifically, we
    have a function named `countdown()` that simulates a heavy CPU-bound task, which
    takes in a number, `n`, and decrements it until it becomes zero or negative. We
    then call `countdown()` on `50,000,000` once, as a sequential program. Finally,
    we call the function twice, each in a separate thread, on `25,000,000`, which
    is exactly half of `50,000,000`; this is the multithreading version of the program.
    We are also keeping track of the time it takes for Python to run both the sequential
    program and the multithreading program.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在比较在Python中顺序和并发执行特定程序的速度，通过多线程实现。具体来说，我们有一个名为`countdown()`的函数，它模拟了一个重CPU密集型任务，它接受一个数字`n`，并将其递减到零或负数。然后我们以顺序程序的方式调用`countdown()`一次`50,000,000`。最后，我们在`25,000,000`上调用该函数两次，每次在一个单独的线程中，这是`50,000,000`的一半；这是程序的并发版本。我们还在跟踪Python运行顺序程序和并发程序所需的时间。
- en: 'Theoretically, the multithreading version of the program should take half as
    long as the sequential version, as the task is effectively being split in half
    and run in parallel, via the two threads that we created. However, the output
    produced by the program would suggest otherwise. The following output is what
    I obtained through running the script:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，程序的并发版本应该比顺序版本快一半，因为任务实际上被分成两半，通过我们创建的两个线程并行运行。然而，程序产生的输出却表明了相反的情况。以下是通过运行脚本获得的输出：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Contrary to what we predicted, the concurrent version of the countdown took
    almost as long as the sequential version; multithreading did not offer any considerable
    speedup for our program. This is a direct effect of having the GIL guarding CPU-bound
    tasks, as multiple threads are not allowed to run simultaneously. Sometimes, a
    multithreading program can take even longer to complete its execution than its
    sequential counterpart, since there is also the overhead of acquiring and releasing
    the GIL.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的预测相反，并发版本的倒计时几乎与顺序版本一样长；多线程并没有为我们程序提供任何明显的加速。这是GIL保护CPU密集型任务的一个直接效果，因为不允许多个线程同时运行。有时，多线程程序甚至可能比其顺序版本完成执行所需的时间更长，因为还有获取和释放GIL的开销。
- en: This is undoubtedly a significant problem for multithreading, and for concurrent
    programming in Python in general, because as long as a program contains CPU-bound
    instructions, those instructions will, in fact, be sequential in the execution
    of the program. However, instructions that are not CPU-bound happen outside the
    GIL, and thus they are not affected by the GIL (for example, **input/output**
    (**I/O**)-bound instructions).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这无疑是多线程编程，尤其是Python中的并发编程的一个重大问题，因为只要程序包含CPU密集型指令，这些指令实际上在程序执行过程中将是顺序的。然而，非CPU密集型指令发生在GIL之外，因此它们不受GIL的影响（例如，**输入/输出**（**I/O**）密集型指令）。
- en: With these problems identified, let's next see what the infamous GIL is.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定了这些问题之后，让我们接下来看看臭名昭著的GIL是什么。
- en: The potential removal of the GIL from Python
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中GIL的潜在移除
- en: You have learned that the GIL sets a significant constraint on our multithreading
    programs in Python, especially those with CPU-bound tasks. For this reason, many
    Python developers have come to view the GIL in a negative light, and the term
    *the infamous GIL* has started to become popular. It is not surprising, then,
    that some have even advocated the complete removal of the GIL from the Python
    language.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解到GIL对我们的Python多线程程序设置了一个重大的限制，特别是那些具有CPU密集型任务的程序。因此，许多Python开发者开始对GIL持负面看法，*臭名昭著的GIL*这个术语也开始变得流行。因此，有些人甚至主张从Python语言中完全移除GIL，这并不令人惊讶。
- en: In fact, multiple attempts to remove the GIL have been made by prominent Python
    users. However, the GIL is so deeply implanted in the implementation of the language,
    and the execution of most libraries and packages that are not thread-safe is so
    significantly dependent on the GIL, that the removal of the GIL will actually
    engender bugs as well as backward-incompatibility issues for your Python programs.
    A number of Python developers and researchers tried to completely omit the GIL
    from Python execution, and most existing C extensions, which depend heavily on
    the functionalities of the GIL, stopped working.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，一些著名的 Python 用户已经尝试过多次移除 GIL。然而，GIL 已经深深地植根于语言的实现中，大多数不是线程安全的库和包的执行也极大地依赖于
    GIL，因此移除 GIL 实际上会给你的 Python 程序带来错误以及向后不兼容的问题。一些 Python 开发者和研究人员试图完全从 Python 执行中省略
    GIL，而大多数现有的依赖 GIL 功能的 C 扩展已经停止工作。
- en: 'Now, there are other viable solutions to address the problems that we have
    discussed; in other words, the GIL is in every way replaceable. However, most
    of these solutions contain so many complex instructions that they actually decrease
    the performance of sequential and I/O-bound programs, which are not affected by
    the GIL. So, these solutions will slow down single-threaded or multithreaded I/O
    programs, which actually make up a large percentage of existing Python applications.
    Interestingly, the creator of Python, Guido van Rossum, also commented on this
    topic in his article *It isn''t Easy to Remove the GIL*, as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，还有其他可行的解决方案来解决我们讨论过的问题；换句话说，GIL 在任何方面都是可替代的。然而，这些解决方案中包含了许多复杂的指令，实际上会降低顺序和
    I/O 密集型程序的性能，而这些程序不受 GIL 的影响。因此，这些解决方案会减慢单线程或多线程 I/O 程序的速度，而这实际上占到了现有 Python 应用程序的大比例。有趣的是，Python
    的创造者 Guido van Rossum 在他的文章《移除 GIL 并不容易》中也对此进行了评论，如下所示：
- en: '"I''d welcome a set of patches into Py3k only if the performance for a single-threaded
    program (and for a multi-threaded but I/O-bound program) does not decrease."'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: “我欢迎将一系列补丁集成到 Py3k 中，前提是单线程程序（以及多线程但 I/O 密集型程序）的性能不会降低。”
- en: Unfortunately, this request has not been achieved by any of the proposed alternatives
    to the GIL. The GIL remains an integral part of the Python language.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个请求还没有通过任何提出的 GIL 替代方案得到实现。GIL 仍然是 Python 语言的一个基本组成部分。
- en: With this covered, let's now see how to work with the GIL.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个基础上，现在让我们看看如何与 GIL 一起工作。
- en: Working with the GIL
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 GIL 一起工作
- en: There are a few ways to deal with the GIL in your Python applications, and these
    will be addressed in the following sections.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 Python 应用程序中处理 GIL 有几种方法，这些方法将在接下来的章节中讨论。
- en: Implementing multiprocessing, rather than multithreading
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现多进程，而不是多线程
- en: This is perhaps the most popular and easiest method to circumvent the GIL and
    achieve optimal speed in a concurrent program. As the GIL only prevents multiple
    threads from executing CPU-bound tasks simultaneously, processes executing over
    multiple cores of a system, each having its own memory space, are completely immune
    to the GIL.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是绕过 GIL 并在并发程序中实现最佳速度的最流行和最简单的方法。因为 GIL 只阻止多个线程同时执行 CPU 密集型任务，而跨系统多个核心执行的过程，每个过程都有自己的内存空间，对
    GIL 完全免疫。
- en: 'Specifically, considering the preceding countdown example, let''s compare the
    performance of that CPU-bound program when it is sequential, multithreading, and
    multiprocessing. Navigate to the `Chapter15/example3.py` file. The first part
    of the program is identical to what we saw earlier, but at the end, we add in
    an implementation of a multiprocessing solution for the problem of counting down
    from 50,000,000, using two separate processes, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，考虑到前面的倒计时示例，让我们比较一下当程序是顺序的、多线程的和多进程的时，这个 CPU 密集型程序的性能。导航到 `Chapter15/example3.py`
    文件。程序的前一部分与之前看到的是一样的，但在最后，我们添加了一个针对从 50,000,000 开始倒计时的多进程解决方案的实现，使用两个独立的过程，如下所示：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After running the program, this was my output:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 程序运行后，这是我的输出：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There is still a minimal difference in speed between the sequential and multithreading
    versions of the program. However, the multiprocessing version was able to cut
    that speed by almost half in its execution. As discussed in earlier chapters,
    since processes are fairly heavyweight, multiprocessing instructions contain significant
    overhead, which is the reason why the speed of the multiprocessing program was
    not exactly half of the sequential program.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的顺序和多线程版本之间仍然存在微小的速度差异。然而，多进程版本在执行过程中能够将速度降低近一半。正如前面章节所讨论的，由于进程相对较重，多进程指令包含显著的开销，这也是为什么多进程程序的速度并没有正好是顺序程序的一半。
- en: Getting around the GIL with native extensions
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用原生扩展绕过GIL
- en: There are Python-native extensions that are written in C/C++ and are therefore
    able to avoid the limitations that the GIL sets out; one example is the most popular
    Python scientific computing package, NumPy. Within these extensions, manual releases
    of the GIL can be made so that the execution can simply bypass the lock. However,
    these releases need to be implemented carefully and accompanied by the reassertion
    of the GIL before the execution goes back to the main Python execution.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些用C/C++编写的Python原生扩展，因此能够避免GIL设定的限制；一个例子是最受欢迎的Python科学计算包NumPy。在这些扩展中，可以手动释放GIL，以便执行可以简单地绕过锁。然而，这些释放需要谨慎实现，并在执行返回到主Python执行之前重新声明GIL。
- en: Utilizing a different Python interpreter
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用不同的Python解释器
- en: The GIL only exists in CPython, which is the most common interpreter for the
    language by far and is built in C. However, there are other interpreters for Python,
    such as Jython (written in Java) and IronPython (written in C++), that can be
    used to avoid the GIL and its effects on multithreading programs. Keep in mind
    that these interpreters are not as widely used as CPython, and some packages and
    libraries might not be compatible with one or both of what? please clarify.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: GIL只存在于CPython中，这是迄今为止语言最常用的解释器，是用C编写的。然而，还有其他Python解释器，如Jython（用Java编写）和IronPython（用C++编写），可以用来避免GIL及其对多线程程序的影响。请记住，这些解释器不像CPython那样广泛使用，并且一些包和库可能不与CPython兼容，或者与两者都不兼容？请澄清。
- en: Summary
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: While the GIL in Python offers a simple and intuitive solution to one of the
    more difficult problems in the language, it also raises a number of problems of
    its own, concerning the ability to run multiple threads in a Python program to
    process CPU-bound tasks. Multiple attempts have been made to remove the GIL from
    the main implementation of Python, but none has been able to achieve it while
    maintaining the effectiveness of processing non-CPU-bound tasks, which are affected
    by the GIL.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Python中的GIL为语言中更困难的问题之一提供了一个简单直观的解决方案，但它也引发了许多自身的问题，涉及在Python程序中运行多个线程以处理CPU密集型任务的能力。已经尝试过多次从Python的主要实现中移除GIL，但没有任何一种方法能够在保持处理非CPU密集型任务有效性的同时实现这一点，这些任务受到GIL的影响。
- en: Overall, we have discussed practical methods that make working with the GIL
    easier. We have also learned that while it possesses considerable notoriety among
    the Python community, the GIL only affects a certain portion of the ecosystem.
    This should better inform our opinion about the GIL.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，我们讨论了使与GIL一起工作变得更简单的实用方法。我们还了解到，尽管它在Python社区中相当有名，但GIL只影响生态系统的一部分。这应该更好地指导我们对GIL的看法。
- en: In the last four chapters, we discussed some of the most well-known and common
    problems in concurrent programming in Python. For the remainder of the book, we
    will be looking at a different topic—advanced design patterns in Python. In the
    next chapter, we will start with the *factory* pattern.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后四章中，我们讨论了Python中并发编程的一些最常见和最著名的问题。在本书的剩余部分，我们将探讨一个不同的主题——Python的高级设计模式。下一章，我们将从*工厂*模式开始。
- en: Questions
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the differences in memory management between Python and C++?
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python和C++在内存管理方面的区别有哪些？
- en: Which problem does the GIL solve for Python?
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GIL为Python解决了哪些问题？
- en: Which problem does the GIL create for Python?
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GIL为Python带来了哪些问题？
- en: What are some of the approaches to circumventing the GIL in Python programs?
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Python程序中绕过GIL有哪些方法？
- en: Further reading
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information, you can refer to the following sources:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如需更多信息，您可以参考以下资源：
- en: '*What Is the Python Global Interpreter Lock (GIL)?* ([realpython.com/python-gil/](http://realpython.com/python-gil/)),
    *Abhinav Ajitsaria*'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python全局解释器锁（GIL）是什么？* ([realpython.com/python-gil/](http://realpython.com/python-gil/)),
    *Abhinav Ajitsaria*'
- en: '*The Python GIL Visualized* ([dabeaz.blogspot.com/2010/01/python-gil-visualized](http://dabeaz.blogspot.com/2010/01/python-gil-visualized)),
    *Dave Beazley*'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python GIL可视化* ([dabeaz.blogspot.com/2010/01/python-gil-visualized](http://dabeaz.blogspot.com/2010/01/python-gil-visualized)),
    *Dave Beazley*'
- en: '*Copy Operations in Python* ([pythontic.com/modules/copy/introduction](http://pythontic.com/modules/copy/introduction))'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python中的复制操作* ([pythontic.com/modules/copy/introduction](http://pythontic.com/modules/copy/introduction))'
- en: '*It isn''t Easy to Remove the GIL* ([www.artima.com/weblogs/viewpost.jsp?thread=214235](http://www.artima.com/weblogs/viewpost.jsp?thread=214235)),
    *Guido van Rossum*'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*移除GIL并不容易* ([www.artima.com/weblogs/viewpost.jsp?thread=214235](http://www.artima.com/weblogs/viewpost.jsp?thread=214235)),
    *Guido van Rossum*'
- en: '*Parallel Programming with Python*, by *Jan Palach*, *Packt Publishing Ltd*
    (2014)'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Python进行并行编程*，由*Jan Palach*著，*Packt Publishing Ltd* (2014)'
- en: '*Learning Concurrency in Python: Build highly efficient, robust, and concurrent
    applications*, *Elliot Forbes* (2017)'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在Python中学习并发：构建高效、健壮和并发的应用程序*，*Elliot Forbes* (2017)'
