- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Integrating FastAPI with SQL Databases
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 FastAPI 与 SQL 数据库集成
- en: We’ll now embark on a journey to harness the full potential of SQL databases
    within your FastAPI applications. This chapter is meticulously designed to guide
    you through the nuances of leveraging **SQLAlchemy**, a powerful SQL toolkit and
    **object-relational** **mapping** (**ORM**) for Python. From setting up your database
    environment to implementing sophisticated **create, read, update and delete**
    (**CRUD**) operations and managing complex relationships, this chapter provides
    a comprehensive blueprint for integrating SQL databases seamlessly with FastAPI.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将开始一段旅程，充分利用 SQL 数据库在 FastAPI 应用程序中的全部潜力。本章精心设计，旨在指导你深入了解利用 **SQLAlchemy**
    的细微差别，这是一个强大的 SQL 工具包和 **对象关系映射**（**ORM**）库，适用于 Python。从设置你的数据库环境到实现复杂的 **创建、读取、更新和删除**（**CRUD**）操作，以及管理复杂的关系，本章提供了一个全面蓝图，以无缝集成
    SQL 数据库与 FastAPI。
- en: By creating a basic ticketing platform, you’ll practically engage in configuring
    SQLAlchemy with FastAPI, creating data models that reflect your application’s
    data structures, and crafting efficient, secure CRUD operations.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个基本的票务平台，你将实际参与配置 SQLAlchemy 与 FastAPI，创建反映你的应用程序数据结构的数据库模型，并构建高效、安全的 CRUD
    操作。
- en: Moreover, you’ll explore the management of database migrations with **Alembic**,
    ensuring your database schema evolves alongside your application without hassle.
    This chapter doesn’t stop at just handling data; it delves into optimizing SQL
    queries for performance, securing sensitive information within your database,
    and managing transactions and concurrency to ensure data integrity and reliability.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还将探索使用 **Alembic** 管理数据库迁移，确保你的数据库模式与你的应用程序同步发展而无需麻烦。本章不仅涉及数据处理，还深入到优化 SQL
    查询以提升性能、在数据库中保护敏感信息以及管理事务和并发，以确保数据完整性和可靠性。
- en: By the end of this chapter, you’ll be adept at integrating and managing SQL
    databases in your FastAPI applications, equipped with the skills to ensure your
    applications are not only efficient and scalable but also secure. Whether you’re
    building a new application from scratch or integrating a database into an existing
    project, the insights and techniques covered here will empower you to leverage
    the full power of SQL databases in your FastAPI projects.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将熟练地集成和管理 SQL 数据库在你的 FastAPI 应用程序中，并具备确保你的应用程序不仅高效和可扩展，而且安全的技能。无论你是从头开始构建新应用程序还是将数据库集成到现有项目中，这里涵盖的见解和技术将赋予你利用
    SQL 数据库在 FastAPI 项目中全部力量的能力。
- en: 'In this chapter, we’re going to cover the following recipes:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Setting up SQLAlchemy
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 SQLAlchemy
- en: Implementing CRUD operations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 CRUD 操作
- en: Working with migrations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与迁移一起工作
- en: Handling relationships in SQL databases
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 SQL 数据库中的关系
- en: Optimizing SQL queries for performance
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化 SQL 查询以提升性能
- en: Securing sensitive data in SQL databases
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 SQL 数据库中保护敏感数据
- en: Handling transactions and concurrency
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理事务和并发
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with all the recipes of the chapter, make sure you have these
    essentials in your setup:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章的所有食谱，请确保你的设置中包含以下基本要素：
- en: '**Python**: Your environment should have a Python version above 3.9 installed.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python**：你的环境应安装有高于 3.9 的 Python 版本。'
- en: '**FastAPI**: It should be installed in your virtual environment with all the
    dependencies it needs. If you didn’t do it in the previous chapters, you can easily
    do it from your terminal:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FastAPI**：它应该安装在你的虚拟环境中，并包含所有需要的依赖项。如果你在前几章中没有这样做，你可以很容易地从你的终端完成它：'
- en: '[PRE0]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The code that accompanies the chapter is available on GitHub at the following
    link: [https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter06](https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter06)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可在 GitHub 上的以下链接找到：[https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter06](https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter06)
- en: 'It is also advisable to create a virtual environment for the project inside
    the project root folder, to handle dependencies well and keep the project separate.
    In your virtual environment, you can install all the dependencies at once by using
    the `requirements.txt` file from the GitHub repo in the project folder:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 还建议在项目根目录内为项目创建一个虚拟环境，以更好地处理依赖关系并保持项目独立。在你的虚拟环境中，你可以通过使用项目文件夹中 GitHub 仓库的 `requirements.txt`
    文件一次性安装所有依赖项：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Since the code of the chapter will make use of the `async`/`await` syntax from
    the `asyncio` Python library, you should be already familiar with it. Feel free
    to read more about `asyncio` and `async`/`await` syntax at the following links:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章的代码将使用来自 `asyncio` Python 库的 `async`/`await` 语法，你应该已经熟悉它。请随意阅读以下链接了解更多关于
    `asyncio` 和 `async`/`await` 语法的信息：
- en: '[https://docs.python.org/3/library/asyncio.xhtml](https://docs.python.org/3/library/asyncio.xhtml)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Python 3 库文档](https://docs.python.org/3/library/asyncio.xhtml)'
- en: '[https://fastapi.tiangolo.com/async/](https://fastapi.tiangolo.com/async/)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[FastAPI 异步教程](https://fastapi.tiangolo.com/async/)'
- en: Now that we have this ready Once we have everything ready, we can begin preparing
    our recipes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了 一旦一切准备就绪，我们就可以开始准备我们的食谱。
- en: Setting up SQLAlchemy
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 SQLAlchemy
- en: To begin any data application, you need to establish a database connection.
    This recipe will help you set up and configure `sqlalchemy` package with an **SQLite**
    database so that you can use the advantages of SQL databases in your applications.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始任何数据应用，你需要建立数据库连接。本食谱将帮助你设置和配置 `sqlalchemy` 包与 **SQLite** 数据库，以便你可以在应用中使用
    SQL 数据库的优势。
- en: Getting ready
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The project is going to be fairly large, so we will put the working modules
    for the application in a folder named `app`, which will be under the root project
    folder that we will call `ticketing_system`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 项目将会相当大，因此我们将把应用的工作模块放在一个名为 `app` 的文件夹中，该文件夹位于我们称之为 `ticketing_system` 的根项目文件夹下。
- en: 'You need `fastapi`, `sqlalchemy`, and `aiosqlite` installed in your environment
    to use the recipe. The recipe is meant to work with `sqlalchemy` with versions
    above 2.0.0\. You can still use version 1; however, some adaptions are required.
    You can find a migration guide at the following link: [https://docs.sqlalchemy.org/en/20/changelog/migration_20.xhtml](https://docs.sqlalchemy.org/en/20/changelog/migration_20.xhtml).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在你的环境中安装 `fastapi`、`sqlalchemy` 和 `aiosqlite` 以使用这个食谱。这个食谱旨在与版本高于 2.0.0 的
    `sqlalchemy` 一起工作。你仍然可以使用版本 1；然而，需要一些适配。你可以在以下链接找到迁移指南：[SQLAlchemy 2.0 迁移指南](https://docs.sqlalchemy.org/en/20/changelog/migration_20.xhtml)。
- en: 'If you haven’t installed the packages with the `requirements.txt` file in the
    repo, you can do it by running the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有使用存储库中的 `requirements.txt` 文件安装包，你可以通过运行以下命令来完成：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once the packages are correctly installed, you can follow the recipe.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦包正确安装，你就可以按照食谱进行操作。
- en: How to do it...
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The setup of a generic SQL database connection with `sqlalchemy` will go through
    the following steps:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `sqlalchemy` 设置通用 SQL 数据库连接将经过以下步骤：
- en: Creating mapping object classes, that will match the database tables
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建映射对象类，以匹配数据库表
- en: Creating abstraction layers, an engine, and a session to communicate with the
    database
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建抽象层、引擎和会话以与数据库通信
- en: Initializing a database connection, at the server startup
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务器启动时初始化数据库连接
- en: Creating mapping object classes
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建映射对象类
- en: 'In the `app` folder, let’s create a module called `database.py` and then create
    a class object to track tickets as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `app` 文件夹中，让我们创建一个名为 `database.py` 的模块，然后创建一个类对象来跟踪票务，如下所示：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We just created a `Ticket` class that will be used to match the `tickets` table
    into our SQL database.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个 `Ticket` 类，它将被用来将我们的 SQL 数据库中的 `tickets` 表进行匹配。
- en: Creating abstraction layers
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建抽象层
- en: In SQLAlchemy, the *engine* manages database connections and executes SQL statements,
    while a *session* allows querying, inserting, updating, and deleting data within
    a transactional context, ensuring consistency and atomicity. Sessions are bound
    to an engine for communication with the database.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLAlchemy 中，*引擎* 管理数据库连接并执行 SQL 语句，而 *会话* 允许在事务性上下文中查询、插入、更新和删除数据，确保一致性和原子性。会话绑定到引擎以与数据库通信。
- en: 'We will start by creating a function that returns the engine. In a new module
    called `db_connection.py`, under the `app` folder, let’s write the function as
    follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个返回引擎的函数。在一个名为 `db_connection.py` 的新模块中，位于 `app` 文件夹下，让我们按照以下方式编写函数：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You may have observed that the `SQLALCHEMY_DATABASE_URL` database URL uses the
    `sqlite` and `aiosqlite` modules.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，`SQLALCHEMY_DATABASE_URL` 数据库 URL 使用了 `sqlite` 和 `aiosqlite` 模块。
- en: This implies that we will use an SQLite database where the operations will happen
    via the `aiosqlite` asynchronous library that supports the `asyncio` library.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们将使用 SQLite 数据库，操作将通过支持 `asyncio` 库的 `aiosqlite` 异步库来完成。
- en: 'Then, we will use a session maker to specify that the session will be asynchronous,
    as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用会话创建器来指定会话将是异步的，如下所示：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `get_db_session` function will be used as a dependency for each endpoint
    interacting with the database.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_db_session`函数将被用作与数据库交互的每个端点的依赖项。'
- en: Initializing a database connection
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化数据库连接
- en: 'Once we have the abstraction layers, we need to create our FastAPI server object
    and start the database classes when the server runs. We can do it in the `main.py`
    module under the `app` folder:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了抽象层，我们需要在服务器运行时创建我们的FastAPI服务器对象并启动数据库类。我们可以在`app`文件夹下的`main.py`模块中这样做：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To specify server actions at the startup event, we have used the `lifespan`
    parameter.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在启动事件中指定服务器操作，我们使用了`lifespan`参数。
- en: We have everything in place to connect our application with the database.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好将我们的应用程序与数据库连接。
- en: How it works…
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The creation of the `Ticket` database mapping class tells our application how
    the database is structured, and the session will manage the transactions. Then,
    the engine will not only execute the operations but compare the mapping classes
    with the database, and it will create tables if any are missing.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ticket`数据库映射类的创建告诉我们应用程序数据库的结构，并且会话将管理事务。然后，引擎不仅会执行操作，还会将映射类与数据库进行比较，如果缺少任何表，它将创建这些表。'
- en: 'To check that our app communicates with our database, let’s spin up the server
    from the command line at the project root folder:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查我们的应用程序是否与数据库通信，让我们从项目根目录的命令行启动服务器：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You should see message logs on the command output that says table tickets have
    been created. Furthermore, open the `.database.db` file with the database reader
    you prefer, and the table should be there with the schema that is defined in the
    `database.py` module.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在命令输出中看到消息日志，表明已创建表tickets。此外，使用你偏好的数据库阅读器打开`.database.db`文件，你应该会看到在`database.py`模块中定义的模式下的表。
- en: See also
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'You can see more about how to set up a database with SQLAlchemy and how to
    make it compatible with the `asyncio` module on the official documentation pages:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在官方文档页面上了解更多关于如何使用SQLAlchemy设置数据库以及如何使其与`asyncio`模块兼容的信息：
- en: '*How to set up an SQLAlchemy* *database*: [https://docs.sqlalchemy.org/en/20/orm/quickstart.xhtml](https://docs.sqlalchemy.org/en/20/orm/quickstart.xhtml)'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如何设置SQLAlchemy* *数据库*: [https://docs.sqlalchemy.org/en/20/orm/quickstart.xhtml](https://docs.sqlalchemy.org/en/20/orm/quickstart.xhtml)'
- en: '*SQLAlchemy* `asyncio` *extension* *reference*: [https://docs.sqlalchemy.org/en/20/orm/extensions/asyncio.xhtml](https://docs.sqlalchemy.org/en/20/orm/extensions/asyncio.xhtml)'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SQLAlchemy* `asyncio` *扩展* *参考*: [https://docs.sqlalchemy.org/en/20/orm/extensions/asyncio.xhtml](https://docs.sqlalchemy.org/en/20/orm/extensions/asyncio.xhtml)'
- en: 'In this example, we have used an SQLite database by specifying the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过指定以下内容使用了SQLite数据库：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: However, you can use SQLAlchemy to interact with multiple SQL databases such
    as `asyncio`-supported driver, and the database address.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以使用SQLAlchemy与多个SQL数据库交互，例如`asyncio`支持的驱动程序和数据库地址。
- en: 'For example, for MySQL, the connection string would look like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于MySQL，连接字符串看起来会是这样：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this case, you need the `aiomysql` package installed in your environment.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你需要在你的环境中安装`aiomysql`包。
- en: 'You can check more on the official documentation pages:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在官方文档页面查看更多信息：
- en: 'SQLAlchemy MySQL dialect: [https://docs.sqlalchemy.org/en/20/dialects/mysql.xhtml](https://docs.sqlalchemy.org/en/20/dialects/mysql.xhtml)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'SQLAlchemy MySQL方言: [https://docs.sqlalchemy.org/en/20/dialects/mysql.xhtml](https://docs.sqlalchemy.org/en/20/dialects/mysql.xhtml)'
- en: 'SQLAlchemy PostgreSQL dialect: [https://docs.sqlalchemy.org/en/20/dialects/postgresql.xhtml](https://docs.sqlalchemy.org/en/20/dialects/postgresql.xhtml)'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'SQLAlchemy PostgreSQL方言: [https://docs.sqlalchemy.org/en/20/dialects/postgresql.xhtml](https://docs.sqlalchemy.org/en/20/dialects/postgresql.xhtml)'
- en: Implementing CRUD operations
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现CRUD操作
- en: CRUD operations with a RESTful API can be implemented using HTTP methods (`POST`,
    `GET`, `PUT`, and `DELETE`) for web services. This recipe demonstrates how to
    use SQLAlchemy and `asyncio` to build CRUD operations asynchronously on an SQL
    database with the corresponding endpoints.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RESTful API的CRUD操作可以通过HTTP方法（`POST`、`GET`、`PUT`和`DELETE`）实现，用于网络服务。这个配方演示了如何使用SQLAlchemy和`asyncio`在SQL数据库上异步构建CRUD操作以及相应的端点。
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before you start with the recipe, you need to have a database connection and
    a table in the dataset, as well as a matching class in the code base. If you completed
    the previous recipe, you should have them ready.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始食谱之前，您需要有一个数据库连接、数据集中的表以及代码库中匹配的类。如果您完成了前面的食谱，应该已经准备好了。
- en: How to do it…
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: We’ll begin by making an `operations.py` module under the `app` folder to contain
    our database operations by following these steps.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在`app`文件夹下创建一个`operations.py`模块，按照以下步骤包含我们的数据库操作。
- en: 'First, we can set up the operation to add a new ticket to the database as follows:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们可以设置操作以将新票添加到数据库，如下所示：
- en: '[PRE10]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The function will give back the ID attached to the ticket when saved.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数在保存时会返回附加到票上的ID。
- en: 'Then, let’s create a function to get a ticket:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们创建一个获取票的功能：
- en: '[PRE11]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If the ticket is not found, the function will return a `None` object.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果找不到票，函数将返回一个`None`对象。
- en: 'Then, we build an operation to update only the price of the ticket:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们构建一个仅更新票价的操作：
- en: '[PRE12]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The function gives back `False` if the operation couldn’t delete any ticket.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果操作无法删除任何票，函数将返回`False`。
- en: 'To conclude the CRUD operations, we define a `delete_ticket` operation:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成CRUD操作，我们定义了一个`delete_ticket`操作：
- en: '[PRE13]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Similarly to the update operation, the function returns `False` if it does not
    find any ticket to delete.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与更新操作类似，如果找不到要删除的票，函数将返回`False`。
- en: After defining the operations, we can expose them by creating the corresponding
    endpoints in the `main.py` module.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义操作后，我们可以在`main.py`模块中创建相应的端点来公开它们。
- en: 'Let’s do it for the create operation right after defining the app server:'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在定义应用服务器后，让我们立即为创建操作做这件事：
- en: '[PRE14]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The remaining operations can be exposed in the same way.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 剩余的操作也可以以相同的方式公开。
- en: Exercise
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Similarly to what we did for the `create_ticket` operation, expose the other
    operations (get, update, and delete) with the respective endpoints.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与`create_ticket`操作类似，使用相应的端点公开其他操作（获取、更新和删除）。
- en: How it works…
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The functions created to interact with the database are exposed through the
    endpoints. This means that an external user will execute the operations by calling
    the respective endpoints.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 用于与数据库交互的函数通过端点公开。这意味着外部用户将通过调用相应的端点来执行操作。
- en: Let’s verify that the endpoint works correctly.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证端点是否正确工作。
- en: 'Start the server from the command line as usual by running the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，从命令行启动服务器，运行以下命令：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Then, go to the interactive documentation link at `http://localhost:8000/docs`,
    and you will see the endpoints you just created. Experiment with them in different
    combinations and see the results in the `.database.db` database file.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，转到交互式文档链接`http://localhost:8000/docs`，您将看到您刚刚创建的端点。尝试不同的组合并查看`.database.db`数据库文件中的结果。
- en: You have just created CRUD operations to interact with an SQL database by using
    `sqlalchemy` with the `asyncio` library.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚使用`sqlalchemy`和`asyncio`库创建了对SQL数据库的CRUD操作。
- en: Exercise
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Make a `tests` folder in the root project folder and write all the unit tests
    for the operation functions and the endpoints. You can refer to [*Chapter 5*](B21025_05.xhtml#_idTextAnchor157),
    *Testing and Debugging FastAPI Applications*, to learn how to unit test FastAPI
    applications.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在根项目文件夹中创建一个`tests`文件夹，并编写操作函数和端点的所有单元测试。您可以参考[*第5章*](B21025_05.xhtml#_idTextAnchor157)，*测试和调试FastAPI应用程序*，了解如何对FastAPI应用程序进行单元测试。
- en: Working with migrations
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与迁移一起工作
- en: Database migrations let you version control your database schema and keep it
    consistent across environments. They also help you automate the deployment of
    your database changes and track the history of your schema evolution.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库迁移让您可以版本控制数据库模式，并使其在各个环境中保持一致。它们还有助于自动化数据库更改的部署，并跟踪模式演化的历史。
- en: The recipe shows you how to use **Alembic**, a popular tool for managing database
    migrations in Python. You will learn how to create, run, and roll back migrations
    and how to integrate them with your ticketing system.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 食谱向您展示了如何使用**Alembic**，这是一个流行的Python数据库迁移管理工具。您将学习如何创建、运行和回滚迁移，以及如何将它们与您的票务系统集成。
- en: Getting ready
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To use the recipe, you need to have `alembic` in your environment. You can
    install it with `pip,` if you didn’t do it with the `requirements.txt` file from
    the GitHub repository, by typing this on the command line:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个配方，你需要在你的环境中安装`alembic`。如果你没有通过GitHub仓库中的`requirements.txt`文件安装它，可以在命令行中输入以下内容来安装：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You also need to make sure you have at least one class that corresponds to the
    table in the database you want to create. If you don’t have one, go back to the
    *Setting up SQLAlchemy* recipe and make one. If you’re already running the application,
    delete the `.database.db` file that the application has created.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要确保你至少有一个与你要创建的数据库中的表相对应的类。如果你没有，请回到*设置SQLAlchemy*配方并创建一个。如果你已经在运行应用程序，请删除应用程序创建的`.database.db`文件。
- en: How to do it…
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: To configure Alembic and manage database migrations, go through the following
    steps.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置Alembic并管理数据库迁移，请按照以下步骤进行。
- en: 'The first step is to set up `alembic`. In the project root folder, run the
    following command in the command line:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是设置`alembic`。在项目根目录中，在命令行中运行以下命令：
- en: '[PRE17]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Find the `sqlalchemy.url` variable and set the database URL to the following:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到`sqlalchemy.url`变量，并将数据库URL设置为以下：
- en: '[PRE18]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This specifies that we are using an SQLite database If you use a different database,
    adjust it accordingly.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这指定了我们正在使用SQLite数据库。如果你使用的是不同的数据库，请相应地调整。
- en: The `alembic` directory contains a folder version and an `env.py` file that
    has the variable for creating our database migrations.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`alembic`目录包含一个版本文件夹和一个包含创建我们数据库迁移变量的`env.py`文件。'
- en: 'Open the `env.py` file and find the `target_metadata` variable. Set its value
    to the metadata of our application as follows:'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打开`env.py`文件，找到`target_metadata`变量。将其值设置为我们的应用程序的元数据，如下所示：
- en: '[PRE19]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can now create our first database migration script and apply the migration.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在可以创建我们的第一个数据库迁移脚本并应用迁移。
- en: 'Execute the following command from the command line to create an initial migration:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行执行以下命令以创建初始迁移：
- en: '[PRE20]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Make sure you removed the existing `.database.db` file, and let’s execute our
    first migration with the following command:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你已经删除了现有的`.database.db`文件，然后使用以下命令执行我们的第一个迁移：
- en: '[PRE21]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works…
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Once we have the first version of our database, let’s see the migration in action.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了我们数据库的第一个版本，让我们看看迁移是如何工作的。
- en: Imagine we want to change the table in the `database.py` module while the application
    is already deployed in a production environment so that we can’t delete any records
    when updating it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在应用程序已经部署在生产环境中时更改`database.py`模块中的表，以便在更新时不能删除任何记录。
- en: 'Add some tickets to the database, then in the code, let’s add a new field called
    `sold` that will indicate if the ticket has been sold or not:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 向数据库添加一些票据，然后在代码中，让我们添加一个名为`sold`的新字段，以指示票据是否已售出：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To make a new migration, run the following command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的迁移，请运行以下命令：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You will find a new script in the `alembic/versions` folder.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在`alembic/versions`文件夹中找到一个新脚本。
- en: 'Run the migration command again:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行迁移命令：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Open the database, and you will see that the `tickets` table schema has the
    `sold` field added to it, and no record has been deleted.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 打开数据库，你会看到`tickets`表模式已添加了`sold`字段，并且没有记录被删除。
- en: You just created a migration strategy that will seamlessly change our database
    while running without any data loss. From now on, remember to use migrations to
    track changes on database schemas.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚创建了一个迁移策略，它将在运行时无缝更改我们的数据库，而不会丢失任何数据。从现在开始，请记住使用迁移来跟踪数据库模式的变化。
- en: See also
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'You can see more on how to manage database migrations with Alembic at the official
    documentation links:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在官方文档链接中了解更多关于如何使用Alembic管理数据库迁移的信息：
- en: '*Setting up* *Alembic*: [https://alembic.sqlalchemy.org/en/latest/tutorial.xhtml](https://alembic.sqlalchemy.org/en/latest/tutorial.xhtml)'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置* *Alembic*：[https://alembic.sqlalchemy.org/en/latest/tutorial.xhtml](https://alembic.sqlalchemy.org/en/latest/tutorial.xhtml)'
- en: '*Autogenerating* *migrations*: [https://alembic.sqlalchemy.org/en/latest/autogenerate.xhtml](https://alembic.sqlalchemy.org/en/latest/autogenerate.xhtml)'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自动生成* *迁移*：[https://alembic.sqlalchemy.org/en/latest/autogenerate.xhtml](https://alembic.sqlalchemy.org/en/latest/autogenerate.xhtml)'
- en: Handling relationships in SQL databases
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在SQL数据库中处理关系
- en: Database relationships are associations between two or more tables that allow
    you to model complex data structures and perform queries across multiple tables.
    In this recipe, you will learn how to implement one-to-one, many-to-one, and many-to-many
    relationships for the existing ticketing system application. You will also see
    how to use SQLAlchemy to define your database schema relationships and query the
    database.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库关系是两个或多个表之间的关联，允许您建模复杂的数据结构并在多个表之间执行查询。在本教程中，您将学习如何为现有的票务系统应用程序实现一对一、多对一和多对多关系。您还将了解如何使用SQLAlchemy定义数据库模式关系并查询数据库。
- en: Getting ready
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To follow the recipe, you need to have the core of the application already implemented
    with at least one table in it. If you have already done that, you will also have
    the necessary packages ready. We will keep on working on our ticketing system
    platform application.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了遵循本教程，您需要已经实现应用程序的核心，其中至少包含一个表。如果您已经做到了这一点，您也将准备好必要的包。我们将继续在我们的票务系统平台应用程序上工作。
- en: How to do it…
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: We will now proceed to set up relationships. We will show an example for each
    type of SQL table relationship.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将继续设置关系。我们将为每种类型的SQL表关系提供一个示例。
- en: One to one
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一对一
- en: We will demonstrate the one-to-one relationship by making a new table that holds
    details about the ticket.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过创建一个新的表格来展示一对一关系，该表格包含有关票的详细信息。
- en: One-to-one relationships are used to group specific information about a record
    in a separate logic.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一对一关系用于将特定记录的信息分组到单独的逻辑中。
- en: That being said, let’s make the table in the `database.py` module. The records
    will have information such as the seat associated with the ticket, with a ticket
    type that we will use as a label for possible information. Let's create the table
    in two steps.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们在`database.py`模块中创建表格。记录将包含有关与票关联的座位、票类型等信息，我们将使用票类型作为可能信息的标签。让我们分两步创建表格。
- en: 'First, we will add the ticket details reference to the existing `Ticket` class:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将向现有的`Ticket`类添加票详情引用：
- en: '[PRE25]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, we create the table to map the ticket’s details as follows:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建表格以映射票的详细信息，如下所示：
- en: '[PRE26]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Once the database classes are set up to accommodate the new table, we can proceed
    to update the CRUD operations with the following steps.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据库类被设置以容纳新表，我们就可以按照以下步骤更新CRUD操作。
- en: 'To update ticket details, let’s create a dedicated function in the `operations.py`
    module:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要更新票务详情，让我们在`operations.py`模块中创建一个专用函数：
- en: '[PRE27]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The function will return `False` if no records have been updated.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果没有记录被更新，该函数将返回`False`。
- en: 'Next, modify the `create_ticket` function to consider the details of the ticket
    and create an endpoint to expose the updating operation we just created, like
    so:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，修改`create_ticket`函数以考虑票的详细信息，并创建一个端点来公开我们刚刚创建的更新操作，如下所示：
- en: '[PRE28]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this example, each time a ticket is created, an empty record of ticket details
    is created as well to keep the database consistent.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本例中，每次创建票时，也会创建一个空的票详情记录，以保持数据库的一致性。
- en: This was the minimum setup to handle one-to-one relationships. We will continue
    by setting up many-to-one relationships.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是处理一对一关系的最小配置。我们将继续设置多对一关系。
- en: Many to one
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多对一
- en: 'A ticket can be associated with an event, and an event can have multiple tickets.
    To showcase a many-to-one relationship, we will create an `events` table that
    will have a relationship with the `tickets` table. Let’s go through the following
    steps:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 票可以与活动相关联，活动可以有多个票。为了展示多对一关系，我们将创建一个`events`表，该表将与`tickets`表相关联。让我们按以下步骤进行：
- en: 'Let’s first create a column in the `tickets` table that will accommodate the
    reference to the `events` table in the `database.py` module, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先在`tickets`表中创建一个列，该列将容纳`database.py`模块中`events`表的引用，如下所示：
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'class Event(Base):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Event(Base):'
- en: __tablename__ = "events"
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: __tablename__ = "events"
- en: 'id: Mapped[int] = mapped_column(primary_key=True)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 'id: Mapped[int] = mapped_column(primary_key=True)'
- en: 'name: Mapped[str]'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 'name: Mapped[str]'
- en: 'tickets: Mapped[list["Ticket"]] = relationship('
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 'tickets: Mapped[list["Ticket"]] = relationship('
- en: back_populates="event"
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: back_populates="event"
- en: )
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'class Event(Base):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Event(Base):'
- en: __tablename__ = "events"
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: __tablename__ = "events"
- en: '# existing columns'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '# 现有列'
- en: 'sponsors: Mapped[list["Sponsor"]] = relationship('
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 'sponsors: Mapped[list["Sponsor"]] = relationship('
- en: secondary="sponsorships",
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: secondary="sponsorships",
- en: back_populates="events",
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: back_populates="events",
- en: 'sponsors table:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 赞助商表格：
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you might have noticed, the class contains columns to accommodate the `events`
    reference.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所注意到的，该类包含用于容纳`events`引用的列。
- en: 'Finally, we can define an association table that will be the `sponsorships`
    table:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以定义一个关联表，该表将是`sponsorships`表：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The association table can contain information on the relationship itself. For
    example, in our case, a piece of useful information is the amount provided by
    the sponsor for the event.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 关联表可以包含关于关系本身的信息。例如，在我们的案例中，一条有用的信息是赞助商为活动提供的金额。
- en: This is all you need to create many-to-many relationships for your ticketing
    system platform.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您为您的票务系统平台创建多对多关系所需的所有内容。
- en: Exercise
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: 'To complete your application, create an operations function with the relative
    endpoints to do the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成您的申请，创建一个包含相关端点的操作函数，以执行以下操作：
- en: '- Add a sponsor to the database.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '- 向数据库添加赞助商。'
- en: '- Add a sponsorship with the amount. If the sponsorship already exists, replace
    the sponsorship with the new amount.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '- 添加带有金额的赞助。如果赞助已经存在，则用新金额替换赞助。'
- en: See also
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: 'You can dive deeper into handling relationships with SQLAlchemy at the following
    official documentation page:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下官方文档页面深入了解使用SQLAlchemy处理关系的操作：
- en: '*SQLAlchemy basic* *relationships*: [https://docs.sqlalchemy.org/en/20/orm/basic_relationships.xhtml](https://docs.sqlalchemy.org/en/20/orm/basic_relationships.xhtml)'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SQLAlchemy基本* *关系*：[https://docs.sqlalchemy.org/en/20/orm/basic_relationships.xhtml](https://docs.sqlalchemy.org/en/20/orm/basic_relationships.xhtml)'
- en: Optimizing SQL queries for performance
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 优化SQL查询以提升性能
- en: Optimizing SQL queries is key in database management, as it enhances efficiency,
    scalability, cost-effectiveness, user satisfaction, data integrity, compliance,
    and security.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库管理中，优化SQL查询是关键，因为它提高了效率、可扩展性、成本效益、用户满意度、数据完整性、合规性和安全性。
- en: This recipe shows how to make applications run faster by improving SQL queries.
    Queries that use fewer resources and less time can enhance user satisfaction and
    application capacity. Improving SQL queries is a repeated process, but you could
    use some tips that could assist you.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方展示了如何通过改进SQL查询来提高应用程序的运行速度。使用更少资源和时间的查询可以提升用户满意度和应用程序容量。改进SQL查询是一个反复的过程，但您可以采用一些有助于您的技巧。
- en: Getting ready
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you have an existing application running using SQLAlchemy for database
    interaction or to keep working on the ticketing system application all along the
    chapter. Also, basic knowledge of SQL and database schema design can be beneficial.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您有一个正在运行的应用程序，该应用程序使用SQLAlchemy进行数据库交互，或者在整个章节中继续开发票务系统应用程序。此外，对SQL和数据库模式设计的基本了解可能有益。
- en: How to do it…
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Improving SQL queries is a process that involves several steps. As with most
    optimization processes, many steps are specific to the use case, but there are
    general rules that can help optimize SQL queries overall, such as the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 改进SQL查询是一个涉及多个步骤的过程。与大多数优化过程一样，许多步骤都是特定于用例的，但有一些通用规则可以帮助整体优化SQL查询，例如以下内容：
- en: Avoid *N*+1 queries
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用*N*+1查询
- en: Use the `JOIN` statement sparingly
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适度使用`JOIN`语句
- en: Minimize data to fetch
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化要获取的数据
- en: We will apply each with a significant example.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用每个具有显著示例。
- en: Avoiding N+1 queries
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 避免N+1查询
- en: The N+1 query issue happens when your application does one query to get a list
    of items and then loops over those items to get related data, making N more queries.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的应用程序执行一个查询以获取项目列表，然后遍历这些项目以获取相关数据，从而产生N个更多查询时，就会发生N+1查询问题。
- en: Let’s say we want an endpoint to show all events with the associated sponsors.
    A first try might be to fetch the `events` table and loop over the events to fetch
    the `sponsors` table. This solution means a first query to get the events and
    N more queries to get the sponsors for each event, which is exactly what we want
    to avoid.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要一个端点来显示所有与相关赞助商相关的事件。第一次尝试可能是获取`events`表并遍历事件以获取`sponsors`表。这个解决方案意味着一个查询来获取事件，以及为每个事件获取赞助商的N个更多查询，这正是我们想要避免的。
- en: The solution is to load all related records in the query to retrieve the related
    sponsors. This is technically called *eager loading*.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是在查询中加载所有相关记录以检索相关赞助商。这在技术上称为*预加载*。
- en: 'In SQLAlchemy, this is done by using a `joinedload` option so that the function
    operation will look like this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQLAlchemy中，这是通过使用`joinedload`选项来完成的，以便函数操作看起来像这样：
- en: '[PRE33]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `joinedload` method will include a `JOIN` operation on the query, so it
    is no longer necessary to make N queries to get the sponsors.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`joinedload` 方法将在查询中包含一个 `JOIN` 操作，因此不再需要执行 N 次查询来获取赞助商。'
- en: Using the join statement sparingly
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 节省使用连接语句
- en: Joined tables can make the query easier to read. But be careful and only join
    tables that you need for your query.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 连接表可以使查询更容易阅读。但请注意，只连接您查询所需的表。
- en: Suppose we want to get a list of sponsors names with the amount given for a
    certain event in order from the highest to the lowest.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要获取一个按金额从高到低排序的赞助商名称列表，以获取某个活动的金额。
- en: 'We can use multiple joins since we need to fetch three tables. The function
    would look like this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要获取三个表，我们可以使用多个连接。函数看起来会是这样：
- en: '[PRE34]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The double join implies to call the `events` table that we won’t use, so it
    would be much more efficient to organize the query as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 双重连接意味着调用我们不会使用的 `events` 表，因此将查询组织如下会更有效率：
- en: '[PRE35]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This will return what we need without selecting the `events` table at all.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回我们所需的内容，而无需选择 `events` 表。
- en: Minimizing data to fetch
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最小化要获取的数据
- en: Fetching more data than needed can slow down your queries and the application.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 获取比所需更多的数据可能会减慢您的查询和应用程序。
- en: Use SQLAlchemy’s `load_only` function to load only specific columns from the
    database.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SQLAlchemy 的 `load_only` 函数只从数据库中加载特定的列。
- en: 'Imagine that for a marketing analysis, we are asked to make a function that
    gets a list of tickets with only the ticket ID, the user, and the price:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，为了进行市场分析，我们被要求编写一个函数，该函数只获取具有票务 ID、用户和价格的票务列表：
- en: '[PRE36]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We now try to retrieve the tickets from this function, as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在尝试从该函数检索票务，如下所示：
- en: '[PRE37]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You will notice that each element only has the `id`, `user`, and `price` fields
    and it will give an error if you attempt to access the `show` field, for example.
    In larger applications, this can reduce memory usage and make responses much faster.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到每个元素只包含 `id`、`user` 和 `price` 字段，如果您尝试访问 `show` 字段，例如，将会出现错误。在大型应用程序中，这可以减少内存使用并使响应更快。
- en: There’s more…
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多...
- en: SQL query optimization involves more than what the recipe showed. Often, choosing
    a certain SQL database depends on specific optimization needs.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 查询优化不仅涉及配方中显示的内容。通常，选择特定的 SQL 数据库取决于特定的优化需求。
- en: Different SQL databases may have different strengths and weaknesses in handling
    these factors, depending on their architecture and features. For example, some
    SQL databases may support partitioning, sharding, replication, or distributed
    processing, which can improve the scalability and availability of data. Some SQL
    databases may offer more advanced query optimization techniques, such as cost-based
    optimization, query rewriting, or query caching, which can reduce the execution
    time and resource consumption of queries. Some SQL databases may implement different
    storage engines, transaction models, or index types, which can affect the performance
    and consistency of data operations.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的 SQL 数据库在处理这些因素时可能具有不同的优势和劣势，这取决于它们的架构和功能。例如，一些 SQL 数据库可能支持分区、分片、复制或分布式处理，这可以提高数据的可扩展性和可用性。一些
    SQL 数据库可能提供更高级的查询优化技术，如基于成本的优化、查询重写或查询缓存，这可以减少查询的执行时间和资源消耗。一些 SQL 数据库可能实现不同的存储引擎、事务模型或索引类型，这可能会影响数据操作的性能和一致性。
- en: Therefore, when choosing an SQL database for a specific application, it is important
    to consider the characteristics and requirements of the data and queries, and
    compare the capabilities and limitations of the available SQL databases. A good
    way to do this is to benchmark the performance of SQL databases using realistic
    datasets and queries and measure the relevant metrics, such as throughput, latency,
    accuracy, and reliability. By doing so, one can find the optimal SQL database
    for the given scenario and also identify potential areas for improvement in the
    database design and query formulation.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在选择特定应用程序的 SQL 数据库时，考虑数据和查询的特征和需求，以及比较可用 SQL 数据库的功能和限制，非常重要。一种好的方法是使用真实数据集和查询对
    SQL 数据库的性能进行基准测试，并测量相关指标，如吞吐量、延迟、准确性和可靠性。通过这样做，可以找到给定场景的最佳 SQL 数据库，并确定数据库设计和查询制定中可能需要改进的潜在领域。
- en: Securing sensitive data in SQL databases
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQL 数据库中保护敏感数据
- en: Sensitive data, such as personal information, financial records, or confidential
    documents, is often stored in SQL databases for various applications and purposes.
    However, this also exposes the data to potential risks of unauthorized access,
    theft, leakage, or corruption. Therefore, it is essential to secure sensitive
    data in SQL databases and protect it from malicious attacks or accidental errors.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 敏感数据，如个人信息、财务记录或机密文件，通常存储在SQL数据库中，用于各种应用程序和目的。然而，这也使数据面临未经授权访问、盗窃、泄露或损坏的风险。因此，在SQL数据库中保护敏感数据并防止恶意攻击或意外错误至关重要。
- en: This recipe will show how to store sensitive data, such as credit card information,
    in SQL databases.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱将展示如何将敏感数据，如信用卡信息，存储在SQL数据库中。
- en: Getting ready
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 准备工作
- en: To follow the recipe, you need to have an application with a database connection
    already in place.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循这个食谱，你需要有一个已经设置好数据库连接的应用程序。
- en: 'Furthermore, we will use the `cryptography` package. If you haven’t installed
    it with the `requirements.txt` file, you can do it by running this command in
    your environment:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将使用`cryptography`包。如果你还没有通过`requirements.txt`文件安装它，你可以在你的环境中运行以下命令来安装：
- en: '[PRE38]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: A sound knowledge of cryptography can be beneficial but is not necessary.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 对密码学的深入了解可能有益，但并非必需。
- en: How to do it…
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如何做……
- en: We will make a new table from the ground up to store credit card information.
    Some of the information, such as credit card numbers and **Card Verification Values**
    (**CVV**), will not be saved in clear text in our database but rather encrypted.
    Since we need to get it back, we will use a symmetric encryption that needs a
    key. Let's make the process through the following steps.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从零开始创建一个新的表格来存储信用卡信息。其中一些信息，例如信用卡号码和**卡验证值**（**CVV**），将不会以明文形式存储在我们的数据库中，而是加密存储。由于我们需要将其恢复，我们将使用需要密钥的对称加密。让我们通过以下步骤来完成这个过程。
- en: 'Let’s start by creating a class in the `database.py` module that corresponds
    to the `credit_card` table in our database, as follows:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从在`database.py`模块中创建一个与数据库中的`credit_card`表相对应的类开始，如下所示：
- en: '[PRE39]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '2.  Next, in the `app` folder, we create a module named `security.py` where
    we will write our code for encrypting and decrypting data using **Fernet symmetric
    encryption**, as follows:'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2.  接下来，在`app`文件夹中，我们创建一个名为`security.py`的模块，我们将在这个模块中编写使用**Fernet对称加密**加密和解密数据的代码，如下所示：
- en: '[PRE40]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `cypher_suite` object will be used to define the encryption and decryption
    function.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`cypher_suite`对象将用于定义加密和解密函数。'
- en: It is worth mentioning that in a production environment, the `cypher_key` object
    can be either kept in an external service that offers rotation or created at startup,
    based on the security needs of the business.
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 值得注意的是，在生产环境中，`cypher_key`对象可以是外部提供轮换服务的一部分，也可以根据业务的安全需求在启动时创建。
- en: '3.  In the same module, we can create a function to encrypt credit card info
    and one to decrypt it as follows:'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3.  在同一个模块中，我们可以创建一个加密信用卡信息的函数和一个解密它的函数，如下所示：
- en: '[PRE41]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Those functions will be used when writing and reading from the database.
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些函数将在从数据库写入和读取时使用。
- en: '4.  Then, we can write a storing operation in the same `security.py` module
    as follows:'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 4.  然后，我们可以在同一个`security.py`模块中编写存储操作，如下所示：
- en: '[PRE42]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Each time the function is awaited, the credit card information will be stored
    with the confidential data encrypted.
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每次函数被等待时，信用卡信息将加密后与机密数据一起存储。
- en: '5.  Similarly, we can define a function to retrieve the encrypted credit card
    information from the database as follows:'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 5.  类似地，我们可以定义一个从数据库中检索加密信用卡信息的函数，如下所示：
- en: '[PRE43]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We have just developed code to save confidential information in our database.
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经开发出了代码，可以在我们的数据库中保存机密信息。
- en: Exercise
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: 'We just saw the backbone of how to store sensitive data securely. You can complete
    the feature by yourself by doing the following:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了如何安全存储敏感数据的基本框架。你可以通过以下步骤自己完成这个功能：
- en: '- Writing unit tests for our encryption operations. In the `tests` folder,
    let’s create a new test module called `test_security.py`. Verify that the credit
    card is securely saved in our database, but the fields for credit card numbers
    and CVV are encrypted.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '- 为我们的加密操作编写单元测试。在`tests`文件夹中，让我们创建一个新的测试模块，名为`test_security.py`。验证信用卡信息是否安全地保存在我们的数据库中，但信用卡号码和CVV字段是加密的。'
- en: '- Creating endpoints to store, retrieve, and delete credit card information
    in the database.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '- 在数据库中创建端点以存储、检索和删除信用卡信息。'
- en: '- Associating a credit card with a sponsor and managing the relative CRUD operations.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '- 将信用卡与赞助商关联并管理相关的CRUD操作。'
- en: See also
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: 'We have used Fernet symmetric encryption to encrypt credit card information.
    You can have a deeper insight about it at the following link:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用Fernet对称加密来加密信用卡信息。您可以在以下链接中深入了解：
- en: '*Fernet symmetric* *encryption*: [https://cryptography.io/en/latest/fernet/](https://cryptography.io/en/latest/fernet/)'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Fernet对称* *加密*：[https://cryptography.io/en/latest/fernet/](https://cryptography.io/en/latest/fernet/)'
- en: Handling transactions and concurrency
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 处理事务和并发
- en: 'In the realm of database management, two critical aspects govern the reliability
    and performance of applications: handling transactions and managing concurrency.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库管理的领域，两个关键方面决定了应用程序的可靠性和性能：处理事务和管理并发。
- en: Transactions, encapsulating a series of database operations, are fundamental
    for maintaining data consistency by ensuring that changes occur as a single unit
    of work. Concurrency, on the other hand, addresses the challenge of managing simultaneous
    access to shared resources by multiple users or processes.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 事务，封装一系列数据库操作，通过确保更改作为一个单一的工作单元发生，对于维护数据一致性是基本的。另一方面，并发解决多个用户或进程同时访问共享资源的挑战。
- en: The relationship between transactions and concurrency becomes apparent when
    considering scenarios where multiple transactions may attempt to access or modify
    the same data concurrently. Without proper concurrency control mechanisms such
    as locking, transactions could interfere with each other, potentially leading
    to data corruption or inconsistencies.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑可能同时尝试访问或修改相同数据的多个事务的场景时，事务和并发之间的关系变得明显。如果没有适当的并发控制机制，如锁定，事务可能会相互干扰，可能导致数据损坏或不一致。
- en: The recipe will show how to manage transactions and concurrency with FastAPI
    and SQLAlchemy by emulating the process of selling tickets from the ticketing
    platform we created.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱将展示如何通过模拟我们从票务平台创建的销售过程来使用FastAPI和SQLAlchemy管理事务和并发。
- en: Getting ready
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need a CRUD application as the basis for the recipe, or you can continue
    to use the ticketing system application that we have been using throughout the
    chapter.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个CRUD应用程序作为食谱的基础，或者您可以使用我们本章中一直在使用的票务系统应用程序。
- en: How to do it…
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: The most significant situation where transaction and concurrency become important
    is in managing updating operations, such as with the sales ticket for our application.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 事务和并发变得重要的最显著情况是在管理更新操作时，例如在我们的应用程序的销售票中。
- en: We will begin by creating a function operation that will label our ticket as
    sold and give the name of the customer. Then, we will simulate two sales occurring
    at the same time and observe the outcome. To do so, follow these steps.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个函数操作，将我们的票标记为已售出并给出客户的名字。然后，我们将模拟同时发生两个销售并观察结果。为此，请按照以下步骤操作。
- en: 'In the `operations.py` module, create the function to sell a ticket as follows::'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`operations.py`模块中，创建以下函数来出售票：
- en: '[PRE44]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The query will only sell the ticket if the ticket has not been sold yet; otherwise,
    the function will return `False`.
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查询只有在票尚未售出时才会出售票；否则，函数将返回`False`。
- en: 2.  Let’s try to add a ticket to our database and try to simulate two users
    buying the same ticket at the same time. Let’s write all in the form of unit tests.
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2. 让我们尝试向我们的数据库添加一个票并尝试模拟两个用户同时购买同一张票。让我们将所有内容都写成单元测试的形式。
- en: 'We start by defining a fixture to write our ticket into the database in the
    `tests/conftest.py` file as follows:'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们首先在`tests/conftest.py`文件中定义一个固定装置，将我们的票写入数据库，如下所示：
- en: '[PRE45]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '3.  We can create a test by performing two concurrent sales with two separate
    database sessions (define another one as a different fixture) to do them at the
    same time in the `tests/test_operations.py` file:'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3. 我们可以通过在`tests/test_operations.py`文件中执行两个并发销售并使用两个不同的数据库会话（定义另一个作为不同的固定装置）来创建一个测试，以同时进行：
- en: '[PRE46]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the test function, we run two coroutines at the same time by using the `asyncio.gather`
    function.
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在测试函数中，我们通过使用`asyncio.gather`函数同时运行两个协程。
- en: 'We just assume that only one user can purchase the ticket and they will match
    the successful transaction. Once we have created the test, we can execute with
    `pytest` as follows:'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们只是假设只有一个用户可以购买票，并且它们将匹配成功的交易。一旦我们创建了测试，我们就可以使用`pytest`执行如下：
- en: '[PRE47]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The test will succeed, which means that the asynchronous session handles transaction
    conflicts.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 测试将成功，这意味着异步会话处理了事务冲突。
- en: Exercise
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: 'You have just created a draft of the selling ticket operation. As an exercise,
    you can improve the draft by doing the following:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚创建了一个售票操作的草稿。作为一个练习，您可以通过以下方式改进草稿：
- en: '- Adding a table for users to the database'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '- 在数据库中添加一个用户表'
- en: '- Adding the foreign key reference of the user on the ticket to make it sold'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '- 在票上添加用户的外键引用以使其售出'
- en: '- Creating an `alembic` migration for the database modification'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '- 为数据库修改创建一个 `alembic` 迁移'
- en: '- Creating an API endpoint that exposes the `sell_ticket_to_user` function'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '- 创建一个公开 `sell_ticket_to_user` 函数的 API 端点'
- en: There’s more…
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多...
- en: One of the fundamental challenges of database systems is to handle concurrent
    transactions from multiple users while preserving data consistency and integrity.
    Different types of transactions may have different requirements for how they access
    and modify data and how they deal with other transactions that may conflict with
    them. For example, a common way to manage concurrency is to use *locks*, which
    are mechanisms that prevent unauthorized or incompatible operations on data. However,
    locks can also introduce trade-offs between performance, availability, and correctness.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库系统的一个基本挑战是在保持数据一致性和完整性的同时处理来自多个用户的并发事务。不同类型的交易可能对它们如何访问和修改数据以及如何处理可能与之冲突的其他交易有不同的要求。例如，管理并发的一种常见方法是使用
    *锁*，这是一种防止对数据进行未经授权或不兼容操作的机制。然而，锁也可能在性能、可用性和正确性之间引入权衡。
- en: Depending on the business needs, some transactions may need to acquire locks
    for longer periods or at different levels of granularity, such as table-level
    or row-level. For example, SQLite only allows locks on a database level, while
    PostgreSQL allows locks till the row table level.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 根据业务需求，某些事务可能需要更长时间或在不同粒度级别上获取锁，例如表级别或行级别。例如，SQLite 只允许在数据库级别上锁定，而 PostgreSQL
    允许锁定到行表级别。
- en: Another key aspect of managing concurrent transactions is the concept of *isolation
    levels*, which define the degree to which one transaction must be isolated from
    the effects of other concurrent transactions. Isolation levels ensure that transactions
    maintain data consistency despite simultaneous access and modification by multiple
    users.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 管理并发事务的另一个关键方面是 *隔离级别* 的概念，它定义了一个事务必须从其他并发事务的影响中隔离的程度。隔离级别确保尽管有多个用户同时访问和修改数据，事务仍能保持数据一致性。
- en: 'The SQL standard defines four isolation levels, each offering different trade-offs
    between concurrency and data consistency:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 标准定义了四个隔离级别，每个级别在并发性和数据一致性之间提供不同的权衡：
- en: '**READ UNCOMMITTED**:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**读取未提交**:'
- en: Transactions at this level allow dirty reads, meaning a transaction can see
    uncommitted changes made by other concurrent transactions.
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此级别的交易允许脏读，这意味着一个事务可以看到其他并发事务所做的未提交更改。
- en: Non-repeatable reads and phantom reads are possible.
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可重复读和幻读是可能的。
- en: This isolation level provides the highest concurrency but the lowest level of
    data consistency.
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此隔离级别提供了最高的并发性但数据一致性最低。
- en: '**READ COMMITTED**:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**读取提交**:'
- en: Transactions at this level only see changes committed by other transactions.
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此级别的交易只能看到其他事务提交的更改。
- en: They do not allow dirty reads.
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不允许脏读。
- en: Non-repeatable reads are possible, but phantom reads can still occur.
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可重复读是可能的，但幻读仍然可能发生。
- en: This level strikes a balance between concurrency and consistency.
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此级别在并发性和一致性之间取得了平衡。
- en: '**REPEATABLE READ**:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**可重复读**:'
- en: Transactions at this level see a consistent snapshot of the data throughout
    the transaction.
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此级别的交易在整个交易过程中看到数据的一致快照。
- en: Changes committed by other transactions after the transaction began are not
    visible.
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务开始后其他事务提交的更改不可见。
- en: Non-repeatable reads are prevented, but phantom reads can occur.
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止了可重复读，但可能会发生幻读。
- en: This level provides stronger consistency at the cost of some concurrency.
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此级别在牺牲一些并发性的情况下提供了更强的一致性。
- en: '**SERIALIZABLE**:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**可序列化**:'
- en: Transactions at this level behave as if they are executed serially – that is,
    one after another.
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此级别的交易表现得好像它们是顺序执行的——也就是说，一个接一个。
- en: They provide the highest level of data consistency.
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提供了数据一致性的最高级别。
- en: Non-repeatable reads and phantom reads are prevented.
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止了可重复读和幻读。
- en: This level offers strong consistency but may result in reduced concurrency due
    to increased locking.
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此级别提供强一致性，但由于锁定增加，可能会导致并发性降低。
- en: SQLite, for example, allows isolation, while MySQL and PostgreSQL offer all
    four transaction levels.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，SQLite 允许隔离，而 MySQL 和 PostgreSQL 提供所有四个事务级别。
- en: When the database supports it, in SQLAlchemy, you can set up the isolation level
    per engine or connection by specifying it as an argument when initializing.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据库支持时，在 SQLAlchemy 中，你可以通过在初始化时指定它作为参数来为每个引擎或连接设置隔离级别。
- en: 'For example, if you want to specify the isolation level at the engine level
    for PostgreSQL, the engine will be initialized as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想在 PostgreSQL 的引擎级别指定隔离级别，引擎将初始化如下：
- en: '[PRE48]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: All these choices in terms of locks and isolation level affect the architecture
    and design of the database system since not all SQL databases support it. Therefore,
    it is important to understand the principles and best practices of locking strategies
    and how they relate to the transaction behavior and the business logic.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些关于锁和隔离级别的选择都会影响数据库系统的架构和设计，因为并非所有 SQL 数据库都支持这些功能。因此，了解锁定策略的原则和最佳实践，以及它们与事务行为和业务逻辑的关系非常重要。
- en: You have just completed a comprehensive overview of integrating SQL databases
    with FastAPI. In the next chapter, we will explore integrating FastAPI applications
    with NoSQL databases.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚完成了一个关于将 SQL 数据库与 FastAPI 集成的全面概述。在下一章中，我们将探讨如何将 FastAPI 应用程序与 NoSQL 数据库集成。
- en: See also
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: 'You can find more information about locking strategies for SQLite and PostgreSQL
    at the following links:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接中找到有关 SQLite 和 PostgreSQL 锁定策略的更多信息：
- en: '*SQLite* *locking*: [https://www.sqlite.org/lockingv3.xhtml](https://www.sqlite.org/lockingv3.xhtml)'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SQLite* *锁定*: [https://www.sqlite.org/lockingv3.xhtml](https://www.sqlite.org/lockingv3.xhtml)'
- en: '*PostgreSQL* *locking*: [https://www.postgresql.org/docs/current/explicit-locking.xhtml](https://www.postgresql.org/docs/current/explicit-locking.xhtml)'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PostgreSQL* *锁定*: [https://www.postgresql.org/docs/current/explicit-locking.xhtml](https://www.postgresql.org/docs/current/explicit-locking.xhtml)'
- en: 'Information on the isolation level for singular databases can be found on the
    respective documentation pages:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 关于单个数据库的隔离级别信息可以在相应的文档页面上找到：
- en: '*SQLite* *isolation*: [https://www.sqlite.org/isolation.xhtml](https://www.sqlite.org/isolation.xhtml)'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SQLite* *隔离*: [https://www.sqlite.org/isolation.xhtml](https://www.sqlite.org/isolation.xhtml)'
- en: '*MySQL isolation* *levels*: [https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.xhtml](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.xhtml)'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*MySQL 隔离* *级别*: [https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.xhtml](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.xhtml)'
- en: '*PostgreSQL isolation* *levels*: [https://www.postgresql.org/docs/current/transaction-iso.xhtml](https://www.postgresql.org/docs/current/transaction-iso.xhtml)'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PostgreSQL 隔离* *级别*: [https://www.postgresql.org/docs/current/transaction-iso.xhtml](https://www.postgresql.org/docs/current/transaction-iso.xhtml)'
- en: 'Also, a comprehensive guide on how to manage isolation levels with SQLAlchemy
    is available at the link:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，关于如何使用 SQLAlchemy 管理隔离级别的全面指南可在以下链接找到：
- en: '*SQLAlchemy session* *transaction*: [https://docs.sqlalchemy.org/en/20/orm/session_transaction.xhtml](https://docs.sqlalchemy.org/en/20/orm/session_transaction.xhtml)'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SQLAlchemy 会话* *事务*: [https://docs.sqlalchemy.org/en/20/orm/session_transaction.xhtml](https://docs.sqlalchemy.org/en/20/orm/session_transaction.xhtml)'
- en: '[PRE49]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
