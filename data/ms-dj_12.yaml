- en: Chapter 12. Testing in Django
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。Django中的测试
- en: Introduction to testing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试简介
- en: Like all mature programming languages, Django provides inbuilt *unit testing*
    capabilities. Unit testing is a software testing process where individual units
    of a software application are tested to ensure they do what they are expected
    to do.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 像所有成熟的编程语言一样，Django提供了内置的*单元测试*功能。单元测试是一种软件测试过程，其中测试软件应用程序的各个单元，以确保它们执行预期的操作。
- en: Unit testing can be performed at multiple levels-from testing an individual
    method to see if it returns the right value and how it handles invalid data, up
    to testing a whole suite of methods to ensure a sequence of user inputs leads
    to the desired results.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试可以在多个级别进行-从测试单个方法以查看它是否返回正确的值以及如何处理无效数据，到测试整套方法以确保一系列用户输入导致期望的结果。
- en: 'Unit testing is based on four fundamental concepts:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试基于四个基本概念：
- en: A **test fixture** is the setup needed to perform tests. This could include
    databases, sample datasets and server setup. A test fixture may also include any
    clean-up actions required after tests have been performed.
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试装置**是执行测试所需的设置。这可能包括数据库、样本数据集和服务器设置。测试装置还可能包括在测试执行后需要进行的任何清理操作。'
- en: A **test case** is the basic unit of testing. A test case checks whether a given
    set of inputs leads to an expected set of results.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试用例**是测试的基本单元。测试用例检查给定的输入是否导致预期的结果。'
- en: A **test suite** is a number of test cases, or other test suites, that are executed
    as a group.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试套件**是一些测试用例或其他测试套件，作为一个组执行。'
- en: A **test runner** is the software program that controls the execution of tests
    and feeds the results of tests back to the user.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试运行器**是控制测试执行并将测试结果反馈给用户的软件程序。'
- en: Software testing is a deep and detailed subject and this chapter should be considered
    to be only a bare introduction to unit testing. There are a large number of resources
    on the Internet on software testing theory and methods and I encourage you to
    do your own research on this important topic. For a more detailed discussion on
    Django's approach to unit testing, see the Django Project website.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试是一个深入而详细的主题，本章应被视为对单元测试的简要介绍。互联网上有大量关于软件测试理论和方法的资源，我鼓励你就这个重要主题进行自己的研究。有关Django对单元测试方法的更详细讨论，请参阅Django项目网站。
- en: Introducing automated testing
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入自动化测试
- en: What are automated tests?
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是自动化测试？
- en: You have been testing code right throughout this book; maybe without even realizing
    it. Each time you use the Django shell to see if a function works, or to see what
    output you get for a given input, you are testing your code. For example, back
    in [Chapter 2](ch02.xhtml "Chapter 2. Views and URLconfs"), *Views and URLconfs*,
    we passed a string to a view that expected an integer to generate a `TypeError`
    exception.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，你一直在测试代码；也许甚至没有意识到。每当你使用Django shell来查看一个函数是否有效，或者查看给定输入的输出时，你都在测试你的代码。例如，在[第2章](ch02.xhtml
    "第2章。视图和URLconfs")中，*视图和URLconfs*，我们向一个期望整数的视图传递了一个字符串，以生成`TypeError`异常。
- en: Testing is a normal part of application development, however what's different
    in automated tests is that the testing work is done for you by the system. You
    create a set of tests once, and then as you make changes to your app, you can
    check that your code still works as you originally intended, without having to
    perform time consuming manual testing.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是应用程序开发的正常部分，但自动化测试的不同之处在于系统为你完成了测试工作。你只需创建一组测试，然后在对应用程序进行更改时，可以检查你的代码是否仍然按照最初的意图工作，而无需进行耗时的手动测试。
- en: So why create tests?
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那么为什么要创建测试？
- en: If creating simple applications like those in this book is the last bit of Django
    programming you do, then true, you don't need to know how to create automated
    tests. But, if you wish to become a professional programmer and/or work on more
    complex projects, you need to know how to create automated tests.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果创建像本书中那样简单的应用程序是你在Django编程中的最后一步，那么确实，你不需要知道如何创建自动化测试。但是，如果你希望成为一名专业程序员和/或在更复杂的项目上工作，你需要知道如何创建自动化测试。
- en: 'Creating automated tests will:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自动化测试将会：
- en: '**Save you time**: Manually testing the myriad complex interactions between
    components of a big application is time-consuming and error prone. Automated tests
    save time and let you focus on programming.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节省时间**：手动测试大型应用程序组件之间的复杂交互是耗时且容易出错的。自动化测试可以节省时间，让你专注于编程。'
- en: '**Prevent problems**: Tests highlight the internal workings of your code, so
    you can see where things have gone wrong.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预防问题**：测试突出显示了代码的内部工作原理，因此你可以看到哪里出了问题。'
- en: '**Look professional**: The pros write tests. Jacob Kaplan-Moss, one of Django''s
    original developers, says "Code without tests is broken by design."'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**看起来专业**：专业人士编写测试。Django的原始开发人员之一Jacob Kaplan-Moss说：“没有测试的代码从设计上就是有问题的。”'
- en: '**Improve teamwork**: Tests guarantee that colleagues don''t inadvertently
    break your code (and that you don''t break theirs without knowing).'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**改善团队合作**：测试可以确保同事们不会无意中破坏你的代码（而你也不会在不知情的情况下破坏他们的代码）。'
- en: Basic testing strategies
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本测试策略
- en: 'There are many ways to approach writing tests. Some programmers follow a discipline
    called **test-driven development**; they actually write their tests before they
    write their code. This might seem counter-intuitive, but in-fact, it''s similar
    to what most people will often do anyway: they describe a problem, then create
    some code to solve it.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以用来编写测试。一些程序员遵循一种称为**测试驱动开发**的纪律；他们实际上是在编写代码之前编写他们的测试。这可能看起来有些反直觉，但事实上，这与大多数人通常会做的事情相似：他们描述一个问题，然后创建一些代码来解决它。
- en: Test-driven development simply formalizes the problem in a Python test case.
    More often, a newcomer to testing will create some code and later decide that
    it should have some tests. Perhaps it would have been better to write some tests
    earlier, but it's never too late to get started.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发只是在Python测试用例中正式化了问题。更常见的是，测试的新手会创建一些代码，然后决定它应该有一些测试。也许更好的做法是早些时候编写一些测试，但现在开始也不算太晚。
- en: Writing a test
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个测试
- en: To create your first test, let's introduce a bug into your Book model.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建您的第一个测试，让我们在您的Book模型中引入一个错误。
- en: 'Say you have decided to create a custom method on your Book model to indicate
    whether the book has been published recently. Your Book model may look something
    like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经决定在您的Book模型上创建一个自定义方法，以指示书籍是否最近出版。您的Book模型可能如下所示：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'First we have imported two new modules: Python''s `datetime` and `timezone`
    from `django.utils`. We need these modules to be able to do calculations with
    dates. Then we have added a custom method to the `Book` model called `recent_publication`
    that works out what date it was eight weeks ago and returns true if the publication
    date of the book is more recent.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入了两个新模块：Python的`datetime`和`django.utils`中的`timezone`。我们需要这些模块来进行日期计算。然后，我们在`Book`模型中添加了一个名为`recent_publication`的自定义方法，该方法计算出八周前的日期，并在书籍的出版日期更近时返回true。
- en: 'So let''s jump to the interactive shell and test our new method:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们跳到交互式shell并测试我们的新方法：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So far so good, we have imported our book model and retrieved a book. Today
    is the 11th June, 2016 and I have entered the publication date of my book in the
    database as the 1st of May, which is less than eight weeks ago, so the function
    correctly returns `True`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很顺利，我们已经导入了我们的书籍模型并检索到了一本书。今天是2016年6月11日，我已经在数据库中输入了我的书的出版日期为5月1日，这比八周前还要早，所以函数正确地返回了`True`。
- en: Obviously, you will have to modify the publication date in your data so this
    exercise still works for you based on when you complete this exercise.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，您将不得不修改数据中的出版日期，以便在您完成这个练习时，这个练习仍然对您有效。
- en: 'Now let''s see what happens if we set the publication date to a time in the
    future to, say, 1st September:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如果我们将出版日期设置为未来的某个时间，比如说9月1日会发生什么：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Oops! Something is clearly wrong here. You should be able to quickly see the
    error in the logic-any date after eight weeks ago is going to return true, including
    dates in the future.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！这里显然有些问题。您应该能够很快地看到逻辑上的错误-八周前之后的任何日期都将返回true，包括未来的日期。
- en: So, ignoring the fact that this is a rather contrived example, lets now create
    a test that exposes our faulty logic.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，暂且不管这是一个相当牵强的例子，现在让我们创建一个暴露我们错误逻辑的测试。
- en: Creating a test
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个测试
- en: 'When you created your books app with Django''s `startapp` command, it created
    a file called `tests.py` in your app directory. This is where any tests for the
    books app should go. So let''s get right to it and write a test:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用Django的`startapp`命令创建了您的books应用程序时，它在您的应用程序目录中创建了一个名为`tests.py`的文件。这就是books应用程序的任何测试应该放置的地方。所以让我们马上开始编写一个测试：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This should all be pretty straight forward as it's nearly exactly what we did
    in the Django shell, the only real difference is that we now have encapsulated
    our test code in a class and created an assertion that tests our `recent_publication()`
    method against a future date.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该非常简单明了，因为它几乎与我们在Django shell中所做的一样，唯一的真正区别是我们现在将我们的测试代码封装在一个类中，并创建了一个断言，用于测试我们的`recent_publication()`方法是否与未来日期相匹配。
- en: We will be covering test classes and the `assertEqual` method in greater detail
    later in the chapter-for now, we just want to look at how tests work at a very
    basic level before getting onto more complicated topics.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面更详细地介绍测试类和`assertEqual`方法-现在，我们只想在进入更复杂的主题之前，看一下测试是如何在非常基本的水平上工作的。
- en: Running tests
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行测试
- en: 'Now we have created our test, we need to run it. Fortunately, this is very
    easy to do, jump into your terminal and type:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的测试，我们需要运行它。幸运的是，这非常容易做到，只需跳转到您的终端并键入：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After a moment, Django should print out something like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 片刻之后，Django应该打印出类似于这样的内容：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'What happened is this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的事情是这样的：
- en: Python `manage.py test books` looked for tests in the books application
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python `manage.py test books`在books应用程序中查找测试。
- en: It found a subclass of the `django.test.TestCase` class
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它找到了`django.test.TestCase`类的一个子类
- en: It created a special database for the purpose of testing
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为测试目的创建了一个特殊的数据库
- en: It looked for methods with names beginning with "test"
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它寻找以“test”开头的方法
- en: In `test_recent_pub` it created a Book instance whose `publication_date` field
    is 5 days in the future; and
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`test_recent_pub`中，它创建了一个`Book`实例，其`publication_date`字段是未来的5天；而
- en: Using the `assertEqual()` method, it discovered that its `recent_publication()`
    returns `True`, when it was supposed to return `False`.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`assertEqual()`方法，它发现它的`recent_publication()`返回`True`，而应该返回`False`。
- en: The test informs us which test failed and even the line on which the failure
    occurred. Note also that if you are on a *nix system or a Mac, the file path will
    be different.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 测试告诉我们哪个测试失败了，甚至还告诉了失败发生的行。还要注意，如果您使用的是*nix系统或Mac，文件路径将会有所不同。
- en: That's it for a very basic introduction to testing in Django. As I said at the
    beginning of the chapter, testing is a deep and detailed subject that is highly
    important to your career as a programmer. I can't possibly cover all the facets
    of testing in a single chapter, so I encourage you to dig deeper into some of
    the resources mentioned in this chapter as well as the Django documentation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Django中测试的非常基本的介绍。正如我在本章开头所说的，测试是一个深入而详细的主题，对于您作为程序员的职业非常重要。我不可能在一个章节中涵盖所有测试的方面，所以我鼓励您深入研究本章中提到的一些资源以及Django文档。
- en: For the remainder of the chapter, I will be going over the various testing tools
    Django puts at your disposal.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我将介绍Django为您提供的各种测试工具。
- en: Testing tools
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试工具
- en: Django provides a set of tools that come in handy when writing tests.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Django提供了一套在编写测试时非常方便的工具。
- en: The test client
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试客户端
- en: 'The test client is a Python class that acts as a dummy web browser, allowing
    you to test your views and interact with your Django-powered application programmatically.
    Some of the things you can do with the test client are:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 测试客户端是一个Python类，充当虚拟网络浏览器，允许您以编程方式测试视图并与Django应用程序进行交互。测试客户端可以做的一些事情包括：
- en: Simulate `GET` and `POST` requests on a URL and observe the response-everything
    from low-level HTTP (result headers and status codes) to page content.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟URL上的`GET`和`POST`请求，并观察响应-从低级HTTP（结果标头和状态代码）到页面内容的一切。
- en: See the chain of redirects (if any) and check the URL and status code at each
    step.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看重定向链（如果有）并检查每一步的URL和状态代码。
- en: Test that a given request is rendered by a given Django template, with a template
    context that contains certain values.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试给定请求是否由给定的Django模板呈现，并且模板上下文包含某些值。
- en: 'Note that the test client is not intended to be a replacement for Selenium
    (for more information visit [http://seleniumhq.org/](http://seleniumhq.org/))
    or other in-browser frameworks. Django''s test client has a different focus. In
    short:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，测试客户端并不打算替代Selenium（有关更多信息，请访问[http://seleniumhq.org/](http://seleniumhq.org/)）或其他浏览器框架。Django的测试客户端有不同的重点。简而言之：
- en: Use Django's test client to establish that the correct template is being rendered
    and that the template is passed the correct context data.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Django的测试客户端来确保正确的模板被渲染，并且模板传递了正确的上下文数据。
- en: Use in-browser frameworks like Selenium to test rendered HTML and the behavior
    of web pages, namely JavaScript functionality. Django also provides special support
    for those frameworks; see the section on `LiveServerTestCase` for more details.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用浏览器框架（如Selenium）测试呈现的HTML和网页的行为，即JavaScript功能。Django还为这些框架提供了特殊的支持；有关更多详细信息，请参阅`LiveServerTestCase`部分。
- en: A comprehensive test suite should use a combination of both test types.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 全面的测试套件应该结合使用这两种测试类型。
- en: For a more detailed look at the Django test client with examples, see the Django
    Project website.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Django测试客户端的更详细信息和示例，请参阅Django项目网站。
- en: Provided TestCase classes
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供的TestCase类
- en: 'Normal Python unit test classes extend a base class of `unittest.TestCase`.
    Django provides a few extensions of this base class:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 普通的Python单元测试类扩展了`unittest.TestCase`的基类。Django提供了一些这个基类的扩展：
- en: Simple TestCase
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单的TestCase
- en: 'Extends `unittest.TestCase`with some basic functionality like:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展`unittest.TestCase`，具有一些基本功能，如：
- en: Saving and restoring the Python warning machinery state.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存和恢复Python警告机制的状态。
- en: 'Adding a number of useful assertions including:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了一些有用的断言，包括：
- en: Checking that a callable raises a certain exception.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查可调用对象是否引发了特定异常。
- en: Testing form field rendering and error treatment.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试表单字段的呈现和错误处理。
- en: Testing HTML responses for the presence/lack of a given fragment.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试HTML响应中是否存在/缺少给定的片段。
- en: Verifying that a template has/hasn't been used to generate a given response
    content.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证模板是否已/未用于生成给定的响应内容。
- en: Verifying a HTTP redirect is performed by the app.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证应用程序执行了HTTP重定向。
- en: Robustly testing two HTML fragments for equality/inequality or containment.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强大地测试两个HTML片段的相等性/不相等性或包含关系。
- en: Robustly testing two XML fragments for equality/inequality.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强大地测试两个XML片段的相等性/不相等性。
- en: Robustly testing two JSON fragments for equality.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强大地测试两个JSON片段的相等性。
- en: The ability to run tests with modified settings.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用修改后的设置运行测试的能力。
- en: Using the test `Client`.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用测试`Client`。
- en: Custom test-time URL maps.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义测试时间URL映射。
- en: Transaction TestCase
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Transaction TestCase
- en: Django's `TestCase` class (described in following paragraph) makes use of database
    transaction facilities to speed up the process of resetting the database to a
    known state at the beginning of each test. A consequence of this, however, is
    that some database behaviors cannot be tested within a Django `TestCase` class.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Django的`TestCase`类（在下一段中描述）利用数据库事务设施来加快在每个测试开始时将数据库重置为已知状态的过程。然而，这样做的一个后果是，一些数据库行为无法在Django的`TestCase`类中进行测试。
- en: 'In those cases, you should use `TransactionTestCase`. `TransactionTestCase`
    and `TestCase` are identical except for the manner in which the database is reset
    to a known state and the ability for test code to test the effects of commit and
    rollback:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，您应该使用`TransactionTestCase`。`TransactionTestCase`和`TestCase`除了数据库重置到已知状态的方式和测试代码测试提交和回滚的效果外，两者是相同的：
- en: A `TransactionTestCase` resets the database after the test runs by truncating
    all tables. A `TransactionTestCase` may call commit and rollback and observe the
    effects of these calls on the database.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TransactionTestCase`通过截断所有表在测试运行后重置数据库。`TransactionTestCase`可以调用提交和回滚，并观察这些调用对数据库的影响。'
- en: A `TestCase`, on the other hand, does not truncate tables after a test. Instead,
    it encloses the test code in a database transaction that is rolled back at the
    end of the test. This guarantees that the rollback at the end of the test restores
    the database to its initial state.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，`TestCase`在测试后不会截断表。相反，它将测试代码封装在数据库事务中，在测试结束时回滚。这保证了测试结束时的回滚将数据库恢复到其初始状态。
- en: '`TransactionTestCase` inherits from `SimpleTestCase`.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`TransactionTestCase`继承自`SimpleTestCase`。'
- en: TestCase
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TestCase
- en: 'This class provides some additional capabilities that can be useful for testing
    web sites. Converting a normal `unittest.TestCase` to a Django `TestCase` is easy:
    Just change the base class of your test from `unittest.TestCase` to `django.test.TestCase`.
    All of the standard Python unit test functionality will continue to be available,
    but it will be augmented with some useful additions, including:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类提供了一些对于测试网站有用的额外功能。将普通的`unittest.TestCase`转换为Django的`TestCase`很容易：只需将测试的基类从`unittest.TestCase`更改为`django.test.TestCase`。所有标准的Python单元测试功能仍然可用，但它将增加一些有用的附加功能，包括：
- en: Automatic loading of fixtures.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动加载fixture。
- en: 'Wraps the tests within two nested `atomic` blocks: one for the whole class
    and one for each test.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将测试包装在两个嵌套的`atomic`块中：一个用于整个类，一个用于每个测试。
- en: Creates a `TestClient` instance.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`TestClient`实例。
- en: Django-specific assertions for testing for things like redirection and form
    errors.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于测试重定向和表单错误等内容的Django特定断言。
- en: '`TestCase` inherits from `TransactionTestCase`.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestCase`继承自`TransactionTestCase`。'
- en: LiveServerTestCase
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LiveServerTestCase
- en: '`LiveServerTestCase` does basically the same as `TransactionTestCase` with
    one extra feature: it launches a live Django server in the background on setup,
    and shuts it down on teardown. This allows the use of automated test clients other
    than the Django dummy client such as, for example, the Selenium client, to execute
    a series of functional tests inside a browser and simulate a real user''s actions.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`LiveServerTestCase`基本上与`TransactionTestCase`相同，只是多了一个功能：它在设置时在后台启动一个实时的Django服务器，并在拆卸时关闭它。这允许使用除Django虚拟客户端之外的自动化测试客户端，例如Selenium客户端，来在浏览器中执行一系列功能测试并模拟真实用户的操作。'
- en: Test cases features
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试用例特性
- en: Default test client
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认测试客户端
- en: 'Every test case in a `*TestCase` instance has access to an instance of a Django
    test client. This client can be accessed as `self.client`. This client is recreated
    for each test, so you don''t have to worry about state (such as cookies) carrying
    over from one test to another. This means, instead of instantiating a `Client`
    in each test:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`*TestCase`实例中的每个测试用例都可以访问Django测试客户端的一个实例。可以将此客户端访问为`self.client`。每个测试都会重新创建此客户端，因此您不必担心状态（例如cookies）从一个测试传递到另一个测试。这意味着，而不是在每个测试中实例化`Client`：'
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '... you can just refer to `self.client`, like so:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '...您可以像这样引用`self.client`：'
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Fixture loading
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: fixture加载
- en: A test case for a database-backed website isn't much use if there isn't any
    data in the database. To make it easy to put test data into the database, Django's
    custom `TransactionTestCase` class provides a way of loading fixtures. A fixture
    is a collection of data that Django knows how to import into a database. For example,
    if your site has user accounts, you might set up a fixture of fake user accounts
    in order to populate your database during tests.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据库支持的网站的测试用例没有任何数据，则没有多大用处。为了方便地将测试数据放入数据库，Django的自定义`TransactionTestCase`类提供了一种加载fixtures的方法。fixture是Django知道如何导入到数据库中的数据集合。例如，如果您的网站有用户帐户，您可能会设置一个虚假用户帐户的fixture，以便在测试期间填充数据库。
- en: 'The most straightforward way of creating a fixture is to use the `manage.pydumpdata`
    command. This assumes you already have some data in your database. See the `dumpdata`
    documentation for more details. Once you''ve created a fixture and placed it in
    a `fixtures` directory in one of your `INSTALLED_APPS`, you can use it in your
    unit tests by specifying a `fixtures` class attribute on your `django.test.TestCase`
    subclass:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 创建fixture的最直接方法是使用`manage.pydumpdata`命令。这假设您的数据库中已经有一些数据。有关更多详细信息，请参阅`dumpdata`文档。创建fixture并将其放置在`INSTALLED_APPS`中的`fixtures`目录中后，您可以通过在`django.test.TestCase`子类的`fixtures`类属性上指定它来在单元测试中使用它：
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here''s specifically what will happen:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，将发生以下情况：
- en: At the start of each test case, before `setUp()` is run, Django will flush the
    database, returning the database to the state it was in directly after `migrate`
    was called.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个测试用例开始之前，在运行`setUp()`之前，Django将刷新数据库，将数据库返回到直接在调用`migrate`之后的状态。
- en: Then, all the named fixtures are installed. In this example, Django will install
    any JSON fixture named `mammals`, followed by any fixture named `birds`. See the
    `loaddata` documentation for more details on defining and installing fixtures.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，所有命名的fixtures都将被安装。在此示例中，Django将安装名为`mammals`的任何JSON fixture，然后是名为`birds`的任何fixture。有关定义和安装fixtures的更多详细信息，请参阅`loaddata`文档。
- en: This flush/load procedure is repeated for each test in the test case, so you
    can be certain that the outcome of a test will not be affected by another test,
    or by the order of test execution. By default, fixtures are only loaded into the
    `default` database. If you are using multiple databases and set `multi_db=True`,
    fixtures will be loaded into all databases.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个刷新/加载过程对测试用例中的每个测试都会重复进行，因此您可以确保一个测试的结果不会受到另一个测试或测试执行顺序的影响。默认情况下，fixture只加载到`default`数据库中。如果您使用多个数据库并设置`multi_db=True`，fixture将加载到所有数据库中。
- en: Overriding settings
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 覆盖设置
- en: Note
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Use the functions  to temporarily alter the value of settings in tests. Don't
    manipulate `django.conf.settings` directly as Django won't restore the original
    values after such manipulations.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数在测试中临时更改设置的值。不要直接操作`django.conf.settings`，因为Django不会在此类操作后恢复原始值。
- en: settings()
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: settings()
- en: 'For testing purposes it''s often useful to change a setting temporarily and
    revert to the original value after running the testing code. For this use case
    Django provides a standard Python context manager (see PEP 343at [https://www.python.org/dev/peps/pep-0343](https://www.python.org/dev/peps/pep-0343))
    called `settings()`, which can be used like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试目的，通常在运行测试代码后临时更改设置并恢复到原始值是很有用的。对于这种用例，Django提供了一个标准的Python上下文管理器（参见PEP
    343at [https://www.python.org/dev/peps/pep-0343](https://www.python.org/dev/peps/pep-0343)）称为`settings()`，可以像这样使用：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This example will override the `LOGIN_URL` setting for the code in the `with`
    block and reset its value to the previous state afterwards.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将在`with`块中覆盖`LOGIN_URL`设置，并在之后将其值重置为先前的状态。
- en: modify_settings()
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: modify_settings()
- en: 'It can prove unwieldy to redefine settings that contain a list of values. In
    practice, adding or removing values is often sufficient. The `modify_settings()`
    context manager makes it easy:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 重新定义包含值列表的设置可能会变得难以处理。实际上，添加或删除值通常就足够了。`modify_settings()`上下文管理器使这变得很容易：
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For each action, you can supply either a list of values or a string. When the
    value already exists in the list, `append` and `prepend` have no effect; neither
    does `remove` when the value doesn't exist.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个操作，您可以提供一个值列表或一个字符串。当值已经存在于列表中时，`append`和`prepend`没有效果；当值不存在时，`remove`也没有效果。
- en: override_settings()
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: override_settings()
- en: 'In case you want to override a setting for a test method, Django provides the
    `override_settings()` decorator (see PEP 318 at [https://www.python.org/dev/peps/pep-0318](https://www.python.org/dev/peps/pep-0318)).
    It''s used like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要为测试方法覆盖设置，Django提供了`override_settings()`装饰器（请参阅[https://www.python.org/dev/peps/pep-0318](https://www.python.org/dev/peps/pep-0318)的PEP
    318）。用法如下：
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The decorator can also be applied to `TestCase` classes:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器也可以应用于`TestCase`类：
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: modify_settings()
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: modify_settings()
- en: 'Likewise, Django provides the `modify_settings()` decorator:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，Django还提供了`modify_settings()`装饰器：
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The decorator can also be applied to test case classes:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器也可以应用于测试用例类：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When overriding settings, make sure to handle the cases in which your app's
    code uses a cache or similar feature that retains state even if the setting is
    changed. Django provides the `django.test.signals.setting_changed` signal that
    lets you register call-backs to clean up and otherwise reset state when settings
    are changed.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在覆盖设置时，请确保处理应用程序代码使用缓存或类似功能保留状态的情况，即使更改了设置。Django提供了`django.test.signals.setting_changed`信号，让您注册回调以在更改设置时清理和重置状态。
- en: Assertions
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 断言
- en: 'As Python''s normal `unittest.TestCase` class implements assertion methods
    such as `assertTrue()` and `assertEqual()`, Django''s custom `TestCase` class
    provides a number of custom assertion methods that are useful for testing web
    applications:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python的普通`unittest.TestCase`类实现了`assertTrue()`和`assertEqual()`等断言方法，Django的自定义`TestCase`类提供了许多对测试Web应用程序有用的自定义断言方法：
- en: '`assertRaisesMessage`: Asserts that execution of the callable object raised
    an exception with an `expected_message` representation.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertRaisesMessage`：断言可调用对象的执行引发了带有`expected_message`表示的异常。'
- en: '`assertFieldOutput`: Asserts that a form field behaves correctly with various
    inputs.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertFieldOutput`：断言表单字段对各种输入的行为是否正确。'
- en: '`assertFormError`: Asserts that a field on a form raises the provided list
    of errors when rendered on the form.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertFormError`：断言表单上的字段在表单上呈现时引发提供的错误列表。'
- en: '`assertFormsetError`: Asserts that the `formset` raises the provided list of
    errors when rendered.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertFormsetError`：断言`formset`在呈现时引发提供的错误列表。'
- en: '`assertContains`: Asserts that a `Response` instance produced the given `status_code`
    and that `text` appears in the content of the response.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertContains`：断言`Response`实例产生了给定的`status_code`，并且`text`出现在响应内容中。'
- en: '`assertNotContains`: Asserts that a `Response` instance produced the given
    `status_code` and that `text` does not appear in the content of the response.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertNotContains`：断言`Response`实例产生了给定的`status_code`，并且`text`不出现在响应内容中。'
- en: '`assertTemplateUsed`: Asserts that the template with the given name was used
    in rendering the response. The name is a string such as `''admin/index.html''`.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertTemplateUsed`：断言在呈现响应时使用了给定名称的模板。名称是一个字符串，例如`''admin/index.html''`。'
- en: '`assertTemplateNotUsed`: Asserts that the template with the given name was
    not used in rendering the response.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertTemplateNotUsed`：断言在呈现响应时未使用给定名称的模板。'
- en: '`assertRedirects`: Asserts that the response returned a `status_code` redirect
    status, redirected to `expected_url` (including any `GET` data), and that the
    final page was received with `target_status_code`.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertRedirects`：断言响应返回了`status_code`重定向状态，重定向到`expected_url`（包括任何`GET`数据），并且最终页面以`target_status_code`接收到。'
- en: '`assertHTMLEqual`: Asserts that the strings `html1` and `html2` are equal.
    The comparison is based on HTML semantics. The comparison takes following things
    into account:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertHTMLEqual`：断言字符串`html1`和`html2`相等。比较基于HTML语义。比较考虑以下内容：'
- en: Whitespace before and after HTML tags is ignored.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML标签前后的空白会被忽略。
- en: All types of whitespace are considered equivalent.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有类型的空白都被视为等效。
- en: All open tags are closed implicitly, for example, when a surrounding tag is
    closed or the HTML document ends.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有未关闭的标签都会被隐式关闭，例如，当周围的标签关闭或HTML文档结束时。
- en: Empty tags are equivalent to their self-closing version.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空标签等同于它们的自关闭版本。
- en: The ordering of attributes of an HTML element is not significant.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML元素的属性排序不重要。
- en: Attributes without an argument are equal to attributes that equal in name and
    value (see the examples).
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有参数的属性等同于名称和值相等的属性（请参阅示例）。
- en: '`assertHTMLNotEqual`: Asserts that the strings `html1` and `html2` are *not*
    equal. The comparison is based on HTML semantics. See `assertHTMLEqual()` for
    details.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertHTMLNotEqual`：断言字符串`html1`和`html2`*不*相等。比较基于HTML语义。详情请参阅`assertHTMLEqual()`。'
- en: '`assertXMLEqual`: Asserts that the strings `xml1` and `xml2` are equal. The
    comparison is based on XML semantics. Similarly to `assertHTMLEqual()`, the comparison
    is made on parsed content, hence only semantic differences are considered, not
    syntax differences.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertXMLEqual`：断言字符串`xml1`和`xml2`相等。比较基于XML语义。与`assertHTMLEqual()`类似，比较是基于解析内容的，因此只考虑语义差异，而不考虑语法差异。'
- en: '`assertXMLNotEqual`: Asserts that the strings `xml1` and `xml2` are *not* equal.
    The comparison is based on XML semantics. See `assertXMLEqual()` for details.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertXMLNotEqual`：断言字符串`xml1`和`xml2`*不*相等。比较基于XML语义。详情请参阅`assertXMLEqual()`。'
- en: '`assertInHTML`: Asserts that the HTML fragment `needle` is contained in the
    `haystack` one.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertInHTML`：断言HTML片段`needle`包含在`haystack`中。'
- en: '`assertJSONEqual`: Asserts that the JSON fragments `raw` and `expected_data`
    are equal.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertJSONEqual`：断言JSON片段`raw`和`expected_data`相等。'
- en: '`assertJSONNotEqual`: Asserts that the JSON fragments `raw` and `expected_data`
    are not equal.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertJSONNotEqual`：断言JSON片段`raw`和`expected_data`不相等。'
- en: '`assertQuerysetEqual`: Asserts that a queryset`qs` returns a particular list
    of values `values`. The comparison of the contents of `qs` and `values` is performed
    using the function `transform`; by default, this means that the `repr()` of each
    value is compared.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertQuerysetEqual`：断言查询集`qs`返回特定的值列表`values`。使用`transform`函数执行`qs`和`values`的内容比较；默认情况下，这意味着比较每个值的`repr()`。'
- en: '`assertNumQueries`: Asserts that when `func` is called with `*args` and `**kwargs`
    that `num` database queries are executed.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertNumQueries`：断言当使用`*args`和`**kwargs`调用`func`时，将执行`num`个数据库查询。'
- en: Email services
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电子邮件服务
- en: If any of your Django views send email using Django's email functionality, you
    probably don't want to send email each time you run a test using that view. For
    this reason, Django's test runner automatically redirects all Django-sent email
    to a dummy outbox. This lets you test every aspect of sending email-from the number
    of messages sent to the contents of each message-without actually sending the
    messages. The test runner accomplishes this by transparently replacing the normal
    email backend with a testing backend. (Don't worry-this has no effect on any other
    email senders outside of Django, such as your machine's mail server, if you're
    running one.)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的Django视图使用Django的电子邮件功能发送电子邮件，您可能不希望每次使用该视图运行测试时都发送电子邮件。因此，Django的测试运行器会自动将所有Django发送的电子邮件重定向到一个虚拟的outbox。这样，您可以测试发送电子邮件的每个方面，从发送的消息数量到每个消息的内容，而无需实际发送消息。测试运行器通过透明地将正常的电子邮件后端替换为测试后端来实现这一点。（不用担心-这不会对Django之外的任何其他电子邮件发送者产生影响，比如您的机器邮件服务器，如果您正在运行的话。）
- en: 'During test running, each outgoing email is saved in `django.core.mail.outbox`.
    This is a simple list of all `EmailMessage` instances that have been sent. The
    `outbox` attribute is a special attribute that is created only when the `locmem`
    email backend is used. It doesn''t normally exist as part of the `django.core.mail`
    module and you can''t import it directly. The following code shows how to access
    this attribute correctly. Here''s an example test that examines `django.core.mail.outbox`
    for length and contents:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试运行期间，每封发送的电子邮件都会保存在`django.core.mail.outbox`中。这是所有已发送的`EmailMessage`实例的简单列表。`outbox`属性是仅在使用`locmem`电子邮件后端时才会创建的特殊属性。它通常不作为`django.core.mail`模块的一部分存在，也不能直接导入。以下代码显示了如何正确访问此属性。以下是一个检查`django.core.mail.outbox`长度和内容的示例测试：
- en: '[PRE15]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As noted previously, the test outbox is emptied at the start of every test
    in a Django `*TestCase`. To empty the outbox manually, assign the empty list to
    `mail.outbox`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在Django的`*TestCase`中，测试outbox在每个测试开始时都会被清空。要手动清空outbox，请将空列表分配给`mail.outbox`：
- en: '[PRE16]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Management commands
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理命令
- en: 'Management commands can be tested with the `call_command()` function. The output
    can be redirected into a `StringIO` instance:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`call_command()`函数测试管理命令。输出可以重定向到`StringIO`实例中：
- en: '[PRE17]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Skipping tests
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跳过测试
- en: The `unittest` library provides the `@skipIf` and `@skipUnless` decorators to
    allow you to skip tests if you know ahead of time that those tests are going to
    fail under certain conditions. For example, if your test requires a particular
    optional library in order to succeed, you could decorate the test case with `@skipIf`.
    Then, the test runner will report that the test wasn't executed and why, instead
    of failing the test or omitting the test altogether.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest`库提供了`@skipIf`和`@skipUnless`装饰器，允许您在预先知道这些测试在特定条件下会失败时跳过测试。例如，如果您的测试需要特定的可选库才能成功，您可以使用`@skipIf`装饰测试用例。然后，测试运行器将报告该测试未被执行以及原因，而不是失败测试或完全省略测试。'
- en: The test database
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试数据库
- en: Tests that require a database (namely, model tests) will not use your production
    database; separate, blank databases are created for the tests. Regardless of whether
    the tests pass or fail, the test databases are destroyed when all the tests have
    been executed. You can prevent the test databases from being destroyed by adding
    the `-keepdb` flag to the test command. This will preserve the test database between
    runs.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 需要数据库的测试（即模型测试）不会使用生产数据库；测试时会为其创建单独的空白数据库。无论测试是否通过，测试数据库在所有测试执行完毕时都会被销毁。您可以通过在测试命令中添加`-keepdb`标志来阻止测试数据库被销毁。这将在运行之间保留测试数据库。
- en: If the database does not exist, it will first be created. Any migrations will
    also be applied in order to keep it up to date. By default, the test databases
    get their names by prepending `test_` to the value of the `NAME` settings for
    the databases defined in `DATABASES`. When using the SQLite database engine, the
    tests will by default use an in-memory database (that is, the database will be
    created in memory, bypassing the filesystem entirely!).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据库不存在，将首先创建它。任何迁移也将被应用以保持数据库的最新状态。默认情况下，测试数据库的名称是在`DATABASES`中定义的数据库的`NAME`设置值前加上`test_`。在使用SQLite数据库引擎时，默认情况下测试将使用内存数据库（即，数据库将在内存中创建，完全绕过文件系统！）。
- en: 'If you want to use a different database name, specify `NAME` in the `TEST`
    dictionary for any given database in `DATABASES`. On PostgreSQL, `USER` will also
    need read access to the built-in `postgres` database. Aside from using a separate
    database, the test runner will otherwise use all of the same database settings
    you have in your settings file: `ENGINE`, `USER`, `HOST`, and so on. The test
    database is created by the user specified by `USER`, so you''ll need to make sure
    that the given user account has sufficient privileges to create a new database
    on the system.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要使用不同的数据库名称，请在`DATABASES`中为任何给定数据库的`TEST`字典中指定`NAME`。在PostgreSQL上，`USER`还需要对内置的`postgres`数据库具有读取权限。除了使用单独的数据库外，测试运行器将使用与设置文件中相同的数据库设置：`ENGINE`、`USER`、`HOST`等。测试数据库由`USER`指定的用户创建，因此您需要确保给定的用户帐户具有在系统上创建新数据库的足够权限。
- en: Using different testing frameworks
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用不同的测试框架
- en: Clearly, `unittest` is not the only Python testing framework. While Django doesn't
    provide explicit support for alternative frameworks, it does provide a way to
    invoke tests constructed for an alternative framework as if they were normal Django
    tests.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`unittest`并不是唯一的Python测试框架。虽然Django不提供对替代框架的显式支持，但它提供了一种调用为替代框架构建的测试的方式，就像它们是普通的Django测试一样。
- en: 'When you run `./manage.py test`, Django looks at the `TEST_RUNNER` setting
    to determine what to do. By default, `TEST_RUNNER` points to `django.test.runner.DiscoverRunner`.
    This class defines the default Django testing behavior. This behavior involves:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行`./manage.py test`时，Django会查看`TEST_RUNNER`设置以确定要执行的操作。默认情况下，`TEST_RUNNER`指向`django.test.runner.DiscoverRunner`。这个类定义了默认的Django测试行为。这种行为包括：
- en: Performing global pre-test setup.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行全局的测试前设置。
- en: Looking for tests in any of the following file the in current directory whose
    name matches the pattern `test*.py`.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在当前目录中查找任何以下文件中的测试，其名称与模式`test*.py`匹配。
- en: Creating the test databases.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建测试数据库。
- en: Running migrate to install models and initial data into the test databases.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行迁移以将模型和初始数据安装到测试数据库中。
- en: Running the tests that were found.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行找到的测试。
- en: Destroying the test databases.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 销毁测试数据库。
- en: Performing global post-test teardown.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行全局的测试后拆卸。
- en: If you define your own test runner class and point `TEST_RUNNER` at that class,
    Django will execute your test runner whenever you run `./manage.py test`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您定义自己的测试运行器类并将`TEST_RUNNER`指向该类，Django将在运行`./manage.py test`时执行您的测试运行器。
- en: In this way, it's possible to use any test framework that can be executed from
    Python code, or to modify the Django test execution process to satisfy whatever
    testing requirements you may have.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，可以使用任何可以从Python代码执行的测试框架，或者修改Django测试执行过程以满足您可能有的任何测试要求。
- en: See the Django Project website for more information on using different testing
    frameworks.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看Django项目网站，了解更多关于使用不同测试框架的信息。
- en: What's next?
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来呢？
- en: Now that you know how to write tests for your Django projects, we will be moving
    on to a very important topic once you are ready to turn your project into a real
    live website-deploying Django to a web server.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道如何为您的Django项目编写测试，一旦您准备将项目变成一个真正的网站，我们将继续讨论一个非常重要的话题-将Django部署到Web服务器。
