- en: Chapter 10. The Functools Module
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。Functools模块
- en: Functional programming emphasizes functions as first class objects. We have
    many high-order functions that accept functions as arguments or return functions
    as results. In this chapter, we'll look at the `functools` library with some functions
    to help us create and modify functions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程强调函数作为一等对象。我们有许多接受函数作为参数或返回函数作为结果的高阶函数。在本章中，我们将查看`functools`库，其中包含一些函数来帮助我们创建和修改函数。
- en: We'll look at some higher-order functions in this chapter. Earlier, we looked
    at higher-order functions in [Chapter 5](ch05.html "Chapter 5. Higher-order Functions"),
    *Higher-order Functions*. We'll continue to look at higher-order function techniques
    in [Chapter 11](ch11.html "Chapter 11. Decorator Design Techniques"), *Decorator
    Design Techniques*, as well.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中查看一些高阶函数。之前，我们在[第5章](ch05.html "第5章。高阶函数")中看了高阶函数。我们还将在[第11章](ch11.html
    "第11章。装饰器设计技术")中继续研究高阶函数技术，*装饰器设计技术*。
- en: 'We''ll look at the following functions in this module:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本模块中，我们将查看以下函数：
- en: '`@lru_cache`: This decorator can be a huge performance boost for certain types
    of applications.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@lru_cache`：这个装饰器对某些类型的应用程序可能会带来巨大的性能提升。'
- en: '`@total_ordering`: This decorator can help create rich comparison operators.
    However, it lets us look at the more general question of object-oriented design
    mixed with functional programming.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@total_ordering`：这个装饰器可以帮助创建丰富的比较运算符。然而，它让我们看到了面向对象设计与函数式编程的更一般问题。'
- en: '`partial()`: It creates a new function with some arguments applied to a given
    function.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`partial（）`：它创建一个应用于给定函数的一些参数的新函数。'
- en: '`reduce()`: It is a higher-order function which generalizes reductions like
    `sum()`.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reduce（）`：它是一个泛化的`sum（）`等归约的高阶函数。'
- en: 'We''ll defer two additional members of this library to [Chapter 11](ch11.html
    "Chapter 11. Decorator Design Techniques"), *Decorator Design Techniques*: the
    `update_wrapper()` and `wraps()` functions. We''ll look more closely at writing
    our own decorators in the next chapter also.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个库的另外两个成员推迟到[第11章](ch11.html "第11章。装饰器设计技术")，*装饰器设计技术*：`update_wrapper（）`和`wraps（）`函数。我们还将在下一章更仔细地研究编写我们自己的装饰器。
- en: We'll ignore the `cmp_to_key()` function entirely. Its purpose is to help with
    converting Python 2 code—which uses a comparison—to run under Python 3 which uses
    key extraction. We're only interested in Python 3; we'll write proper key functions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将完全忽略`cmp_to_key（）`函数。它的目的是帮助转换Python 2代码（使用比较）以在Python 3下运行，Python 3使用键提取。我们只对Python
    3感兴趣；我们将编写适当的键函数。
- en: Function tools
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数工具
- en: We looked at a number of higher-order functions in [Chapter 5](ch05.html "Chapter 5. Higher-order
    Functions"), *Higher-order Functions*. These functions either accepted a function
    as an argument or returned a function (or generator expression) as a result. All
    these higher-order functions had an essential algorithm which was customized by
    injecting another function. Functions like `max()`, `min()`, and `sorted()` accepted
    a `key=` function that customized their behavior. Functions like `map()` and `filter()`
    accept a function and an iterable and apply this function to the arguments. In
    the case of the `map()` function, the results of the function are simply kept.
    In the case of the `filter()` function, the Boolean result of the function is
    used to pass or reject values from the iterable.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第5章](ch05.html "第5章。高阶函数")中看了许多高阶函数，*高阶函数*。这些函数要么接受一个函数作为参数，要么返回一个函数（或生成器表达式）作为结果。所有这些高阶函数都有一个基本算法，可以通过注入另一个函数来定制。像`max（）`，`min（）`和`sorted（）`这样的函数接受一个`key=`函数来定制它们的行为。像`map（）`和`filter（）`这样的函数接受一个函数和一个可迭代对象，并将该函数应用于参数。在`map（）`函数的情况下，函数的结果被简单地保留。在`filter（）`函数的情况下，函数的布尔结果用于从可迭代对象中传递或拒绝值。
- en: 'All the functions in [Chapter 5](ch05.html "Chapter 5. Higher-order Functions"),
    *Higher-order Functions* are part of the Python `__builtins__` package: they''re
    available without the need to do an `import`. They are ubiquitous because they
    are so universally useful. The functions in this chapter must be introduced with
    an `import` because they''re not quite so universally usable.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[第5章](ch05.html "第5章。高阶函数")中的所有函数，*高阶函数*都是Python `__builtins__`包的一部分：它们无需进行`import`即可使用。它们是无处不在的，因为它们非常普遍有用。本章中的函数必须通过`import`引入，因为它们并不是如此普遍可用。'
- en: The `reduce()` function straddles this fence. It was originally built-in. After
    much discussion, it was removed from the `__builtins__` package because of the
    possibility of abuse. Some seemingly simple operations can perform remarkably
    poorly.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce（）`函数跨越了这个界限。它最初是内置的。经过多次讨论，它从`__builtins__`包中移除，因为可能会被滥用。一些看似简单的操作可能表现得非常糟糕。'
- en: Memoizing previous results with lru_cache
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用lru_cache进行记忆先前的结果
- en: 'The `lru_cache` decorator transforms a given function into a function that
    might perform more quickly. The **LRU** means **Least Recently Used**: a finite
    pool of recently used items is retained. Items not frequently used are discarded
    to keep the pool to a bounded size.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`lru_cache`装饰器将给定的函数转换为可能执行得更快的函数。**LRU**表示**最近最少使用**：保留了一组最近使用的项目。不经常使用的项目被丢弃以保持池的有界大小。'
- en: 'Since this is a decorator, we can apply it to any function that might benefit
    from caching previous results. We might use it as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个装饰器，我们可以将其应用于任何可能从缓存先前结果中受益的函数。我们可以这样使用它：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is an example based on [Chapter 6](ch06.html "Chapter 6. Recursions and
    Reductions"), *Recursions and Reductions*. We've applied the `@lru_cache` decorator
    to the naïve Fibonacci number calculation. Because of this decoration, each call
    to the `fibc(n)` function will now be checked against a cache maintained by the
    decorator. If the argument, `n`, is in the cache, the previously computed result
    is used instead of doing a potentially expensive re-calculation. Each return value
    is added to the cache. When the cache is full, the oldest value is ejected to
    make room for a new value.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是基于[第6章](ch06.html "第6章。递归和简化")的一个例子，*递归和简化*。我们已经将`@lru_cache`装饰器应用于天真的斐波那契数计算。由于这个装饰，对`fibc(n)`函数的每次调用现在将被检查装饰器维护的缓存。如果参数`n`在缓存中，将使用先前计算的结果，而不是进行可能昂贵的重新计算。每个返回值都被添加到缓存中。当缓存满时，最旧的值将被弹出以腾出空间给新值。
- en: We highlight this example because the naïve recursion is quite expensive in
    this case. The complexity of computing any given Fibonacci number, ![Memoizing
    previous results with lru_cache](graphics/B03652_10_01.jpg), involves not merely
    computing ![Memoizing previous results with lru_cache](graphics/B03652_10_02.jpg)
    but ![Memoizing previous results with lru_cache](graphics/B03652_10_03.jpg) also.
    This tree of values leads to a complexity in the order of ![Memoizing previous
    results with lru_cache](graphics/B03652_10_04.jpg).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强调这个例子，因为在这种情况下，天真的递归是非常昂贵的。计算任何给定的斐波那契数的复杂性，![Memoizing previous results
    with lru_cache](graphics/B03652_10_01.jpg)，不仅涉及计算![Memoizing previous results
    with lru_cache](graphics/B03652_10_02.jpg)，还涉及计算![Memoizing previous results with
    lru_cache](graphics/B03652_10_03.jpg)。这些值的树导致了一个![Memoizing previous results with
    lru_cache](graphics/B03652_10_04.jpg)的复杂度。
- en: 'We can try to confirm the benefits empirically using the `timeit` module. We
    can execute the two implementations a thousand times each to see how the timing
    compares. Using the `fib(20)` and `fibc(20)` methods shows just how costly this
    calculation is without the benefit of caching. Because the naïve version is so
    slow, the `timeit` number of repetitions was reduced to only 1,000\. Following
    are the results:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试使用`timeit`模块来经验性地确认这些好处。我们可以分别执行两种实现一千次，以查看时间的比较。使用`fib(20)`和`fibc(20)`方法显示了没有缓存的情况下这个计算是多么昂贵。因为天真的版本太慢了，`timeit`的重复次数被减少到只有1,000次。以下是结果：
- en: Naive 3.23
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Naive 3.23
- en: Cached 0.0779
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存 0.0779
- en: 'Note that we can''t trivially use the `timeit` module on the `fibc()` function.
    The cached values will remain in place: we''ll only compute the `fibc(20)` function
    once, which populates this value in the cache. Each of the remaining 999 iterations
    will simply fetch the value from the cache. We need to actually clear the cache
    between uses of the `fibc()` function or the time drops to almost 0\. This is
    done with a `fibc.cache_clear()` method built by the decorator.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们无法在`fibc()`函数上轻易使用`timeit`模块。缓存的值将保持不变：我们只会计算一次`fibc(20)`函数，这将在缓存中填充这个值。其余的999次迭代将简单地从缓存中获取值。我们需要在使用`fibc()`函数之间清除缓存，否则时间几乎降为0。这是通过装饰器构建的`fibc.cache_clear()`方法来完成的。
- en: The concept of memoization is powerful. There are many algorithms that can benefit
    from memoization of results. There are also some algorithms that might not benefit
    quite so much.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆化的概念是强大的。有许多算法可以从结果的记忆化中受益。也有一些算法可能受益不那么多。
- en: 'The number of combinations of `p` things taken in groups of `r` is often stated
    as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`p`个事物中以`r`个为一组的组合数通常被陈述如下：'
- en: '![Memoizing previous results with lru_cache](graphics/B03652_10_05.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![Memoizing previous results with lru_cache](graphics/B03652_10_05.jpg)'
- en: This binomial function involves computing three factorial values. It might make
    sense to use an `@lru_cache` decorator on a factorial function. A program that
    calculates a number of binomial values will not need to re-compute all of those
    factorials. For cases where similar values are computed repeatedly, the speedup
    can be impressive. For situations where the cached values are rarely reused, the
    overheads of maintaining the cached values outweigh any speedups.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个二项式函数涉及计算三个阶乘值。在阶乘函数上使用`@lru_cache`装饰器可能是有意义的。计算一系列二项式值的程序将不需要重新计算所有这些阶乘。对于重复计算类似值的情况，加速可能会令人印象深刻。对于很少重复使用缓存值的情况，维护缓存值的开销超过了任何加速。
- en: 'When computing similar values repeatedly, we see the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当重复计算类似值时，我们看到以下结果：
- en: Naive Factorial 0.174
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Naive Factorial 0.174
- en: Cached Factorial 0.046
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存阶乘 0.046
- en: Cleared Cache Factorial 1.335
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清除缓存阶乘 1.335
- en: If we re-calculate the same binomial with the `timeit` module, we'll only really
    do the computation once, and return the same value the rest of the time; the cleared
    cache factorial shows the impact of clearing the cache before each calculation.
    The cache clearing operation—the `cache_clear()` function—introduces some overheads,
    making it appear more costly than it actually is. The moral of the story is that
    an `lru_cache` decorator is trivial to add. It often has a profound impact; but
    it may also have no impact, depending on the distribution of the actual data.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`timeit`模块重新计算相同的二项式，我们只会真正计算一次，并在其余时间返回相同的值；清除缓存的阶乘显示了在每次计算之前清除缓存的影响。清除缓存操作——`cache_clear()`函数——引入了一些开销，使其看起来比实际上更昂贵。故事的寓意是`lru_cache`装饰器很容易添加。它经常产生深远的影响；但也可能没有影响，这取决于实际数据的分布。
- en: 'It''s important to note that the cache is a stateful object. This design pushes
    the edge of the envelope on purely functional programming. A possible ideal is
    to avoid assignment statements and the associated changes of state. This concept
    of avoiding stateful variables is exemplified by a recursive function: the current
    state is contained in the argument values, and not in the changing values of variables.
    We''ve seen how tail-call optimization is an essential performance improvement
    to assure that this idealized recursion actually works nicely with the available
    processor hardware and limited memory budgets. In Python, we do this tail-call
    optimization manually by replacing the tail recursions with a `for` loop. Caching
    is a similar kind of optimization: we''ll implement it manually as needed.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，缓存是一个有状态的对象。这种设计推动了纯函数式编程的边界。一个可能的理想是避免赋值语句和相关状态的改变。避免有状态变量的概念通过递归函数得到了体现：当前状态包含在参数值中，而不是在变量的变化值中。我们已经看到，尾递归优化是一种必要的性能改进，以确保这种理想化的递归实际上可以很好地与可用的处理器硬件和有限的内存预算配合使用。在Python中，我们通过用`for`循环替换尾递归来手动进行尾递归优化。缓存是一种类似的优化：我们将根据需要手动实现它。
- en: 'In principle, each call to a function with an LRU cache has two results: the
    expected result and a new cache object which should be used for all future requests.
    Pragmatically, we encapsulate the new cache object inside the decorated version
    of the `fibc()` function.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，每次调用带有LRU缓存的函数都有两个结果：预期结果和一个新的缓存对象，应该用于以后的所有请求。实际上，我们将新的缓存对象封装在`fibc()`函数的装饰版本内。
- en: Caching is not a panacea. Applications that work with float values might not
    benefit much from memoization because all floats differ by small amounts. The
    least-significant bits of a float value are sometimes just random noise which
    prevents the exact equality test in the `lru_cache` decorator from working.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存并不是万能的。与浮点值一起工作的应用程序可能不会从记忆化中受益太多，因为所有浮点数之间的差异都很小。浮点值的最低有效位有时只是随机噪音，这会阻止`lru_cache`装饰器中的精确相等测试。
- en: We'll revisit this in [Chapter 16](ch16.html "Chapter 16. Optimizations and
    Improvements"), *Optimizations and Improvements*. We'll look at some additional
    ways to implement this.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第16章](ch16.html "第16章。优化和改进")中重新讨论这个问题，*优化和改进*。我们将看一些其他实现这个的方法。
- en: Defining classes with total ordering
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义具有完全排序的类
- en: The `total_ordering` decorator is helpful for creating new class definitions
    that implement a rich set of comparison operators. This might apply to numeric
    classes that subclass `numbers.Number`. It may also apply to semi-numeric classes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`total_ordering`装饰器有助于创建实现丰富的比较运算符的新类定义。这可能适用于子类`numbers.Number`的数值类。它也可能适用于半数值类。'
- en: As an example of a semi-numeric class, consider a playing card. It has a numeric
    rank and a symbolic suit. The rank matters only when doing simulations of some
    games. This is particularly important when simulating casino Blackjack. Like numbers,
    cards have an ordering. We often sum the point values of each card, making them
    number-like. However, multiplication of *card × card* doesn't really make any
    sense.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个半数值类的例子，考虑一张扑克牌。它有一个数值rank和一个符号suit。只有在模拟某些游戏时，rank才重要。这在模拟赌场二十一点时尤为重要。像数字一样，卡牌有一个顺序。我们经常对每张卡的点数进行求和，使它们类似于数字。然而，*card
    × card*的乘法实际上没有任何意义。
- en: 'We can almost emulate a playing card with a `namedtuple()` function as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎可以用`namedtuple()`函数模拟一张扑克牌：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This suffers from a profound limitation: all comparisons include both a rank
    and a suit by default. This leads to the following awkward behavior:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这受到了一个深刻的限制：所有比较默认包括rank和suit。这导致了以下尴尬的行为：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This doesn't work well for Blackjack. It's unsuitable for certain Poker simulations
    also.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于二十一点游戏不起作用。它也不适用于某些扑克模拟。
- en: 'We''d really prefer the cards to be compared only by their rank. Following
    is a much more useful class definition. We''ll show this in two parts. The first
    part defines the essential attributes:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真的希望卡片只按照它们的rank进行比较。以下是一个更有用的类定义。我们将分两部分展示。第一部分定义了基本属性：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This class extends the `tuple` class; it has no additional slots, thereby making
    it immutable. We've overridden the `__new__()` method so that we can seed initial
    values of a rank and a suit. We've provided a `__repr__()` method to print a string
    representation of a `Card`. We've provided two properties to extract a rank and
    a suit using attribute names.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类扩展了`tuple`类；它没有额外的插槽，因此是不可变的。我们重写了`__new__()`方法，以便我们可以初始化一个rank和一个suit的初始值。我们提供了一个`__repr__()`方法来打印`Card`的字符串表示。我们提供了两个属性，使用属性名称提取rank和suit。
- en: 'The rest of the class definition shows how we can define just two comparisons:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义的其余部分显示了我们如何定义只有两个比较：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We've defined the `__eq__()` and `__lt__()` functions. The `@total_ordering`
    decorator handles the construction of all other comparisons. In both cases, we've
    allowed comparisons between cards and also between a card and a number.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了`__eq__()`和`__lt__()`函数。`@total_ordering`装饰器处理了所有其他比较的构造。在这两种情况下，我们允许卡片之间的比较，也允许卡片和数字之间的比较。
- en: 'First, we get proper comparison of only the ranks as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们只能得到rank的正确比较如下：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can use this class for a number of simulations with simplified syntax to
    compare ranks of cards. Further, we also have a rich set of comparison operators
    as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个类进行许多模拟，使用简化的语法来比较卡牌的rank。此外，我们还有一套丰富的比较运算符，如下所示：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We didn't need to write all of the comparison method functions; they were generated
    by the decorator. The decorator's creation of operators isn't perfect. In our
    case, we've asked for comparisons with integers as well as between `Card` instances.
    This reveals some problems.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要编写所有的比较方法函数；它们是由装饰器生成的。装饰器创建的运算符并不完美。在我们的情况下，我们要求使用整数进行比较以及在`Card`实例之间进行比较。这揭示了一些问题。
- en: Operations like the `c4c > 3` and `3 < c4c` commands would raise `TypeError`
    exceptions. This is a limitation in what the `total_ordering` decorator can do.
    The problem rarely shows up in practice, since this kind of mixed-class coercion
    is relatively uncommon.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 像`c4c > 3`和`3 < c4c`这样的操作会引发`TypeError`异常。这是`total_ordering`装饰器的局限性。这种混合类强制转换在实践中很少出现问题，因为这种情况相对不常见。
- en: Object-oriented programming is not antithetical to functional programming. There
    is a realm in which the two techniques are complementary. Python's ability to
    create immutable objects works particularly well with functional programming techniques.
    We can easily avoid the complexities of stateful objects, but still benefit from
    encapsulation to keep related method functions together. It's particularly helpful
    to define class properties that involve complex calculations; this binds the calculations
    to the class definition, making the application easier to understand.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程并不与函数式编程对立。两种技术在某些领域是互补的。Python创建不可变对象的能力与函数式编程技术特别契合。我们可以轻松避免有状态对象的复杂性，但仍然受益于封装，以保持相关的方法函数在一起。定义涉及复杂计算的类属性特别有帮助；这将计算绑定到类定义，使应用程序更容易理解。
- en: Defining number classes
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义数字类
- en: In some cases, we might want to extend the numeric tower available in Python.
    A subclass of `numbers.Number` may simplify a functional program. We can, for
    example, isolate parts of a complex algorithm to the `Number` subclass definition,
    making other parts of the application simpler or clearer.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能希望扩展Python中可用的数字体系。`numbers.Number`的子类可能简化函数式程序。例如，我们可以将复杂算法的部分隔离到`Number`子类定义中，从而使应用程序的其他部分更简单或更清晰。
- en: Python already offers a rich variety of numeric types. The built-in types of
    the `int` and `float` variables cover a wide variety of problem domains. When
    working with currency, the `decimal.Decimal` package handles this elegantly. In
    some cases, we might find the `fractions.Fraction` class to be more appropriate
    than the `float` variable.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Python已经提供了丰富多样的数字类型。内置类型的`int`和`float`变量涵盖了各种问题领域。在处理货币时，`decimal.Decimal`包可以优雅地处理这个问题。在某些情况下，我们可能会发现`fractions.Fraction`类比`float`变量更合适。
- en: When working with geographic data, for example, we might consider creating a
    subclass of `float` variable that introduces additional attributes for conversion
    between degrees of latitude (or longitude) and radians. The arithmetic operations
    in this subclass could be done ![Defining number classes](graphics/B03652_10_06.jpg)
    to simplify calculations that move across the equator or the Greenwich meridian.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在处理地理数据时，我们可能考虑创建`float`变量的子类，引入额外的属性，用于在纬度（或经度）和弧度之间进行转换。这个子类中的算术操作可以简化穿越赤道或本初子午线的计算。
- en: Since Python `Numbers` class is intended to be immutable, ordinary functional
    design can be applied to all of the various method functions. The exceptional
    Python in-place special methods (for example, `__iadd__()` function) can be simply
    ignored.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python的`Numbers`类旨在是不可变的，普通的函数式设计可以应用于所有各种方法函数。特殊的Python就地特殊方法（例如，`__iadd__()`函数）可以简单地忽略。
- en: 'When working with subclasses of `Number`, we have a fairly extensive volume
    of design considerations as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`Number`的子类时，我们有以下一系列设计考虑：
- en: Equality testing and hash value calculation. The core features of hash calculation
    for numbers is documented in the *9.1.2 Notes for type implementors* section of
    the *Python Standard Library*.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相等性测试和哈希值计算。关于数字的哈希计算的核心特性在*Python标准库*的*9.1.2类型实现者注意事项*部分有详细说明。
- en: The other comparison operators (often defined via `@total_ordering` decorator).
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他比较操作符（通常通过`@total_ordering`装饰器定义）。
- en: 'The arithmetic operators: `+`, `-`, `*`, `/`, `//`, `%`, and `**`. There are
    special methods for the forward operations as well as additional methods for reverse
    type-matching. Given an expression like `a-b`, Python uses the type of a to attempt
    to locate an implementation of the `__sub__()` method function: effectively, the
    `a.__sub__(b)` method. If the class of the left-hand value, `a` in this case,
    doesn''t have the method or returns the `NotImplemented` exception, then the right-hand
    value is examined to see if the `b.__rsub__(a)` method provides a result. There''s
    an additional special case that applies when `b`''s class is a subclass of `a`''s
    class: this allows the subclass to override the left-hand side operation choice.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术操作符：`+`，`-`，`*`，`/`，`//`，`%`和`**`。前向操作有特殊方法，还有额外的方法用于反向类型匹配。例如，对于表达式`a-b`，Python使用`a`的类型来尝试找到`__sub__()`方法函数的实现：实际上是`a.__sub__(b)`方法。如果左侧值的类，在这种情况下是`a`，没有该方法或返回`NotImplemented`异常，那么将检查右侧值，看看`b.__rsub__(a)`方法是否提供结果。还有一个特殊情况，当`b`的类是`a`的类的子类时，这允许子类覆盖左侧操作选择。
- en: 'The bit-fiddling operators: `&`, `|`, **^**, `>>`, `<<`, and `~`. These might
    not make sense for floating-point values; omitting these special methods might
    be the best design.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位操作符：`&`，`|`，**^**，`>>`，`<<`和`~`。这些可能对浮点值没有意义；省略这些特殊方法可能是最好的设计。
- en: Some additional functions like `round()`, `pow(),` and `divmod()` are implemented
    by numeric special method names. These might be meaningful for this class of numbers.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些额外的函数，如`round()`，`pow()`和`divmod()`，是通过数字特殊方法名称实现的。这些可能对这类数字有意义。
- en: '[Chapter 7](ch07.html "Chapter 7. Additional Tuple Techniques"), *Mastering
    Object-Oriented Python* provides a detailed example of creating a new type of
    number. Visit the link for more details:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[第7章](ch07.html "第7章。附加元组技术")，《精通面向对象的Python》提供了创建新类型数字的详细示例。访问链接以获取更多详细信息：'
- en: '[https://www.packtpub.com/application-development/mastering-object-oriented-python](https://www.packtpub.com/application-development/mastering-object-oriented-python).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/mastering-object-oriented-python](https://www.packtpub.com/application-development/mastering-object-oriented-python)。'
- en: As we noted previously, functional programming and object-oriented programming
    can be complementary. We can easily define classes that follow functional programming
    design patterns. Adding new kinds of numbers is one example of leveraging Python's
    object-oriented features to create more readable functional programs.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所指出的，函数式编程和面向对象编程可以是互补的。我们可以轻松地定义遵循函数式编程设计模式的类。添加新类型的数字是利用Python的面向对象特性创建更易读的函数式程序的一个例子。
- en: Applying partial arguments with partial()
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用partial（）应用部分参数
- en: The `partial()` function leads to something called partial application. A partially
    applied function is a new function built from an old function and a subset of
    the required arguments. It is closely related to the concept of currying. Much
    of the theoretical background is not relevant here, since currying doesn't apply
    to the way Python functions are implemented. The concept, however, can lead us
    to some handy simplifications.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`partial（）`函数导致了部分应用的东西。部分应用的函数是从旧函数和一部分所需参数构建的新函数。它与柯里化的概念密切相关。由于柯里化不适用于Python函数的实现方式，因此大部分理论背景在这里并不相关。然而，这个概念可以带给我们一些方便的简化。'
- en: 'We can look at trivial examples as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看以下的简单例子：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We've created a function, `exp2(y)`, which is the `pow(2,y)` function. The `partial()`
    function bounds the first positional parameter to the `pow()` function. When we
    evaluate the newly created `exp2()` function, we get values computed from the
    argument bound by the `partial()` function, plus the additional argument provided
    to the `exp2()` function.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`exp2（y）`的函数，它是`pow（2，y）`函数。`partial（）`函数将第一个位置参数限制在`pow（）`函数中。当我们评估新创建的`exp2（）`函数时，我们得到从`partial（）`函数绑定的参数计算出的值，以及提供给`exp2（）`函数的额外参数。
- en: The bindings of positional parameters are handed in a strict left-to-right order.
    For functions that accept keyword parameters, these can also be provided when
    building the partially applied function.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 位置参数的绑定以严格的从左到右的顺序进行。对于接受关键字参数的函数，在构建部分应用的函数时也可以提供这些参数。
- en: 'We can also create this kind of partially applied function with a lambda form
    as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用lambda形式创建这种部分应用的函数，如下所示：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Neither is clearly superior. Measuring performance shows that the `partial()`
    function is a hair faster than a lambda form in the following manner:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都没有明显的优势。性能测试表明，`partial（）`函数比lambda形式稍快，具体如下：
- en: partial 0.37
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0.37部分
- en: lambda 0.42
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: lambda 0.42
- en: 'This is 0.05 seconds over 1,000,000 iterations: not a remarkable savings.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在100万次迭代中超过0.05秒：并没有显著的节省。
- en: Since lambda forms have all of the capabilities of the `partial()` function,
    it seems that we can safely set this function aside as not being profoundly useful.
    We'll return to it in [Chapter 14](ch14.html "Chapter 14. The PyMonad Library"),
    *The PyMonad Library*, and look at how we can accomplish this with currying also.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于lambda形式具有`partial（）`函数的所有功能，因此我们可以安全地将此函数设置为不是非常有用。我们将在[第14章](ch14.html "第14章。PyMonad库")*PyMonad库*中返回它，并看看我们如何使用柯里化来实现这一点。
- en: Reducing sets of data with reduce()
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`reduce（）`函数减少数据集
- en: The `sum()`, `len()`, `max()`, and `min()` functions are—in a way— all specializations
    of a more general algorithm expressed by the `reduce()` function. The `reduce()`
    function is a higher-order function that folds a function into each pair of items
    in an iterable.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum（）`，`len（）`，`max（）`和`min（）`函数在某种程度上都是`reduce（）`函数表达的更一般算法的特殊化。`reduce（）`函数是一个高阶函数，它将一个函数折叠到可迭代对象中的每一对项目中。'
- en: 'A sequence object is given as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个序列对象如下：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The function, `reduce(lambda x,y: x+y, d)`, will fold in `+` operators to the
    list as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`reduce（lambda x，y：x+y，d）`将`+`运算符折叠到列表中如下：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Including `()` can show the effective grouping as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 包括`（）`可以显示有效的分组如下：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Python's standard interpretation of expressions involves a left-to-right evaluation
    of operators. The fold left isn't a big change in meaning.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Python对表达式的标准解释涉及对运算符的从左到右的评估。左折叠并没有太大的意义变化。
- en: 'We can also provide an initial value as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以提供一个初始值如下：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we don''t, the initial value from the sequence is used as the initialization.
    Providing an initial value is essential when there''s a `map()` function as well
    as a `reduce()` function. Following is how the right answer is computed with an
    explicit 0 initializer:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不这样做，序列的初始值将被用作初始化。当有`map（）`函数和`reduce（）`函数时，提供初始值是必不可少的。以下是如何使用显式0初始化器计算正确答案的：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we omit the initialization of 0, and the `reduce()` function uses the first
    item as an initial value, we get the following wrong answer:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们省略0的初始化，并且`reduce（）`函数使用第一个项目作为初始值，我们会得到以下错误答案：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can define a number of built-in reductions using the `reduce()` higher-order
    function as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`reduce（）`高阶函数定义一些内置的缩减如下：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `sum2()` reduction function is the sum of squares, useful for computing
    standard deviation of a set of samples. This `sum()` reduction function mimics
    the built-in `sum()` function. The `count()` reduction function is similar to
    the `len()` function, but it can work on an iterable, where the `len()` function
    can only work on a materialized `collection` object.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum2（）`缩减函数是平方和，用于计算一组样本的标准偏差。这个`sum（）`缩减函数模仿了内置的`sum（）`函数。`count（）`缩减函数类似于`len（）`函数，但它可以在可迭代对象上工作，而`len（）`函数只能在实例化的`collection`对象上工作。'
- en: The `min()` and `max()` functions mimic the built-in reductions. Because the
    first item of the iterable is used for initialization, these two functions will
    work properly. If we provided any initial value to these `reduce()` functions,
    we might incorrectly use a value that never occurred in the original iterable.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`min（）`和`max（）`函数模仿了内置的缩减。因为可迭代对象的第一个项目被用于初始化，所以这两个函数将正常工作。如果我们为这些`reduce（）`函数提供任何初始值，我们可能会错误地使用原始可迭代对象中从未出现的值。'
- en: Combining map() and reduce()
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结合map（）和reduce（）
- en: 'We can see how to build higher-order functions around these simple definitions.
    We''ll show a simplistic map-reduce function that combines the `map()` and `reduce()`
    functions as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到如何围绕这些简单定义构建高阶函数。我们将展示一个简单的map-reduce函数，它结合了`map()`和`reduce()`函数，如下所示：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We''ve created a composite function from the `map()` and `reduce()` functions
    that take three arguments: the mapping, the reduction operation, and the iterable
    or sequence to process.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`map()`和`reduce()`函数中创建了一个复合函数，它接受三个参数：映射、缩减操作和要处理的可迭代对象或序列。
- en: 'We can build a sum-squared reduction using the `map()` and `reduce()` functions
    separately as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以分别使用`map()`和`reduce()`函数构建一个平方和缩减，如下所示：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this case, we''ve used the `lambda y: y**2` parameter as a mapping to square
    each value. The reduction is simply `lambda x,y: x+y` parameter. We don''t need
    to explicitly provide an initial value because the initial value will be the first
    item in the iterable after the `map()` function has squared it.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种情况下，我们使用了`lambda y: y**2`参数作为映射来对每个值进行平方。缩减只是`lambda x,y: x+y`参数。我们不需要明确提供初始值，因为初始值将是`map()`函数对其进行平方后的可迭代对象中的第一项。'
- en: 'The `lambda x,y: x+y` parameter is merely the `+` operator. Python offers all
    of the arithmetic operators as short functions in the `operator` module. Following
    is how we can slightly simplify our map-reduce operation:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambda x,y: x+y`参数只是`+`运算符。Python在`operator`模块中提供了所有算术运算符作为简短的函数。以下是我们如何稍微简化我们的map-reduce操作：'
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We've used the `operator.add` method to sum our values instead of the longer
    lambda form.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`operator.add`方法来对值进行求和，而不是更长的lambda形式。
- en: 'Following is how we can count values in an iterable:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们如何在可迭代对象中计算值的数量：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We''ve used the `lambda y: 1` parameter to map each value to a simple 1\. The
    count is then a `reduce()` function using the `operator.add` method.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '我们使用`lambda y: 1`参数将每个值映射为简单的1。然后计数是使用`operator.add`方法进行`reduce()`函数。'
- en: The general-purpose `reduce()` function allows us to create any species of reduction
    from a large dataset to a single value. There are some limitations, however, on
    what we should do with the `reduce()` function.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通用的`reduce()`函数允许我们从大型数据集创建任何种类的缩减到单个值。然而，对于我们应该如何使用`reduce()`函数存在一些限制。
- en: 'We should avoid executing commands such as the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该避免执行以下命令：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Yes, it works. However, the `"".join(["1", ",", "2", ",", "3"])` method is considerably
    more efficient. We measured 0.23 seconds per million to do the `"".join()` function
    versus 0.69 seconds to do the `reduce()` function.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，它有效。然而，`"".join(["1", ",", "2", ",", "3"])`方法要高效得多。我们测得每百万次执行`"".join()`函数需要0.23秒，而执行`reduce()`函数需要0.69秒。
- en: Using reduce() and partial()
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`reduce()`和`partial()`
- en: Note
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `sum()` function can be seen as the `partial(reduce, operator.add)` method.
    This, too, gives us a hint as to how we can create other mappings and other reductions.
    We can, indeed, define all of the commonly used reductions as partials instead
    of lambdas.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum()`函数可以看作是`partial(reduce, operator.add)`方法。这也给了我们一个提示，即我们可以创建其他映射和其他缩减。实际上，我们可以将所有常用的缩减定义为partial而不是lambda。'
- en: 'Following are two examples:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是两个例子：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We can now use these functions via the `sum2(some_data)` or the `count(some_iter)`
    method. As we noted previously, it's not clear how much benefit this has. It's
    possible that a particularly complex calculation can be explained simply with
    functions like this.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过`sum2(some_data)`或`count(some_iter)`方法使用这些函数。正如我们之前提到的，目前还不清楚这有多大的好处。可能可以用这样的函数简单地解释特别复杂的计算。
- en: Using map() and reduce() to sanitize raw data
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`map()`和`reduce()`来清理原始数据
- en: When doing data cleansing, we'll often introduce filters of various degrees
    of complexity to exclude invalid values. We may also include a mapping to sanitize
    values in the cases where a valid but improperly formatted value can be replaced
    with a valid but proper value.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行数据清理时，我们经常会引入各种复杂程度的过滤器来排除无效值。在某些情况下，我们还可以包括一个映射，以清理值，即在有效但格式不正确的值可以被替换为有效且正确的值的情况下。
- en: 'We might produce the following output:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会产生以下输出：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We've defined a simple mapping, the `comma_fix()` class, that will convert data
    from a nearly correct format into a usable floating-point value.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个简单的映射，即`comma_fix()`类，它将数据从几乎正确的格式转换为可用的浮点值。
- en: We've also defined a map-reduce that applies a given cleaner function, the `comma_fix()`
    class, in this case, to the data before doing a `reduce()` function using the
    `operator.add` method.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一个map-reduce，它将给定的清理函数（在本例中是`comma_fix()`类）应用于数据，然后使用`operator.add`方法进行`reduce()`函数。
- en: 'We can apply the previously described function as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式应用先前描述的函数：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We've cleaned the data, by fixing the commas, as well as computed a sum. The
    syntax is very convenient for combining these two operations.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经清理了数据，修复了逗号，并计算了总和。这种语法非常方便，可以将这两个操作结合起来。
- en: 'We have to be careful, however, of using the cleaning function more than once.
    If we''re also going to compute a sum of squares, we really should not execute
    the following command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们必须小心，不要多次使用清理函数。如果我们还要计算平方和，我们真的不应该执行以下命令：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we use the `clean_sum(comma_fix_squared, d)` method as part of computing
    a standard deviation, we''ll do the comma-fixing operation twice on the data:
    once to compute the sum and once to compute the sum of squares. This is a poor
    design; caching the results with an `lru_cache` decorator can help. Materializing
    the sanitized intermediate values as a temporary `tuple` object is probably better.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`clean_sum(comma_fix_squared, d)`方法作为计算标准差的一部分使用，我们将对数据进行两次逗号修复操作：一次用于计算总和，一次用于计算平方和。这是一个糟糕的设计；使用`lru_cache`装饰器可以帮助缓存结果。将经过清理的中间值实现为临时的`tuple`对象可能更好。
- en: Using groupby() and reduce()
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`groupby()`和`reduce()`
- en: A common requirement is to summarize data after partitioning it into groups.
    We can use a `defaultdict(list)` method to partition data. We can then analyze
    each partition separately. In [Chapter 4](ch04.html "Chapter 4. Working with Collections"),
    *Working with Collections*, we looked at some ways to group and partition. In
    [Chapter 8](ch08.html "Chapter 8. The Itertools Module"), *The Itertools Module*,
    we looked at others.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的要求是在将数据分成组后对数据进行汇总。我们可以使用`defaultdict(list)`方法来分区数据。然后我们可以分别分析每个分区。在[第4章](ch04.html
    "第4章。处理集合")*处理集合*中，我们看了一些分组和分区的方法。在[第8章](ch08.html "第8章。Itertools模块")*Itertools模块*中，我们看了其他方法。
- en: 'Following is some sample data that we need to analyze:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们需要分析的一些示例数据：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We've got a sequence of raw data values with a key and a measurement for each
    key.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一系列原始数据值，每个键和每个键的测量值。
- en: 'One way to produce usable groups from this data is to build a dictionary that
    maps a key to a list of members in this group as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些数据中产生可用的组的一种方法是构建一个将键映射到该组中成员列表的字典，如下所示：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will separate each item in the iterable into individual groups. The `key()`
    function is used to extract a key value from each item. This key is used to append
    each item to a list in the `pd` dictionary. The resulting value of this function
    matches the results of the `itertools.groupby()` function: it''s an iterable sequence
    of the `(group key, iterator)` pairs.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把可迭代对象中的每个项目分成单独的组。`key()`函数用于从每个项目中提取一个键值。这个键用于将每个项目附加到`pd`字典中的列表中。这个函数的结果值与`itertools.groupby()`函数的结果相匹配：它是一个可迭代的`(group
    key, iterator)`对序列。
- en: 'Following is the same feature done with the `itertools.groupby()` function:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`itertools.groupby()`函数完成的相同特性：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can summarize the grouped data as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按如下方式总结分组数据：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The results of the `partition()` functions will be a sequence of `(key, iterator)`
    two tuples. We'll separate the key from the item iterator. Each item in the item
    iterator is one of the original objects in the source data; these are `(key, value)`
    pairs; we only want the values, and so we've used a simple generator expression
    to separate the source keys from the values.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`partition()`函数的结果将是一个`(key, iterator)`两个元组的序列。我们将键与项目迭代器分开。项目迭代器中的每个项目都是源数据中的原始对象之一；这些是`(key,
    value)`对；我们只需要值，因此我们使用了一个简单的生成器表达式来将源键与值分开。'
- en: 'We can also execute the following command to pick the second item from each
    of the two tuples:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以执行以下命令，从两个元组中选择第二个项目：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This requires the `snd= lambda x: x[1]` method.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '这需要`snd= lambda x: x[1]`方法。'
- en: 'We can use the following command to apply the `summarize()` function to each
    partition:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令将`summarize()`函数应用于每个分区：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The alternative commands are as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 替代命令如下：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Both will provide us summary values for each group. The resulting group statistics
    look as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都将为我们提供每个组的汇总值。生成的组统计如下：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The variance can be used as part of a ![Using groupby() and reduce()](graphics/B03652_10_07.jpg)
    test to determine if the null hypothesis holds for this data. The null hypothesis
    asserts that there's nothing to see; the variance in the data is essentially random.
    We can also compare the data between the four groups to see if the various means
    are consistent with the null hypothesis or there is some statistically significant
    variation.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 方差可以作为![使用groupby()和reduce()](graphics/B03652_10_07.jpg)的一部分来测试数据的零假设是否成立。零假设断言没有什么可看的；数据中的方差基本上是随机的。我们还可以比较四个组之间的数据，看各种平均值是否与零假设一致，或者是否存在一些统计学上显著的变化。
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've looked at a number of functions in the `functools` module.
    This library module provides a number of functions that help us create sophisticated
    functions and classes.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了`functools`模块中的许多函数。这个库模块提供了许多函数，帮助我们创建复杂的函数和类。
- en: We've looked at the `@lru_cache` function as a way to boost certain types of
    applications with frequent re-calculations of the same values. This decorator
    is of tremendous value for certain kinds of functions that take the `integer`
    or the `string` argument values. It can reduce processing by simply implementing
    memoization.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将`@lru_cache`函数视为一种提高某些类型的应用程序的方法，这些应用程序需要频繁重新计算相同值。这个装饰器对于那些接受`integer`或`string`参数值的某些类型的函数来说是非常有价值的。它可以通过简单地实现记忆化来减少处理。
- en: We looked at the `@total_` `ordering` function as a decorator to help us build
    objects that support rich ordering comparisons. This is at the fringe of functional
    programming, but is very helpful when creating new kinds of numbers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`@total_` `ordering`函数视为装饰器，以帮助我们构建支持丰富排序比较的对象。这在函数式编程的边缘，但在创建新类型的数字时非常有帮助。
- en: The `partial()` function creates a new function with the partial application
    of argument values. As an alternative, we can build a `lambda` with similar features.
    The use case for this is ambiguous.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`partial()`函数创建一个新函数，其中包含参数值的部分应用。作为替代，我们可以构建一个具有类似特性的`lambda`。这种用例是模棱两可的。'
- en: We also looked at the `reduce()` function as a higher-order function. This generalizes
    reductions like the `sum()` function. We'll use this function in several examples
    in the later chapters. This fits logically with the `filter()` and `map()` functions
    as an important higher-order function.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了`reduce()`函数作为高阶函数。这概括了像`sum()`函数这样的缩减。我们将在后面的章节中的几个示例中使用这个函数。这与`filter()`和`map()`函数在逻辑上是一致的，是一个重要的高阶函数。
- en: In the next chapters, we'll look at how we can build higher-order functions
    using decorators. These higher-order functions can lead to slightly simpler and
    clearer syntax. We can use decorators to define an isolated aspect that we need
    to incorporate into a number of other functions or classes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看看如何使用装饰器构建高阶函数。这些高阶函数可以导致稍微更简单和更清晰的语法。我们可以使用装饰器来定义我们需要合并到许多其他函数或类中的孤立方面。
