- en: Chapter 9. Integration Testing and System Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。集成测试和系统测试
- en: '*With all of the tools, techniques, and practices that we''ve discussed so
    far, we''ve still only been been thinking about testing units: the smallest meaningfully
    testable pieces of code. It''s time to expand the focus and start testing code
    that incorporates multiple units.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*到目前为止，我们已经讨论了所有的工具、技术和实践，但我们仍然只是在思考测试单元：代码中最小且具有实际测试意义的部分。现在是时候扩大关注范围，开始测试包含多个单元的代码了。*'
- en: 'In this chapter, we shall:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Describe integration testing and system testing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述集成测试和系统测试
- en: Learn how to break up a program into testable multi-unit sections
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何将程序分解成可测试的多单元部分
- en: Use doctest, unittest, and Nose to automate multi-unit tests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用doctest、unittest和Nose来自动化多单元测试
- en: So let's get on with it!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧！
- en: Integration tests and system tests
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试和系统测试
- en: Integration testing is the process of checking that the units making up your
    program work correctly in concert with each other, rather than in isolation. It's
    not practical to start the process with integration testing, because if the units
    don't work, the integration won't work either, and it will be harder to track
    down the cause of your problems. Once your units are solid though, it's necessary
    to test that the things you build out of them also work. The interactions between
    units can be surprising.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试是检查构成您程序的单元是否能够与其他单元正确协作工作，而不是单独工作。在集成测试开始之前启动这个过程并不实际，因为如果单元不工作，集成也不会工作，而且追踪问题的原因会更困难。然而，一旦单元稳固，测试您从中构建的东西是否也工作就是必要的。单元之间的交互可能会令人惊讶。
- en: While you perform integration testing, you'll be putting the units together
    into bigger and bigger collections and testing those collections. When your integration
    tests expand to cover the entirety of your program, they have become system tests.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当您执行集成测试时，您将把单元组合成更大和更大的集合，并测试这些集合。当您的集成测试扩展到覆盖整个程序时，它们就变成了系统测试。
- en: The trickiest part of integration testing is choosing which units to integrate
    into each test, so that you always have a solid base of code that you can believe
    in; a place to stand, while you pull in more code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试中最棘手的部分是选择将哪些单元集成到每个测试中，以便您始终有一个可以信赖的稳固代码基础；一个可以立足的地方，在您引入更多代码的同时。
- en: Time for action – figuring out the order of integration
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 确定集成顺序
- en: We'll walk through an exercise that can help with the process of deciding where
    to put the boundaries of integration tests.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一个练习来帮助确定集成测试边界的放置过程。
- en: Using a piece of paper or a graphics program, write out names or representations
    for each of the units in the time planner project from Chapter 7\. Group the methods
    of each class together. Being part of the same class is an obvious relationship
    between units, and we'll take advantage of that. (The `==` symbol here represents
    the Python `==` operator, which invokes the `__eq__` method on an object).![Time
    for action – figuring out the order of integration](img/8846_09_01.jpg)
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一张纸或图形程序，为第7章中的时间规划项目中的每个单元写出名称或表示。将每个类的方法定组。同一类中的单元之间存在明显的关联，我们将利用这一点。（这里的`==`符号代表Python的`==`运算符，它在对象上调用`__eq__`方法）。![行动时间
    - 确定集成顺序](img/8846_09_01.jpg)
- en: Now, draw arrows between units that are supposed to directly interact with each
    other, from the caller to the callee. Laying everything out in an orderly fashion
    (like in step 1) can actually make this harder, so feel free to move the classes
    around to help the lines make sense.![Time for action – figuring out the order
    of integration](img/8846_09_02.jpg)
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在应该直接相互交互的单元之间画箭头，从调用者到被调用者。将所有内容有序地排列（就像步骤1中那样）实际上可能会使这个过程变得更难，所以请随意移动类以帮助线条有意义。![行动时间
    - 确定集成顺序](img/8846_09_02.jpg)
- en: Draw circles around each class and each pair of classes that is connected by
    at least one line.![Time for action – figuring out the order of integration](img/8846_09_03.jpg)
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个类和至少通过一条线连接的每一对类周围画圆圈。![行动时间 - 确定集成顺序](img/8846_09_03.jpg)
- en: Continue the process by drawing circles around overlapping pairs of circles,
    until there are only three circles left. Circle a pair of them and then put one
    more big circle around the whole mess.![Time for action – figuring out the order
    of integration](img/8846_09_04.jpg)
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在重叠的圆圈对周围画圆，继续这个过程，直到只剩下三个圆圈。画出一对圆圈，然后在整个混乱中再画一个更大的圆圈。![行动时间 – 确定积分顺序](img/8846_09_04.jpg)
- en: These circles tell us which order to write our integration tests in. The smaller
    the circle, the sooner the test should be written.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些圆圈告诉我们应该按什么顺序编写我们的集成测试。圆圈越小，测试应该越早编写。
- en: '*What just happened?*'
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: What we just did is a way to visualize and concretize the process of building
    up integration tests. While it's not critical to actually draw the lines and circles,
    it's useful to follow the process in your head. For larger projects, a lot can
    be gained from actually drawing the diagrams. When you can see the diagram, the
    correct next step tends to jump right out at you—especially if you use multiple
    colors to render the diagram—where it might otherwise be hidden behind the complexity
    of the program.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才做的是一种可视化和具体化构建集成测试过程的方法。虽然实际上画线和圆圈不是必要的，但在脑海中跟随这个过程是有用的。对于较大的项目，实际绘制图表可以获得很多好处。当你看到图表时，正确的下一步通常会立即显现出来——特别是如果你使用多种颜色来渲染图表——否则它可能隐藏在程序的复杂性背后。
- en: Pop quiz – diagramming integration
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速问答 - 绘制集成图
- en: What's the point of grouping units together into classes during the early part
    of this process?
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个过程的早期阶段，将单元组合成类有什么意义？
- en: When we move classes around to help the arrows make sense, what effect does
    that have on the later process?
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们移动类以帮助箭头有意义时，这对后续过程有什么影响？
- en: Why do we always focus on grouping together pairs when we do this?
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们总是在做这个的时候总是将单元组合在一起？
- en: Have a go hero – diagram your own program
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试自己绘制程序图
- en: Take one of your own programs and build an integration diagram for it. If your
    program is large enough that the diagram begins to get clumsy, try putting different
    'levels' of the diagram on separate pages.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 拿你自己的程序之一，并为它绘制一个集成图。如果你的程序足够大，以至于图表开始变得笨拙，尝试将图表的不同“级别”放在单独的页面上。
- en: Automation with doctest, unittest, and Nose
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用doctest、unittest和Nose进行自动化
- en: The only real difference between an integration test and a unit test, is that
    you could break the code being tested into smaller meaningful chunks, in an integration
    test. In a unit test, if you divided the code up any more it wouldn't be meaningful.
    For this reason, the same tools that help automate unit testing can be applied
    to integration testing. Since system testing is really the highest level of integration
    testing, the tools can be used for that as well.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试和单元测试之间唯一的真正区别在于，在集成测试中，你可以将正在测试的代码分解成更小的、有意义的块。在单元测试中，如果你再细分代码，它就不再有意义了。因此，帮助自动化单元测试的工具也可以应用于集成测试。由于系统测试实际上是集成测试的最高级别，因此这些工具也可以用于此。
- en: The role of doctest in integration testing tends to be fairly limited. The real
    strengths of doctest are in the early part of the development process. It's easy
    for a testable specification to stray into integration testing—as mentioned before,
    that's fine as long as there are unit tests as well—but after that it's likely
    that you'll prefer unittest and Nose for writing your integration tests.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: doctest在集成测试中的作用通常相当有限。doctest的真正优势在于开发过程的早期阶段。一个可测试的规范很容易进入集成测试——如前所述，只要有单元测试，那就没问题——但之后你可能会更喜欢unittest和Nose来编写你的集成测试。
- en: Integration tests need to be isolated from each other. Even though they contain
    multiple interacting units within themselves, you still benefit from knowing that
    nothing outside the test is affecting it. For this reason, unittest is a good
    choice for writing automated integration tests. Working together with unittest,
    Nose and Mocker complete the picture nicely.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试需要彼此隔离。尽管它们在自身内部包含多个相互作用的单元，但你仍然受益于知道测试之外没有东西在影响它。因此，unittest是编写自动化集成测试的好选择。与unittest、Nose和Mocker一起工作，可以很好地完成这个画面。
- en: Time for action – writing integration tests for the time planner
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 为时间规划器编写集成测试
- en: Now that we've got an integration diagram for the time planner code, we can
    move ahead with actually writing automated integration tests.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为时间规划器代码绘制了集成图，我们可以继续编写实际的自动化集成测试。
- en: 'The integration diagram provides only a partial ordering of the integration
    tests, and there are several tests that could be the first one we write. Looking
    at the diagram, we see that the `statuses` and `activities` classes are at the
    ends of a lot of arrows, but not at the beginnings of any. This makes them particularly
    good places to start, because it means that they don''t call on anything outside
    of themselves to operate. Since there''s nothing to distinguish one of them as
    a better place to start than the other, we can choose between them arbitrarily.
    Let''s start with `statuses`, and then do `activities`. We''re going to write
    tests that exercise the whole class. At this low level, the integration tests
    will look a lot like the unit tests for the same class, but we''re not going to
    use mock objects to represent other instances of the same class: we''ll use real
    instances. We''re testing whether the class correctly interacts with itself.'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整合图仅提供了集成测试的部分排序，并且有几个测试可能是我们首先编写的。查看图表，我们看到`statuses`和`activities`类位于许多箭头的末端，但不在任何箭头的起始处。这使得它们成为特别好的起点，因为这意味着它们不需要调用自身之外的东西来操作。由于没有东西能区分它们中哪一个比另一个更适合作为起点，我们可以任意选择它们。让我们从`statuses`开始，然后进行`activities`。我们将编写测试来测试整个类。在这个低级别上，集成测试将非常类似于同一类的单元测试，但我们不会使用模拟对象来表示同一类的其他实例：我们将使用真实实例。我们正在测试类是否能够正确地与自身交互。
- en: 'Here is the test code for `statuses`:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面是`statuses`的测试代码：
- en: '[PRE0]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is the test code for `activities`:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面是`activities`的测试代码：
- en: '[PRE1]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Looking at our diagram, we can see that the next level out from either `statuses`
    or `activities` represents the integration of those classes with the `schedules`
    class. Before we write that integration, we ought to write any tests that involve
    the schedules class interacting with itself, without mocking it.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看我们的图表，我们可以看到从`statuses`或`activities`延伸出的下一级代表了这些类与`schedules`类的集成。在我们编写集成之前，我们应该编写任何涉及`schedules`类与自身交互的测试，而不使用模拟。
- en: '[PRE2]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that interactions within the `schedules` class have been tested, we can
    write tests that integrate `schedules` and one of `statuses` or `activities`.
    Let''s start with `statuses`, then do `activities`. Here are the tests for `schedules`
    and `statuses`:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，`schedules`类内部的交互已经测试过了，我们可以编写将`schedules`与`statuses`或`activities`之一集成的测试。让我们从`statuses`开始，然后进行`activities`。以下是`schedules`和`statuses`的测试：
- en: '[PRE3]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here are the tests for `schedules` and `activities`:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面是`schedules`和`activities`的测试：
- en: '[PRE4]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It's time to pull `schedules`, `statuses`, and `activities` all together into
    the same tests.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候将`schedules`、`statuses`和`activities`全部整合到同一测试中。
- en: '[PRE5]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The next thing that we need to pull in is the `file` class, but before we integrate
    it with the rest of the system, we need to integrate it with itself; checking
    its internal interactions without using mock objects.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步需要整合的是`file`类，但在将其与其他系统整合之前，我们需要将其与自身整合；不使用模拟对象检查其内部交互。
- en: '[PRE6]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now we can write tests that integrate `schedules` and `file`. Notice that for
    this step, we still aren't involving `statuses` or `activities`, because they're
    outside the oval.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以编写将`schedules`和`file`集成的测试。注意，对于这一步，我们仍然没有涉及`statuses`或`activities`，因为它们在椭圆形之外。
- en: '[PRE7]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We've built our way up to the outermost circle now, which means that it's time
    to write tests that involve the whole system, with no mock objects anywhere.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在已经构建到了最外层圆圈，这意味着现在是时候编写涉及整个系统的测试，没有任何模拟对象。
- en: '[PRE8]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*What just happened?*'
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We've just tested our whole code base, always being careful to test one thing
    at a time. Because we took care to go step-by-step, we always knew where newly
    discovered bugs originated, and we were able to fix them easily.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚测试了整个代码库，始终注意一次测试一件事。因为我们采取了逐步进行的做法，所以我们总是知道新发现的错误起源于何处，并且我们能够轻松地修复它们。
- en: Let's take a moment to examine each section of the code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间检查代码的每个部分。
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We're creating a status object here in our `setUp` method. Because it's a `setUp`
    method—part of the test fixture—each test will have its own unique version of
    `self.A`, and changes made in one test won't be visible to any other test.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`setUp`方法中，我们在这里创建了一个状态对象。因为这是一个`setUp`方法——测试固定的一部分——每个测试都将有自己的唯一版本`self.A`，一个测试中做出的更改对其他任何测试都是不可见的。
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `test_equality` test checks that a status compares equal to itself, and
    that differences in name, start time or end time cause statuses to compare as
    unequal.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_equality`测试检查一个状态是否与自己比较相等，以及名称、开始时间或结束时间的差异会导致状态比较为不相等。'
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This series of tests checks that statuses correctly recognize when they overlap,
    whether that overlap happens at the beginning, at the end, or because one status
    is within the other.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这一系列测试检查状态是否能够正确识别它们何时重叠，无论这种重叠发生在开始、结束，还是因为一个状态包含在另一个状态中。
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As with statuses, activities are tested by creating a sample object in the `setUp`
    method, and performing operations on it in the tests. Equality checking is the
    same as in statuses; we want to make sure that a different name, begin time, or
    end time means that the two activities are not equal.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 与状态一样，活动是通过在`setUp`方法中创建一个样本对象并在测试中对其执行操作来测试的。相等性检查与状态中的相同；我们希望确保不同的名称、开始时间或结束时间意味着两个活动不相等。
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This series of tests makes sure that activities correctly recognize when they
    overlap with each other, whether that overlapping happens at the beginning, the
    end, or in the middle.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这一系列测试确保活动能够正确识别它们之间何时重叠，无论这种重叠发生在开始、结束还是中间。
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We'll test how `schedules` interacts with itself, but not yet how it interacts
    with `activities` and `statuses`. As such, we need some mock objects to represent
    those things. Here in the test fixture, we create three mock objects for just
    that purpose.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将测试`schedules`如何与自身交互，但尚未测试它与`activities`和`statuses`的交互。因此，我们需要一些模拟对象来代表这些事物。在这里的测试固定装置中，我们创建了三个模拟对象，正是为了这个目的。
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The only interaction that `schedules` has with itself is equality comparison,
    so here we've tested that the comparison between two real schedules works the
    way it's supposed to.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`schedules`与自身唯一的交互是相等性比较，因此在这里我们已经测试了两个实际计划之间的比较是否按预期工作。'
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Where before we used mock objects to represent the statuses, now we can use
    the real thing. Since we're testing the interaction between `schedules` and `statuses`,
    we need to use the real thing.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前我们使用模拟对象来表示状态的情况下，现在我们可以使用真实的事物。由于我们正在测试` schedules`和` statuses`之间的交互，我们需要使用真实的事物。
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This test runs through the whole expected usage pattern between `schedules`
    and `statuses`, all in one test. This sort of thing isn't a good idea when we
    perform unit testing, because it naturally involves more than one unit. We're
    doing integration testing now, though, and all of the involved units have already
    been tested in isolation. We actually want to have them interact with each other
    to make sure it works, and this is a good way to achieve that.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试在一个测试中运行了` schedules`和` statuses`之间整个预期的使用模式。当我们进行单元测试时，这种做法并不好，因为它自然涉及到多个单元。然而，我们现在正在进行集成测试，所有涉及的单元都已经单独进行了测试。我们实际上希望它们相互交互以确保它们可以正常工作，这是实现这一目标的好方法。
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: These tests are a lot like the tests for `schedules` and `statuses` together.
    The differences are due to the fact that activities can exclude each other from
    participating in a schedule, so when we try to add an overlapping activity to
    the schedule, it should raise an exception, and then should not be added to the
    schedule.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试与` schedules`和` statuses`一起的测试非常相似。差异是由于活动可以排除彼此参与计划，因此当我们尝试将重叠的活动添加到计划中时，应该抛出一个异常，然后不应将其添加到计划中。
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We're not using any mocks at all here. These tests use `schedules`, `activities`,
    and `statuses` without any limits on their interactions. Our test fixture just
    creates a bunch of them, so we don't have to duplicate that code in each of the
    tests.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里根本不使用任何模拟。这些测试使用` schedules`、` activities`和` statuses`，没有任何限制它们的交互。我们的测试固定装置只是创建了一堆它们，所以我们不需要在每个测试中重复这段代码。
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here again, we have a single test for a complete usage pattern. We're intentionally
    not limiting the interactions between the tested components; instead we're putting
    them together and making sure that they work.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次有一个针对完整使用模式的单个测试。我们故意不对测试组件之间的交互进行限制；相反，我们将它们组合在一起并确保它们可以正常工作。
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Our test fixture creates a persistence database, containing several objects
    before each test runs, and deletes that database after each test. As usual, that
    means we know what the environment looks like for each test, and they don't interact
    with each other.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试固定装置在每次测试运行之前创建一个持久化数据库，包含几个对象，并在每次测试之后删除该数据库。通常情况下，这意味着我们知道每个测试的环境看起来是什么样子，它们不会相互影响。
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this test, we create a new persistence file object, and tell it to load data
    from the database created in the `setUp` method. Then we make sure that the loaded
    data match our expectations.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们创建一个新的持久化文件对象，并告诉它从`setUp`方法中创建的数据库加载数据。然后我们确保加载的数据符合我们的预期。
- en: When we run this test, it turns up an error which was not previously visible.
    The changes to the database aren't being committed to the file, and so they aren't
    visible outside of the transaction where they were stored. Not testing the persistence
    code in separate transactions was an oversight, but that's exactly the sort of
    mistake that we perform integration testing to catch.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个测试时，出现了一个之前没有出现的错误。数据库的更改没有被提交到文件中，因此它们在存储它们的交易之外是不可见的。没有在单独的交易中测试持久化代码是一个疏忽，但这正是我们进行集成测试来捕捉的错误。
- en: 'We can fix the problem by altering the `store_object` method of the `file`
    class in `persistence.py` as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过修改`persistence.py`中`file`类的`store_object`方法来解决这个问题：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `unpickle_mocked_task` function is necessary because one thing that mocks
    doesn't handle very well is being 'pickled' and 'unpickled'. We used tuples in
    the tests for `file` because of that, but we need mocks for this test, so we have
    to go to the extra trouble of telling Pickle how to handle them.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`unpickle_mocked_task`函数是必要的，因为mocks处理得不是很好的一件事是“pickle”和“unpickle”。我们因为这样在`file`的测试中使用了元组，但我们需要对这个测试进行mocks，所以我们必须额外麻烦地告诉Pickle如何处理它们。'
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This should be a fairly familiar sort of test fixture, by now. The new thing
    is that the `tearDown` method will delete a database file, ( if it exists) but
    won't complain if it doesn't. The database is expected to be created within the
    test itself, and we don't want to leave it lying around, but if it's not there,
    it's not a test fixture error.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，这应该是一种相当熟悉的测试环境。新的东西是`tearDown`方法将删除一个数据库文件（如果存在的话），但不会对它不存在而抱怨。数据库预计将在测试本身中创建，我们不希望它留在外面，但如果它不存在，这并不是测试环境的错误。
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We're testing the interaction between schedules and persistence files, which
    means we've created and populated a schedule, created a persistence file, stored
    the schedule, and then created a new persistence file object using the same database
    file and loaded a new schedule from it. If the loaded schedule matches our expectations,
    all's well.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在测试调度和持久化文件之间的交互，这意味着我们已经创建并填充了一个调度，创建了一个持久化文件，存储了调度，然后使用相同的数据库文件创建了一个新的持久化文件对象，并从中加载了一个新的调度。如果加载的调度符合我们的预期，那么一切正常。
- en: A lot of the test code in this chapter might seem redundant to you. That's because,
    in some sense, it is. Some things are repeatedly checked in different tests. Why
    bother?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的许多测试代码可能看起来很冗余。这在某种程度上是正确的。有些事情在不同的测试中被反复检查。为什么还要这样做呢？
- en: The main reason for the redundancy is that each test is supposed to stand alone.
    We're not supposed to care what order they run in, or whether any other tests
    even exist. Each test is self-contained, so if it fails, we know exactly what
    needs to be fixed. Because each test is self-contained, some foundational things
    end up getting tested multiple times. In the case of this simple project, that
    redundancy is even more pronounced than it would normally be.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 重复性的主要原因在于每个测试都应该独立存在。我们不应该关心它们的运行顺序，或者是否有其他测试存在。每个测试都是自包含的，所以如果它失败了，我们就知道需要修复什么。因为每个测试都是自包含的，一些基础的东西最终会被多次测试。在这个简单的项目中，这种重复性比通常情况下更为明显。
- en: Whether it's blatant or subtle, the redundancy isn't a problem. The so-called
    DRY (Don't Repeat Yourself) principle doesn't particularly apply to tests. There's
    not much downside to having something tested multiple times. This is not to say
    that it's a good idea to copy and paste tests, because it's most certainly not.
    Don't be surprised or alarmed to see similarity between your tests, but don't
    use that as an excuse.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 无论这种重复性是明显的还是微妙的，都不是问题。所谓的DRY（不要重复自己）原则并不特别适用于测试。多次测试某事物并没有多少缺点。这并不是说复制粘贴测试是个好主意，因为显然不是。不要对测试之间的相似性感到惊讶或恐慌，但不要以此为借口。
- en: Pop quiz – writing integration tests
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 突击测验 - 编写集成测试
- en: Which integration tests do you write first?
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该先编写哪些集成测试？
- en: What happens when you have a large chunk of integrated code, but the next section
    you need to pull in doesn't have any integration tests at all?
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你有一大块集成代码，但下一个需要引入的部分根本没有任何集成测试时，会发生什么？
- en: What's the point of writing tests that check the integration of a chunk of code
    with itself?
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写测试来检查代码块与自身集成的目的是什么？
- en: What is a system test, and how do system tests relate to integration tests?
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统测试是什么，系统测试如何与集成测试相关？
- en: Have a go hero – integrating your own program
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄 - 集成你自己的程序
- en: Earlier, you wrote an integration diagram for one of your own programs. It's
    time now to follow up on that and write integration tests for that code, guided
    by the diagram.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，你为你的一个程序编写了一个集成图。现在是时候跟进并针对该代码编写集成测试，由图来指导。
- en: Summary
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the process of building up from a foundation
    of unit tests, into a set of tests that cover the whole system.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了从单元测试的基础构建到覆盖整个系统的测试集的过程。
- en: 'Specifically, we covered:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们涵盖了：
- en: How to draw an integration diagram
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何绘制集成图
- en: How to interpret an integration diagram to decide in what order to build the
    tests
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何解释集成图以决定测试构建的顺序
- en: How to write integration tests
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写集成测试
- en: Now that we've learned about integration testing, we're ready to introduce a
    number of other useful testing tools and strategies—which is the topic of the
    next chapter.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了集成测试，我们现在准备介绍一些其他有用的测试工具和策略——这是下一章的主题。
