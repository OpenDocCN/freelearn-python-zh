- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Understanding Microservices
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解微服务
- en: We are always trying to improve how we create software. Computer programming
    is less than 100 years old, and we have evolved rapidly through technology, design,
    and philosophy to improve the tools and applications we produce.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在努力改进我们创建软件的方式。计算机编程还不到100年，我们通过技术、设计和哲学的快速发展，来改进我们生产的工具和应用程序。
- en: Microservices have revolutionized software products by improving the readability
    and scalability of services, and have allowed organizations to speed up their
    release cycles and be more responsive to the needs of their customers. Everybody
    wants to ship new products and new features to their customers as fast as possible.
    They want to be *agile* by iterating often, and they want to ship, ship, and ship
    again.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务通过提高服务的可读性和可伸缩性，彻底改变了软件产品，并使组织能够加快其发布周期，并更快速地响应用户的需求。每个人都希望尽可能快地将新产品和新功能推向客户。他们希望通过频繁迭代来变得*敏捷*，并希望不断地发货，发货，再发货。
- en: With thousands of customers using your service simultaneously, it is considered
    good practice to push an experimental feature to production and remove it again
    if needed, instead of waiting for months to publish it and many other features
    at the same time.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当有数千名客户同时使用您的服务时，将实验性功能推送到生产环境并在必要时将其移除，而不是等待数月才能发布它以及许多其他功能，这被认为是良好的实践。
- en: Companies such, as Netflix, are promoting their continuous delivery techniques
    where small changes are made very often in production and tested on a subset of
    the user base. They've developed tools such as **Spinnaker** ([http://www.spinnaker.io/](http://www.spinnaker.io/))
    to automate as many steps as possible to update production and ship their features
    in the cloud as independent microservices.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如 Netflix 这样的公司正在推广他们的持续交付技术，在生产环境中非常频繁地进行小改动，并在用户子集上进行测试。他们开发了诸如 **Spinnaker**
    ([http://www.spinnaker.io/](http://www.spinnaker.io/)) 这样的工具，尽可能自动化更新生产和将功能作为独立微服务部署到云中的步骤。
- en: 'But if you read Hacker News or Reddit, it can be quite hard to untangle what''s
    useful for you and what''s just buzzword-compliant journalistic-style information.
    As *Edsger Dijkstra*, noted computer science researcher and discoverer of the
    famous shortest-path routing algorithm, put it:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你阅读 Hacker News 或 Reddit，可能会很难区分对你有用的信息和仅仅是符合流行语标准的新闻式信息。正如著名计算机科学家和著名最短路径路由算法的发现者*埃德加·迪杰斯特拉*所说：
- en: '"Write a paper promising salvation, make it a structured something or a virtual
    something, or abstract, distributed or higher-order or applicative and you can
    almost be certain of having started a new cult."'
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “写一篇承诺救赎的论文，让它成为一个结构化的东西，或者一个虚拟的东西，或者一个抽象的、分布式的、高阶的或应用性的东西，你几乎可以肯定你已经开启了一个新的教派。”
- en: ''
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Edsger W. Dijkstra
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ——埃德加·W·迪杰斯特拉
- en: This book will take you through the creation of a traditional monolithic service
    and provide guidance on how to identify components that will be more effective
    as microservices. We will cover ways to integrate with other services, pass messages
    and schedule tasks, and securely deploy our service in Amazon Web Services.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将带您了解传统单体服务的创建，并提供如何识别作为微服务将更有效的组件的指导。我们将涵盖与其他服务集成、传递消息和调度任务的方法，以及如何在亚马逊网络服务中安全地部署我们的服务。
- en: 'This chapter is going to help you understand what microservices are, and will
    then focus on the various ways in which you can implement them using Python. It
    is composed of the following sections:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将帮助您了解微服务是什么，然后重点介绍您可以使用 Python 实现微服务的各种方法。它由以下部分组成：
- en: The origins of service-oriented architecture
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向服务架构的起源
- en: The monolithic approach to building an application
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建应用程序的单体方法
- en: The microservices approach to building applications
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建应用程序的微服务方法
- en: Benefits of microservices
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务的优势
- en: Potential pitfalls in microservices
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务中的潜在陷阱
- en: Implementing microservices with Python
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Python 实现微服务
- en: Hopefully, once you've reached the end of the chapter, you will be able to dive
    into the rest of the book and build microservices with a good understanding of
    what they are and what they're not—and how you can use Python.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您在阅读完本章后，能够深入到本书的其余部分，并在对微服务及其不是什么有良好理解的情况下，使用 Python 构建微服务。
- en: The origins of service-oriented architecture
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向服务架构的起源
- en: There is no official standard for microservices, so it is helpful to look at
    a bit of the history in this area of software design. When discussing microservices,
    **Service-Oriented Architecture** (**SOA**) is often used as a starting point.
    SOA is a way of thinking about software architecture that encourages reusable
    software components that provide well-defined interfaces. This allows those components
    to be reused and applied to new situations.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于微服务，目前没有官方标准，因此查看该领域软件设计的历史是有帮助的。在讨论微服务时，**面向服务的架构**（**SOA**）通常被用作起点。SOA是一种关于软件架构的思考方式，它鼓励可重用的软件组件，这些组件提供了定义良好的接口。这使得这些组件可以被重用，并应用于新的情况。
- en: Each unit in the preceding definition is a self-contained service that implements
    one facet of a business and provides its feature through some interface.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 上述定义中的每个单元都是一个自包含的服务，它实现了一个商业方面的功能，并通过某种接口提供其功能。
- en: While SOA clearly states that services should be standalone processes, it does
    not enforce what protocols should be used for those processes to interact with
    each other and is quite vague about how you deploy and organize your application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SOA明确表示服务应该是独立进程，但它并没有强制规定这些进程之间应该使用哪些协议进行交互，并且对于如何部署和组织应用程序相当模糊。
- en: If you read the **SOA Manifesto** ([http://www.soa-manifesto.org](http://www.soa-manifesto.org)),
    first published on the web circa 2009, the authors don't even mention whether
    the services interact via a network, although contemporary understanding of the
    principles mostly involves networked services.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读了首次于2009年左右在网络上发布的**SOA宣言**（[http://www.soa-manifesto.org](http://www.soa-manifesto.org)），作者甚至没有提到服务是否通过网络进行交互，尽管对原则的理解大多涉及网络服务。
- en: SOA services could communicate via **Inter-Process Communication** (**IPC**)
    using sockets on the same machine, through shared memory, through indirect message
    queues, or even with **Remote Procedure Calls** (**RPC**). The options are extensive,
    and SOA is a useful set of principles for a wide variety of situations.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: SOA服务可以通过**进程间通信**（**IPC**）使用同一台机器上的套接字、通过共享内存、通过间接消息队列，甚至通过**远程过程调用**（**RPC**）进行通信。选项很多，SOA是一套适用于各种情况的有用原则。
- en: However, it is common to say that microservices are one specialization of SOA,
    because they allow us to focus on the needs of the organization, its safety, and
    the scaling and separation of its software.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，人们通常会说微服务是SOA的一种专业化，因为它们允许我们专注于组织的需要、其安全性以及软件的扩展和分离。
- en: If we want to give a complete definition of microservices, the best way to understand
    it is in the context of different software architectures. We will start with a
    monolith, and then discuss how microservices are different.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要给出微服务的完整定义，最好的方式是在不同的软件架构的背景下理解它。我们将从一个单体开始，然后讨论微服务是如何不同的。
- en: The monolithic approach
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单体方法
- en: 'With a monolith, everything about the service is in one place – the API, database,
    and all associated tools are managed as part of one code base. Let''s take a very
    simple example of a traditional monolithic application: a hotel booking website.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体架构中，关于服务的所有内容都在一个地方——API、数据库以及所有相关工具都被视为一个代码库的一部分。让我们以一个非常简单的传统单体应用程序为例：一个酒店预订网站。
- en: Besides the static HTML content, the website has a booking feature that will
    let its users book hotels in any city in the world. Users can search for hotels,
    then book them with their credit cards.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 除了静态HTML内容外，该网站还有一个预订功能，允许其用户在世界上的任何城市预订酒店。用户可以搜索酒店，然后使用信用卡预订。
- en: 'When a user performs a search on the hotel website, the application goes through
    the following steps:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在酒店网站上执行搜索时，应用程序会经过以下步骤：
- en: It runs a couple of SQL queries against its hotel database.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它在其酒店数据库上运行几个SQL查询。
- en: An HTTP request is made to a partner's service to add more hotels to the list.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向合作伙伴的服务发送HTTP请求，以将更多酒店添加到列表中。
- en: Results are sent to the JavaScript embedded in the web page, to render the information
    for the viewer.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果被发送到嵌入网页中的JavaScript，以渲染供观众查看的信息。
- en: 'From there, once the user has found the perfect hotel and selected the booking
    option, the application performs these steps:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，一旦用户找到了理想的酒店并选择了预订选项，应用程序会执行以下步骤：
- en: The customer gets created in the database, if needed, and has to authenticate
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，会在数据库中创建客户，并需要进行身份验证。
- en: Payment is carried out by interacting with the bank's web service
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过与银行的网络服务交互进行支付。
- en: The app saves the payment details in the database for legal reasons
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用出于法律原因将支付详情保存在数据库中
- en: A receipt is generated using a PDF generator
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用PDF生成器生成收据
- en: A recap email is sent to the user using the email service
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用电子邮件服务向用户发送总结电子邮件
- en: A reservation email is forwarded to the third-party hotel using the email service
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用电子邮件服务将预订电子邮件转发给第三方酒店
- en: A database entry is added to keep track of the reservation
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加数据库条目以跟踪预订
- en: This process is a simplified model, of course, but describes enough for us to
    learn from.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程是一个简化的模型，当然，但它描述了足够的内容，让我们从中学习。
- en: The application interacts with a database that contains the hotel's information,
    the reservation details, the billing, the user information, and so on. It also
    interacts with external services for sending emails, making payments, and getting
    more hotels from partners.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 应用与包含酒店信息、预订详情、计费、用户信息等的数据库进行交互。它还与外部服务交互，用于发送电子邮件、进行支付和从合作伙伴那里获取更多酒店。
- en: In the early days of the web, a new service would commonly use a **LAMP** (**Linux-Apache-MySQL-Perl/PHP/Python**)
    architecture. With this approach, every incoming request generates a cascade of
    SQL queries on the database, and a few network calls to external services, then
    the server generates the HTML response using a template engine.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络发展的早期，新的服务通常会使用**LAMP**（**Linux-Apache-MySQL-Perl/PHP/Python**）架构。这种方法中，每个进入的请求都会在数据库上生成一系列SQL查询，以及一些对外部服务的网络调用，然后服务器使用模板引擎生成HTML响应。
- en: 'The following diagram illustrates this centralized architecture:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示说明了这种集中式架构：
- en: '![](img/B17108_01_01_.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17108_01_01_.png)'
- en: 'Figure 1.1: A sample monolithic service architecture'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：一个示例单体服务架构
- en: This application is a typical monolith, and it has a lot of benefits. The biggest
    one is that the whole application is in a single code base, and when the project
    coding starts, it makes everything simpler. Building a good test coverage is easy,
    and you can organize your code in a clean and structured way inside the code base.
    Storing all the data in a single database also simplifies the development of the
    application. You can tweak the data model, and how the code will query it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用是一个典型的单体应用，它有很多好处。最大的好处是整个应用都在一个代码库中，当项目编码开始时，会使一切变得简单。构建良好的测试覆盖率很容易，你可以在代码库内部以干净和结构化的方式组织代码。将所有数据存储在单个数据库中也有助于简化应用的开发。你可以调整数据模型，以及代码如何查询它。
- en: The deployment is also straightforward; we can build a package, install it,
    and run it somewhere. To scale up, we can run several instances of the booking
    app, and run several databases with some replication mechanism in place.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 部署过程也很简单；我们可以构建一个包，安装它，并在某个地方运行它。为了扩展，我们可以运行多个预订应用的实例，并运行一些具有复制机制的数据库。
- en: If your application stays small, this model works well and is easy to maintain
    for a single team. But projects usually grow, and they get bigger than what was
    first intended. And having the whole application in a single code base brings
    some nasty issues along the way. For instance, if you need to make a sweeping
    change that is large in scope, such as changing your banking service or your database
    layer, the risks impact the whole application. These changes can have a huge impact
    on the project and need to be tested well before being deployed, and such testing
    often can't be exhaustive. Changes like this will happen in a project's life.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用保持小型，这种模型工作得很好，并且对于单一团队来说很容易维护。但是项目通常会增长，并且变得比最初设想的大。整个应用在单个代码库中会带来一些棘手的问题。例如，如果你需要做出大规模的改动，比如更改你的银行服务或数据库层，这些改动会对整个应用产生风险。这些更改对项目有很大影响，在部署之前需要经过良好的测试，而这种测试通常无法彻底。这样的改变在项目生命周期中是会发生的。
- en: Small changes can also generate collateral damage because different parts of
    the system have different uptime and stability requirements. Putting the billing
    and reservation processes at risk because the function that creates a PDF crashes
    the server is a bit of a problem.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 小的改动也可能产生附带损害，因为系统的不同部分有不同的运行时间和稳定性要求。将计费和预订流程置于风险之中，因为创建PDF的功能导致服务器崩溃，这确实是个问题。
- en: Uncontrolled growth is another issue. The application is bound to get new features,
    and with developers leaving and joining the project, the code might start to get
    messy, the tests a bit slower, and the deployment more fragile. This growth usually
    ends up with a spaghetti code base that's hard to maintain, with a hairy database
    that needs complicated migration plans every time some developer refactors the
    data model.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 无控制的增长是另一个问题。应用程序必然会添加新功能，随着开发人员的加入和离开，代码可能会变得杂乱无章，测试可能会变慢，部署可能会变得脆弱。这种增长通常会导致难以维护的意大利面代码库，以及需要复杂迁移计划的复杂数据库。
- en: The other form of growth that makes the project interesting is capacity management.
    If just one element in the application needs to scale very differently than the
    rest, then scaling the application becomes much trickier; for example, if the
    hotel room availability starts being used to generate website advertising, as
    well as serving people visiting the website.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使项目变得有趣的其他增长形式是容量管理。如果应用程序中的某个元素需要与其它元素非常不同的扩展，那么扩展应用程序就会变得非常困难；例如，如果酒店房间可用性开始被用来生成网站广告，以及服务于访问网站的访客。
- en: Large software projects usually take a couple of years to mature, and then they
    slowly start to turn into an incomprehensible mess that's hard to maintain. And
    it does not happen because developers are bad. It happens because as the complexity
    grows, fewer people fully understand the implications of every small change they
    make.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 大型软件项目通常需要几年时间才能成熟，然后它们会逐渐开始变成难以理解的混乱，难以维护。这并不是因为开发者做得不好。这是因为随着复杂性的增加，越来越少的人能够完全理解他们所做的每一个小更改的后果。
- en: So, they try to work in isolation with a fragment of the code base, and the
    mess only becomes visible when you view the entire structure of the project. We've
    all been there.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，他们试图与代码库的一部分独立工作，混乱只有在查看整个项目结构时才会变得明显。我们都有过这样的经历。
- en: It's not fun, and developers who work on such a project dream of building the
    application from scratch with the newest framework. And by doing so, they usually
    face the same issues again – the same story is repeated.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不有趣，从事此类项目的开发者梦想着从头开始使用最新的框架来构建应用程序。通过这样做，他们通常又会面临同样的问题——同样的故事再次上演。
- en: 'To summarize, with a monolithic architecture there are benefits:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，单体架构有一些好处：
- en: Starting a project as a monolith is easy, and probably the best approach.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以单体形式启动项目很容易，而且可能是最好的方法。
- en: A centralized database simplifies the design and organization of the data.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集中式数据库简化了数据的设计和组织。
- en: Deploying one application is simple.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署一个应用程序很简单。
- en: 'However:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而：
- en: Any change in the code can impact unrelated features. When something breaks,
    the whole application may break.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码中的任何更改都可能影响无关的功能。当某个功能出现问题时，整个应用程序可能会崩溃。
- en: 'Solutions to scale your application are limited: you can deploy several instances,
    but if one particular feature inside the app takes all the resources, it impacts
    everything.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展应用程序的解决方案有限：你可以部署多个实例，但如果应用程序中的某个特定功能消耗了所有资源，它会影响一切。
- en: As the code base grows, it's hard to keep it clean and under control.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着代码库的增长，很难保持其整洁和可控。
- en: There are, of course, some ways to avoid some of the issues described here.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有一些方法可以避免这里描述的一些问题。
- en: The obvious solution is to split the application into separate pieces, even
    if the resulting code is still going to run in a single process. Developers do
    this by building their apps with external libraries and frameworks. Those tools
    can be in-house or from the **Open-Source Software** (**OSS**) community.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 显而易见的解决方案是将应用程序拆分成独立的组件，即使最终代码仍然会在单个进程中运行。开发者通过使用外部库和框架来构建他们的应用程序来实现这一点。这些工具可以是内部开发的，也可以来自**开源软件**（**OSS**）社区。
- en: If you build a web app in Python using a framework like **Quart** or **Flask**,
    you are able to focus on the business logic, and it becomes very appealing to
    externalize some of your code into framework extensions and small Python packages.
    And splitting your code into small packages is often a good idea to control your
    application growth.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用像**Quart**或**Flask**这样的框架在Python中构建Web应用程序，你能够专注于业务逻辑，将一些代码外部化为框架扩展和小的Python包变得非常有吸引力。将代码拆分成小包通常是控制应用程序增长的好主意。
- en: '"Small is beautiful."'
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “小即是美。”
- en: ''
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —The UNIX philosophy
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —UNIX哲学
- en: For instance, the PDF generator described in the hotel booking app could be
    a separate Python package that uses **ReportLab** and some templates to do the
    work. It's highly likely that this package could be reused in some other applications,
    and maybe even published to the **Python Package Index** (**PyPI**) for the community.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，酒店预订应用程序中描述的PDF生成器可以是一个独立的Python包，该包使用**ReportLab**和一些模板来完成工作。这个包很可能在其他应用程序中重用，甚至可能发布到**Python包索引**（**PyPI**）供社区使用。
- en: But you're still building a single application and some problems persist, like
    the inability to scale parts differently, or any indirect issue introduced by
    a buggy dependency.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 但你仍然在构建一个单一的应用程序，一些问题仍然存在，比如无法不同比例地扩展部分，或者由有缺陷的依赖项引入的任何间接问题。
- en: You'll even face new challenges because you're now using dependencies. One problem
    that you'll face is *dependency hell*. If two parts of your application use the
    same library, you could get into the situation where one part of your application
    requires a new version for a feature that has been added, but another component
    can't use the newer one because something else has changed, and you are now in
    *dependency hell*. There's a good chance you will eventually have some ugly workaround
    for this problem in a large project, such as having a copy of the dependency that
    you now need to maintain separately to keep the fix up to date.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至会面临新的挑战，因为你现在正在使用依赖项。你将面临的一个问题是**依赖地狱**。如果你的应用程序的两个部分使用相同的库，你可能会陷入这样的情况：一个部分的应用程序需要新版本的功能，但另一个组件不能使用更新的版本，因为其他东西已经改变，你现在处于**依赖地狱**。有很大可能性，你最终会在大型项目中找到一些丑陋的解决方案来解决这个问题，比如保留一个依赖项的副本，你现在需要单独维护以保持修复更新。
- en: Of course, all the problems described in this section do not appear on day one
    when the project starts, but rather pile up over time.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，本节中描述的所有问题在项目开始的第一天都不会出现，而是在一段时间内逐渐积累。
- en: Let's now look at how the same application would look if we were to use microservices
    to build it.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看，如果我们使用微服务来构建相同的应用程序，它将看起来如何。
- en: The microservice approach
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务方法
- en: 'If we were to build the same application using microservices, we would organize
    the code into several separate components that run in separate processes. We have
    already discussed the PDF report generator, and we can examine the rest of the
    application and see where we could split it into different microservices, as shown
    in the following diagram:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用微服务构建相同的应用程序，我们会将代码组织成几个独立的组件，这些组件在单独的进程中运行。我们已经讨论了PDF报告生成器，我们可以检查应用程序的其余部分，看看我们可以在哪里将其拆分为不同的微服务，如下面的图所示：
- en: '![](img/B17108_01_02.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17108_01_02.png)'
- en: 'Figure 1.2: A sample microservice architecture'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：一个示例微服务架构
- en: 'Don''t be afraid of the number of components displayed in this diagram. The
    internal interactions of the monolithic application are just being made visible
    by separate pieces. We''ve shifted some of the complexity and ended up with these
    seven standalone components:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 不要害怕图中显示的组件数量。单体应用程序的内部交互只是通过单独的部分变得可见。我们已经将一些复杂性转移，最终得到了这些七个独立的组件：
- en: '**Booking UI**: A frontend service that generates the web user interface, and
    interacts with all the other microservices.'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**预订UI**：一个前端服务，生成网页用户界面，并与所有其他微服务进行交互。'
- en: '**PDF reports**: A very simple service that will create PDFs for receipts or
    any other document given a template and some data. Also known as the PDF reporting
    service.'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**PDF报告**：一个非常简单的服务，可以根据模板和一些数据创建收据或其他文档。也称为PDF报告服务。'
- en: '**Search**: A service that can be queried to get a list of hotels when given
    a location. This service has its own database.'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**搜索**：一个服务，当给定一个位置时，可以查询以获取酒店列表。此服务有自己的数据库。'
- en: '**Payments**: A service that interacts with the third-party bank service, and
    manages a billing database. It also sends emails on successful payment.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**支付**：一个与第三方银行服务交互并管理计费数据库的服务。它还在支付成功时发送电子邮件。'
- en: '**Reservations**: Manages reservations and changes to bookings.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**预订**：管理预订和预订更改。'
- en: '**Users**: Stores the user information, and interacts with users via emails.'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**用户**：存储用户信息，并通过电子邮件与用户交互。'
- en: '**Authentication**: An OAuth 2-based service that returns authentication tokens,
    which each microservice can use to authenticate when calling others.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**认证**：一个基于OAuth 2的服务，返回认证令牌，每个微服务都可以在调用其他服务时使用这些令牌进行认证。'
- en: Those microservices, along with a few external services, like the email service,
    would provide a feature set similar to the monolithic application. In this design,
    each component communicates using the HTTP protocol, and features are made available
    through RESTful web services.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这些微服务，以及一些外部服务，如电子邮件服务，将提供类似于单体应用的功能集。在这个设计中，每个组件使用HTTP协议进行通信，功能通过RESTful Web服务提供。
- en: There's no centralized database, as each microservice deals internally with
    its own data structures, and the data that gets in and out uses a language-agnostic
    format like JSON. It could use XML or YAML as long as it can be produced and consumed
    by any language, and travel through HTTP requests and responses.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 没有集中式数据库，因为每个微服务内部处理自己的数据结构，进出数据使用一种语言无关的格式，如JSON。只要它可以被任何语言产生和消费，并且通过HTTP请求和响应传输，它也可以使用XML或YAML。
- en: The Booking UI service is a bit particular in that regard, since it generates
    the **User Interface** (**UI**). Depending on the frontend framework used to build
    the UI, the Booking UI output could be a mix of HTML and JSON, or even plain JSON
    if the interface uses a static JavaScript-based client-side tool to generate the
    interface directly in the browser.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 预订UI服务在这方面有点特别，因为它生成**用户界面**（**UI**）。根据用于构建UI的前端框架，预订UI输出可能是HTML和JSON的混合体，或者如果界面使用基于静态JavaScript的客户端工具直接在浏览器中生成界面，则可能是纯JSON。
- en: But besides this particular UI case, a web application designed with microservices
    is a composition of several microservices, which may interact with each other
    through HTTP to provide the whole system.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 但除了这个特定的UI案例之外，一个使用微服务设计的Web应用程序是由几个微服务组成的，这些微服务可能通过HTTP相互交互，以提供整个系统。
- en: 'In that context, microservices are logical units that focus on a very particular
    task. Here''s a full definition attempt:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个背景下，微服务是专注于非常特定任务的逻辑单元。以下是一个完整的定义尝试：
- en: A microservice is a lightweight application that provides a narrow list of features
    with a well-defined contract. It's a component with a single responsibility that
    can be developed and deployed independently.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是一个轻量级的应用程序，提供一系列具有良好定义契约的功能。它是一个具有单一责任、可以独立开发和部署的组件。
- en: This definition does not mention HTTP or JSON, because you could consider, for
    example, a small UDP-based service that exchanges binary data as a microservice,
    or a service that communicates using gRPC. (gRPC is a recursive acronym that stands
    for gRPC Remote Procedure Call, an open-source remote procedure call system.)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义没有提到HTTP或JSON，因为你可以考虑，例如，一个小型的基于UDP的服务，它作为微服务交换二进制数据，或者一个使用gRPC进行通信的服务。（gRPC是一个递归缩写，代表gRPC远程过程调用，一个开源的远程过程调用系统。）
- en: But in our case, and throughout the book, all our microservices are just simple
    web applications that use the HTTP protocol and consume and produce JSON when
    it's not a UI.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们的案例中，以及在整个书中，我们所有的微服务都只是简单的Web应用程序，它们使用HTTP协议，并且在不是UI的情况下消费和产生JSON。
- en: Microservice benefits
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务的好处
- en: 'While the microservices architecture looks more complicated than its monolithic
    counterpart, it offers multiple advantages. It offers the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然微服务架构看起来比其单体对应物更复杂，但它提供了多个优点。它提供了以下优点：
- en: Separation of concerns
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关注点的分离
- en: Smaller projects to deal with
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更小的项目要处理
- en: More scaling and deployment options
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多的扩展和部署选项
- en: We will discuss them in more detail in the following sections.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中更详细地讨论它们。
- en: Separation of concerns
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关注点的分离
- en: First of all, each microservice can be developed independently by a separate
    team. For instance, building a reservation service can be a full project on its
    own. The team in charge can code it in the programming language and database of
    their choice, as long as it has a well-documented HTTP API.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，每个微服务都可以由一个单独的团队独立开发。例如，构建一个预订服务可以是一个完整的项目。负责的团队可以使用他们选择的编程语言和数据库进行编码，只要它有一个良好的文档化的HTTP
    API。
- en: That also means the evolution of the app is more under control than with monoliths.
    For example, if the payment system changes its underlying interactions with the
    bank, the impact is localized inside that service, and the rest of the application
    stays stable and is probably unaffected.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着应用程序的演变比单体应用更容易控制。例如，如果支付系统更改其与银行的底层交互，影响将局限于该服务内部，其余的应用程序保持稳定，可能不受影响。
- en: This is known as loose coupling, and improves the overall project velocity as
    we apply, at the service level, a philosophy similar to the *single responsibility* principle.
    By contrast, a tightly coupled payment service would need inside knowledge of
    how the system represents its data or performs its task.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为松耦合，并且当我们应用类似*单一职责*原则的哲学在服务级别时，它提高了整体项目的速度。相比之下，紧密耦合的支付服务需要了解系统如何表示其数据或执行其任务的内部知识。
- en: Robert Martin, the author of many widely respected books about software engineering,
    defined the single responsibility principle to explain that a class should have
    only one reason to change; in other words, each class should provide a single,
    well-defined feature. Applied to microservices, it means that we want to make
    sure that each microservice focuses on a single role.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工程领域许多备受尊敬的书籍的作者罗伯特·马丁（Robert Martin）定义了单一职责原则，以解释一个类应该只有一个改变的理由；换句话说，每个类应该提供一个单一、定义良好的功能。应用于微服务，这意味着我们想要确保每个微服务专注于单一角色。
- en: Smaller projects
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 较小的项目
- en: The second benefit is breaking the complexity of the project. When you add a
    feature to an application such as PDF reporting, even if you do it cleanly, you
    make the code base bigger, more complicated, and sometimes slower. Building that
    feature in a separate application avoids this problem and makes it easier to write
    it with whatever tools you want. You can refactor it often, shorten your release
    cycles, and stay on top of things. The growth of the application remains under
    your control.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个好处是简化项目的复杂性。当您向应用程序添加一个功能，如PDF报告，即使您做得干净利落，也会使代码库变大、更复杂，有时甚至变慢。在单独的应用程序中构建该功能可以避免这个问题，并使其更容易使用您想要的任何工具来编写。您可以经常重构它，缩短发布周期，并保持对事物的控制。应用程序的增长仍然在您的控制之下。
- en: 'Dealing with a smaller project also reduces risks when improving the application:
    if a team wants to try out the latest programming language or framework, they
    can iterate quickly on a prototype that implements the same microservice API,
    try it out, and decide whether or not to stick with it.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 处理较小的项目在改进应用程序时也能降低风险：如果一个团队想要尝试最新的编程语言或框架，他们可以快速迭代实现相同微服务API的原型，尝试使用它，并决定是否继续使用。
- en: One real-life example is the Firefox Sync storage microservice. There were experiments
    to switch from storing data in MySQL, to an implementation that stores users'
    data in standalone SQLite databases. The risks of an experimental prototype were
    mitigated by isolating the storage feature in a microservice with a well-defined
    HTTP API. This minimized the unexpected interactions with other components and
    allowed a small subset of the user base to try out the new version of the service.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一个现实生活中的例子是Firefox Sync存储微服务。曾经有实验尝试从将数据存储在MySQL中，切换到将用户数据存储在独立的SQLite数据库中的实现。通过将存储功能隔离在一个具有良好定义的HTTP
    API的微服务中，降低了实验原型可能带来的风险。这最小化了与其他组件的意外交互，并允许一小部分用户尝试新版本的服务。
- en: Reducing the size of each component also makes it easier to think about for
    developers, especially new ones joining the team or ones who are stressed about
    handling an outage with the service. Instead of having to work through an entire
    system, a developer can focus on a smaller area and not worry about the rest of
    the application's features.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 减少每个组件的大小也使得开发者更容易思考，尤其是对于新加入团队或对处理服务中断感到压力的开发者。开发者不必处理整个系统，可以专注于较小的区域，不必担心应用程序的其他功能。
- en: Scaling and deployment
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展和部署
- en: Finally, having your application split into components makes it easier to scale
    depending on your constraints. Let's say your business grows and there are many
    more customers who book hotels each day, and the PDF generation starts to use
    more resources and slows down. To tackle this problem, you can deploy that specific
    microservice in some servers that have bigger CPUs or more memory.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将应用程序拆分为组件，根据您的限制更容易进行扩展。假设您的业务增长，每天都有更多的客户预订酒店，PDF生成开始使用更多资源并变慢。为了解决这个问题，您可以在一些具有更大CPU或更多内存的服务器上部署那个特定的微服务。
- en: Another typical example is a high memory usage microservice, such as ones that
    interact with in-memory databases such as **Redis** or **Memcached**. You could
    tweak your deployments, consequently, by using servers with less CPU and a lot
    more RAM.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个典型的例子是高内存使用微服务，例如与内存数据库（如**Redis**或**Memcached**）交互的微服务。因此，您可以通过使用具有较少CPU和更多RAM的服务器来调整您的部署。
- en: 'We can, thus, summarize the benefits of microservices as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以总结微服务的以下好处：
- en: A team can develop each microservice independently, and use whatever technology
    stack makes sense. They can define a custom release cycle. All they need to define
    is a language-agnostic HTTP API.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个团队可以独立开发每个微服务，并使用任何有意义的科技栈。他们可以定义一个自定义发布周期。他们需要定义的只是一个语言无关的HTTP API。
- en: Developers split the application complexity into logical components. Each microservice
    focuses on doing one thing well.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者将应用程序的复杂性拆分为逻辑组件。每个微服务专注于做好一件事。
- en: Since microservices are standalone applications, there's finer control over
    deployments, which makes scaling easier.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于微服务是独立的应用程序，对部署有更精细的控制，这使得扩展变得更容易。
- en: The microservices architecture is good at solving a lot of the problems that
    may arise once your application starts to grow. However, we need to be aware of
    some of the new issues that are brought along.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构擅长解决应用程序开始增长后可能出现的许多问题。然而，我们需要意识到随之而来的某些新问题。
- en: Pitfalls of microservices
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务的陷阱
- en: As discussed earlier, building an application with microservices has many benefits,
    but it's not a silver bullet by any means.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，使用微服务构建应用程序有许多好处，但绝不是万能的。
- en: 'You need to be aware of these main problems you might have to deal with when
    coding microservices:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当编码微服务时，你需要意识到以下主要问题：
- en: Illogical splitting
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不合理的拆分
- en: More network interactions
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多的网络交互
- en: Data storing and sharing
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据存储和共享
- en: Compatibility issues
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 兼容性问题
- en: Testing
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试
- en: These issues will be covered in detail in the following sections.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题将在以下章节中详细讨论。
- en: Illogical splitting
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不合理的拆分
- en: The first issue of a microservice architecture is how it gets designed. There's
    no way a team can come up with the perfect microservice architecture on their
    first shot. Some microservices like the PDF generator are an obvious use case.
    But as soon as you deal with the business logic, there's a good chance that your
    code will move around before you get a good grasp of how to split things into
    the right set of microservices.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构的第一个问题是其设计方式。团队不可能在一次尝试中就提出完美的微服务架构。一些微服务，如PDF生成器，是一个明显的用例。但是，一旦你处理业务逻辑，就有很大可能性在掌握如何将事物拆分为正确的微服务集合之前，你的代码就会移动。
- en: The design needs to mature with some try-and-fail cycles. And adding and removing
    microservices can be more painful than refactoring a monolithic application. You
    can mitigate this problem by avoiding splitting your app into microservices if
    the split is not evident.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 设计需要通过一些尝试和失败周期来成熟。添加和删除微服务可能比重构单体应用程序更痛苦。你可以通过避免将应用程序拆分为微服务来减轻这个问题，如果拆分不明显的话。
- en: If there's any doubt that the split makes sense, keeping the code in the same
    app is the safe bet. It's always easier to split apart some of the code into a
    new microservice later than to merge two microservices back in the same code base
    because the decision turned out to be wrong.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有任何疑问，认为拆分是有意义的，那么将代码保留在同一个应用程序中是安全的赌注。总是更容易在以后将一些代码拆分到一个新的微服务中，而不是因为决策错误而将两个微服务合并回同一个代码库。
- en: For instance, if you always have to deploy two microservices together, or if
    one change in a microservice impacts the data model of the other one, the odds
    are that you did not split the application correctly and that those two services
    should be reunited.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你总是必须一起部署两个微服务，或者如果微服务中的一个更改影响了另一个微服务的数据模型，那么很可能你没有正确地拆分应用程序，这两个服务应该被重新组合。
- en: More network interactions
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多的网络交互
- en: The second problem is the number of network interactions added to build the
    same application. In the monolithic version, even if the code gets messy, everything
    happens in the same process, and you can send back the result without having to
    call too many backend services to build the actual response.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是构建相同应用时添加的网络交互数量。在单体版本中，即使代码变得混乱，所有操作都在同一个进程中完成，你可以在不调用太多后端服务构建实际响应的情况下发送回结果。
- en: 'That requires extra attention to how each backend service is called and raises
    a lot of questions, like the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要特别注意如何调用每个后端服务，并引发许多问题，如下所示：
- en: What happens when the Booking UI cannot reach the PDF reporting service because
    of a network split or a laggy service?
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当预订用户界面因为网络分割或服务延迟无法访问PDF报告服务时会发生什么？
- en: Does the Booking UI call the other services synchronously or asynchronously?
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预订用户界面是同步调用其他服务还是异步调用？
- en: How will that impact the response time?
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将如何影响响应时间？
- en: We will need to have a solid strategy to be able to answer all those questions,
    and we will address those in *Chapter 6*, *Interacting with Other Services*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要有一个稳固的策略来回答所有这些问题，我们将在第6章*与其他服务交互*中解决这些问题。
- en: Data storing and sharing
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据存储和共享
- en: Another problem is data storing and sharing. An effective microservice needs
    to be independent of other microservices, and ideally, should not share a database.
    What does this mean for our hotel booking app?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题在于数据存储和共享。一个有效的微服务需要独立于其他微服务，理想情况下，不应共享数据库。这对我们的酒店预订应用意味着什么？
- en: 'Again, that raises a lot of questions, such as the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这引发了许多问题，例如以下这些：
- en: Do we use the same users' IDs across all databases, or do we have independent
    IDs in each service and keep it as a hidden implementation detail?
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否在所有数据库中使用相同的用户ID，或者每个服务都有独立的ID，并将其作为隐藏的实现细节？
- en: Once a user is added to the system, do we replicate some of her information
    in other services' databases via strategies like data pumping, or is that overkill?
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦用户被添加到系统中，我们是否通过数据泵送等策略在其他服务的数据库中复制她的部分信息，或者这是否过于过度？
- en: How do we deal with data removal?
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何处理数据删除？
- en: These are hard questions to answer, and there are many different ways to solve
    those problems, as we'll learn throughout the book.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题是很难回答的，而且有很多人不同的方式来解决这些问题，正如我们将在本书中学习的那样。
- en: Avoiding data duplication as much as possible while keeping microservices in
    isolation is one of the biggest challenges in designing microservices-based applications.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在尽可能避免数据重复的同时，保持微服务的隔离是设计基于微服务应用程序的最大挑战之一。
- en: Compatibility issues
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 兼容性问题
- en: Another problem happens when a feature change impacts several microservices.
    If a change affects, in a backward-incompatible way, the data that travels between
    services, you're in for some trouble.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题发生在功能变更影响多个微服务时。如果变更以向后不兼容的方式影响服务之间的数据传输，你将面临一些麻烦。
- en: Can you deploy your new service, and will it work with older versions of other
    services? Or do you need to change and deploy several services at once? Does it
    mean you've just stumbled on some services that should probably be merged back
    together?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你能否部署你的新服务，并且它是否与旧版本的其他服务兼容？或者你是否需要一次性更改和部署多个服务？这意味着你是否偶然发现了一些应该合并回一起的服务？
- en: Good versioning and API design hygiene helps to mitigate those issues, as we
    will discover in the second part of the book, when we'll build our application.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的版本控制和API设计卫生有助于减轻这些问题，正如我们在本书的第二部分将了解到的那样，当我们构建我们的应用程序时。
- en: Testing
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试
- en: Lastly, when you want to do some end-to-end tests and deploy your whole app,
    you have to deal with many components. You need to have a robust and agile deployment
    process to be efficient. You need to be able to play with your whole application
    when you develop it. You can't fully test things out with just one piece of the
    puzzle, although having a clean and well-defined interface does help.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当你想要进行一些端到端测试并部署整个应用程序时，你必须处理许多组件。你需要有一个强大且敏捷的部署流程才能高效。你在开发时需要能够玩转整个应用程序。你不能只通过一块拼图来完全测试事物，尽管拥有干净和定义良好的接口确实有帮助。
- en: Many of the recent developments in cloud orchestration tools, such as Kubernetes,
    Terraform, and CloudFormation make life much easier when deploying an application
    that consists of several components. They can be used to create test and staging
    environments as well as production, customer-facing deployments. The popularity
    of these tools has helped in the success and adoption of microservices.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 云编排工具的最新发展，如Kubernetes、Terraform和CloudFormation，在部署由多个组件组成的应用程序时使生活变得更加容易。它们可以用来创建测试和预发布环境，以及面向客户的部署。这些工具的流行有助于微服务的成功和采用。
- en: Microservices-style architecture boosts deployment tools' innovation, and deployment
    tools lower the bar for the approval of microservices-style architecture.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务风格的架构推动了部署工具的创新，而部署工具降低了微服务风格架构的审批门槛。
- en: 'The pitfalls of using microservices can be summarized as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微服务的陷阱可以总结如下：
- en: Premature splitting of an application into microservices can lead to architectural
    problems.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过早地将应用程序拆分为微服务可能导致架构问题。
- en: Network interactions between microservices add potential points of failure and
    additional overhead.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务之间的网络交互增加了潜在的故障点和额外的开销。
- en: Testing and deploying microservices can be complex.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试和部署微服务可能很复杂。
- en: And the biggest challenge—data sharing between microservices is hard.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大的挑战——微服务之间的数据共享很困难。
- en: You should not worry too much about all the pitfalls described in this section
    for now. They may seem overwhelming, and the traditional monolithic application
    may look like a safer bet, but in the long term, splitting your project into microservices
    will make many of your tasks, as a developer or as an **operations person** (**ops**),
    easier. It can also make running a service cheaper. To add more capacity to a
    monolithic application, you need a larger server, or the ability to add more large
    servers. If the architecture is distributed and based around microservices, then
    extra resources can be added in smaller increments, holding far closer to the
    amount actually needed. And as we will discover in *Chapter 9:* *Deployment, Running,
    and Scaling*, it can be easier to set a cloud service provider up to automatically
    scale based on demand.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在不必过于担心本节中描述的所有陷阱。它们可能看起来令人难以承受，传统的单体应用可能看起来更安全，但从长远来看，将你的项目拆分为微服务将使作为开发者或作为**运维人员**（**ops**）的许多任务更容易。这也可以使运行服务更便宜。要向单体应用添加更多容量，你需要更大的服务器，或者能够添加更多大型服务器的能力。如果架构是分布式的并且基于微服务，那么可以以更小的增量添加额外资源，更接近实际所需的数量。而且，正如我们将在*第9章：部署、运行和扩展*中发现的，可以更容易地设置云服务提供商以根据需求自动扩展。
- en: Implementing microservices with Python
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python实现微服务
- en: Python is an amazingly versatile language. As you probably already know, Python
    is used to build many different kinds of applications – from simple system scripts
    that perform tasks on a server to large object-oriented applications that run
    services for millions of users. Python is also used in machine learning and data
    analysis tools.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种非常灵活的语言。正如你可能已经知道的，Python被用来构建许多不同种类的应用程序——从在服务器上执行任务的简单系统脚本到为数百万人运行服务的庞大面向对象应用程序。Python也被用于机器学习和数据分析工具。
- en: Python sits comfortably in the top five languages in the TIOBE index ([http://www.tiobe.com/tiobe-index/](http://www.tiobe.com/tiobe-index/)),
    and has reached as high as number two. It's probably even bigger in the web development
    world since languages like C are rarely used as main languages to build web applications.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Python在TIOBE指数中排名前五（[http://www.tiobe.com/tiobe-index/](http://www.tiobe.com/tiobe-index/）），甚至达到过第二的位置。在Web开发领域，它可能更为重要，因为像C这样的语言很少被用作构建Web应用程序的主语言。
- en: This book makes the assumption that you are already familiar with the Python
    programming language. If you are not an experienced Python developer, you can
    read the book *Expert Python Programming*, *Third Edition*, where you will learn
    advanced programming skills in Python.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 本书假设你已经熟悉Python编程语言。如果你不是经验丰富的Python开发者，你可以阅读《Expert Python Programming》，《第三版》，在那里你将学习Python的高级编程技能。
- en: However, some developers criticize Python for being slow and unfit for building
    efficient web services. Python is slow, and this is undeniable, though it is fast
    enough for most situations. But it still is the language of choice for building
    microservices, and many major companies happily use it.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一些开发者批评Python速度慢，不适合构建高效的Web服务。Python确实慢，这是不可否认的，尽管它对于大多数情况来说已经足够快。但它仍然是构建微服务的首选语言，许多大型公司都乐意使用它。
- en: This section will give you some background on the different ways you can write
    microservices using Python, offer some insights on asynchronous versus synchronous
    programming, and conclude with some details on Python performance.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将为你提供一些背景信息，介绍你可以使用Python编写微服务的不同方式，提供一些关于异步编程与同步编程的见解，并以Python性能的细节作为总结。
- en: How web services work
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络服务的工作原理
- en: 'If we imagine a simple program that answers queries on the web, the description
    is straightforward. A new connection is made, and the protocol is negotiated.
    A request is made, and some processing is done: perhaps a database is queried.
    Then a response is structured and sent, and the connection is closed. This is
    often how we want to think about our application''s logic, because it keeps things
    simple for the developer as well as anyone else responsible for the program once
    it''s running.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想象一个简单的程序，该程序在网络上回答查询，其描述是直接的。一个新的连接被建立，并协商协议。一个请求被提出，并进行一些处理：可能查询了一个数据库。然后构建响应并发送，连接关闭。这通常是我们要思考应用程序逻辑的方式，因为它使开发者和任何其他负责程序运行的人都能保持事情简单。
- en: The web is a big, complicated place, though. Various parts of the internet will
    try to do malicious things to a vulnerable web service they find. Others just
    behave badly because they have not been set up well. Even when things are working
    well, there are different HTTP protocol versions, encryption, load balancing,
    access control, and a whole set of other things to think about.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，网络是一个庞大而复杂的地方。互联网的各个部分都会试图对它们发现的易受攻击的Web服务进行恶意操作。其他人只是表现不佳，因为他们没有设置好。即使事情运行良好，也有不同的HTTP协议版本、加密、负载均衡、访问控制和一系列其他需要考虑的事情。
- en: Rather than reinvent all of this technology, there are **interfaces** and **frameworks**
    that let us use the tools that other people have built, and spend more of our
    time working on our own applications. They let us use web servers such as **Apache**
    and **nginx** and let them handle the difficult parts of being on the web, such
    as certificate management, load balancing, and handling multiple website identities.
    Our application then has a smaller, more manageable configuration to control its behavior.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是重新发明所有这些技术，有一些**接口**和**框架**让我们可以使用其他人构建的工具，并将更多时间花在我们自己的应用程序上。它们让我们可以使用Web服务器，如**Apache**和**nginx**，并让它们处理网络上的困难部分，如证书管理、负载均衡和处理多个网站身份。然后，我们的应用程序有一个更小、更易于管理的配置来控制其行为。
- en: The WSGI standard
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WSGI标准
- en: What strikes most web developers who start with Python is how easy it is to
    get a web application up and running.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于从Python开始学习的多数网络开发者来说，最令人印象深刻的是构建一个Web应用程序是多么容易。
- en: Inspired by the older **Common Gateway Interface** (**CGI**), the Python web
    community has created a standard called the **Web Server Gateway Interface** (**WSGI**).
    It simplifies how you can write a Python application in order to serve HTTP requests.
    When your code uses this standard, your project can be executed by standard web
    servers like Apache or nginx, using WSGI extensions like `uwsgi` or `mod_wsgi`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 受较旧的**通用网关接口**（**CGI**）的启发，Python网络社区创建了一个名为**Web服务器网关接口**（**WSGI**）的标准。它简化了编写Python应用程序以服务HTTP请求的方式。当您的代码使用此标准时，您的项目可以通过标准Web服务器（如Apache或nginx）以及使用WSGI扩展（如`uwsgi`或`mod_wsgi`）来执行。
- en: Your application just has to deal with incoming requests and send back JSON
    responses, and Python includes all that goodness in its standard library.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序只需处理传入的请求并发送JSON响应，Python在它的标准库中包含了所有这些优点。
- en: 'You can create a fully functional microservice that returns the server''s local
    time with a vanilla Python module of fewer than 10 lines:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用少于10行的纯Python模块创建一个完全功能化的微服务，该服务返回服务器的本地时间：
- en: '[PRE0]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Since its introduction, the WSGI protocol has become an essential standard,
    and the Python web community has widely adopted it. Developers have written middleware,
    which are functions you can hook before or after the WSGI application function
    itself, to do something within the environment.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 自从其推出以来，WSGI协议已成为一个基本标准，Python网络社区已经广泛采用它。开发者编写了中间件，这些是可以在WSGI应用函数之前或之后挂载的函数，以在环境中执行某些操作。
- en: Some web frameworks, such as **Bottle** ([http://bottlepy.org](http://bottlepy.org)),
    were created specifically around that standard, and soon enough, every framework
    out there could be used through WSGI in one way or another.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一些网络框架，例如**Bottle**（[http://bottlepy.org](http://bottlepy.org)），是专门围绕该标准创建的，并且很快，每个框架都可以以某种方式通过WSGI使用。
- en: The biggest problem with WSGI, though, is its synchronous nature. More recently,
    the **Asynchronous Server Gateway Interface** (**ASGI**) has emerged as a successor
    to WSGI, allowing frameworks to operate asynchronously with the same seamless
    behavior as before. What are synchronous and asynchronous applications? We will
    cover that now.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，WSGI最大的问题是其同步特性。最近，**异步服务器网关接口**（**ASGI**）作为WSGI的继任者出现，允许框架以前所未有的无缝行为异步运行。那么什么是同步和异步应用程序呢？我们现在就来探讨这个问题。
- en: Workers, threads, and synchronicity
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作者、线程和同步性
- en: Thinking back to our simple application that handles requests, our model of
    the program is synchronous. This means that it accepts a piece of work, does that
    work, and returns the result, but while it's doing all of that, the program can't
    do anything else. Any other requests that come in when it's already working on
    something will have to wait.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们处理请求的简单应用程序，我们的程序模型是同步的。这意味着它接受一项工作，完成这项工作，并返回结果，但在它完成所有这些工作的同时，程序不能做其他任何事情。当它正在处理某项工作时，任何其他到达的请求都必须等待。
- en: There are several approaches to solving this problem, from using worker pools
    to early context switching environments, and more recently, full asynchronous
    Python.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以解决这个问题，从使用工作池到早期上下文切换环境，再到最近的全异步Python。
- en: A worker pool approach
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作池方法
- en: Accepting a new request is often very fast, and the bulk of the time is taken
    up by doing the work that has been requested. Reading a request that tells you
    "Give me a list of all our customers in Paris" takes much less time than putting
    the list together and sending it back.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接受一个新的请求通常非常快，而大部分时间都花在执行请求的工作上。读取一个请求告诉你“给我巴黎所有客户的列表”所花费的时间要比整理列表并发送它的时间少得多。
- en: When an application has lots of requests arriving, an effective strategy is
    to ensure that all the heavy lifting is done using other processes or threads.
    Starting a new thread can be slow, and starting a new process is even slower,
    and so a common technique is to start these workers early and keep them around,
    giving them new work to do as it arrives.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序收到大量请求时，一个有效的策略是确保所有重负载都由其他进程或线程来完成。启动一个新的线程可能很慢，启动一个新的进程甚至更慢，因此一个常见的做法是提前启动这些工作者，并保持它们处于就绪状态，以便在请求到达时分配新的工作。
- en: This is an old technique and a very effective one, but it does have limitations.
    As far as each worker is concerned, it receives work, and can't do anything else
    until it has finished. This means that if you have eight worker processes, you
    can only handle eight simultaneous requests. Your application could create more
    workers if it is running low, but there is always a bottleneck.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个古老的技术，非常有效，但它确实有限制。就每个工作者而言，它接收工作，直到完成工作之前不能做其他任何事情。这意味着如果你有八个工作进程，你只能处理八个并发请求。如果你的应用程序运行不足，它可以创建更多的工作者，但总会有瓶颈。
- en: There is also a practical limit to the number of processes and threads that
    an application can create, and swapping between them takes a lot of time that
    a responsive application can't always afford.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以创建的进程和线程的数量也有实际限制，而且在这些进程和线程之间切换需要大量时间，而响应式应用程序并不总是能负担得起。
- en: Being asynchronous
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步处理
- en: One important thing to realize is that computers interacting with each other
    is a slow process. Not from a human perspective, where a new message from a family
    member can appear on our phones in the blink of an eye, but from the perspective
    of the computer itself.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的事情要认识到的是，计算机之间的交互是一个缓慢的过程。并不是从人类的角度来看，因为一条来自家庭成员的新消息可以在我们眼中一闪而过，而是从计算机自身的角度来看。
- en: There are several charts available that suggest "*Latency Numbers Every Programmer
    Should Know*," originally by *Jeff Dean* and *Peter Norvig*. A version of it can
    be found at [https://colin-scott.github.io/personal_website/research/interactive_latency.html](https://colin-scott.github.io/personal_website/research/interactive_latency.html).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个图表可以说明“程序员应该知道的延迟数字”，最初由*Jeff Dean*和*Peter Norvig*编写。可以在[https://colin-scott.github.io/personal_website/research/interactive_latency.html](https://colin-scott.github.io/personal_website/research/interactive_latency.html)找到它的一个版本。
- en: There are a lot of numbers in these tables, but the important ones for us are
    the ones about network traffic. We can learn that reading about 1 MB from a computer's
    memory takes about 3,000 ns, but sending a packet over the network to a computer
    in the same building, and getting a response, can take about 500,000 ns. Talking
    to a computer on another continent can take hundreds of milliseconds.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这些表格中有许多数字，但对我们来说，重要的是关于网络流量的数字。我们可以了解到从计算机内存中读取大约1 MB需要约3,000 ns，但向同一建筑内的计算机发送数据包并获取响应可能需要约500,000
    ns。与另一个大陆上的计算机通信可能需要数百毫秒。
- en: 'To put this in human terms: it might take you a few seconds to remember that
    you need to ask someone a question. Sending them the question and hearing back
    that they''ve read it, whether or not you get the answer you need, might take
    two days.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 用人类的话来说：你可能需要几秒钟才能记住你需要问某人一个问题。发送问题并听到他们已经阅读了它，无论你是否得到了你需要的答案，可能需要两天。
- en: You don't really want to be sitting there doing nothing while waiting for an
    answer, but that's what a process usually does if it's synchronous. An asynchronous
    program is aware that some tasks it has been told to perform might take a long
    time, and so it can get on with some other work while it is waiting, without necessarily
    having to use other processes or threads.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你肯定不希望在那里无所事事地等待答案，但如果是同步的，进程通常会这样做。异步程序知道它被告知执行的一些任务可能需要很长时间，因此它可以在等待时继续进行其他工作，而不必一定使用其他进程或线程。
- en: Twisted, Tornado, Greenlets, and Gevent
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Twisted, Tornado, Greenlets, and Gevent
- en: For a long time, non-WSGI frameworks like **Twisted** and **Tornado** were the
    popular answers for concurrency when using Python, allowing developers to specify
    **callbacks** for many simultaneous requests. In a sequential program, you might
    call a function and wait for it to return a value to you. A callback is a technique
    where the calling part of the program doesn't wait but instead tells the function
    what it should do with the result it generates. Often this is another function
    that it should call.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 很长一段时间里，非WSGI框架如**Twisted**和**Tornado**在Python中使用时是处理并发的流行选择，允许开发者为许多并发请求指定**回调**。在顺序程序中，你可能会调用一个函数并等待它返回一个值给你。回调是一种技术，其中调用程序的部分不等待，而是告诉函数如何处理它生成的结果。通常这将是另一个它应该调用的函数。
- en: Another popular approach involved Greenlets and Gevent. The **Greenlet** project
    ([https://github.com/python-greenlet/greenlet](https://github.com/python-greenlet/greenlet))
    is a package based on the **Stackless** project, a particular CPython implementation,
    and provides *greenlets*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种流行的方法涉及Greenlets和Gevent。**Greenlet**项目（[https://github.com/python-greenlet/greenlet](https://github.com/python-greenlet/greenlet)）是一个基于**Stackless**项目的包，这是一个特定的CPython实现，并提供**greenlets**。
- en: Greenlets are *pseudo-threads* that are very cheap to instantiate, unlike real
    threads, and that can be used to call Python functions. Within those functions,
    you can *switch*, and give back the control to another function. The switching
    is done with an event loop and allows you to write an asynchronous application
    using a thread-like interface paradigm.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Greenlets是成本很低的**伪线程**，与真实线程不同，可以用来调用Python函数。在这些函数内部，你可以**切换**，并将控制权交回给另一个函数。切换是通过事件循环完成的，允许你使用类似线程的接口范式编写异步应用程序。
- en: However, switching from one greenlet to another has to be done explicitly, and
    the resulting code can quickly become messy and hard to understand. That's where
    Gevent can become very useful. The **Gevent** project ([http://www.gevent.org/](http://www.gevent.org/))
    is built on top of Greenlet and offers an implicit and automatic way of switching
    between greenlets, among many other things.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从一个greenlet切换到另一个greenlet必须显式进行，并且由此产生的代码可能会很快变得混乱且难以理解。这就是Gevent变得非常有用的地方。**Gevent**项目（[http://www.gevent.org/](http://www.gevent.org/））建立在Greenlet之上，提供了一种隐式且自动地在greenlet之间切换的方法，以及其他许多功能。
- en: With the experience from all of these options, Python now has `asyncio` as a
    core feature of the language since 3.5, and this is what we will be using in our
    code.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 基于所有这些选项的经验，Python从3.5版本开始将`asyncio`作为语言的核心功能，这就是我们将在代码中使用的内容。
- en: Asynchronous Python
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步Python
- en: When *Guido* *van Rossum* started to work on adding async features in Python
    3, part of the community pushed for a Gevent-like solution, because it made a
    lot of sense to write applications in a synchronous, sequential fashion rather
    than having to add explicit callbacks like in Tornado or Twisted.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *Guido* *van Rossum* 开始在 Python 3 中添加异步功能时，社区的一部分人推动了一个类似于 Gevent 的解决方案，因为在同步、顺序的方式编写应用程序比在
    Tornado 或 Twisted 中添加显式回调要合理得多。
- en: But Guido picked the explicit technique and experimented in a project called
    **Tulip** inspired by Twisted. Eventually, the `asyncio` module was born out of
    that side project and added into Python.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 但吉多选择了显式技术，并在一个名为 **Tulip** 的项目中进行了实验，该项目灵感来源于 Twisted。最终，`asyncio` 模块就是从这个辅助项目中诞生的，并被添加到
    Python 中。
- en: In hindsight, implementing an explicit event loop mechanism in Python instead
    of going the Gevent way makes a lot of sense. The way the Python core developers
    coded asyncio, and how they extended the language with the `async` and `await`
    keywords to implement coroutines, made asynchronous applications built with vanilla
    Python 3.5+ code look very elegant and close to synchronous programming.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 事后看来，在 Python 中实现显式的事件循环机制，而不是走 Gevent 的路，是非常有意义的。Python 核心开发者编写的 asyncio 方式，以及他们如何使用
    `async` 和 `await` 关键字扩展语言以实现协程，使得使用纯 Python 3.5+ 代码构建的异步应用程序看起来非常优雅，接近同步编程。
- en: Python 3 has introduced a full set of features and helpers in the asyncio package
    to build asynchronous applications; refer to [https://docs.python.org/3/library/asyncio.html](https://docs.python.org/3/library/asyncio.html).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3 在 asyncio 包中引入了一套完整的特性和辅助工具，用于构建异步应用程序；请参阅 [https://docs.python.org/3/library/asyncio.html](https://docs.python.org/3/library/asyncio.html)。
- en: '**aiohttp** ([http://aiohttp.readthedocs.io](http://aiohttp.readthedocs.io))
    is one of the most mature asyncio packages, and building the earlier "time" microservice
    with it would simply need these few lines:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**aiohttp** ([http://aiohttp.readthedocs.io](http://aiohttp.readthedocs.io))
    是最成熟的 asyncio 包之一，使用它构建早期的 "time" microservice 只需要这几行代码：'
- en: '[PRE1]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this small example, we're very close to how we would implement a synchronous
    app. The only hint we're using asynchronous code is the `async` keyword, which
    marks the `handle` function as being a coroutine.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个小型示例中，我们非常接近于如何实现一个同步应用程序。我们唯一使用的异步代码提示是 `async` 关键字，它将 `handle` 函数标记为协程。
- en: 'And this concept is what''s going to be used at every level of an async Python
    app going forward. Here''s another example using `aiopg`, a PostgreSQL library
    for asyncio from the project documentation:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念将是未来在异步 Python 应用程序每个级别上都要使用的内容。以下是一个使用 `aiopg` 的例子，这是一个来自项目文档的 asyncio
    PostgreSQL 库：
- en: '[PRE2]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With a few `async` and `await` prefixes, the function that performs an SQL query
    and sends back the result looks a lot like a synchronous function. We will explain
    more about this code in later chapters.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 几个带有 `async` 和 `await` 前缀的函数，执行 SQL 查询并返回结果的方式看起来非常像同步函数。我们将在后面的章节中详细解释这段代码。
- en: If you need to use a library that is not asynchronous in your code, to use it
    from your asynchronous code means that you will need to go through some extra
    and challenging work if you want the different libraries to work well together.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码需要使用非异步的库，要从异步代码中使用它，那么你需要做一些额外且具有挑战性的工作，以便让不同的库能够良好地协同工作。
- en: 'There are many great synchronous frameworks to build microservices with Python,
    like **Bottle**, **Pyramid** with **Cornice**, or **Flask**. We will be using
    one that is very similar to Flask, but is also asynchronous: **Quart**.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python 构建 microservices 的优秀同步框架有很多，比如 **Bottle**、**Pyramid** 与 **Cornice**
    或 **Flask**。我们将使用一个与 Flask 非常相似，但也是异步的框架：**Quart**。
- en: Keep in mind that whatever Python web framework you use, you should be able
    to transpose all the examples in this book. This is because most of the coding
    involved when building microservices is very close to plain Python, and the framework
    is mostly to route the requests and offer a few helpers.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，无论你使用哪种 Python Web 框架，你都应能够转换这本书中的所有示例。这是因为构建 microservices 时涉及的编码大部分非常接近纯
    Python，而框架主要是为了路由请求并提供一些辅助工具。
- en: Language performance
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语言性能
- en: 'In the previous sections, we went through the two different ways to write microservices:
    asynchronous versus synchronous, and whatever technique you use, the speed of
    Python directly impacts the performance of your microservice.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们介绍了编写 microservices 的两种不同方式：异步与同步，无论你使用哪种技术，Python 的速度都会直接影响你的 microservice
    的性能。
- en: Of course, everyone knows Python is slower than Java or Go, but execution speed
    is not always the top priority. A microservice is often a thin layer of code that
    sits most of its life waiting for some network responses from other services.
    Its core speed is usually less important than how fast your SQL queries will take
    to return from your Postgres server, because the latter will represent most of
    the time spent building the response.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，每个人都知道 Python 的执行速度比 Java 或 Go 慢，但执行速度并不总是首要考虑的因素。微服务通常是一层薄薄的代码，大部分时间都在等待来自其他服务的网络响应。它的核心速度通常不如你的
    SQL 查询从 Postgres 服务器返回的速度重要，因为后者将代表构建响应的大部分时间。
- en: It's also important to remember that how long you spend developing the software
    can be just as important. If your services are rapidly changing, or a new developer
    joins and has to understand the code, it is important to have code that is easy
    to understand, develop, and deploy.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 还重要的是要记住，你花费在软件开发上的时间可能同样重要。如果你的服务正在快速变化，或者有新的开发者加入并需要理解代码，那么拥有易于理解、开发和部署的代码就很重要。
- en: But wanting an application that's as fast as possible is legitimate.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 但希望应用程序尽可能快是合理的。
- en: One controversial topic in the Python community around speeding up the language
    is how the **Global Interpreter Lock** (**GIL**) can affect performance, because
    multi-threaded applications cannot use several processes.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 社区中关于加快语言速度的一个有争议的话题是全局解释器锁（**GIL**）如何影响性能，因为多线程应用程序无法使用多个进程。
- en: The GIL has good reasons to exist. It protects non-thread-safe parts of the
    CPython interpreter and exists in other languages like Ruby. And all attempts
    to remove it so far have failed to produce a faster CPython implementation.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: GIL 存在有其合理的原因。它保护了 CPython 解释器中非线程安全的部分，并在像 Ruby 这样的其他语言中存在。迄今为止，所有尝试移除它的尝试都未能产生更快的
    CPython 实现。
- en: For microservices, besides preventing the usage of multiple cores in the same
    process, the GIL will slightly degrade performance under high load because of
    the system calls overhead introduced by the mutex.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 对于微服务来说，除了防止在同一个进程中使用多个核心之外，由于互斥锁引入的系统调用开销，GIL 还会在高负载下略微降低性能。
- en: 'However, all the scrutiny around the GIL has been beneficial: work has been
    done in the past to reduce GIL contention in the interpreter, and in some areas,
    Python''s performance has improved a lot. Changes in Python 3.8 to introduce subinterpreters
    and multiple locks have also helped with some areas.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，围绕 GIL 的所有审查都是有益的：过去已经做了工作来减少解释器中的 GIL 竞争，在某些领域，Python 的性能有了很大的提升。Python
    3.8 中引入子解释器和多个锁的更改也帮助了一些领域。
- en: Bear in mind that even if the core team removes all the GIL performance issues,
    Python is an interpreted and garbage collected language and suffers performance
    penalties for those properties.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，即使核心团队消除了所有 GIL 性能问题，Python 仍然是一种解释和垃圾回收语言，并因这些特性而遭受性能损失。
- en: 'Python provides the `dis` module if you are interested in seeing how the interpreter
    decomposes a function. In the following example, the interpreter will decompose
    a simple function that yields incremented values from a sequence in no less than
    22 steps:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣，Python 提供了 `dis` 模块来查看解释器如何分解一个函数。在下面的例子中，解释器将分解一个简单的函数，该函数从序列中产生递增的值，至少需要
    22 步：
- en: '[PRE3]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A similar function written in a statically compiled language will dramatically
    reduce the number of operations required to produce the same result. There are
    ways to speed up Python execution, though.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 用静态编译语言编写的类似功能将大大减少产生相同结果所需的操作数量。尽管如此，也有方法可以加快 Python 的执行速度。
- en: One is to write a part of your code in compiled code by building extensions
    in C, Rust, or another compiled language, or using a static extension of the language
    like **Cython** ([http://cython.org/](http://cython.org/)), but that makes your
    code more complicated.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是通过在 C、Rust 或其他编译语言中构建扩展，或者使用像 **Cython** ([http://cython.org/](http://cython.org/))
    这样的静态扩展语言来编写代码的一部分，但这会使你的代码更加复杂。
- en: Another solution is by simply running your application using the **PyPy** interpreter
    ([http://pypy.org/](http://pypy.org/)). This can give noticeable performance improvements
    just by swapping out the Python interpreter.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案是使用 **PyPy** 解释器 ([http://pypy.org/](http://pypy.org/)) 运行你的应用程序。这可以通过简单地替换
    Python 解释器来带来明显的性能提升。
- en: PyPy implements a **Just-In-Time** (**JIT**) compiler. This compiler directly
    replaces, at runtime, pieces of Python with machine code that can be directly
    used by the CPU. The whole trick for the JIT compiler is to detect in real time,
    ahead of the execution, when and how to do it.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: PyPy实现了一个**即时编译器**（**JIT**）。这个编译器在运行时直接用机器代码替换Python代码的一部分，这些机器代码可以直接由CPU使用。JIT编译器的整个技巧是在执行之前实时检测何时以及如何进行替换。
- en: Even if PyPy is always a few Python versions behind CPython, it has reached
    a point where you can use it in production, and its performance can be quite amazing.
    In one of our projects at Mozilla that needs fast execution, the PyPy version
    was almost as fast as the Go version, and we decided to use Python there instead.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 即使PyPy始终比CPython落后几个版本，但它已经达到了可以在生产中使用，并且其性能可以非常惊人的程度。在我们的Mozilla项目中，有一个需要快速执行的项目，PyPy版本几乎与Go版本一样快，我们决定在那里使用Python。
- en: The Pypy Speed Center website is a great place to look at how PyPy compares
    to CPython ( [http://speed.pypy.org/](http://speed.pypy.org/)).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Pypy Speed Center网站是一个很好的地方，可以查看PyPy与CPython（[http://speed.pypy.org/](http://speed.pypy.org/)）的比较。
- en: However, if your program uses C extensions or has any other compiled dependencies,
    you will need to recompile them for PyPy, and that extra work must be balanced
    against the speed improvements, especially if you are depending on another project
    or other developers to maintain the extensions you are using.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你的程序使用C扩展或具有任何其他编译依赖项，你将需要为PyPy重新编译它们，并且必须权衡额外的工作与速度改进，尤其是如果你依赖于其他项目或其他开发人员维护你使用的扩展。
- en: But if you build your microservice with a standard set of libraries, chances
    are that it will work out of the box with the PyPy interpreter, so that's worth
    a try. In any case, for most projects, the benefits of Python and its ecosystem
    largely surpass the performance issues described in this section, because the
    overhead in a microservice is rarely a problem. And if performance is a problem,
    the microservice approach allows you to rewrite and scale performance-critical
    components without affecting the rest of the system.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你使用标准库集构建你的微服务，那么它很可能与PyPy解释器无缝工作，所以值得一试。在任何情况下，对于大多数项目来说，Python及其生态系统的优势在很大程度上超过了本节中描述的性能问题，因为微服务中的开销很少是问题。如果性能是问题，微服务方法允许你重写和扩展性能关键组件，而不会影响系统的其他部分。
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've compared the monolithic and microservice approaches to
    building web applications, and it became apparent that there's not a binary choice
    where you have to pick one model on day one and stick with it.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们比较了构建Web应用的单体和微服务方法，很明显，你不必在第一天就选择一个模型并坚持下去，这不是一个二选一的选择。
- en: You should see microservices as an improvement of an application that started
    its life as a monolith. As the project matures, parts of the service logic should
    migrate into microservices. It is a useful approach, as we've learned in this
    chapter, but it should be done carefully to avoid falling into some common traps.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该将微服务视为一个从单体应用开始的生命周期中的应用程序的改进。随着项目的成熟，服务逻辑的一部分应该迁移到微服务中。正如我们在本章中学到的，这是一个有用的方法，但应该谨慎进行，以避免陷入一些常见的陷阱。
- en: Another important lesson is that Python is considered to be one of the best
    languages to write web applications and, therefore, microservices. For the same
    reasons, it's a language of choice in other areas, and also because it provides
    many mature frameworks and packages to do the work.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的教训是，Python被认为是最适合编写Web应用和微服务的语言之一。因此，它也是其他领域的选择语言，并且因为它提供了许多成熟的框架和包来完成工作。
- en: Python can be a slow language, and that can be a problem in very specific cases.
    Knowing what makes it slow, and the different solutions to avoid this issue, will
    usually be enough to work through any trouble.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Python可能是一种慢速语言，在非常具体的情况下可能会成为问题。了解是什么让它变慢，以及避免这个问题的不同解决方案，通常足以解决任何麻烦。
- en: We've rapidly looked at several frameworks, both synchronous and asynchronous,
    and for the rest of the book, we'll be using Quart. The next chapter will introduce
    this fantastic framework.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们快速地查看了几种框架，包括同步和异步的，在本书的其余部分，我们将使用Quart。下一章将介绍这个**出色的框架**。
