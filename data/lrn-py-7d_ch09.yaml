- en: File Handling and Exceptions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件处理和异常
- en: So far you have seen the various Python programs, which took the input from
    the keyboard and delivered the output on the screen. In this chapter, you will,
    however, learn to take input from files and write result to the files. Also, we
    will go through the concept of exceptions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了各种Python程序，它们从键盘获取输入并在屏幕上显示输出。然而，在本章中，你将学习如何从文件中获取输入并将结果写入文件。我们还将讨论异常的概念。
- en: Reading text from a file
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文件中读取文本
- en: 'In order to read and write into a file, we will use the `open()` built-in function
    to open the file. The `open()` function creates an `file_object` object. What
    is an object?  You will understand in  [Chapter 11](lrn-py-7d_ch11.html), *Class
    and Objects*.  The Syntax is given as:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了读取和写入文件，我们将使用内置的`open()`函数来打开文件。`open()`函数创建了一个`file_object`对象。什么是对象？你将在第11章[类和对象](lrn-py-7d_ch11.html)中了解。语法如下：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first argument,`file_name`, specifies the filename that you want to open.
    The second argument, `access_mode`, determines in which mode the file has to be
    opened, that is, read, write, append, and so on.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数`file_name`指定了你要打开的文件名。第二个参数`access_mode`确定文件必须以哪种模式打开，即读取、写入、追加等。
- en: The read() method
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: read()方法
- en: Now we will read a file by a program. The access mode for reading is `r`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将通过程序读取一个文件。读取的访问模式是`r`。
- en: 'Let''s take the sample of a text file containing famous quotes:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以包含著名引言的文本文件为例：
- en: '![](img/file_figure1.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](img/file_figure1.jpg)'
- en: Sample file
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 样本文件
- en: I have saved the preceding file with the name `sample1.txt`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将前面的文件保存为`sample1.txt`。
- en: 'Let''s write a `readfile.py` program to read the earlier file:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个`readfile.py`程序来读取前面的文件：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the given code, first we created a `file_input` file object, then we called
    `file_input.read()` to read the file content. After reading, the `file_input`
    file object is closed by `file_input.close()`.  To be sure the sample file and
    the code `readfile.py` must be in the same directory. Let''s check the output:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定的代码中，我们首先创建了一个`file_input`文件对象，然后调用`file_input.read()`来读取文件内容。读取后，通过`file_input.close()`关闭`file_input`文件对象。为了确保样本文件和代码`readfile.py`在同一个目录下，让我们检查输出：
- en: '![](img/file_figure2.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/file_figure2.jpg)'
- en: Reading a file
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 读取文件
- en: The preceding code is running successfully. In order to read character from
    the file, you can pass the argument to the `read()` function, for example, `read(5)`
    would read the first five characters of the file.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码正在成功运行。为了从文件中读取字符，你可以将参数传递给`read()`函数，例如，`read(5)`将读取文件的前五个字符。
- en: 'Let''s understand the sample code `readcount1.py`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解样本代码`readcount1.py`：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s analyze the output:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析输出：
- en: '![](img/file_figure3.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/file_figure3.jpg)'
- en: Output of code read
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 读取代码的输出
- en: The second line of code reads the first `20` characters of the file, the third
    line reads the next `15` characters, and the fourth line reads the next `10` characters
    of the file.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第二行读取文件的前`20`个字符，第三行读取接下来的`15`个字符，第四行读取接下来的`10`个字符。
- en: The readline() method
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: readline()方法
- en: In order to read the file line by line, use `readline()`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了逐行读取文件，使用`readline()`。
- en: 'Let''s see the sample code `readline1.py`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看样本代码`readline1.py`：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s see the output of code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码的输出：
- en: '![](img/file_figure4.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/file_figure4.jpg)'
- en: 'In code, we have printed three lines. What happens, if you specify `count`
    in `readline(count)`. See the code `readlinecount.py`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们打印了三行。如果你在`readline(count)`中指定`count`会发生什么？看看代码`readlinecount.py`：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s see the output:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看输出：
- en: '![](img/file_figure5.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/file_figure5.jpg)'
- en: In the `file_input.readline(100)` syntax prints `100` characters of the first
    line. But the first line contains only 48 characters. The syntax file`_input.readline(20)`
    prints the `20` characters from the second line of `sample1.txt`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在`file_input.readline(100)`语法中打印了第一行的`100`个字符。但第一行只有48个字符。语法`file_input.readline(20)`从`sample1.txt`的第二行打印了`20`个字符。
- en: The readlines() method
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: readlines()方法
- en: Consider the situation where you want to make a list of lines of a file; in
    that case, the `readlines()` method allows you to do that.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑你想制作一个文件行列表的情况；在这种情况下，`readlines()`方法允许你这样做。
- en: 'See the code in `readlines1.py`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 看看`readlines1.py`中的代码：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s check the output of the code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查代码的输出：
- en: '![](img/file_figure6.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/file_figure6.jpg)'
- en: In the preceding screenshot, you can easily see the list of lines.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，你可以轻松地看到行列表。
- en: 'For reading purposes, you can loop over the file object. Let''s analyze the
    code in `readfileforloop.py`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于读取目的，你可以遍历文件对象。让我们分析`readfileforloop.py`中的代码：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is the output:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '![](img/file_figure7.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![文件图7](img/file_figure7.jpg)'
- en: You can see all the lines. This is memory efficient, fast, and leads to simple
    code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到所有行。这是内存高效、快速且代码简单的。
- en: Exercise
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Let's do an exercise.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一个练习。
- en: See the given file, `batman.txt`, containing the quotes from famous Hollywood
    movies.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 看看给定的文件`batman.txt`，其中包含著名好莱坞电影的引言。
- en: 'Our aim is to write a program to find a given word from the file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目的是编写一个程序从文件中查找一个特定的单词：
- en: '![](img/file_figure_burce.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![文件图_burce.jpg](img/file_figure_burce.jpg)'
- en: Screenshot of batman.txt
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: batman.txt的截图
- en: Let's write a program to find the particular word from the file. We are making
    the assumption that the program should be case insensitive, which means it does
    not matter whether the characters are in uppercase or lowercase.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个程序从文件中查找特定的单词。我们假设程序应该是大小写不敏感的，这意味着字符是大写还是小写无关紧要。
- en: 'See the code in `findword.py`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 看看`findword.py`中的代码：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The program is very easy to understand. Let''s see the output of the code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 程序非常容易理解。让我们看看代码的输出结果：
- en: '![](img/file_figure8.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![文件图8](img/file_figure8.jpg)'
- en: Output of findword.py
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: findword.py的输出
- en: The program `findword.py` is working fine.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`findword.py`程序运行正常。'
- en: Writing text to a file
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向文件写入文本
- en: In this section, we will learn how to write a new file using Python.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用Python编写新文件。
- en: This time we'll use the write mode `'w'` in `open()`. The `'w'` mode creates
    a new file. If the file already exists, then the file would be overwritten.  We
    will use the `write()` function.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们将在`open()`中使用写模式`'w'`。`'w'`模式创建一个新文件。如果文件已存在，则文件会被覆盖。我们将使用`write()`函数。
- en: 'Let''s discuss the code in `filewrite1.py`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论`filewrite1.py`中的代码：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can see that I have written the famous WWE star John Cena's quotes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我已经写下了著名WWE明星约翰·塞纳的引言。
- en: 'Let''s see the output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看输出结果：
- en: '![](img/file_figure9.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![文件图9](img/file_figure9.jpg)'
- en: Output of code filewrite.py
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: code filewrite.py的输出
- en: 'We wrote lines one by one by adding a new line character `n`.  You can supply
    all of them in one go as shown here:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过添加一个新行字符`n`逐行写入。你可以一次性提供所有这些，如下所示：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Next, I will use the `writelines()` function. This method writes a Python list
    of strings to a file.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将使用`writelines()`函数。此方法将Python字符串列表写入文件。
- en: 'Let''s see the code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding code, Python list, `list1`, contains some motivational lines,
    and we want to save that in a file. We could use the `writelines()` function for
    our requirement. Let''s see the output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，Python列表`list1`包含一些励志的语句，我们想要将它们保存到文件中。我们可以使用`writelines()`函数来满足我们的需求。让我们看看输出结果：
- en: '![](img/file_figure10.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![文件图10](img/file_figure10.jpg)'
- en: Output of filewriteline.py
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: filewriteline.py的输出
- en: Every time you run the program, the file gets overwritten, means a new file
    would be created. Consider the situation where you want to add content to the
    previous file; you can use access mode `'a'`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行程序，文件都会被覆盖，意味着会创建一个新的文件。考虑你想向之前的文件添加内容的情况；你可以使用访问模式`'a'`。
- en: Let’s use the preceding program `filewritea.py` with access mode `'a'`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用前面程序`filewritea.py`的访问模式`'a'`。
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s see the output:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看输出结果：
- en: '![](img/file_figure11.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![文件图11](img/file_figure11.jpg)'
- en: Output of filewritea.py
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: filewritea.py的输出
- en: 'Let''s run the program with different lines:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用不同的行运行程序：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s see the output:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看输出结果：
- en: '![](img/file_figure12.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![文件图12](img/file_figure12.jpg)'
- en: Output of program filewritea1.py
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: program filewritea1.py的输出
- en: The `newmotivation.txt` file has been successfully appended.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`newmotivation.txt`文件已成功追加。'
- en: There are other access modes too.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他访问模式。
- en: Examples
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例
- en: The `"r+"` opens a file for reading and writing. This mode places the pointer
    at the beginning of the file.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`"r+"`模式打开一个文件用于读写。此模式将指针放置在文件的开头。'
- en: The `"w+"` opens a file for reading and writing. If the file doesn't exist,
    then a new file is created.  If the file exists, then the file is overwritten.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`"w+"`模式打开一个文件用于读写。如果文件不存在，则创建一个新文件。如果文件存在，则文件会被覆盖。'
- en: The `"a+"` opens a file for appending and reading. If the file doesn't exist,
    it creates a new file. If the file already exists, the pointer is placed at the
    end of the file.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`"a+"`模式打开一个文件用于追加和读取。如果文件不存在，则创建一个新文件。如果文件已存在，则指针放置在文件末尾。'
- en: Pickling
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化
- en: 'Text files are convenient to use because you can read, write, and append them
    with any text editor, but they are limited to storing a series of characters.
    Sometimes you may want to store complex information such as list and dictionary.
    Here we would use Python''s `pickle` module. The `pickle` module is used to store
    complex data such as list and dictionary. Let''s discuss with the help of an example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 文本文件使用方便，因为你可以用任何文本编辑器读取、写入和追加它们，但它们仅限于存储一系列字符。有时你可能想存储复杂的信息，如列表和字典。在这里，我们将使用
    Python 的 `pickle` 模块。`pickle` 模块用于存储复杂的数据，如列表和字典。让我们通过一个例子来讨论：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The program seems complex to understand. Let's understand the code line by line.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序看起来难以理解。让我们逐行理解代码。
- en: The `name` and `skill` are two lists which we have to store.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`name` 和 `skill` 是两个我们需要存储的列表。'
- en: The `pickle_file = open("emp1.dat","w")` syntax creates a `pickle_file` object
    in write mode as we have done earlier.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`pickle_file = open("emp1.dat","w")` 语法以写入模式创建一个 `pickle_file` 对象，就像我们之前做的那样。'
- en: 'The `pickle.dump()` is used to dump and store the lists `name` and `skill` in
    the `pick.dat` file. The `pickle.dump()` requires two arguments, first the data
    (like list) to `pickle` and second the file to store it. The `pickle_file.close()`
    finally close the file. Let''s see the output:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`pickle.dump()` 用于将列表 `name` 和 `skill` 导出到 `pick.dat` 文件中。`pickle.dump()` 需要两个参数，第一个是要
    `pickle` 的数据（如列表），第二个是存储它的文件。`pickle_file.close()` 最终关闭文件。让我们看看输出：'
- en: '![](img/file_figure13.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file_figure13.jpg)'
- en: Output of pickle file
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: pickle 文件输出
- en: Now you must have an idea how to store complex data.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该有了如何存储复杂数据的概念。
- en: Unpickling
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反序列化
- en: Unpickling means retrieving the data from the `pickle` file. In the previous
    topic, you learned how to store `(list, dictionary)` data in the `pickle` file;
    now it's time to retrieve the stored data. In order to perform unpickling, we
    will use `pickle.load()`. The `pickle.load()` takes one file object as an argument.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 反序列化意味着从 `pickle` 文件中检索数据。在前面的话题中，你学习了如何将 `(list, dictionary)` 数据存储在 `pickle`
    文件中；现在是时候检索存储的数据了。为了执行反序列化，我们将使用 `pickle.load()`。`pickle.load()` 接收一个文件对象作为参数。
- en: 'Let''s see the program:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看程序：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let's understand the program line by line. The `pickle_file = open("emp1.dat",'r')`
    syntax creates a file object in read mode. The `name_list = pickle.load(pickle_file)`
    syntax reads the first pickled object in the file and unpickles it to produce
    the `['mohit', 'bhaskar', 'manish']` list. Similarly,  `skill_list =pickle.load(pickle_file)`
    reads the second pickled object in the file and unpickles it to produce the `['Python',
    'Python', 'Java']` list.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行理解程序。`pickle_file = open("emp1.dat",'r')` 语法以读取模式创建一个文件对象。`name_list =
    pickle.load(pickle_file)` 语法读取文件中的第一个 pickled 对象并将其反序列化为产生 `['mohit', 'bhaskar',
    'manish']` 列表。同样，`skill_list =pickle.load(pickle_file)` 读取文件中的第二个 pickled 对象并将其反序列化为产生
    `['Python', 'Python', 'Java']` 列表。
- en: 'Let''s see the output to clear up any confusion:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看输出以消除任何混淆：
- en: '![](img/file_figure14.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file_figure14.jpg)'
- en: Output of filepickle2.py
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: filepickle2.py 文件输出
- en: In `pickle,` you can not access the data randomly. `Pickle` stores and retrieves
    the list sequentially.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `pickle` 中，你不能随机访问数据。`Pickle` 按顺序存储和检索列表。
- en: The data you dump in the `pickle` file first, would be retrieved first. This
    is the limitation of the `pickle` file.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先在 `pickle` 文件中导出的数据将首先被检索。这是 `pickle` 文件的限制。
- en: Given the limitation of the `pickle` file, you can't access the list randomly,
    but you can use the dictionary with lists to retrieve the lists randomly.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `pickle` 文件的限制，你不能随机访问列表，但你可以使用包含列表的字典来随机检索列表。
- en: 'Consider the following example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: By dumping this dictionary, you can access any list randomly.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导出这个字典，你可以随机访问任何列表。
- en: 'Let''s see the program:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看程序：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding program, we have dumped a dictionary referred by name `leapx_team`.
    Run the preceding program and check the directory. A file named `emp2.dat` must
    be formed.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，我们导出了一个名为 `leapx_team` 的字典。运行前面的程序并检查目录。必须形成一个名为 `emp2.dat` 的文件。
- en: Let's retrieve the content of the `emp2.dat` file.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检索 `emp2.dat` 文件的内容。
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding program, `all_data` is the dictionary and we are accessing
    the values of the dictionary by keys.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，`all_data` 是字典，我们通过键访问字典的值。
- en: 'Let''s see the output:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看输出：
- en: '![](img/file_figure15.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file_figure15.jpg)'
- en: We are accessing the list randomly.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在随机访问列表。
- en: The `pickle` module is written in Python, while the `cPickle` module is written
    in C language, which is faster than the `pickle` module.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`pickle` 模块是用 Python 编写的，而 `cPickle` 模块是用 C 语言编写的，它比 `pickle` 模块运行更快。'
- en: 'Let''s see the example code in `filecpickle1.py`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `filecpickle1.py` 中的示例代码：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Exceptions
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常
- en: Consider you have created a program `calc.py` and that it is running successfully.
    After some time, a third person edits the program `calc.py`. While executing the
    program, the interpreter throws some error. Due to the error, the whole program
    stops working. How can we avoid this situation, where, if any error occurs, then
    the whole program execution does not suffer?
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你创建了一个程序 `calc.py`，并且它正在成功运行。过了一段时间，第三方人员编辑了程序 `calc.py`。在执行程序时，解释器抛出了一些错误。由于错误，整个程序停止工作。我们如何避免这种情况，即如果发生任何错误，整个程序执行不会受到影响？
- en: 'The answer is simple: just use exception handling. Errors detected during execution
    are called exceptions. In the next section, you will see the example in detail,
    where we will see how to use exception handling with the `try...except` clause.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 答案很简单：只需使用异常处理。在执行过程中检测到的错误称为异常。在下一节中，你将看到详细的示例，我们将看到如何使用 `try...except` 子句进行异常处理。
- en: The try statement with an except clause
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有 `except` 子句的 `try` 语句
- en: In this section, you will see how to use the `try...except` block to handle
    the exceptions. Let's understand the usage of the `try...except` block with examples.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将看到如何使用 `try...except` 块来处理异常。让我们通过示例来理解 `try...except` 块的用法。
- en: 'Consider the following program:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下程序：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Consider that a third person edits the program `calc.py`; the full program
    is shown here:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 假设第三方人员编辑了程序 `calc.py`；完整的程序如下所示：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s run the program:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行程序：
- en: '![](img/file_figure16.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/file_figure16.jpg)'
- en: Output of calc.py
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`calc.py` 的输出'
- en: In the preceding output, the program is showing an error because we performed
    division by `0`. Due to one error, the whole program stop. In order to deal with
    the situation, we use the `try and except` blocks.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，程序显示了一个错误，因为我们执行了除以 `0` 的操作。由于一个错误，整个程序停止。为了处理这种情况，我们使用 `try and except`
    块。
- en: 'Let''s see the program `calc.py`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看程序 `calc.py`：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s run it again:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行它：
- en: '![](img/file_figure_calc.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/file_figure_calc.jpg)'
- en: Output of calc.py
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`calc.py` 的输出'
- en: Now the `sum1()` function is giving the output `Error occurred in divide function`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `sum1()` 函数输出为“`divide` 函数中发生错误”。
- en: 'Let''s discuss `try...except` in detail. First see the syntax:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论 `try...except`。首先看看语法：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the `calc.py` program, a call to divide raises an exception; the exception
    is caught and the crafted message is displayed: `Error in divide function`. If
    no exception is raised, the program skips the except clause, continuing with the
    rest of the code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `calc.py` 程序中，调用 `divide` 函数会引发异常；异常被捕获并显示了一个定制的消息：“`divide` 函数错误”。如果没有引发异常，程序将跳过
    `except` 子句，继续执行其余代码。
- en: Multiple exception blocks
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个异常块
- en: 'In previous example, you learned how to catch the exceptions. But you don''t
    know the type of error that occurred. Every exception has a certain type. The
    types in the example are `ZeroDivisionError`, `NameError`, and `TypeError.` Type
    is written in the error message. Consider a different program `divide1.py`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，你学习了如何捕获异常。但你不知道发生了什么类型的错误。每个异常都有一定的类型。示例中的类型有 `ZeroDivisionError`、`NameError`
    和 `TypeError`。类型在错误消息中写出。考虑一个不同的程序 `divide1.py`：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the given program, when we give the input from the keyboard, the input string
    will be converted into int type.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定的程序中，当我们从键盘输入时，输入的字符串将被转换为 int 类型。
- en: 'Let''s run program with different inputs:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用不同的输入运行程序：
- en: '![](img/file_figure17.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/file_figure17.jpg)'
- en: Output of program divied.py
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`divied.py` 程序的输出'
- en: When we give the input `5`, then the program returns `9`. When we supply a string
    instead of a number, then the interpreter returns a message with a  `ValueError`
    error as highlighted under red line. When number `0` is supplied, then `ZeroDivisionError`
    is returned.  By using multiple exception blocks, you can handle both the exceptions.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们输入 `5` 时，程序返回 `9`。当我们提供一个字符串而不是数字时，解释器会返回一个带有 `ValueError` 错误的消息，如红色下划线所示。当我们提供数字
    `0` 时，则返回 `ZeroDivisionError`。通过使用多个异常块，你可以处理这两种异常。
- en: 'Refer to the program `divide1.py`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考程序 `divide1.py`：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the preceding program, multiple exceptions have been handled and a crafted
    message has been displayed. Let''s see the output:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，已经处理了多个异常，并显示了一个定制的消息。让我们看看输出：
- en: '![](img/file_figure18.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/file_figure18.jpg)'
- en: Output of program divide1.py
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`divide1.py`程序的输出'
- en: In the preceding output, customized messages have been displayed so that the
    user can understand his mistake.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，显示了自定义的消息，以便用户可以理解他的错误。
- en: The try...finally statement
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: try...finally语句
- en: In a situation where you are completely sure that a certain block of code will
    be executed whether the program throws exceptions or not, `try...finally` is useful.
    Consider the situation when you open a file and read the input, but for some reason
    the program throws an exception and the file you want is closed whether the exception
    occurs or not, then `try...finally` will solve the problem.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在你完全确信某个代码块无论程序是否抛出异常都会被执行的情况下，`try...finally`是有用的。考虑当你打开一个文件并读取输入时的情况，但由于某种原因程序抛出了异常，而你想要的文件无论是否发生异常都需要关闭，那么`try...finally`将解决这个问题。
- en: 'The syntax is as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 语法如下：
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The order of the statement should be:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 语句的顺序应该是：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s discuss the code in `finally1.py`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论`finally1.py`中的代码：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding code, we used `try`, `except`, `else`, and `finally` blocks.
    Let''s discuss the functionality by executing the code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了`try`、`except`、`else`和`finally`块。让我们通过执行代码来讨论其功能：
- en: '![](img/file_figure19.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file_figure19.jpg)'
- en: Output of finally1.py
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally1.py`的输出'
- en: In the preceding output, in the first run, `10` has been provided as the input
    and  `try`, `else`, and `finally` blocks have been executed. In the second run,
    a string `Mohit` has been supplied. Due to error in type conversion `except` and
    `finally` blocks have been executed.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，第一次运行时提供了输入`10`，并且`try`、`else`和`finally`块被执行。在第二次运行中，提供了字符串`Mohit`。由于类型转换错误，`except`和`finally`块被执行。
- en: With this you have seen the importance of the `finally` statement.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个，你已经看到了`finally`语句的重要性。
- en: The exception argument
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常参数
- en: 'When you write a program, it is very mundane and tedious to write each and
    every exception type. Instead of writing each exception, you could use just one
    line. See the code in `exceptiontype.py`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写程序时，逐个编写每个异常类型是非常枯燥和乏味的。你不需要逐个编写异常，只需一行即可。看看`exceptiontype.py`中的代码：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The preceding code catches the exception as `e` and `type(e)` displays its
    exception type. Let''s see the output. In the code, `e` is the argument of the
    exception: the contents referred by the argument vary by exception:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码将异常捕获为`e`，`type(e)`显示了其异常类型。让我们看看输出。在代码中，`e`是异常的参数：参数的内容因异常而异：
- en: '![](img/file_figure20.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file_figure20.jpg)'
- en: Output of program exceptiontype.py
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`exceptiontype.py`程序的输出'
- en: You can see that we run the program three times. The first time we passed the
    value `10`. It runs successfully. In the second run, we passed string `'mohit'`,
    which is when the interpreter handled the exception and showed the exception message
    and its type. In third run, we passed `0`, which is when interpreter showed the
    corresponding exception message and its type.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们运行了程序三次。第一次我们传递了值`10`。它运行成功。在第二次运行中，我们传递了字符串`'mohit'`，这是解释器处理异常并显示异常信息和其类型的时候。在第三次运行中，我们传递了`0`，这是解释器显示了相应的异常信息和其类型的时候。
- en: Raising exceptions
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抛出异常
- en: The `raise` statement allows the programmer to trigger specific exceptions explicitly.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`raise`语句允许程序员显式地触发特定的异常。'
- en: 'Consider the following example:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE29]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the preceding example, the specific exception `IOError` has been raised
    by the `raise` keyword:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，通过`raise`关键字抛出了特定的异常`IOError`：
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding example, a string `"Hi there"` argument has been passed, which
    is printed with the exception.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，传递了一个字符串`"Hi there"`参数，它被打印出来，并伴随着异常。
- en: User-defined exceptions
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户定义的异常
- en: In this section, we will use classes, as you have not read the [Chapter 11](lrn-py-7d_ch11.html),
    *Class and Objects*, you can skip the topic and get back once you complete the
    class and objects.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用类，因为你还没有阅读[第11章](lrn-py-7d_ch11.html)，*类和对象*，你可以跳过这个主题，完成类和对象的学习后再回来。
- en: Python allows you to define your own exceptions. Exceptions should be inherited
    from the `Exception` class.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Python 允许你定义自己的异常。异常应该继承自`Exception`类。
- en: 'Let''s discuss with an example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来讨论：
- en: '[PRE31]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Do not be afraid to see the full code.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 不要害怕查看完整的代码。
- en: 'Let''s see the class part:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看类部分：
- en: '[PRE32]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The preceding code defined the `MyException` class, which inherits the base
    class `Exception`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码定义了`MyException`类，它继承自基类`Exception`。
- en: In this example, the `default __init__()` exception has been overridden.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`default __init__()` 异常已被覆盖。
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The preceding code raises the user-defined exception if you pass the value `2`.
    The raised exception is handled by the `except` block.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你传递的值是 `2`，前面的代码会引发用户定义的异常。这个异常由 `except` 块处理。
- en: 'See the output of the code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 查看代码的输出：
- en: '![](img/file_figure21.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file_figure21.jpg)'
- en: Output of code userdefined.py
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 程序 userdefined.py 的输出
- en: In the preceding code, if you pass the value `2`, then it gives a user-defined
    custom error. If you pass a number other than `2`, then no error occurs. Let's
    make some changes in the code to understand the example clearly.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，如果你传递的值是 `2`，则会引发一个用户定义的自定义错误。如果你传递的不是 `2` 的数字，则不会发生错误。让我们对代码进行一些修改，以便更清楚地理解这个例子。
- en: 'See the program `userdefined2.py`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 查看程序 `userdefined2.py`：
- en: '[PRE34]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Just the `except` block has been changed. Now, the `except` block is only handling
    `IOError` not `MyException`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 只修改了 `except` 块。现在，`except` 块只处理 `IOError` 而不是 `MyException`。
- en: 'Let''s see the output:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看输出：
- en: '![](img/file_figure22.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file_figure22.jpg)'
- en: Output of program userdefind2.py
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 程序 userdefind2.py 的输出
- en: When you pass a value other than `2`, then the `MyException` exception is raised
    and the except block does not handle the raised exception. The interpreter shows
    the error with an exception type.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当你传递的值不是 `2` 时，则会引发 `MyException` 异常，而 `except` 块不会处理这个引发的异常。解释器会显示带有异常类型的错误。
- en: 'If you do not want to print an exception message, you can use pass the statement `except:
    pass`.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你不想打印异常信息，可以使用 `except: pass` 语句。'
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you learned how to read data from text files. You learned how
    to write data to the text files. Text files are not a good choice to store complex
    data such as list and dictionary. In order to store complex data, we have used
    `pickle` files. After that, you learned to handle exceptions. Without handling
    exceptions you cannot write standard code. In exceptions, you learned how to handle
    multiple exceptions and how to print its exception type. In end of the chapter, you
    learned how to create your own exception.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何从文本文件中读取数据。你学习了如何将数据写入文本文件。文本文件不是存储复杂数据（如列表和字典）的好选择。为了存储复杂数据，我们使用了
    `pickle` 文件。之后，你学习了如何处理异常。不处理异常，你无法编写标准代码。在异常处理中，你学习了如何处理多个异常以及如何打印其异常类型。在章节的结尾，你学习了如何创建自己的异常。
