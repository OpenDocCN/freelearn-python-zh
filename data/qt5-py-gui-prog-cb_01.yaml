- en: Chapter 1. Creating the GUI Form and Adding Widgets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章 创建 GUI 表单并添加小部件
- en: 'In this chapter, we start creating amazing GUIs using Python 3:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始使用 Python 3 创建令人惊叹的图形用户界面：
- en: Creating our first Python GUI
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的第一个Python图形用户界面
- en: Preventing the GUI from being resized
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止GUI被调整大小
- en: Adding a label to the GUI form
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为GUI表单添加标签
- en: Creating buttons and changing their text property
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建按钮并更改它们的文本属性
- en: Text box widgets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本框小部件
- en: Setting the focus to a widget and disabling widgets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将焦点设置到小部件并禁用小部件
- en: Combo box widgets
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合框小部件
- en: Creating a check button with different initial states
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建具有不同初始状态的复选框
- en: Using radio button widgets
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单选按钮小部件
- en: Using scrolled text widgets
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用滚动文本小部件
- en: Adding several widgets in a loop
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在循环中添加几个小部件
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we will develop our first GUI in Python. We start with the
    minimum code required to build a running GUI application. Each recipe then adds
    different widgets to the GUI form.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开发我们的第一个Python图形用户界面（GUI）。我们从构建一个运行中的GUI应用程序所需的最少代码开始。然后，每个菜谱都会向GUI表单添加不同的控件。
- en: In the first two recipes, we show the entire code, consisting of only a few
    lines of code. In the following recipes we only show the code to be added to the
    previous recipes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个菜谱中，我们展示了整个代码，它只包含几行代码。在接下来的菜谱中，我们只展示需要添加到前一个菜谱中的代码。
- en: By the end of this chapter, we will have created a working GUI application that
    consists of labels, buttons, text boxes, combo boxes, and check buttons in various
    states, as well as radio buttons that change the background color of the GUI.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将已经创建了一个包含各种状态的标签、按钮、文本框、组合框和复选按钮的工作 GUI 应用程序，以及可以改变 GUI 背景颜色的单选按钮。
- en: Creating our first Python GUI
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的第一个Python图形用户界面
- en: Python is a very powerful programming language. It ships with the built-in tkinter
    module. In only a few lines of code (four, to be precise) we can build our first
    Python GUI.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种非常强大的编程语言。它自带内置的 tkinter 模块。只需几行代码（确切地说，是四行）我们就能构建我们的第一个 Python 图形用户界面。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To follow this recipe, a working Python development environment is a prerequisite.
    The IDLE GUI that ships with Python is enough to start. IDLE was built using tkinter!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循这个食谱，一个有效的 Python 开发环境是先决条件。Python 附带的 IDLE 图形用户界面足以开始。IDLE 是使用 tkinter 构建的！
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: All the recipes in this book were developed using Python 3.4 on a Windows 7
    64-bit OS. They have not been tested on any other configuration. As Python is
    a cross-platform language, the code from each recipe is expected to run everywhere.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的所有食谱都是在Windows 7 64位操作系统上使用Python 3.4开发的。它们在其他配置上尚未经过测试。由于Python是一种跨平台语言，因此预计每个食谱中的代码可以在任何地方运行。
- en: If you are using a Mac, it does come built-in with Python, yet it might be missing
    some modules such as tkinter, which we will use throughout this book.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Mac，它确实内置了Python，但可能缺少一些模块，例如tkinter，我们将在整本书中使用这个模块。
- en: We are using Python 3 and the creator of Python intentionally chose not to make
    it backwards compatible with Python 2.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用 Python 3，Python 的创造者有意选择不使其与 Python 2 兼容。
- en: If you are using a Mac or Python 2, you might have to install Python 3 from
    [www.python.org](http://www.python.org) in order to successfully run the recipes
    in this book.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用Mac或Python 2，你可能需要从[www.python.org](http://www.python.org)安装Python 3，以便成功运行本书中的食谱。
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here are the four lines of Python code required to create the resulting GUI:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是创建结果GUI所需的四行Python代码：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Execute this code and admire the result:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码并欣赏结果：
- en: '![How to do it...](img/B04829_01_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_01_01.jpg)'
- en: How it works...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In line 1, we import the built-in `tkinter` module and alias it as `tk` to simplify
    our Python code. In line 2, we create an instance of the `Tk` class by calling
    its constructor (the parentheses appended to `Tk` turn the class into an instance).
    We are using the alias `tk` so we don't have to use the longer word `tkinter`.
    We are assigning the class instance to a variable named `win` (short for a window).
    As Python is a dynamically typed language, we did not have to declare this variable
    before assigning to it and we did not have to give it a specific type. *Python
    infers the type from the assignment of this statement*. Python is a strongly typed
    language, so every variable always has a type. We just don't have to specify its
    type beforehand like in other languages. This makes Python a very powerful and
    productive language to program in.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1行，我们导入内置的`tkinter`模块并将其别名为`tk`以简化我们的Python代码。在第2行，我们通过调用其构造函数（`Tk`后附加的括号将类转换为实例）创建了一个`Tk`类的实例。我们使用别名`tk`，这样我们就不必使用较长的单词`tkinter`。我们将类实例分配给一个名为`win`的变量（代表窗口）。由于Python是一种动态类型语言，我们不需要在分配之前声明这个变量，也不需要给它指定一个特定的类型。*Python从该语句的赋值中推断类型*。Python是一种强类型语言，所以每个变量始终都有一个类型。我们只是不必像在其他语言中那样事先指定它的类型。这使得Python成为一种非常强大且高效的编程语言。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A little note about classes and types:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 关于类和类型的简要说明：
- en: In Python every variable always has a type. We cannot create a variable without
    assigning it a type. Yet, in Python, we do not have to declare the type beforehand,
    as we have to do in the C programming language.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，每个变量始终都有一个类型。我们不能创建一个没有指定类型的变量。然而，在Python中，我们不需要事先声明类型，就像在C编程语言中那样。
- en: Python is smart enough to infer the type. At the time of writing, C# also has
    this capability.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Python足够智能，可以推断类型。在撰写本文时，C#也具备这种能力。
- en: Using Python, we can create our own classes using the `class` keyword instead
    of the `def` keyword.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python，我们可以通过 `class` 关键字而不是 `def` 关键字来创建自己的类。
- en: In order to assign the class to a variable, we first have to create an instance
    of our class. We create the instance and assign this instance to our variable.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将类分配给一个变量，我们首先需要创建我们类的实例。我们创建这个实例并将这个实例分配给我们的变量。
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now the variable `classInstance` is of the type `AClass`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在变量 `classInstance` 的类型是 `AClass`。
- en: If this sounds confusing, do not worry. We will cover OOP in the coming chapters.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来很困惑，请不要担心。我们将在接下来的章节中介绍面向对象编程（OOP）。
- en: In line 3, we use the instance variable of the class (`win`) to give our window
    a title via the `title` property. In line 4, we start the window's event loop
    by calling the `mainloop` method on the class instance `win`. Up to this point
    in our code, we created an instance and set one property *but the GUI will not
    be displayed until we start the main event loop*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3行，我们使用类的实例变量（`win`）通过`title`属性给我们的窗口设置标题。在第4行，我们通过在类实例`win`上调用`mainloop`方法来启动窗口的事件循环。到目前为止，我们的代码创建了一个实例并设置了一个属性，*但是GUI将不会显示，直到我们启动主事件循环*。
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: An event loop is a mechanism that makes our GUI work. We can think of it as
    an endless loop where our GUI is waiting for events to be sent to it. A button
    click creates an event within our GUI or our GUI being resized also creates an
    event.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环是使我们的图形用户界面（GUI）工作的机制。我们可以将其想象为一个无限循环，其中我们的GUI正在等待事件被发送给它。按钮点击会在我们的GUI内创建一个事件，或者我们的GUI被调整大小也会创建一个事件。
- en: We can write all of our GUI code in advance and nothing will be displayed on
    the user's screen until we call this endless loop (`win.mainloop()` in the code
    shown above).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以预先编写所有的GUI代码，直到我们调用这个无限循环（如上面代码所示`win.mainloop()`），用户屏幕上不会显示任何内容。
- en: The event loop ends when the user clicks the red **X** button or a widget that
    we have programmed to end our GUI. When the event loop ends, our GUI also ends.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环在用户点击红色**X**按钮或我们编程来结束我们的GUI的小部件时结束。当事件循环结束时，我们的GUI也随之结束。
- en: There's more...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This recipe used a minimum amount of Python code to create our first GUI program.
    However, throughout this book, we will use OOP when it makes sense.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱使用了最少的Python代码来创建我们的第一个GUI程序。然而，在这本书中，当有需要时，我们将使用面向对象编程（OOP）。
- en: Preventing the GUI from being resized
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止GUI被调整大小
- en: Getting ready
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe extends the previous one. Therefore, it is necessary to have typed
    Recipe 1 yourself into a project of your own or downloaded the code from [https://www.packtpub.com/support](https://www.packtpub.com/support).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱扩展了之前的版本。因此，有必要你自己将菜谱1输入到自己的项目中，或者从[https://www.packtpub.com/support](https://www.packtpub.com/support)下载代码。
- en: How to do it...
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We are preventing the GUI from being resized.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在阻止GUI被调整大小。
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Running the code creates this GUI:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码将创建此图形用户界面：
- en: '![How to do it...](img/B04829_01_02.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_01_02.jpg)'
- en: How it works...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Line 4 prevents the Python GUI from being resized.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第4行防止Python GUI被调整大小。
- en: Running this code will result in a GUI similar to the one we created in Recipe
    1\. However, the user can no longer resize it. Also, notice how the maximize button
    in the toolbar of the window is grayed out.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将生成一个类似于我们在菜谱1中创建的GUI。然而，用户不能再调整其大小。此外，请注意窗口工具栏中的最大化按钮已变为灰色。
- en: Why is this important? Because, once we add widgets to our form, resizing can
    make our GUI look not as good as we want it to be. We will add widgets to our
    GUI in the next recipes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这很重要？因为，一旦我们在表单中添加小部件，调整大小可能会让我们的GUI看起来不如我们期望的好。我们将在下一章节中学习如何在GUI中添加小部件。
- en: '`Resizable()` is a method of the `Tk()` class and, by passing in `(0, 0),`
    we prevent the GUI from being resized. If we pass in other values, we hard-code
    the x and y start up size of the GUI, *but that won''t make it nonresizable*.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`Resizable()` 是 `Tk()` 类的一个方法，通过传入 `(0, 0)`，我们防止了 GUI 的调整大小。如果我们传入其他值，我们将硬编码
    GUI 的 x 和 y 启动大小，*但这不会使其不可调整大小*。'
- en: We also added comments to our code in preparation for the recipes contained
    in this book.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在代码中添加了注释，为这本书中包含的食谱做准备。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: In visual programming IDEs such as Visual Studio .NET, C# programmers often
    do not think of preventing the user from resizing the GUI they developed in this
    language. That creates inferior GUIs. Adding this one line of Python code can
    make our users appreciate our GUI.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在诸如Visual Studio .NET这样的可视化编程IDE中，C#程序员通常不会考虑阻止用户调整他们用这种语言开发的GUI的大小。这会导致GUI质量较差。添加这一行Python代码可以让我们的用户欣赏我们的GUI。
- en: Adding a label to the GUI form
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在GUI表单中添加标签
- en: Getting ready
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We are extending the first recipe. We will leave the GUI resizable, so don't
    use the code from the second recipe (or comment the `win.resizable` line 4 out).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在扩展第一个菜谱。我们将保持GUI可调整大小，因此不要使用第二个菜谱中的代码（或者注释掉第4行的`win.resizable`行）。
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In order to add a `Label` widget to our GUI, we are importing the `ttk` module
    from `tkinter`. Please note the two import statements.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将一个`标签`小部件添加到我们的图形用户界面中，我们正在从`tkinter`导入`ttk`模块。请注意这两个导入语句。
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Add the following code just above `win.mainloop()` located at the bottom of
    recipes 1 and 2.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在食谱1和2的底部找到的`win.mainloop()`上方添加以下代码。
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Running the code adds a label to our GUI:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码为我们的GUI添加一个标签：
- en: '![How to do it...](img/B04829_01_03.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_01_03.jpg)'
- en: How it works...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In line 3 of the above code, we are importing a separate module from `tkinter`.
    The `ttk` module has some advanced widgets that make our GUI look great. In a
    sense, `ttk` is an extension within `tkinter`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码的第3行，我们正在从`tkinter`导入一个独立的模块。`ttk`模块包含一些高级控件，可以让我们的GUI看起来很棒。从某种意义上说，`ttk`是`tkinter`的一个扩展。
- en: We still need to import `tkinter` itself, but we have to specify that we now
    want to also use `ttk` from `tkinter`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要导入`tkinter`本身，但我们必须指定我们现在还想使用来自`tkinter`的`ttk`。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: '`ttk` stands for ''themed tk". It improves our GUI look and feel.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`ttk`代表“主题tk”。它改善了我们的GUI外观和感觉。'
- en: Line 5 above adds the label to the GUI, just before we call `mainloop` (not
    shown here to preserve space. See recipes 1 or 2).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的第5行在调用`mainloop`之前（此处未显示以节省空间。请参阅菜谱1或2）将标签添加到GUI中。
- en: We are passing our window instance into the `ttk.Label` constructor and setting
    the text property. This becomes the text our `Label` will display.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将窗口实例传递给`ttk.Label`构造函数并设置文本属性。这将成为`Label`将显示的文本。
- en: We are also making use of the *grid layout manager*, which we'll explore in
    much more depth in [Chapter 2](ch02.html "Chapter 2. Layout Management"), *Layout
    Management*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在使用*网格布局管理器*，我们将在[第2章](ch02.html "第2章。布局管理")*布局管理*中对其进行更深入的探讨。
- en: Note how our GUI suddenly got much smaller than in previous recipes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们的图形用户界面（GUI）突然比之前的菜谱小了很多。
- en: The reason why it became so small is that we added a widget to our form. Without
    a widget, `tkinter` uses a default size. Adding a widget causes optimization,
    which generally means using as little space as necessary to display the widget(s).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 它变得如此之小的原因是我们向我们的表单添加了一个小部件。没有小部件，`tkinter`会使用默认大小。添加小部件会导致优化，这通常意味着使用尽可能少的空间来显示小部件（们）。
- en: If we make the text of the label longer, the GUI will expand automatically.
    We will cover this automatic form size adjustment in a later recipe in [Chapter
    2](ch02.html "Chapter 2. Layout Management"), *Layout Management*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将标签的文本变长，GUI 将会自动扩展。我们将在[第2章](ch02.html "第2章。布局管理")的后续菜谱中介绍这种自动调整表单大小的功能，*布局管理*。
- en: There's more...
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Try resizing and maximizing this GUI with a label and watch what happens.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试调整并最大化这个带有标签的GUI，看看会发生什么。
- en: Creating buttons and changing their text property
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建按钮并更改它们的文本属性
- en: Getting ready
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: This recipe extends the previous one. You can download the entire code from
    the Packt Publishing website.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱扩展了之前的版本。您可以从Packt Publishing网站下载完整的代码。
- en: How to do it...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We are adding a button that, when clicked, performs an action. In this recipe,
    we will update the label we added in the previous recipe, as well as updating
    the text property of the button.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个按钮，点击后会执行一个动作。在这个菜谱中，我们将更新之前菜谱中添加的标签，以及更新按钮的文本属性。
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Before clicking the button:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在点击按钮之前：
- en: '![How to do it...](img/B04829_01_04.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_01_04.jpg)'
- en: After clicking the button, the color of the label has been changed, and so has
    the text of the button. Action!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮后，标签的颜色已经改变，按钮上的文字也相应地发生了变化。行动！
- en: '![How to do it...](img/B04829_01_05.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_01_05.jpg)'
- en: How it works...
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In line 2 we are now assigning the label to a variable and in line 3 we use
    this variable to position the label within the form. We will need this variable
    to change its properties in the `clickMe()` function. By default, this is a module-level
    variable so we can access it inside the function as long as we declare the variable
    above the function that calls it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2行，我们现在将标签分配给一个变量，在第3行我们使用这个变量在表单中定位标签。我们需要这个变量在`clickMe()`函数中更改其属性。默认情况下，这是一个模块级变量，因此只要我们在调用它的函数上方声明变量，我们就可以在函数内部访问它。
- en: Line 5 is the event handler that is being invoked once the button gets clicked.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 第五行是当按钮被点击时被调用的事件处理器。
- en: In line 7, we create the button and bind the command to the `clickMe()` function.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7行，我们创建了按钮并将命令绑定到`clickMe()`函数。
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: GUIs are event-driven. Clicking the button creates an event. We bind what happens
    when this event occurs in the callback function using the command property of
    the `ttk.Button` widget. Notice how we do not use parentheses; only the name `clickMe`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图形用户界面是事件驱动的。点击按钮会创建一个事件。我们使用`ttk.Button`小部件的命令属性，在回调函数中绑定此事件发生时会发生什么。注意我们并没有使用括号；只有名称`clickMe`。
- en: We also change the text of the label to include `red` as in the printed book,
    this might otherwise not be obvious. When you run the code you can see that the
    color did indeed change.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将标签的文本改为包含`红色`，就像在印刷书中一样，否则可能不明显。当你运行代码时，你可以看到颜色确实发生了变化。
- en: Lines 3 and 8 both use the grid layout manager, which will be discussed in the
    following chapter. This aligns both the label and the button.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 第三行和第八行都使用了网格布局管理器，这将在下一章中进行讨论。这会使标签和按钮对齐。
- en: There's more...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We will continue to add more and more widgets to our GUI and we will make use
    of many built-in properties in other recipes in the book.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续向我们的GUI添加越来越多的组件，并且我们会利用书中其他菜谱中的许多内置属性。
- en: Text box widgets
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本框小部件
- en: In `tkinter`, the typical textbox widget is called `Entry`. In this recipe,
    we will add such an `Entry` to our GUI. We will make our label more useful by
    describing what the `Entry` is doing for the user.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `tkinter` 中，典型的文本框小部件被称为 `Entry`。在本教程中，我们将向我们的图形用户界面添加这样一个 `Entry`。我们将通过描述
    `Entry` 为用户做了什么来使我们的标签更加有用。
- en: Getting ready
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: This recipe builds upon the *Creating buttons and changing their text property*
    recipe.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方基于 *创建按钮并更改其文本属性* 配方。
- en: How to do it...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: '[PRE6]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now our GUI looks like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的图形用户界面看起来是这样的：
- en: '![How to do it...](img/B04829_01_06.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_01_06.jpg)'
- en: 'After entering some text and clicking the button, there is the following change
    in the GUI:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入一些文本并点击按钮后，GUI（图形用户界面）将发生以下变化：
- en: '![How to do it...](img/B04829_01_07.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_01_07.jpg)'
- en: How it works...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In line 2 we are getting the value of the `Entry` widget. We are not using OOP
    yet, so how come we can access the value of a variable that was not even declared
    yet?
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2行，我们正在获取`Entry`小部件的值。我们还没有使用面向对象编程（OOP），那么我们是如何访问一个甚至还未声明的变量的值的呢？
- en: Without using OOP classes, in Python procedural coding we have to physically
    place a name above a statement that tries to use that name. So how come this works
    (it does)?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python的过程式编程中，如果不使用面向对象（OOP）类，我们必须在尝试使用该名称的语句上方实际放置一个名称。那么这是怎么做到的（它确实做到了）？
- en: The answer is that the button click event is a callback function, and by the
    time the button is clicked by a user, the variables referenced in this function
    are known and do exist.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是按钮点击事件是一个回调函数，当用户点击按钮时，这个函数中引用的变量是已知的并且确实存在。
- en: Life is good.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 生活很美好。
- en: Line 4 gives our label a more meaningful name, because now it describes the
    textbox below it. We moved the button down next to the label to visually associate
    the two. We are still using the grid layout manager, to be explained in more detail
    in [Chapter 2](ch02.html "Chapter 2. Layout Management"), *Layout Management*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第4行给我们的标签赋予了一个更有意义的名称，因为它现在描述了其下方的文本框。我们将按钮向下移动到标签旁边，以便在视觉上关联这两个元素。我们仍然在使用网格布局管理器，这将在[第2章](ch02.html
    "第2章。布局管理")*布局管理*中更详细地解释。
- en: Line 6 creates a variable `name`. This variable is bound to the `Entry` and,
    in our `clickMe()` function, we are able to retrieve the value of the `Entry`
    box by calling `get()` on this variable. This works like a charm.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第6行创建了一个变量`name`。这个变量绑定到`Entry`上，在我们的`clickMe()`函数中，我们能够通过在这个变量上调用`get()`方法来检索`Entry`框的值。这就像魔法一样有效。
- en: Now we see that while the button displays the entire text we entered (and more),
    the textbox `Entry` widget did not expand. The reason for this is that we had
    hard-coded it to a width of 12 in line 7.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到，虽然按钮显示了我们所输入的完整文本（甚至更多），但`Entry`文本框并没有扩展。这是因为我们在第7行将其硬编码为12英寸的宽度。
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: Python is a dynamically-typed language and infers the type from the assignment.
    What this means is if we assign a string to the variable `name,` the variable
    will be of the type string, and if we assign an integer to `name,` this variable's
    type will be integer.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种动态类型语言，它从赋值中推断类型。这意味着如果我们将字符串赋值给变量 `name`，该变量将是字符串类型，如果我们将整数赋值给 `name`，这个变量的类型将是整数。
- en: Using tkinter, we have to declare the variable `name` as the type `tk.StringVar()`
    before we can use it successfully. The reason is this that Tkinter is not Python.
    We can use it from Python but it is not the same language.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用tkinter时，我们必须在成功使用之前将变量`name`声明为类型`tk.StringVar()`。原因是这样的，Tkinter不是Python。我们可以从Python中使用它，但它并不是同一种语言。
- en: Setting the focus to a widget and disabling widgets
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将焦点设置到小部件并禁用小部件
- en: While our GUI is nicely improving, it would be more convenient and useful to
    have the cursor appear in the `Entry` widget as soon as the GUI appears. Here
    we learn how to do this.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的GUI界面正在得到很好的改进时，如果光标能在GUI出现时立即出现在`Entry`小部件中，将会更加方便和实用。在这里，我们将学习如何实现这一点。
- en: Getting ready
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: This recipe extends the previous recipe.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱扩展了之前的食谱。
- en: How to do it...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Python is truly great. All we have to do to set the focus to a specific control
    when the GUI appears is call the `focus()` method on an instance of a `tkinter`
    widget we previously created. In our current GUI example, we assigned the `ttk.Entry`
    class instance to a variable we named `nameEntered`. Now we can give it the focus.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Python 真的是非常出色。当 GUI 出现时，我们只需在之前创建的 `tkinter` 小部件实例上调用 `focus()` 方法，就可以将焦点设置到特定的控件上。在我们的当前
    GUI 示例中，我们将 `ttk.Entry` 类实例分配给了一个名为 `nameEntered` 的变量。现在我们可以给它设置焦点。
- en: Place the following code just above the bottom of the module that starts the
    main windows event loop, just like in previous recipes. If you get some errors,
    make sure you are placing calls to variables below the code where they are declared.
    We are not using OOP as of yet, so this is still necessary. Later, it will no
    longer be necessary to do this.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码放置在启动主窗口事件循环的模块底部上方，就像在之前的食谱中一样。如果你遇到一些错误，请确保你将变量调用放置在代码下方，它们被声明的位置。因为我们目前还没有使用面向对象编程（OOP），所以这仍然是必要的。稍后，将不再需要这样做。
- en: '[PRE7]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: On a Mac, you might have to set the focus to the GUI window first before being
    able to set the focus to the `Entry` widget in this window.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac上，你可能需要首先将焦点设置到GUI窗口，然后才能将焦点设置到该窗口中的`Entry`小部件。
- en: Adding this one line of Python code places the cursor into our text `Entry`
    box, giving the text `Entry` box the focus. As soon as the GUI appears, we can
    type into this text box without having to click it first.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这一行Python代码将光标置于我们的文本`Entry`框中，使文本`Entry`框获得焦点。一旦GUI出现，我们就可以直接在文本框中输入，而无需先点击它。
- en: '![How to do it...](img/B04829_01_08.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_01_08.jpg)'
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: Note how the cursor now defaults to residing inside the text `Entry` box.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意现在光标默认位于文本`Entry`框内。
- en: 'We can also disable widgets. To do that, we set a property on the widget. We
    can make the button disabled by adding this one line of Python code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以禁用小部件。为此，我们可以在小部件上设置一个属性。我们可以通过添加以下这一行Python代码来使按钮不可用：
- en: '[PRE8]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After adding the above line of Python code, clicking the button no longer creates
    any action!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加上述Python代码行之后，点击按钮不再产生任何动作！
- en: '![How to do it...](img/B04829_01_09.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_01_09.jpg)'
- en: How it works...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This code is self-explanatory. We set the focus to one control and disable another
    widget. Good naming in programming languages helps to eliminate lengthy explanations.
    Later in this book, there will be some advanced tips on how to do this while programming
    at work or practicing our programming skills at home.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是自我解释的。我们将焦点设置到一个控件上，并禁用另一个小部件。在编程语言中良好的命名有助于消除冗长的解释。本书后面将会有一些关于如何在工作中编程或在家中练习编程技能时如何做到这一点的进阶技巧。
- en: There's more...
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Yes. This is only the first chapter. There is much more to come.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。这仅仅是第一章。还有更多内容即将到来。
- en: Combo box widgets
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合框小部件
- en: In this recipe, we will improve our GUI by adding drop-down combo boxes that
    can have initial default values. While we can restrict the user to only certain
    choices, at the same time, we can allow the user to type in whatever they wish.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将通过添加具有初始默认值的下拉组合框来改进我们的GUI。虽然我们可以限制用户只能选择某些选项，但同时，我们也可以允许用户输入他们想要的任何内容。
- en: Getting ready
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: This recipe extends the previous recipes.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱扩展了之前的菜谱。
- en: How to do it...
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We are inserting another column between the `Entry` widget and the `Button`
    using the grid layout manager. Here is the Python code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用网格布局管理器在`Entry`小部件和`Button`之间插入另一列。以下是Python代码。
- en: '[PRE9]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code, when added to previous recipes, creates the following GUI. Note how,
    in line 4 in the preceding code, we assign a tuple with default values to the
    combo box. These values then appear in the drop-down box. We can also change them
    if we like (by typing in different values when the application is running).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码，当添加到之前的菜谱中时，会创建以下GUI。注意，在前面的代码的第4行中，我们给组合框分配了一个带有默认值的元组。这些值随后会出现在下拉框中。我们也可以根据需要更改它们（在应用程序运行时输入不同的值）。
- en: '![How to do it...](img/B04829_01_10.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_01_10.jpg)'
- en: How it works...
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Line 1 adds a second label to match the newly created combo box (created in
    line 3). Line 2 assigns the value of the box to a variable of a special `tkinter`
    type (`StringVar`), as we did in a previous recipe.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行添加第二个标签以匹配新创建的组合框（在第三行创建）。第二行将框的值赋给一个特殊的 `tkinter` 类型变量（`StringVar`），正如我们在之前的菜谱中所做的那样。
- en: Line 5 aligns the two new controls (label and combo box) within our previous
    GUI layout, and line 6 assigns a default value to be displayed when the GUI first
    becomes visible. This is the first value of the `numberChosen['values']` tuple,
    the string `"1"`. We did not place quotes around our tuple of integers in line
    4, but they got casted into strings because, in line 2, we declared the values
    to be of type `tk.StringVar`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 第5行将两个新的控件（标签和组合框）在我们的前一个GUI布局中进行对齐，第6行分配了一个默认值，当GUI首次可见时将显示此值。这是`numberChosen['values']`元组的第一个值，字符串`"1"`。我们在第4行没有给整数的元组加上引号，但它们因为，在第2行中，我们声明了值的数据类型为`tk.StringVar`，而被转换成了字符串。
- en: The screenshot shows the selection made by the user (**42**). This value gets
    assigned to the `number` variable.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 截图显示了用户所做的选择（**42**）。此值被分配给`number`变量。
- en: There's more...
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If we want to restrict the user to only be able to select the values we have
    programmed into the `Combobox`, we can do that by passing the *state property*
    into the constructor. Modify line 3 in the previous code to:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要限制用户只能选择我们编程到`Combobox`中的值，我们可以通过将*状态属性*传递给构造函数来实现。将前一段代码的第3行修改为：
- en: '[PRE10]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now users can no longer type values into the `Combobox`. We can display the
    value chosen by the user by adding the following line of code to our Button Click
    Event Callback function:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户不能再将值输入到`Combobox`中。我们可以在我们的按钮点击事件回调函数中添加以下代码行来显示用户选择的价值：
- en: '[PRE11]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After choosing a number, entering a name, and then clicking the button, we
    get the following GUI result, which now also displays the number selected:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择一个数字、输入一个名称然后点击按钮后，我们得到以下GUI结果，现在它也显示了所选的数字：
- en: '![There''s more...](img/B04829_01_11.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/B04829_01_11.jpg)'
- en: Creating a check button with different initial states
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建具有不同初始状态的复选框
- en: In this recipe, we will add three `Checkbutton` widgets, each with a different
    initial state.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将添加三个`Checkbutton`小部件，每个小部件的初始状态都不同。
- en: Getting ready
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: This recipe extends the previous recipes.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱扩展了之前的菜谱。
- en: How to do it...
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We are creating three `Checkbutton` widgets that differ in their states. The
    first is disabled and has a checkmark in it. The user cannot remove this checkmark
    as the widget is disabled.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了三个状态不同的`Checkbutton`小部件。第一个是禁用的，并且里面有一个勾选标记。由于小部件处于禁用状态，用户无法移除这个勾选标记。
- en: The second `Checkbutton` is enabled and, by default, has no checkmark in it,
    but the user can click it to add a checkmark.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个 `Checkbutton` 被启用，并且默认情况下其中没有勾选标记，但用户可以点击它来添加勾选标记。
- en: The third `Checkbutton` is both enabled and checked by default. The users can
    uncheck and recheck the widget as often as they like.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个`Checkbutton`默认既启用又选中。用户可以根据自己的喜好频繁地取消选中并重新选中该控件。
- en: '[PRE12]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Running the new code results in the following GUI:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 运行新代码将产生以下图形用户界面：
- en: '![How to do it...](img/B04829_01_12.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_01_12.jpg)'
- en: How it works...
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In lines 2, 6, and 10, we create three variables of type `IntVar`. In the following
    line, for each of these variables we create a `Checkbutton`, passing in these
    variables. They will hold the state of the `Checkbutton` (unchecked or checked).
    By default, that is either 0 (unchecked) or 1 (checked) so the type of the variable
    is a `tkinter` integer.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2行、第6行和第10行，我们创建了三个类型为`IntVar`的变量。在下一行，对于这些变量中的每一个，我们创建了一个`Checkbutton`，并将这些变量传递进去。它们将保存`Checkbutton`的状态（未选中或选中）。默认情况下，这要么是0（未选中），要么是1（选中），因此变量的类型是`tkinter`整数。
- en: We place these `Checkbutton` widgets in our main window so the first argument
    passed into the constructor is the parent of the widget; in our case `win`. We
    give each `Checkbutton` a different label via its `text` property.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些`Checkbutton`小部件放置在我们的主窗口中，因此构造函数传入的第一个参数是部件的父级；在我们的例子中是`win`。我们通过每个`Checkbutton`的`text`属性为其分配不同的标签。
- en: Setting the sticky property of the grid to `tk.W` means that the widget will
    be aligned to the west of the grid. This is very similar to Java syntax and it
    means that it will be aligned to the left. When we resize our GUI, the widget
    will remain on the left side and not be moved towards the center of the GUI.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 将网格的粘性属性设置为 `tk.W` 意味着小部件将被对齐到网格的西部。这与Java语法非常相似，意味着它将被对齐到左侧。当我们调整我们的GUI大小时，小部件将保持在左侧，而不会移动到GUI的中心。
- en: Lines 4 and 12 place a checkmark into the `Checkbutton` widget by calling the
    `select()` method on these two `Checkbutton` class instances.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 第四行和第十二行通过在这两个`Checkbutton`类实例上调用`select()`方法，在`Checkbutton`小部件中放置一个勾选标记。
- en: We continue to arrange our widgets using the grid layout manager, which will
    be explained in more detail in [Chapter 2](ch02.html "Chapter 2. Layout Management"),
    *Layout Management*.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续使用网格布局管理器来排列我们的小部件，这将在[第2章](ch02.html "第2章。布局管理")*布局管理*中更详细地解释。
- en: Using radio button widgets
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单选按钮小部件
- en: In this recipe, we will create three `tkinter Radiobutton` widgets. We will
    also add some code that changes the color of the main form depending upon which
    `Radiobutton` is selected.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建三个 `tkinter Radiobutton` 小部件。我们还将添加一些代码，根据选中的哪个 `Radiobutton` 来改变主表单的颜色。
- en: Getting ready
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: This recipe extends the previous recipes.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱扩展了之前的菜谱。
- en: How to do it...
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We are adding the following code to the previous recipe:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在将以下代码添加到之前的食谱中：
- en: '[PRE13]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Running this code and selecting the `Radiobutton` named **Gold** creates the
    following window:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码并选择名为**黄金**的`单选按钮`将创建以下窗口：
- en: '![How to do it...](img/B04829_01_13.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_01_13.jpg)'
- en: How it works...
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In lines 2-4 we create some module-level global variables, which we will use
    in the creation of each radio button as well as in the callback function that
    creates the action of changing the background color of the main form (using the
    instance variable `win`).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2-4行中，我们创建了一些模块级别的全局变量，这些变量将在创建每个单选按钮以及创建更改主表单背景颜色的动作的回调函数（使用实例变量`win`）中使用。
- en: We are using global variables to make it easier to change the code. By assigning
    the name of the color to a variable and using this variable in several places,
    we can easily experiment with different colors. Instead of doing a global search-and-replace
    of a hard-coded string (which is prone to errors), we just need to change one
    line of code and everything else will work. This is known as the **DRY principle**,
    which stands for **Don't Repeat Yourself**. This is an OOP concept that we will
    use in later recipes of the book.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用全局变量来简化代码的修改。通过将颜色的名称分配给一个变量并在多个地方使用这个变量，我们可以轻松地尝试不同的颜色。而不是进行全局的硬编码字符串搜索和替换（这容易出错），我们只需更改一行代码，其他所有内容都会正常工作。这被称为**DRY原则**，即**不要重复自己**。这是我们将在本书后面的食谱中使用的面向对象编程（OOP）概念。
- en: Note
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: The names of the colors we are assigning to the variables (`COLOR1`, `COLOR2
    …`) are `tkinter` keywords (technically, they are *symbolic names*). If we use
    names that are not `tkinter` color keywords, then the code will not work.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分配给变量（`COLOR1`, `COLOR2 ...`）的颜色名称是 `tkinter` 关键字（技术上，它们是 *符号名称*）。如果我们使用不是
    `tkinter` 颜色关键字的名称，那么代码将无法工作。
- en: Line 6 is the *callback function* that changes the background of our main form
    (`win`) depending upon the user's selection.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 第6行是*回调函数*，根据用户的选项改变我们的主表单（`win`）的背景。
- en: In line 8 we are creating a `tk.IntVar` variable. What is important about this
    is that we are creating only one variable to be used by all three radio buttons.
    As can be seen from the above screenshot, no matter which `Radiobutton` we select,
    all the others will automatically be unselected for us.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8行，我们创建了一个`tk.IntVar`变量。这个变量的重要之处在于我们只创建了一个变量，将被三个单选按钮共同使用。从上面的截图可以看出，无论我们选择哪个`Radiobutton`，其他所有选项都会自动为我们取消选中。
- en: Lines 9 to 14 create the three radio buttons, assign them to the main form,
    and pass in the variable to be used in the callback function that creates the
    action of changing the background of our main window.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 第9至14行创建了三个单选按钮，将它们分配给主表单，并将用于回调函数中创建更改主窗口背景动作的变量传入。
- en: Note
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: While this is the first recipe that changes the color of a widget, quite honestly,
    it looks a bit ugly. A large portion of the following recipes in this book explain
    how to make our GUI look truly amazing.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是第一个改变小部件颜色的配方，但坦白说，它看起来有点丑陋。本书中接下来的大部分配方都解释了如何让我们的图形用户界面真正令人惊叹。
- en: There's more...
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Here is a small sample of the available symbolic color names that you can look
    up at the official tcl manual page:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是您可以在官方 tcl 手册页面查找的可用符号颜色名称的小样本：
- en: '[http://www.tcl.tk/man/tcl8.5/TkCmd/colors.htm](http://www.tcl.tk/man/tcl8.5/TkCmd/colors.htm)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.tcl.tk/man/tcl8.5/TkCmd/colors.htm](http://www.tcl.tk/man/tcl8.5/TkCmd/colors.htm)'
- en: '| Name | Red | Green | Blue |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 姓名 | 红色 | 绿色 | 蓝色 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| alice blue | 240 | 248 | 255 |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 爱丽丝蓝 | 240 | 248 | 255 |'
- en: '| AliceBlue | 240 | 248 | 255 |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 雅典蓝 | 240 | 248 | 255 |'
- en: '| Blue | 0 | 0 | 255 |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 蓝色 | 0 | 0 | 255 |'
- en: '| Gold | 255 | 215 | 0 |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 金色 | 255 | 215 | 0 |'
- en: '| Red | 255 | 0 | 0 |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 红色 | 255 | 0 | 0 |'
- en: Some of the names create the same color, so `alice blue` creates the same color
    as `AliceBlue`. In this recipe we used the symbolic names `Blue`, `Gold`, and
    `Red`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一些名称创建相同的颜色，所以 `alice blue` 与 `AliceBlue` 创建相同的颜色。在这个配方中我们使用了符号名称 `Blue`、`Gold`
    和 `Red`。
- en: Using scrolled text widgets
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用滚动文本小部件
- en: '`ScrolledText` widgets are much larger than simple `Entry` widgets and span
    multiple lines. They are widgets like Notepad and wrap lines, automatically enabling
    vertical scrollbars when the text gets larger than the height of the `ScrolledText`
    widget.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScrolledText`小部件比简单的`Entry`小部件大得多，并且跨越多行。它们类似于记事本这样的小部件，会自动换行，当文本超过`ScrolledText`小部件的高度时，会自动启用垂直滚动条。'
- en: Getting ready
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: This recipe extends the previous recipes. You can download the code for each
    chapter of this book from the Packt Publishing website.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱扩展了之前的菜谱。您可以从Packt Publishing网站下载本书每一章的代码。
- en: How to do it...
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'By adding the following lines of code, we create a `ScrolledText` widget:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加以下代码行，我们创建一个`ScrolledText`小部件：
- en: '[PRE14]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can actually type into our widget, and if we type enough words, the lines
    will automatically wrap around!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上可以在我们的小部件中输入文字，如果我们输入足够的单词，行就会自动换行！
- en: '![How to do it...](img/B04829_01_14.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_01_14.jpg)'
- en: Once we type in more words than the height of the widget can display, the vertical
    scrollbar becomes enabled. This all works out-of-the-box without us needing to
    write any more code to achieve this.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们输入的单词数量超过了小部件能够显示的高度，垂直滚动条就会被启用。这一切都是现成的，无需我们再编写任何代码来实现这一功能。
- en: '![How to do it...](img/B04829_01_15.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_01_15.jpg)'
- en: How it works...
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In line 2 we are importing the module that contains the `ScrolledText` widget
    class. Add that to the top of the module, just below the other two `import` statements.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2行，我们正在导入包含`ScrolledText`小部件类的模块。将其添加到模块顶部，位于其他两个`import`语句之下。
- en: Lines 4 and 5 define the width and height of the `ScrolledText` widget we are
    about to create. These are hard-coded values we are passing into the `ScrolledText`
    widget constructor in line 6.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 第4行和第5行定义了我们即将创建的`ScrolledText`小部件的宽度和高度。这些是硬编码的值，我们在第6行的`ScrolledText`小部件构造函数中传递了这些值。
- en: These values are *magic numbers* found by experimentation to work well. You
    might experiment by changing `srcolW` from 30 to 50 and observe the effect!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值是经过实验发现的*魔法数字*，效果良好。你可以通过将`srcolW`从30改为50进行实验，观察其效果！
- en: In line 6 we are setting a property on the widget by passing in `wrap=tk.WORD`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6行，我们通过传递`wrap=tk.WORD`来在部件上设置一个属性。
- en: By setting the `wrap` property to `tk.WORD` we are telling the `ScrolledText`
    widget to break lines by words, so that we do not wrap around within a word. The
    default option is `tk.CHAR`, which wraps any character regardless of whether we
    are in the middle of a word.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`wrap`属性设置为`tk.WORD`，我们告诉`ScrolledText`小部件按单词断行，这样我们就不需要在单词内部换行。默认选项是`tk.CHAR`，它会无论我们是否在单词中间都进行换行。
- en: The second screenshot shows that the vertical scrollbar moved down because we
    are reading a longer text that does not entirely fit into the x, y dimensions
    of the `SrolledText` control we created.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 第二张截图显示，垂直滚动条向下移动了，因为我们正在阅读一段较长的文本，而这段文本并没有完全适合我们创建的`SrolledText`控件在x, y维度内。
- en: Setting the `columnspan` property of the grid widget to `3` for the `SrolledText`
    widget makes this widget span all three columns. If we did not set this property,
    our `SrolledText` widget would only reside in column one, which is not what we
    want.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 将网格小部件的`columnspan`属性设置为`3`，以便`SrolledText`小部件跨越所有三列。如果我们没有设置此属性，我们的`SrolledText`小部件将仅位于第一列，这并不是我们想要的。
- en: Adding several widgets in a loop
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在循环中添加几个小部件
- en: So far we have created several widgets of the same type (for example. `Radiobutton`)
    by basically copying and pasting the same code and then modifying the variations
    (for example, the column number). In this recipe, we start refactoring our code
    to make it less redundant.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们通过基本复制粘贴相同的代码并修改变体（例如，列数）的方式创建了几个相同类型的组件（例如，`Radiobutton`）。在这个菜谱中，我们开始重构我们的代码，使其更加简洁。
- en: Getting ready
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We are refactoring some parts of the previous recipe's code, so you need that
    code to apply to this recipe to.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在重构之前食谱代码的一些部分，因此你需要这段代码来应用到这个食谱中。
- en: How to do it...
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: '[PRE15]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Running this code will create the same window as before, but our code is much
    cleaner and easier to maintain. This will help us when we expand our GUI in the
    following recipes.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将创建与之前相同的窗口，但我们的代码更加简洁且易于维护。这将在我们后续的GUI扩展中有所帮助。
- en: How it works...
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In line 1, we have turned our global variables into a list.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们将全局变量转换成了一个列表。
- en: In line 2, we are setting a default value to the `tk.IntVar` variable we named
    `radVar`. This is important because, while in the previous recipe we had set the
    value for `Radiobutton` widgets starting at 1, in our new loop it is much more
    convenient to use Python's zero-based indexing. If we did not set the default
    value to a value outside the range of our `Radiobutton` widgets, one of the radio
    buttons would be selected when the GUI appears. While this in itself might not
    be so bad, *it would not trigger the callback* and we would end up with a radio
    button selected that does not do its job (that is, change the color of the main
    win form).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2行，我们为名为`radVar`的`tk.IntVar`变量设置了一个默认值。这很重要，因为在之前的菜谱中，我们为`Radiobutton`小部件设置了从1开始的值，而在我们新的循环中，使用Python的基于0的索引方式要方便得多。如果我们没有将默认值设置为我们`Radiobutton`小部件的范围之外的值，当GUI出现时，其中一个单选按钮会被选中。虽然这本身可能不是那么糟糕，*但它不会触发回调函数*，我们最终会选中一个不执行其工作（即改变主窗口表单的颜色）的单选按钮。
- en: In line 3 we are replacing the three previously hard-coded creations of the
    Radiobutton widgets with a loop, which does the same. It is just more concise
    (fewer lines of code) and much more maintainable. For example, if we want to create
    100 instead of just 3 `Radiobutton` widgets, all we have to change is the number
    inside Python's range operator. We would not have to type or copy and paste 97
    sections of duplicate code, just one number.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3行，我们将之前硬编码的三个Radiobutton小部件的创建替换为一个循环，它执行相同的操作。这仅仅更加简洁（代码行数更少）且易于维护。例如，如果我们想要创建100个而不是仅仅3个Radiobutton小部件，我们只需更改Python范围运算符内的数字即可。我们不需要输入或复制粘贴97段重复的代码，只需一个数字。
- en: Line 4 shows the modified callback, which physically lives above the previous
    lines. We placed it below to give emphasis to the more important parts of this
    recipe.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 第4行显示了修改后的回调函数，它在物理上位于前面的行之上。我们将它放置在下方，以强调这个菜谱中更重要的部分。
- en: There's more...
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This recipe concludes the first chapter of this book. All the following recipes
    in all of the next chapters will build upon the GUI we have constructed so far,
    greatly enhancing it.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱总结了本书的第一章。所有接下来的章节中的食谱都将基于我们迄今为止构建的GUI进行构建，极大地增强它。
