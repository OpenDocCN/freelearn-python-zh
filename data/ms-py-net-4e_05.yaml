- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Docker Containers for Network Engineers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络工程师的Docker容器
- en: Computer hardware virtualization has revolutionized and changed the way we approach
    infrastructure. Gone are the days when we must dedicate hardware to a single host
    and operating system. We now have the option to share precious hardware such as
    CPU, memory, and disk space with multiple virtual machines, each with its own
    operating system and applications. Because software executed on these virtual
    machines is separated from the underlying hardware resources, we are free to allocate
    a different combination of hardware resources to virtual machines based on their
    specific needs. Nowadays, it is hard to imagine a world without virtual machines.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机硬件虚拟化已经彻底改变了我们处理基础设施的方式。那些必须为单个主机和操作系统分配硬件的日子已经过去了。我们现在可以选择将宝贵的硬件资源，如CPU、内存和磁盘空间，与多个虚拟机共享，每个虚拟机都有自己的操作系统和应用程序。由于在这些虚拟机上运行的软件与底层硬件资源分离，我们可以根据虚拟机的特定需求分配不同的硬件资源组合。如今，很难想象一个没有虚拟机的世界。
- en: As much as virtual machines are great for application building, they do take
    a while to build, spin up, and, ultimately, tear down. The reason is that the
    virtualization technology associated with virtual machines completely simulates
    the actual hardware for which the hardware is indistinguishable from the guest
    virtual machines.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管虚拟机在构建应用程序方面非常出色，但它们需要花费一些时间来构建、启动，最终还需要拆除。原因是与虚拟机相关的虚拟化技术完全模拟了实际硬件，使得硬件与客户虚拟机无法区分。
- en: 'The question might now be: is there a way to speed up the life cycle of applications
    with even more virtualization? The answer is yes, with the help of containers.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可能有人会问：有没有一种方法可以通过更多的虚拟化来加速应用程序的生命周期？答案是肯定的，借助容器。
- en: Containers and virtual machines are similar in that they both allow sharing
    of computing resources amongst different isolated applications. The difference
    is that virtual machines are abstracted at the Hypervisor level, whereas containers
    are abstracted within the operating system by a container engine. Containers are
    often referred to as OS-level virtualization.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 容器和虚拟机在允许不同隔离的应用程序之间共享计算资源方面相似。区别在于虚拟机在虚拟机管理程序级别进行抽象，而容器是由容器引擎在操作系统内部进行抽象。容器通常被称为操作系统级别的虚拟化。
- en: '![Graphical user interface  Description automatically generated](img/B18403_05_01.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面 自动生成描述](img/B18403_05_01.png)'
- en: 'Figure 5.1: Virtual Machine and Container Comparison (source: https://www.atlassian.com/microservices/cloud-computing/containers-vs-vms)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：虚拟机和容器比较（来源：https://www.atlassian.com/microservices/cloud-computing/containers-vs-vms）
- en: In a full virtual machine, we can install different operating systems, such
    as Windows and Linux. Because container virtualization is being handled by the
    operating system, each container will have the same operating system. However,
    the application and its associated resources will be isolated and run independently
    of each other. The container engine will separate the configuration, software
    bundle, and libraries from each container.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在全虚拟机中，我们可以安装不同的操作系统，如Windows和Linux。因为容器虚拟化是由操作系统处理的，所以每个容器都将拥有相同的操作系统。然而，应用程序及其相关资源将被隔离，并独立于彼此运行。容器引擎将配置、软件包和库从每个容器中分离出来。
- en: 'Container virtualization is not new; **Linux containers** (**LXC**), Solaris
    containers, Docker, and Podman are examples of such implementation. In this chapter,
    we will look at the most popular container technology today, Docker. We will discuss
    the following topics related to Docker containers:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 容器虚拟化并不新鲜；**Linux容器**（**LXC**）、Solaris容器、Docker和Podman都是此类实现的例子。在本章中，我们将探讨当今最流行的容器技术Docker。我们将讨论与Docker容器相关的以下主题：
- en: Docker overview
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker概述
- en: Building Python applications with Docker
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker构建Python应用程序
- en: Container networking
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器网络
- en: Containers in the network engineering field
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络工程领域的容器
- en: Docker and Kubernetes
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker和Kubernetes
- en: We will be using containers for some of the technologies we will learn in this
    book; this is a good place to start getting familiar with containers.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书中学习的一些技术中用到容器；这是一个开始熟悉容器的良好起点。
- en: Let’s start by looking at a high-level overview of Docker.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从Docker的高级概述开始。
- en: Docker Overview
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker概述
- en: Docker is a set of products and tools that supports the delivery of containers.
    It was started by the company dotCloud in 2008 (renamed to Docker, Inc. in 2013).
    The set of tools includes the container technology of Docker, the container engine
    called Docker Engine, the cloud-based repository of containers called Docker Hub,
    and the desktop graphical user interface software called Docker Desktop.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是一套支持容器交付的产品和工具。它始于2008年的公司dotCloud（2013年更名为Docker, Inc.）。这套工具包括Docker的容器技术、名为Docker
    Engine的容器引擎、名为Docker Hub的基于云的容器仓库以及名为Docker Desktop的桌面图形用户界面软件。
- en: Docker has two versions, **Docker Community Edition** (**Docker-CE**) and **Docker
    Enterprise Edition** (**Docker-EE**). Docker-CE is a free and open-source platform
    based on the Apache 2.0 license, while Docker-EE is a premium version geared toward
    enterprises. When the term “Docker” is mentioned in this book, we are referring
    to the Community Edition.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Docker有两个版本，**Docker社区版**（**Docker-CE**）和**Docker企业版**（**Docker-EE**）。Docker-CE是一个基于Apache
    2.0许可证的免费开源平台，而Docker-EE是一个面向企业的付费版本。当本书中提到“Docker”一词时，我们指的是社区版。
- en: 'There are three main components in a Docker container environment:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Docker容器环境中有三个主要组件：
- en: 'Building and Development: These include the tools used to build a container,
    including the CLI commands, the images, and the repositories where we get the
    various base images. In Docker, we use a Dockerfile to specify most of the building
    steps for a container.'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建和开发：这包括用于构建容器的工具，包括CLI命令、镜像以及我们获取各种基础镜像的仓库。在Docker中，我们使用Dockerfile来指定容器构建的大多数步骤。
- en: 'Docker Engine: This is the daemon running in the background. We can use the
    Docker command to manage the daemon.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker引擎：这是在后台运行的守护进程。我们可以使用Docker命令来管理守护进程。
- en: 'Container Orchestration: During development, we will typically use `Docker-compose`
    from Docker to manage a multi-container environment. In production, a common tool
    is a Google-originated tool called Kubernetes ([https://kubernetes.io/](https://kubernetes.io/)).'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器编排：在开发过程中，我们通常会使用Docker的`Docker-compose`来管理多容器环境。在生产环境中，一个常见的工具是由谷歌发起的工具，称为Kubernetes
    ([https://kubernetes.io/](https://kubernetes.io/))。
- en: In the next section, we will discuss the advantages of Docker.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论Docker的优势。
- en: Advantages of Docker
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker的优势
- en: 'There are many advantages of Docker. We will summarize some of them here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Docker有许多优势。我们将在此总结其中一些：
- en: Docker containers are fast to deploy and destroy.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker容器部署和销毁都非常快速。
- en: Containers reset gracefully. The containers are transient and ephemeral, leaving
    no residual artifacts when restarted. This leaves a clean state whenever a new
    container is spawned.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器优雅地重置。容器是短暂的，当重启时不会留下任何残留的文件。这确保了每次生成新容器时都有一个干净的状态。
- en: It is self-contained and deterministic. Containers are often delivered with
    configuration files with instructions on how the container can be rebuilt. We
    can be sure each container image is built in the same way.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是自包含且确定的。容器通常附带配置文件，其中包含有关如何重建容器的说明。我们可以确信每个容器镜像都是按照相同的方式进行构建的。
- en: It allows seamless integration between application development and DevOps. Because
    of the advantages stated above, many companies have deployed. Docker images directly
    in the production environment. The container can be reproduced exactly as the
    developer intended and tested into production.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它允许应用程序开发和DevOps之间的无缝集成。由于上述优点，许多公司已将Docker镜像直接部署到生产环境中。容器可以精确地按照开发者的意图进行复制并测试到生产环境中。
- en: Now that we have a general understanding of Docker, it is time to build our
    first Python applications in a Docker container.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对Docker有了基本的了解，是时候在我们的Docker容器中构建第一个Python应用程序了。
- en: Building Python applications in Docker
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker中构建Python应用程序
- en: A Docker container is a very popular way to build Python applications.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Docker容器是构建Python应用程序的一种非常流行的方式。
- en: Installing Docker
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Docker
- en: Of course, we will need to install Docker to start using it. We will follow
    DigitalOcean’s excellent installation guide for Ubuntu 22.04 ([https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-22-04](https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-22-04)).
    If you are using other versions of the Linux distribution, you can simply use
    the drop-down menu from the documentation to pick a different version. For installation
    on Mac or Windows, my recommendation would be to install Docker Desktop ([https://docs.docker.com/desktop/](https://docs.docker.com/desktop/)).
    It will include the Docker Engine, CLI client, and GUI application.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要安装Docker才能开始使用它。我们将遵循DigitalOcean为Ubuntu 22.04提供的优秀安装指南[https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-22-04](https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-22-04)。如果您使用的是其他版本的Linux发行版，您可以直接从文档中的下拉菜单选择不同的版本。对于Mac或Windows的安装，我的建议是安装Docker
    Desktop[https://docs.docker.com/desktop/](https://docs.docker.com/desktop/)。它将包括Docker
    Engine、CLI客户端和GUI应用程序。
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There are some optional but useful post-installation steps for Linux at [https://docs.docker.com/engine/install/linux-postinstall/](https://docs.docker.com/engine/install/linux-postinstall/).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Linux，有一些可选但有用的安装后步骤，请参阅[https://docs.docker.com/engine/install/linux-postinstall/](https://docs.docker.com/engine/install/linux-postinstall/)。
- en: 'We can check the status of our Docker installation:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查我们的Docker安装状态：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the next section, we will see how we can build a Python application in Docker
    containers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将了解如何使用Docker容器构建Python应用程序。
- en: Useful Docker commands
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有用的Docker命令
- en: We will need to use some commands to build, run, and test our containers.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要使用一些命令来构建、运行和测试我们的容器。
- en: 'For more Docker CLI references, check out the documentation: [https://docs.docker.com/engine/reference/run/](https://docs.docker.com/engine/reference/run/).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更多的Docker CLI参考，请查看文档：[https://docs.docker.com/engine/reference/run/](https://docs.docker.com/engine/reference/run/)。
- en: 'Here are some of the commands we will be using in this chapter:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用以下一些命令：
- en: '`docker run`: `docker run` is used to specify the image to derive the container
    from (by default, it is Docker Hub), network settings, name, and other settings.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker run`：`docker run`用于指定从哪个镜像（默认为Docker Hub）派生容器，网络设置、名称和其他设置。'
- en: '`docker container ls`: lists the containers; by default, it only lists currently
    running containers.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker container ls`：列出容器；默认情况下，它只列出当前正在运行的容器。'
- en: '`docker exec`: runs a command on a running container.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker exec`：在运行的容器上运行命令。'
- en: '`docker network`: used when we need to manage Docker networks, such as to create,
    list, and remove Docker networks.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker network`：在需要管理Docker网络时使用，例如创建、列出和删除Docker网络。'
- en: '`docker image`: manages Docker images.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker image`：管理Docker镜像。'
- en: There are many more CLI commands, but these are enough to get us started. For
    a complete reference, check out the link provided in the information box.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他的CLI命令，但这些已经足够我们开始使用了。对于完整的参考，请查看信息框中提供的链接。
- en: Building hello world
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建“hello world”
- en: 'The first step is to make sure we have reachability to Docker Hub to retrieve
    an image. To do so, Docker provides a very simple `hello-world` app:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是确保我们能够访问Docker Hub以检索镜像。为此，Docker提供了一个非常简单的`hello-world`应用程序：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can see the various steps the Docker client needed to do to display the
    message. We can display the Docker processes that ran:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到Docker客户端需要执行的各种步骤以显示消息。我们可以显示运行的Docker进程：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can see the `hello-world` image information:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`hello-world`镜像信息：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now we can build our first Python application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以构建我们的第一个Python应用程序。
- en: Building our application
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建我们的应用程序
- en: Let’s start by thinking about what we will build. Since we built a few Ansible
    playbooks in the last chapter, how about we containerize the `ios_config_backup.yml`
    playbook so we can share this with other team members?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先思考一下我们将要构建的内容。由于我们在上一章中构建了一些Ansible playbooks，我们为什么不将`ios_config_backup.yml`
    playbooks容器化，这样我们就可以与其他团队成员共享呢？
- en: 'We will create a new folder to keep all the files together. If you recall,
    for us to build a Docker image, there is a special file called a Dockerfile. We
    will also create such a file in the directory:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的文件夹来保存所有文件。如果您还记得，为了构建Docker镜像，我们需要一个特殊的文件，称为Dockerfile。我们也将在这个目录中创建这样一个文件：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We will also copy the *host_vars* folder, *ansible.cfg*, *hosts*, and *ios_config_backup.yml*
    files into this folder. We should also make sure the playbook runs as expected
    before we build the Docker container from it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将把`host_vars`文件夹、`ansible.cfg`、`hosts`和`ios_config_backup.yml`文件复制到这个文件夹中。我们还需要确保在从它构建Docker容器之前，playbook能够按预期运行。
- en: 'Docker builds itself in a layered fashion, starting with a base image. In the
    Dockerfile, we will specify the following lines:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Docker以分层的方式构建自身，从基础镜像开始。在Dockerfile中，我们将指定以下行：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The lines starting with a “#” mark are comments, just like in Python. The `FROM`
    keyword specifies the base image we will retrieve from the default Docker Hub.
    All the official Ubuntu images can be found on the site, [https://hub.docker.com/_/ubuntu](https://hub.docker.com/_/ubuntu).
    In the `ENV` statement, we specified no need for interactive prompts.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以“#”开头的行是注释，就像在Python中一样。`FROM`关键字指定了我们将从默认Docker Hub检索的基础镜像。所有官方Ubuntu镜像都可以在网站上找到，[https://hub.docker.com/_/ubuntu](https://hub.docker.com/_/ubuntu)。在`ENV`语句中，我们指定不需要交互式提示。
- en: The Dockerfile reference can be viewed at [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile参考可以在[https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)查看。
- en: 'Let us build this image:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建这个镜像：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `build` command builds from the Dockerfile in the local directory while
    tagging the final image to be `ansible-docker` with version 0.1\. Once completed,
    we can view the image:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`build`命令从本地目录中的Dockerfile构建，并将最终标记为`ansible-docker`的镜像版本为0.1。一旦完成，我们可以查看镜像：'
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If we need to remove an image before the rebuild, we can delete the image with
    “`docker rmi <image id>`.”
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在重建之前需要删除镜像，我们可以使用“`docker rmi <image id>`”删除镜像。
- en: 'We can start the container based on the image:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据镜像启动容器：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It will drop us into the bash shell prompt, and the container will stop itself
    once we exit. In order for it to run in a detached mode, we will need to start
    it with a `"-d"` flag. Let’s go ahead and delete the container and recreate it
    with the flag:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 它将带我们进入bash shell提示符，容器一旦我们退出就会自己停止。为了使其以分离模式运行，我们需要用`"-d"`标志启动它。让我们先删除容器，然后带标志重新创建它：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Remember to substitute your container ID. A nice shortcut to delete all containers
    in one setting is `docker rm -f $(docker ps -a -q)`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 记得替换你的容器ID。一次性删除所有容器的快捷方式是`docker rm -f $(docker ps -a -q)`。
- en: 'The container now runs in detached mode, and we can execute an interactive
    prompt on the container:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 容器现在以分离模式运行，我们可以在容器上执行交互式提示符：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can go ahead and stop the container, then delete it:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以停止容器，然后删除它：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will introduce a few more Dockerfile commands:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍一些更多的Dockerfile命令：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `RUN` command executes the shell commands as if we were typing them in the
    shell. We can specify the working directory as `/app` on the container, then copy
    everything in the current working directory (`host_vars`, hosts, playbook, etc.)
    to the `/app` directory on the remote container.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN`命令执行shell命令，就像我们在shell中输入它们一样。我们可以在容器上指定工作目录为`/app`，然后将当前工作目录中的所有内容（`host_vars`、hosts、playbook等）复制到远程容器的`/app`目录。'
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We will keep the same tag, but if we would like to make it a new release, we
    can always tag it as `v0.2`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保留相同的标签，但如果我们想将其作为新版本发布，我们总是可以将其标记为`v0.2`。
- en: 'We will launch the container again and execute the `ansible-playbook`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次启动容器并执行`ansible-playbook`：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once the container is launched, we can start and stop via the hostname:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦容器启动，我们可以通过主机名来启动和停止：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Congratulations on working through the complete container workflow! This might
    not seem much now, but it is a big step. The steps might seem a bit foreign now,
    but don’t worry, they will become more familiar as we get more practice under
    our belt.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你完成了完整的容器工作流程！现在这看起来可能不多，但这是一个很大的进步。现在这些步骤可能看起来有点陌生，但不用担心，随着我们积累更多的实践经验，它们会变得更加熟悉。
- en: Sharing Docker images
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分享Docker镜像
- en: The last step will be to share the container images. One way to do it would
    be to tar zip the directory and share the file. Another way is to push the image
    to a repository accessible to whoever needs access. Docker Hub is one of the most
    popular repositories, but many others exist. They generally offer several different
    subscription price tiers.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步将是分享容器镜像。一种方法是将目录tar zip并分享文件。另一种方法是推送镜像到任何需要访问的人都可以访问的仓库。Docker Hub是最受欢迎的仓库之一，但还有许多其他仓库。它们通常提供几个不同的订阅价格层。
- en: '![Graphical user interface, application  Description automatically generated](img/B18403_05_02.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B18403_05_02.png)'
- en: 'Figure 5.2: Docker Hub Pricing (source: [https://www.docker.com/pricing/](https://www.docker.com/pricing/))'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：Docker Hub定价（来源：[https://www.docker.com/pricing/](https://www.docker.com/pricing/))
- en: 'Besides sharing the container image, having an accessible repository is crucial
    in a DevOps **CI/CD** (**Continuous Integration/Continuous Delivery**) process.
    For example, we might be checking in the code with an automated build and test
    process. Once all the validation test passes, we can automatically push the image
    to the repository and deploy it to production. We will create a private repository
    on Docker Hub:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 除了共享容器镜像外，在DevOps **CI/CD**（**持续集成/持续交付**）过程中，拥有可访问的仓库至关重要。例如，我们可能会通过自动构建和测试过程提交代码。一旦所有验证测试通过，我们就可以自动将镜像推送到仓库并部署到生产环境。我们将在Docker
    Hub上创建一个私有仓库：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18403_05_03.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序描述自动生成](img/B18403_05_03.png)'
- en: 'Figure 5.3: Docker Hub Repository'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：Docker Hub仓库
- en: 'Then we will log in via the Docker CLI:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将通过Docker CLI进行登录：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Then we can tag the existing image following the remote repository, then push
    toward it. Notice in the output below that the destination tag name matches the
    repository name on Docker Hub. This allows flexibility in local naming while conforming
    to the remote team naming conventions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以根据远程仓库标记现有镜像，然后将其推送到它。注意以下输出中目标标签名称与Docker Hub上的仓库名称匹配。这允许在本地命名时具有灵活性，同时遵守远程团队命名约定。
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Once the image finishes uploading, we can access the image and we can use it
    directly or use it as a base image in another Dockerfile.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦镜像上传完成，我们就可以访问该镜像，可以直接使用它，或者将其用作另一个Dockerfile中的基础镜像。
- en: '![Graphical user interface, application  Description automatically generated](img/B18403_05_04.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B18403_05_04.png)'
- en: 'Figure 5.4: New Uploaded Image'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4：新上传的镜像
- en: In the next section, we will see how to coordinate multi-container setup locally
    during development.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何在开发过程中本地协调多容器设置。
- en: Container orchestration with Docker-compose
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Docker-compose进行容器编排
- en: Modern applications often have interdependencies with each other. For example,
    for a web application, we usually have a “stack” of applications. The popular
    LAMP stack is an acronym denoting Linux, Apache, MySQL, and PHP/Python to specify
    the components required to deliver a web application. In the world of Docker,
    we can use docker-compose ([https://docs.docker.com/compose/](https://docs.docker.com/compose/))
    to specify how multiple containers should be built and run simultaneously.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现代应用程序通常相互依赖。例如，对于Web应用程序，我们通常有一个“堆栈”的应用程序。流行的LAMP堆栈是一个缩写，代表Linux、Apache、MySQL和PHP/Python，用于指定交付Web应用程序所需的组件。在Docker的世界里，我们可以使用docker-compose
    ([https://docs.docker.com/compose/](https://docs.docker.com/compose/))来指定如何同时构建和运行多个容器。
- en: 'If you have installed Docker Desktop for Mac or Windows, docker-compose is
    already included. In the Linux environment, docker-compose needs to be installed
    separately. We will follow DigitalOcean’s guide for docker-compose ([https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-compose-on-ubuntu-22-04](https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-compose-on-ubuntu-22-04)):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经安装了适用于Mac或Windows的Docker Desktop，docker-compose已经包含在内。在Linux环境中，需要单独安装docker-compose。我们将遵循DigitalOcean的指南来安装docker-compose
    ([https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-compose-on-ubuntu-22-04](https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-compose-on-ubuntu-22-04))：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Docker-compose uses a YAML file named `docker-compose.yml` to construct the
    environment. There are lots of knobs to specify different service dependencies,
    persistent volumes, and opening public ports. Let’s put together a simple example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Docker-compose使用名为`docker-compose.yml`的YAML文件来构建环境。有许多旋钮可以指定不同的服务依赖关系、持久卷和打开公共端口。让我们来构建一个简单的示例：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here is what the file specifies:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中指定了以下内容：
- en: The file specifies two services, `ansible` and `db`. Each of the services is
    similar to the `docker run` commands.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件指定了两个服务，`ansible`和`db`。每个服务都与`docker run`命令类似。
- en: The `ansible` service builds with the current Dockerfile in the current working
    directory named `dockerfile`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ansible`服务使用当前工作目录中名为`dockerfile`的当前Dockerfile进行构建。'
- en: We map the host port 5434 to the container port 5434\.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将主机端口5434映射到容器端口5434。
- en: We specify two environmental variables for the Postgres database.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为Postgres数据库指定了两个环境变量。
- en: We use a volume named `db` so that the database information written is persisted
    in the volume.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用名为`db`的卷，以便将写入数据库的信息持久化在卷中。
- en: For more information on Docker-compose, please visit [https://docs.docker.com/compose/](https://docs.docker.com/compose/).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于Docker-compose的信息，请访问[https://docs.docker.com/compose/](https://docs.docker.com/compose/)。
- en: 'We can run the combined service with the *docker-compose* command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`docker-compose`命令运行组合服务：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The services are launched concurrently. We can then tear down both services:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是并发启动的。然后我们可以同时关闭这两个服务：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We have only built simple applications thus far in the book. This might make
    more sense when we learn about building a Web API later in the book. For now,
    it is good to consider how we can launch multiple containers via docker-compose.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书中我们只构建了简单的应用程序。当我们学习本书后面的构建Web API时，这可能会更有意义。现在，考虑一下我们如何通过docker-compose启动多个容器是很好的。
- en: As network engineers, it would be interesting to know how networking is done
    in a Docker environment. That is the subject of the next section.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 作为网络工程师，了解Docker环境中的网络实现方式会很有趣。这就是下一节的主题。
- en: Container networking
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器网络
- en: Container networking is not an easy topic to cover because of its scope and
    the number of technologies it touches. The space spans from Linux networking,
    how the particular type of Linux (Ubuntu, Red Hat, etc.) implements networking,
    to Docker’s implementation of networking. Adding to the complexity is the fact
    that Docker is a fast-moving project, and many third-party plugins are available.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 容器网络不是一个容易涵盖的主题，因为它涉及的范围和触及的技术数量。这个空间从Linux网络，特定类型的Linux（Ubuntu、Red Hat等）如何实现网络，到Docker对网络的实现。增加复杂性的是，Docker是一个快速发展的项目，许多第三方插件都可用。
- en: In this section, we will stick to the basics of the networking options offered
    by Docker by default. We will then briefly explain the options of overlay, Macvlan,
    and network plugins.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将坚持介绍Docker默认提供的网络选项的基本知识。然后我们将简要解释overlay、Macvlan和网络插件选项。
- en: 'When we launch a container, it can reach the internet by default. Let’s do
    a quick test by launching an Ubuntu container and attaching to it:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动一个容器时，它默认可以访问互联网。让我们通过启动一个Ubuntu容器并附加到它来进行快速测试：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can see the host has a private IP different from our host’s IP. It can also
    reach the Ubuntu repository to install software as well as ping the outside network.
    How does it do that? By default, Docker created three types of networks: `bridge`,
    `host`, and `none`. Let’s launch a second Terminal window while keeping the host
    running in the first Terminal window:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到主机有一个与我们的主机IP不同的私有IP。它还可以访问Ubuntu仓库来安装软件以及ping外部网络。它是如何做到这一点的呢？默认情况下，Docker创建了三种类型的网络：`bridge`、`host`和`none`。让我们在保持第一个终端窗口中主机运行的同时，打开第二个终端窗口：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The *none* network option is straightforward. It disables all networking and
    makes the container sit on a network island by itself. This leaves us with the
    `bridge` and `host` options. By default, Docker puts the host in the bridge network,
    `docker0`, with a **virtual Ethernet** (**veth**) interface ([https://man7.org/linux/man-pages/man4/veth.4.html](https://man7.org/linux/man-pages/man4/veth.4.html))
    to allow it to communicate to the internet:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`none`网络选项很简单。它禁用了所有网络，使容器独自坐在一个网络孤岛上。这让我们只剩下`bridge`和`host`选项。默认情况下，Docker将主机放入桥接网络`docker0`，并使用**虚拟以太网**（**veth**）接口（[https://man7.org/linux/man-pages/man4/veth.4.html](https://man7.org/linux/man-pages/man4/veth.4.html)）来允许它与互联网通信：'
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If we launch another container, we will see an additional veth interface created
    and put into the same bridge group. By default, they can communicate with each
    other.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们启动另一个容器，我们会看到创建了一个额外的veth接口，并将其放入相同的桥接组。默认情况下，它们可以相互通信。
- en: Container host network
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器主机网络
- en: 'We can also share the host network with the container. Let’s start an Ubuntu
    container in the host network. We will also install Python 3.10 and other software
    packages:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将主机网络与容器共享。让我们在主机网络中启动一个Ubuntu容器。我们还将安装Python 3.10和其他软件包：
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we check now, we can see the container now shares the same IP as the host
    network. We can create a simple HTML page and start the Python3 built-in web server
    on the container:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在检查，我们可以看到容器现在与主机网络共享相同的IP。我们可以创建一个简单的HTML页面，并在容器上启动Python3内置的Web服务器：
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If we open up the IP address with port 8000 in a browser, we can see the page
    we created!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中打开端口8000的IP地址，我们可以看到我们创建的页面！
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18403_05_05.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序  自动生成的描述](img/B18403_05_05.png)'
- en: 'Figure 5.5: Index Page of Container Host'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5：容器主机索引页
- en: If you have a firewall on your host (such as iptables or ufw) turned on, make
    sure to open up port 8000 so you can see the page.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你主机上（如iptables或ufw）有开启的防火墙，请确保打开端口8000，以便你可以看到页面。
- en: The host network option is useful when we need to expose containers for public
    service.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要公开服务暴露容器时，主机网络选项很有用。
- en: Custom bridge network
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义桥接网络
- en: 'We can also create custom bridge networks and group containers together. We
    will create the network first:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建自定义桥接网络并将容器分组在一起。我们首先创建网络：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can now assign the containers to the custom bridge network:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将容器分配到自定义桥接网络：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The host is now in its custom bridge network. It has network access to the
    public internet and other containers in the same bridge network. If we want to
    expose a particular port to a container in the custom bridge network, we can use
    the `–publish` option to map the port to the `local host`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 主机现在在其自定义桥接网络中。它有权访问公共互联网和同一桥接网络中的其他容器。如果我们想将特定端口公开到自定义桥接网络中的容器，我们可以使用`–publish`选项将端口映射到`本地主机`：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can remove the network via the `docker network rm`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`docker network rm`来删除网络：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The custom network option is great for developing multi-container projects that
    need isolation from each other. Up to this point, we have been looking at networking
    options in a single host. In the next section, we will see the options for inter-host
    communication between containers.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义网络选项非常适合开发需要彼此隔离的多容器项目。到目前为止，我们一直在查看单个主机中的网络选项。在下一节中，我们将看到容器之间主机间通信的选项。
- en: Other container network options
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他容器网络选项
- en: If we look closely at the `docker` `network` `ls` output, we can see the columns
    of `driver` and `scope`. Docker’s network subsystem is pluggable, using drivers.
    The core networking functions were provided by the default drivers of `bridge`,
    `host`, and `none`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细查看`docker` `network` `ls`输出，我们可以看到`driver`和`scope`列。Docker的网络子系统是可插拔的，使用驱动程序。核心网络功能由默认的`bridge`、`host`和`none`驱动程序提供。
- en: 'Other notable drivers are listed below:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 其他值得注意的驱动程序如下所示：
- en: 'Overlay: The overlay network creates a distributed network among multiple Docker
    daemon hosts.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 叠加网络：叠加网络在多个Docker守护进程主机之间创建一个分布式网络。
- en: 'Macvlan: The macvlan network option is meant for applications needing to be
    directly connected to the physical network.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Macvlan：macvlan网络选项旨在为需要直接连接到物理网络的应用程序使用。
- en: 'Third-party network plugins: We can install third-party network plugins ([https://hub.docker.com/search?q=&type=plugin)](https://hub.docker.com/search?q=&type=plugin))
    for additional features. For example, the vSphere-storage plugin ([https://hub.docker.com/r/vmware/vsphere-storage-for-docker](https://hub.docker.com/r/vmware/vsphere-storage-for-docker))
    enables customers to address persistent storage requirements for containers in
    a vSphere environment.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方网络插件：我们可以安装第三方网络插件（[https://hub.docker.com/search?q=&type=plugin](https://hub.docker.com/search?q=&type=plugin)）以获得更多功能。例如，vSphere-storage插件（[https://hub.docker.com/r/vmware/vsphere-storage-for-docker](https://hub.docker.com/r/vmware/vsphere-storage-for-docker)）使客户能够满足vSphere环境中容器的持久存储需求。
- en: An overlay network driver is probably the option we will need to use beyond
    the development stage. It is meant to handle the routing of the packets to and
    from the Docker daemon host and the correct destination container. For example,
    an overlay ingress network would handle the incoming traffic and load balance
    to the correct container. Due to its complexity, this is typically handled by
    the orchestration tool of choice, such as Swarm or Kubernetes. If we use a public
    cloud provider, such as Google Kubernetes Engine, they might even handle this
    overlay network for us.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 叠加网络驱动程序可能是我们将在开发阶段之后需要使用的选项。它的目的是处理数据包在Docker守护进程主机之间以及到正确目标容器的路由。例如，一个叠加入口网络将处理传入流量并将负载均衡到正确的容器。由于其复杂性，这通常由选择的编排工具处理，例如Swarm或Kubernetes。如果我们使用公共云提供商，如Google
    Kubernetes Engine，他们甚至可能为我们处理这个叠加网络。
- en: Containers in the network engineering field
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络工程领域的容器
- en: Container technologies are transforming how infrastructure is built in modern
    days. We now have an additional layer of abstraction we can use to overcome limitations
    on physical space, power, cooling, and other factors. This is especially true
    of the need to move toward more environmentally-friendly data centers.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 容器技术正在改变现代基础设施的建设方式。我们现在有一个额外的抽象层，可以用来克服物理空间、电力、冷却和其他因素的限制。这对于需要向更环保的数据中心过渡的需求尤其如此。
- en: 'There are many new challenges and opportunities associated with the new container-based
    world:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于新容器的世界相关联有许多新的挑战和机遇：
- en: Networking in the container world. As we saw in the last section, there are
    lots of options that exist when it comes to networking in containers.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器世界的网络。正如我们在上一节中看到的，在容器中进行网络有许多选项。
- en: DevOps. One of the challenges when trying to implement DevOps practices in network
    engineering is the lack of options for flexible, virtualized network devices.
    Containers can potentially solve that problem if we can virtualize our network
    along with the hosts.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DevOps。在尝试在网络工程中实施DevOps实践时，一个挑战是缺乏灵活的、虚拟化的网络设备选项。如果我们能够将网络与主机一起虚拟化，容器有潜力解决这个问题。
- en: Lab and Testing. If we can virtualize our network via container images, this
    makes lab and testing much easier.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实验室和测试。如果我们可以通过容器镜像虚拟化网络，这将使实验室和测试变得更加容易。
- en: We will discuss DevOps in *Chapter 12*, *Continuous Integration with**GitLab*;
    in the next section, we will look at a new way to test and run containerized network
    operating systems.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第12章中讨论DevOps，**与GitLab的持续集成**；在下一节中，我们将探讨测试和运行容器化网络操作系统的新方法。
- en: Containerlab
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Containerlab
- en: 'Containerlab ([https://containerlab.dev/](https://containerlab.dev/)) is a
    way to run containerized network operating systems. It is a project started by
    the team at Nokia led by Roman Dodin ([https://twitter.com/ntdvps](https://twitter.com/ntdvps)).
    The team is also responsible for developing **SR Linux** (**Service Router Linux**),
    an open **network operating system** (**NOS**). Although born out of Nokia, Containerlab
    has multi-vendor support with Arista cEOS, Azure SONiC, Juniper cRPD, and many
    others. Let’s do a quick example to illustrate the workflow of Containerlab. To
    install, we can follow the installation steps ([https://containerlab.dev/install/](https://containerlab.dev/install/))
    for Debian-based systems. To isolate the installation, we can create a new directory:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Containerlab ([https://containerlab.dev/](https://containerlab.dev/)) 是运行容器化网络操作系统的一种方式。这是一个由诺基亚团队发起的项目，由Roman
    Dodin领导（[https://twitter.com/ntdvps](https://twitter.com/ntdvps)）。该团队还负责开发**SR
    Linux**（**服务路由器Linux**），一个开源的**网络操作系统**（**NOS**）。尽管起源于诺基亚，Containerlab支持多个厂商，包括Arista
    cEOS、Azure SONiC、Juniper cRPD等。让我们通过一个快速示例来说明Containerlab的工作流程。对于基于Debian的系统，我们可以遵循安装步骤（[https://containerlab.dev/install/](https://containerlab.dev/install/)）进行安装。为了隔离安装，我们可以创建一个新的目录：
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We will define a `clab` file to define the topology, image, and starting configurations.
    There are several example labs under `/etc/containerlab/lab-examples/`. We will
    use the two-node lab example ([https://github.com/srl-labs/containerlab/blob/main/lab-examples/srl02/srl2.cfg](https://github.com/srl-labs/containerlab/blob/main/lab-examples/srl02/srl2.cfg))
    with two SR Linux devices connected over an Ethernet interface. Since SR Linux
    container images can be downloaded over a public repository, this will save us
    the step of needing to download the container image separately. We will call this
    lab topology `srl02.clab.yml`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个`clab`文件来定义拓扑、镜像和起始配置。在`/etc/containerlab/lab-examples/`目录下有多个示例实验室。我们将使用包含两个SR
    Linux设备通过以太网接口连接的两个节点实验室示例（[https://github.com/srl-labs/containerlab/blob/main/lab-examples/srl02/srl2.cfg](https://github.com/srl-labs/containerlab/blob/main/lab-examples/srl02/srl2.cfg)）。由于SR
    Linux容器镜像可以通过公共仓库下载，这将节省我们单独下载容器镜像的步骤。我们将把这个实验室拓扑命名为`srl02.clab.yml`：
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As indicated in the file, the topology consists of nodes and links. The nodes
    are the NOS systems, while the links define how they are connected. The two device
    configuration files are vendor-specific, in this case, SR Linux configurations:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如文件所示，拓扑由节点和链路组成。节点是NOS系统，而链路定义了它们的连接方式。这两个设备配置文件是厂商特定的，在这种情况下，是SR Linux配置：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can now launch the lab with `containerlab` `deploy`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用`containerlab`的`deploy`命令启动实验室：
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Technically, we do not need the `—topo` option to specify a topology. Containerlab
    will look for an `*.clab.y*ml` topology file by default. However, I find it a
    good practice to specify a topology file in case we have several topology files
    in the same directory.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，我们不需要使用 `—topo` 选项来指定拓扑。Containerlab 默认会查找 `*.clab.yml` 拓扑文件。然而，我发现指定一个拓扑文件是一个好的实践，以防我们在同一个目录中有多个拓扑文件。
- en: 'If successful, we will see the device information. The device names are in
    the format of `clab-{ lab name }-{ device name }`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，我们将看到设备信息。设备名称的格式为 `clab-{ 实验室名称 }-{ 设备名称 }`：
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can access the device via `ssh` to the device; the default username and
    passwords are both `admin`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 `ssh` 访问设备；默认用户名和密码都是 `admin`：
- en: '[PRE37]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'A directory is created with the associated files for the lab:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 将创建一个目录，其中包含与实验室相关的文件：
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can also see there is an additional bridge network created with the two
    veth interfaces connected to the bridge network:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到，使用连接到桥接网络的两个 veth 接口创建了一个额外的桥接网络：
- en: '[PRE39]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can tear down the lab with the `containerlab destroy` command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `containerlab destroy` 命令来拆除实验室：
- en: '[PRE40]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: I don’t know about you, but Containerlab is the easiest way to launch a networking
    lab that I have seen. With more vendor support, it might one day become the only
    lab and testing software we need for network testing.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道你们的情况如何，但Containerlab 是我见过的最容易启动网络实验室的方法。随着更多厂商的支持，它可能有一天会成为我们进行网络测试所需的唯一实验室和测试软件。
- en: In the next section, we will briefly discuss the relationship between Docker
    and Kubernetes with a very brief overview of Kubernetes.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将简要讨论 Docker 和 Kubernetes 之间的关系，并对 Kubernetes 进行简要概述。
- en: Docker and Kubernetes
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 和 Kubernetes
- en: As we have seen, Docker images and orchestration can be done with the tools
    provided by the Docker community. However, it is almost impossible to think about
    Docker containers without Kubernetes. This is because when it comes to container
    orchestration, Kubernetes is becoming the de facto standard in doing so. There
    is not enough space to cover Kubernetes in this chapter, but because of its strong
    ties to container orchestration, we should at least know the basics about Kubernetes.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，可以使用 Docker 社区提供的工具进行 Docker 镜像和编排。然而，不提及 Kubernetes 就几乎无法想象 Docker 容器。这是因为当涉及到容器编排时，Kubernetes
    正在成为这一领域的实际标准。在这一章中，没有足够的空间来涵盖 Kubernetes，但由于它与容器编排的紧密联系，我们至少应该了解 Kubernetes 的基础知识。
- en: Kubernetes ([https://kubernetes.io/](https://kubernetes.io/)) was originally
    developed by Google, but the project is now managed by the Cloud Native Computing
    Foundation. It is an open-source container orchestration system that automatically
    deploys, scales, and manages containers. The project was well-received by the
    community right from the beginning since it had a proven track record of scale
    with Google’s internal usage.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes ([https://kubernetes.io/](https://kubernetes.io/)) 最初由 Google 开发，但现在由云原生计算基金会管理。它是一个开源的容器编排系统，可以自动部署、扩展和管理容器。该项目从一开始就得到了社区的广泛欢迎，因为它在
    Google 内部使用中证明了其可扩展性。
- en: Kubernetes uses a master as the controlling unit that manages worker nodes to
    deploy containers. Each worker node can have one or more pods, which are the smallest
    units of units in Kubernetes. The pods are where the containers will be deployed.
    When the containers are deployed, they are generally grouped into different types
    of sets spread across the pods.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 使用主节点作为控制单元来管理工作节点以部署容器。每个工作节点可以有一个或多个 pod，pod 是 Kubernetes 中的最小单元。pod
    是容器部署的地方。当容器部署时，它们通常被分组到分布在 pod 中的不同类型的集合中。
- en: Most public cloud providers (AWS, Azure, Google, and DigitalOcean) offer managed
    Kubernetes clusters that users can try. The Kubernetes documentation ([https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/))
    also offers many tutorials for step-by-step guides to learn more about the technology.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数公共云提供商（AWS、Azure、Google 和 DigitalOcean）都提供用户可以尝试的托管 Kubernetes 集群。Kubernetes
    文档 ([https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)) 也提供了许多教程，用于逐步学习更多关于这项技术的内容。
- en: Summary
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about container virtualization. Containers are similar
    to virtual machines in their ability to isolate computing resources but different
    in the sense that they are lightweight and fast to deploy.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了容器虚拟化。容器在隔离计算资源方面与虚拟机类似，但在轻量级和快速部署方面有所不同。
- en: We saw how to use Docker containers to build Python applications and docker-compose
    to build multi-container applications on a single host.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何使用Docker容器来构建Python应用程序，以及如何使用docker-compose在单个主机上构建多容器应用程序。
- en: Later in the chapter, we learned how networks are constructed with Docker containers
    by using the default bridge, custom bridges, and host options. Containers can
    also help with network operating system testing using the Containerlab project.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们学习了如何通过使用默认桥接、自定义桥接和主机选项来使用Docker容器构建网络。容器还可以通过Containerlab项目帮助进行网络操作系统测试。
- en: In the next chapter, we will look at how we can use Python in network security.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用Python进行网络安全。
- en: Join our book community
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的书籍社区
- en: 'To join our community for this book – where you can share feedback, ask questions
    to the author, and learn about new releases – follow the QR code below:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入本书的社区——在这里您可以分享反馈、向作者提问，并了解新书发布——请扫描下面的二维码：
- en: '[https://packt.link/networkautomationcommunity](https://packt.link/networkautomationcommunity)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/networkautomationcommunity](https://packt.link/networkautomationcommunity)'
- en: '![](img/QR_Code2903617220506617062.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code2903617220506617062.png)'
