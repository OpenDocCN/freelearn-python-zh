- en: Chapter 3. Creating Views with Templates
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。使用模板创建视图
- en: Now that we have our data in an easily accessible format, displaying the information
    in a web page becomes much easier. In this chapter, we will use the included templating
    language for Flask Jinja, to dynamically create HTML from our SQLAlchemy models.
    We will also examine Jinja's methods to automate the creation of HTML and modify
    data for presentation inside a template. Then, the chapter will end with automatically
    creating and validating HTML forms with Jinja.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的数据以一种方便访问的格式呈现，将信息显示在网页上变得更加容易。在本章中，我们将使用Flask Jinja的包含模板语言，从我们的SQLAlchemy模型动态创建HTML。我们还将研究Jinja的方法，自动创建HTML并修改数据以在模板内进行呈现。然后，本章将以使用Jinja自动创建和验证HTML表单结束。
- en: Jinja's syntax
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jinja的语法
- en: '**Jinja** is a templating language written in Python. A **templating language**
    is a simple format that is designed to help automate the creation of documents.
    In any templating language, variables passed to the template replace predefined
    locations in the template. In Jinja, variable substitutions are defined by `{{
    }}`. The `{{ }}` syntax is called a **variable block**. There are also **control
    blocks** defined by `{% %}`, which declare language functions, such as **loops**
    or `if` statements. For example, when the `Post` model from the previous chapter
    is passed to it, we have the following Jinja code:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jinja**是用Python编写的模板语言。**模板语言**是一种旨在帮助自动创建文档的简单格式。在任何模板语言中，传递给模板的变量将替换模板中预定义的位置。在Jinja中，变量替换由`{{}}`定义。`{{}}`语法称为**变量块**。还有由`{%
    %}`定义的**控制块**，它声明语言函数，如**循环**或`if`语句。例如，当从上一章传递给它的`Post`模型时，我们有以下Jinja代码：'
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This produces the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下结果：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The variables displayed in a Jinja template can be any Python type or object,
    as long as they can be converted into a string via the Python function `str()`.
    For example, a dictionary or a list passed to a template can have its attributes
    displayed via:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jinja模板中显示的变量可以是任何Python类型或对象，只要它们可以通过Python函数`str（）`转换为字符串。例如，传递给模板的字典或列表可以通过其属性显示：
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Many programmers prefer to use JavaScript to template and dynamically create
    their HTML documents to take the HTML rendering load off of the server. This will
    not be covered in this chapter as it is an advanced JavaScript topic. However,
    many JavaScript templating engines use the `{{ }}` syntax as well. If you choose
    to combine Jinja and your JavaScript templates defined in your HTML files, then
    wrap the JavaScript templates in the `raw` control block to tell Jinja to ignore
    them:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序员更喜欢使用JavaScript来模板化和动态创建他们的HTML文档，以减轻服务器的HTML渲染负载。本章不会涵盖这个话题，因为这是一个高级的JavaScript话题。然而，许多JavaScript模板引擎也使用`{{}}`语法。如果您选择将Jinja和在HTML文件中定义的JavaScript模板结合在一起，则将JavaScript模板包装在`raw`控制块中，以告诉Jinja忽略它们：
- en: '[PRE3]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Filters
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤器
- en: 'It''s a common mistake to believe that Jinja and Python''s syntax is the same
    because of their similarity. However, there is a lot of differences. As you will
    see in this section, normal Python functions do not really exist. Instead, in
    Jinja, variables can be passed to built-in functions that modify the variables
    for display purposes. These functions, named filters, are called in the variable
    block with the pipe character `|`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 认为Jinja和Python的语法是相同的是一个常见的错误，因为它们相似。然而，它们之间有很多不同之处。正如您将在本节中看到的，普通的Python函数实际上并不存在。相反，在Jinja中，变量可以传递给修改变量以供显示目的的内置函数。这些函数，称为过滤器，使用管道字符`|`在变量块中调用：
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Otherwise, if no arguments are passed to the filter, the parentheses can be
    omitted as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果没有向过滤器传递参数，则可以省略括号，如下所示：
- en: '[PRE5]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Filters can also be called control blocks to apply them to blocks of text:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器也可以被称为控制块，以将它们应用于文本块：
- en: '[PRE6]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There are many filters in Jinja; this book will cover only the most useful filters.
    For the sake of brevity, in each example, the output of each filter will be listed
    directly beneath the filter itself.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja中有许多过滤器；本书将仅涵盖最有用的过滤器。为了简洁起见，在每个示例中，每个过滤器的输出将直接列在过滤器本身下面。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For a full list of all the default filters in Jinja, visit [http://jinja.pocoo.org/docs/dev/templates/#list-of-builtin-filters](http://jinja.pocoo.org/docs/dev/templates/#list-of-builtin-filters).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Jinja中所有默认过滤器的完整列表，请访问[http://jinja.pocoo.org/docs/dev/templates/#list-of-builtin-filters](http://jinja.pocoo.org/docs/dev/templates/#list-of-builtin-filters)。
- en: default
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认
- en: 'If the passed variable is `None`, then replace it with a default value as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递的变量是`None`，则将其替换为默认值，如下所示：
- en: '[PRE7]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you wish to replace the variable with the default value and if the variable
    evaluates to `False`, then pass `True` to the optional second parameter:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望用默认值替换变量，并且如果变量求值为`False`，则将可选的第二个参数传递给`True`：
- en: '[PRE8]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: escape
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逃脱
- en: 'If the passed variable is a string of HTML, the `&`, `<`, `>`, `''`, and `"`
    characters will be printed as HTML escape sequences:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递的变量是HTML字符串，则将打印`&`，`<`，`>`，`'`和`"`字符作为HTML转义序列：
- en: '[PRE9]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: float
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: float
- en: 'This converts the passed value to a floating point number with the Python `float()`
    function as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用Python的`float（）`函数将传递的值转换为浮点数，如下所示：
- en: '[PRE10]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: int
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整数
- en: 'This converts the passed value to an integer with the Python `int()` function
    as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用Python的`int（）`函数将传递的值转换为整数，如下所示：
- en: '[PRE11]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: join
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接
- en: 'This is a filter that joins elements of a list with a string and works exactly
    same as the `list` method of the same name. It is given as:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用字符串和字符串列表的元素连接的过滤器，与相同名称的`list`方法完全相同。它被给定为：
- en: '[PRE12]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: length
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 长度
- en: 'This is a filter that fills the same role as the Python `len()` function. It
    is given as:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个填充与Python `len（）`函数相同作用的过滤器。它被给定为：
- en: '[PRE13]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: round
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 圆
- en: 'This rounds off a float to the specified precision:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这将四舍五入浮点数到指定的精度：
- en: '[PRE14]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You may also specify how you want the number to be rounded off:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以指定要将数字舍入到的方式：
- en: '[PRE15]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `common` option rounds like a person would: anything at or above 0.5 is
    rounded up, and anything less than 0.5 is rounded down. The `floor` option always
    rounds the number down, and the `ceil` option always rounds up, regardless of
    the decimal.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`common`选项像人一样四舍五入：大于或等于0.5的四舍五入，小于0.5的舍去。`floor`选项总是向下舍入数字，`ceil`选项总是向上舍入，不考虑小数。'
- en: safe
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: safe
- en: 'If you try to insert HTML into your page from a variable, for example, when
    you wish to display a blog post, Jinja will automatically try to add HTML escape
    sequences to the output. Look at the following example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试从变量插入HTML到你的页面中，例如，当你希望显示一个博客文章时，Jinja将自动尝试向输出添加HTML转义序列。看下面的例子：
- en: '[PRE16]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is a necessary security feature. When an application has inputs that allow
    users to submit arbitrary text, it allows a malicious user to input HTML code.
    For example, if a user were to submit a script tag as a comment and Jinja didn't
    have this feature, the script would be executed on all the browsers that visited
    the page.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个必要的安全功能。当应用程序具有允许用户提交任意文本的输入时，它允许恶意用户输入HTML代码。例如，如果用户提交一个脚本标签作为评论，而Jinja没有这个功能，该脚本将在访问页面的所有浏览器上执行。
- en: 'However, we still need a way to display HTML that we know is safe to show,
    such as the HTML of our blog posts. We can achieve this using the `safe` filter
    as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们仍然需要一种方法来显示我们知道是安全的HTML，比如我们博客文章的HTML。我们可以使用`safe`过滤器来实现这一点，如下所示：
- en: '[PRE17]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: title
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: title
- en: 'We capitalize a string using title case format as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用标题格式来大写字符串，如下所示：
- en: '[PRE18]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: tojson
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: tojson
- en: We can pass the variable to the Python `json.dumps` function. Remember that
    your passed object must be serializable by the `json` module.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将变量传递给Python的`json.dumps`函数。请记住，你传递的对象必须是`json`模块可序列化的。
- en: '[PRE19]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This feature is most commonly used to pass SQLAlchemy models to JavaScript
    MVC frameworks on page load rather than waiting for an AJAX request. If you use
    `tojson` in this way, remember to pass the result to the `safe` filter as well
    to make sure that you don''t get HTML escape sequences in your JavaScript. Here
    is an example with a `Backbone.js`, a popular JavaScript MVC framework, collection
    of models:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能最常用于在页面加载时将SQLAlchemy模型传递给JavaScript MVC框架，而不是等待AJAX请求。如果你以这种方式使用`tojson`，请记住也将结果传递给`safe`过滤器，以确保你的JavaScript中不会出现HTML转义序列。以下是一个使用`Backbone.js`的示例，这是一个流行的JavaScript
    MVC框架，包含了一系列模型：
- en: '[PRE20]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: truncate
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: truncate
- en: 'This takes a long string and returns a string cutoff at the specified length
    in characters and appends an ellipses:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这将获取一个长字符串，并返回指定长度的字符串，并附加省略号：
- en: '[PRE21]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'By default, any words that are cut in the middle are discarded. To disable
    this, pass `True` as an extra parameter:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，任何在中间被截断的单词都会被丢弃。要禁用这一点，作为额外参数传递`True`：
- en: '[PRE22]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Custom filters
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义过滤器
- en: 'Adding your own filter into Jinja is as simple as writing a Python function.
    To understand custom filters, we will look at an example. Our simple filter will
    count the number of occurrences of a substring in a string and return it. Look
    at the following call:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 将自己的过滤器添加到Jinja中就像编写Python函数一样简单。为了理解自定义过滤器，我们将看一个例子。我们的简单过滤器将计算字符串中子字符串的出现次数并返回它。看下面的调用：
- en: '[PRE23]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This will be changed to:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将被更改为：
- en: '[PRE24]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can define our filter as:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义我们的过滤器如下：
- en: '[PRE25]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To add this function to the list of available filters, we have to manually
    add it to the `filters` dictionary of the `jinja_env` object in our `main.py`
    file:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此功能添加到可用过滤器列表中，我们必须手动将其添加到`main.py`文件中`jinja_env`对象的`filters`字典中：
- en: '[PRE26]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Comments
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释
- en: 'Comments in the template are defined by `{# #}`, will be ignored by Jinja,
    and will not be in the returned HTML code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '模板中的注释由`{# #}`定义，将被Jinja忽略，并不会出现在返回的HTML代码中：'
- en: '[PRE27]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: if statements
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if语句
- en: '`if` statements in Jinja are similar to Python''s `if` statements. Anything
    that returns, or is, a Boolean determines the flow of the code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja中的`if`语句类似于Python的`if`语句。任何返回或是布尔值的东西决定了代码的流程：
- en: '[PRE28]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Filters can also be used in `if` statements:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器也可以用在`if`语句中：
- en: '[PRE29]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Loops
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环
- en: 'We can use loops in Jinja to iterate over any list or generator function:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Jinja中使用循环来迭代任何列表或生成器函数：
- en: '[PRE30]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Loops and `if` statements can be combined to mimic the `break` functionality
    in Python loops. In this example, the loop will only use the post `if post.text`
    is not `None`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 循环和`if`语句可以结合使用，以模仿Python循环中的`break`功能。在这个例子中，只有当`post.text`不是`None`时，循环才会使用`post`：
- en: '[PRE31]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Inside the loop, you have access to a special variable named `loop`, which
    gives you access to information about the `for` loop. For example, if we want
    to know the current index of the current loop to emulate the `enumerate` function
    in Python, we may use the index variable of the loop variable as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内，你可以访问一个名为`loop`的特殊变量，它可以让你访问有关`for`循环的信息。例如，如果我们想知道当前循环的当前索引以模拟Python中的`enumerate`函数，我们可以使用循环变量的索引变量，如下所示：
- en: '[PRE32]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This will produce the following output:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE33]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'All the variables and functions that the `loop` object exposes are listed in
    the following table:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`loop`对象公开的所有变量和函数在下表中列出：'
- en: '| Variable | Description |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `loop.index` | The current iteration of the loop (1 indexed) |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `loop.index` | 循环的当前迭代（从1开始索引）|'
- en: '| `loop.index0` | The current iteration of the loop (0 indexed) |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `loop.index0` | 循环的当前迭代（从0开始索引）|'
- en: '| `loop.revindex` | The number of iterations from the end of the loop (1 indexed)
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `loop.revindex` | 距离循环末尾的迭代次数（从1开始索引）|'
- en: '| `loop.revindex0` | The number of iterations from the end of the loop (0 indexed)
    |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `loop.revindex0` | 距离循环末尾的迭代次数（从0开始索引）|'
- en: '| `loop.first` | True if the current item is first in the iterator |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `loop.first` | 如果当前项目是迭代器中的第一个，则为True |'
- en: '| `loop.last` | True if the current item is last in the iterator |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `loop.last` | 如果当前项目是迭代器中的最后一个，则为True |'
- en: '| `loop.length` | The number of items in the iterator |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `loop.length` | 迭代器中的项目数 |'
- en: '| `loop.cycle` | The helper function to cycle between the items in the iterator,
    which is explained later |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `loop.cycle` | 用于在迭代器中循环的辅助函数，稍后会解释 |'
- en: '| `loop.depth` | Indicates how deep in a recursive loop the loop currently
    is (starts at level 1) |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `loop.depth` | 表示递归循环中当前循环的深度（从级别1开始） |'
- en: '| `loop.depth0` | Indicates how deep in a recursive loop the loop currently
    is (starts at level 0) |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `loop.depth0` | 表示递归循环中当前循环的深度（从级别0开始） |'
- en: 'The `cycle` function is a function that goes through an iterator one item at
    a time at every loop. We may use the previous example to demonstrate:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`cycle`函数是一个在每次循环时逐个遍历迭代器的函数。我们可以使用前面的示例来演示： '
- en: '[PRE34]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This will output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出：
- en: '[PRE35]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Macros
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 宏
- en: 'A **macro** is best understood as a function in Jinja that returns a template
    or HTML string. This is used to avoid code that is repeated over and over again
    and reduce it to one function call. For example, the following is a macro to add
    a Bootstrap CSS input and a label to your template:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**宏**最好理解为Jinja中返回模板或HTML字符串的函数。这用于避免重复的代码，并将其减少到一个函数调用。例如，以下是一个用于在模板中添加Bootstrap
    CSS输入和标签的宏：'
- en: '[PRE36]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now to quickly add an input to a form in any template, call your macro using
    the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要在任何模板中快速添加输入到表单，使用以下方式调用您的宏：
- en: '[PRE37]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This will output:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出：
- en: '[PRE38]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Flask-specific variables and functions
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flask特定的变量和函数
- en: Flask makes several functions and objects available to you by default in your
    template.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Flask在模板中默认提供了几个函数和对象。
- en: config
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: config
- en: 'Flask makes the current `config` object available in templates:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Flask在模板中提供了当前的`config`对象：
- en: '[PRE39]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: request
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: request
- en: This is the Flask `request` object for the current request.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Flask的`request`对象，用于当前请求。
- en: '[PRE40]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: session
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: session
- en: 'The Flask `session` object is:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Flask的`session`对象是：
- en: '[PRE41]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: url_for()
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: url_for()
- en: The `url_for` function returns the URL of a route by giving the route function
    name as a parameter. This allows URLs to be changed without worrying about where
    links will break.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`url_for`函数通过将路由函数名称作为参数返回路由的URL。这允许更改URL而不必担心链接会断开。'
- en: '[PRE42]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If we had a route that had positional arguments in the URL, we pass them as
    `kwargs`. They will be filled in for us in the resulting URL as:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个在URL中有位置参数的路由，我们将它们作为`kwargs`传递。它们将在生成的URL中为我们填充：
- en: '[PRE43]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: get_flashed_messages()
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: get_flashed_messages()
- en: This returns a list of all the messages passed through the `flash()` function
    in Flask. The `flash` function is a simple function that queues messages, which
    are just Python strings, for the `get_flashed_messages` function to consume.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回通过Flask中的`flash()`函数传递的所有消息的列表。`flash`函数是一个简单的函数，用于排队消息，这些消息只是Python字符串，供`get_flashed_messages`函数消耗。
- en: '[PRE44]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Creating our views
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的视图
- en: To get started, we need to create a new folder named `templates`, in our project
    directory. This folder will store all of our Jinja files, which are just HTML
    files with Jinja syntax mixed in. Our first template will be our home page, which
    will be a list of the first 10 posts with summaries. There will also be a view
    for a post that will just show the post content, comments on the page, links to
    the author user page, and links to tag pages. There will also be user and tag
    pages that show all the posts by a user and all the posts with a specific tag.
    Each page will also have a sidebar showing the five most recent posts and the
    top five most used tags.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要在项目目录中创建一个名为`templates`的新文件夹。该文件夹将存储所有的Jinja文件，这些文件只是带有Jinja语法的HTML文件。我们的第一个模板将是我们的主页，它将是前10篇帖子的摘要列表。还将有一个用于显示帖子内容、页面上的评论、作者用户页面的链接和标签页面的链接的帖子视图。还将有用户和标签页面，显示用户的所有帖子和具有特定标签的所有帖子。每个页面还将有一个侧边栏，显示最近的五篇帖子和使用最多的五个标签。
- en: The view function
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图函数
- en: 'Because each page will have the same sidebar information, we can break that
    into a separate function to simplify our code. In the `main.py` file, add the
    following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个页面都会有相同的侧边栏信息，我们可以将其拆分为一个单独的函数，以简化我们的代码。在`main.py`文件中，添加以下代码：
- en: '[PRE45]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The most recent posts query is straight forward, but the most popular tags query
    looks somewhat familiar, yet a little odd. This is a bit beyond the scope of this
    book, but using the SQLAlchemy `func` library to return a count, we are able to
    order our tags by the most used tags. The `func` function is explained in detail
    at [http://docs.sqlalchemy.org/en/rel_1_0/core/sqlelement.html#sqlalchemy.sql.expression.func](http://docs.sqlalchemy.org/en/rel_1_0/core/sqlelement.html#sqlalchemy.sql.expression.func).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最近的帖子查询很直接，但最受欢迎的标签查询看起来有些熟悉，但有点奇怪。这有点超出了本书的范围，但使用SQLAlchemy的`func`库返回计数，我们可以按最常用的标签对标签进行排序。`func`函数在[http://docs.sqlalchemy.org/en/rel_1_0/core/sqlelement.html#sqlalchemy.sql.expression.func](http://docs.sqlalchemy.org/en/rel_1_0/core/sqlelement.html#sqlalchemy.sql.expression.func)中有详细说明。
- en: 'The home page function in `main.py` will need all the posts in a pagination
    object and the sidebar information:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.py`中的主页函数将需要一个分页对象中的所有帖子和侧边栏信息：'
- en: '[PRE46]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here, we finally see how Flask and Jinja tie together. The Flask function `render_template`
    takes the name of a file in the folder templates and passes all the `kwargs` to
    the template as variables. Also, our `home` function now has multiple routes to
    handle pagination and will default to the first page if there is nothing after
    the slash.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们终于看到了Flask和Jinja是如何联系在一起的。Flask函数`render_template`接受模板文件夹中的文件名，并将所有`kwargs`作为变量传递给模板。另外，我们的`home`函数现在有多个路由来处理分页，并且如果斜杠后面没有内容，将默认显示第一页。
- en: 'Now that you have all the pieces of knowledge that you need to write view functions,
    I challenge you to try to write the rest of the view functions based on the preceding
    descriptions. After you have tried, compare your results to the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经掌握了编写视图函数所需的所有知识，我挑战您尝试根据前面的描述编写其余的视图函数。尝试后，将您的结果与以下内容进行比较：
- en: '[PRE47]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: After all of your views are written, the only thing left to do is to write the
    templates.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写所有视图之后，唯一剩下的事情就是编写模板。
- en: Writing the templates and inheritance
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写模板和继承
- en: Because this book does not focus on interface design, we will use the CSS library
    Bootstrap and avoid writing custom CSS. If you have never used it before, **Bootstrap**
    is a set of default CSS rules that make your website work well across all browsers
    and has tools that allow you to easily control the layout of your website. To
    download Bootstrap, go to [http://getbootstrap.com/](http://getbootstrap.com/)
    and hit the button that says **Download Bootstrap**. Hit another button that says
    **Download Bootstrap** and you will start to download a Zip file. Unzip this file
    into your project directory and rename the folder to `static`. The `static` folder
    must be at the same directory level as the `main.py` file for Flask to automatically
    find the files. From now on, this is where we will keep our CSS, font, images,
    and JavaScript files.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因为本书不专注于界面设计，我们将使用CSS库Bootstrap，并避免编写自定义CSS。如果你以前没有使用过，**Bootstrap**是一组默认的CSS规则，可以使你的网站在所有浏览器上运行良好，并具有工具，可以轻松控制网站的布局。要下载Bootstrap，转到[http://getbootstrap.com/](http://getbootstrap.com/)，点击**下载Bootstrap**按钮。再点击另一个按钮**下载Bootstrap**，你将开始下载一个Zip文件。将此文件解压缩到你的项目目录，并将文件夹重命名为`static`。`static`文件夹必须与`main.py`文件在同一目录级别，Flask才能自动找到这些文件。从现在开始，我们将在这里保存我们的CSS、字体、图像和JavaScript文件。
- en: 'Because every route will have a template assigned to it, each template will
    need the requisite HTML **boilerplate** code with our meta information, style
    sheets, common JavaScript libraries, and so on. To keep our templates **DRY**
    (**Don''t Repeat Yourself**), we will use one of the most powerful features of
    Jinja, template inheritance. **Template inheritance** is when a child template
    can import a base template as a starting point and only replace marked sections
    in the base. To start our base template, we need a basic HTML skeleton as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个路由都将有一个分配给它的模板，每个模板都需要具有我们的元信息、样式表、常用JavaScript库等的必需HTML **样板**代码。为了保持我们的模板**DRY**（**不要重复自己**），我们将使用Jinja最强大的功能之一，模板继承。**模板继承**是指子模板可以导入基础模板作为起点，并只替换基础模板中标记的部分。要开始我们的基础模板，我们需要一个基本的HTML骨架如下：
- en: '[PRE48]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Save this as `base.html` in your `templates` directory. The `block` control
    block is used in inheritance to mark sections to be replaceable by the child template.
    Because we will use pagination in several different pages, let''s create a macro
    to render a pagination widget:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 将其保存为`base.html`在你的`templates`目录中。`block`控制块在继承中用于标记可以由子模板替换的部分。因为我们将在几个不同的页面中使用分页，让我们创建一个宏来渲染一个分页小部件：
- en: '[PRE49]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This macro takes a Flask SQLAlchemy pagination object and a view function name
    and constructs a Bootstrap list of page links. Add this to the top of `base.html`
    so that all the pages that inherit from it will have access to it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏接受一个Flask SQLAlchemy分页对象和一个视图函数名称，并构建一个Bootstrap页面链接列表。将其添加到`base.html`的顶部，以便所有从中继承的页面都可以访问它。
- en: The home page template
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主页模板
- en: 'To inherit a template, the `extends` control block is used:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要继承一个模板，使用`extends`控制块：
- en: '[PRE50]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This template will use all the HTML `base.html` but replace the data in the
    `title` block. If we do not declare a `title` block, the content in `base.html`
    would remain unchanged. Save this template as `index.html`. Now we can see this
    in action. Open `http://127.0.0.1:5000/` on your browser and you should see the
    following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板将使用所有HTML `base.html`，但替换`title`块中的数据。如果我们不声明一个`title`块，`base.html`中的内容将保持不变。将此模板保存为`index.html`。现在我们可以看到它的效果。在浏览器中打开`http://127.0.0.1:5000/`，你应该会看到以下内容：
- en: '![The home page template](img/B03929_03_01.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![主页模板](img/B03929_03_01.jpg)'
- en: 'At this point, it is easier to develop and mock UIs if you have representative
    fake data. Because we only have two posts and manually adding a large amount of
    models from the command line is tedious (which we shall fix in [Chapter 10](ch10.html
    "Chapter 10. Useful Flask Extensions"), *Useful Flash Extensions*), let''s use
    the following script to add 100 example posts:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，如果你有代表性的假数据，开发和模拟UI会更容易。因为我们只有两篇文章，手动从命令行添加大量模型是繁琐的（我们将在[第10章](ch10.html
    "第10章。有用的Flask扩展")中解决这个问题，*有用的Flask扩展*），让我们使用以下脚本添加100个示例文章：
- en: '[PRE51]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This script is simple for loop that sets all the attributes of a new post and
    randomizes what tags the post has. Now, to begin developing our templates in earnest,
    we will start by adding the following to the home page: summaries of our blog
    posts with links, the most recent blog posts, and the most commonly used tags.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本是一个简单的循环，设置一个新文章的所有属性，并随机确定文章的标签。现在，为了认真地开发我们的模板，我们将从主页开始添加以下内容：博客文章的摘要和链接，最近的博客文章，以及最常用的标签。
- en: 'Now, let''s add our content to `home.html`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将内容添加到`home.html`中：
- en: '[PRE52]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: All the other pages will take this general form of content in the middle with
    a sidebar of links to popular content.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他页面将采用这种中间内容一般形式，侧边栏链接到热门内容。
- en: Writing the other templates
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写其他模板
- en: Now that you know the ins and outs of inheritance and you know which data is
    going to go to each template, I will pose the same challenge as the previous section.
    Try to write the content sections of the remaining templates. After finishing
    it, you should be able to freely navigate around your blog, click on posts, and
    view user pages. There is one final bit of functionality to add in this chapter—the
    ability for readers to add comments.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了继承的各个方面，也知道了哪些数据将会放到每个模板中，我将提出与上一节相同的挑战。尝试编写剩余模板的内容部分。完成后，你应该能够自由地浏览你的博客，点击文章并查看用户页面。在本章中还有一个最后的功能要添加——读者添加评论的能力。
- en: Flask WTForms
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flask WTForms
- en: 'Adding forms in your application seems to be an easy task, but when you start
    coding the server-side code, the task of validating user input grows bigger and
    bigger as the form becomes more complex. Security is paramount as the data is
    from an untrustworthy source and is going to be entered in the database. **WTForms**
    is a library that handles server form validation for you by checking input against
    common form types. Flask WTForms is a Flask extension on top of WTForms that add
    features, such as Jinja HTML rendering, and protects you against attacks, such
    as **SQL injection** and **cross-site request forgery**. To install Flask WTForms
    and WTForms, we have:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中添加表单似乎是一项简单的任务，但当您开始编写服务器端代码时，随着表单变得更加复杂，验证用户输入的任务变得越来越大。安全性至关重要，因为数据来自不可信任的来源，并将被输入到数据库中。**WTForms**是一个库，通过检查输入与常见表单类型进行验证，来处理服务器端表单验证。Flask
    WTForms是在WTForms之上的Flask扩展，它添加了功能，如Jinja HTML渲染，并保护您免受**SQL注入**和**跨站请求伪造**等攻击。要安装Flask
    WTForms和WTForms，我们有：
- en: '[PRE53]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Protecting yourself against SQL injection and cross-site request forgery is
    extremely important, as these are the most common forms of attacks your website
    will receive. To learn more about these attacks, visit [https://en.wikipedia.org/wiki/SQL_injection](https://en.wikipedia.org/wiki/SQL_injection)
    and [https://en.wikipedia.org/wiki/Cross-site_request_forgery](https://en.wikipedia.org/wiki/Cross-site_request_forgery)
    for SQL injection and cross-site request forgery, respectively.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 保护自己免受SQL注入和跨站请求伪造是非常重要的，因为这些是您的网站将接收到的最常见的攻击形式。要了解更多关于这些攻击的信息，请访问[https://en.wikipedia.org/wiki/SQL_injection](https://en.wikipedia.org/wiki/SQL_injection)和[https://en.wikipedia.org/wiki/Cross-site_request_forgery](https://en.wikipedia.org/wiki/Cross-site_request_forgery)分别了解SQL注入和跨站请求伪造。
- en: 'To have Flask WTForms'' security measures working properly, we will need a
    secret key. A **secret key** is a random string of characters that will be used
    to cryptographically sign anything that needs to be tested for its authenticity.
    This cannot be any string; it must be randomized to avoid weakening the strength
    of the security protections. To generate a random string, type the following into
    Bash:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使Flask WTForms的安全措施正常工作，我们需要一个秘钥。**秘钥**是一个随机的字符串，将用于对需要进行真实性测试的任何内容进行加密签名。这不能是任何字符串；它必须是随机的，以避免削弱安全保护的强度。要生成一个随机字符串，请在Bash中输入以下内容：
- en: '[PRE54]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If you are using Mac, type the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Mac，请输入以下内容：
- en: '[PRE55]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Add the output in `config.py` on the `Config` object:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Config`对象的`config.py`中添加输出：
- en: '[PRE56]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: WTForms basics
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WTForms基础
- en: 'There are three main parts of WTForms—**forms**, **fields**, and **validators**.
    Fields are representations of input fields and do rudimentary type checking, and
    validators are functions attached to fields that make sure that the data submitted
    in the form is within our constraints. The form is a class that contains fields
    and validators and validates itself on a `POST` request. Let''s see this in action
    to get a better idea. In the `main.py` file, add the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: WTForms有三个主要部分——**表单**、**字段**和**验证器**。字段是输入字段的表示，并进行基本的类型检查，验证器是附加到字段的函数，确保表单中提交的数据在我们的约束范围内。表单是一个包含字段和验证器的类，并在`POST`请求时对自身进行验证。让我们看看这个过程，以便更好地理解。在`main.py`文件中添加以下内容：
- en: '[PRE57]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here we have a class that inherits from Flask WTForm''s `Form` object and defines
    inputs with class variables that equal WTForm fields. The fields take an optional
    parameter `validators`, a list of WTForm validators that will be applied to our
    data. The most commonly used fields are:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有一个从Flask WTForm的`Form`对象继承的类，并使用等于WTForm字段的类变量定义输入。字段接受一个可选参数`validators`，这是一个将应用于我们数据的WTForm验证器列表。最常用的字段有：
- en: '`fields.DateField`'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields.DateField`'
- en: This represents a Python `Date` object and takes an optional parameter format
    that takes a `stftime` format string to translate the data.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这代表了一个Python `Date`对象，并接受一个可选参数格式，该格式采用`stftime`格式字符串来翻译数据。
- en: '`fields.IntegerField`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields.IntegerField`'
- en: This attempts to coerce passed data to an integer and is rendered in the template
    as a number input.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这尝试将传递的数据强制转换为整数，并在模板中呈现为数字输入。
- en: '`fields.FloatField`'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields.FloatField`'
- en: This attempts to coerce passed data to a float and is rendered in the template
    as a number input.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这尝试将传递的数据强制转换为浮点数，并在模板中呈现为数字输入。
- en: '`fields.RadioField`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields.RadioField`'
- en: This represents a set of radio inputs and takes a parameter `choices`, that
    is, a list of tuples that act as the displayed value and the returned value.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这代表了一组单选输入，并接受一个`choices`参数，即一个元组列表，作为显示值和返回值。
- en: '`fields.SelectField`'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields.SelectField`'
- en: Along with `SelectMultipleField`, it represents a set of radio inputs. Takes
    a parameter `choices`, that is, a list of tuples that act as the displayed and
    returned values.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 与`SelectMultipleField`一起，它代表一组单选输入。接受一个`choices`参数，即一个元组列表，作为显示值和返回值。
- en: '`fields.StringField`'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields.StringField`'
- en: This represents a normal text input and will attempt to coerce the returned
    data to a string.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这代表了一个普通的文本输入，并将尝试将返回的数据强制转换为字符串。
- en: Note
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For a full list of validators and fields, visit the WTForms documentation at
    [http://wtforms.readthedocs.org](http://wtforms.readthedocs.org).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 有关验证器和字段的完整列表，请访问WTForms文档[http://wtforms.readthedocs.org](http://wtforms.readthedocs.org)。
- en: 'The most common validators are as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的验证器如下：
- en: '`validators.DataRequired()`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validators.DataRequired()`'
- en: '`validators.Email()`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validators.Email()`'
- en: '`validators.Length(min=-1, max=-1)`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validators.Length(min=-1, max=-1)`'
- en: '`validators.NumberRange(min=None, max=None)`'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validators.NumberRange(min=None, max=None)`'
- en: '`validators.Optional()`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validators.Optional()`'
- en: '`validators.Regexp(regex)`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validators.Regexp(regex)`'
- en: '`validators.URL()`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validators.URL()`'
- en: Each of these validations follows the Pythonic naming scheme. Therefore, they
    are rather straight forward on what they do. All validators take an optional parameter
    named `message`, which is the error message that will be returned if the validator
    fails. If message is not set, it uses same defaults.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这些验证都遵循Python的命名方案。因此，它们对于它们的功能是相当直接的。所有验证器都接受一个名为`message`的可选参数，这是验证器失败时将返回的错误消息。如果未设置消息，则使用相同的默认值。
- en: Custom validators
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义验证器
- en: 'Writing a custom validation function is very simple. All that is required is
    to write a function that takes the `form` object and the `field` object as parameters
    and raises a WTForm.`ValidationError` if the data does not pass the test. Here
    is an example of a custom e-mail validator:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 编写自定义验证函数非常简单。所需的只是编写一个函数，该函数以“form”对象和“field”对象作为参数，并在数据未通过测试时引发WTForm.`ValidationError`。以下是一个自定义电子邮件验证器的示例：
- en: '[PRE58]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: To use this function, just add it to the list of validators for your field.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此函数，只需将其添加到字段的验证器列表中。
- en: Posting comments
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布评论
- en: 'Now that we have our comment form and we understand how to build it, we need
    to add it to the start of our post view:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了评论表单，并且了解了如何构建它，我们需要将其添加到我们的帖子视图的开头：
- en: '[PRE59]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'First, we add the `POST` method to the list of allowed method to our view.
    Then, a new instance of our form object is created. The `validate_on_submit()`
    method then checks whether the Flask request is a `POST` request. If it is a `POST`
    request, it sends the request form data to the form object. If the data is validated,
    then `validate_on_submit()` returns `True` and adds the data to the `form` object.
    We then take the data from each field, populate a new comment, and add it to the
    database. Finally, we add the form to the variable to be sent to the template,
    so we can add the form to our `post.html` file:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将“POST”方法添加到视图的允许方法列表中。然后，创建一个新的表单对象实例。然后，“validate_on_submit（）”方法检查Flask请求是否为“POST”请求。如果是“POST”请求，则将请求表单数据发送到表单对象。如果数据经过验证，那么“validate_on_submit（）”将返回“True”并将数据添加到“form”对象中。然后，我们从每个字段中获取数据，填充一个新的评论，并将其添加到数据库中。最后，我们将表单添加到要发送到模板的变量中，以便将表单添加到我们的“post.html”文件中：
- en: '[PRE60]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: There are several new things happing here. First, the `form.hidden_tag()` method
    adds an anti-cross-site request forgery measure automatically. Second, the `field.errors`
    list is used to render any messages that our validators send if validation fails.
    Third, calling the field itself as a method will render the HTML code of that
    field. Finally, calling `field.label` will automatically create an HTML label
    for our input. Now, adding information to the fields and pressing the submit button
    should add your comment!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了几件新事情。首先，“form.hidden_tag（）”方法会自动添加一个反跨站请求伪造措施。其次，“field.errors”列表用于呈现我们的验证器在验证失败时发送的任何消息。第三，调用字段本身作为方法将呈现该字段的HTML代码。最后，调用“field.label”将自动为我们的输入创建一个HTML标签。现在，向字段添加信息并按下提交按钮应该会添加您的评论！
- en: 'This would look like the following screenshot:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这将看起来像以下的屏幕截图：
- en: '![Posting comments](img/B03929_03_02.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![发布评论](img/B03929_03_02.jpg)'
- en: One final challenge for the reader is to make a macro that takes a `form` object
    and an endpoint to send the `POST` request to and autogenerate HTML for the entire
    form tag. Refer to the WTForms documents if you get stuck. It's tricky, but not
    too difficult.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 读者的最后一个挑战是制作一个宏，该宏接受一个“form”对象和一个要发送“POST”请求的端点，并自动生成整个表单标记的HTML。如果遇到困难，请参考WTForms文档。这有点棘手，但不是太难。
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Now, after only three chapters, you already have a fully functional blog. This
    is where a lot of books on web development technologies would end. However, there
    are still 10 more chapters to go to turn your utilitarian blog into something
    that a user would actually use for their website. In the next chapter, we will
    focus on structuring Flask apps to accommodate long-term development and larger
    scale projects.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，仅仅三章之后，您已经拥有了一个完全功能的博客。这是很多关于Web开发技术的书籍会结束的地方。然而，还有10章要去将您的实用博客转变为用户实际用于其网站的东西。在下一章中，我们将专注于构建Flask应用程序以适应长期开发和更大规模的项目。
