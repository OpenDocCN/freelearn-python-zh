- en: '6'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '6'
- en: User Inputs and Outputs
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 用户输入和输出
- en: The key purpose of software is to produce useful output. Of the many possible
    outputs, one simple type of output is text displaying a useful result. Python
    supports this with the print() function.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 软件的关键目的是产生有用的输出。在许多可能的输出中，一种简单的输出类型是显示有用结果的文本。Python通过print()函数支持这一点。
- en: The input() function has a parallel with the print() function. The input() function
    reads text from a console, allowing us to provide data to our programs. The use
    of print() and input() creates an elegant symmetry between input and output from
    an application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: input()函数与print()函数类似。input()函数从控制台读取文本，使我们能够向程序提供数据。使用print()和input()在应用程序的输入和输出之间创建了一种优雅的对称性。
- en: There are a number of other common ways to provide input to a program. Parsing
    the command line is helpful for many applications. We sometimes need to use configuration
    files to provide useful input. Data files and network connections are yet more
    ways to provide input. Each of these methods is distinct and needs to be looked
    at separately. In this chapter, we’ll focus on the fundamentals of input() and
    print().
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 向程序提供输入有许多其他常见方式。解析命令行对许多应用程序很有帮助。我们有时需要使用配置文件来提供有用的输入。数据文件和网络连接是提供输入的更多方式。这些方法各不相同，需要单独考虑。在本章中，我们将关注input()和print()的基础知识。
- en: 'In this chapter, we’ll look at the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下配方：
- en: '[Using the features of the print() function](ch010.xhtml#x1-3310001)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用print()函数的特性](ch010.xhtml#x1-3310001)'
- en: '[Using input() and getpass() for user input](ch010.xhtml#x1-3370002)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用input()和getpass()获取用户输入](ch010.xhtml#x1-3370002)'
- en: '[Debugging with f”{value=}” strings](ch010.xhtml#x1-3430003)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用f”{value=}”字符串进行调试](ch010.xhtml#x1-3430003)'
- en: '[Using argparse to get command-line input](ch010.xhtml#x1-3490004)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用argparse获取命令行输入](ch010.xhtml#x1-3490004)'
- en: '[Using invoke to get command-line input](ch010.xhtml#x1-3550005)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用invoke获取命令行输入](ch010.xhtml#x1-3550005)'
- en: '[Using cmd to create command-line applications](ch010.xhtml#x1-3610006)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用cmd创建命令行应用程序](ch010.xhtml#x1-3610006)'
- en: '[Using the OS environment settings](ch010.xhtml#x1-3670007)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用OS环境设置](ch010.xhtml#x1-3670007)'
- en: It seems best to start with the print() function and show several of the things
    it can do. After all, it’s often the output from an application that is most useful.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎最好从print()函数开始，并展示它可以做的一些事情。毕竟，应用程序的输出通常最有用。
- en: 6.1 Using the features of the print() function
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.1 使用print()函数的特性
- en: 'In many cases, the print() function is the first function we learn about. The
    first script is often a variation on the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，print()函数是我们首先了解的函数。第一个脚本通常是以下内容的变体：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The print() function can display multiple values, with helpful spaces between
    items.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: print()函数可以显示多个值，项目之间有有帮助的空格。
- en: 'When we write this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样写时：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can see that a space separator is included for us. Additionally, a line break,
    usually represented by the \n character, is printed after the values provided
    in the function.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，为我们包含了空格分隔符。此外，在函数中提供的值之后，通常会打印一个换行符，通常表示为\n字符。
- en: Can we control this formatting? Can we change the extra characters that are
    supplied?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否控制这种格式？我们能否更改提供的额外字符？
- en: 6.1.1 Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1.1 准备工作
- en: 'Consider this spreadsheet, used to record fuel consumption on a large sailboat.
    The CSV file has rows that look like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个用于记录大型帆船燃油消耗的电子表格。CSV文件中的行看起来像这样：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For more information on this data, refer to the [Shrinking sets – remove(),
    pop(), and difference](ch008_split_001.xhtml#x1-2750008) and [Slicing and dicing
    a list](ch008_split_000.xhtml#x1-2400003) recipes in Chapter [4](ch008_split_000.xhtml#x1-2240004).
    Instead of a sensor inside the tank, the depth of fuel is observed through a glass
    panel on the side of the tank. Knowing the tank is approximately rectangular,
    with a full depth of about 31 inches and a volume of about 72 gallons, it’s possible
    to convert depth to volume.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此数据的更多信息，请参阅第[4](ch008_split_000.xhtml#x1-2240004)章中的[缩小集合 – remove()、pop()和difference](ch008_split_001.xhtml#x1-2750008)和[切片和切块列表](ch008_split_000.xhtml#x1-2400003)配方。由于油箱内部没有传感器，燃油的深度是通过油箱侧面的玻璃面板观察到的。知道油箱大约是矩形的，深度约为31英寸，容量约为72加仑，可以将深度转换为体积。
- en: 'Here’s an example of using this CSV data. This function reads the file and
    returns a list of fields built from each row:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用此CSV数据的示例。此函数读取文件并返回由每一行构建的字段列表：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here’s an example of reading and printing rows from the CSV file:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个从CSV文件中读取和打印行的示例：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The output from the print() function, shown here in long lines, is challenging
    to use. Let’s look at how we can improve this output using additional features
    of the print() function.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: print()函数的输出，如这里所示的长行，使用起来具有挑战性。让我们看看如何使用print()函数的附加功能来改进这个输出。
- en: 6.1.2 How to do it...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1.2 如何做...
- en: 'We have two ways to control the print() function output format:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种方式来控制print()函数的输出格式：
- en: Set the inter-field separator string, sep. The default value is a single-space
    character.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置字段分隔符字符串，sep。默认值是一个空格字符。
- en: Set the end-of-line string, end. The default value is the \n character.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置行结束字符串，end。默认值是\n字符。
- en: 'This recipe will show several variations:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将展示几个变体：
- en: 'Read the data:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取数据：
- en: '[PRE5]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For each item in the data, make any useful data conversions:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于数据中的每一项，进行任何有用的数据转换：
- en: '[PRE6]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following alternatives show different ways to include separators:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下替代方案展示了不同的包含分隔符的方法：
- en: 'Print labels and fields using the default values of sep and end:'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用sep和end的默认值打印标签和字段：
- en: '[PRE7]'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When we look at the output, we can see where a space was inserted between each
    item.
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们查看输出时，我们可以看到在每一项之间插入了一个空格。
- en: 'When preparing data, we might want to use a format that’s similar to CSV, perhaps
    using a column separator that’s not a simple comma. We can print labels and fields
    using a string value of " | " for the sep parameter:'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在准备数据时，我们可能希望使用类似于CSV的格式，可能使用非简单逗号的列分隔符。我们可以使用" | "作为sep参数的字符串值来打印标签和字段：
- en: '[PRE8]'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, we can see that each column has the given separator string. Since
    there were no changes to the end setting, each print() function produces a distinct
    line of output.
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以看到每一列都有给定的分隔符字符串。由于没有更改结束设置，每个print()函数都产生了一条独特的输出行。
- en: 'Here’s how we might change the default punctuation to emphasize the field name
    and value. We can print labels and fields using a string value of "=" for the
    sep parameter and ", " for the end parameter:'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是我们如何更改默认标点符号以强调字段名称和值的示例。我们可以使用"="作为sep参数的字符串值和", "作为end参数的值来打印标签和字段：
- en: '[PRE9]'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since the string used at the end of the line was changed to ", ", each use of
    the print() function no longer produces separate lines. In order to see a proper
    end of line, the final print() function has a default value for end. We could
    also have used an argument value of end="\n" to make the presence of the newline
    character explicit.
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于行尾使用的字符串已更改为", "，因此print()函数的每次使用不再产生单独的行。为了看到正确的行尾，最后的print()函数有一个默认的end值。我们也可以使用end="\n"的参数值来明确地表示换行符的存在。
- en: 6.1.3 How it works...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1.3 它是如何工作的...
- en: The print() function has a definition that includes several parameters that
    must be provided as keywords. Two of these are the sep and end keyword parameters,
    with default values of space and newline, respectively.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: print()函数的定义包括几个必须以关键字形式提供的参数。其中两个是sep和end关键字参数，分别具有空格和换行符的默认值。
- en: Using the print() function’s sep and end parameters can get quite complex for
    anything more sophisticated than these simple examples. Rather than working with
    a complex sequence of print() function requests, we can use the format() method
    of a string, or use an f-string.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用print()函数的sep和end参数对于比这些简单示例更复杂的情况可能会变得相当复杂。而不是处理一系列复杂的print()函数请求，我们可以使用字符串的format()方法，或者使用f-string。
- en: 6.1.4 There’s more...
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1.4 更多...
- en: 'The sys module defines the two standard output files that are always available:
    sys.stdout and sys.stderr. Generally, the print() function can be thought of as
    a handy wrapper around sys.stdout.write().'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: sys模块定义了两个始终可用的标准输出文件：sys.stdout和sys.stderr。通常，print()函数可以被视为sys.stdout.write()的一个便捷包装器。
- en: 'We can use the file= keyword argument to write to the standard error file instead
    of writing to the standard output file:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用file=关键字参数将内容写入标准错误文件，而不是写入标准输出文件：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We’ve imported the sys module so that we have access to the standard error file.
    We used this to write a message that will not be part of the standard output stream.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了sys模块，以便我们可以访问标准错误文件。我们使用它来写入一条不会成为标准输出流一部分的消息。
- en: 'Because these two files are always available, using OS file redirection techniques
    often works out nicely. When our program’s primary output is written to sys.stdout,
    it can be redirected at the OS level. A user might enter a shell command line
    like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个文件始终可用，使用OS文件重定向技术通常效果很好。当我们的程序的主要输出写入sys.stdout时，它可以在OS级别进行重定向。用户可能会输入一个类似这样的shell命令行：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will provide the input.dat file as the input to sys.stdin. When this Python
    program writes to sys.stdout, the output will be redirected by the OS to the output.dat
    file.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为sys.stdin提供input.dat文件作为输入。当这个Python程序写入sys.stdout时，输出将由OS重定向到output.dat文件。
- en: 'In some cases, we need to open additional files. In that case, we might see
    programming like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们需要打开额外的文件。在这种情况下，我们可能会看到这样的编程：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, we’ve opened a specific path for the output and assigned the
    open file to target_file, using the with statement. We can then use this as the
    file= value in a print() function to write to this file. Because a file is a context
    manager, leaving the with statement means that the file will be closed properly;
    all of the OS resources will be released from the application. All file operations
    should be wrapped in a with statement context to ensure that the resources are
    properly released.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们已为输出打开了一个特定的路径，并使用with语句将打开的文件分配给target_file。然后我们可以将此作为print()函数中的file=值来写入此文件。因为文件是一个上下文管理器，所以离开with语句意味着文件将被正确关闭；所有OS资源都将从应用程序中释放。所有文件操作都应该用with语句的上下文包装，以确保资源得到适当的释放。
- en: 6.1.5 See also
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1.5 相关阅读
- en: For more formatting options, see the [Debugging with f”{value=}” strings](ch010.xhtml#x1-3430003)
    recipe.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于更多格式化选项，请参阅[使用f”{value=}"字符串进行调试](ch010.xhtml#x1-3430003)食谱。
- en: For more information on the input data in this example, refer to the [Shrinking
    sets – remove(), pop(), and difference](ch008_split_001.xhtml#x1-2750008) and
    [Slicing and dicing a list](ch008_split_000.xhtml#x1-2400003) recipes in Chapter [4](ch008_split_000.xhtml#x1-2240004).
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于本例中输入数据的更多信息，请参阅第[4](ch008_split_000.xhtml#x1-2240004)章中的[收缩集合 – remove(),
    pop(), 和 difference](ch008_split_001.xhtml#x1-2750008)和[切片和切块列表](ch008_split_000.xhtml#x1-2400003)食谱。
- en: For more information on file operations in general, refer to Chapter [8](ch012.xhtml#x1-4520008)
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于文件操作的一般信息，请参阅第[8](ch012.xhtml#x1-4520008)章。
- en: 6.2 Using input() and getpass() for user input
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.2 使用input()和getpass()获取用户输入
- en: Some Python scripts depend on gathering input from a user. There are several
    ways to do this. One popular technique is to use the console to prompt a user
    for input interactively.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Python脚本依赖于从用户那里收集输入。有几种方法可以做到这一点。一种流行的技术是使用控制台以交互方式提示用户输入。
- en: 'There are two relatively common situations:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种相对常见的情况：
- en: 'Ordinary input: This will provide a helpful echo of the characters being entered.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 普通输入：这将提供输入字符的有帮助的回显。
- en: 'Secure, no echo input: This is often used for passwords. The characters entered
    aren’t displayed, providing a degree of privacy. We use the getpass() function
    in the getpass module for this.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全、无回显输入：这通常用于密码。输入的字符不会显示，提供了一定程度的隐私。我们使用getpass模块中的getpass()函数来完成这项工作。
- en: As an alternative to interactive input, we’ll look at some other approaches
    in the [Using argparse to get command-line input](ch010.xhtml#x1-3490004) recipe
    later in this chapter.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 作为交互式输入的替代方案，我们将在本章后面的[使用argparse获取命令行输入](ch010.xhtml#x1-3490004)食谱中探讨一些其他方法。
- en: The input() and getpass() functions are just two implementation choices to read
    from the console. It turns out that getting the string of characters is only the
    first step in gathering useful data. The input also needs to be validated.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: input()和getpass()函数只是从控制台读取的两种实现选择。结果是，获取字符字符串只是收集有用数据的第一步。输入还需要进行验证。
- en: 6.2.1 Getting ready
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2.1 准备工作
- en: We’ll look at a technique to read a complex structure from a person. In this
    case, we’ll use year, month, and day as separate items. These items are then combined
    to create a complete date.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨一种从人那里读取复杂结构的技术。在这种情况下，我们将使用年、月和日作为单独的项目。然后这些项目被组合起来创建一个完整的日期。
- en: 'Here’s a quick example of user input that omits all of the validation considerations.
    This is poor design:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个快速的用户输入示例，省略了所有验证考虑。这是糟糕的设计：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: While it is very easy to use the input() function, it lacks a number of helpful
    features. When the user enters an invalid date, this will raise a potentially
    confusing exception.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用input()函数非常容易，但它缺少许多有用的功能。当用户输入无效日期时，这可能会引发一个可能令人困惑的异常。
- en: We often need to wrap the input() function with data validation processing to
    make it more useful. The calendar is complex, and we’d hate to accept February
    31 without warning the user that it is not a proper date.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要将input()函数与数据验证处理包装起来，使其更有用。日历很复杂，我们不愿意在未警告用户的情况下接受2月31日，这不是一个正确的日期。
- en: 6.2.2 How to do it...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2.2 如何实现...
- en: 'If the input is a password or something equally subject to redaction, the input()
    function isn’t the best choice. If passwords or other secrets are involved, then
    use the getpass.getpass() function. This means we need the following import when
    secrets are involved:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果输入是密码或类似需要编辑的内容，则input()函数不是最佳选择。如果涉及密码或其他秘密，则使用getpass.getpass()函数。这意味着当涉及秘密时，我们需要以下导入：
- en: '[PRE14]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Otherwise, when secret input is not required, we’ll use the built-in input()
    function, and no additional import is required.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 否则，当不需要秘密输入时，我们将使用内置的input()函数，不需要额外的导入。
- en: 'Determine which prompt will be used. In our example, we provided a field name
    and a hint about the type of data expected as the prompt string argument to the
    input() or getpass() functions. It can help to separate the input from the text-to-integer
    conversion. This recipe doesn’t follow the snippet shown previously; it breaks
    the operation into two separate steps. First, get the text value:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定将使用哪个提示。在我们的例子中，我们提供了一个字段名称和有关预期数据类型的提示作为input()或getpass()函数的提示字符串参数。这有助于将输入与文本到整数的转换分开。这个配方不遵循之前显示的片段；它将操作分解为两个独立的步骤。首先，获取文本值：
- en: '[PRE15]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Determine how to validate each item in isolation. The simplest case is a single
    value with a single rule that covers everything. In more complex cases – like
    this one – each individual element is a number with a range constraint. In a later
    step, we’ll look at validating the composite item:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定如何单独验证每个项目。最简单的情况是一个具有涵盖所有内容的单个规则的单个值。在更复杂的情况下——就像这个例子——每个单独的元素都是一个具有范围约束的数字。在后续步骤中，我们将查看验证组合项目：
- en: '[PRE16]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Wrap the input and validation into a while-try block that looks like this:'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将输入和验证包装成如下所示的while-try块：
- en: '[PRE17]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This applies a single validation rule, the int(year_txt) expression, to ensure
    that the input is an integer. The while statement leads to a repeat of the input
    and conversion sequence of steps until the value of the year variable is not None.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此处应用单个验证规则，即int(year_txt)表达式，以确保输入是整数。while语句导致输入和转换步骤的重复，直到year变量的值为None。
- en: Raising an exception for faulty input allows us some flexibility. We can extend
    this with additional exception classes for other conditions the input must meet.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于错误输入抛出异常为我们提供了一些灵活性。我们可以通过扩展额外的异常类来满足输入必须满足的其他条件。
- en: This processing only covers the year field. We still need to get values for
    the month and day fields. This means we’ll need three nearly identical loops for
    each of these three fields of a complex date object. Rather than copying and pasting
    nearly identical code, we need to restructure this processing.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此处理过程仅涵盖年份字段。我们还需要获取月份和日期字段的值。这意味着我们需要为复杂日期对象的这三个字段分别编写三个几乎相同的循环。为了避免复制和粘贴几乎相同的代码，我们需要重构此处理过程。
- en: 'We’ll define a new function, get_integer(), for general-purpose input of a
    numeric value. Here’s the complete function definition:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个新的函数get_integer()，用于通用数字值输入。以下是完整的函数定义：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can combine this into an overall process to get the three integers of a
    date. This will involve a similar while-try design pattern but applied to the
    composite object. It will look like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些组合成一个整体过程，以获取日期的三个整数。这将涉及类似while-try设计模式，但应用于组合对象。它看起来像这样：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This uses individual while-try processing sequences around the sequence of get_integer()
    functions to get the individual values that make up a date. Then, it uses the
    date() constructor to create a date object from the individual fields. If the
    date object – as a whole – can’t be built because the pieces are invalid, then
    the year, month, and day must be reentered to create a valid date.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用围绕get_integer()函数序列的单独while-try处理序列来获取构成日期的各个值。然后，它使用date()构造函数从单个字段创建日期对象。如果由于组件无效，无法构建日期对象——作为一个整体——则必须重新输入年、月和日以创建一个有效的日期。
- en: 6.2.3 How it works...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2.3 它是如何工作的...
- en: 'We need to decompose the input problem into several separate but closely related
    problems. To do this, imagine a tower of conversion steps. At the bottom layer
    is the initial interaction with the user. We identified two of the common ways
    to handle this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将输入问题分解为几个相互独立但密切相关的子问题。为此，想象一个转换步骤的塔。在最底层是与用户的初始交互。我们确定了两种处理这种交互的常见方法：
- en: 'input(): This prompts and reads from a user'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: input()：此函数提示并从用户那里读取
- en: 'getpass.getpass(): This prompts and reads input (like passwords) without a
    visible echo'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: getpass.getpass()：此函数提示并读取输入（如密码）而不显示回显
- en: These two functions provide the essential console interaction. There are other
    libraries that can provide more sophisticated interactions, if that’s required.
    For example, the Click project has some helpful prompting capabilities. See [https://click.palletsprojects.com/en/7.x/](https://click.palletsprojects.com/en/7.x/).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数提供了基本的控制台交互。如果需要更复杂的交互，还有其他库可以提供。例如，Click项目有一些有用的提示功能。参见[https://click.palletsprojects.com/en/7.x/](https://click.palletsprojects.com/en/7.x/)。
- en: The Rich project has extremely sophisticated terminal interaction. See [https://rich.readthedocs.io/en/latest/](https://rich.readthedocs.io/en/latest/).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Rich项目具有极其复杂的终端交互。参见[https://rich.readthedocs.io/en/latest/](https://rich.readthedocs.io/en/latest/)。
- en: 'On top of the foundation, we’ve built several tiers of validation processing.
    The tiers are as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在基础之上，我们构建了几个验证处理的层级。层级如下：
- en: 'A data type validation: This uses built-in conversion functions such as int()
    or float(). These raise a ValueError exception for invalid text.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类型验证：这使用内置的转换函数，如int()或float()。这些函数对无效文本引发ValueError异常。
- en: 'A domain validation: This uses an if statement to determine whether values
    fit any application-specific constraints. For consistency, this should also raise
    a ValueError exception if the data is invalid.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 域验证：这使用if语句来确定值是否符合任何特定应用程序的约束。为了保持一致性，如果数据无效，也应引发ValueError异常。
- en: 'Composite object validation: This is application-specific checking. For our
    example, the composite object was an instance of datetime.date. This also tends
    to raise ValueError exceptions for dates that are invalid.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合对象验证：这是特定于应用程序的检查。在我们的例子中，组合对象是datetime.date的一个实例。这也倾向于对无效的日期引发ValueError异常。
- en: There are a lot of potential kinds of constraints that might be imposed on values.
    We’ve used the valid date constraint because it’s particularly complicated.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 可能对值施加的约束类型有很多。我们使用了有效的日期约束，因为它特别复杂。
- en: 6.2.4 There’s more...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2.4 更多内容...
- en: 'We have several alternatives for user input that involve slightly different
    approaches. We’ll look at these two topics in detail:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种涉及略微不同方法的用户输入替代方案。我们将详细探讨这两个主题：
- en: 'Complex text: This will involve the simple use of input() with more sophisticated
    parsing of the source text. Instead of prompting for individual fields, it might
    be better to accept a string in the yyyy-mm-dd format and use the strptime() parser
    to extract a date. This doesn’t change the design pattern; it replaces an int()
    or float() with something a bit more complicated.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂文本：这将涉及简单使用input()和更复杂的源文本解析。而不是提示单个字段，可能更好的是接受yyyy-mm-dd格式的字符串，并使用strptime()解析器提取日期。这不会改变设计模式；它用稍微复杂一些的东西替换了int()或float()。
- en: 'Interaction via the cmd module: This involves a more complex class to control
    interaction. We’ll look at this closely in the [Using cmd to create command-line
    applications](ch010.xhtml#x1-3610006) recipe.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过cmd模块进行交互：这涉及一个更复杂的类来控制交互。我们将在[使用cmd创建命令行应用程序](ch010.xhtml#x1-3610006)的配方中详细探讨这一点。
- en: A list of potential input validation rules can be extracted from JSON schema
    definitions. This list of types includes Boolean, integer, float, and string.
    A number of common string formats defined in JSON schema include date-time, time,
    date, email, hostname, IP addresses in the version 4 and version 6 formats, and
    URIs.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从JSON模式定义中提取潜在输入验证规则列表。此类型列表包括布尔值、整数、浮点数和字符串。在JSON模式中定义的许多常见字符串格式包括日期时间、时间、日期、电子邮件、主机名、IPv4和IPv6格式的IP地址以及URI。
- en: Another source of user input validation rules can be found in the definition
    of the HTML5 <input> tag. This list includes color, date, datetime-local, email,
    file, month, number, password, telephone numbers, time, URL, and week-year.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 用户输入验证规则的另一个来源可以在HTML5 <input>标签的定义中找到。此列表包括颜色、日期、datetime-local、电子邮件、文件、月份、数字、密码、电话号码、时间、URL和周年的格式。
- en: 6.2.5 See also
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2.5 参见
- en: See the [Using cmd to create command-line applications](ch010.xhtml#x1-3610006)
    recipe in this chapter for complex interaction.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中查看[使用cmd创建命令行应用程序](ch010.xhtml#x1-3610006)的配方以了解复杂交互。
- en: See the [Using argparse to get command-line input](ch010.xhtml#x1-3490004) recipe
    to gather user input from the command line.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看使用[使用argparse获取命令行输入](ch010.xhtml#x1-3490004)的配方以从命令行收集用户输入。
- en: 'In the reference material for the SunOS operating system, which is now owned
    by Oracle, there is a collection of commands that prompt for different kinds of
    user inputs: [https://docs.oracle.com/cd/E19683-01/816-0210/6m6nb7m5d/index.html](https://docs.oracle.com/cd/E19683-01/816-0210/6m6nb7m5d/index.html)'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在SunOS操作系统的参考资料中，该系统现在由Oracle拥有，其中包含一组提示不同类型用户输入的命令：[https://docs.oracle.com/cd/E19683-01/816-0210/6m6nb7m5d/index.html](https://docs.oracle.com/cd/E19683-01/816-0210/6m6nb7m5d/index.html)
- en: 6.3 Debugging with f”{value=}” strings
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.3 使用f”{value=}”字符串进行调试
- en: One of the most important debugging and design tools available in Python is
    the print() function. The two formatting options shown in the [Using the features
    of the print() function](ch010.xhtml#x1-3310001) recipe don’t offer a lot of flexibility.
    We have more flexibility with f"string" formatting. We’ll build on some of the
    recipes shown in Chapter [1](ch005_split_000.xhtml#x1-170001), [Numbers, Strings,
    and Tuples](ch005_split_000.xhtml#x1-170001).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Python中可用的重要调试和设计工具之一是print()函数。在[使用print()函数的功能](ch010.xhtml#x1-3310001)食谱中显示的两个格式选项提供的灵活性不多。我们有更多的灵活性使用f"string"格式。我们将基于第[1](ch005_split_000.xhtml#x1-170001)章、[数字、字符串和元组](ch005_split_000.xhtml#x1-170001)中显示的一些食谱。
- en: 6.3.1 Getting ready
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3.1 准备工作
- en: 'Let’s look at a multi-step process that involves some moderately complex calculations.
    We’ll compute the mean and standard deviation of some sample data. Given these
    values, we’ll locate all items that are more than one standard deviation above
    the mean:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个涉及一些中等复杂计算的多步骤过程。我们将计算一些样本数据的平均值和标准差。给定这些值，我们将定位所有高于平均值一个标准差的项：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This calculation has several working variables. The final list comprehension
    involves three other variables, mean_size, std_size, and sig1\. With so many values
    used to filter the size list, it’s difficult to visualize what’s going on. It’s
    often helpful to know the steps in the calculation; showing the values of the
    intermediate variables can be very helpful.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个计算有几个工作变量。最终的列表推导式涉及其他三个变量，mean_size、std_size和sig1。使用这么多值来过滤大小列表，很难可视化正在发生的事情。了解计算的步骤通常很有帮助；显示中间变量的值可能非常有帮助。
- en: 6.3.2 How to do it...
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3.2 如何做...
- en: 'The f"{name=}" string will have both the literal string name= and the value
    for the name expression. This is often a variable, but any expression can be used.
    Using this with a print() function looks as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: f"{name=}"字符串将同时包含字面字符串name=和name表达式的值。这通常是一个变量，但可以使用任何表达式。使用这个与print()函数结合的例子如下：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We can use {name=} to put any variable into the f-string and see the value.
    These examples in the code above include a suffix of :.2f as the format specification
    to show the values rounded to two decimal places. Another common suffix is !r
    to show the internal representation of the object; we might use f"{name=!r}".
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用{name=}将任何变量放入f-string中并查看其值。上述代码中的这些例子包括格式说明符:.2f作为后缀，以显示四舍五入到两位小数的值。另一个常见的后缀是!r，用于显示对象的内部表示；我们可能会使用f"{name=!r}"。
- en: 6.3.3 How it works...
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3.3 它是如何工作的...
- en: For more background on the formatting options, refer to the [Building complicated
    strings with f-strings](ch005_split_000.xhtml#x1-410004) recipe in Chapter [1](ch005_split_000.xhtml#x1-170001).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 关于格式选项的更多背景信息，请参阅第[1](ch005_split_000.xhtml#x1-170001)章中[构建复杂的f-string字符串](ch005_split_000.xhtml#x1-410004)食谱。
- en: There is a very handy extension to this capability. We can use any expression
    on the left of the = in the f-string. This will show the expression and the value
    computed by the expression, providing us with even more debugging information.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能有一个非常实用的扩展。我们可以在f-string中的=左侧使用任何表达式。这将显示表达式及其计算出的值，为我们提供更多的调试信息。
- en: 6.3.4 There’s more...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3.4 更多...
- en: 'We can use the extended expression capability of f-strings to include additional
    calculations that aren’t simply the values’ local variables:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用f-string的扩展表达式功能包括额外的计算，这些计算不仅仅是局部变量的值：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We’ve computed a new value, mean_size+2*std_size, that appears only inside the
    formatted output. This lets us display intermediate computed results without having
    to create an extra variable.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经计算了一个新值，mean_size+2*std_size，它只出现在格式化输出中。这使得我们可以在不创建额外变量的情况下显示中间计算结果。
- en: 6.3.5 See also
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3.5 参见
- en: Refer to the [Building complicated strings with f-strings](ch005_split_000.xhtml#x1-410004)
    recipe in Chapter [1](ch005_split_000.xhtml#x1-170001), for more of the things
    that can be done with f-strings and the format() method of a string.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考第[1](ch005_split_000.xhtml#x1-170001)章中的[“使用f-strings构建复杂的字符串”](ch005_split_000.xhtml#x1-410004)食谱，了解更多可以使用f-strings和字符串的format()方法完成的事情。
- en: Refer to the [Using the features of the print() function](ch010.xhtml#x1-3310001)
    recipe earlier in this chapter for other formatting options.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考本章前面的[“使用print()函数的特性”](ch010.xhtml#x1-3310001)食谱，了解其他格式化选项。
- en: 6.4 Using argparse to get command-line input
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.4 使用argparse获取命令行输入
- en: For some applications, it can be better to get the user input from the OS command
    line without a lot of human interaction. We’d prefer to parse the command-line
    argument values and either perform the processing or report an error.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些应用，在没有太多人工交互的情况下从操作系统命令行获取用户输入可能更好。我们更愿意解析命令行参数值，然后执行处理或报告错误。
- en: 'For example, at the OS level, we might want to run a program like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在操作系统级别，我们可能想运行这样的程序：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: At the OS prompt of %, we entered a command, python ch06/distance_app.py. This
    command had an optional argument, -u KM, and two positional arguments of 36.12,-86.67
    and 33.94,-118.40.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在%的操作系统提示符下，我们输入了一个命令，python ch06/distance_app.py。此命令有一个可选参数，-u KM，以及两个位置参数36.12,-86.67和33.94,-118.40。
- en: 'If the user enters something incorrect, the interaction might look like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入错误，交互可能看起来像这样：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: An invalid argument value of -118asd leads to an error message. A user can hit
    the up-arrow key to get the previous command line back, make a change, and run
    the program again. The interactive user experience is delegated to OS command-line
    processing.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: -118asd的无效参数值会导致错误消息。用户可以按上箭头键获取之前的命令行，进行更改，然后再次运行程序。交互式用户体验委托给操作系统命令行处理。
- en: 6.4.1 Getting ready
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4.1 准备工作
- en: 'The first thing we need to do is to refactor our code to create three separate
    functions:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是重构我们的代码，创建三个单独的函数：
- en: A function to get the arguments from the command line.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个从命令行获取参数的函数。
- en: A function that does the real work. The intent is to define a function that
    can be reused in a variety of contexts, one of which is with parameters from the
    command line.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个执行实际工作的函数。目的是定义一个可以在各种环境中重用的函数，其中之一是使用命令行参数。
- en: A main function that gathers arguments and invokes the real work function with
    the appropriate argument values.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个主函数，它收集参数并使用适当的参数值调用实际工作函数。
- en: 'Here’s our real work function, display():'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们的实际工作函数，display()：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We’ve imported the core calculation, haversine(), from the ch06.distance_computation
    module. We’ve based this on the calculations shown in the examples in the [Picking
    an order for parameters based on partial functions](ch007_split_001.xhtml#x1-1940006)
    recipe in Chapter [3](ch007_split_000.xhtml#x1-1610003):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已从ch06.distance_computation模块导入了核心计算函数haversine()。这是基于第[3](ch007_split_000.xhtml#x1-1610003)章中[“基于部分函数选择参数顺序”](ch007_split_001.xhtml#x1-1940006)食谱中显示的计算：
- en: 'Here’s how the function looks when it’s used inside Python:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是函数在Python内部使用时的样子：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This function has two important design features. The first feature is that it
    avoids references to features of the argparse.Namespace object that’s created
    by argument parsing. Our goal is to have a function that we can reuse in a number
    of alternative contexts. We need to keep the input and output elements of the
    user interface separate.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数有两个重要的设计特点。第一个特点是它避免了引用由参数解析创建的argparse.Namespace对象的功能。我们的目标是拥有一个可以在多个不同环境中重用的函数。我们需要将用户界面的输入和输出元素分开。
- en: The second design feature is that this function displays a value computed by
    another function. This is a decomposition of a larger problem into two smaller
    problems. We’ve separated the user experience of printed output from the essential
    calculation. (Both aspects are quite small, but the principle of separating these
    two aspects is important.)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个设计特点是该功能显示另一个函数计算出的值。这是将一个较大的问题分解为两个较小问题的分解。我们将打印输出的用户体验与基本计算分离。（这两个方面都相当小，但分离这两个方面的原则很重要。）
- en: 6.4.2 How to do it...
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4.2 如何实现...
- en: 'Define the overall argument parsing function:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义整体参数解析函数：
- en: '[PRE27]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create the parser object:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建解析器对象：
- en: '[PRE28]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add the various types of arguments to the parser object. Sometimes, this is
    difficult because we’re still refining the user experience. It’s difficult to
    imagine all the ways in which people will use a program and all of the questions
    they might have. For our example, we have two mandatory, positional arguments
    and an optional argument:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将各种类型的参数添加到解析器对象中。有时，这很困难，因为我们仍在改进用户体验。很难想象人们会如何使用程序以及他们可能提出的所有问题。在我们的例子中，我们有两个必需的位置参数和一个可选参数：
- en: Point 1 latitude and longitude
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一点：纬度和经度
- en: Point 2 latitude and longitude
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二点：纬度和经度
- en: 'Optional units of distance; we’ll provide nautical miles as the default:'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的距离单位；我们将提供海里作为默认值：
- en: '[PRE29]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We’ve added a mix of optional and mandatory arguments. The -u argument starts
    with a dash to mark it as optional. A longer double dash version, --units, is
    supported as an alternative.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们添加了可选和必需参数的混合。-u 参数以短横线开头，表示它是可选的。支持较长的双短横线版本 --units 作为替代。
- en: The mandatory, positional arguments are named without a prefix.
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 必需的位置参数不带前缀命名。
- en: 'Evaluate the parse_args() method of the parser object created in step 2:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估步骤 2 中创建的解析器对象的 parse_args() 方法：
- en: '[PRE30]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: By default, the parser uses the values from sys.argv, which are the command-line
    argument values entered by the user. Testing is much easier when we can provide
    an explicit argument value.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，解析器使用 sys.argv 的值，即用户输入的命令行参数值。当我们能够提供明确的参数值时，测试会更加容易。
- en: 'Here’s the final function:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是最终的函数：
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This relies on a point_type() function to both validate the strings and convert
    the string to a (latitude, longitude) two-tuple. Here’s the definition of this
    function:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这依赖于一个 point_type() 函数，该函数既验证字符串，又把字符串转换成（纬度，经度）两个元素的元组。下面是这个函数的定义：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If anything goes wrong, an exception will be raised. From this exception, we’ll
    raise an ArgumentTypeError exception. This is caught by the argparse module and
    causes it to report the error to the user.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现任何问题，将引发异常。从这个异常中，我们将引发 ArgumentTypeError 异常。这个异常被 argparse 模块捕获，并导致它向用户报告错误。
- en: 'Here’s the main script that combines the option parser and the output display
    functions:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是结合选项解析器和输出显示功能的主体脚本：
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This main script connects the user inputs to the displayed output. The details
    of error messages and help processing are delegated to the argparse module.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此主体脚本将用户输入连接到显示的输出。错误消息的详细信息和处理帮助被委托给 argparse 模块。
- en: 6.4.3 How it works...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4.3 它是如何工作的...
- en: 'The argument parser works in three stages:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 参数解析器分为三个阶段：
- en: Define the overall context by creating a parser object as an instance of the
    ArgumentParser class.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个 ArgumentParser 类的实例来创建一个解析器对象，从而定义整体上下文。
- en: Add individual arguments with the add_argument() method. These can include optional
    arguments as well as required arguments.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 add_argument() 方法添加单个参数。这些参数可以包括可选参数以及必需参数。
- en: Parse the actual command-line inputs, often based on sys.argv.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析实际的命令行输入，通常基于 sys.argv。
- en: Some simple programs will have a few optional arguments. A more complex program
    may have many optional arguments.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一些简单的程序可能只有几个可选参数。一个更复杂的程序可能有更多可选参数。
- en: 'It’s common to have a filename as a positional argument. When a program reads
    one or more files, the filenames can be provided in the command line, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，文件名作为位置参数。当程序读取一个或多个文件时，文件名可以按如下方式在命令行中提供：
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We’ve used the Linux shell’s globbing feature: the *.rst string is expanded
    into a list of all files that match the naming rule. This is a feature of the
    Linux shell, and it happens before the Python interpreter starts. This list of
    files can be processed using an argument, defined as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 Linux shell 的通配符功能：*.rst 字符串被扩展成匹配命名规则的文件列表。这是 Linux shell 的一个特性，发生在 Python
    解释器开始之前。这个文件列表可以使用以下定义的参数进行处理：
- en: '[PRE35]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: All of the arguments on the command line that do not start with the - character
    are positional arguments, and they are collected into the file value in the object
    built by the parser.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行上所有不以 - 字符开头的参数都是位置参数，并且它们被收集到由解析器构建的对象的 file 值中。
- en: 'We can then use the following to process each of the given files:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下方式处理每个给定的文件：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: For Windows programs, the shell doesn’t glob filenames from wildcard patterns.
    This means the application must deal with filenames that contain wildcard characters
    like "*" and "?" in them. The Python glob module can help with this. Also, the
    pathlib module can create Path objects, which include globbing features to locate
    matching filenames in a directory.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows 程序，shell 不会从通配符模式中获取文件名。这意味着应用程序必须处理包含通配符字符（如 "*" 和 "?”）的文件名。Python
    的 glob 模块可以帮助处理这个问题。此外，pathlib 模块可以创建 Path 对象，这些对象包括用于在目录中定位匹配文件名的通配符功能。
- en: 6.4.4 There’s more...
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4.4 更多内容...
- en: 'What kinds of arguments can we process? There are a lot of argument styles
    in common use. All of these variations are defined using the add_argument() method
    of a parser:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以处理哪些类型的参数？在常见使用中有很多参数风格。所有这些变体都是使用解析器的 add_argument() 方法定义的：
- en: 'Simple options: Arguments of the form -o or --option often define optional
    features. These use the ’store_true’ or ’store_false’ actions.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单选项：形式为 -o 或 --option 的参数通常定义可选功能。这些使用的是 ‘store_true’ 或 ‘store_false’ 动作。
- en: 'Options with values: We showed -r unit as an option with a value. The ’store’
    action is how the value is saved.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带值的选项：我们展示了 -r unit 作为带值的选项。‘store’ 动作是保存值的方式。
- en: 'Options that increment a counter: The action ’count’ and default=0 permit an
    option that can be repeated. The verbose and very verbose logging options, -v
    and -vv, respectively, are an example.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加计数的选项：动作 ‘count’ 和默认值 =0 允许重复的选项。例如，详细和非常详细的日志选项 -v 和 -vv。
- en: 'Options that accumulate a list: The action ’append’ and default=[] can accumulate
    multiple option values.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 累积列表的选项：动作 ‘append’ 和默认值 [] 可以累积多个选项值。
- en: 'Show the version number: A special action of ’version’ can be used to create
    an argument that will show the version number and exit.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示版本号：可以使用特殊动作 ‘version’ 创建一个将显示版本号并退出的参数。
- en: Positional arguments do not have a leading ’-’ in their name. They must be defined
    in the order they will be used.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置参数在其名称中不带有前导 ‘-’。它们必须按照将使用的顺序定义。
- en: The argparse module uses -h, and --help will display a help message and exit.
    These options are available unless changed by an argument that uses the ’help’
    action.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: argparse 模块使用 -h 和 --help 将显示帮助信息并退出。除非使用具有 ‘help’ 动作的参数更改，否则这些选项都是可用的。
- en: This covers most of the common cases for command-line argument processing. Generally,
    we’ll try to leverage these common styles of arguments when we write our own applications.
    If we strive to follow the widely used argument styles, our users are more likely
    to understand how our application works.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了命令行参数处理的常见情况。通常，当我们编写自己的应用程序时，我们会尝试利用这些常见的参数风格。如果我们努力遵循广泛使用的参数风格，我们的用户更有可能理解我们的应用程序是如何工作的。
- en: 6.4.5 See also
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4.5 参见
- en: We looked at how to get interactive user input in the [Using input() and getpass()
    for user input](ch010.xhtml#x1-3370002) recipe.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在 [使用 input() 和 getpass() 获取用户输入](ch010.xhtml#x1-3370002) 的菜谱中探讨了如何获取交互式用户输入。
- en: We’ll look at a way to add even more flexibility to this in the [Using the OS
    environment settings](ch010.xhtml#x1-3670007) recipe.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在 [使用 OS 环境设置](ch010.xhtml#x1-3670007) 的菜谱中查看如何添加更多灵活性。
- en: 6.5 Using invoke to get command-line input
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.5 使用 invoke 获取命令行输入
- en: 'The [invoke](https://www.pyinvoke.org) package is not part of the standard
    library. It needs to be installed separately. Generally, this is done with the
    following terminal command:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[invoke](https://www.pyinvoke.org) 包不是标准库的一部分。它需要单独安装。通常，这是通过以下终端命令完成的：'
- en: '[PRE37]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Using the python -m pip command ensures that we will use the pip command that
    goes with the currently active virtual environment, shown as cookbook3.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 python -m pip 命令确保我们将使用与当前活动虚拟环境一起的 pip 命令，显示为 cookbook3。
- en: 'See the [Using argparse to get command-line input](ch010.xhtml#x1-3490004)
    recipe in this chapter. It describes a command-line application that works something
    like the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅本章中的 [使用 argparse 获取命令行输入](ch010.xhtml#x1-3490004) 菜谱。它描述了一个类似以下的工作命令行应用程序：
- en: '[PRE38]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The command will always be invoke. The Python path information is used to locate
    a module file named tasks.py to provide the definitions of the commands that can
    be invoked. The remaining command-line values are provided to a function defined
    in the tasks module.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 命令始终是 invoke。Python 路径信息用于定位名为 tasks.py 的模块文件，以提供可以调用的命令的定义。剩余的命令行值提供给 tasks
    模块中定义的函数。
- en: 6.5.1 Getting ready
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5.1 准备工作
- en: 'Often, we’ll create a two-tiered design when using invoke. These two tiers
    are:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用invoke时，我们通常会创建一个双层设计。这两层是：
- en: A function to get the arguments from the command line, do any validation or
    conversion required, and invoke the function to perform the real work. This function
    will be decorated with @task.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个从命令行获取参数、执行所需的验证或转换，并调用函数执行真实工作的函数。这个函数将被装饰为@task。
- en: A function that does the real work. It helps if this function is designed so
    that it makes no reference to the command-line options in any direct way. The
    intent is to define a function to be reused in a variety of contexts, one of which
    is with parameters from the command line.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行真实工作的函数。如果这个函数被设计成不直接引用命令行选项，那么这会有所帮助。目的是定义一个可以在各种环境中重用的函数，其中之一就是使用来自命令行的参数。
- en: In some cases, these two functions can be merged into one. This often happens
    when Python is used as a wrapper to provide a simple interface for an underlying
    application that is bewilderingly complicated. In this kind of application, the
    Python wrapper may do very little processing, with no useful distinction between
    validating parameter values and doing the “real work” of the application.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，这两个函数可以合并成一个。这种情况通常发生在Python被用作包装器，为底层提供简单接口，而底层应用却异常复杂时。在这种应用中，Python包装器可能只做很少的处理，参数值验证与应用的“真实工作”之间没有有用的区别。
- en: In the [Using argparse to get command-line input](ch010.xhtml#x1-3490004) recipe
    in this chapter, the display() function is defined. This function does the “real
    work” of the application. When working with invoke, this design will continue
    to be used.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的[使用argparse获取命令行输入](ch010.xhtml#x1-3490004)配方中，定义了display()函数。这个函数执行应用的“真实工作”。当与invoke一起工作时，这种设计将继续使用。
- en: 6.5.2 How to do it...
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5.2 如何做...
- en: 'Define a function that describes a task that can be invoked. It’s often essential
    to provide some help for the various parameters, which is done by providing a
    dictionary of parameter names and help text to the @task decorator:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个描述可以调用的任务的函数。通常，提供一些关于各种参数的帮助信息是至关重要的，这可以通过向@task装饰器提供参数名称和帮助文本的字典来完成：
- en: '[PRE39]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The docstring for the function becomes the help text provided by the invoke distance --help
    command. It’s very important to provide something that will help the user understand
    what the various commands will do and how to use them.
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数的文档字符串成为invoke distance --help命令提供的帮助文本。提供一些有助于用户理解各种命令将做什么以及如何使用它们的内容非常重要。
- en: The Context parameter is required, but it won’t be used in this example. This
    object provides a consistent context when invoking multiple separate tasks. It
    also provides methods to run external applications.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Context参数是必需的，但在这个例子中不会使用。该对象在调用多个单独的任务时提供一致的环境。它还提供了运行外部应用程序的方法。
- en: 'Perform any needed conversions on the various parameter values. Evaluate the
    “real-work” function with cleaned values:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对各种参数值进行所需的转换。使用清洗后的值评估“真实工作”函数：
- en: '[PRE41]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We’ve used sys.exit() to produce a failure message. It’s also possible to raise
    an exception, but this will show long traceback displays that may not be helpful.
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经使用sys.exit()来生成错误信息。也可以抛出异常，但这会显示长的跟踪信息，可能并不有用。
- en: 6.5.3 How it works...
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5.3 它是如何工作的...
- en: The invoke package examines the parameters for a given Python function and builds
    the necessary command-line parsing options. The parameter names become the names
    for options. In the example distance() function, the parameters of p1, p2, and
    u become the command-line options of --p1, --p2, and -u, respectively. This lets
    us provide the parameters flexibly when running the application. The values can
    be provided positionally, or by using the option flags.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: invoke包检查给定Python函数的参数，并构建必要的命令行解析选项。参数名称成为选项的名称。在示例distance()函数中，p1、p2和u的参数分别成为命令行选项--p1、--p2和-u。这使得我们可以在运行应用时灵活地提供参数。值可以是按位置提供，也可以通过使用选项标志提供。
- en: 6.5.4 There’s more...
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5.4 更多...
- en: The most important feature of invoke is its ability to act as a wrapper for
    other binary applications. The Context object that’s provided to each task provides
    ways to change the current working directory and run an arbitrary OS command.
    This includes options to update the environment of the subprocess, capture the
    output and error streams, provide an input stream, and many other features.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: invoke最重要的特性是它能够作为其他二进制应用程序的包装器。提供给每个任务的Context对象提供了更改当前工作目录和运行任意OS命令的方法。这包括更新子进程环境、捕获输出和错误流、提供输入流以及许多其他功能。
- en: We can use invoke to combine multiple applications under a single wrapper. This
    can help to simplify complicated collections of applications by providing a uniform
    interface via a single module of task definitions.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用invoke在单个包装器下组合多个应用程序。这可以通过提供一个统一的接口来简化复杂的应用程序集合，该接口通过单个任务定义模块实现。
- en: We can, for example, combine an application that computes distance between two
    points, and a separate application that processes a CSV file with an entire route
    of a connected series of points.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以组合一个计算两点之间距离的应用程序，以及一个处理连接一系列点的完整路线的CSV文件的应用程序。
- en: 'The overall design might look like this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 整体设计可能看起来像这样：
- en: '[PRE42]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The context.run() method will invoke an arbitrary OS-level command. The env
    parameter value provides updated environment variables to the command that’s executed.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: context.run()方法将调用任意的OS级命令。env参数值提供了更新环境变量的命令。
- en: 6.5.5 See also
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5.5 参见
- en: 'Additional recipes for application integration are shown in Chapter [14](ch018.xhtml#x1-75800014),
    [Application Integration: Combination](ch018.xhtml#x1-75800014).'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序集成的附加配方在第[14](ch018.xhtml#x1-75800014)章[应用程序集成：组合](ch018.xhtml#x1-75800014)中展示。
- en: The [https://www.pyinvoke.org](https://www.pyinvoke.org) web page contains all
    of the documentation on invoke.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.pyinvoke.org](https://www.pyinvoke.org)网页包含了关于invoke的所有文档。'
- en: 6.6 Using cmd to create command-line applications
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.6 使用cmd创建命令行应用程序
- en: There are several ways to create interactive applications. The [Using input()
    and getpass() for user input](ch010.xhtml#x1-3370002) recipe looked at functions
    such as input() and getpass.getpass(). The [Using argparse to get command-line
    input](ch010.xhtml#x1-3490004) recipe showed us how to use the argparse module
    to create applications with which a user can interact from the OS command line.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以创建交互式应用程序。[使用input()和getpass()获取用户输入](ch010.xhtml#x1-3370002)配方探讨了input()和getpass.getpass()等函数。[使用argparse获取命令行输入](ch010.xhtml#x1-3490004)配方展示了如何使用argparse模块创建用户可以从OS命令行与之交互的应用程序。
- en: 'We have another way to create interactive applications: using the cmd module.
    This module will prompt the user for input and then invoke a specific method of
    the class we provide.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有另一种创建交互式应用程序的方法：使用cmd模块。此模块将提示用户输入，然后调用我们提供的类的一个特定方法。
- en: 'Here’s an example of the interaction:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个交互示例：
- en: '[PRE43]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We entered the dice 5 command to set the number of dice. After that, the roll
    command showed the results of rolling five dice. The help command will show the
    available commands.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们输入了dice 5命令来设置骰子的数量。之后，roll命令显示了掷出五个骰子的结果。help命令将显示可用的命令。
- en: 6.6.1 Getting ready
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6.1 准备工作
- en: The core feature of a cmd.Cmd application is a read-evaluate-print loop (REPL).
    This kind of application works well when there are a number of individual state
    changes and a number of closely related commands to make those state changes.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: cmd.Cmd应用程序的核心特性是一个读取-评估-打印循环（REPL）。当存在多个单独的状态变化和许多密切相关用于执行这些状态变化的命令时，这种应用程序运行良好。
- en: We’ll make use of a simple, stateful dice game. The idea is to have a handful
    of dice, some of which can be rolled and some of which are frozen. This means
    our Cmd class definition must have some attributes that describe the current state
    of a handful of dice.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个简单的、有状态的骰子游戏。想法是有一把骰子，其中一些可以掷出，而另一些是冻结的。这意味着我们的Cmd类定义必须有一些属性来描述一把骰子的当前状态。
- en: 'Commands will include the following:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将包括以下内容：
- en: dice to set the number of dice
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: dice设置骰子的数量
- en: roll to roll the dice
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: roll掷骰子
- en: reroll to re-roll selected dice, leaving the others untouched
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: reroll重新掷选定的骰子，其他骰子保持不变
- en: 6.6.2 How to do it...
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6.2 如何实现...
- en: 'Import the cmd module to make the cmd.Cmd class definition available. Since
    this is a game, the random module will also be needed:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入cmd模块以使cmd.Cmd类定义可用。由于这是一个游戏，还需要随机模块：
- en: '[PRE44]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Define an extension to cmd.Cmd:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个扩展到cmd.Cmd：
- en: '[PRE45]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Define any initialization required in the preloop() method:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 preloop() 方法中定义任何所需的初始化：
- en: '[PRE46]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This method is evaluated once when the processing starts.
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法在处理开始时评估一次。
- en: Initialization can also be done in an __init__() method. However, doing this
    is a bit more complicated because it must collaborate with the Cmd class initialization.
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 初始化也可以在 __init__() 方法中完成。然而，这样做稍微复杂一些，因为它必须与 Cmd 类的初始化协作。
- en: 'For each command, create a do_command() method. The name of the method will
    be the command, prefixed by the characters do_. Any user input text after the
    command will be provided as an argument value to the method. The docstring comment
    in the method definition is the help text for the command. Here is the roll command,
    defined by the do_roll() method:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个命令，创建一个 do_command() 方法。方法名将是命令，前面加上 do_ 字符。任何命令之后的用户输入文本将作为方法的参数值提供。方法定义中的文档字符串注释是命令的帮助文本。以下是由
    do_roll() 方法定义的 roll 命令：
- en: '[PRE47]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Parse and validate the arguments to the commands that use them. The user’s
    input after the command will be provided as the value of the first positional
    argument to the method. Here is the dice command, defined by the do_dice() method:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析和验证使用它们的命令的参数。用户在命令之后的输入将作为方法第一个位置参数的值提供。以下是由 do_dice() 方法定义的 dice 命令：
- en: '[PRE48]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Write the main script. This will create an instance of this class and execute
    the cmdloop() method:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写主脚本。这将创建此类的实例并执行 cmdloop() 方法：
- en: '[PRE49]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The cmdloop() method handles the details of prompting, collecting input, and
    executing the proper method.
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: cmdloop() 方法处理提示、收集输入和根据用户的输入执行适当方法的细节。
- en: 6.6.3 How it works...
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6.3 它是如何工作的...
- en: The Cmd class contains a large number of built-in features to display a prompt,
    read input from a user, and then locate the proper method based on the user’s
    input.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Cmd 类包含大量内置功能来显示提示、从用户那里读取输入，然后根据用户的输入定位适当的方法。
- en: For example, when we enter a command like dice 5, the built-in methods of the
    Cmd superclass will strip the first word from the input, dice, and prefix this
    with do_. It will then try to evaluate the method with the argument value of the
    rest of the line, 5.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们输入 dice 5 这样的命令时，Cmd 超类的内置方法将从输入中删除第一个单词 dice，并将其前缀为 do_。然后它将尝试使用行剩余部分的参数值，即
    5，来评估该方法。
- en: If we enter a command for which there’s no matching do_*() method, the command
    processor writes an error message. This is done automatically; we don’t need to
    write any code to handle invalid command input.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们输入了一个没有匹配 do_*() 方法的命令，命令处理器将写入一个错误信息。这是自动完成的；我们不需要编写任何代码来处理无效的命令输入。
- en: Some methods, such as do_help(), are already part of the application. These
    methods will summarize the other do_* methods. When one of our methods has a docstring,
    this will be displayed by the built-in help feature.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 一些方法，如 do_help()，已经是应用程序的一部分。这些方法将总结其他 do_* 方法。当我们的方法有一个文档字符串时，这将通过内置的帮助功能显示。
- en: The Cmd class relies on Python’s facilities for introspection. An instance of
    the class can examine the method names to locate all of the methods that start
    with do_. Introspection is an advanced topic, one that will be touched on in Chapter [8](ch012.xhtml#x1-4520008).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Cmd 类依赖于 Python 的内省功能。类的实例可以检查方法名以定位所有以 do_ 开头的方法。内省是一个高级主题，将在第 [8](ch012.xhtml#x1-4520008)
    章中简要介绍。
- en: 6.6.4 There’s more...
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6.4 更多...
- en: 'The Cmd class has a number of additional places where we can add interactive
    features:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Cmd 类有多个可以添加交互功能的地方：
- en: We can define specific help_*() methods that become part of the help topics.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以定义特定的 help_*() 方法，使其成为帮助主题的一部分。
- en: When any of the do_*() methods return a non-False value, the loop will end.
    We might want to add a do_quit() method to return True.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当任何 do_*() 方法返回非 False 值时，循环将结束。我们可能想要添加一个 do_quit() 方法来返回 True。
- en: If the input stream is closed, an EOF command will be provided. In Linux, using
    ctrl-d will close the input file. This leads to the do_EOF() method, which should
    use return True.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果输入流被关闭，将提供一个 EOF 命令。在 Linux 中，使用 ctrl-d 将关闭输入文件。这导致 do_EOF() 方法，它应该使用 return
    True。
- en: We might provide a method named emptyline() to respond to blank lines.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能提供一个名为 emptyline() 的方法来响应空白行。
- en: The default() method is evaluated when the user’s input does not match any of
    the do_*() methods.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户的输入与任何 do_*() 方法都不匹配时，将评估 default() 方法。
- en: The postloop() method can be used to do some processing just after the loop
    finishes. This would be a good place to write a summary.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: postloop() 方法可以在循环结束后进行一些处理。这是一个写总结的好地方。
- en: 'Also, there are a number of attributes we can set. These are class-level variables
    that would be peers of the method definitions:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以设置一些属性。这些是与方法定义平级的类级变量：
- en: 'The prompt attribute is the prompt string to write. The intro attribute is
    the introductory text to write before the first prompt. For our example, we can
    do the following:'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提示属性是要写入的提示字符串。介绍属性是在第一个提示之前要写入的介绍性文本。对于我们的示例，我们可以这样做：
- en: '[PRE50]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We can tailor the help output by setting doc_header, undoc_header, misc_header,
    and ruler attributes.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过设置 doc_header、undoc_header、misc_header 和 ruler 属性来定制帮助输出。
- en: The goal is to be able to create a tidy class that handles user interaction
    as directly as possible.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是能够创建一个尽可能直接处理用户交互的整洁类。
- en: 6.6.5 See also
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6.5 相关内容
- en: We’ll look at class definitions in Chapter [7](ch011_split_000.xhtml#x1-3760007)
    and Chapter [8](ch012.xhtml#x1-4520008).
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在第 [7](ch011_split_000.xhtml#x1-3760007) 章和第 [8](ch012.xhtml#x1-4520008)
    章中查看类定义。
- en: 6.7 Using the OS environment settings
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.7 使用操作系统环境设置
- en: 'There are several ways to look at inputs provided by the users of our software:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方式来看待我们软件用户提供的输入：
- en: 'Interactive input: This is provided by the user as required by the application.
    See the [Using input() and getpass() for user input](ch010.xhtml#x1-3370002) recipe.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交互式输入：这是根据应用程序的要求由用户提供的。请参阅 [使用 input() 和 getpass() 获取用户输入](ch010.xhtml#x1-3370002)
    的配方。
- en: 'Command-line arguments: These are provided once, when the program is started.
    See the [Using argparse to get command-line input](ch010.xhtml#x1-3490004) and
    [Using invoke to get command-line input](ch010.xhtml#x1-3550005) recipes.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行参数：这些是在程序启动时提供的。请参阅 [使用 argparse 获取命令行输入](ch010.xhtml#x1-3490004) 和 [使用 invoke
    获取命令行输入](ch010.xhtml#x1-3550005) 的配方。
- en: 'Environment variables: These are OS-level settings. There are several ways
    these can be set:'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境变量：这些是操作系统级别的设置。有几种方式可以设置它们：
- en: At the command line, when running the application.
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在命令行中，当运行应用程序时。
- en: Set in a configuration file for the user’s selected shell. For example, if using
    zsh, these files are the ~/.zshrc file and the ~/.profile file. There can also
    be system-wide files, like the /etc/zshrc file.
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在用户选择的 shell 的配置文件中设置。例如，如果使用 zsh，这些文件是 ~/.zshrc 文件和 ~/.profile 文件。也可以有系统范围的文件，如
    /etc/zshrc 文件。
- en: In Windows, there’s the Advanced Settings option for environment variables.
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Windows 中，有环境变量的高级设置选项。
- en: 'Configuration files: These are unique to an application. They are the subject
    of Chapter [13](ch017.xhtml#x1-71500013).'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置文件：这些是特定于应用程序的。它们是第 [13](ch017.xhtml#x1-71500013) 章的主题。
- en: The environment variables are available through the os module.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量可以通过 os 模块获得。
- en: 6.7.1 Getting ready
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.7.1 准备工作
- en: 'In the [Using argparse to get command-line input](ch010.xhtml#x1-3490004) recipe,
    we wrapped the haversine() function in a simple application that parsed command-line
    arguments. We created a program that worked like this:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [使用 argparse 获取命令行输入](ch010.xhtml#x1-3490004) 的配方中，我们将 haversine() 函数包装在一个简单的应用程序中，该应用程序解析命令行参数。我们创建了一个这样工作的程序：
- en: '[PRE51]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: After using this version of the application for a while, we may find that we’re
    often using nautical miles to compute distances from where our boat is anchored.
    We’d really like to have default values for one of the input points as well as
    the -r argument.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用这个版本的应用程序一段时间后，我们可能会发现我们经常使用海里来计算从我们船锚定的地方的距离。我们真的希望有一个输入点的默认值以及 -r 参数的默认值。
- en: Since a boat can be anchored in a variety of places, we need to change the default
    without having to tweak the actual code. The idea of a ”slowly changing” argument
    value fits well with the OS environment variables. They can be persistent but
    are also relatively easy to change.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一艘船可以在多个地方锚定，我们需要在不修改实际代码的情况下更改默认设置。一个“缓慢变化”的参数值的概念与操作系统环境变量很好地吻合。它们可以持久存在，但相对容易更改。
- en: 'We’ll use two OS environment variables:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两个操作系统环境变量：
- en: UNITS will have the default distance units.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UNITS 将具有默认的距离单位。
- en: HOME_PORT can have an anchor point.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HOME_PORT 可以有一个锚点。
- en: 'We want to be able to do the following:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够做到以下几点：
- en: '[PRE52]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 6.7.2 How to do it...
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.7.2 如何实现...
- en: 'Import the os module. The default set of command-line arguments to parse comes
    from sys.argv, so it’s important to also import the sys module. The application
    will also depend on the argparse module:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入os模块。要解析的默认命令行参数集来自sys.argv，因此还需要导入sys模块。应用程序还将依赖于argparse模块：
- en: '[PRE53]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Import any other classes or objects needed for the application:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入应用程序需要的任何其他类或对象：
- en: '[PRE54]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Define a function that will use the environment values as defaults for optional
    command-line arguments:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数，该函数将使用环境值作为可选命令行参数的默认值：
- en: '[PRE55]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Gather default values from the OS environment settings. This includes any validation
    required:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从操作系统环境设置中收集默认值。这包括所需的任何验证：
- en: '[PRE56]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note that using os.environ.get() permits the application to include a default
    value for cases where the environment variable is not set.
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，使用os.environ.get()允许应用程序在环境变量未设置的情况下包含一个默认值。
- en: 'Create the parser object. Provide the default values for the relevant arguments
    extracted from the environment variables:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建解析器对象。为从环境变量中提取的相关参数提供默认值：
- en: '[PRE57]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Do any additional validation to ensure that arguments are set properly. In this
    example, it’s possible to have no value for HOME_PORT and no value provided for
    the second command-line argument.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行任何额外的验证以确保参数设置正确。在这个例子中，可能没有为HOME_PORT设置值，也没有为第二个命令行参数提供值。
- en: 'This requires an if statement and a call to sys.exit():'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这需要使用if语句和调用sys.exit()：
- en: '[PRE58]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Return the final options object with the set of valid arguments:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回包含有效参数集的最终选项对象：
- en: '[PRE59]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This will allow the -u argument and the second point to be optional. The argument
    parser will use the configuration information to supply default values if these
    are omitted from the command line.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使-u参数和第二个点成为可选的。如果这些参数从命令行中省略，参数解析器将使用配置信息提供默认值。
- en: There is a nuanced distinction in the error code provided by sys.exit(). When
    applications fail because of command-line problems, it’s common to return a status
    code of 2, but sys.exit() will set the value to 1\. A slightly better approach
    is to use the parser.error() method. Doing this requires refactoring to create
    the ArgumentParser instance before acquiring and validating values from environment
    variables.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit()提供的错误代码有细微的区别。当应用程序因命令行问题失败时，通常返回状态码2，但sys.exit()会将值设置为1。一个稍微更好的方法是使用parser.error()方法。这样做需要重构，在获取和验证环境变量值之前创建ArgumentParser实例。
- en: 6.7.3 How it works...
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.7.3 它是如何工作的...
- en: We’ve used the OS environment variables to create default values that can be
    overridden by command-line arguments. If the environment variable is set, that
    string is provided as the default to the argument definition. If the environment
    variable is not set, then an application-level default value will used. In the
    case of the UNITS variable, in this example, the application uses kilometers as
    the default if the OS environment variable is not set.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用操作系统环境变量来创建默认值，这些值可以被命令行参数覆盖。如果环境变量已设置，则该字符串将作为默认值提供给参数定义。如果没有设置环境变量，则应用程序将使用默认值。在UNITS变量的情况下，在这个例子中，如果操作系统环境变量未设置，应用程序将使用公里作为默认值。
- en: We’ve used the OS environment to set default values that can be overridden by
    the command-line argument values. This supports the idea of the environment providing
    a general context that might be shared by a number of commands.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用操作系统环境来设置默认值，这些值可以被命令行参数值覆盖。这支持环境提供可能由多个命令共享的一般上下文的概念。
- en: 6.7.4 There’s more...
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.7.4 更多...
- en: The [Using argparse to get command-line input](ch010.xhtml#x1-3490004) recipe
    shows a slightly different way to handle the default command-line arguments available
    from sys.argv. The first of the arguments is the name of the Python application
    being executed and is not often relevant to argument parsing.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用argparse获取命令行输入](ch010.xhtml#x1-3490004)的配方展示了处理从sys.argv中可用的默认命令行参数的略微不同的方法。第一个参数是正在执行的Python应用程序的名称，通常与参数解析不相关。'
- en: 'The value of sys.argv will be a list of strings:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: sys.argv的值将是一个字符串列表：
- en: '[PRE60]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We have to skip the initial value in sys.argv[0] at some point in the processing.
    Generally, the application needs to provide sys.argv[1:] to the parser. This can
    be done inside the get_options() function. It can be done when the main() function
    evaluates the get_options() function. As shown in this example, it can be done
    when creating the default argument values for the get_options() function.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理过程中，我们不得不在某些时候跳过 sys.argv[0] 的初始值。通常，应用程序需要将 sys.argv[1:] 提供给解析器。这可以在 get_options()
    函数内部完成。这也可以在 main() 函数评估 get_options() 函数时完成。正如本例所示，这也可以在为 get_options() 函数创建默认参数值时完成。
- en: The argparse module allows us to provide type information for an argument definition.
    Providing type information can be used to validate argument values. In many cases,
    there may be a finite list of choices for a value, and this set of allowed choices
    can be provided as part of the argument definition. Doing this creates better
    error and help messages, improving the user experience when running the application.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: argparse 模块允许我们为参数定义提供类型信息。提供类型信息可以用于验证参数值。在许多情况下，一个值可能有一组有限的选项，这组允许的选项可以作为参数定义的一部分提供。这样做可以创建更好的错误和帮助信息，提高应用程序运行时的用户体验。
- en: 6.7.5 See also
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.7.5 参见
- en: We’ll look at numerous ways to handle configuration files in Chapter [13](ch017.xhtml#x1-71500013).
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在第 [13](ch017.xhtml#x1-71500013) 章节中探讨处理配置文件的多种方法。
- en: Join our community Discord space
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的社区 Discord 空间
- en: 'Join our Python Discord workspace to discuss and find out more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Python Discord 工作空间，讨论并了解更多关于这本书的信息：[https://packt.link/dHrHU](https://packt.link/dHrHU)
- en: '![PIC](img/file1.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1.png)'
