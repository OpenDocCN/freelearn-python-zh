- en: Chapter 7. Design Patterns in Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。Python中的设计模式
- en: Design Patterns simplify building software by reusing successful designs and
    architectures. Patterns build on the collective experience of software engineers
    and architects. When encountered with a problem which needs new code to be written,
    an experienced software architect tends to make use of the rich ecosystem of available
    design/architecture patterns.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式通过重用成功的设计和架构简化软件构建。模式建立在软件工程师和架构师的集体经验之上。当遇到需要编写新代码的问题时，经验丰富的软件架构师倾向于利用可用的设计/架构模式丰富的生态系统。
- en: Patterns evolve when a specific design proves successful in solving certain
    classes of problems repeatedly. When experts find that a specific design or architecture
    helps them to solve classes of related problems consistently, they tend to apply
    it more and more, codifying the structure of the solution into a pattern.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当专家发现特定的设计或架构帮助他们一贯解决相关问题类时，模式会不断演变。他们倾向于越来越多地应用它，将解决方案的结构编码为模式。
- en: Python, being a language which supports dynamic types, and high-level object
    oriented structures like classes and metaclasses, first-class functions, co-routines,
    callable objects, and so on, is a very rich playground for constructing reusable
    design and architecture patterns. In fact, as opposed to languages like C++ or
    Java, you would often find there are multiple ways of implementing a specific
    design pattern in Python. Also, more often than not, you would find that the Pythonic
    ways of implementing a pattern is more intuitive and illustrative than, say, copying
    a standard implementation from C++/Java into Python.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种支持动态类型和高级面向对象结构（如类和元类）、一级函数、协程、可调用对象等的语言，非常适合构建可重用的设计和架构模式。实际上，与C++或Java等语言相反，你会经常发现在Python中实现特定设计模式的多种方法。而且，往往你会发现Python实现模式的方式比从C++/Java中复制标准实现更直观和有说明性。
- en: This chapter's focus is mostly on this latter aspect—illustrating how one can
    build design patterns which are more Pythonic than what usual books and literature
    on this topic tend to do. It doesn't aim to be a comprehensive guide to design
    patterns, though we would be covering most of the usual aspects as we head into
    the content.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点主要是后一方面——说明如何构建更符合Python风格的设计模式，而不是通常关于这个主题的书籍和文献所倾向于做的。它并不旨在成为设计模式的全面指南，尽管随着内容的展开，我们将涵盖大部分常见方面。
- en: 'The topics we plan to cover in this chapter are as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计划在本章中涵盖的主题如下：
- en: Design patterns elements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计模式元素
- en: Categories of design patterns
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计模式的类别
- en: Pluggable hashing algorithms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可插拔哈希算法
- en: Summing up pluggable hashing algorithms
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总结可插拔哈希算法
- en: Patterns in Python – Creational
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的模式 - 创造性
- en: The Singleton pattern
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例模式
- en: The Borg pattern
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 波格模式
- en: The Factory pattern
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂模式
- en: The Prototype pattern
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型模式
- en: The Builder pattern
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器模式
- en: Patterns in Python – Structural
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的模式 - 结构性
- en: The Adapter pattern
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器模式
- en: The Facade pattern
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外观模式
- en: The Proxy pattern
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理模式
- en: Patterns in Python – Behavioral
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的模式 - 行为
- en: The Iterator pattern
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器模式
- en: The Observer pattern
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者模式
- en: The State pattern
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态模式
- en: Design patterns - Elements
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式 - 元素
- en: A design pattern attempts to record those aspects of a recurring design in object-oriented
    systems that solve a problem or a class of problems.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式试图记录面向对象系统中解决问题或一类问题的重复设计的方面。
- en: 'When we inspect design patterns, we find that almost all of them have the following
    elements:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检查设计模式时，我们发现几乎所有设计模式都具有以下元素：
- en: '**Name**: A well-known handle or title, which is commonly used to describe
    the pattern. Having standard names for design patterns aids communication and
    increases our design vocabulary.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称：常用于描述模式的知名句柄或标题。为设计模式使用标准名称有助于沟通并增加我们的设计词汇量。
- en: '**Context**: This is the situation in which the problem arises. A context can
    be generic like *develop a web application software*, or specific like *Implementing
    resource-change notification in a shared memory implementation of the publisher-subscriber
    system*.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 背景：问题出现的情况。背景可以是通用的，如“开发Web应用软件”，也可以是具体的，如“在发布者-订阅者系统的共享内存实现中实现资源更改通知”。
- en: '**Problem**: Describes the actual problem that the pattern is applied for.
    A problem can be described in terms of its forces, which are as follows:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题：描述了模式适用的实际问题。问题可以根据其力量来描述，如下所示：
- en: '**Requirements**: The requirements that the solution should fulfill, for example,
    the *Publisher-subscriber pattern implementation must support HTTP*.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要求：解决方案应满足的要求，例如，“发布者-订阅者模式实现必须支持HTTP”。
- en: '**Constraints**: The constraints to the solution, if any, for example, the
    *Scalable peer-to-peer publisher pattern should not exchange more than three messages
    for publishing a notification*.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 约束：解决方案的约束，如果有的话，例如，“可扩展的点对点发布者模式在发布通知时不应交换超过三条消息”。
- en: '**Properties**: The properties of the solution which are desirable to have,
    for example, *The solution should work equally well on the Windows and Linux platforms*.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性：解决方案的期望属性，例如，“解决方案应在Windows和Linux平台上同样有效”。
- en: '**Solution**: Shows the actual solution to the problem. It describes the structure
    and responsibilities, the static relationships, and the runtime interactions (collaborations)
    of the elements making up the solution. A solution should also discuss what *forces*
    of the problem it solves, and what it doesn''t. A solution should also try to
    mention its consequences, that is, the results and trade-offs of applying a pattern.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案：显示了问题的实际解决方案。它描述了解决方案的结构和责任、静态关系以及组成解决方案的元素之间的运行时交互（协作）。解决方案还应讨论它解决的问题的“力量”，以及它不解决的问题。解决方案还应尝试提及其后果，即应用模式的结果和权衡。
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A design pattern solution almost never resolves all the forces of the problem
    leading to it, but leaves some of them open to related or alternate implementations.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式解决方案几乎从不解决导致它的问题的所有力量，而是留下一些力量供相关或替代实现使用。
- en: Categories of design patterns
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式的分类
- en: Design patterns can be categorized in different ways according to the criteria
    chosen. A commonly accepted way of categorizing is by using the criterion of purpose
    of the pattern. In other words, we ask the pattern what class of problems the
    pattern solves.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式可以根据所选择的标准以不同的方式进行分类。一个常见的分类方式是使用模式的目的作为标准。换句话说，我们问模式解决了什么类的问题。
- en: 'This kind of categorization gives us three neat varieties of pattern classes.
    These are as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分类给我们提供了三种模式类的清晰变体。它们如下：
- en: '**Creational**: These patterns solve the problems associated with object creation
    and initialization. These are problems that occur the earliest in the life cycle
    of problem solving with objects and classes. Take a look at the following examples:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建模式**：这些模式解决了与对象创建和初始化相关的问题。这些问题是在对象和类的问题解决生命周期的最早阶段出现的。看一下以下的例子：'
- en: '**The Factory pattern**: The "How do I make sure I can create related class
    instances in a repeatable and predictable fashion?" question is solved by the
    Factory class of patterns'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工厂模式**："如何确保我可以以可重复和可预测的方式创建相关的类实例？"这个问题由工厂模式类解决'
- en: '**The Prototype pattern**: The "What is a smart approach to instantiate an
    object, and then create hundreds of similar objects by just copying across this
    one object ?" question is solved by the Prototype patterns'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原型模式**："如何智能地实例化一个对象，然后通过复制这个对象创建数百个类似的对象？"这个问题由原型模式解决'
- en: '**Singleton and related patterns**: The "How do I make sure that any instance
    of a class I create is created and initialized just once" or "How do I make sure
    that any instances of a class share the same initial state ?" questions are solved
    by the Singleton and related patterns'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单例和相关模式**："如何确保我创建的类的任何实例只创建和初始化一次"或"如何确保类的任何实例共享相同的初始状态？"这些问题由单例和相关模式解决'
- en: '**Structural**: These patterns concern themselves with composition and assembling
    of objects into meaningful structures, which provides the architect and developer
    with reusable behaviors, where "the whole is more than the sum of its parts".
    Naturally, they occur in the next step of problem solving with objects, once they
    are created. Examples of such problems are as follows:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构模式**：这些模式涉及对象的组合和组装成有意义的结构，为架构师和开发人员提供可重用的行为，其中“整体大于部分的总和”。自然地，它们出现在解决对象问题的下一步，一旦它们被创建。这些问题的例子如下：'
- en: '**The Proxy pattern**: "How do I control access to an object and its methods
    via a wrapper, behavior on top?"'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理模式**："如何通过包装器控制对对象及其方法的访问，以及在顶部的行为？"'
- en: '**The Composite pattern**: "How can I represent an object which is made of
    many components at the same time using the same class for representing the part
    and the whole—for example, a Widget tree ?"'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合模式**："如何使用相同的类同时表示部分和整体来表示由许多组件组成的对象，例如，一个Widget树？"'
- en: '**Behavioral**: These patterns solve the problems originating with runtime
    interactions of objects, and how they distribute responsibilities. Naturally,
    they occur in the later stage, once the classes are created, and then combined
    into larger structures. Here are a couple of examples:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行为模式**：这些模式解决了对象在运行时交互产生的问题，以及它们如何分配责任。自然地，它们出现在后期阶段，一旦类被创建，然后组合成更大的结构。以下是一些例子：'
- en: '**Using the Median pattern in such case**: "Ensure that all the objects use
    loose coupling to refer to each other at runtime to promote run-time dynamism
    for interactions"'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在这种情况下使用中介者模式**："确保所有对象在运行时使用松散耦合来相互引用，以促进交互的运行时动态性"'
- en: '**Using the Observer pattern in such case**: "An object wants to be notified
    when the state of a resource changes, but it does not want to keep polling the
    resource to find this out. There may be many such instances of objects in the
    system"'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在这种情况下使用观察者模式**："一个对象希望在资源的状态发生变化时得到通知，但它不想一直轮询资源来找到这一点。系统中可能有许多这样的对象实例"'
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The order of Creational, Structural, and Behavioral patterns implicitly embed
    the life cycle of objects in a system at runtime. Objects are first created (Creational),
    then combined into useful structures (Structural), and then they interact (Behavioral).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 创建模式、结构模式和行为模式的顺序隐含地嵌入了系统中对象的生命周期。对象首先被创建（创建模式），然后组合成有用的结构（结构模式），然后它们相互作用（行为模式）。
- en: Let us now turn our attention to the subject matter of this chapter, namely,
    implementing Patterns in Python in Python's own inimitable way. We will look at
    an illustrative example to get the matter going.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在把注意力转向本章的主题，即以Python独特的方式在Python中实现模式。我们将看一个例子来开始讨论这个问题。
- en: Pluggable hashing algorithms
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可插拔的哈希算法
- en: Let us look at the following problem.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下的问题。
- en: 'You want to read data from an input stream—a file or network socket—and hash
    the contents in a chunked manner. You write some code like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你想从输入流（文件或网络套接字）中读取数据，并以分块的方式对内容进行哈希。你写了一些像这样的代码：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All code is in Python3, unless explicitly mentioned otherwise.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 所有代码都是Python3，除非另有明确说明。
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So that works, as expected.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这样做是符合预期的。
- en: 'Now let''s say you want a more reusable and versatile implementation, one that
    will work with multiple hashing algorithms. You first attempt to modify the previous
    code, but quickly realize that this means rewriting a lot of code, which is not
    a very smart way of doing it:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你想要一个更可重用和多功能的实现，可以与多个哈希算法一起使用。你首先尝试修改以前的代码，但很快意识到这意味着重写大量的代码，这不是一个很聪明的做法：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You realize that you can reuse a lot of code by using a class. Being an experienced
    programmer, you may end up with something like this after a few iterations:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您会意识到，通过使用类，您可以重复使用大量代码。作为一名经验丰富的程序员，经过几次迭代后，您可能会得到类似这样的东西：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'First lets try with `md5`, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们尝试使用`md5`，如下所示：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now with `sha1`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用`sha1`：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As it must be evident by now, you can build different hasher objects, each with
    a specific algorithm, which will return the corresponding hash digest of the stream
    (in this case, a file).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如现在显而易见的那样，您可以构建不同的哈希对象，每个对象都有一个特定的算法，将返回流的相应哈希摘要（在这种情况下是文件）。
- en: Now lets summarize what we just did here.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们总结一下我们刚刚做的事情。
- en: We first developed a function, `hash_stream`, which took in a stream object,
    and hashed it chunk-wise using the `md5` algorithm. We then developed a class
    named `StreamHasher`, which allowed us to configure it using one algorithm at
    a time, thereby making the code more reusable. We obtained the hash digest by
    way of the method `get_hash`, which accepts the stream object as argument.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先开发了一个名为`hash_stream`的函数，它接受一个流对象，并使用`md5`算法逐块对其进行哈希。然后我们开发了一个名为`StreamHasher`的类，允许我们一次配置一个算法，从而使代码更可重用。我们通过`get_hash`方法获得哈希摘要，该方法接受流对象作为参数。
- en: Now let us turn our attention to what more Python can do for us.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们把注意力转向Python可以为我们做的更多事情。
- en: Our class is versatile with respect to different hashing algorithms, and is
    definitely more reusable, but is there a way to call it as if it were a function
    ? That would be rather neat, wouldn't it?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类对于不同的哈希算法是多功能的，并且肯定更可重用，但是有没有一种方法可以像调用函数一样调用它？那将非常棒，不是吗？
- en: 'Here is a slight reimplementation of our `StreamHasher` class, which does just
    that:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`StreamHasher`类的一个轻微重新实现，它就是这样做的：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: What did we do in the last code ? We simply renamed the `get_hash` function
    as `Get_Call`. Let us see what effect this has.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一段代码中我们做了什么？我们只是将`get_hash`函数重命名为`Get_Call`。让我们看看这会产生什么影响。
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We are able to call the instance of the class as if it were a function by simply
    passing the file object to it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够调用类的实例，就像调用函数一样，只需将文件对象传递给它。
- en: So our class not only gives us reusable and versatile code, but also acts as
    if it were a function. This is done by making our class a callable type in Python
    by simply implementing the magic method `__call__` .
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的类不仅为我们提供了可重用和多功能的代码，而且还可以像函数一样运行。这是通过在Python中使我们的类成为可调用类型来实现的，只需实现魔术方法`__call__`。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Callables** in Python are any object that can be called. In other words,
    `x` is a callable if we can perform `x()`—with or without params depending upon
    how the `__call__` method is overridden. Functions are the simplest and most familiar
    callables.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，**可调用对象**是指可以被调用的任何对象。换句话说，如果我们可以执行`x()`，那么`x`就是一个可调用对象，具体取决于`__call__`方法如何被覆盖，可以带参数也可以不带参数。函数是最简单和最熟悉的可调用对象。
- en: In Python, `foo(args)` is a syntactic sugar for `foo.__call__(args)`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，`foo(args)`是`foo.__call__(args)`的一种语法糖。
- en: Summing up pluggable hashing algorithm
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结可插拔的哈希算法
- en: So what does the previous example illustrate? It illustrates the power of Python
    in taking an existing problem, which would be solved traditionally in other programming
    languages, in a more exotic and powerful way due to the power of Python and the
    way it does things—in this case, by making any object callable by overriding a
    special method.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 那么前面的例子说明了什么？它说明了Python的强大之处，它以一种更奇特和强大的方式解决了传统上在其他编程语言中解决的现有问题，这是由于Python的强大之处以及它的工作方式——在这种情况下，通过覆盖特殊方法使任何对象可调用。
- en: But what is the pattern we have achieved here? We discussed in the beginning
    of the chapter that something is a pattern only if it solves a class of problems.
    Is there a pattern hidden in this particular illustration?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们在这里实现了什么模式？我们在本章开头讨论过，只有解决了一类问题，才能成为模式。这个特定的例子中是否隐藏着一种模式？
- en: 'Yes there is—this is an implementation of the Strategy behavioral pattern:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这是策略行为模式的一种实现：
- en: '*Strategy pattern is used when we need different behaviors from a class and
    we should be able to configure a class with one of many available behaviors or
    algorithms*.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*当我们需要从一个类中获得不同的行为，并且我们应该能够使用众多可用的行为或算法之一来配置一个类时，就会使用策略模式*。'
- en: In this particular case, we needed a class which supports different algorithms
    to perform the same thing—hashing data from a stream using chunks, and returning
    the digest. The class accepted the algorithm as a parameter, and since all algorithms
    support the same method for returning data (the method `hexdigest`), we were able
    to implement the class in a very simple way.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种特殊情况下，我们需要一个支持使用不同算法执行相同操作的类——使用块从流中哈希数据，并返回摘要。该类接受算法作为参数，由于所有算法都支持相同的返回数据方法（`hexdigest`方法），我们能够以非常简单的方式实现该类。
- en: Let us continue our journey to find out what are some other interesting patterns
    we can write using Python, and its unique way of solving problems. We will follow
    the order of the Creational, Structural, and Behavioral patterns in this journey.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续我们的旅程，找出使用Python编写的其他有趣模式，以及它独特解决问题的方式。在这个旅程中，我们将按照创建型、结构型和行为型模式的顺序进行。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Our approach to the discussion on patterns that follows is very pragmatic. It
    may not use the formal language used by the popular **Gang-of-four** (**G4**)
    patterns—the most elemental approach to Design Patterns. Our focus is on demonstrating
    the power of Python in building patterns rather than getting the formalisms right.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对接下来讨论的模式的方法非常务实。它可能不使用流行的**四人帮**（**G4**）模式所使用的正式语言——这是设计模式的最基本方法。我们的重点是展示Python在构建模式方面的能力，而不是追求形式主义的正确性。
- en: Patterns in Python – Creational
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的模式-创建型
- en: In this section, we will take a look at a few of the common creational patterns.
    We will start with Singleton, and then go on to Prototype, Builder, and Factory,
    in that order.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一些常见的创建型模式。我们将从Singleton开始，然后按顺序进行原型、生成器和工厂。
- en: The Singleton pattern
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单例模式
- en: 'The Singleton pattern is one of the most well-known and easily understood patterns
    in the entire pantheon of design patterns. It is usually defined as:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式是设计模式中最著名和最容易理解的模式之一。它通常被定义为：
- en: '*A Singleton is a class which has only one instance and a well-defined point
    of access to it*.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*单例是一个只有一个实例和明确定义的访问点的类*。'
- en: 'The requirements of a Singleton can be summarized as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 单例的要求可以总结如下：
- en: A class must have only one instance accessible via a well-known access point
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类必须只有一个通过一个众所周知的访问点可访问的实例
- en: The class must be extensible by inheritance without breaking the pattern
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类必须可以通过继承进行扩展，而不会破坏模式
- en: 'The simplest Singleton implementation in Python is shown next. It is done by
    overriding the `__new__` method of the base `object` type:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中最简单的单例实现如下所示。它是通过重写基本`object`类型的`__new__`方法完成的：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Since we would be requiring this check for a while, let us define a function
    for the same:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们将需要一段时间进行这个检查，让我们为此定义一个函数：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now let us see if our Singleton implementation satisfies the second requirement.
    We will define a simple subclass to test this:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在让我们看看我们的单例实现是否满足第二个要求。我们将定义一个简单的子类来测试这一点：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Cool! So our simple implementation passes the test. Are we done here now?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！所以我们简单的实现通过了测试。我们现在完成了吗？
- en: 'Well, the point with Python, as we discussed before, is that it provides a
    number of ways to implement patterns due to its dynamism and flexibility. So,
    let us keep up with the Singleton for a while, and see if we can get some illustrative
    examples which would give us insights into the power of Python:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，正如我们之前讨论过的，Python提供了许多实现模式的方法，因为它的动态性和灵活性。所以，让我们继续关注单例一段时间，看看我们是否能得到一些有启发性的例子，这些例子会让我们了解Python的强大之处：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding implementation moves the logic of creating a Singleton to the
    type of the class, namely, its metaclass.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的实现将创建单例的逻辑移到了类的类型，即其元类。
- en: We first create a type for Singletons, named `MetaSingleton`, by extending type
    and overriding the `__init__` and `__call__` methods on the metaclass. Then we
    declare the `SingletonM` class, `SingletonM`, as using the metaclass.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个名为`MetaSingleton`的单例类型，通过扩展类型并在元类上重写`__init__`和`__call__`方法。然后我们声明`SingletonM`类，`SingletonM`，使用元类。
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here is a peep into what is happening behind the scenes in the new implementation
    of the Singleton:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个对单例新实现背后发生的事情的一瞥：
- en: '**Initializing a class variable**: We can either do it at the class level (just
    after the class declaration) as we saw in previous implementation, or we can put
    it in the metaclass `__init__` method. This is what we are doing here for the
    `_instance` class variable, which will hold the single instance of the class.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**初始化类变量**：我们可以在类级别（在类声明后）进行，就像我们在之前的实现中看到的那样，或者我们可以将其放在元类`__init__`方法中。这就是我们在这里为`_instance`类变量所做的，它将保存类的单个实例。'
- en: '**Overriding class creation**: One can either do it at the class level by overriding
    the `__new__` method of class as we saw in previous implementation, or, equivalently,
    do it in the metaclass by overriding its `__call__` method. This is what the new
    implementation does.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**覆盖类创建**：可以在类级别通过重写类的`__new__`方法进行，就像我们在之前的实现中看到的那样，或者可以在元类中通过重写其`__call__`方法来进行。这就是新实现所做的。'
- en: Note
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When we override a class's `__call__` method, it affects its instance, and instances
    become callable. Similarly, when we override a metaclass's `_call_` method, it
    affects its classes, and modifies the way the classes are called—in other words,
    the way the class creates its instances.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们重写一个类的`__call__`方法时，它会影响它的实例，并且实例变得可调用。同样，当我们重写元类的`_call_`方法时，它会影响它的类，并修改类被调用的方式-换句话说，类创建其实例的方式。
- en: 'Let''s take a look at the pros and cons in the metaclass approach over the
    class approach:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看元类方法相对于类方法的优缺点：
- en: One benefit is that we can create any number of new top-level classes which
    get Singleton behavior via the metaclass. Using the default implementation, every
    class has to inherit the top-level class Singleton or its subclasses to obtain
    Singleton behavior. The metaclass approach provides more flexibility with respect
    to class hierarchies.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个好处是我们可以创建任意数量的新顶级类，通过元类获得单例行为。使用默认实现，每个类都必须继承顶级类Singleton或其子类以获得单例行为。元类方法提供了更多关于类层次结构的灵活性。
- en: However, the metaclass approach can be interpreted as creating slightly obscure
    and difficult-to-maintain code as opposed to the class approach. This is because
    the number of Python programmers who understand metaclasses and metaprogramming
    are less when compared to those who understand classes. This may be a disadvantage
    with the metaclass solution.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，与类方法相比，元类方法可能被解释为创建略微晦涩和难以维护的代码。这是因为了解元类和元编程的Python程序员数量较少，而了解类的程序员数量较多。这可能是元类解决方案的一个缺点。
- en: Now let us think out of the box, and see if we can solve the Singleton problem
    in a little different way.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们打破常规，看看我们是否可以以稍有不同的方式解决单例问题。
- en: The Singleton – do we need a Singleton?
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单例-我们需要单例吗？
- en: 'Let us paraphrase the first requirement of a Singleton in a way slightly different
    from the original:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个与原始略有不同的方式来解释单例的第一个要求：
- en: '*A class must provide a way for all its instances to share the same initial
    state.*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*类必须提供一种让所有实例共享相同初始状态的方法。*'
- en: To explain that, let us briefly look at what a Singleton pattern actually tries
    to achieve.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释这一点，让我们简要地看一下单例模式实际上试图实现什么。
- en: When a Singleton ensures it has only one instance, what it guarantees is that
    the class provides one single state when it is created and initialized. In other
    words, what a Singleton actually gives is a way for a class to ensure a single
    shared state across all its instances.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当单例确保只有一个实例时，它保证的是类在创建和初始化时提供一个单一状态。换句话说，单例实际上提供的是一种让类确保所有实例共享单一状态的方式。
- en: In other words, the first requirement of the Singleton can be paraphrased in
    a slightly different form, which has the same end result as the first form.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，单例的第一个要求可以用稍微不同的形式来表述，这与第一种形式有相同的结果。
- en: '*A class must provide a way for all its instances to share the same initial
    state*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个类必须提供一种方法，使其所有实例共享相同的初始状态*'
- en: '*The technique of ensuring just a single actual instance at a specific memory
    location is just one way of achieving this.*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*确保在特定内存位置只有一个实际实例的技术只是实现这一点的一种方式。*'
- en: Ah! So what has been happening so far is that we have been expressing the pattern
    in terms of the implementation details of lesser flexible and versatile programming
    languages, really. With a language like Python, we need not stick pedantically
    to this original definition.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 啊！到目前为止，我们一直在用不太灵活和多用途的编程语言的实现细节来表达模式，实际上。使用Python这样的语言，我们不需要死板地坚持这个原始定义。
- en: 'Let us look at the following class:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下类：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This pattern ensures that when you create a class, you specifically initialize
    all of its instances with a shared state which belongs to the class (since it
    is declared at the class level).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式确保当你创建一个类时，你可以明确地用属于类的共享状态初始化它的所有实例（因为它是在类级别声明的）。
- en: What we really care about in a Singleton is actually this shared state, so `Borg`
    works without worrying about all instances being exactly the same.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在单例中我们真正关心的是这种共享状态，所以`Borg`可以在不担心所有实例完全相同的情况下工作。
- en: Since this is Python, it does this by initializing a shared state dictionary
    on the class, and then instantiating the instance's dictionary to this value,
    thereby ensuring that all instances share the same state.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是Python，它通过在类上初始化一个共享状态字典，然后将实例的字典实例化为这个值来实现这一点，从而确保所有实例共享相同的状态。
- en: 'Here is a specific example of `Borg` in action:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Borg`实际操作的一个具体示例：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So using `Borg`, we managed to create a class whose instances share the same
    state, even though the instances are actually not the same. And the state change
    was propagated across the instances; as the preceding example shows, when we change
    the value of state in `i1`, it also changes in `i2`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 所以使用`Borg`，我们成功创建了一个类，其实例共享相同的状态，即使实例实际上并不相同。状态的改变也传播到了实例；正如前面的例子所示，当我们改变`i1`中的状态值时，`i2`中的状态值也会改变。
- en: What about dynamic values? We know it will work in a Singleton, since it's the
    same object always, but what about the Borg?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 动态值呢？我们知道它在单例中可以工作，因为它总是相同的对象，但是波尔格呢？
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: So we attached a dynamic attribute `x` to instance `i1`, and it appeared in
    instance `i2` as well. Neat!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们给实例`i1`附加了一个动态属性`x`，它也出现在实例`i2`中。很整洁！
- en: 'So let''s see if there are any benefits of `Borg` over Singleton:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们看看`Borg`是否比单例有任何好处：
- en: In a complex system where we may have multiple classes inheriting from a root
    Singleton class, it may be difficult to impose the requirement of a single instance
    due to import issues or race conditions—for example, if a system is using threads.
    A Borg pattern circumvents these problems neatly by doing away with the requirement
    of a single instance in memory.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个复杂的系统中，我们可能有多个类从根单例类继承，由于导入问题或竞争条件（例如，如果系统正在使用线程），要求一个单一实例可能很难实现。波尔格模式通过巧妙地摆脱了内存中单一实例的要求，解决了这些问题。
- en: The Borg pattern also allows for simple sharing of state across the Borg class
    and all its subclasses. This is not the case for a Singleton, since each subclass
    creates its own state. We will see an example illustrating this next.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 波尔格模式还允许在波尔格类和其所有子类之间简单共享状态。这对于单例来说并非如此，因为每个子类都创建自己的状态。我们将在接下来的示例中看到一个说明。
- en: State sharing – Borg versus Singleton
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态共享——波尔格与单例
- en: A Borg pattern always shares the same state from the top class (Borg) down to
    all the subclasses. This is not the case with a Singleton. Let us see an illustration.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 波尔格模式总是从顶级类（波尔格）向下到所有子类共享相同的状态。这在单例中并非如此。让我们看一个例子。
- en: 'For this exercise, we will create two subclasses of our original Singleton
    class, namely, `SingletonA` and `SingletonB`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建我们原始单例类的两个子类，即`SingletonA`和`SingletonB`：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let us create a subclass of `SingletonA`, namely, `SingletonA1`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建`SingletonA`的一个子类，即`SingletonA1`：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now lets create instances:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建实例：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let us attach a dynamic property, `x`, with a value `100` to `a`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给`a`附加一个值为100的动态属性`x`：
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let us check if this is available on the instance `a1` of the subclass `SingletonA1`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下子类`SingletonA1`的实例`a1`上是否可用：
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Good! Now let us check if it is available on the instance `b`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 好了！现在让我们检查它是否在实例`b`上可用：
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Oops! So it appears that `SingletonA` and `SingletonB` don't share the same
    state. This is why a dynamic attribute that is attached to an instance of `SingletonA`
    appears in the instance of its sub-classes, but doesn't appear on the instance
    of a sibling or peer subclass namely `SingletonB` – because it is an a different
    branch of the class hierarchy from the top-level `Singleton` class.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕！看起来`SingletonA`和`SingletonB`并不共享相同的状态。这就是为什么附加到`SingletonA`实例的动态属性会出现在其子类的实例上，但不会出现在同级或同级子类`SingletonB`的实例上的原因——因为它是类层次结构中与顶级`Singleton`类不同的分支。
- en: Let us see if the Borgs can do any better.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看波尔格是否能做得更好。
- en: 'First, let''s create the classes and their instances:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建类和它们的实例：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now let''s attach a dynamic attribute x to a with value 100:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们给`a`附加一个值为100的动态属性x：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s check if the instance of the sibling class Borg also gets it:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查同级类波尔格的实例是否也有它：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This proves that the Borg pattern is much better at state sharing across classes
    and sub-classes than the Singleton pattern, and it does so without a lot of fuss
    or the overhead of ensuring a single instance.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明了Borg模式在跨类和子类之间共享状态方面比Singleton模式更好，并且这样做不需要大量的麻烦或确保单个实例的开销。
- en: Let us now move on to other creational patterns.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转向其他创建模式。
- en: The Factory pattern
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工厂模式
- en: The Factory pattern solves the problem of creating instances of related classes
    to another class, which usually implements the instance creation via a single
    method, usually, defined on a parent Factory class and overridden by subclasses
    (as needed).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂模式解决了创建与另一个类相关的类的实例的问题，通常通过单个方法实现实例创建，通常在父工厂类上定义，并由子类（根据需要）覆盖。
- en: The Factory pattern provides a convenient way for the client (user) of a class
    to provide a single entry point to create instances of classes and subclasses,
    usually, by passing in parameters to a specific method of the `Factory` class
    namely the Factory Method.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂模式为类的客户（用户）提供了一个方便的方式，通过`Factory`类的特定方法传递参数，通常是通过创建类和子类的实例的单个入口点。
- en: 'Let us look at a specific example:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个具体的例子：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We have created a general `Employee` class with some attributes and three subclasses,
    namely, `Engineer`, `Accountant`, and `Admin`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个通用的`Employee`类，具有一些属性和三个子类，分别是`Engineer`，`Accountant`和`Admin`。
- en: Since all of them are related classes, a `Factory` class is useful to abstract
    away the creation of instances of these classes.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们都是相关类，因此`Factory`类对于抽象化这些类的实例创建非常有用。
- en: 'Here is our `EmployeeFactory` class:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`EmployeeFactory`类：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The class provides a single `create` factory method, which accepts a `name`
    parameter, which is matched to the class's name and instance created accordingly.
    The rest of the arguments are parameters required for instantiating the class's
    instance, which is passed unchanged to its constructor.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 该类提供了一个`create`工厂方法，接受一个`name`参数，该参数与类的名称匹配，并相应地创建实例。其余参数是实例化类实例所需的参数，这些参数不变地传递给其构造函数。
- en: 'Let us see our `Factory` class in action:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的`Factory`类如何运作：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here are a few interesting notes about our `Factory` class:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于我们的`Factory`类的一些有趣的注释：
- en: A single factory class can create instances of any class in the Employee hierarchy.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个工厂类可以创建员工层次结构中任何类的实例。
- en: In the Factory pattern, it is conventional to use one `Factory` class associated
    to a class family (a class and its subclass hierarchy). For example, a `Person`
    class could use a `PersonFactory`, an automobile class—`AutomobileFactory`, and
    so on.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在工厂模式中，通常使用一个与类族（类及其子类层次结构）相关联的`Factory`类是常规做法。例如，`Person`类可以使用`PersonFactory`，汽车类可以使用`AutomobileFactory`，依此类推。
- en: 'The Factory method is usually decorated as a `classmethod` in Python. This
    way it can be called directly via the class namespace. For example:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中，工厂方法通常被装饰为`classmethod`。这样可以直接通过类命名空间调用它。例如：
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In other words, an instance of the `Factory` class is really not required for
    this pattern.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这种模式实际上不需要`Factory`类的实例。
- en: The Prototype pattern
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原型模式
- en: The Prototype design pattern allows a programmer to create an instance of a
    class as a template instance, and then create new instances by copying or cloning
    this Prototype.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 原型设计模式允许程序员创建一个类的实例作为模板实例，然后通过复制或克隆该原型来创建新实例。
- en: 'A Prototype is most useful in the following cases:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 原型在以下情况下最有用：
- en: When the classes instantiated in a system are dynamic, that is, they are specified
    as part of a configuration, or can otherwise change at runtime.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当系统中实例化的类是动态的，即作为配置的一部分指定，或者在运行时可以发生变化时。
- en: When the instances only have a few combinations of initial state. Rather than
    keeping track of the state and instantiating an instance each time, it is more
    convenient to create prototypes matching each state and clone them.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当实例只有少量初始状态的组合时。与跟踪状态并每次实例化一个实例相比，更方便的是创建与每个状态匹配的原型并进行克隆。
- en: A Prototype object usually supports copying itself via the `clone` method.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 原型对象通常支持通过`clone`方法复制自身。
- en: 'Here is a simple implementation of the Prototype in Python:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Python中原型的简单实现：
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `clone` method is implemented using the `copy` module, which copies the
    object deeply and returns a clone.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`clone`方法使用`copy`模块实现，该模块深度复制对象并返回克隆。'
- en: 'Let us see how this works. For that we need to create a meaningful subclass:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何工作的。为此，我们需要创建一个有意义的子类：
- en: '[PRE32]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Prototype – deep versus shallow copy
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原型-深复制与浅复制
- en: Now let us take a deeper look at the implementation details of our Prototype
    class.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更深入地了解我们的原型类的实现细节。
- en: You may notice that we use the `deepcopy` method of the `copy` module to implement
    our object cloning. This module also has a `copy` method, which implements shallow
    copying.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能注意到我们使用`copy`模块的`deepcopy`方法来实现对象克隆。该模块还有一个`copy`方法，用于实现浅复制。
- en: If we implement shallow copying, you will find that all objects are copied via
    a reference. This is fine for immutable objects such as strings or tuples, as
    they can't be changed.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们实现浅复制，您会发现所有对象都是通过引用复制的。对于不可变对象（如字符串或元组），这是可以接受的。
- en: However, for mutables like lists or dictionaries, this is a problem since the
    state of the instance is shared instead of being wholly owned by the instance,
    and any modification of a mutable in one instance will modify the same object
    in the cloned instances as well!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于像列表或字典这样的可变对象来说，这是一个问题，因为实例的状态是共享的，而不是完全由实例拥有的，对一个实例中可变对象的修改也会同时修改克隆实例中的相同对象！
- en: 'Let us see an example. We will use a modified implementation of our Prototype
    class, which uses shallow copying, to demonstrate this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。我们将使用我们的原型类的修改实现，该实现使用浅复制来演示这一点：
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `SRegister` class inherits from the new prototype class:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`SRegister`类继承自新的原型类：'
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let us add a name to the names register of instance `r1`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给`r1`实例的名称注册一个名称：
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now let''s checking `r2.names`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们检查`r2.names`：
- en: '[PRE36]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Oops! This is not what we wanted, but due to the shallow copy, both `r1` and
    `r2` end up sharing the same `names` list, as only the reference is copied over,
    not the entire object. This can be verified by a simple inspection:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！这不是我们想要的，但由于浅拷贝，`r1`和`r2`最终共享相同的`names`列表，因为只复制了引用，而不是整个对象。可以通过简单的检查来验证：
- en: '[PRE37]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: A deep copy, on the other hand, calls `copy` recursively for all objects contained
    in the cloned (copied) object, so nothing is shared, but each clone will end up
    having its own copy of all the referenced objects.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，深拷贝会对克隆的对象中包含的所有对象递归调用`copy`，因此没有任何共享，但每个克隆最终都会有自己的所有引用对象的副本。
- en: Prototype using metaclasses
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用元类构建原型
- en: We've seen how to build the Prototype pattern using classes. Since we've already
    seen a bit of meta-programming in Python in the Singleton pattern example, it
    helps to find if we can do the same in Prototype.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用类构建原型模式。由于我们已经在单例模式示例中看到了Python中的一些元编程，因此有助于找出我们是否可以在原型中做同样的事情。
- en: What we need to do is attach a `clone` method to all the Prototype classes.
    Dynamically attaching a method to a class like this can be done in its metaclass
    via the `__init__` method of the metaclass.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的是将`clone`方法附加到所有原型类上。像这样动态地将方法附加到类中可以通过元类的`__init__`方法来完成。
- en: 'This provides a simple implementation of Prototype using metaclasses:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了使用元类的原型的简单实现：
- en: '[PRE38]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `PrototypeM` class now implements a Prototype pattern. Let''s see an illustration
    by using a subclass:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`PrototypeM`类现在实现了原型模式。让我们通过使用一个子类来进行说明：'
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'First we will create an `ItemCollection` object:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们将创建一个`ItemCollection`对象：
- en: '[PRE40]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now we will clone it as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将克隆它如下：
- en: '[PRE41]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The clone is clearly a different object:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆显然是一个不同的对象：
- en: '[PRE42]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'And it has its own copy of the attributes:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 它有自己的属性副本：
- en: '[PRE43]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Combining patterns using metaclasses
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用元类组合模式
- en: 'It is possible to create interesting and customized patterns by using the power
    of metaclasses. The following example illustrates a type which is both a Singleton
    as well as a Prototype:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用元类的强大功能，可以创建有趣和定制的模式。以下示例说明了一种既是单例又是原型的类型：
- en: '[PRE44]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Any class using this metaclass as its type would show both Singleton and Prototype
    behavior.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个元类作为其类型的任何类都会显示单例和原型行为。
- en: 'This may look a bit strange having a single class combine what looks like conflicting
    behaviors into one, since a Singleton allows only one instance and a Prototype
    allows cloning to derive multiple instances, but if we think of patterns in terms
    of their APIs then it begins to feel a bit more natural:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来有点奇怪，因为一个单例只允许一个实例，而原型允许克隆来派生多个实例，但是如果我们从它们的API来考虑模式，那么它开始感觉更自然一些：
- en: Calling the class using the constructor would always return the same instance
    – it behaves like the Singleton pattern.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用构造函数调用类总是会返回相同的实例 - 它的行为就像单例模式。
- en: Calling `clone` on the class's instance would always return cloned instances.
    The instances are always cloned using the Singleton instance as the source – it
    behaves like the Prototype pattern.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类的实例上调用`clone`总是会返回克隆的实例。实例总是使用单例实例作为源进行克隆 - 它的行为就像原型模式。
- en: 'Here, we have modified our `PrototypeM` class to now use the new metaclass:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们修改了我们的`PrototypeM`类，现在使用新的元类：
- en: '[PRE45]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Since `ItemCollection` continues to subclass `PrototypeM`, it automatically
    gets the new behavior.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`ItemCollection`继续子类化`PrototypeM`，它会自动获得新的行为。
- en: 'Take a look at the following code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码：
- en: '[PRE46]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `clone` method works as expected, and produces a clone:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`clone`方法按预期工作，并产生一个克隆：'
- en: '[PRE47]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'However, building an instance via the constructor always returns the Singleton
    (Prototype) instance only as it invokes the Singleton API:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过构造函数构建实例总是只返回单例（原型）实例，因为它调用了单例API：
- en: '[PRE48]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Metaclasses allow powerful customization of class creation. In this specific
    example, we created a combination of behaviors which included both Singleton and
    Prototype patterns into one class via a metaclass. The power of Python using metaclasses
    allows the programmer to go beyond traditional patterns and come up with such
    creative techniques.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 元类允许对类的创建进行强大的定制。在这个具体的例子中，我们通过元类将单例和原型模式的行为组合到一个类中。Python使用元类的强大功能使程序员能够超越传统模式，提出这样的创造性技术。
- en: The Prototype factory
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原型工厂
- en: A prototype class can be enhanced with a helper **Prototype factory** or **registry
    class**, which can provide factory functions for creating prototypical instances
    of a configured family or group of products. Think of this as a variation of our
    previous Factory pattern.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 原型类可以通过一个辅助的**原型工厂**或**注册类**进行增强，它可以提供用于创建配置的产品系列或产品组的原型实例的工厂函数。将其视为我们以前工厂模式的变体。
- en: 'Here is the code for this class. See that we inherit it from `Borg` to share
    state automatically from the top of the hierarchy:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个类的代码。看到我们从`Borg`继承它以自动共享状态从层次结构的顶部：
- en: '[PRE49]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Let us create a few subclasses of Prototype, whose instances which we can register
    on the factory:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一些原型的子类，我们可以在工厂上注册它们的实例：
- en: '[PRE50]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We have two classes—one, a `Name` class another, an animal class, both of which
    inherit from `SPrototype`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个类 - 一个是`Name`类，另一个是动物类，两者都继承自`SPrototype`。
- en: 'First create a name and animal object each:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个名称和动物对象：
- en: '[PRE51]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now, let us create an instance of the Prototype Factory.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个原型工厂的实例。
- en: '[PRE52]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now let''s register the two instances on the factory:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在工厂上注册这两个实例：
- en: '[PRE53]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now the factory is ready to clone any number of them from the configured instances:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在工厂已经准备好从配置的实例中克隆任意数量的实例：
- en: '[PRE54]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The factory, rightfully, complains if we try to clone a class whose instance
    is not registered:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂如果尝试克隆未注册实例的类，会合理地抱怨：
- en: '[PRE55]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The factory class shown here could be enhanced with a check for the existence
    of the `clone` method on the registered class to make sure any class that is registered
    is obeying the API of the Prototype class. This is left as an exercise to the
    reader.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的工厂类可以通过检查已注册类上的`clone`方法的存在来增强，以确保任何注册的类都遵守原型类的API。这留给读者作为练习。
- en: 'It is instructive to discuss a few aspects of this specific example we have
    chosen if the reader hasn''t observed them already:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果读者还没有注意到，讨论我们选择的这个特定示例的一些方面是很有启发性的：
- en: The `PrototypeFactory` class is a Factory class, so it is usually a Singleton.
    In this case, we have made it a Borg, as we've seen that `Borgs` do a better job
    in state sharing across class hierarchies.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PrototypeFactory`类是一个工厂类，因此通常是一个单例。在这种情况下，我们将其制作成了一个Borg，因为我们已经看到`Borgs`在类层次结构之间的状态共享方面做得更好。'
- en: The `Name` class and `Animal` class inherit from `SPrototype`, since their attributes
    are integers and strings which are immutable, so, a shallow copy is fine here.
    This is unlike our first Prototype subclass.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Name`类和`Animal`类继承自`SPrototype`，因为它们的属性是不可变的整数和字符串，所以在这里浅复制就可以了。这与我们的第一个原型子类不同。'
- en: Prototypes preserve the class creation signature in the prototypical instance
    namely the `clone` method. This makes it easy for the programmer, as he/she does
    not to have to worry about the class creation signature – the order and type of
    parameters to `__new__,` and hence, the `__init__` methods - but only has to call
    `clone` on an existing instance.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型保留了原型实例中的类创建签名，即`clone`方法。这使得程序员很容易，因为他/她不必担心类创建签名——`__new__`的顺序和类型，因此也不必调用`__init__`方法——只需在现有实例上调用`clone`即可。
- en: The Builder pattern
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建造者模式
- en: A Builder pattern separates out construction of an object from its representation
    (assembly) so that the same construction process can be used to build different
    representations.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 建造者模式将对象的构建与其表示（组装）分离，以便可以使用相同的构建过程来构建不同的表示。
- en: In other words, using a Builder pattern, one can conveniently create different
    types or representative instances of the same class, each using a slightly different
    building or assembling process.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，使用建造者模式，可以方便地创建同一类的不同类型或代表性实例，每个实例使用略有不同的构建或组装过程。
- en: Formally, the Builder pattern uses a `Director` class, which directs the `Builder`
    object to build instances of the target class. Different types (classes) of builders
    help to build slightly different variations of the same class.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 形式上，建造者模式使用一个`Director`类，该类指导`Builder`对象构建目标类的实例。不同类型（类）的构建者有助于构建同一类的略有不同的变体。
- en: 'Let us look at an example:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子：
- en: '[PRE56]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Our example shows three classes, which are as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例显示了三个类，它们分别是：
- en: A `Room` and `Porch` class each representing a room and porch of a house—a room
    has windows and doors, and a porch has doors
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Room`和`Porch`类分别表示房子的房间和门廊——房间有窗户和门，门廊有门'
- en: A `LegoHouse` class representing a toy example for an actual house (We are imagining
    a kid building a house with lego blocks here, having rooms and porches.) —The
    Lego house will consist of any number of rooms and porches.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LegoHouse`类代表了一个玩具示例，用于实际房子（我们想象一个孩子用乐高积木建造房子，有房间和门廊。）——乐高房子将包括任意数量的房间和门廊。'
- en: 'Let us try and create a simple `LegoHouse` instance with one room and one porch,
    each with default configuration:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试创建一个简单的`LegoHouse`实例，其中有一个房间和一个门廊，每个都有默认配置：
- en: '[PRE57]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Are we done ? No! Notice that our `LegoHouse` is a class that doesn't fully
    construct itself in its constructor. The rooms and porches are not really built
    yet, only their counters are initialized.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了吗？没有！请注意，我们的`LegoHouse`是一个在其构造函数中并没有完全构建自身的类。房间和门廊实际上还没有建好，只是它们的计数器被初始化了。
- en: 'So we need to build out the rooms and porches separately, and add them to the
    house. Let us do that:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要分别建造房间和门廊，并将它们添加到房子中。让我们来做：
- en: '[PRE58]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Now you see that our house is fully built. Printing it displays not only the
    number of rooms and porches, but also details about them. All good!
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你看到我们的房子已经建好了。打印它不仅显示了房间和门廊的数量，还显示了有关它们的详细信息。一切顺利！
- en: Now, imagine that you need to build 100 such different house instances, each
    having different configurations of rooms and porches, and often, the rooms themselves
    having various numbers of windows and directions!
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下你需要建造100个这样不同配置的房子实例，每个实例的房间和门廊配置都不同，而且房间本身的窗户数量和方向也经常不同！
- en: (Maybe you are building a mobile game which uses Lego Houses where cute little
    characters like Trolls or Minions stay and do interesting things, whatever.)
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: （也许你正在制作一个移动游戏，其中使用乐高房子，可爱的小角色像巨魔或小黄人住在里面，并做有趣的事情，无论是什么。）
- en: It is pretty clear from the example that writing code like the last one will
    not scale to solve the problem.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 从示例中很明显，编写像最后一个示例那样的代码将无法解决问题。
- en: This is where the Builder pattern can help you. Let us start with a simple `LegoHouse`
    builder.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是建造者模式可以帮助你的地方。让我们从一个简单的`LegoHouse`构建者开始。
- en: '[PRE59]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Here are the main aspects of this class:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的主要方面如下：
- en: You configure the Builder class with the target class configuration—the number
    of rooms and porches in this case
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用目标类配置来配置构建者类——在这种情况下是房间和门廊的数量
- en: It provides a `build` method, which constructs and assembles (builds) the components
    of the house—in this case, `Rooms` and `Porches`, according to the specified configuration
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了一个`build`方法，根据指定的配置构建和组装（建造）房子的组件，即`Rooms`和`Porches`
- en: The `build` method returns the constructed and assembled house
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build`方法返回构建和组装好的房子'
- en: 'Now building different types of Lego Houses with different designs of rooms
    and porches is just two lines of code:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用两行代码构建不同类型的乐高房子，每种类型的房子都有不同的房间和门廊设计：
- en: '[PRE60]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We will now build a similar house, but with rooms having two windows each:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将建造一个类似的房子，但是房间里有两扇窗户：
- en: '[PRE61]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Let''s say you find you are continuing to build a lot of Lego Houses with this
    configuration. You can encapsulate it in a subclass of the Builder so that the
    preceding code itself is not duplicated a lot:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您发现自己继续使用这个配置构建了许多乐高房子。您可以将其封装在构建者的子类中，这样前面的代码就不会重复很多次：
- en: '[PRE62]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, the house configuration is *burned into* the new builder class, and building
    one is as simple as this:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，房屋配置被*固定*到新的构建者类中，构建一个就像这样简单：
- en: '[PRE63]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You can also build many of them (say `100`, `50` for the Trolls and `50` for
    the Minions) as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以构建许多这样的实例（比如`100`，`50`用于巨魔，`50`用于小黄人）：
- en: '[PRE64]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'One can also create more exotic builder classes which do some very specific
    things. For example, here is a builder class which creates houses with rooms and
    porches always facing in the north direction:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 人们还可以创建更奇特的构建者类，做一些非常特定的事情。例如，这里有一个构建者类，它创建的房屋的房间和门廊总是朝向北方：
- en: '[PRE65]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'And using Python''s multiple inheritance power, one can combine any such builders
    into new and interesting subclasses. Here, for example, is a builder that produces
    North-facing small houses:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 利用Python的多重继承功能，可以将任何这样的构建者组合成新的有趣的子类。例如，这里有一个构建者，它产生朝北的小房子：
- en: '[PRE66]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'As expected, it always produces North-facing, small houses with 2 windowed
    rooms repeatedly. Not very interesting maybe, but very reliable indeed:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，它总是重复产生朝北的小房子，有2个有窗的房间。也许不是很有趣，但确实非常可靠：
- en: '[PRE67]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Before we conclude our discussion on Creational Patterns, let us summarize
    some interesting aspects of these creational patterns and their interplay, which
    are as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束对创建模式的讨论之前，让我们总结一些有趣的方面，以及它们之间的相互作用，如下所示：
- en: '**Builder and Factory**: The Builder pattern separates out the assembling process
    of a class''s instance, from its creation. A Factory on the other hand is concerned
    with creating instances of different sub-classes belonging to same hierarchy using
    a unified interface. A builder also returns the built instance as a final step,
    whereas, a Factory returns the instance immediately, as there is no separate building
    step.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建者和工厂**：构建者模式将类的实例的组装过程与其创建分离。另一方面，工厂关注使用统一接口创建属于同一层次结构的不同子类的实例。构建者还将构建的实例作为最后一步返回，而工厂则立即返回实例，因为没有单独的构建步骤。'
- en: '**Builder and Prototype**: A Builder can, internally, use a prototype for creating
    its instances. Further instances from the same builder can then be cloned from
    this instance. For example, it is instructive to build a Builder class which uses
    one of our Prototype metaclasses to always clone a prototypical instance.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建者和原型**：构建者可以在内部使用原型来创建其实例。然后可以从该实例克隆同一构建者的更多实例。例如，建立一个使用我们的原型元类之一始终克隆原型实例的构建者类是很有启发性的。'
- en: '**Prototype and Factory**: A Prototype factory can, internally, make use of
    a Factory pattern to build the initial instances of the classes in question.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原型和工厂**：原型工厂可以在内部使用工厂模式来构建所讨论类的初始实例。'
- en: '**Factory and Singleton**: A Factory class is usually a Singleton in traditional
    programming languages. The other option is to make its methods a class or static
    method so there is no need to create an instance of the Factory itself. See that
    in our examples, we made it a Borg instead.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工厂和单例**：工厂类通常是传统编程语言中的单例。另一个选项是将其方法设置为类或静态方法，因此无需创建工厂本身的实例。在我们的示例中，我们将其设置为Borg。'
- en: We will now move on to the next class of patterns, namely, the Structural Patterns.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将转移到下一个模式类，即结构模式。
- en: Patterns in Python – Structural
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的模式-结构
- en: Structural patterns concern themselves with the intricacies of combining classes
    or objects to form larger structures, which are more than the sum of their parts.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 结构模式关注于组合类或对象以形成更大的结构的复杂性，这些结构不仅仅是它们各自部分的总和。
- en: 'Structural patterns implement this by these two distinct ways:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 结构模式通过这两种不同的方式来实现这一点：
- en: By using class Inheritance to compose classes into one. This is the static approach.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用类继承将类组合成一个。这是一种静态的方法。
- en: By using object composition at runtime to achieve combined functionality. This
    approach is more dynamic and flexible.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在运行时使用对象组合来实现组合功能。这种方法更加动态和灵活。
- en: Python, by virtue of supporting multiple inheritance, can implement both of
    these very well. Being a language with dynamic attributes and using the power
    of magic methods, Python can also do object composition and the resultant method
    wrapping pretty well also. So, with Python, a programmer is indeed at a good place
    with respect to implementing structural patterns.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 由于支持多重继承，Python可以很好地实现这两种功能。作为一种具有动态属性并使用魔术方法的语言，Python也可以很好地进行对象组合和由此产生的方法包装。因此，使用Python，程序员确实处于一个很好的位置，可以实现结构模式。
- en: 'We will be discussing the following structural patterns in this section: Adapter,
    Facade, and Proxy.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论以下结构模式：适配器，外观和代理。
- en: The Adapter pattern
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适配器模式
- en: As the name implies, the Adapter pattern wraps or adapts an existing implementation
    of a specific interface into another interface which a client expects. The Adapter
    is also called a **Wrapper**.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，适配器模式将特定接口的现有实现包装或适配到客户端期望的另一个接口中。适配器也被称为**包装器**。
- en: You very often adapt objects into interfaces or types you want when you program,
    most often without realizing this.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程时，您经常会将对象适配到您想要的接口或类型中，而往往并不自知。
- en: 'Example:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: 'Look at this list containing two instances of a fruit and its count:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个包含两个水果实例及其数量的列表：
- en: '[PRE68]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Let us say you want to quickly find the number of fruits, given a fruit name.
    The list doesn't allow you to use the fruit as a key, which is the interface more
    suited to the operation.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想快速找到水果的数量，给定水果名称。列表不允许您将水果用作键，这是更适合操作的接口。
- en: 'What do you do ? Well, you simply convert the list to a dictionary:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 你该怎么办？嗯，你只需将列表转换为字典：
- en: '[PRE69]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Voila! You got the object in a form that is more convenient for you, adapted
    to your programming needs. This is a kind of data or object adaption.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 看！你得到了一个更方便的对象形式，适应了你的编程需求。这是一种数据或对象适应。
- en: Programmers do such data or object adaptation almost continuously in their code
    without realizing it. Adaptation of code or data is more common than you think.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员在他们的代码中几乎不断地进行数据或对象适应，而并没有意识到。代码或数据的适应比你想象的更常见。
- en: 'Let us consider a class Polygon, representing a regular or irregular Polygon
    of any shape:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个多边形类，表示任何形状的正规或不规则多边形：
- en: '[PRE70]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This preceding class describes a generic, closed Polygon geometric figure in
    geometry.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类描述了几何学中的一个通用的封闭多边形图形。
- en: Note
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We have implemented some of the basic methods such as `perimeter` and `is_regular`,
    the latter returning whether the Polygon is a regular one such as a hexagon or
    pentagon.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了一些基本方法，如`perimeter`和`is_regular`，后者返回多边形是否是正规的，比如六边形或五边形。
- en: Let us say we want to implement specific classes for a few regular geometric
    shapes such as a triangle or rectangle. We can implement these from scratch, of
    course. However, since a Polygon class is available, we can try and reuse it,
    and adapt it to our needs.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要为一些常见的几何形状（如三角形或矩形）实现特定的类。当然，我们可以从头开始实现这些。但是，由于有一个多边形类可用，我们可以尝试重用它，并根据我们的需求进行适应。
- en: 'Let us say the `Triangle` class requires the following methods:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`Triangle`类需要以下方法：
- en: '`is_equilateral`: Returns whether the triangle is an equilateral one'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_equilateral`：返回三角形是否是等边三角形'
- en: '`is_isosceles`: Returns whether the triangle is an isosceles triangle'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_isosceles`：返回三角形是否是等腰三角形'
- en: '`is_valid`: Implements the `is_valid` method for a triangle'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_valid`：实现了三角形的`is_valid`方法'
- en: '`area`: Implements the area method for a triangle'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`area`：实现了三角形的面积方法'
- en: 'Similarly the `Rectangle` class, needs the following methods:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`Rectangle`类需要以下方法：
- en: '`is_square`: Returns whether the rectangle is a square'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_square`：返回矩形是否为正方形'
- en: '`is_valid`: Implements the `is_valid` method for a rectangle'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_valid`：实现了矩形的`is_valid`方法'
- en: '`area`: Implements the area method rectangle'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`area`：实现了矩形的面积方法'
- en: Following is the code for an adapter pattern, reusing the `Polygon` class for
    the `Triangle` and `Rectangle` classes.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是适配器模式的代码，重用`Polygon`类用于`Triangle`和`Rectangle`类。
- en: 'Here is the code for the `Triangle` class:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Triangle`类的代码：
- en: '[PRE71]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Take a look at the following `Rectangle` class:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下的`Rectangle`类：
- en: '[PRE72]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Now let's see the classes in action.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看这些类的实际应用。
- en: 'Let''s create an equilateral triangle for the first test:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为第一次测试创建一个等边三角形：
- en: '[PRE73]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'An equilateral triangle is also isosceles:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 等边三角形也是等腰三角形：
- en: '[PRE74]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Lets calculate the area:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们计算面积：
- en: '[PRE75]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Let''s try a triangle which is not valid:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个无效的三角形：
- en: '[PRE76]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Note
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The dimensions show it is a straight line, not a triangle. The `is_valid` method
    is not implemented in the base class, hence, the subclasses need to override it
    to provide a proper implementation. In this case, we raise an exception if the
    triangle is invalid.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 尺寸显示这是一条直线，而不是一个三角形。`is_valid`方法没有在基类中实现，因此子类需要重写它以提供适当的实现。在这种情况下，如果三角形无效，我们会引发一个异常。
- en: 'Here is an illustration of the `Rectangle` class in action:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Rectangle`类的示例：
- en: '[PRE77]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Let''s create a square:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个正方形：
- en: '[PRE78]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The `Rectangle`/`Triangle` classes shown here are examples of `class adapters`.
    This is because they inherit the class that they want to adapt, and provide the
    methods expected by the client, often delegating the computation to the base-class's
    methods. This is evident in the methods `is_equilateral` and `is_square` of the
    `Triangle` and `Rectangle` classes respectively.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的`Rectangle`/`Triangle`类是`类适配器`的示例。这是因为它们继承了它们想要适应的类，并提供了客户端期望的方法，通常将计算委托给基类的方法。这在`Triangle`和`Rectangle`类的`is_equilateral`和`is_square`方法中是明显的。
- en: 'Let us look at an alternative implementation of the same classes—this time,
    via object composition, in other words, `object adapters`:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下相同类的另一种实现方式——这次是通过对象组合，换句话说，`对象适配器`：
- en: '[PRE79]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This class works similar to the other one, even though the internal details
    are implemented via object composition than class inheritance:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类与另一个类类似，尽管内部细节是通过对象组合而不是类继承实现的：
- en: '[PRE80]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The main differences between this implementation and the class adapter are
    as follows:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现与类适配器的主要区别如下：
- en: The object adapter class doesn't inherit from the class we want to adapt from.
    Instead, it composes an instance of the class.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象适配器类不继承我们想要适应的类。相反，它组合了该类的一个实例。
- en: Any wrapper methods are forwarded to the composed instance. For example, the
    `perimeter` method.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何包装方法都会转发到组合实例。例如，`perimeter`方法。
- en: All attribute access of the wrapped instance has to be specified explicitly
    in this implementation. Nothing comes for free (since we are not inheriting the
    class. (For example, inspect the way we access the `sides` attribute of the enclosed
    `polygon` instance.).
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个实现中，封装实例的所有属性访问都必须明确指定。没有什么是免费的（因为我们没有继承该类）。 （例如，检查我们如何访问封闭的`polygon`实例的`sides`属性的方式。）。
- en: Note
  id: totrans-377
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Observe how we converted the previous `is_valid` method to a decorator in this
    implementation. This is because many methods carry out a first check on `is_valid`,
    and then perform their actions, so it is an ideal candidate for a decorator. This
    also aids rewriting of this implementation to a more convenient form, which is
    discussed next.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 观察我们如何将以前的`is_valid`方法转换为此实现中的装饰器。这是因为许多方法首先对`is_valid`进行检查，然后执行它们的操作，因此它是装饰器的理想候选者。这也有助于将此实现重写为更方便的形式，下面将讨论这一点。
- en: One problem with the object adapter implementation, as shown in the preceding
    implementation, is that any attribute reference to the enclosed adapted instance
    has to be made explicitly. For example, had we forgotten to implement the `perimeter`
    method for the `Triangle` class here, there wouldn't have been any method at all
    to call, as we aren't inheriting from the `Adapter` class.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 对象适配器实现的一个问题是，对封闭的适配实例的任何属性引用都必须显式进行。例如，如果我们在这里忘记为`Triangle`类实现`perimeter`方法，那么根本就没有方法可供调用，因为我们没有从`Adapter`类继承。
- en: The following is an alternate implementation, which makes use of the power of
    one of Python's magic methods, namely `__getattr__`, to simplify this. We are
    demonstrating this implementation on the `Rectangle` class`:`
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是另一种实现，它利用了Python的一个魔术方法`__getattr__`的功能，以简化这个过程。我们在`Rectangle`类上演示这个实现：
- en: '[PRE81]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Let us look at examples using this class:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用这个类的例子：
- en: '[PRE82]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: You can see that we are able to call the method `is_perimeter` on the `Rectangle`
    instance even though no such method is actually defined on the class. Similarly,
    `is_square` seems to work magically. What is happening here ?
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，我们能够在`Rectangle`实例上调用`is_perimeter`方法，即使在类上实际上并没有定义这样的方法。同样，`is_square`似乎也能奇迹般地工作。这里发生了什么？
- en: The magic method `__getattr__` is invoked by Python on an object if it cannot
    find an attribute in the usual ways – which is by first looking up the object's
    dictionary, then its class's dictionary and so on. It takes a name, and hence,
    provides a hook on a class, to implement a way to provide method lookups by routing
    them to other objects.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Python在通常的方式下找不到对象的属性，它会调用魔术方法`__getattr__`。它接受一个名称，因此为类提供了一个挂钩，以实现通过将方法查找路由到其他对象的方式。
- en: 'In this case, the `__getattr__` method does the following:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`__getattr__`方法执行以下操作：
- en: Check for the attribute name in the `method_mapper` dictionary. This is a dictionary
    we have created on the class, which maps a method name that we want to call on
    the class (as key) to the actual method name on the wrapped instance (as value).
    If an entry is found, it is returned.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`method_mapper`字典中检查属性名称。这是一个我们在类上创建的字典，将我们想要在类上调用的方法名称（作为键）映射到包装实例上的实际方法名称（作为值）。如果找到条目，则返回它。
- en: If no entry is found on the `method_mapper` dictionary, the entry is passed
    as such to the wrapped instance to be looked by the same name.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在`method_mapper`字典中找不到条目，则将条目原样传递给包装实例，以便按相同的名称查找。
- en: We use `getattr` in both cases to look up and return the attribute from the
    wrapped instance.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在两种情况下都使用`getattr`来查找并从包装实例返回属性。
- en: Attributes can be anything—data attributes or methods. For example, see how
    we refer to the `sides` attribute of the wrapped `polygon` instance as if it belonged
    to the `Rectangle` class in the method `area` and the `is_valid` decorator.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性可以是任何东西——数据属性或方法。例如，看看我们如何在方法`area`和`is_valid`装饰器中将包装的`polygon`实例的`sides`属性称为属于`Rectangle`类的属性。
- en: 'If an attribute is not present on the wrapped instance, it raises an `AttributeError`:'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在包装实例上不存在属性，则会引发`AttributeError`：
- en: '[PRE83]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Object adapters implemented using this technique are much more versatile, and
    lead to less amount of code than regular object adapters where every method has
    to be explicitly written and forwarded to the wrapped instance.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术实现的对象适配器更加灵活，比常规对象适配器需要编写每个方法并将其转发到包装实例的代码量要少。
- en: The Facade pattern
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外观模式
- en: A facade is a structural pattern that provides a unified interface to multiple
    interfaces in a subsystem. The Facade pattern is useful where a system consists
    of multiple subsystems, each with its own interfaces, but presents some high-level
    functionality, which needs to be captured, as a general top-level interface to
    the client.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 外观是一种结构模式，为子系统中的多个接口提供统一接口。外观模式在系统由多个子系统组成，每个子系统都有自己的接口，但需要捕获一些高级功能作为通用顶层接口提供给客户端时非常有用。
- en: A classic example of an object of everyday life which is a Facade is an automobile.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 一个日常生活中的经典例子是汽车，它是一个外观。
- en: For example, a car consists of an engine, power train, axle and wheel assembly,
    electronics, steering systems, brake systems, and other such components.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，汽车由发动机、动力传动系统、轴和车轮组件、电子设备、转向系统、制动系统和其他组件组成。
- en: However, usually, you don't have to bother whether the brake in your car is
    a disc-brake, or whether its suspension is coil-spring or McPherson struts, do
    you?
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常情况下，你并不需要担心你的汽车刹车是盘式刹车，还是悬架是螺旋弹簧或麦弗逊减震器，对吧？
- en: 'This is because the car manufacturer has provided a Facade for you to operate
    and maintain the car which reduces the complexity and provides you with simpler
    sub-systems which are easy to operate by themselves- such as follows:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为汽车制造商为您提供了一个外观，以操作和维护汽车，从而减少了复杂性，并为您提供了更简单的子系统，这些子系统本身很容易操作，例如：
- en: The ignition system to start the car
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动汽车的点火系统
- en: The steering system to maneuver it
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于操纵它的转向系统
- en: The clutch-accelerator-brake system to control it
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制它的离合器-油门-刹车系统
- en: The gear and transmission system to manage the power and speed
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理动力和速度的齿轮和传动系统
- en: A lot of complex systems around us are Facades. Like the car example, a computer
    is a Facade, an Industrial Robot is another. All factory control systems are facades,
    giving a few dashboards and controls for the engineer to tweak the complex systems
    behind it, and keep them running.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们周围有很多复杂的系统都是外观。就像汽车的例子一样，计算机是一个外观，工业机器人是另一个。所有工厂控制系统都是外观，为工程师提供了一些仪表板和控件，以调整其背后的复杂系统，并使其保持运行。
- en: Facades in Python
  id: totrans-405
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python中的外观
- en: The Python standard library contains a lot of modules which are good examples
    of Facades. The `compiler` module, which provides hooks to parse and compile the
    Python source code, is a Facade to the lexer, parser, ast tree generator, and
    the like.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库包含许多模块，它们是外观的很好的例子。`compiler`模块提供了解析和编译Python源代码的钩子，是词法分析器、解析器、ast树生成器等的外观。
- en: 'The following is an image of the help contents of this module:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此模块的帮助内容的图像。
- en: '![Facades in Python](../Images/image00486.jpeg)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![Python中的外观](../Images/image00486.jpeg)'
- en: 'In the next page of the help contents, you can see how this module is a facade
    to other modules which are used to implement the functions defined in this package.
    (Look at "Package contents" at the bottom of the image):'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在帮助内容的下一页中，您可以看到这个模块是其他模块的外观，这些模块用于实现此包中定义的函数。（查看图像底部的“包内容”）：
- en: '![Facades in Python](../Images/image00487.jpeg)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![Python中的外观](../Images/image00487.jpeg)'
- en: Let us look at a sample code for a Facade pattern. In this example, we will
    model a Car with a few of its multiple subsystems.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个外观模式的示例代码。在这个例子中，我们将模拟一辆汽车及其多个子系统中的一些。
- en: 'Here is the code for all the subsystems:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这是所有子系统的代码：
- en: '[PRE84]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: As you can see, we have covered a good amount of the subsystems in a car, at
    least those which are essential.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们已经涵盖了汽车中的大部分子系统，至少是那些必不可少的。
- en: 'Here is the code for the `Car` class, which combines them as a Facade with
    two methods, namely, to `start` and `stop` the car:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Car`类的代码，它将它们组合为一个外观，有两个方法，即`start`和`stop`汽车：
- en: '[PRE85]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Let''s build an instance of the `Car` first:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先建立一个`Car`的实例：
- en: '[PRE86]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Let''s now take the car out of the garage and go for a spin:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们把车开出车库去兜风：
- en: '[PRE87]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Car started.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 汽车已启动。
- en: Now that we have driven it for a while, we can stop the car. As you may have
    guessed, stopping is more involved than starting!
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经开了一段时间，我们可以停车了。正如你可能已经猜到的那样，停车比起开车更复杂！
- en: '[PRE88]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Facades are useful for taking the complexity out of systems so that working
    with them becomes easier. As the preceding example shows, it would've been awfully
    difficult if we hadn't built the `start` and `stop` methods the way we have done
    in this example. These methods hide the complexity behind the actions involved
    with the subsystems in starting and stopping a `Car`.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 外观对于简化系统的复杂性以便更容易地使用它们是很有用的。正如前面的例子所示，如果我们没有像在这个例子中那样构建`start`和`stop`方法，那么它将会非常困难。这些方法隐藏了启动和停止`Car`中涉及的子系统的复杂性。
- en: This is what a Facade does best.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是外观最擅长的。
- en: The Proxy pattern
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理模式
- en: 'A Proxy pattern wraps another object to control access to it. Some usage scenarios
    are as follows:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 代理模式包装另一个对象以控制对其的访问。一些使用场景如下：
- en: We need a virtual resource closer to the client, which acts in place of the
    real resource in another network, for example, a remote proxy
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个更接近客户端的虚拟资源，它在另一个网络中代替真实资源，例如，远程代理
- en: When we need to control/monitor access to a resource, for example, a network
    proxy and an instance counting proxy
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们需要控制/监视对资源的访问时，例如，网络代理和实例计数代理
- en: We need to protect a resource or object (protection proxy) because direct access
    to it would cause security issues or compromise it, for example, a reverse proxy
    server
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要保护一个资源或对象（保护代理），因为直接访问它会导致安全问题或损害它，例如，反向代理服务器
- en: We need to optimize access to results from a costly computation or network operation
    so that the computation is not performed every time, for example, a caching proxy
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要优化对昂贵计算或网络操作的结果的访问，以便不必每次都执行计算，例如，一个缓存代理
- en: A Proxy always implements the interface of the object it is proxying to – its
    target in other words. This can be either via inheritance or via composition.
    In Python, the latter can be done more powerfully by overriding the `__getattr__`
    method, as we've seen in Adapter example.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 代理始终实现被代理对象的接口 - 换句话说，它的目标。这可以通过继承或组合来实现。在Python中，后者可以通过重写`__getattr__`方法更强大地实现，就像我们在适配器示例中看到的那样。
- en: An instance-counting proxy
  id: totrans-433
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实例计数代理
- en: 'We will start with an example that demonstrates usage of the Proxy pattern
    for keeping track of instances of a class. We will reuse our `Employee` class
    and its subclasses from the Factory pattern here:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个示例开始，演示代理模式用于跟踪类的实例的用法。我们将在这里重用我们的`Employee`类及其子类，这些子类来自工厂模式：
- en: '[PRE89]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Note
  id: totrans-436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We haven't duplicated the code for the employee subclasses, as these are already
    available in the Factory pattern discussion.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有复制员工子类的代码，因为这些已经在工厂模式讨论中可用。
- en: We have two classes here, namely, the `EmployeeProxy` and the original `factory`
    class modified to return instances of `EmployeeProxy` instead of Employee. The
    modified factory class makes it easy for us to create Proxy instances instead
    of having to do it ourselves.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个类，即`EmployeeProxy`和修改后的原始`factory`类，用于返回`EmployeeProxy`的实例而不是Employee的实例。修改后的工厂类使我们能够轻松创建代理实例，而不必自己去做。
- en: The proxy, as implemented here, is a composition or object proxy, as it wraps
    around the target object (employee) and overloads `__getattr__` to redirect attribute
    access to it. It keeps track of the count of instances by overriding the `__new__`
    and `__del__` methods for instance creation and instance deletion respectively.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里实现的代理是一个组合或对象代理，因为它包装目标对象（员工）并重载`__getattr__`以将属性访问重定向到它。它通过重写`__new__`和`__del__`方法来跟踪实例的数量，分别用于实例创建和实例删除。
- en: 'Let''s see an example of using the Proxy:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用代理的例子：
- en: '[PRE90]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Note
  id: totrans-442
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This prints details of the engineer via proxy, since we have overridden the
    `__str__` method in the proxy class, which calls the same method of the employee
    instance.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过代理打印了工程师的详细信息，因为我们在代理类中重写了`__str__`方法，该方法调用了员工实例的相同方法。
- en: '[PRE91]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Let''s check the instance count now. This can be done either via the instances
    or via the class, since it is anyway referencing a class variable:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们检查实例计数。这可以通过实例或类来完成，因为它无论如何都引用一个类变量：
- en: '[PRE92]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Let's delete the instances, and see what happens!
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们删除这些实例，看看会发生什么！
- en: '[PRE93]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Note
  id: totrans-449
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The weak reference module in Python provides a proxy object which performs something
    very similar to what we have implemented, by proxying access to class instances.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的弱引用模块提供了一个代理对象，它执行了与我们实现的非常相似的操作，通过代理访问类实例。
- en: 'Here is an example:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE94]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Let us check the reference count of the new object:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下新对象的引用计数：
- en: '[PRE95]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Now create a weak reference to it:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个对它的弱引用：
- en: '[PRE96]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The `weakref` object acts in all respects like the object its proxying for:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`weakref`对象在所有方面都像它的代理对象一样：'
- en: '[PRE97]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'However, note that a `weakref` proxy doesn''t increase the reference count
    of the proxied object:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请注意，`weakref`代理不会增加被代理对象的引用计数：
- en: '[PRE98]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Patterns in Python – Behavioral
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的模式-行为
- en: Behavioral patterns are the last stage in the complexity and functionality of
    patterns. They also come last chronologically in object life cycle in a system
    since objects are first created, then built into larger structures, before they
    interact with each other.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 行为模式是模式的复杂性和功能的最后阶段。它们也是系统中对象生命周期中的最后阶段，因为对象首先被创建，然后构建成更大的结构，然后彼此交互。
- en: These patterns encapsulate models of communication and interaction between objects.
    These patterns allow us to describe complex workflows that may be difficult to
    follow at runtime.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式封装了对象之间的通信和交互模型。这些模式允许我们描述可能在运行时难以跟踪的复杂工作流程。
- en: Typically, Behavioral patterns favor object composition over inheritance as
    usually, the interacting objects in a system would be from separate class hierarchies.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，行为模式更青睐对象组合而不是继承，因为系统中交互的对象通常来自不同的类层次结构。
- en: 'In this brief discussion, we will look at the following patterns: **Iterator**,
    **Observer**, and **State**.'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的讨论中，我们将看一下以下模式：**迭代器**，**观察者**和**状态**。
- en: The Iterator pattern
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器模式
- en: An iterator provides a way to access elements of a container object sequentially
    without exposing the underlying object itself. In other words, an iterator is
    a proxy that provides a single method of iterating over a container object.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器提供了一种顺序访问容器对象元素的方法，而不暴露底层对象本身。换句话说，迭代器是一个代理，提供了一个遍历容器对象的方法。
- en: Iterators are everywhere in Python, so there is no special need to introduce
    them.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，迭代器随处可见，因此没有特别需要引入它们。
- en: All container/sequence types in Python, that is, list, tuple, str, and set implement
    their own iterators. Dictionaries also implement iterators over their keys.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的所有容器/序列类型，即列表、元组、字符串和集合都实现了自己的迭代器。字典也实现了对其键的迭代器。
- en: In Python, an iterator is any object that implements the magic method `__iter__`,
    and also responds to the function iter returning the iterator instance.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，迭代器是实现魔术方法`__iter__`的任何对象，并且还响应于返回迭代器实例的函数iter。
- en: Usually, the iterator object that is created is hidden behind the scenes in
    Python.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在Python中，创建的迭代器对象是隐藏在幕后的。
- en: 'For example, we iterate through a list like this:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以这样遍历列表：
- en: '[PRE99]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Internally, something very similar to the following happens:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，类似于以下的事情发生：
- en: '[PRE100]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Every sequence type implements its own iterator type as well in Python. Examples
    for this are given as follows:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 每种序列类型在Python中都实现了自己的迭代器类型。以下是一些示例：
- en: '**Lists**:'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表**：'
- en: '[PRE101]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '**Tuples**:'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元组**：'
- en: '[PRE102]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '**Sets**:'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集合**：'
- en: '[PRE103]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Even dictionaries come with their own special key iterator type in Python3:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在Python3中，字典也有自己的特殊键迭代器类型：
- en: '[PRE104]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'We will see a small example of implementing your own iterator class/type in
    Python now:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看到一个在Python中实现自己的迭代器类/类型的小例子：
- en: '[PRE105]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'This preceding class is a prime number iterator, which returns prime numbers
    between two limits:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 上述的类是一个素数迭代器，它返回两个限制之间的素数：
- en: '[PRE106]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The Prime number iterator without the end limit is an infinite iterator. For
    example, the following iterator will return all prime numbers starting from `2`
    and will never stop:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 没有结束限制的素数迭代器是一个无限迭代器。例如，以下迭代器将返回从`2`开始的所有素数，并且永远不会停止：
- en: '[PRE107]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: However by combining it with the itertools module, one can extract specific
    data that one wants from such infinite iterators.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过与itertools模块结合，可以从这样的无限迭代器中提取所需的特定数据。
- en: 'For example here, we use it with the `islice` method of `itertools` to compute
    the first 100 prime numbers:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在这里，我们使用`itertools`的`islice`方法计算前100个素数：
- en: '[PRE108]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Similarly, here are the first 10 prime numbers ending with 1 in the unit''s
    place using the `filterfalse` method:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，这里是以1结尾的前10个素数，使用`filterfalse`方法：
- en: '[PRE109]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'In a similar way, here are the first 10 palindromic primes:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，这里是前10个回文素数：
- en: '[PRE110]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The interested reader is referred to the documentation on the `itertools` module
    and its methods to find out fun and interesting ways to use and manipulate the
    data of such infinite generators.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 感兴趣的读者可以参考`itertools`模块及其方法的文档，找出使用和操作这样的无限生成器数据的有趣方法。
- en: The Observer pattern
  id: totrans-499
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察者模式
- en: The Observer pattern decouples objects, but at the same time, allows one set
    of objects (Subscribers) to keep track of the changes in another object (the Publisher).
    This avoids one-to-many dependency and references while keeping their interaction
    alive.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式解耦了对象，但同时允许一组对象（订阅者）跟踪另一个对象（发布者）的变化。这避免了一对多的依赖和引用，同时保持它们的交互活跃。
- en: This pattern is also called as **Publish-Subscribe**.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式也被称为**发布-订阅**。
- en: Here is a rather simple example using an `Alarm` class, which runs in its own
    thread and generates periodic alarms every second (by default). It also works
    as a `Publisher` class, notifying its subscribers whenever the alarm happens.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单的例子，使用了一个`Alarm`类，它在自己的线程中运行，并每秒（默认）生成周期性的警报。它还作为一个`Publisher`类工作，通知其订阅者每当警报发生时。
- en: '[PRE111]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Our subscriber is a simple `DumbClock` class, which subscribes to the `Alarm`
    object for its notifications, and using that, updates its time:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的订阅者是一个简单的`DumbClock`类，它订阅`Alarm`对象以获取通知，并使用它来更新时间：
- en: '[PRE112]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Let''s get these objects ticking:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们让这些对象开始运行：
- en: 'First create the alarm with a notification period of one second. This allows:'
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个通知周期为一秒的闹钟。这允许：
- en: '[PRE113]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Next create the `DumbClock` object:'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来创建`DumbClock`对象：
- en: '[PRE114]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Finally, register the clock object on the alarm object as an observer so that
    it can receive the notifications:'
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将时钟对象注册为观察者，以便它可以接收通知：
- en: '[PRE115]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Now the clock will keep receiving updates from the alarm. Every time you print
    the clock, it will show the current time correct to a second:'
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在时钟将不断接收来自闹钟的更新。每次打印时钟时，它将显示当前时间，精确到秒：
- en: '[PRE116]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'After a while it will show you the following:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 过一段时间它会显示如下内容：
- en: '[PRE117]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Sleep for a while and print.
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 睡一会儿然后打印。
- en: '[PRE118]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Here are some aspects to keep in mind when implementing observers:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现观察者时要记住的一些方面：
- en: '**References to subscribers**: Publishers can choose to keep a reference to
    subscribers or use a Mediator pattern to get a reference when required. A Mediator
    pattern decouples many objects in a system from strongly referencing each other.
    In Python, for example, this could be a collection of weak references or proxies
    or an object managing such a collection if both publisher and subscriber objects
    are in the same Python runtime. For remote references, one can use a remote proxy.'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订阅者的引用**：发布者可以选择保留对订阅者的引用，也可以使用中介者模式在需要时获取引用。中介者模式将系统中的许多对象从强烈相互引用中解耦。例如，在Python中，这可以是弱引用或代理的集合，或者如果发布者和订阅者对象都在同一个Python运行时中，则可以是管理这样一个集合的对象。对于远程引用，可以使用远程代理。'
- en: '**Implementing Callbacks**: In this example, the `Alarm` class directly updates
    the state of the subscriber by calling its `update` method. An alternate implementation
    is for the publisher to simply notify the subscribers, at which point they query
    the state of the Publisher using a `get_state` type of method to implement their
    own state change:'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现回调**：在这个例子中，`Alarm`类直接通过调用其`update`方法来更新订阅者的状态。另一种实现方式是发布者简单地通知订阅者，然后订阅者使用`get_state`类型的方法查询发布者的状态来实现自己的状态改变。'
- en: This is the preferred option for a Publisher which may be interacting with subscribers
    of different types/classes. This also allows for decoupling of code from Publisher
    to Subscriber as the publisher doesn't have to change its code if the `update`
    or `notify` method of the Subscriber changes.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 这是与不同类型/类的订阅者交互的首选选项。这也允许从发布者到订阅者的代码解耦，因为如果订阅者的`update`或`notify`方法发生变化，发布者就不必更改其代码。
- en: '**Synchronous versus Asynchronous**: In this example, the notify is called
    in the same thread as the Publisher when the state is changed since the clock
    needs reliable and immediate notifications to be accurate. In an asynchronous
    implementation, this could be done asynchronously so that the main thread of the
    Publisher continues running. For example this may be the preferred approach in
    systems using asynchronous execution which returns a future object upon notification,
    but the actual notification may occur sometime later.'
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步与异步**：在这个例子中，当状态改变时，通知在与发布者相同的线程中调用，因为时钟需要可靠和即时的通知才能准确。在异步实现中，这可以异步完成，以便发布者的主线程继续运行。例如，在使用异步执行返回一个future对象的系统中，这可能是首选的方法，但实际通知可能在稍后发生。'
- en: Since we've already encountered asynchronous processing in [Chapter 5](part0040.xhtml#aid-164MG1
    "Chapter 5. Writing Applications That Scale"), on scalability, we will conclude
    our discussion on the Observer pattern with one more example, showing an asynchronous
    example where the Publisher and Subscriber interact asynchronously. We will be
    using the asyncio module in Python for this.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在[第5章](part0040.xhtml#aid-164MG1 "第5章。编写可扩展的应用程序")中遇到了异步处理，关于可扩展性，我们将用一个更多的例子来结束我们对观察者模式的讨论，展示一个异步的例子，展示发布者和订阅者异步交互。我们将在Python中使用asyncio模块。
- en: For this example, we will be using the domain of news publishing. Our publisher
    gets news stories from various sources as news URLs which are tagged to certain
    specific news channels. Examples of such channels could be - "sports", "international",
    "technology", "India", and so on.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用新闻发布的领域。我们的发布者从各种来源获取新闻故事作为新闻URL，这些URL被标记为特定的新闻频道。这些频道的示例可能是 - "体育"，"国际"，"技术"，"印度"等等。
- en: The news subscribers register for news channels of their interest, consuming
    news stories as URLs. Once they get a URL they fetch the data of the URL asynchronously.
    The publisher to subscriber notification too happens asynchronously.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 新闻订阅者注册他们感兴趣的新闻频道，以URL形式获取新闻故事。一旦他们获得URL，他们会异步获取URL的数据。发布者到订阅者的通知也是异步进行的。
- en: 'Here is the source code of our publisher:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们发布者的源代码：
- en: '[PRE119]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: The publisher's `notify` method is asynchronous. It goes through list of channels,
    finds out the subscribers to each of them, and calls back the subscriber using
    its `callback` method, supplying it with the most recent data from the channel.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 发布者的`notify`方法是异步的。它遍历通道列表，找出每个通道的订阅者，并使用其`callback`方法回调订阅者，提供来自通道的最新数据。
- en: The `callback` method itself being asynchronous, it returns a future and not
    any final processed result. Further processing of this future occurs asynchronously
    inside the `fetch_urls` method of the subscriber.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '`callback`方法本身是异步的，它返回一个future而不是任何最终处理的结果。这个future的进一步处理在订阅者的`fetch_urls`方法中异步进行。'
- en: 'Here is the source code of the subscriber:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们订阅者的源代码：
- en: '[PRE120]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Notice how both the `callback` and `fetch_urls` methods are both declared as
    asynchronous. The `callback` method passes the URL from the publisher to the `aiohttp`
    module's `GET` method which simply returns a future.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`callback`和`fetch_urls`方法都声明为异步。`callback`方法将URL从发布者传递给`aiohttp`模块的`GET`方法，该方法简单地返回一个future。
- en: The future is appended a local list of futures, which is processed again asynchronously
    – by the `fetch_urls` method to get the URL data which is then appended to the
    local stories dictionary with the URL as the key.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 未来将被添加到本地的未来列表中，再次异步处理 - 通过`fetch_urls`方法获取URL数据，然后将其附加到本地的故事字典中，URL作为键。
- en: Here is the asynchronous loop part of the code.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码的异步循环部分。
- en: 'Take a look at the following steps:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下步骤：
- en: 'To get things started we create a publisher and add some news stories via specific
    URLs to couple of channels on the publisher:'
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了开始，我们创建一个发布者，并通过特定的URL添加一些新闻故事到发布者的几个频道上：
- en: '[PRE121]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'We then create two subscribers, one listening to the `sports` channel and the
    other to the `india` channel:'
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建两个订阅者，一个监听`sports`频道，另一个监听`india`频道：
- en: '[PRE122]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Now we create the asynchronous event loop:'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们创建异步事件循环：
- en: '[PRE123]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Next, we add the tasks as co-routines to the loop to get the asynchronous loop
    to start its processing. We need to add the following three tasks:'
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将任务作为协程添加到循环中，以使异步循环开始处理。我们需要添加以下三个任务：
- en: '`publisher.notify()`:'
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`publisher.notify()`:'
- en: '`subscriber.fetch_urls()`: one for each of the two subscribers'
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscriber.fetch_urls()`: 每个订阅者一个'
- en: 'Since both the publisher and subscriber processing loops never exit we add
    a timeout the processing via its `wait` method:'
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于发布者和订阅者处理循环都不会退出，我们通过其`wait`方法添加了一个超时来处理：
- en: '[PRE124]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Here is our asynchronous Publisher and Subscriber(s) in action, on the console.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们异步的发布者和订阅者在控制台上的操作。
- en: '![The Observer pattern](../Images/image00488.jpeg)'
  id: totrans-549
  prefs: []
  type: TYPE_IMG
  zh: '![观察者模式](../Images/image00488.jpeg)'
- en: We now move on to the last pattern in our discussion of design patterns, namely
    the State pattern.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们继续讨论设计模式中的最后一个模式，即状态模式。
- en: The State pattern
  id: totrans-551
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态模式
- en: A State pattern encapsulates the internal state of an object in another class
    (**state object**). The object changes its state by switching the internally encapsulated
    state object to different values.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 状态模式将对象的内部状态封装在另一个类（**状态对象**）中。对象通过将内部封装的状态对象切换到不同的值来改变其状态。
- en: A State object and its related cousin, **Finite State Machine** (**FSM**), allows
    a programmer to implement state transitions seamlessly across different states
    for the object without requiring complex code.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 状态对象及其相关的表亲，**有限状态机**（**FSM**），允许程序员在不需要复杂代码的情况下实现对象在不同状态之间的状态转换。
- en: In Python, the State pattern can be implemented easily, since Python has a magic
    attribute for an object's class, namely, the `__class__` attribute.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，状态模式可以很容易地实现，因为Python为对象的类有一个魔术属性，即`__class__`属性。
- en: It may sound a bit strange, but in Python this attribute can be modified on
    the dictionary of the instance! This allows the instance to dynamically change
    its class, something which we can take advantage of to implement this pattern
    in Python.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来有点奇怪，但在Python中，这个属性可以在实例的字典上进行修改！这允许实例动态地改变其类，这是我们可以利用来在Python中实现这种模式的东西。
- en: 'Here is a simple example showing this:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子：
- en: '[PRE125]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: We were able to change the class of the object `c` at runtime. Now, in this
    example, this proved dangerous, since `C` and `D` are unrelated classes, so this
    is never a smart thing to do in such cases. This is evident in the way c forgot
    its method `f` when it changed to an instance of class `D` (`D` has no method
    `f`).
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够在运行时更改对象`c`的类。现在，在这个例子中，这证明是危险的，因为`C`和`D`是不相关的类，所以在这种情况下做这样的事情从来不是明智的。这在c在切换到`D`类的实例时忘记了它的方法`f`的方式中是显而易见的（`D`没有`f`方法）。
- en: However, for related classes, and more specifically, subclasses of a parent
    class implementing the same interface, this gives a lot of power, and can be used
    to implement patterns like State.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于相关的类，更具体地说，实现相同接口的父类的子类，这给了很大的权力，并且可以用来实现诸如状态之类的模式。
- en: In the following example, we have used this technique to implement the State
    pattern. It shows a computer which can switch from one state to another.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们使用了这种技术来实现状态模式。它展示了一个可以从一个状态切换到另一个状态的计算机。
- en: 'Notice how we are using an iterator to define this class since an iterator
    defines movement to the next position naturally by way of its nature. We are taking
    advantage of this fact to implement our state pattern:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在定义这个类时使用了迭代器，因为迭代器通过其本质自然地定义了移动到下一个位置。我们利用了这一事实来实现我们的状态模式：
- en: '[PRE126]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Now let us define some concrete subclasses of the `ComputerState` class.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义`ComputerState`类的一些具体子类。
- en: Each class can define a list of `next_states` which is a set of legal states
    the current state can switch to. It can also define a list of random states which
    are random legal states it can switch to once it has switched to the next state.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类都可以定义一个`next_states`列表，其中包含当前状态可以切换到的合法状态集。它还可以定义一个随机状态列表，这些是它可以切换到的随机合法状态，一旦它切换到下一个状态。
- en: For example, here is the first state namely that of the `off` state of the computer.
    The next compulsory state is of course the `on` state. Once the computer is on,
    this state can move off to any of the other random states.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里是第一个状态，即计算机的`off`状态。下一个强制状态当然是`on`状态。一旦计算机开启，这个状态可以转移到任何其他随机状态。
- en: 'Hence the definition is as follows:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，定义如下：
- en: '[PRE127]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Similarly, here are the definitions of the other state classes:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这里是其他状态类的定义：
- en: '[PRE128]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Finally, here is the class for the Computer which uses the state classes to
    set its internal state.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是使用状态类设置其内部状态的计算机类。
- en: '[PRE129]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Here are some interesting aspects of this implementation:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现的一些有趣方面：
- en: '**State as an iterator**: We have implemented the `ComputerState` class as
    an iterator. This is because a state has, naturally, a list of immediate future
    states it can switch to and nothing else. For example, a computer in an `Off`
    state can move only to the `On` state next. Defining it as an iterator allows
    us to take advantage of the natural progression of an iterator from one state
    to next.'
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态作为迭代器**：我们将`ComputerState`类实现为迭代器。这是因为状态自然地具有可以切换到的即时未来状态列表，没有其他内容。例如，处于“关闭”状态的计算机只能转移到下一个“打开”状态。将其定义为迭代器使我们能够利用迭代器从一个状态自然地进展到下一个状态。'
- en: '**Random States**: We have implemented the concept of random states in this
    example. Once a computer moves from one state to its mandatory next state (On
    to Off, Suspend to WakeUp), it has a list of random states available to move on
    to. A computer that is On need not always be switched off. It can also go to Sleep
    (Suspend) or Hibernate.'
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**随机状态**：我们在这个例子中实现了随机状态的概念。一旦计算机从一个状态移动到其强制的下一个状态（从打开到关闭，从暂停到唤醒），它有一个可以移动到的随机状态列表。处于打开状态的计算机不一定总是要关闭。它也可以进入睡眠（暂停）或休眠。'
- en: '**Manual Change**: The computer can move to a specific state via the second
    optional argument of the `change` method. However, this is possible only if the
    state change is valid, otherwise an exception is raised.'
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**手动更改**：计算机可以通过`change`方法的第二个可选参数移动到特定状态。但是，只有在状态更改有效时才可能，否则会引发异常。'
- en: We will now see our State pattern in action.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看到我们的状态模式在实际中的应用。
- en: 'The computer starts being off, of course:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机开始关闭，当然：
- en: '[PRE130]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Let us see some automatic state changes:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些自动状态更改：
- en: '[PRE131]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'And now, let the state machine decide its next states—note these are random
    states till the computer enters a state where it has to mandatorily move on to
    the next state:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让状态机决定它的下一个状态——注意这些是随机状态，直到计算机进入必须移动到下一个状态的状态为止：
- en: '[PRE132]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Now the state is Hibernate, which means the next state has to be On as it is
    a compulsory next state:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 现在状态是休眠，这意味着下一个状态必须是打开，因为这是一个强制的下一个状态：
- en: '[PRE133]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Now the state is Off, which means the next state has to be On:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 现在状态是关闭，这意味着下一个状态必须是打开：
- en: '[PRE134]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'The following are all random state changes:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是所有随机状态更改：
- en: '[PRE135]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Now, since the underlying state is an iterator, one can even iterate on the
    state using a module like itertools.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于底层状态是一个迭代器，因此可以使用itertools等模块对状态进行迭代。
- en: 'Here is an example of this – iterating on the next five states of the computer:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子——迭代计算机的下一个五个状态：
- en: '[PRE136]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Now let us try some manual state changes:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试一些手动状态更改：
- en: '[PRE137]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: We get an exception when we try an invalid state transition, as the computer
    cannot go directly from Suspend to Hibernate. It has to wake up first!
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试无效的状态转换时，我们会得到一个异常，因为计算机不能直接从暂停转换到休眠。它必须先唤醒！
- en: '[PRE138]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: All good now.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都很好。
- en: We are at an end of our discussion on design patterns in Python, so it is time
    to summarize what we learned so far.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了Python中设计模式的讨论到此结束，现在是总结我们迄今为止学到的东西的时候了。
- en: Summary
  id: totrans-598
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took a detailed tour of object-oriented design patterns,
    and found out new and different ways of implementing them in Python. We started
    with an overview of Design Patterns and their classification into Creational,
    Structural, and Behavioral patterns.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细介绍了面向对象设计模式，并发现了在Python中实现它们的新方法和不同方法。我们从设计模式及其分类（创建型、结构型和行为型模式）开始。
- en: We went on to see an example of a Strategy design pattern, and saw how to implement
    this in a Pythonic manner. We then began our formal discussion of patterns in
    Python.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续看了一个策略设计模式的例子，并看到如何以Python的方式实现它。然后我们开始正式讨论Python中的模式。
- en: In Creational patterns, we covered the Singleton, Borg, Prototype, Factory,
    and Builder patterns. We saw why Borg is usually a better approach than the Singleton
    in Python due to its ability to keep state across class hierarchies. We saw the
    interplay between the Builder, Prototype, and Factory patterns, and saw a few
    examples. Everywhere possible, metaclass discussions were introduced, and pattern
    implementations were done using metaclasses.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建型模式中，我们涵盖了单例、Borg、原型、工厂和生成器模式。我们看到了为什么Borg通常比单例在Python中更好，因为它能够在类层次结构中保持状态。我们看到了生成器、原型和工厂模式之间的相互作用，并看到了一些例子。在可能的情况下，引入了元类讨论，并使用元类实现了模式。
- en: In Structural patterns, our focus was on the Adapter, façade, and Proxy patterns.
    We saw detailed examples using the Adapter pattern, and discussed approaches via
    inheritance and object composition. We saw the power of magic methods in Python
    when we implemented the Adapter and Proxy patterns via the `__getattr__` technique.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 在结构型模式中，我们的重点是适配器、facade和代理模式。我们通过适配器模式看到了详细的例子，并讨论了通过继承和对象组合的方法。当我们通过`__getattr__`技术实现适配器和代理模式时，我们看到了Python中魔术方法的威力。
- en: In Facade, using a `Car` class, we saw a detailed example on how Facade helps
    the programmers to conquer complexity and provide generic interfaces over the
    subsystems. We also saw that many of the Python standard library modules are themselves
    facades.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 在Facade中，使用`Car`类，我们看到了一个详细的例子，说明了Facade如何帮助程序员征服复杂性，并在子系统上提供通用接口。我们还看到许多Python标准库模块本身就是facade。
- en: In the Behavioral section, we discussed the patterns Iterator, Observer, and
    State. We saw how iterators were part and parcel of Python. We implemented an
    iterator as a generator for building Prime numbers.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 在行为部分，我们讨论了迭代器、观察者和状态模式。我们看到迭代器是Python的一部分。我们实现了一个迭代器作为生成器来构建素数。
- en: We saw a simple example of the Observer pattern by using an `Alarm` class as
    a Publisher and a clock class as Subscriber. We also saw an example of an asynchronous
    observer pattern using the asyncio module in Python.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用`Alarm`类作为发布者和时钟类作为订阅者，看到了观察者模式的一个简单例子。我们还看到了在Python中使用asyncio模块的异步观察者模式的例子。
- en: Finally, we ended our discussion of Patterns with the State pattern. We discussed
    a detailed example of switching the states of a computer through allowable state
    changes, and how one can use Python's `__class__` as a dynamic attribute to change
    the class of an instance. In the implementation of State, we borrowed techniques
    from the Iterator pattern, and implemented the State example class as an Iterator.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们以状态模式结束了模式的讨论。我们讨论了通过允许的状态更改来切换计算机状态的详细示例，以及如何使用Python的`__class__`作为动态属性来更改实例的类。在状态的实现中，我们借鉴了迭代器模式的技术，并将状态示例类实现为迭代器。
- en: In our next chapter, we move on from design to the next higher paradigm of patterns
    in software architecture, namely that of Architectural Patterns.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一章中，我们从设计转向软件架构中模式的下一个更高范式，即架构模式。
