- en: Chapter 9. Extending and Deploying
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。扩展和部署
- en: In this chapter, we will prepare our application for deployment in production
    by utilizing various Django framework features. We will add support for multiple
    languages, improve performance by caching and automated testing, and configure
    the project for a production environment. There is a lot of interesting and useful
    information in this chapter, so make sure you go through it before publishing
    your application online!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过利用各种Django框架功能来准备我们的应用程序以在生产中部署。我们将添加对多种语言的支持，通过缓存和自动化测试来提高性能，并为生产环境配置项目。本章中有很多有趣和有用的信息，因此在将应用程序发布到网上之前，请确保您仔细阅读！
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下主题：
- en: Sending invitation e-mails to friends
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向朋友发送邀请电子邮件
- en: Internationalization (i18n)—offering the site in multiple languages
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 国际化（i18n）-提供多种语言的站点
- en: Caching—improving the performance of your site during high traffic
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存-在高流量期间提高站点性能
- en: Unit testing—automating the process of testing your application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试-自动化测试应用程序的过程
- en: Sending invitation e-mails to friends
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向朋友发送邀请电子邮件
- en: Enabling our users to invite their friends carries many benefits. People are
    more likely to join our site if their friends already use it. After they join,
    they will also invite their friends, and so on, which means more and more users
    for our application. Therefore, it is a good idea to include an "invite a friend"
    feature in our app.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使我们的用户邀请他们的朋友具有许多好处。如果他们的朋友已经使用我们的网站，那么他们更有可能加入我们的网站。加入后，他们还会邀请他们的朋友，依此类推，这意味着我们的应用程序会有越来越多的用户。因此，在我们的应用程序中包含“邀请朋友”的功能是一个好主意。
- en: 'Building this feature requires the following components:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 构建此功能需要以下组件：
- en: An invitation data model to store invitations in the database
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个邀请数据模型，用于在数据库中存储邀请
- en: A form in which users can type the e-mail IDs of their friends and send invitations
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以在其中输入他们朋友的电子邮件ID并发送邀请的表单
- en: An invitation e-mail with an activation link
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有激活链接的邀请电子邮件
- en: A mechanism to process activation links sent in e-mails
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理电子邮件中发送的激活链接的机制
- en: 'Throughout this section, we will implement each of these components. However,
    because this section involves sending e-mails, we first need to configure Django
    to send e-mails by adding some options to the `settings.py` file. So, open the
    `settings.py` file and add the following lines:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现这些组件中的每一个。但是，因为本节涉及发送电子邮件，我们首先需要通过向`settings.py`文件添加一些选项来配置Django发送电子邮件。因此，打开`settings.py`文件并添加以下行：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s see what each variable in the preceding code does:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看前面代码中的每个变量都做了什么：
- en: '`SITE_HOST`: This is the hostname of your server. Leave it as `127.0.0.1:8000`
    for now. When we deploy our server in the next chapter, we will change this.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SITE_HOST`：这是您服务器的主机名。现在将其保留为`127.0.0.1:8000`。在下一章中部署服务器时，我们将更改此设置。'
- en: '`DEFAULT_FROM_EMAIL`: This is the e-mail address that appears in the **From**
    field of the outgoing e-mail server. For the host username, input your username
    plus your e-mail server, as shown in the preceding code snippet. Leave the fields
    empty if your ISP does not require them.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEFAULT_FROM_EMAIL`：这是出站电子邮件服务器**From**字段中显示的电子邮件地址。对于主机用户名，请输入您的用户名加上您的电子邮件服务器，如前面的代码片段所示。如果您的ISP不需要这些字段，请将其留空。'
- en: '`EMAIL_HOST`: This is the hostname of your e-mail server.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EMAIL_HOST`：这是您的电子邮件服务器的主机名。'
- en: '`EMAIL_PORT`: This is the port number of the outgoing e-mail server. If you
    leave it empty, the default value (25) will be used. You also need to obtain this
    from your ISP.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EMAIL_PORT`：这是出站电子邮件服务器的端口号。如果将其留空，则将使用默认值（25）。您还需要从ISP那里获取此信息。'
- en: '`EMAIL_HOST_USER` and `EMAIL_HOST_PASSWORD`: This is the username and password
    for e-mails sent by Django.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EMAIL_HOST_USER`和`EMAIL_HOST_PASSWORD`：这是Django发送的电子邮件的用户名和密码。'
- en: If your development machine doesn't run a mail server, most likely this is the
    case, then you need to enter your ISP's outgoing e-mail server. Contact your ISP
    for more information.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的开发计算机没有运行邮件服务器，很可能是这种情况，那么您需要输入ISP的出站电子邮件服务器。联系您的ISP以获取更多信息。
- en: 'To verify that your settings are correct, launch the interactive shell and
    enter the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证您的设置是否正确，请启动交互式shell并输入以下内容：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Replace the `your_email@example.com` parameter with your actual e-mail address.
    If the preceding call to send mail does not raise an exception and you receive
    the e-mail, then all is set. Otherwise, you need to verify your settings with
    your ISP and try again.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 将`your_email@example.com`参数替换为您的实际电子邮件地址。如果前面的发送邮件调用没有引发异常并且您收到了邮件，那么一切都设置好了。否则，您需要与ISP验证您的设置并重试。
- en: 'But wait, what if you don''t get any information from the ISP? We then try
    the alternate way: using Gmail to send a mail (of course, not as `noreply@mytweet.com`,
    but from your real e-mail ID). Let''s look at the changes you will have to make
    in the `settings.py` file of `MyTweeets` project for the same.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您没有从ISP那里获得任何信息怎么办？然后我们尝试另一种方式：使用Gmail发送邮件（当然，不是作为`noreply@mytweet.com`，而是从您的真实电子邮件ID）。让我们看看您需要对`MyTweeets`项目的`settings.py`文件进行哪些更改。
- en: 'Remove the previous `settings.py` file entries entirely and add the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 完全删除以前的`settings.py`文件条目，并添加以下内容：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you are getting an error such as:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到错误，例如：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This means that the `EMAIL_HOST_PASSWORD` parameter needs a application authorization
    password that is not your e-mail password. Follow the link mentioned in the host
    section to get more details on how to create one.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`EMAIL_HOST_PASSWORD`参数需要一个应用程序授权密码，而不是您的电子邮件密码。请按照主机部分中提到的链接获取有关如何创建的更多详细信息。
- en: 'After setting the things up, try sending the mail again from the shell using
    the following commands:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好这些东西后，尝试使用以下命令从shell再次发送邮件：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, the `your_email@example.com` parameter is any e-mail address that you
    want to send a mail to. The from address of the mail will be the Gmail e-mail
    address that we passed to the following variable:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`your_email@example.com`参数是您想发送邮件的任何电子邮件地址。邮件的发件人地址将是我们传递给以下变量的Gmail电子邮件地址：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, once the settings are correct, sending an e-mail in Django is a piece of
    cake! We will use the `EmailMessage` function to send the invitation e-mail, but
    first, let's create a data model to store invitations.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦设置正确，使用Django发送邮件就像小菜一碟！我们将使用`EmailMessage`函数发送邀请邮件，但首先，让我们创建一个数据模型来存储邀请。
- en: The invitation data model
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 邀请数据模型
- en: 'An invitation consists of the following information:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 邀请包括以下信息：
- en: The recipient name
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收件人姓名
- en: The recipient e-mail
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收件人邮箱
- en: The user object of the sender
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发件人的用户对象
- en: 'We also need to store an activation code for the invitation. This code will
    be sent in the invitation e-mail. The code will serve two purposes:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为邀请存储一个激活码。该代码将在邀请邮件中发送。该代码将有两个目的：
- en: Before accepting the invitation, we can use the code to verify that the invitation
    actually exists in the database
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在接受邀请之前，我们可以使用该代码验证邀请是否实际存在于数据库中
- en: After accepting the invitation, we can use the code to retrieve the invitation
    information from the database and to follow relationships between the sender and
    recipient
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受邀请后，我们可以使用该代码从数据库中检索邀请信息，并跟踪发件人和收件人之间的关系
- en: 'With the preceding information in mind, let''s create the invitation data model.
    Open the `user_profile/models.py` file and append the following code to it:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到上述信息，让我们创建邀请数据模型。打开`user_profile/models.py`文件，并将以下代码追加到其中：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There shouldn't be anything new or difficult to understand in this model. We
    have simply defined fields for the recipient name, recipient e-mail, activation
    code, and the sender of the invitation. We also created a `__unicode__` method
    for debugging and enabled the model in the administration interface. Do not forget
    to run the `python manage.py syncdb` command to create the new model's table in
    the database.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模型中没有什么新的或难以理解的。我们只是为收件人姓名、收件人电子邮件、激活码和邀请发件人定义了字段。我们还为调试创建了一个`__unicode__`方法，并在管理界面中启用了该模型。不要忘记运行`python
    manage.py syncdb`命令来在数据库中创建新模型的表。
- en: 'We will also create the invitation form for this. Create a file called `forms.py`
    in the `user_profile` directory and update it with the following code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将为此创建邀请表单。在`user_profile`目录中创建一个名为`forms.py`的文件，并使用以下代码进行更新：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Creating the view page from where the invitations will be sent is similar to
    creating the other pages that we created for search and tweets forms that we made
    by creating a new file called `template/invite.html`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 创建发送邀请的视图页面类似于创建我们为搜索和推文表单创建的其他页面，通过创建一个名为`template/invite.html`的新文件：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The URL entry for this is as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的URL输入如下：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, we need to create `get` and `post` methods to send an invitation mail with
    this form.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建`get`和`post`方法来使用此表单发送邀请邮件。
- en: As sending an e-mail is more specific to a user than a tweet, we will create
    this method in `user_profile` views, contrary to the tweet view that we used before.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于发送邮件比推文更具体于用户，我们将在`user_profile`视图中创建此方法，而不是之前使用的推文视图。
- en: 'Update the `user_profile/views.py` file with the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码更新`user_profile/views.py`文件：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, the `get()` method is as simple as rendering the `invite.html` file with
    the invite form as a parameter and a flag called the `success` and `email` variable
    is initially unset.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`get()`方法就像使用`invite.html`文件渲染邀请表单一样简单，并且初始未设置`success`和`email`变量。
- en: 'The `post()` method uses the usual form check and variable extraction concept;
    the code you will see for the first time is as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`post()`方法使用通常的表单检查和变量提取概念；您将首次看到的代码如下：'
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is actually a static function call that generated the activation token
    with a unique key for every invited user. The `render_to_string()` method works
    when you load a template called `_invite_email_template.html` and pass the following
    variables to it:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是一个静态函数调用，为每个受邀用户生成具有唯一密钥的激活令牌。当您加载名为`_invite_email_template.html`的模板并将以下变量传递给它时，`render_to_string()`方法将起作用：
- en: '`sender_name`: This is the name of the person who has invited or is the sender
    of the e-mail'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sender_name`：这是邀请或发件人的姓名'
- en: '`sender_email`: This is the e-mail address of the sender'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sender_email`：这是发件人的电子邮件地址'
- en: '`email`: This is the e-mail address of the person who has been invited'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`email`：这是被邀请人的电子邮件地址'
- en: '`link`: This is the invitation acceptance link'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`link`：这是邀请接受链接'
- en: The template is then used to render the body of the invitation e-mail. After
    that, we use the `EmailMultiAlternatives()` method to send the e-mail, as we did
    during the interactive session in the previous section.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用该模板来渲染邀请邮件的正文。之后，我们使用`EmailMultiAlternatives()`方法发送邮件，就像我们在上一节的交互式会话中所做的那样。
- en: 'There are several observations to be made here:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几点需要注意：
- en: The format of the activation link is `http://SITE_HOST/invite/accept/CODE/`.
    We will write a view to handle such URLs later in this section.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 激活链接的格式为`http://SITE_HOST/invite/accept/CODE/`。我们将在本节后面编写一个视图来处理此类URL。
- en: This is the first time we used a template to render something other than a web
    page. As you can see, the template system is quite flexible and allows us to build
    e-mails, as well as web pages, or any other text for that matter.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是我们第一次使用模板来渲染除网页以外的其他内容。正如您所见，模板系统非常灵活，允许我们构建电子邮件，以及网页或任何其他文本。
- en: We used the `render_to_string()` and `render()` methods to build the message
    body as opposed to the usual `render_to_response` call. If you remember, this
    is how we rendered templates earlier in this book. We are doing this here because
    we are not rendering a web page.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`render_to_string()`和`render()`方法构建消息正文，而不是通常的`render_to_response`调用。如果你还记得，这就是我们在本书早期渲染模板的方式。我们这样做是因为我们不是在渲染网页。
- en: 'Since the `send` method loads a template called `_invite_email_template.html`,
    create a file with this name in the templates folder and insert the following
    content:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`send`方法加载名为`_invite_email_template.html`的模板，请在模板文件夹中创建一个同名文件并插入以下内容：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We are halfway through the implementation of the "invite a friend" feature.
    At the moment, clicking on the activation link produces a 404 page not found error,
    so, next, we will write a view to handle it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了“邀请朋友”功能的一半实现。目前，点击激活链接会产生404页面未找到错误，因此，接下来，我们将编写一个视图来处理它。
- en: Handling activation links
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理激活链接
- en: We have made good progress; users are now able to send invitations to their
    friends via e-mail. The next step is to build a mechanism that handles activation
    links in invitations. Here is an outline of what we are going to do.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们取得了良好的进展；用户现在能够通过电子邮件邀请他们的朋友。下一步是构建一个处理邀请中激活链接的机制。以下是我们将要做的概述。
- en: We will build a view that handles activation links. This view verifies that
    the invitation code actually exists in the database, and that the user who registers
    automatically follows the user who sent the link and gets redirected to the registration
    page.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个视图来处理激活链接。此视图验证邀请码实际上是否存在于数据库中，并且注册的用户自动关注发送链接的用户并被重定向到注册页面。
- en: 'Let''s start by writing a URL entry for the view. Open the `urls.py` file and
    add the highlighted line to it:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为视图编写URL条目开始。打开`urls.py`文件并添加以下突出显示的行：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Create a class in the `user_profile/view.py` file with thename of the class
    as `InviteAccept()`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在`user_profile/view.py`文件中创建一个名为`InviteAccept()`的类。
- en: Logically, InviteAccept will work as the users will be asked to register for
    the application, and if they have already registered, they will be asked to follow
    the user who invited them.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 从逻辑上讲，邀请接受将起作用，因为用户将被要求注册应用程序，如果他们已经注册，他们将被要求关注邀请他们的用户。
- en: 'For the sake of simplicity, we will redirect the user to the registration page
    with the activation code so that when they register, they automatically become
    followers. Let''s take a look at the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们将用户重定向到带有激活码的注册页面，这样当他们注册时，他们将自动成为关注者。让我们看一下以下代码：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, we will write the registration page with the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将用以下代码编写注册页面：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, the view follows the URL format sent in invitation e-mails.
    The activation code is captured from the URL using a regular expression and is,
    then, passed to the view as a parameter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，视图遵循邀请电子邮件中发送的URL格式。激活码是使用正则表达式从URL中捕获的，然后作为参数传递给视图。
- en: This was a bit time-consuming, but we were able to put our Django knowledge
    to good use while implementing it. You can now click on the invitation link that
    you received via e-mail to see what happens. You will be redirected to the registration
    page; you can create a new account there, log in, and note how the new account,
    and your original one, became followers of the sender.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点耗时，但我们能够充分利用我们的Django知识来实现它。您现在可以点击通过电子邮件收到的邀请链接，看看会发生什么。您将被重定向到注册页面；您可以在那里创建一个新账户，登录，并注意新账户和您的原始账户如何成为发送者的关注者。
- en: Internationalization (i18n) – offering the site in multiple languages
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 国际化（i18n）-提供多种语言的网站
- en: People won't use our application if they cannot read its pages. So far, we have
    been concerned with English-speaking users only. However, there are people all
    over the world who do not know English or prefer to use their native language.
    To appeal to those people, it would be a good idea to offer the interface of our
    application in multiple languages. This would overcome the language barrier and
    open new frontiers for our application, especially in regions where English is
    not common.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果人们无法阅读我们应用的页面，他们就不会使用我们的应用。到目前为止，我们只关注说英语的用户。然而，全世界有许多人不懂英语或更喜欢使用他们的母语。为了吸引这些人，将我们应用的界面提供多种语言是个好主意。这将克服语言障碍，并为我们的应用打开新的前沿，特别是在英语不常用的地区。
- en: As you may have guessed, Django provides all the components needed to translate
    a project into multiple languages. The system that is responsible for providing
    this feature is called the **internationalization system** (**i18n**). The process
    of translating a Django project is quite simple.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经猜到的那样，Django提供了将项目翻译成多种语言所需的所有组件。负责提供此功能的系统称为**国际化系统**（**i18n**）。翻译Django项目的过程非常简单。
- en: 'You follow these three steps:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下三个步骤进行：
- en: Specify which strings should be translated in your application—for example,
    status and error messages are translatable, whereas usernames are not.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定应用程序中应翻译的字符串，例如，状态和错误消息是可翻译的，而用户名则不是。
- en: Create a translation file for each language you want to support.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为要支持的每种语言创建一个翻译文件。
- en: Enable and configure the i18n system.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用和配置i18n系统。
- en: We will go through each step in detail in the following subsections. By the
    end of this section of the chapter, our application will support multiple languages
    and you will be able to translate any other Django project with ease.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下各小节中详细介绍每个步骤。在本章节的最后，我们的应用将支持多种语言，您将能够轻松翻译任何其他Django项目。
- en: Marking strings as translatable
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将字符串标记为可翻译的
- en: 'The first step in translating an application is telling Django which strings
    should be translated. Generally speaking, strings that are part of views and templates
    need to be translated, while strings that are entered by the user do not need
    to be. Marking a string as translatable is done with a function call. The name
    of the function and how it is called depends on where the string is located: in
    a view, template, model, or form.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译应用程序的第一步是告诉Django哪些字符串应该被翻译。一般来说，视图和模板中的字符串需要被翻译，而用户输入的字符串则不需要。将字符串标记为可翻译是通过函数调用完成的。函数的名称以及调用方式取决于字符串的位置：在视图、模板、模型或表单中。
- en: 'This step is much easier than it initially looks. Let''s learn about it with
    an example. We will translate the "invite follower" functionality in our application.
    The process of translating the rest of the application will be exactly the same.
    Open the `user_profile/views.py` file and make the highlighted changes to the
    invite view:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步比起一开始看起来要容易得多。让我们通过一个例子来了解它。我们将翻译应用程序中的“邀请关注者”功能。翻译应用程序的其余部分的过程将完全相同。打开`user_profile/views.py`文件，并对邀请视图进行突出显示的更改：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Note that the subject string starts with a "`_`"; alternatively, you can also
    write it as:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，主题字符串以“`_`”开头；或者，您也可以这样写：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Either way, it works well.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，它都运行良好。
- en: 'As you can see, the changes are minimal:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，更改是微不足道的：
- en: We imported a function called `ugettext` from `django.utils.translation`.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从`django.utils.translation`中导入了一个名为`ugettext`的函数。
- en: We used as a keyword to assign a shorter name to the function (the underscore
    character). We did so because this function will be used to mark strings as translatable
    in views, and since this is a very common task, it's a good idea to give the function
    a shorter name.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了`as`关键字为函数（下划线字符）分配了一个更短的名称。我们这样做是因为这个函数将用于在视图中标记字符串为可翻译的，而且由于这是一个非常常见的任务，给函数一个更短的名称是个好主意。
- en: We marked a string as translatable simply by passing it to the `_` function.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们只需将一个字符串传递给`_`函数即可将其标记为可翻译。
- en: 'That was pretty simple, wasn''t it? However, there is one little observation
    that we need to make here. The first message uses string formatting, and we applied
    the `%` operator after calling the `_()` function. This is necessary to avoid
    translating the e-mail address. It''s also preferable to use named formats, which
    give you greater control while doing the actual translation later. So, you may
    want to define the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，不是吗？然而，这里有一个小观察需要做。第一条消息使用了字符串格式化，并且在调用`_()`函数后应用了`%`运算符。这是为了避免翻译电子邮件地址。最好使用命名格式，这样在实际翻译时可以更好地控制。因此，您可能想要定义以下代码：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now that we know how to mark strings as translatable in views, let''s move
    to templates. Open the `invite.html` file in the templates folder and modify it
    as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道如何在视图中标记字符串为可翻译的，让我们转到模板。在模板文件夹中打开`invite.html`文件，并修改如下：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we placed the `{% load i18n %}` parameter at the beginning of the template
    to give it access to translation tags. The `<load>` tag is generally used to enable
    additional template tags that are not available by default. You need to place
    it at the top of every template that uses translation tags. i18n is shorthand
    for internationalization, which is the name of the Django framework that provides
    translation features.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在模板的开头放置了`{% load i18n %}`参数，以便让它可以访问翻译标签。`<load>`标签通常用于启用默认情况下不可用的额外模板标签。您需要在使用翻译标签的每个模板的顶部放置它。i18n是国际化的缩写，这是Django框架的名称，它提供了翻译功能。
- en: 'Next, we used a template tag called `trans` to mark strings as translatable.
    This template tag works exactly the same as the `gettext` function in views. It''s
    worth noting that the `trans` tag does not work if the string contains a template
    variable. In this case, you would need to use the `blocktrans` tag like:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用了一个名为`trans`的模板标签来标记字符串为可翻译的。这个模板标签与视图中的`gettext`函数完全相同。值得注意的是，如果字符串包含模板变量，`trans`标签将不起作用。在这种情况下，您需要使用`blocktrans`标签，如下所示：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can pass a variable block, that is, `{{ variable }}` also inside `{% endblocktrans
    %}` block to make it more meaningful for the readers.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`{% endblocktrans %}`块中传递一个变量块，即`{{ variable }}`，以使其对读者更有意义。
- en: 'Now you know how to deal with translatable strings in templates too. So, let''s
    move to forms and models. Marking a string as translatable in a form or model
    is slightly different from views. To learn how it is done, open the `user_profile/forms.py`
    file and modify the invite form, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何在模板中处理可翻译的字符串了。那么，让我们转到表单和模型。在表单或模型中标记字符串为可翻译与在视图中略有不同。要了解如何完成这一点，请打开`user_profile/forms.py`文件，并修改邀请表单如下：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The only difference here is that we imported the `gettext_lazy` function instead
    of `gettext . gettext_lazy`, which delays translating the string until its return
    value is accessed. This is needed here because the attributes of the form are
    created only once: when the application is started. If we use the normal `gettext`
    function, the translated labels will be stored in the form attributes using the
    default language (usually English) and will never be translated again. However,
    if we use the `gettext_lazy` function, the function will return a special object
    that will translate the string every time it is accessed and, hence, the translation
    will be done correctly. This feature makes the `gettext_lazy` function ideal for
    form and model attributes.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是我们导入了`gettext_lazy`函数而不是`gettext`。`gettext_lazy`会延迟直到访问其返回值时才翻译字符串。这在这里是必要的，因为表单的属性只在应用程序启动时创建一次。如果我们使用普通的`gettext`函数，翻译后的标签将以默认语言（通常是英语）存储在表单属性中，并且永远不会再次翻译。但是，如果我们使用`gettext_lazy`函数，该函数将返回一个特殊对象，每次访问时都会翻译字符串，因此翻译将正确进行。这使得`gettext_lazy`函数非常适合表单和模型属性。
- en: 'With this, we finish marking the strings of the "invite friend" view for translation.
    To help you remember what''s covered in this subsection, here is a quick summary
    of the techniques used to mark the translatable strings:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们完成了为“邀请朋友”视图标记字符串以进行翻译。为了帮助您记住本小节涵盖的内容，这里是标记可翻译字符串所使用的技术的快速总结：
- en: In views, mark the translatable strings using the `gettext` function (usually
    imported as `_` )
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在视图中，使用`gettext`函数标记可翻译的字符串（通常导入为`_`）
- en: In templates, mark the translatable strings using the `trans` template tag for
    strings that do not contain variables and the `blocktrans` tag for the strings
    that do
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模板中，使用`trans`模板标记标记不包含变量的可翻译字符串，使用`blocktrans`标记标记包含变量的字符串。
- en: In forms and models, mark the translatable strings using the `gettext_lazy`
    function (usually imported as `_` )
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在表单和模型中，使用`gettext_lazy`函数标记可翻译的字符串（通常导入为`_`）
- en: Of course, there are special cases that may need to be handled separately. For
    example, you may want to translate default parameter values in views using the
    `gettext_lazy` function instead of the `gettext` function. As long as you understand
    the difference between these two functions, you should be able to decide when
    you need to do so.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也有一些特殊情况可能需要单独处理。例如，您可能希望使用`gettext_lazy`函数而不是`gettext`函数来翻译视图中的默认参数值。只要您理解这两个函数之间的区别，您就应该能够决定何时需要这样做。
- en: Creating translation files
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建翻译文件
- en: Now that we have finished marking strings for translation, the next step is
    to create a translation file for each language that we want to support. This file
    contains all the translatable strings along with their translations and is created
    using a utility provided by Django.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了标记要翻译的字符串，下一步是为我们想要支持的每种语言创建一个翻译文件。这个文件包含所有可翻译的字符串及其翻译，并使用Django提供的实用程序创建。
- en: Let's create a translation file. First, you need to locate a file named `make-messages.py`
    in the `bin` directory inside your Django installation folder. The easiest way
    to find it is by using the search functionality in your operating system. Once
    you find it, copy it to your system path (`/usr/bin/` in Linux and Mac OS X and.
    `c:\windows\` in Windows).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个翻译文件。首先，您需要在Django安装文件夹内的`bin`目录中找到一个名为`make-messages.py`的文件。找到它的最简单方法是使用操作系统中的搜索功能。找到它后，将其复制到系统路径（在Linux和Mac
    OS X中为`/usr/bin/`，在Windows中为`c:\windows\`）。
- en: 'Also, make sure that it is executable by running the following command in Linux
    and Mac OS X (this step is not needed for Windows users):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，确保在Linux和Mac OS X中运行以下命令使其可执行（对Windows用户来说，这一步是不需要的）：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `make-messages.py` utility uses a software package called GNU gettext to
    extract the translatable strings from the source code. So, you need to install
    this package. For Linux, search for the package in your package manager and install
    it. Windows users will find an installer for the package at [http://gnuwin32.sourceforge.net/packages/gettext.htm](http://gnuwin32.sourceforge.net/packages/gettext.htm).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`make-messages.py`实用程序使用一个名为GNU gettext的软件包从源代码中提取可翻译的字符串。因此，您需要安装这个软件包。对于Linux，搜索您的软件包管理器中的软件包并安装它。Windows用户可以在[http://gnuwin32.sourceforge.net/packages/gettext.htm](http://gnuwin32.sourceforge.net/packages/gettext.htm)找到该软件包的安装程序。'
- en: Finally, Mac OS X users will find a version of the package for their operating
    system along with the installation instructions at [http://gettext.darwinports.com/](http://gettext.darwinports.com/).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Mac OS X用户将在[http://gettext.darwinports.com/](http://gettext.darwinports.com/)找到适用于其操作系统的软件包版本以及安装说明。
- en: 'Once you have the GNU gettext package installed, open a terminal, go to your
    project folder, create a folder called `locale` there, and then run the following
    command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 安装GNU gettext软件包后，打开终端，转到您的项目文件夹，在那里创建一个名为`locale`的文件夹，然后运行以下命令：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This command creates a translation file for the German language. The `de` variable
    is the language code for German. If you want to target another language, put its
    language code instead of `de` and continue to do so for the rest of the chapter.
    In addition to this, if you want to support more than one language, run the previous
    command for each language and apply the instructions to the rest of this section
    to all languages.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '这个命令为德语语言创建了一个翻译文件。`de`变量是德语的语言代码。如果您想要翻译其他语言，将其语言代码放在`de`的位置，并继续为本章的其余部分执行相同的操作。除此之外，如果您想要支持多种语言，为每种语言运行上一个命令，并将说明应用到本节的所有语言。 '
- en: 'Once you run the preceding command, it will create a file called `django.po`
    at `locale/de/LC_MESSAGES/`. This is the translation file for the German language.
    Open it in a text editor to see what it looks like. The file starts with some
    metadata, such as the creation date and a character set. After that, you will
    find an entry for each translatable string. Each entry consists of the filename
    and line number of the string, the string itself, and an empty string below it
    where the translation should go. Here is a sample entry from the file:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您运行了上述命令，它将在`locale/de/LC_MESSAGES/`下创建一个名为`django.po`的文件。这是德语语言的翻译文件。在文本编辑器中打开它，看看它是什么样子的。文件以一些元数据开头，比如创建日期和字符集。之后，您会发现每个可翻译字符串的条目。每个条目包括字符串的文件名和行号，字符串本身，以及下面的空字符串，用于放置翻译。以下是文件中的一个示例条目：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To translate the string, simply use your text editor to type the translation
    in the empty string on the third line. You can also use a specialized translation
    editor, such as `Poedit` (available for all major operating systems at [http://www.poedit.net/](http://www.poedit.net/)),
    but for our simple file, a regular text editor should suffice. Make sure that
    you set a valid character in the metadata section of the file. I recommend that
    you use **UTF-8**:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要翻译字符串，只需使用文本编辑器在第三行的空字符串中输入翻译。您也可以使用专门的翻译编辑器，比如`Poedit`（在[http://www.poedit.net/](http://www.poedit.net/)上提供所有主要操作系统的版本），但对于我们的简单文件，普通文本编辑器就足够了。确保在文件的元数据部分设置一个有效的字符。我建议您使用**UTF-8**：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You may note that the translation file contains some strings from the admin
    interface. This is because the `admin/base_site.html` admin template uses the
    `trans` template tag to mark its strings as translatable. There is no need to
    translate these strings; Django already comes with translation files for them.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到翻译文件包含一些来自管理界面的字符串。这是因为`admin/base_site.html`管理模板使用`trans`模板标记将其字符串标记为可翻译的。无需翻译这些字符串；Django已经为它们提供了翻译文件。
- en: Once you're done translating, you need to compile the translation file into
    a format that Django can use. This is done using another utility provided by Django
    called the `compile-messages.py` command. Locate and move this file to your system
    path and make sure that it is executable by following the same procedure as we
    did with the `make-messages.py` command.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译完成后，您需要将翻译文件编译为Django可以使用的格式。这是使用Django提供的另一个实用程序`compile-messages.py`命令完成的。找到并将此文件移动到系统路径，并确保它是可执行的，方法与我们使用`make-messages.py`命令相同。
- en: 'Next, run the following command from within your project folder:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在项目文件夹中运行以下命令：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If the utility complains about an error in the file (such as a missing quotation
    mark), correct the error and try again. Once it is successful, the utility will
    create a compiled translation file called `django.mo` in the same folder and everything
    will be set for the next step in this section.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实用程序报告文件中的错误（例如缺少引号），请更正错误并重试。一旦成功，实用程序将在同一文件夹中创建一个名为`django.mo`的已编译翻译文件，并为本节的下一步做好一切准备。
- en: Enabling and configuring the i18n system
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用和配置i18n系统
- en: 'Django comes with the i18n system enabled by default. You can verify this by
    searching for the following line in the `settings.py` file:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Django默认启用了i18n系统。您可以通过在`settings.py`文件中搜索以下行来验证这一点：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There are two ways to configure the i18n system. You can either set the language
    globally for all users or let users specify their preferred languages individually.
    We will see how to do both in this subsection.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种配置i18n系统的方法。您可以为所有用户全局设置语言，也可以让用户单独指定其首选语言。我们将在本小节中看到如何同时进行这两种配置。
- en: 'To set the active language globally, find the variable called `LANGUAGE_CODE`
    in the `settings.py` file and assign your preferred language code to it. For example,
    if you want to set German as the default language for our project, change the
    language code as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要全局设置活动语言，请在`settings.py`文件中找到名为`LANGUAGE_CODE`的变量，并将您喜欢的语言代码分配给它。例如，如果您想将德语设置为项目的默认语言，请将语言代码更改如下：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, start the development server if it's not already running, and navigate
    to the "invite friend" page. There, you will find that the strings have changed
    according to what you entered in the German translation file. Now, change the
    value of the `LANGUAGE_CODE` variable to '`en`' and note how the page reverts
    back to English.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果开发服务器尚未运行，请启动它，并转到“邀请朋友”页面。在那里，您会发现字符串已根据您在德语翻译文件中输入的内容进行了更改。现在，将`LANGUAGE_CODE`变量的值更改为'`en`'，并注意页面如何恢复为英语。
- en: 'The second configuration method is to let users choose the language. To do
    so, we should enable a class called `LocaleMiddleware`. To put it simply, a middleware
    is a class that processes a request or response object. Many components of Django
    make use of middleware classes to implement features. To see this, open the `settings.py`
    file and search for the `MIDDLEWARE_CLASSES` variable. You will find a list of
    strings there, and one of them will be `django.contrib.sessions.middleware.SessionMiddleware`,
    which attaches session data to the request object. We don''t need to learn how
    middleware classes are implemented before using them. To enable `LocaleMiddleware`,
    simply add its classpath to the `MIDDLEWARE_CLASSES` list. Make sure that you
    put `LocaleMiddleware` after `SessionMiddleware` because the locale middleware
    utilizes the session API, as we will see next. Open the `settings.py` file and
    modify the file as highlighted in the following code snippet:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种配置方法是让用户选择语言。为此，我们应该启用一个名为`LocaleMiddleware`的类。简而言之，中间件是处理请求或响应对象的类。Django的许多组件都使用中间件类来实现功能。要查看这一点，请打开`settings.py`文件并搜索`MIDDLEWARE_CLASSES`变量。您会在那里找到一个字符串列表，其中一个是`django.contrib.sessions.middleware.SessionMiddleware`，它将会话数据附加到请求对象上。在使用中间件之前，我们不需要了解中间件类是如何实现的。要启用`LocaleMiddleware`，只需将其类路径添加到`MIDDLEWARE_CLASSES`列表中。确保将`LocaleMiddleware`放在`SessionMiddleware`之后，因为区域设置中间件利用会话API，我们将在下面看到。打开`settings.py`文件并按照以下代码片段中的突出显示的内容修改文件：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The locale middleware determines the active language for the user by following
    these steps:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 区域设置中间件通过以下步骤确定用户的活动语言：
- en: It looks for a key named `django_language` in the session data.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它在会话数据中查找名为`django_language`的键。
- en: If the key does not exist, it looks for a cookie called `django_language`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果键不存在，则查找名为`django_language`的cookie。
- en: If the cookie does not exist, it looks at the language code in the Accept-Language
    HTTP header. This header is sent by the browser to the web server indicating which
    languages you would prefer to receive content in.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果cookie不存在，则查看Accept-Language HTTP标头中的语言代码。此标头由浏览器发送到Web服务器，指示您希望以哪种语言接收内容。
- en: If all else fails, the `LANGUAGE_CODE` variable in the `settings.py` file is
    used.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切都失败了，将使用`settings.py`文件中的`LANGUAGE_CODE`变量。
- en: 'In all the preceding steps, Django looks for a language code that matches one
    of the available translation files. To effectively utilize the locale middleware,
    we need a view that enables the user to choose a language and updates the session
    data accordingly. Fortunately, Django already comes with such a view for us to
    use. The view is called **setlanguage**, and it expects a language code in a GET
    variable called language. It updates the session data using this variable and
    redirects the user to the originating page. To enable this view, edit the `urls.py`
    file and add the following highlighted lines to it:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有前面的步骤中，Django会寻找与可用翻译文件匹配的语言代码。为了有效地利用区域设置中间件，我们需要一个视图，使用户能够选择语言并相应地更新会话数据。幸运的是，Django已经为我们提供了这样的视图。该视图称为**setlanguage**，并且它期望在名为language的GET变量中包含语言代码。它使用此变量更新会话数据，并将用户重定向到原始页面。要启用此视图，请编辑`urls.py`文件，并向其中添加以下突出显示的行：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Adding the preceding lines is similar to how we added URL entries for the admin
    interface. If you recall from a previous chapter, the `include()` function can
    be used to include URL entries from another application under a specific path.
    Now, we can let the user change the language to German by providing a link, such
    as `/i18n/setlang/language=de`. We will modify the base template to add such links
    to all pages. Open the `templates/base.html` file and add the following highlighted
    lines to it:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 添加上述行类似于我们为管理界面添加URL条目的方式。如果您还记得之前的章节，`include()`函数可以用于在特定路径下包含来自另一个应用程序的URL条目。现在，我们可以通过提供链接（例如`/i18n/setlang/language=de`）让用户将语言更改为德语。我们将修改基本模板以在所有页面上添加此类链接。打开`templates/base.html`文件，并向其中添加以下突出显示的行：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Additionally, we will style the new footer by appending the following CSS code
    to the `site_media/style.css` file:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将通过将以下CSS代码附加到`site_media/style.css`文件来为新的页脚设置样式：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, the i18n functionality of our application is ready. Point your browser
    to the "invite friend" page and try the new language links at the bottom of the
    page. The language should change according to which link is clicked.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用程序的i18n功能已经准备就绪。将浏览器指向“邀请朋友”页面，并尝试页面底部的新语言链接。语言应该根据点击的链接而改变。
- en: 'Before we conclude this section, there are a few observations to be made here:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本节之前，这里有一些观察结果：
- en: You can access the currently active language in views using the request `LANGUAGE_CODE`
    attribute.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在视图中使用请求`LANGUAGE_CODE`属性访问当前活动的语言。
- en: Django itself is translated in a number of languages. You can see this by triggering
    a form error while a language other than English is active. Error messages will
    appear in the selected language even though you didn't translate them yourself.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django本身被翻译成多种语言。您可以通过在激活英语以外的语言时触发表单错误来查看这一点。错误消息将以所选语言显示，即使您自己没有进行翻译。
- en: In templates, when the `RequestContext` variable is used, the currently active
    language is accessible using the `LANGUAGE_CODE` template variable.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模板中，当使用`RequestContext`变量时，可以使用`LANGUAGE_CODE`模板变量访问当前活动的语言。
- en: This section was a bit long, but you learned a very important feature from it.
    By offering our application in multiple languages, we make it accessible to a
    broader audience, which gives it greater potential to attract more and more users.
    This actually applies to any web application, and, now, we will be able to translate
    any Django project in multiple languages with ease.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分有点长，但您从中学到了一个非常重要的功能。通过以多种语言提供我们的应用程序，我们使其能够吸引更广泛的受众，从而具有吸引更多用户的潜力。这实际上适用于任何Web应用程序，现在，我们将能够轻松地将任何Django项目翻译成多种语言。
- en: In the next section, we will shift to a different topic. When the user base
    of your application grows, the load on your server will increase and you will
    start to look for ways to improve the performance of your application. This is
    where caching comes to rescue.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将转移到另一个主题。当您的应用程序用户基数增长时，服务器的负载将增加，您将开始寻找改进应用程序性能的方法。这就是缓存发挥作用的地方。
- en: So, please read on to learn about this very useful technique!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，请继续阅读以了解这个非常有用的技术！
- en: Caching – improving the performance of your site during high traffic
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存-在高流量期间提高站点性能
- en: Pages of web applications are dynamically generated. Code is executed to process
    user input and generate output every time a page is requested. There are a lot
    of overheads involved in generating dynamic pages, especially when compared to
    serving static HTML files. The code may connect to a database, perform expensive
    calculations, process files, and so on. At the same time, being able to generate
    pages with code is exactly what makes a website dynamic and interactive.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序的页面是动态生成的。每次请求页面时，都会执行代码来处理用户输入并生成输出。生成动态页面涉及许多开销，特别是与提供静态HTML文件相比。代码可能会连接到数据库，执行昂贵的计算，处理文件等等。同时，能够使用代码生成页面正是使网站动态和交互的原因。
- en: Wouldn't it be great if we could get the best of both worlds? This is what caching
    does, and it's a feature that is implemented on most the sites with medium to
    high traffic. When a page is requested, caching stores the generated HTML of the
    page and reuses it later when the same page is requested again. This cuts a lot
    of overheads by avoiding the generation of the same page over and over again.
    Of course, cached pages are not stored forever. When a page is cached, an expiration
    period is set for the cache. When the cached page expires, it is deleted and the
    page is generated and cached again. The expiration period is usually between a
    few seconds and a few minutes, depending on the traffic of the site. The expiration
    period ensures that the cache is updated periodically and that users receive content
    updates, while, at the same time, reducing the overhead of generating pages.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能同时获得两全其美岂不是太好了？这就是缓存所做的，这是大多数中高流量网站上实现的功能。当请求页面时，缓存会存储页面的生成 HTML，并在以后再次请求相同页面时重用它。这样可以通过避免一遍又一遍地生成相同页面来减少很多开销。当然，缓存页面并不是永久存储的。当页面被缓存时，会为缓存设置一个过期时间。当缓存页面过期时，它会被删除，页面会被重新生成并缓存。过期时间通常在几秒到几分钟之间，取决于网站的流量。过期时间确保缓存定期更新，并且用户接收内容更新的同时，减少生成页面的开销。
- en: Although caching is particularly useful for medium to high traffic sites, sites
    with low traffic can also benefit from it. If the site happens to receive a surge
    of high traffic suddenly, perhaps because it was featured on a major news site,
    you can enable caching to reduce the server load and help your website survive
    the surge of high traffic. Later, when the traffic calms down, you can turn off
    caching. So, caching is also useful for small websites. You never know when you
    may need it, so you'd better have this information ready.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管缓存对于中高流量网站特别有用，低流量网站也可以从中受益。如果网站突然接收到大量高流量，可能是因为它被主要新闻网站报道，您可以启用缓存以减少服务器负载，并帮助您的网站度过高流量的冲击。稍后，当流量平息时，您可以关闭缓存。因此，缓存对小型网站也很有用。您永远不知道何时会需要它，所以最好提前准备好这些信息。
- en: Enabling caching
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用缓存
- en: 'We will start this section by enabling the caching system. To use caching,
    you first need to choose a caching backend and specify your choice in a variable
    called `CACHE_BACKEND` in the `settings.py` file. The contents of this variable
    depend on the caching backend you choose. Some of the available options are:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从启用缓存系统开始这一部分。要使用缓存，您首先需要选择一个缓存后端，并在 `settings.py` 文件中的一个名为 `CACHE_BACKEND`
    的变量中指定您的选择。此变量的内容取决于您选择的缓存后端。一些可用的选项包括：
- en: '**Simple Caching**: For this, the cache data is stored in process memory. This
    is only useful to test the caching system during development and must not be used
    in production. To enable it, add the following to the `settings.py` file:'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单缓存**：对于这种情况，缓存数据存储在进程内存中。这只对开发过程中测试缓存系统有用，不应在生产中使用。要启用它，请在 `settings.py`
    文件中添加以下内容：'
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '**Database Caching**: For this, the cache data is stored in a database table.
    To create the cache table, run the following command:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库缓存**：对于这种情况，缓存数据存储在数据库表中。要创建缓存表，请运行以下命令：'
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, add the following to the `settings.py` file:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `settings.py` 文件中添加以下内容：
- en: '[PRE35]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, the cache table was called `cache_table`. You can call it whatever you
    want as long as it doesn't conflict with an existing table.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，缓存表被称为 `cache_table`。只要不与现有表冲突，您可以随意命名它。
- en: '**Filesystem Caching**: Here, the cache data is stored in the local filesystem.
    To use it, add the following to the `settings.py` file:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件系统缓存**：在这里，缓存数据存储在本地文件系统中。要使用它，请在 `settings.py` 文件中添加以下内容：'
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, the `/tmp/django_cache` variable is used to store cache files. You can
    specify another path if you like.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`/tmp/django_cache` 变量用于存储缓存文件。如果需要，您可以指定另一个路径。
- en: '**Memcached**: Memcached is an advanced, highly efficient, and fast caching
    framework. Installing and configuring it is beyond the scope of this book, but
    if you already have a Memcached server available, you can specify its IP and port
    in the `settings.py` file, as follows:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Memcached**：Memcached 是一个先进、高效和快速的缓存框架。安装和配置它超出了本书的范围，但如果您已经有一个可用的 Memcached
    服务器，可以在 `settings.py` 文件中指定其 IP 和端口，如下所示：'
- en: '[PRE37]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If you are not sure which backend to choose for this section, go with simple
    caching. In reality, however, if you are caught in a sudden surge of traffic and
    want to improve server performance, go with Memcached or database caching, depending
    on what's available to you on the server. On the other hand, if you have a website
    with medium to high traffic, I highly recommend you to use Memcached, as it is
    definitely the fastest caching solution available for Django. The information
    presented in this section works the same regardless of which caching backend you
    choose.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不确定在本节中选择哪个后端，请选择简单缓存。然而，实际上，如果您突然遇到高流量并希望提高服务器性能，可以选择 Memcached 或数据库缓存，具体取决于服务器上可用的选项。另一方面，如果您有一个中高流量的网站，我强烈建议您使用
    Memcached，因为它绝对是 Django 可用的最快的缓存解决方案。本节中提供的信息无论您选择哪种缓存后端都是一样的。
- en: 'So, decide on a caching backend and insert the corresponding `CACHE_BACKEND`
    variable in the `settings.py` file. Next, you should specify the expiration duration
    of cached pages in seconds. Add the following to the `settings.py` file to cache
    pages for five minutes:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，决定一个缓存后端，并在 `settings.py` 文件中插入相应的 `CACHE_BACKEND` 变量。接下来，您应该指定缓存页面的过期持续时间（以秒为单位）。在
    `settings.py` 文件中添加以下内容，以便将页面缓存五分钟：
- en: '[PRE38]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, we are done with enabling the caching system. Continue reading to learn
    how to utilize caching to improve the performance of your application.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了启用缓存系统。继续阅读，了解如何利用缓存来提高应用程序的性能。
- en: Configuring caching
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置缓存
- en: You can configure Django to cache your whole site or specific views. We will
    learn how to do both in this subsection.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以配置 Django 缓存整个站点或特定视图。我们将在本小节中学习如何做到这两点。
- en: Caching the whole site
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存整个站点
- en: 'To cache your whole site, add the `CacheMiddleware` class to your `MIDDLEWARE_CLASSES`
    class in the `settings.py` file:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要缓存整个网站，请将`CacheMiddleware`类添加到`settings.py`文件中的`MIDDLEWARE_CLASSES`类中：
- en: '[PRE39]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Order matters here as it did when we added the locale middleware. The caching
    middleware class should be added after the session and authentication middleware
    classes and before the locale middleware class.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里顺序很重要，就像我们添加区域设置中间件时一样。缓存中间件类应该在会话和身份验证中间件类之后添加，在区域设置中间件类之前添加。
- en: This is all that you need to cache your Django site. From now on, whenever a
    page is requested, Django will store the generated HTML and reuse it later. It's
    important to realize that the caching system only caches pages that do not have
    `GET` and `POST` variables. So, our users will still be able to post tweets and
    follow friends because the views of these pages expect GET or POST variables.
    On the other hand, pages such as tweets and hashtag listings will be cached.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您需要缓存Django网站的全部内容。从现在开始，每当请求页面时，Django都会存储生成的HTML并在以后重复使用。重要的是要意识到，缓存系统只缓存没有`GET`和`POST`变量的页面。因此，我们的用户仍然可以发布推文和关注朋友，因为这些页面的视图期望GET或POST变量。另一方面，推文和标签列表等页面将被缓存。
- en: Caching specific views
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存特定视图
- en: Sometimes, you will want to cache only specific pages of your website—perhaps
    a high-traffic site linked to a page of yours, so that most of the traffic will
    be directed to this particular page. In this case, it would make sense to cache
    this page only. Another good candidate for caching is a page that is expensive
    to generate, so you would only want it to be generated once every five minutes
    or so. The tag cloud page in our application fits the latter case. Every time
    the page is requested, Django iterates through all the tags in the database and
    counts the number of tweets for each tag. This is an expensive operation because
    it requires a large number of database queries. Therefore, caching this view is
    a good idea.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能只想缓存网站的特定页面-可能是一个与您的页面链接的高流量网站，因此大部分流量将被引导到这个特定页面。在这种情况下，只缓存此页面是有意义的。另一个适合缓存的好候选者是生成成本高昂的页面，因此您只希望每五分钟生成一次。我们应用程序中的标签云页面符合后一种情况。每次请求页面时，Django都会遍历数据库中的所有标签，并计算每个标签的推文数量。这是一个昂贵的操作，因为它需要大量的数据库查询。因此，缓存这个视图是一个好主意。
- en: 'To cache the view based on the hashtag class, you simply apply a method called
    `cache_page` and the caching parameter with it. Try this by editing the `mytweets/urls.py`
    file as highlighted in the following code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要根据标签类缓存视图，只需应用一个名为`cache_page`的方法和与之相关的缓存参数。通过编辑`mytweets/urls.py`文件中的以下代码来尝试这一点：
- en: '[PRE40]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Using the `cache_page()` method is straightforward. It lets you specify which
    views to cache. The rules mentioned in site caching also apply to view caching.
    If the view receives GET or POST parameters, Django won't cache it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`cache_page()`方法很简单。它允许您指定要缓存的视图。站点缓存中提到的规则也适用于视图缓存。如果视图接收GET或POST参数，Django将不会对其进行缓存。
- en: With this information, we finish this section. Caching won't be necessary when
    you first release your website to the public. However, when your website grows,
    or if you suddenly receive a surge of high traffic, the caching system will certainly
    become handy. So, keep it in mind while monitoring the performance of your application.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息，我们完成了本节。当您首次将网站发布到公众时，缓存是不必要的。然而，当您的网站增长，或者突然接收到大量高流量时，缓存系统肯定会派上用场。因此，在监视应用程序性能时要牢记这一点。
- en: Next, we are going to learn about the Django testing framework. Testing can
    sometimes be a tedious task. Wouldn't it be great if you could run a single command
    and it took care of testing your site? Django lets you do this, and we will learn
    about it in the next section.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习Django测试框架。测试有时可能是一项乏味的任务。如果您可以运行一个命令来处理测试您的网站，那不是很好吗？Django允许您这样做，我们将在下一节中学习。
- en: 'Template fragments can be cached in the following manner:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 模板片段可以以以下方式进行缓存：
- en: '[PRE41]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Unit testing – automating the process of testing your application
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试-自动化测试应用程序的过程
- en: During the course of this book, we sometimes modified a view that we wrote previously.
    This actually happens quite often while developing software. One may modify or
    even rewrite a function to change the implementation details, because the requirements
    have changed, or simply to refactor the code and make it more readable.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的过程中，我们有时修改了先前编写的视图。这在软件开发过程中经常发生。一个人可能会修改甚至重写一个函数来改变实现细节，因为需求已经改变，或者只是为了重构代码，使其更易读。
- en: When you modify a function, you have to test it again to make sure that your
    changes didn't introduce bugs. However, testing will become a boring task if you
    have to repeat the same tests over and over every time you modify a function.
    You may also forget to test all aspects of the function if they are not well documented.
    Clearly, this is not an ideal situation; we definitely need a better mechanism
    to handle testing.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当您修改一个函数时，您必须再次测试它，以确保您的更改没有引入错误。然而，如果您不断重复相同的测试，测试将变得乏味。如果函数的各个方面没有很好地记录，您可能会忘记测试所有方面。显然，这不是一个理想的情况；我们绝对需要一个更好的机制来处理测试。
- en: Fortunately, a solution already exists for this. It is called unit testing.
    The idea is that you write code to test your code. The testing code calls your
    functions and verifies that they behave as expected and then prints a report of
    the results. You only have to write the testing code once. Later, whenever you
    want to test, you can simply run the testing code and examine the resulting report.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，已经有了一个解决方案。它被称为单元测试。其思想是编写代码来测试您的代码。测试代码调用您的函数并验证它们的行为是否符合预期，然后打印出结果报告。您只需要编写一次测试代码。以后，每当您想要测试时，只需运行测试代码并检查生成的报告即可。
- en: Python comes with a framework for unit testing. It is located in the unit test
    module. Django extends this framework to add support for view testing. We will
    learn how to use the Django unit testing framework in this section.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Python自带了一个用于单元测试的框架。它位于单元测试模块中。Django扩展了这个框架，以添加对视图测试的支持。我们将在本节中学习如何使用Django单元测试框架。
- en: The test client
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试客户端
- en: 'In order to interact with views, Django provides a class that emulates browser
    functionality. You can use it to send requests to your application and receive
    the responses. Let''s learn about it using the interactive console. Launch the
    console using this command:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与视图交互，Django提供了一个模拟浏览器功能的类。您可以使用它向应用程序发送请求并接收响应。让我们使用交互式控制台来学习。使用以下命令启动控制台：
- en: '[PRE42]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Import the `Client()` class, create a `Client` object, and retrieve the homepage
    of the application using a GET request:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 导入`Client()`类，创建一个`Client`对象，并使用GET请求检索应用程序的主页：
- en: '[PRE43]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Try to send a POST request to the login view. The output will vary depending
    on whether you provide correct credentials or not:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试向登录视图发送POST请求。输出将根据您是否提供正确的凭据而有所不同：
- en: '[PRE44]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, if there is a view that is restricted only to the users that are logged
    in, you can send a request to it like this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果有一个只允许已登录用户访问的视图，您可以像这样发送一个请求：
- en: '[PRE45]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As you can see from the interactive session, the `Client()` class provides
    three methods:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从交互式会话中看到的，`Client()`类提供了三种方法：
- en: '`get`: This method sends a GET request to a view. It takes the URL of the view
    as a parameter. You can pass an optional dictionary of GET variables to this method.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get`：这个方法向视图发送一个GET请求。它将视图的URL作为参数。您可以向该方法传递一个可选的GET变量字典。'
- en: '`post`: This method sends sends a POST request to a view. It takes the URL
    of the view and a dictionary of POST variables as parameters.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post`：这个方法向视图发送一个POST请求。它将视图的URL和一个POST变量字典作为参数。'
- en: '`login`: This method sends a GET request to a view that is restricted to logged
    in users only. It takes the URL of the view, a username, and password as parameters.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`login`：这个方法向一个只允许已登录用户访问的视图发送一个GET请求。它将视图的URL、用户名和密码作为参数。'
- en: 'The `Client()` class is stateful, which means that it retains its state across
    requests. Once you log in, later requests will be handled while you are logged
    in. The response object returned by the `Client()` class''s methods contains the
    following attributes:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`Client()`类是有状态的，这意味着它在请求之间保留其状态。一旦您登录，后续的请求将在您登录的状态下处理。`Client()`类的方法返回的响应对象包含以下属性：'
- en: '`status_code`: This is the HTTP status of the response'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status_code`：这是响应的HTTP状态'
- en: '`content`: This is the body of the response page'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content`：这是响应页面的主体'
- en: '`template`: This is the `Template` instance used to render the page; if multiple
    templates were used, this attribute would be a list of Template objects'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template`：这是用于渲染页面的`Template`实例；如果使用了多个模板，这个属性将是一个`Template`对象的列表'
- en: '`context` : This is the `Context` object used to render the template'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context`：这是用于渲染模板的`Context`对象'
- en: These fields are useful to check whether the test succeeded or failed, as we
    will see next. Feel free to experiment more with the `Client()` class. It's important
    to understand how it works before you continue to the next subsection, where we
    will create the first unit test.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字段对于检查测试是否成功或失败非常有用，接下来我们将看到。请随意尝试更多`Client()`类的用法。在继续下一小节之前，了解它的工作原理是很重要的，我们将在下一小节中创建第一个单元测试。
- en: Testing the registration view
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试注册视图
- en: 'Now that you are comfortable with the `Client()` class, let''s write our first
    test. Unit tests should reside in a module named `tests.py` inside the application
    folder. Each test should be a method in a class derived from the `django.test.TestCase`
    module. The name of the method must start with the word test. With this in mind,
    we will write a test method that tries to register a new user account. So, create
    a file named `tests.py` inside the `bookmarks` folder and type the following content
    in it:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对`Client()`类感到满意了，让我们编写我们的第一个测试。单元测试应该位于应用程序文件夹内名为`tests.py`的模块中。每个测试应该是从`django.test.TestCase`模块派生的类中的一个方法。方法的名称必须以单词test开头。有了这个想法，我们将编写一个测试方法，试图注册一个新的用户帐户。因此，在`bookmarks`文件夹内创建一个名为`tests.py`的文件，并在其中输入以下内容：
- en: '[PRE46]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let''s go through the code line by line:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行查看代码：
- en: First, we imported the `TestCase` and `Client` classes.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们导入了`TestCase`和`Client`类。
- en: Next, we defined a class called `ViewTest()`, which is derived from the `TestCase`
    class. As I said earlier, all test classes must be derived from this base class.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一个名为`ViewTest()`的类，它是从`TestCase`类派生的。正如我之前所说，所有测试类都必须从这个基类派生。
- en: After that, we defined a method called `setUp()`. This method is called when
    the testing process starts. Here, we created a `Client` object.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，我们定义了一个名为`setUp()`的方法。当测试过程开始时，将调用这个方法。在这里，我们创建了一个`Client`对象。
- en: Finally, we defined a method called `test_register_page`. The name of the method
    starts with the word test, indicating that it is a test method. The method sends
    a POST request to the registration view and checks the status code for equality
    with the number `302`. This number is the HTTP status for a redirect.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们定义了一个名为`test_register_page`的方法。方法的名称以单词test开头，表示它是一个测试方法。该方法向注册视图发送一个POST请求，并检查状态码是否等于数字`302`。这个数字是重定向的HTTP状态。
- en: If you recall from a previous chapter, the registration view redirects the user
    if the request succeeds.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您回忆一下前面的章节，注册视图在请求成功时会重定向用户。
- en: We checked the response object using a method called `assertEqual()`. This method
    is inherited from the `TestCase` class. It raises an exception if the two passed
    arguments are not equal. If an exception is raised, the testing framework knows
    that the test failed; otherwise, if no exception is raised, it assumes that the
    test succeeded.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个名为`assertEqual()`的方法来检查响应对象。这个方法是从`TestCase`类继承的。如果两个传递的参数不相等，它会引发一个异常。如果引发了异常，测试框架就知道测试失败了；否则，如果没有引发异常，它就认为测试成功了。
- en: 'The `TestCase` class provides a set of methods to be used in testing. Here
    is a list of the important ones:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestCase`类提供了一组方法供测试使用。以下是一些重要的方法列表：'
- en: '`assertEqual`: This expects two values to be equal'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertEqual`：这期望两个值相等'
- en: '`assertNotEquals`: This expects two values to be unequal'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertNotEquals`：这期望两个值不相等'
- en: '`assertTrue`: This expects a value to be `True`'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertTrue`：这期望一个值为`True`'
- en: '`assertFalse`: This expects a value to be `False`'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertFalse`：这期望一个值为`False`'
- en: 'Now that you understand the test class, let''s run the actual test by issuing
    the command:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您了解了测试类，让我们通过发出命令来运行实际测试：
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The output will be similar to the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于以下内容：
- en: '[PRE48]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: So, what has happened here? The testing framework starts by creating a test
    database with tables similar to those in the real database. Next, it runs the
    tests found in the tests module. Finally, it prints a report of the results and
    destroys the test database.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这里发生了什么？测试框架首先通过创建一个类似于真实数据库中的表的测试数据库来开始。接下来，它运行在测试模块中找到的测试。最后，它打印出结果的报告并销毁测试数据库。
- en: 'Here, our single test succeeded. To see what the output would be like if the
    test fails, modify the `test_register_page` view in the `tests.py` file by removing
    a required form field:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的单个测试成功了。如果测试失败，输出会是什么样子，请修改`tests.py`文件中的`test_register_page`视图，删除一个必需的表单字段：
- en: '[PRE49]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, run the `python manage.py test` command again to see the results:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次运行`python manage.py test`命令以查看结果：
- en: '[PRE50]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Our test is working! Django detected an error and gave us the exact details
    of what happened. Don't forget to return the test to its original form once you're
    done. Now, let's write another test, a slightly more advanced one, to understand
    the testing framework better.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试有效！Django检测到错误并给了我们发生的确切细节。完成后不要忘记将测试恢复到原始形式。现在，让我们编写另一个测试，一个稍微更高级的测试，以更好地了解测试框架。
- en: 'There are many other scenarios for which you can write unit tests:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他情景可以编写单元测试：
- en: Checking whether registration fails if the two password fields do not match
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查注册是否失败，如果两个密码字段不匹配
- en: Testing the "add friend" and "invite friend" views
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试“添加朋友”和“邀请朋友”视图
- en: Testing the "edit bookmark" functionality
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试“编辑书签”功能
- en: Testing that a search returns correct results
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试搜索返回正确结果
- en: The preceding list shows just examples. Writing unit tests to cover as many
    use cases as possible is important to maintain a healthy application and to minimize
    bugs and regressions. The more unit tests you write, the more confident you can
    be when your application passes all the tests. Django makes it extremely easy
    to unit test your application, so make use of this fact.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的列表只是一些例子。编写单元测试以覆盖尽可能多的用例对于保持应用程序的健康和减少错误和回归非常重要。你编写的单元测试越多，当你的应用程序通过所有测试时，你就越有信心。Django使单元测试变得非常容易，所以要充分利用这一点。
- en: At some point in the application's life, it will move from the development mode
    to production. The next section explains how to prepare your Django project for
    a production environment.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的生命周期中的某个时刻，它将从开发模式转移到生产模式。下一节将解释如何为生产环境准备您的Django项目。
- en: Deploying Django
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署Django
- en: So, you have done a lot of work on your web application, and now it is the time
    to go live. To make sure that the transition from development to production goes
    smoothly, there are a number of changes that must be made to the application before
    it goes live. This section covers these changes to help make the launch of your
    web application successful.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你在你的Web应用程序上做了很多工作，现在是时候上线了。为了确保从开发到生产的过渡顺利进行，必须在应用程序上线之前进行一些更改。本节涵盖了这些更改，以帮助您成功上线您的Web应用程序。
- en: The production web server
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生产Web服务器
- en: We have been using the development web server that comes with Django throughout
    this book. While this server is perfect for the development process, it's definitely
    not intended to be a production web server, as it wasn't developed with security
    or performance in mind. Therefore, it is certainly not suitable for production.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们一直在使用Django自带的开发Web服务器。虽然这个服务器非常适合开发过程，但绝对不适合作为生产Web服务器，因为它并没有考虑安全性或性能。因此，它绝对不适合生产环境。
- en: There are several options to choose from when it comes to a web server, but
    **Apache** is by far the most popular choice, and the Django development team
    actually recommends it. The details of how to set up Django with Apache depends
    on your hosting solution. Some hosting plans offer preconfigured Django hosting,
    where you only have to copy your project files to the server, whereas other hosting
    plans give you the freedom to configure everything yourself.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择Web服务器时，有几个选项可供选择，但**Apache**是迄今为止最受欢迎的选择，Django开发团队实际上也推荐使用它。如何在Apache上设置Django的详细信息取决于您的托管解决方案。一些托管计划提供预配置的Django托管，您只需将项目文件复制到服务器上，而其他托管计划则允许您自己配置一切。
- en: The details of setting up Apache can vary depending on a number of factors and
    are beyond the scope of this book. If you end up having to configure Apache yourself,
    consult the Django documentation at [http://www.djangoproject.com/documentation/apache_auth/](http://www.djangoproject.com/documentation/apache_auth/)
    for detailed instructions.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 设置Apache的详细信息可能会因多种因素而有所不同，超出了本书的范围。如果最终需要自己配置Apache，请参考Django文档[http://www.djangoproject.com/documentation/apache_auth/](http://www.djangoproject.com/documentation/apache_auth/)以获取详细说明。
- en: Summary
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter covered a variety of interesting topics. We developed an important
    set of features for our project in this chapter. A follower's networks are very
    important to help users socialize and share interests together. We learned about
    several Django frameworks that are useful while deploying Django. We also learned
    how to move a Django project from a development to a production environment. Notably,
    the frameworks that we learned about are all very easy to use, so you will be
    able to effectively utilize them in your future projects. These features are common
    in web 2.0 applications, and, now, you will be able to incorporate them in any
    Django website.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了各种有趣的主题。在本章中，我们为项目开发了一组重要的功能。追随者的网络对于帮助用户社交和共享兴趣非常重要。我们了解了几个在部署Django时有用的Django框架。我们还学会了如何将Django项目从开发环境迁移到生产环境。值得注意的是，我们学到的这些框架都非常易于使用，因此您将能够在未来的项目中有效地利用它们。这些功能在Web
    2.0应用程序中很常见，现在，您将能够将它们整合到任何Django网站中。
- en: In the next chapter, we will learn about improving various aspects of our application,
    mainly performance and localization. We will also learn how to deploy our project
    on a production server. The next chapter comes with a lot of useful information,
    so read on!
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何改进应用程序的各个方面，主要是性能和本地化。我们还将学习如何在生产服务器上部署我们的项目。下一章将提供大量有用的信息，所以请继续阅读！
