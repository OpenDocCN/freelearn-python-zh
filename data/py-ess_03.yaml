- en: Chapter 3. Expressions and Output
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。表达式和输出
- en: Expressions are central to Python programming. As noted in [Chapter 1](ch01.html
    "Chapter 1. Getting Started"), *Getting Started*, Python has a rich collection
    of operators and built-in functions. In this chapter, we'll summarize the relationship
    between data types and the operators they support.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式是Python编程的核心。正如[第1章](ch01.html "第1章。入门")，*入门*中所述，Python拥有丰富的运算符和内置函数集合。在本章中，我们将总结数据类型及其支持的运算符之间的关系。
- en: Perhaps the most fundamental program possible is one that performs a calculation
    and displays output. To demonstrate this, we'll look at the `print()` function
    in this chapter. We'll expand on the basics by looking at a number of ways to
    produce nicely-formatted text output.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最基础的程序就是执行计算并显示输出的程序。为了演示这一点，我们将在本章中探讨`print()`函数。我们将通过探讨多种生成格式化文本输出的方式来扩展基础知识。
- en: We'll need to look in detail at the Python syntax rules. This will be essential
    for writing scripts with more complex sequences of statements. It will also set
    the stage for looking at compound statements in [Chapter 5](ch05.html "Chapter 5. Logic,
    Comparisons, and Conditions"), *Logic, Comparisons, and Conditions*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要详细研究Python的语法规则。这对于编写包含更复杂语句序列的脚本至关重要。这将为在[第5章](ch05.html "第5章。逻辑、比较和条件")，*逻辑、比较和条件*中探讨复合语句奠定基础。
- en: This chapter will also demonstrate some additional string processing techniques.
    We'll summarize some of the standard library modules that are focused on string
    processing. We'll look closely at the `re` module; we use this to build regular
    expressions that help parse string input. Between the built-in methods of the
    `str` class, and the `re` module, we can handle a wide variety of text input conversion.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还将演示一些额外的字符串处理技术。我们将总结一些专注于字符串处理的标准库模块。我们将仔细研究`re`模块；我们使用这个模块来构建正则表达式，帮助解析字符串输入。在`str`类的内置方法和`re`模块之间，我们可以处理各种文本输入转换。
- en: Expressions, operators, and data types
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式、运算符和数据类型
- en: Python expressions are built from operators and operands. In [Chapter 2](ch02.html
    "Chapter 2. Simple Data Types"), *Simple Data Types*, we introduced some of the
    basics of number and string operands, and looked at the variety of operators.
    We'll summarize the details here so that we can address some additional operator
    features.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Python表达式由运算符和操作数构成。在[第2章](ch02.html "第2章。简单数据类型")，*简单数据类型*中，我们介绍了数值和字符串操作数的一些基础知识，并探讨了各种运算符。我们在这里总结这些细节，以便我们可以讨论一些额外的运算符特性。
- en: 'Our numeric operands form a "tower", with types including:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数值操作数构成一个“塔”，包括以下类型：
- en: '| Type | Cardinality | Number of operators |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 卡氏数 | 运算符数量 |'
- en: '| --- | --- | --- |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `complex` | Ideally, the most distinct values built from a pair of irrational
    numbers, ∞×∞.Actually (`float` × `float`) or about ![Expressions, operators, and
    data types](img/B03671_03_01.jpg) values. | The fewest operators; only arithmetic,
    some built-in functions, and the `cmath` module. |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| `complex` | 理想情况下，由一对无理数构成的最独特值，∞×∞。实际上（`float` × `float`）或大约![表达式、运算符和数据类型](img/B03671_03_01.jpg)的值。
    | 最少的运算符；只有算术运算、一些内置函数和`cmath`模块。 |'
- en: '| `float` | Ideally this is a rational number union with irrational numbers
    (∞+∞).Actually closer to ![Expressions, operators, and data types](img/B03671_03_02.jpg)
    distinct values. | Arithmetic operators, comparisons. Many additional `math` modules
    and built-in functions. |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| `float` | 理想情况下这是有理数与无理数的并集（∞+∞）。实际上更接近![表达式、运算符和数据类型](img/B03671_03_02.jpg)不同的值。
    | 算术运算符、比较。许多额外的`math`模块和内置函数。 |'
- en: '| `fractions.Fraction` | Ideally, these are rational numbers (∞×∞).Actually
    only limited by available memory to represent two integers. | Arithmetic operators,
    comparisons, built-in functions. |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| `fractions.Fraction` | 理想情况下，这些是有理数（∞×∞）。实际上仅受可用内存限制，以表示两个整数。 | 算术运算符、比较、内置函数。
    |'
- en: '| `decimal.Decimal` | Ideally, rational numbers.Actually only limited by memory
    | Arithmetic operators, comparisons, built-in functions. |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `decimal.Decimal` | 理想情况下，有理数。实际上仅受内存限制。 | 算术运算符、比较、内置函数。 |'
- en: '| `int` | Ideally, natural numbers, ∞.Actually limited only by memory. | Arithmetic
    operators, comparisons, plus bit-handling operators, libraries and built-in functions.
    |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `int` | 理想情况下，自然数，∞。实际上仅受内存限制。 | 算术运算符、比较、位操作运算符、库和内置函数。 |'
- en: The `Fraction` and `Decimal` class definitions must be imported, the other three
    classes are built-in. We typically use a statement such as `from fractions import
    Fraction`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 必须导入`Fraction`和`Decimal`类的定义，其他三个类是内置的。我们通常使用如下语句：`from fractions import Fraction`。
- en: The idea behind the tower is that many arithmetic operators coerce operands
    up the tower from integer to float to complex. Most of the time, this fits with
    our implicit mathematical expectations. We would be unhappy if we had to write
    explicit conversions to compute `2.333*3`. Python's arithmetic rules assure us
    that we'll get the expected floating-point result.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 塔背后的想法是许多算术运算符会将操作数从整数强制转换为浮点数，再到复数。大多数时候，这符合我们隐含的数学期望。如果我们不得不编写显式转换来计算`2.333*3`，我们会感到不高兴。Python的算术规则确保我们会得到预期的浮点数结果。
- en: 'The `Decimal` class doesn''t fit well with the implicit coercion rules: in
    the rare case of trying to do arithmetic between `float` and `Decimal`, it''s
    unclear how to go about it. An attempt to make a `Decimal` value from a `float`
    value will expose tiny errors because `float` values are an approximation. An
    attempt to make a `float` value from a `Decimal` value subverts the `Decimal`
    objective of yielding exact results. In the face of this ambiguity, an exception
    will be raised. This means that we''ll need to write explicit conversions.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`Decimal`类与隐式转换规则不太匹配：在尝试在`float`和`Decimal`之间进行算术运算的罕见情况下，不清楚如何进行。尝试从一个`float`值创建一个`Decimal`值会暴露出微小的错误，因为`float`值是近似值。尝试从一个`Decimal`值创建一个`float`值会违背`Decimal`的目标，即产生精确结果。面对这种歧义，将引发异常。这意味着我们需要编写显式转换。'
- en: String objects are not implicitly coerced into numeric values. We must explicitly
    convert a string to a number. The `int()`, `float()`, `complex()`, `Fraction()`,
    and `Decimal()` functions convert a string to a number object of the appropriate
    class.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串对象不会隐式地转换为数值。我们必须显式地将字符串转换为数字。`int()`、`float()`、`complex()`、`Fraction()`和`Decimal()`函数将字符串转换为适当类的数字对象。
- en: We can group operators into a number of categories.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将运算符分组到几个类别中。
- en: '**Arithmetic**: `+`, `-`, `*`, `**`, `/`, `//`, `%`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**算术**：`+`、`-`、`*`、`**`、`/`、`//`、`%`'
- en: '**Bit-oriented**: `<<`, `>>`, `&`, `|`, `^`, `~`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位运算**：`<<`、`>>`、`&`、`|`、`^`、`~`'
- en: '**Comparison**: `<`, `>`, `<=`, `>=`, `==`, `!=`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**比较**：`<`、`>`、`<=`、`>=`、`==`、`!=`'
- en: The bit-oriented operators are supported by operands of the `int` class. The
    other number classes don't have useful implementations of these operators. The
    bit-oriented operators are also defined for sets, something we'll look at in [Chapter
    6](ch06.html "Chapter 6. More Complex Data Types"), *More Complex Data Types*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 位运算符由`int`类的操作数支持。其他数字类没有这些运算符的有用实现。位运算符也定义在集合上，我们将在[第6章](ch06.html "第6章。更复杂的数据类型")中探讨，*更复杂的数据类型*。
- en: Using operators on non-numeric data
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在非数值数据上使用运算符
- en: 'We can apply some of the arithmetic operators to strings, bytes, and tuples.
    The results are focused on creating larger strings or larger tuples from smaller
    pieces. Here are some examples of this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将一些算术运算符应用于字符串、字节和元组。结果主要集中在从较小的部分创建更大的字符串或更大的元组。以下是一些示例：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the first example, we applied `+` to two strings. In the second example,
    we applied `*` between a `str` and an `int`. Interestingly, Python produces a
    string result by concatenating several copies of the original string object. Multiplying
    by any negative number creates a zero-length string.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，我们将`+`应用于两个字符串。在第二个例子中，我们在`str`和`int`之间应用了`*`。有趣的是，Python通过连接几个副本的原始字符串对象来产生一个字符串结果。乘以任何负数会创建一个零长度的字符串。
- en: The print() function
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`print()`函数'
- en: When working with Python's REPL, we can enter an expression and Python prints
    the result. In other contexts, we must use the `print()` function to see results.
    The `print()` function implicitly writes to `sys.stdout`, so the results will
    be visible on the console where we ran the Python script.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Python的交互式解释器（REPL）时，我们可以输入一个表达式，Python会打印出结果。在其他上下文中，我们必须使用`print()`函数来查看结果。`print()`函数隐式地写入`sys.stdout`，因此结果将出现在我们运行Python脚本的控制台上。
- en: 'We can provide any number of expressions to the `print()` function. Each value
    is converted to a string using the `repr()` function. The strings are combined
    with a default separator of `'' ''` and printed with a default line ending of
    `''\n''`. We can change the separator and line ending characters. Here are some
    examples of this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向`print()`函数提供任意数量的表达式。每个值都会使用`repr()`函数转换为字符串。这些字符串会使用默认的分隔符`' '`组合，并以默认的行结束符`'\n'`打印。我们可以更改分隔符和行结束字符。以下是一些示例：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We've printed a string and the floating-point result of an expression. In the
    second example, we changed the separator string from a space to `'='`. In the
    third example, we changed the separator string to `'='` and the end-of-line string
    to `'!\n'`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打印了一个字符串和一个表达式的浮点结果。在第二个示例中，我们将分隔符字符串从空格更改为`'='`。在第三个示例中，我们将分隔符字符串更改为`'='`，并将行结束字符串更改为`'!\n'`。
- en: Note that the `sep` and `end` parameters must be provided by name; these are
    called **keyword arguments**. Python syntax rules require that keyword argument
    values are provided after all of the positional arguments. We'll examine the rules
    in detail in [Chapter 7](ch07.html "Chapter 7. Basic Function Definitions"), *Basic
    Function Definitions*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，必须按名称提供`sep`和`end`参数；这些被称为**关键字参数**。Python语法规则要求关键字参数值在所有位置参数之后提供。我们将在[第7章](ch07.html
    "第7章。基本函数定义")中详细检查这些规则，*基本函数定义*。
- en: We can use `,` as a separator to create simple **comma-separated values** (**CSV**)
    files. We can also use `\t` to create a kind of CSV file with a tab character
    as the column separator. The `csv` library module does an even more complete job
    of CSV formatting, specifically including proper escapes or quoting for data items
    which contain the separator character.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`,`作为分隔符来创建简单的**逗号分隔值**（CSV）文件。我们也可以使用`\t`来创建一种以制表符作为列分隔符的CSV文件。`csv`库模块在CSV格式化方面做得更加完善，特别是对于包含分隔符字符的数据项，它提供了适当的转义或引号。
- en: 'To write to the standard error file, we''ll need to import the `sys` module,
    where that object is defined. For example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要写入标准错误文件，我们需要导入`sys`模块，其中定义了该对象。例如：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We've imported the `sys` module. This contains definitions of `sys.stderr` and
    `sys.stdout` for the standard output files. By using the `file=` keyword parameter,
    we can direct a specific line of output to the `stderr` file instead of the default
    of `stdout`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经导入了`sys`模块。这个模块包含了`sys.stderr`和`sys.stdout`的定义，用于标准输出文件。通过使用`file=`关键字参数，我们可以将特定的输出行定向到`stderr`文件，而不是默认的`stdout`。
- en: This can work well in a script file. Using the standard error file doesn't look
    very interesting at the REPL prompt since, by default, both standard output and
    standard error go to the console. Some IDE's will color-code the standard error
    output. We'll look at many ways to open and write to other files in [Chapter 10](ch10.html
    "Chapter 10. Files, Databases, Networks, and Contexts"), *Files, Databases, Networks,
    and Contexts*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这在脚本文件中可以很好地工作。在REPL提示符中使用标准错误文件看起来并不有趣，因为默认情况下，标准输出和标准错误都输出到控制台。一些IDE会为标准错误输出着色。我们将在[第10章](ch10.html
    "第10章。文件、数据库、网络和上下文")中查看许多打开和写入其他文件的方法，*文件、数据库、网络和上下文*。
- en: Examining syntax rules
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查语法规则
- en: 'There are nine fundamental syntax rules in section 2.1 of the *Python Language
    Reference*. We''ll summarize those rules here:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Python语言参考*的2.1节中有九条基本的语法规则。我们在这里总结这些规则：
- en: 'There are two species of statements: simple and compound. Simple statements
    must be complete on a single logical line. A compound statement starts with a
    single logical line and must contain indented statements. The initial clause of
    a compound statement ends with a `:` character. It''s possible, using rules 5
    and 6, to join a number of physical lines together to create a single logical
    line.'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有两种语句类型：简单和复合。简单语句必须在单个逻辑行中完整。复合语句以单个逻辑行开始，必须包含缩进的语句。复合语句的初始子句以冒号`:`字符结束。通过使用规则5和6，可以将多个物理行合并为一个逻辑行。
- en: 'Here''s a typical simple statement, complete in a single logical line:'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里是一个典型的简单语句，完整地位于一个逻辑行中：
- en: '[PRE3]'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here''s a typical compound statement with a nested simple statement, spread
    across two logical lines:'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里是一个典型的复合语句，包含嵌套的简单语句，跨越两个逻辑行：
- en: '[PRE4]'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A **physical line** ends with `\n`. In Windows, `\r\n` is also accepted.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**物理行**以`\n`结尾。在Windows中，`\r\n`也被接受。'
- en: A **comment** starts with `#` and continues to the end of the physical line.
    It will end the logical line.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**注释**以`#`开头，并持续到物理行的末尾。它将结束逻辑行。'
- en: 'Here''s an example of a comment:'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里是一个注释的示例：
- en: '[PRE5]'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A special comment can be used to annotate the file encoding. This is generally
    not needed, since most IDE's and text editors handle the file encoding politely.
    We should generally save Python files in UTF-8 encoding. Older files may be saved
    in ASCII.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用特殊的注释来注释文件编码。这通常不是必需的，因为大多数IDE和文本编辑器都会礼貌地处理文件编码。我们应该通常以UTF-8编码保存Python文件。较旧的文件可能保存为ASCII。
- en: Physical lines can be joined explicitly into a logical line using the `\` as
    an escape character in front of the physical end-of-line character. This is rarely
    used and generally discouraged.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 物理行可以通过在物理行结束字符前的`\`作为转义字符显式地合并为一个逻辑行。这很少使用，并且通常不推荐使用。
- en: Physical lines can be joined implicitly into a logical line using `()`, `[]`,
    or `{}`; these must pair properly for the logical line to be complete. An expression
    beginning with `(` can span multiple physical lines until there is a matching
    `)`. This is used frequently and is strongly encouraged.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 物理行可以使用`()`、`[]`或`{}`隐式地合并为一个逻辑行；这些必须正确配对，逻辑行才能完整。以`(`开头的表达式可以跨越多个物理行，直到出现匹配的`)`。这被频繁使用，并且被强烈推荐。
- en: 'Here''s an example of a statement that relies on `()` to join four physical
    lines into one logical line:'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里是一个依赖于`()`将四行物理行合并为一条逻辑行的语句示例：
- en: '[PRE6]'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Blank lines contain only spaces, tabs and newlines. The interactive REPL uses
    a blank line to end a compound statement; the REPL is the only context in which
    a blank line is meaningful.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 空行只包含空格、制表符和换行符。交互式REPL使用空行来结束复合语句；REPL是唯一有意义的空白行上下文。
- en: Leading whitespace is **required** to properly group statements inside the clauses
    of compound statements. Either spaces or tabs can be used to indent. Consistency
    is essential. A four space indent is widely used and strongly encouraged.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在复合语句的子句内部正确地分组语句需要**前置空白**。可以使用空格或制表符进行缩进。一致性是必要的。四个空格的缩进被广泛使用，并且强烈推荐。
- en: Except at the beginning of the line,—where it determines nesting of compound
    statements—whitespace can be used freely between tokens. Note that there are some
    preferences regarding precisely how spaces are used within a statement; the **Python
    Enhancement Proposal** (**PEP**) number 8 provides some advice. See [https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/)
    for fodder for endless disputes.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了行首——它决定了复合语句的嵌套——可以在标记之间自由使用空白。注意，关于在语句中精确使用空格有一些偏好；**Python增强提案**（**PEP**）编号8提供了一些建议。参见[https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/)以获取无休止争论的素材。
- en: Perhaps the most important two rules are rule 6 and rule 8\. Rule 6 means that
    it is very common to use `()`, `[]`, and `{}` to force multiple physical lines
    to be joined into a single logical line.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最重要的两条规则是规则6和规则8。规则6意味着非常常见地使用`()`、`[]`和`{}`来强制将多个物理行合并为一条逻辑行。
- en: 'Rule 8 requires that our indentation is done consistently: indents and outdents
    must be matched. While it''s legal to use tabs, spaces, and any haphazard—but
    consistent—mix of tabs and spaces, four spaces is highly recommended. Tabs are
    discouraged because they''re hard to distinguish from spaces. Most editors can
    be set to replace the tab key with four spaces. A good text editor can recognize
    the basics of Python syntax and can handle indents and outdents gracefully.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 规则8要求我们的缩进保持一致：缩进和缩出必须匹配。虽然可以使用制表符、空格以及任何一致但随意的制表符和空格的混合，但四个空格被高度推荐。制表符不被推荐，因为它们难以与空格区分。大多数编辑器都可以设置为将制表符键替换为四个空格。一个好的文本编辑器可以识别Python语法的基础知识，并且可以优雅地处理缩进和缩出。
- en: Tip
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Use `()` to allow a statement to span multiple physical lines; avoid `\` at
    end-of-line.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`()`允许一个语句跨越多个物理行；避免在行尾使用`\`。
- en: Use a four space indent.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用四个空格的缩进。
- en: 'Also note that Python will merge adjacent strings when parsing the source.
    We can have code that looks like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，Python在解析源代码时会合并相邻的字符串。我们可以有如下代码：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This assignment statement used a gratuitous `()` pair to allow the logical line
    to span multiple physical lines. The expression is simply two adjacent strings,
    `"Hello"` and `"world"`. When Python parses the source text, these two adjacent
    strings are merged; only a single string is used when evaluating the statement.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个赋值语句使用了一个不必要的`()`对，允许逻辑行跨越多个物理行。表达式仅仅是两个相邻的字符串，`"Hello"`和`"world"`。当Python解析源文本时，这两个相邻的字符串会被合并；在评估语句时只使用一个字符串。
- en: Additionally, note that the REPL prompt changed from `>>>` to … because the
    REPL recognized the first physical line as a partial statement. This is a handy
    reminder that our statement isn't complete. When the final `)` was parsed, the
    statement was complete and the prompt switched back to `>>>`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，REPL 提示符已从 `>>>` 更改为 …，因为 REPL 识别第一行物理文本为部分语句。这是一个方便的提醒，说明我们的语句尚未完整。当解析到最后一个
    `)` 时，语句才算完整，提示符才切换回 `>>>`。
- en: Splitting, partitioning, and joining strings
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分割、分区和连接字符串
- en: In [Chapter 2](ch02.html "Chapter 2. Simple Data Types"), *Simple Data Types*,
    we looked at different processing methods for a string object. We can transform
    a string into a new string, create strings from non-string data, access a string
    to determine properties or locations within the string, and parse a string to
    decompose it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 2 章](ch02.html "Chapter 2. Simple Data Types") 中，我们探讨了字符串对象的不同的处理方法。我们可以将字符串转换成新的字符串，从非字符串数据创建字符串，访问字符串以确定字符串中的属性或位置，以及解析字符串以分解它。
- en: In many cases, we need to extract elements of a string. The `split()` method
    is used to locate repeating list-like structures within a string. The `partition()`
    method is used to separate the head and tail of a string.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们需要提取字符串的元素。`split()` 方法用于在字符串中定位重复的类似列表的结构。`partition()` 方法用于分离字符串的头和尾。
- en: 'For example, given a string of the form `"numerator=355,denominator=115"` we
    can use these two methods to locate the various names and values. Here''s how
    we can decompose this complex string into pieces:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，给定一个形式为 `"numerator=355,denominator=115"` 的字符串，我们可以使用这两种方法来定位各种名称和值。以下是我们将这个复杂字符串分解成片段的方法：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We've used the `split(",")` method to break the longer string on each `,` character,
    creating a list object which has two substrings. The REPL automatically assigns
    all expression results to a variable named `_`. We assigned the object to the
    `items` variable because the value of `_` gets overwritten by each expression
    statement.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `split(",")` 方法在每个 `,` 字符处将较长的字符串分割，创建了一个包含两个子字符串的列表对象。REPL 自动将所有表达式结果分配给一个名为
    `_` 的变量。我们将对象分配给 `items` 变量，因为 `_` 的值会被每个表达式语句覆盖。
- en: We used the `partition("=")` method on each item in the `items` variable to
    break the assignment down into name, `=`, and value. A more complex application
    would probably perform more complex processing on the names and values.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `items` 变量的每个项目上使用了 `partition("=")` 方法，将赋值分解为名称、`=` 和值。更复杂的应用可能需要对名称和值进行更复杂的处理。
- en: 'The `join()` method is the inverse of the `split()` method. This works with
    a sequence of string objects to create a single long string from many smaller
    strings. Here''s an example of using a tuple of strings to create a longer string:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`join()` 方法是 `split()` 方法的逆操作。它使用字符串对象的序列来创建一个由许多较小的字符串组成的单个长字符串。以下是一个使用字符串元组创建长字符串的示例：'
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We've created a sequence of three strings and assigned it to a variable named
    `options`. We then used the string `"|"` to join the items in the `options` sequence.
    The result is a longer string with the items separated by the given string.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个包含三个字符串的序列，并将其分配给一个名为 `options` 的变量。然后我们使用字符串 `"|"` 将 `options` 序列中的项目连接起来。结果是包含项目并通过给定字符串分隔的更长的字符串。
- en: The `split()` and `join()` methods work well with singletons. If we try to split
    a single item with no punctuation, we get a sequence with a single item. If we
    join a singleton item, the separator will not be used.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`split()` 和 `join()` 方法与单例很好地配合工作。如果我们尝试分割一个没有标点的单例项，我们会得到一个只有一个元素的序列。如果我们连接一个单例项，分隔符将不会被使用。'
- en: Python's string methods give us the tools to handle a variety of string parsing
    and decomposition. For a more general solution, we'll have to resort to even more
    powerful tools. We'll look at the regular expression module, `re`, later.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的字符串方法为我们提供了处理各种字符串解析和分解的工具。对于更通用的解决方案，我们可能需要求助于更强大的工具。我们将在稍后查看正则表达式模块
    `re`。
- en: If we want to create complex strings, we use the `format()` method. We'll look
    at this next.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要创建复杂的字符串，我们使用 `format()` 方法。我们将在下一节查看这个方法。
- en: Using the format() method to make more readable output
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 format() 方法生成更易读的输出
- en: 'Sophisticated string creation can be done with the `format()` method. We create
    a template string and values which can be plugged into the template. Here''s an
    example of how this works:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `format()` 方法进行复杂的字符串创建。我们创建一个模板字符串和可以插入模板的值。以下是如何工作的示例：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We've created a variable, `c`, with a value of 42\. We've used a template, `"{0:d}°C
    is {1:.1f}°F"`, to format two values. The argument value with an index of 0 is
    `c`, the argument value with an index of 1 is the value of the expression `32+9*c/5`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个变量`c`，其值为42。我们使用模板`"{0:d}°C is {1:.1f}°F"`来格式化两个值。索引为0的参数值是`c`，索引为1的参数值是表达式`32+9*c/5`的值。
- en: The template string includes literal characters, plus replacement fields. Each
    replacement field is surrounded by `{}`. The replacement field has two components
    with a syntax of `{index:specification}`. The *index* component identifies which
    item is taken from the positional arguments to the `format()` method. The *specification*
    component shows us how to format the selected object.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串包括字面字符，以及替换字段。每个替换字段由`{}`包围。替换字段有两个组成部分，其语法为`{index:specification}`。*索引*部分标识从`format()`方法的参数中取出的哪个项目。*指定*部分显示如何格式化选定的对象。
- en: The example gives two specifications. One specification is the character `d`,
    which is the decimal integer conversion. The other is the slightly more complex
    `.1f`, which is a floating-point conversion with one digit to the right of the
    decimal point.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 示例给出了两个规范。一个是字符`d`，它是十进制整数转换。另一个是稍微复杂一些的`.1f`，它是一个小数点右侧有一位数字的浮点转换。
- en: 'There is considerable sophistication available in the format specifications.
    There are eight fields to a format specification. The syntax gloss looks like
    this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 格式规范中有相当多的复杂性。格式规范有八个字段。语法概述如下：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We've surrounded each field with `[]` to group the names visually. Note that
    all the fields are actually optional and have default values.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用`[]`将每个字段围起来，以便在视觉上分组名称。请注意，所有字段实际上都是可选的，并且有默认值。
- en: We'll summarize the fields from right to left in order of importance.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按从右到左的顺序，按照重要性的顺序总结字段。
- en: '**Type**: This specifies the overall type of conversion. Depending on the kind
    of Python object, there are a number of type codes available:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型**：这指定了转换的整体类型。根据Python对象的类型，有多个类型代码可用：'
- en: For string values, the type code of `s` is used.
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于字符串值，使用类型代码`s`。
- en: For integer values, type codes of `d`, `n`, `b`, `o`, `x`, or `X` can be used.
    These provide decimal, locale-aware numbers, binary, octal, or hexadecimal output.
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于整数值，可以使用`d`、`n`、`b`、`o`、`x`或`X`类型代码。这些提供十进制、区域感知的数字、二进制、八进制或十六进制输出。
- en: For float values, type codes are `e`, `E`, `f`, `F`, `g`, `G`, `n`, or `%`.
    The `e` formats provide explicit exponents. The `f` codes show `float` values
    with no exponent. The `g` values are called **general** and choose `e` or `f,`
    depending on the size of the number. The `n` code is locale-aware, using the locale
    settings for floating-point presentation. The `%` multiplies by 100 and includes
    the `%` symbol.
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于浮点值，类型代码可以是`e`、`E`、`f`、`F`、`g`、`G`、`n`或`%`。`e`格式提供显式的指数。`f`代码显示没有指数的`float`值。`g`值被称为**通用**，根据数字的大小选择`e`或`f`。`n`代码是区域感知的，使用区域设置进行浮点表示。`%`乘以100并包含`%`符号。
- en: '**Precision**: The `.precision` value is only used for floating-point formats.
    It''s the number of positions to the right of the decimal point.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**精度**：`.precision`值仅用于浮点格式。它是小数点右侧的位置数。'
- en: '**The , separator**: If a `,` character is used, then US-style `,` as 1,000''s
    separators are included. This isn''t locale-aware, so it can''t be overridden
    by the OS and the Python locale module.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逗号分隔符**：如果使用逗号字符，则包括美式逗号作为1,000的分隔符。这不是区域感知的，因此不能由操作系统和Python区域模块覆盖。'
- en: '**Width**: If omitted, the number is formatted as wide as necessary. If provided,
    the number is filled out to this width. By default, the fill uses leading spaces,
    but this can be changed by providing values for the *fill* and *align* fields.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**宽度**：如果省略，数字将按必要宽度格式化。如果提供，数字将填充到这个宽度。默认情况下，填充使用前导空格，但可以通过提供`fill`和`align`字段的值来更改。'
- en: '**0**: This forces filling to the required width with leading zeroes. This
    is the same as a fill and align of `0=`.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**0**：这强制用前导零填充到所需的宽度。这与填充和定位`0=`相同。'
- en: '**#**: This is used with `b`, `o`, and `x` formatting to include a prefix of
    `0b`, `0o`, or `0x` in front of the number.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**#**：与`b`、`o`和`x`格式化一起使用，在数字前面包含前缀`0b`、`0o`或`0x`。'
- en: '**Sign**: By default, positive numbers have no sign and negative numbers have
    a leading `-`. Providing a *sign* field of `+` means that all signs are shown
    explicitly. Providing a *sign* field of `-` means that an extra space is included
    for positive numbers, assuring that positive and negative numbers will align in
    columns when printed using a fixed-width font.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**符号**：默认情况下，正数没有符号，负数有前导 `-`。提供 `+` 的 *符号* 字段表示所有符号都明确显示。提供 `-` 的 *符号* 字段表示为正数包含额外空格，确保正负数在打印时使用固定宽度字体时在列中对齐。'
- en: '**Fill and align**: This fills up the space to the value of the *width* field.
    If we provide *align* without a specific *fill* character, the default character
    is a space. We can''t provide a *fill* character on its own, though. There are
    four codes we can use:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**填充和对齐**：这会将空间填充到 *宽度* 字段的值。如果我们提供 *对齐* 而没有特定的 *填充* 字符，则默认字符是空格。我们虽然不能单独提供
    *填充* 字符，但我们可以使用以下四种代码：'
- en: '`<` or *fill*`<` will push the data to the left, and the filling will be on
    the right.'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<` 或 *fill*`<` 将数据推向左边，填充将在右边。'
- en: '`>` or *fill*`>` will push the data to the right, the fill character will be
    used on the left.'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>` 或 *fill*`>` 将数据推向右边，填充字符将用于左边。'
- en: '`^` or *fill*`^` will center the data, filling both left and right.'
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`^` 或 *fill*`^` 将数据居中，填充左右两边。'
- en: '`=` or *fill*`=` will put the sign first, and the fill character will be used
    after the sign. This will make the signs more prominent in a column of numbers.'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`=` 或 *fill*`=` 将符号放在前面，填充字符将跟在符号后面。这将使符号在数字列中更加突出。'
- en: 'Here''s an example that uses a fairly complex format specification:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个使用相当复杂的格式规范的例子：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We've created an object, `amount`, with a `Decimal` value. We then used a format
    specification of `*>10n` on this number. This used leading `*` characters to fill
    out the number to 10 characters.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个具有 `Decimal` 值的对象 `amount`。然后我们在这个数字上使用了格式规范 `*>10n`。这使用了前导 `*` 字符来填充数字至
    10 个字符。
- en: Summary of the standard string libraries
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准字符串库总结
- en: Python's standard library offers a number of modules with additional string
    processing features.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的标准库提供了一些具有额外字符串处理功能的模块。
- en: '`string`: The string module contains constants that decompose the ASCII characters
    into letters, numbers, whitespace, and so on. It contains the full definition
    of the formatter that is used by the `str.format()` method. We''ll look at this
    in the next section. It also contains the `Template` class which defines a string
    template into which values can be interpolated.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`：`string` 模块包含将 ASCII 字符分解为字母、数字、空白等常量。它包含了 `str.format()` 方法使用的格式化器的完整定义。我们将在下一节中探讨这一点。它还包含
    `Template` 类，该类定义了一个字符串模板，可以将值插入其中。'
- en: '`re`: The regular expression library allows us to define a pattern that can
    be used to parse input strings. We''ll look at this in the next section.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`re`：正则表达式库允许我们定义一个模式，该模式可以用于解析输入字符串。我们将在下一节中探讨这一点。'
- en: '`difflib`: The `difflib` module is used to compare sequences of strings, typically
    from text files. There are a number of comparison algorithms available in this
    module.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`difflib`：`difflib` 模块用于比较字符串序列，通常来自文本文件。此模块中提供了多种比较算法。'
- en: '`textwrap`: We can use the `textwrap` module to format large blocks of text.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`textwrap`：我们可以使用 `textwrap` 模块来格式化大块文本。'
- en: '`unicodedata`: The `unicodedata` module provides functions for determining
    what kind of Unicode character is present. Unicode Standard Annex 44 defines a
    collection of properties that apply to the Unicode characters. One commonly-used
    function is the general category of a character; this includes simple Latin rules
    like "Lu" for uppercase letter or "Nd" for decimal number. The general category
    codes also include "Sk" which is for non-letter like modifier symbols.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unicodedata`：`unicodedata` 模块提供了确定 Unicode 字符类型的函数。Unicode 标准附件 44 定义了一组适用于
    Unicode 字符的属性。一个常用的函数是字符的一般类别；这包括简单的拉丁规则，如 "Lu" 表示大写字母或 "Nd" 表示十进制数字。一般类别代码还包括
    "Sk"，用于非字母符号，如修饰符号。'
- en: '`stringprep`: This is an implementation of RFC 3454, which prepares Unicode
    text strings in order to support sensible string comparisons.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stringprep`：这是 RFC 3454 的实现，它准备 Unicode 文本字符串以支持合理的字符串比较。'
- en: Using the re module to parse strings
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 re 模块解析字符串
- en: Regular expressions give us a simple way to specify a set of related strings
    by describing the pattern they have in common. A regular expression is an element
    of set theory that could (in theory) define the set of all possible related strings.
    The theoretical matching process would be a quick check to see if a given string
    in this set of all possible strings is generated by the expression. Since the
    set of all possible strings generated from a pattern could potentially be infinite,
    this isn't how things work in practice.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式给我们提供了一个简单的方法，通过描述它们共有的模式来指定一组相关的字符串。正则表达式是集合论的一个元素，理论上可以定义所有可能的相关的字符串集合。理论上的匹配过程将是一个快速检查，以查看这个所有可能的字符串集合中的给定字符串是否是由该表达式生成的。由于从模式生成的所有可能的字符串集合可能是无限的，所以在实践中并不是这样工作的。
- en: When we use the `re` module, we generally do three things. Firstly, we specify
    the pattern string. Secondly, we compile the pattern into an object that efficiently
    determines if and where a given string matches the pattern. Finally, we repeatedly
    use the `pattern` object to efficiently match, search, or parse the given input
    strings.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `re` 模块时，我们通常做三件事。首先，我们指定模式字符串。其次，我们将模式编译成一个对象，该对象可以有效地确定给定的字符串是否以及在哪里与模式匹配。最后，我们反复使用
    `pattern` 对象来有效地匹配、搜索或解析给定的输入字符串。
- en: 'As a concrete example, we need to process input which contains lines like this:
    `Birth Date: 3/8/1987` or `Birth Date: 1/18/59`. Note that the number of digits
    in each date and the amount of whitespace is allowed to vary.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '作为具体的一个例子，我们需要处理包含如下行的输入：`Birth Date: 3/8/1987` 或 `Birth Date: 1/18/59`。注意，每个日期中的数字数量以及允许的空格量可能会有所不同。'
- en: 'We may perform any of the following three common kinds of processing:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以执行以下三种常见的处理方式中的任何一种：
- en: A **matching** regular expression might be `Birth Date:\s+\d+/\d+/\d+`. The
    `\s+` subexpression means one or more spaces. The `\d+` subexpression of this
    means one or more digits. A match pattern is usually designed to match the whole
    string.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**匹配**正则表达式可能是 `Birth Date:\s+\d+/\d+/\d+`。`\s+` 子表达式意味着一个或多个空格。这个 `\d+` 子表达式的意思是一个或多个数字。匹配模式通常被设计为匹配整个字符串。
- en: A **searching** regular expression might be `\d+/\d+/\d+`. This search pattern
    includes one or more digits, `\d+`, and literal punctuation, `/`. This expression
    describes a substring that can be found somewhere within the given string.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**搜索**正则表达式可能是 `\d+/\d+/\d+`。这个搜索模式包括一个或多个数字，`\d+`，以及字面符号，`/`。这个表达式描述了一个可以在给定字符串中找到的子串。
- en: A **parsing** pattern separates the various digit groups from the surrounding
    context. This is a slight modification to one of the previous examples to include
    `()`, that specifies what to capture. We might use `(\d+)/(\d+)/(\d+)` to show
    that the digit groups should be extracted for further processing.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**解析**模式将各个数字组与周围上下文分开。这是对前面示例的一个轻微修改，包括 `()`，指定要捕获的内容。我们可能使用 `(\d+)/(\d+)/(\d+)`
    来表示数字组应该被提取以进行进一步处理。
- en: We can accomplish these matching, searching, and parsing operations with the
    `re` module in Python.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Python 中的 `re` 模块来完成这些匹配、搜索和解析操作。
- en: Using regular expressions
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用正则表达式
- en: 'The general recipe for using regular expressions in a Python program has three
    essential steps. Of course, we must use import re to include the required module.
    The three steps are:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 程序中使用正则表达式的一般步骤有三个基本步骤。当然，我们必须使用 `import re` 来包含所需的模块。这三个步骤是：
- en: Define the pattern string. This will almost always be a raw string, starting
    with `r"`, because the regular expression string will be full of `\` characters
    that we don't want to be treated as escapes by Python. Because `\` begins a Python
    language escape, if we want to write a standalone `\` character, we have to double
    them up in a non-raw string. It is better to use a raw string to write `r"\d+/\d+/\d+"`
    than `\\d+/\\d+/\\d+`.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义模式字符串。这几乎总是原始字符串，以 `r"` 开头，因为正则表达式字符串将充满我们不想被 Python 作为转义字符处理的 `\` 字符。因为 `\`
    是 Python 语言转义符的开始，如果我们想在非原始字符串中写一个独立的 `\` 字符，我们必须将它们加倍。使用原始字符串来编写 `r"\d+/\d+/\d+"`
    比使用 `\\d+/\\d+/\\d+` 更好。
- en: Evaluate the `re.compile()` function to create a `pattern` object. The resulting
    object will do the real work of matching a given target string against the regular
    expression `pattern` object.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估 `re.compile()` 函数以创建一个 `pattern` 对象。这个生成的对象将执行匹配给定目标字符串与正则表达式 `pattern` 对象的实际工作。
- en: 'We can combine the pattern and the compile in one statement like this:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以将模式和编译合并到一个语句中，如下所示：
- en: '[PRE13]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Use the compiled `pattern` object to match or search the candidate strings.
    The result of a successful match or search will be a `Match` object. We can then
    use the match object, where necessary, to extract fields. For example:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用编译后的`pattern`对象来匹配或搜索候选字符串。成功匹配或搜索的结果将是一个`Match`对象。然后我们可以使用这个匹配对象，在需要的时候提取字段。例如：
- en: '[PRE14]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the first example, the `date_pattern.match()` expression returned `None`
    because the given string didn't match the regular expression. In the second example,
    the given string did match the regular expression pattern, and a `Match` object
    was created. If our regular expression is used for parsing, we'll interrogate
    the `Match` object to get the various substrings.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第一个示例中，`date_pattern.match()`表达式返回`None`，因为给定的字符串没有匹配正则表达式。在第二个示例中，给定的字符串与正则表达式模式匹配，并创建了一个`Match`对象。如果我们使用正则表达式进行解析，我们将查询`Match`对象以获取各种子字符串。
- en: 'When we have a `Match` object, it can have captured substrings that match parts
    of the overall pattern. We''ll usually make use of the various `group()` methods
    to get substrings. Here are some examples:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个`Match`对象时，它可能包含匹配整体模式一部分的捕获子字符串。我们通常会使用各种`group()`方法来获取子字符串。以下是一些示例：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the first example, we saw all of the matching content. In the second example,
    we saw the value of group number one, the first portion of the regular expression
    wrapped in `()`. In the final example, we saw all `()`-wrapped groups in the regular
    expression. Since there was only one such group, the value of `groups()` is a
    single-item `tuple` with matching text.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，我们看到了所有匹配的内容。在第二个示例中，我们看到了组号一的价值，即正则表达式中的第一个部分，用`()`括起来。在最后的示例中，我们看到了正则表达式中的所有`()`括起来的组。由于只有一个这样的组，`groups()`的值是一个包含匹配文本的单项元组。
- en: Creating a regular expression string
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建正则表达式字符串
- en: There are numerous rules for creating regular expression patterns, and we'll
    look at a few of them here. The definitive list is in the *Python Standard Library*
    documentation for the `re` module, in section 6.2.1\. For more information on
    this topic, see *Mastering Python Regular Expressions* from Packt Books. See [https://www.packtpub.com/application-development/mastering-python-regular-expressions](https://www.packtpub.com/application-development/mastering-python-regular-expressions).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 创建正则表达式模式有许多规则，我们在这里将探讨其中的一些。完整的列表可以在`re`模块的*Python标准库*文档的6.2.1节中找到。有关此主题的更多信息，请参阅Packt
    Books的*精通Python正则表达式*。请参阅[https://www.packtpub.com/application-development/mastering-python-regular-expressions](https://www.packtpub.com/application-development/mastering-python-regular-expressions)。
- en: 'First we''ll look at the "atomic" regular expressions. Then we''ll look at
    the rules for combining regular expressions into a larger regular expression.
    Here are some simple, atomic regular expressions:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将查看“原子”正则表达式。然后我们将查看将正则表达式组合成更大正则表达式的规则。以下是一些简单的、原子的正则表达式：
- en: Any single character. With a few exceptions, this means just about any printable
    character. The exceptions are the characters which have special meaning in the
    regular expression language, including `.`, `*`, `?`, `(`, `)`, `[`, `]`, `|`
    among others.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何单个字符。除了一些例外，这意味着几乎任何可打印字符。这些例外是正则表达式语言中有特殊意义的字符，包括`.`, `*`, `?`, `(`, `)`,
    `[`, `]`, `|`等。
- en: 'A `.` matches any character. To match a period, the `\` escape character is
    used: `\.` matches a period.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.`匹配任何字符。为了匹配点，使用转义字符`\`：`\.`匹配一个点。'
- en: Some escape sequences match whole classes of characters.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些转义序列匹配整个字符类。
- en: '`\d` matches any digit. `\D` matches any non-digit character.'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\d`匹配任何数字。`\D`匹配任何非数字字符。'
- en: '`\s` matches any whitespace character. `\S` matches any non-space character.'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\s`匹配任何空白字符。`\S`匹配任何非空白字符。'
- en: '`\w` matches any word character. `\W` matches any non-word character. By default,
    these follow the Unicode rules. We can override this to follow a considerably
    simpler set of ASCII-only rules.'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\w`匹配任何单词字符。`\W`匹配任何非单词字符。默认情况下，这些遵循Unicode规则。我们可以覆盖它以遵循一个相当简单的仅ASCII规则集。'
- en: There are some suffixes that we can put after a regular expression.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在正则表达式后面添加一些后缀。
- en: A `*` suffix means the previous expression can be matched zero or more times.
    This has the effect of making the previous RE pattern optional as well as eligible
    for repetition.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`后缀表示前面的表达式可以匹配零次或多次。这相当于使前面的正则表达式模式既可选又可重复。'
- en: A `+` suffix means the previous expression can be matched one or more times.
    This means that the previous pattern is mandatory and can also be repeated.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+` 后缀表示前面的表达式可以匹配一次或多次。这意味着前面的模式是必需的，也可以重复。'
- en: A `?` suffix means the previous expression is optional; it can be matched zero
    times or just one time.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?` 后缀表示前面的表达式是可选的；它可以匹配零次或一次。'
- en: To actually match a suffix character, use the `\` escape. For example, `\*`
    matches an asterisk.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要实际匹配后缀字符，请使用 `\` 转义。例如，`\*` 匹配一个星号。
- en: 'We can combine individual expressions into larger patterns. Here are some common
    techniques for doing this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将单个表达式组合成更大的模式。以下是一些常见的组合技术：
- en: A sequence of regular expressions is a regular expression. We simply put the
    expressions one after another inside the pattern string. When we write an expression
    like `Birth` it's a sequence of five atomic expressions which match each individual
    character.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式的序列是一个正则表达式。我们只需将表达式一个接一个地放在模式字符串中。当我们编写 `Birth` 这样的表达式时，它是一个由五个原子表达式组成的序列，每个表达式匹配单个字符。
- en: A sequence of characters in `[]` matches any one of the given characters. This
    is generally used with single-character expressions; often we'll see constructs
    like `[a-zA-Z0-9_]` to match any letter or digit or `_`. To match multiple-character
    strings we use a suffix after the `[]`. We can use `r"[0-9a-fA-F]+"` to match
    one or more hexadecimal digits. To make `-` one of the alternative characters,
    it must be first or last within the list of characters inside the `[]`.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[]` 中的字符序列匹配给定的任意一个字符。这通常用于单字符表达式；我们经常看到像 `[a-zA-Z0-9_]` 这样的结构来匹配任何字母、数字或
    `_`。为了匹配多字符字符串，我们在 `[]` 后使用后缀。我们可以使用 `r"[0-9a-fA-F]+"` 来匹配一个或多个十六进制数字。为了使 `-`
    成为可选字符之一，它必须是列表中字符的第一个或最后一个。'
- en: 'Two regular expressions separated by `|` is a regular expression. Either one
    can match. We might be looking at a pattern like `true|false`. We must match one
    of the two regular expressions: either `true` or `false`. To match the pipe character,
    `|`, it must be escaped like this `\|`.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 `|` 分隔的两个正则表达式是一个正则表达式。任一都可以匹配。我们可能正在查看 `true|false` 这样的模式。我们必须匹配这两个正则表达式中的一个：`true`
    或 `false`。为了匹配管道字符 `|`，它必须像这样转义 `\|`。
- en: A regular expression surrounded by `()`'s is a regular expression. It's also
    preserved as a group, so that we can use the matching characters while parsing.
    To match parentheses, they must be escaped, `\(` matches a `(`. Substrings captured
    via `()` are available via the `group()` method of the match object.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 括号 `()` 包围的正则表达式是一个正则表达式。它也被保留为一个组，这样我们可以在解析时使用匹配的字符。为了匹配括号，它们必须被转义，`\(` 匹配一个
    `(`。通过 `()` 捕获的子串可以通过匹配对象的 `group()` 方法访问。
- en: 'These rules help us examine the details of a specific pattern. Here''s a pattern
    we might use to parse some input:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则帮助我们检查特定模式的细节。以下是我们可能用于解析一些输入的模式：
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is a regular expression which is a sequence of 5 regular expressions.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个由 5 个正则表达式组成的正则表达式序列。
- en: The characters `(\w+)` make a regular expression, `\w`, with a `+` suffix enclosed
    in `()`. This matches any sequence of one or more word characters.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符 `(\w+)` 创建了一个带有 `+` 后缀的括号内的正则表达式 `\w`。这匹配任何由一个或多个单词字符组成的序列。
- en: '`\s*` is a regular expression. It''s a simple expression `\s` with a suffix
    of `*`. It matches zero or more whitespace characters. This means that spaces
    are optional after the initial word. If spaces are present, any number may be
    used.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\s*` 是一个正则表达式。它是一个简单的表达式 `\s`，带有 `*` 后缀。它匹配零个或多个空白字符。这意味着在初始单词之后的空间是可选的。如果存在空格，可以使用任意数量的空格。'
- en: '`[=:]` is a regular expression built from two single-character expressions,
    `=` and `:`. It matches either one of the two characters.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[=:]` 是由两个单字符表达式 `=` 和 `:` 构成的正则表达式。它匹配这两个字符中的任意一个。'
- en: '`\s*` is used a second time to permit any number of whitespace characters between
    the `=` or `:` and the value.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\s*` 用于第二次出现，允许在 `=` 或 `:` 和值之间有任意数量的空白字符。'
- en: The final regular expression is `(.*)` which matches any sequence of characters.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终的正则表达式是 `(.*)`，它匹配任何字符序列。
- en: When we use this regular expression, if a `Match` object is created, it will
    have two groups. We can then extract the name and value matched by the patterns
    within this regular expression.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用这个正则表达式时，如果创建了一个 `Match` 对象，它将有两个组。然后我们可以提取由这个正则表达式中的模式匹配的名称和值。
- en: Working with Unicode, ASCII, and bytes
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理 Unicode、ASCII 和字节
- en: 'The `re` module works with bytes as well as Unicode strings. We must provide
    proper pattern literals depending on which kind of string we''re working with.
    With Unicode, we use pattern literals with the `r` prefix: `r"\w+"`. With bytes,
    we use the `rb` prefix, `rb"\w+"`; the `rb` means raw bytes instead of raw Unicode
    characters.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`re`模块可以与字节以及Unicode字符串一起工作。我们必须根据我们正在处理的字符串类型提供适当的模式字面量。对于Unicode，我们使用带有`r`前缀的模式字面量：`r"\w+"`。对于字节，我们使用`rb`前缀，`rb"\w+"`；这里的`rb`表示原始字节而不是原始Unicode字符。'
- en: The rules for the character classes are, of course, different. A Unicode string
    that matches the `"\w+"` pattern can have any of a wide variety of Unicode "word"
    characters. A bytes object that uses the `"\w+"` pattern will match ASCII characters
    from the set `a-z`, `A-Z`, `0-9` and `_`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 字符类别的规则当然不同。匹配`"\w+"`模式的Unicode字符串可以包含任何广泛的Unicode“单词”字符。使用`"\w+"`模式的字节对象将匹配来自集合`a-z`、`A-Z`、`0-9`和`_`的ASCII字符。
- en: Tip
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We must explicitly use bytes for the pattern literals when parsing, searching,
    or matching with bytes.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析、搜索或与字节匹配时，我们必须明确使用字节为模式字面量。
- en: We can use an option in the `re.compile()` to force a Unicode pattern to follow
    the simplified ASCII rules. If we write `re.compile(r"\w+", re.ASCII)` we've replaced
    the default Unicode assumption for `\w` with the ASCII rule for `\w` even though
    we're doing Unicode string matching.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`re.compile()`中使用一个选项来强制Unicode模式遵循简化的ASCII规则。如果我们写`re.compile(r"\w+",
    re.ASCII)`，我们就用ASCII规则替换了`\w`的默认Unicode假设，即使我们正在进行Unicode字符串匹配。
- en: Using the locale module for personalization
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用区域模块进行个性化
- en: When looking at the `str.format()` method, we saw that the `n` format type produced
    a number with formatting based on the user's locale. This means that the formatting
    varies according to the OS locale settings. Users in different countries will
    see that their personal locale settings are used properly.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看`str.format()`方法时，我们看到`n`格式类型根据用户的区域设置产生了一个格式化的数字。这意味着格式根据操作系统区域设置而变化。不同国家的用户将看到他们的个人区域设置被正确使用。
- en: 'Here''s an example of using the `locale` module to get locale-specific formatting:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用`locale`模块获取特定区域设置格式化的示例：
- en: '[PRE17]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This script used the `locale` module to set the Python locale to match the prevailing
    OS locale. The locale is reported to be English as used in the US (`en_US`) and
    the preferred Unicode encoding is shown as UTF-8.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本使用了`locale`模块来设置Python区域设置以匹配当前的操作系统区域设置。区域设置报告为美国使用的英语（`en_US`），首选的Unicode编码显示为UTF-8。
- en: The formatted value of `23.456` showed up with a US English decimal point. This
    fits the expectations of users in the US.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`23.456`的格式化值显示为美国英语的小数点。这符合美国用户的预期。'
- en: We then switched the locale to Sweden. The language was reported as `sv_SE`,
    which means the Swedish language, as used in Sweden. The formatted value switched
    to `23,456` with a decimal comma, which is appropriate for users in Sweden.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将区域设置切换到瑞典。语言报告为`sv_SE`，这意味着在瑞典使用的瑞典语。格式化的值切换到`23,456`，使用小数逗号，这对于瑞典用户来说是合适的。
- en: 'Let''s continue this example, and use the `locale.currency()` formatting function:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续这个例子，并使用`locale.currency()`格式化函数：
- en: '[PRE18]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The amount was formatted using `,` for the decimal separator and `kr` as the
    local currency in Sweden. The locale module includes the currency names.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 金额使用`,`作为小数分隔符，以`kr`作为瑞典的本地货币。区域模块包括货币名称。
- en: Note that we provided the numeric value, `23.54`, in Python syntax, which does
    not vary by locale. Python floating-point literals always use decimal points.
    Only the output string from the `currency()` function uses the `,` character as
    a decimal place separator.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们提供了数值`23.54`，使用Python语法，这不会因区域设置而变化。Python浮点字面量始终使用小数点。只有`currency()`函数的输出字符串使用`,`字符作为小数点分隔符。
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've reviewed the essential numeric types and the operators
    available on Python. We've looked at some expressions that involve a mixture of
    string and numeric data.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了Python的基本数字类型和可用的运算符。我们查看了一些涉及字符串和数字数据混合的表达式。
- en: In order to view the output from our scripts, we've looked at the `print()`
    function. This is used widely to produce output. The `print()` function is a very
    handy tool for debugging particularly complex functions or classes.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看我们脚本的输出，我们查看`print()`函数。这被广泛用于产生输出。`print()`函数是调试特别复杂函数或类的一个非常方便的工具。
- en: Additionally, we've looked at how we can use the `str.format()` method to produce
    elaborately formatted data. This gives us a wide variety of techniques for converting
    Python objects to strings that can be displayed. We've also looked at some ways
    that we can parse strings using string method functions such as `split()` and
    `partition()`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们探讨了如何使用`str.format()`方法来生成格式化的数据。这为我们提供了将Python对象转换为可显示字符串的广泛技术。我们还探讨了使用诸如`split()`和`partition()`之类的字符串方法函数来解析字符串的一些方法。
- en: Beyond the basics of string processing, we've looked at how we can use the `re`
    module to match, search, and parse strings. This module is sophisticated and has
    a large number of features for extracting useful information from input strings.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符串处理的基本知识之外，我们探讨了如何使用`re`模块来匹配、搜索和解析字符串。这个模块功能强大，具有大量从输入字符串中提取有用信息的特性。
- en: In [Chapter 4](ch04.html "Chapter 4. Variables, Assignment and Scoping Rules"),
    *Variables, Assignment and Scoping Rules*, we'll expand on our script-writing
    by using variables to store intermediate results. We'll also look at how objects
    are created and removed. These rules will lead to an understanding of which variables
    are visible in which portions of a complex program.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。变量、赋值和作用域规则")*变量、赋值和作用域规则*中，我们将通过使用变量来存储中间结果来扩展我们的脚本编写。我们还将探讨如何创建和删除对象。这些规则将有助于理解在复杂程序的不同部分中哪些变量是可见的。
