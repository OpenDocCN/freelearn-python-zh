- en: Securing Serverless Applications with Zappa
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Zappa保护无服务器应用程序
- en: this chapter, we are going to learn about securing Python-based applications
    that are deployed on AWS Lambda. In the previous chapters, we learned about developing
    an application and deploying it on a serverless infrastructure using Zappa. Zappa
    also supports several mechanisms that enable you to implement a security layer
    for your application. Securing an application from unauthorized access is an essential
    process for any web application, but it would be more interesting to be able to
    secure a web application on a serverless infrastructure.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何保护部署在AWS Lambda上的基于Python的应用程序。在之前的章节中，我们学习了如何开发一个应用程序并将其部署到无服务器基础设施上使用Zappa。Zappa还支持多种机制，使您能够为应用程序实现安全层。保护应用程序免受未经授权的访问是任何Web应用程序的重要过程，但能够在无服务器基础设施上保护Web应用程序将更加有趣。
- en: Therefore, we will be developing an API-based application and will demonstrate
    some mechanisms to secure it from unauthorized access. Let's move on and explore
    detailed information about setting up the development environment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将开发一个基于API的应用程序，并演示一些机制来保护它免受未经授权的访问。让我们继续并探索有关设置开发环境的详细信息。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Implementing a random quote API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现随机引用API
- en: Enabling secure endpoints on the API Gateway
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在API Gateway上启用安全端点
- en: Tracing AWS Lambda failures with dead letter queues
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用死信队列跟踪AWS Lambda的失败
- en: Analyzing Zappa applications with AWS X-Ray
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AWS X-Ray分析Zappa应用程序
- en: Securing your Zappa application using AWS VPC
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AWS VPC保护您的Zappa应用程序
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we are going to cover more AWS features in order to enhance
    the security layer using Zappa. Before diving into this chapter, make sure that
    you have fulfilled the following prerequisites:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖更多的AWS功能，以增强使用Zappa的安全层。在深入研究本章之前，请确保您已满足以下先决条件：
- en: Ubuntu 16.04/macOS/Windows
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu 16.04/macOS/Windows
- en: Python 3.6
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.6
- en: Pipenv tool
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pipenv工具
- en: AWS account
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS账户
- en: Gunicorn
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gunicorn
- en: Zappa
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zappa
- en: Other Python packages
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他Python包
- en: Once you have enabled the development environment, we can move on and develop
    a simple Falcon-based API for generating a random quote on request. In further sections,
    we will be securing this API with different mechanisms and approaches using Zappa.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您启用了开发环境，我们就可以继续并开发一个简单的基于Falcon的API，以便在请求时生成一个随机引用。在接下来的章节中，我们将使用Zappa使用不同的机制和方法来保护这个API。
- en: Implementing a random quote API
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现随机引用API
- en: In this section, we are going to create a RESTful API that generates a random
    quote. This will include the Falcon-based API implementation with Mashape API
    integration, like we did in [Chapter 9](part0219.html#6GRB60-8241a43bed654018b51365a570bcef1d),
    *Asynchronous Task Execution on AWS Lambda*. This time, we are not going to integrate
    a database as we don't want to persist any information. This will be a simple
    HTTP `GET` request to our API and then we will return a JSON response with a randomly
    generated quote using the Mashape API. Let's look at the prerequisites in the
    next section.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将创建一个RESTful API，用于生成随机引用。这将包括基于Falcon的API实现与Mashape API集成，就像我们在[第9章](part0219.html#6GRB60-8241a43bed654018b51365a570bcef1d)中所做的那样，*在AWS
    Lambda上执行异步任务*。这一次，我们不打算集成数据库，因为我们不想保留任何信息。这将是一个简单的HTTP `GET` 请求到我们的API，然后我们将使用Mashape
    API返回一个随机生成的引用的JSON响应。让我们在下一节中看一下先决条件。
- en: Prerequisites
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 先决条件
- en: I hope you have met the previously mentioned technical requirements and set
    up the development environment using the pipenv tool. Now, you need to sign up
    at the **Mashape** API marketplace ([https://market.mashape.com/](https://market.mashape.com/)),
    where we will be using the **Random Famous Quote** API ([https://market.mashape.com/andruxnet/random-famous-quotes](https://market.mashape.com/andruxnet/random-famous-quotes)).
    Once you acquire the credentials to use this API, then we need to configure it
    in our application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望您已经满足了先前提到的技术要求，并使用pipenv工具设置了开发环境。现在，您需要在**Mashape** API市场（[https://market.mashape.com/](https://market.mashape.com/)）注册，我们将使用**Random
    Famous Quote** API（[https://market.mashape.com/andruxnet/random-famous-quotes](https://market.mashape.com/andruxnet/random-famous-quotes)）。一旦您获得了使用此API的凭据，我们就需要在我们的应用程序中对其进行配置。
- en: We are going to use Zappa's `remote_env` feature to share these credentials
    as environment variables from the AWS S3 file, hence why you need to upload a
    JSON file on AWS S3.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Zappa的`remote_env`功能从AWS S3文件中将这些凭据作为环境变量共享，因此您需要在AWS S3上上传一个JSON文件。
- en: 'File—`book-config`/`chapter-11-config.json`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 文件—`book-config`/`chapter-11-config.json`：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once you upload this file to S3 storage, you can use the `remove_env` feature
    in your `zappa_settings.json` file. The following is an example of `zappa_settings.json`
    with `remote_env` configuration:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您将此文件上传到S3存储中，您可以在`zappa_settings.json`文件中使用`remote_env`功能。以下是带有`remote_env`配置的`zappa_settings.json`的示例：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will be adding this setting once we initialize Zappa for deployment. As
    of now, you can set up these credentials as environment variables manually, like
    we are doing here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们初始化Zappa进行部署，我们将添加这个设置。目前，您可以手动将这些凭据设置为环境变量，就像我们在这里所做的那样：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, let's move to the next section, where we are going to implement the RESTful
    API for generating random quote data.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一节，在那里我们将实现用于生成随机引用数据的RESTful API。
- en: Developing the random quote API
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发随机引用API
- en: 'Since we have discussed the Mashape API configuration, let''s write a code
    snippet to implement functionality for fetching the random quote data. Have a
    look at the following code snippet:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了Mashape API的配置，让我们编写一个代码片段来实现获取随机引用数据的功能。请看以下代码片段：
- en: 'File—`mashape.py`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 文件—`mashape.py`：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, we wrote a method named `fetch_quote`, which is responsible
    for fetching the random quote data from the Mashape API. We are going to use this
    method for further implementation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们编写了一个名为`fetch_quote`的方法，负责从Mashape API获取随机引用数据。我们将在进一步的实现中使用这个方法。
- en: Now, let's write a resource API for our users, who will be using our API to
    get a random quote. The following is a code snippet of the resource API.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为我们的用户编写一个资源API，他们将使用我们的API来获取随机引用。以下是资源API的代码片段。
- en: 'File—`resource.py`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 文件-`resource.py`：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we implemented a RESTful API using the Falcon framework. This API is mapped
    with the root URL, that is,  `"/"`. We used the `on_get` method to only accept
    the HTTP `GET` request; other requests will be denied access. Once a user initiates
    a `GET` request, this API will return the random quote data.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用Falcon框架实现了一个RESTful API。此API与根URL映射，即`"/"`。我们使用`on_get`方法仅接受HTTP `GET`请求；其他请求将被拒绝访问。一旦用户发起`GET`请求，此API将返回随机引用数据。
- en: 'You can execute this API on your local environment by running this API on the
    localhost using `gunicorn`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本地环境上通过在本地主机上使用`gunicorn`运行此API来执行此API：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once you run the `gunicorn resources:api` command, then the API will be available
    on the localhost with `8000` port. Let''s execute the API using the `curl` command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行`gunicorn resources:api`命令，API将在本地使用`8000`端口可用。让我们使用`curl`命令执行API：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That's it. We are done with the implementation. Now, it's time to deploy the
    application on AWS Lambda using Zappa. Let's move on to the next section, where
    we will discuss the deployment process further.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们已经完成了实施。现在，是时候使用Zappa在AWS Lambda上部署应用程序了。让我们继续下一节，我们将进一步讨论部署过程。
- en: Deploying with Zappa
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Zappa部署
- en: To configure Zappa, you should run the `zappa init` command and follow the auto-generated
    questionnaire. I followed the default suggested settings, and so the following
    is the auto-generated `zappa_settings.json` file.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置Zappa，您应该运行`zappa init`命令并按照自动生成的问卷进行操作。我遵循了默认建议的设置，因此以下是自动生成的`zappa_settings.json`文件。
- en: 'File—`zappa_settings.json`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 文件-`zappa_settings.json`：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'That''s it. Now, with the help of this configuration, you can perform the deployment
    as mentioned in the following log snippet:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。现在，借助这个配置，您可以执行以下日志片段中提到的部署：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Before going any further, let's integrate a custom domain against this application.
    We learned about creating an SSL certificate using ACM and configuring a custom
    domain in [Chapter 8](part0203.html#61J260-8241a43bed654018b51365a570bcef1d), *Custom
    Domain with SSL*. Hence, we will use the previously created wild SSL certificate.
    It would be very easy to create a new custom domain just from Zappa settings.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们针对此应用程序集成一个自定义域。我们学习了如何使用ACM创建SSL证书并在[第8章](part0203.html#61J260-8241a43bed654018b51365a570bcef1d)中配置自定义域，*带SSL的自定义域*。因此，我们将使用先前创建的通配符SSL证书。只需从Zappa设置中轻松创建新的自定义域。
- en: We are going to add the following settings in the `zappa_settings.json` file.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`zappa_settings.json`文件中添加以下设置。
- en: 'File—`zappa_settings.json`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 文件-`zappa_settings.json`：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, the application is updated on AWS Lambda, but we still need to perform
    the domain certification task to make the domain live. With the help of the `zappa
    certify` command, we can achieve this.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，应用程序已更新到AWS Lambda，但我们仍然需要执行域认证任务以使域名上线。借助`zappa certify`命令，我们可以实现这一点。
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As mentioned in the preceding logs, our application is live with the given custom
    domain ([https://random-quote.abdulwahid.info](https://random-quote.abdulwahid.info)),
    but it can take up to 40 minutes to create the domain and propagate it through
    AWS, though it does not require any further work from your end. Let's move on
    to the next section, where we will execute the deployed application.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的日志所述，我们的应用程序已经使用给定的自定义域名（[https://random-quote.abdulwahid.info](https://random-quote.abdulwahid.info)）上线，但可能需要长达40分钟才能创建域名并通过AWS传播，尽管这不需要您进一步的工作。让我们继续下一节，我们将执行已部署的应用程序。
- en: Executing the API
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行API
- en: 'Once the application is live, you can check the API''s execution using the
    cURL tool. The following is the log snippet of the API''s execution:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序上线，您可以使用cURL工具检查API的执行情况。以下是API执行的日志片段：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: That's all for being serverless. Now, we need to explore some essential steps
    for securing our application from unauthorized access. Let's move on to the following
    sections, where we will discuss and implement some solutions to secure the application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部关于无服务器的内容。现在，我们需要探索一些重要的步骤，以保护我们的应用程序免受未经授权的访问。让我们继续下一节，我们将讨论并实施一些解决方案来保护应用程序。
- en: Enabling secure endpoints on API Gateway
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在API Gateway上启用安全端点
- en: 'Securing API access is an essential criterion. You can limit and restrict the
    access for your customers who are going to consume the API. Amazon API Gateway
    does support several mechanisms to secure, limit, and restrict API uses. This
    will help to maintain the API usages as per your customer base. The following
    are three types of implementations that are supported by API Gateway:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 保护API访问是一个重要的标准。您可以限制和限制将要使用API的客户的访问。Amazon API Gateway确实支持多种机制来保护、限制和限制API的使用。这将有助于根据您的客户群维护API的使用情况。以下是API
    Gateway支持的三种实现类型：
- en: API key
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API密钥
- en: IAM policy
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IAM策略
- en: API Gateway Lambda authorizer
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API网关Lambda授权者
- en: Let's look at each implementation in more detail.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看每个实现。
- en: Enabling the API Key
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用API密钥
- en: 'As we described in [Chapter 1](part0021.html#K0RQ0-8241a43bed654018b51365a570bcef1d), *Amazon
    Web Services for Serverless,* regarding Zappa''s deployment workflow, where Zappa
    configures the API Gateway to invoke the AWS Lambda with a proxy pass mechanism,
    this creates an API on the API Gateway interface. Each API supports various stages.
    In our case, we have created a `dev` stage while deploying the application. Therefore,
    the following screenshot shows the state of the API Gateway console:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](part0021.html#K0RQ0-8241a43bed654018b51365a570bcef1d)中描述的，*Amazon
    Web Services for Serverless,*关于Zappa的部署工作流程，Zappa配置API网关以使用代理传递机制调用AWS Lambda，这在API网关接口上创建了一个API。每个API都支持各种阶段。在我们的情况下，我们在部署应用程序时创建了一个`dev`阶段。因此，以下屏幕截图显示了API网关控制台的状态：
- en: '![](img/00098.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00098.jpeg)'
- en: API Gateway supports API keys mechanisms, where you can create an API key along
    with a usage plan. With the help of this API key, you can restrict access for
    your customers. Any customer can access the API if they set the `x-api-key` header
    with the API key value. The API key can be mapped against any API or stage.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: API Gateway支持API密钥机制，您可以创建一个API密钥以及使用计划。借助这个API密钥，您可以限制客户的访问。任何客户都可以在API中设置`x-api-key`头与API密钥值来访问API。API密钥可以映射到任何API或阶段。
- en: 'The following screenshot shows you the manual process of creating an API key:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了创建API密钥的手动过程：
- en: '![](img/00099.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00099.jpeg)'
- en: The manual process of creating the API Key can be eliminated using Zappa. That's
    where Zappa plays an important role, as it will automate the entire process just
    by configuring the Zappa settings.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Zappa可以消除创建API密钥的手动过程。这就是Zappa发挥重要作用的地方，因为它将通过配置Zappa设置自动化整个过程。
- en: Zappa provides the `api_key_required` attribute with a Boolean value. `api_key_required`
    is set to `false` by default, but if you want to generate the API key, then you
    need to set it to `true`. Once you set this attribute to `true`, then you are
    required to redeploy the application.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Zappa提供了一个布尔值的`api_key_required`属性。`api_key_required`默认设置为`false`，但如果您想生成API密钥，则需要将其设置为`true`。一旦将此属性设置为`true`，则需要重新部署应用程序。
- en: The `api_key_required` settings don't work with the `zappa update` command;
    it only works with the `zappa deploy` command. Therefore, you need to undeploy
    the application and remove `CNAME` of your deployed custom domain from Route 53
    and then remove the Custom domain from the API Gateway console. Once you remove
    these, then you can deploy the application once again.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`api_key_required`设置不适用于`zappa update`命令；它只适用于`zappa deploy`命令。因此，您需要取消部署应用程序，并从Route
    53中删除已部署的自定义域的`CNAME`，然后从API Gateway控制台中删除自定义域。一旦删除了这些，就可以再次部署应用程序。'
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'File—`zappa_settings.json`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 文件-`zappa_settings.json`：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, you can perform the fresh deployment again using the `zappa deploy` command,
    as mentioned in the following log snippet:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以再次使用`zappa deploy`命令执行新的部署，如下面的日志片段所示：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that Zappa will generate the new `x-api-key` and return the API key ID,
    as mentioned in the preceding log snippet.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Zappa将生成新的`x-api-key`并返回API密钥ID，如前面的日志片段所述。
- en: 'Once you are done with the deployment, you will be able to see the auto-generated
    API key in the API Gateway console, as shown here:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 部署完成后，您将能够在API Gateway控制台中看到自动生成的API密钥，如此处所示：
- en: '![](img/00100.jpeg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00100.jpeg)'
- en: As shown in the preceding screenshot, you can use the API key value in Zappa
    settings to associate the Zappa deployed API with this key so that the API application
    needs you to have this value in the `x-api-key` header.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，您可以在Zappa设置中使用API密钥值，将Zappa部署的API与此密钥关联，以便API应用程序需要您在`x-api-key`头中具有此值。
- en: 'The next step is to associate the API key with a usage plan by clicking on
    `Add to Usage Plan` in the Associated Usage Plans section that''s shown in the
    preceding screenshot. The API key can be associated with multiple usage plans.
    These￼ plans enable you to define a good structure usage plan for your customers
    as per your business model. The following is a screenshot of Chapter 11 Basic
    Usage Plan and its basic usage plan:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是通过单击前面截图中显示的`Associated Usage Plans`部分中的`Add to Usage Plan`将API密钥与使用计划关联起来。API密钥可以与多个使用计划关联。这些计划使您能够根据您的业务模型为客户定义良好的结构使用计划。以下是第11章Basic
    Usage Plan及其基本使用计划的截图：
- en: '![](img/00101.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00101.jpeg)'
- en: 'As you can see in the preceding screenshot, the usage plan enables you to define
    the throttling limit and timely bounded API request quota for each API key. Once
    you have defined the plan, then you can associate it with any deployed API and
    their respective stages, as mentioned in the following screenshot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，使用计划使您能够为每个API密钥定义限流限制和及时限定的API请求配额。一旦定义了计划，就可以将其与任何部署的API及其各自的阶段关联，如下面的截图所示：
- en: '![](img/00102.jpeg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00102.jpeg)'
- en: We linked the Chapter 11 Basic Usage Plan`dev` API with the `dev` stage to this
    plan. This is how you can set up a business plan of your API for your customers
    and share the API Key to provide authorized access.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将第11章的`Basic Usage Plan` `dev` API与`dev`阶段链接到了这个计划。这就是您可以为客户设置API的业务计划并共享API密钥以提供授权访问的方法。
- en: Now, let's use the API key value that's in the preceding API key screenshot
    in the `zappa_settings.json` file with the ` "api_key"` attribute. The following
    is the updated `zappa_settings.json` file.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`zappa_settings.json`文件中使用前面API密钥截图中的API密钥值，并使用`"api_key"`属性。以下是更新后的`zappa_settings.json`文件。
- en: 'File—`zappa_settings.json`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 文件-`zappa_settings.json`：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'That''s it. Let''s update the deployment once again using the `zappa update`
    command, as shown in the following mentioned log snippet:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。让我们再次使用`zappa update`命令更新部署，如下面提到的日志片段所示：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We are done with enabling the API key authentication. Let's move on to the next
    section to see the API's execution.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了启用API密钥认证。让我们继续下一节，看看API的执行情况。
- en: Executing the API with the API key header
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用API密钥头执行API
- en: We enabled the API key's authentication, and so the API key is mandatory with
    the `x-api-key` header. If a request hits the API without the `x-api-key` header,
    then it would be denied access with the forbidden response. If a user provides
    the valid API key value in the `x-api-key` header, then it would be allowed to
    access the API resource.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启用了API密钥的认证，因此API密钥与`x-api-key`头是强制的。如果请求没有`x-api-key`头，将被拒绝访问并返回禁止响应。如果用户在`x-api-key`头中提供有效的API密钥值，则将被允许访问API资源。
- en: 'API execution without the `x-api-key` header is as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 没有`x-api-key`头的API执行如下：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'API execution with the `x-api-key` header is as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`x-api-key`头的API执行如下：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We are done with the API key authentication integration. Let's move on to the
    next section, where we will be exploring another option of authentication using
    the IAM policy.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了API密钥身份验证集成。让我们继续下一节，我们将探索使用IAM策略进行身份验证的另一种选项。
- en: IAM policy
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IAM策略
- en: 'Amazon API Gateway supports IAM-based V4 signing request authentication. The
    API Gateway requires a user to authenticate the request by signing the request.
    Signing a request is a complete flow of creating a digital signature using the
    cryptographic function. You can read more about the Signing Request process at
    the following links:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon API Gateway支持基于IAM的V4签名请求身份验证。API Gateway要求用户通过对请求进行签名来进行身份验证。签署请求是使用加密函数创建数字签名的完整流程。您可以在以下链接中阅读有关签署请求过程的更多信息：
- en: '[https://docs.aws.amazon.com/apigateway/api-reference/signing-requests/](https://docs.aws.amazon.com/apigateway/api-reference/signing-requests/)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.aws.amazon.com/apigateway/api-reference/signing-requests/](https://docs.aws.amazon.com/apigateway/api-reference/signing-requests/)'
- en: Zappa enables this feature by setting the `"iam_authorization"` attribute to
    `true` in Zappa's settings. This attribute is set to `false` by default. Therefore,
    you can explicitly set it to true in order enable the IAM-based authentication.
    This feature enables you to access the API resources based on the IAM policy.
    You can control this access via the IAM policy ([https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-iam-policy-examples.html](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-iam-policy-examples.html)).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Zappa通过在Zappa的设置中将`"iam_authorization"`属性设置为`true`来启用此功能。此属性默认设置为`false`。因此，您可以显式将其设置为true，以启用基于IAM的身份验证。此功能使您能够根据IAM策略访问API资源。您可以通过IAM策略([https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-iam-policy-examples.html](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-iam-policy-examples.html))来控制此访问。
- en: For demonstration purposes, I am going to create a different stage and custom
    domain for the same application. The following is a snippet of Zappa's settings.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，我将为同一应用程序创建一个不同的阶段和自定义域。以下是Zappa设置的片段。
- en: 'File—`zappa_settings.json`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '文件-`zappa_settings.json`:'
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we created a different stage with `iam_authentication`. This flag will
    enable IAM-based authentication. Now, again, you need to perform deploy, update,
    and certify operations to make this stage live with the following domain.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个带有`iam_authentication`的不同阶段。此标志将启用基于IAM的身份验证。现在，您需要执行部署、更新和认证操作，以使此阶段与以下域名一起生效。
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, you are required to sign the request to access the deployed resource. Signing
    a request requires that you follow some processes, as mentioned here: [https://docs.aws.amazon.com/apigateway/api-reference/signing-requests/](https://docs.aws.amazon.com/apigateway/api-reference/signing-requests/).
    There are also many third-party libraries available to generate the required headers
    for signing the request. We are going to use the `requests-aws-sign` ([https://github.com/jmenga/requests-aws-sign](https://github.com/jmenga/requests-aws-sign))
    library to access the API resource with a signed request.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您需要对请求进行签名以访问部署的资源。签署请求需要您遵循一些流程，如此处所述：[https://docs.aws.amazon.com/apigateway/api-reference/signing-requests/](https://docs.aws.amazon.com/apigateway/api-reference/signing-requests/)。还有许多第三方库可用于生成签署请求所需的标头。我们将使用`requests-aws-sign`([https://github.com/jmenga/requests-aws-sign](https://github.com/jmenga/requests-aws-sign))库来使用签名请求访问API资源。
- en: The following is a code snippet of signing a request to access the API resource.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是签署请求以访问API资源的代码片段。
- en: 'File—`aws_sign_request_test.py`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '文件-`aws_sign_request_test.py`:'
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'That''s it! Now, you can see the output of the preceding script, as shown in
    the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！现在，您可以看到前面脚本的输出，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Finally, we got API access with a signed request. This way, you can secure your
    serverless API application with IAM authentication. Let's move on to the next
    section, where we are going to explore another way of securing the serverless
    API application.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过签名请求获得了API访问权限。通过这种方式，您可以使用IAM身份验证保护无服务器API应用程序。让我们继续下一节，我们将探索保护无服务器API应用程序的另一种方式。
- en: API Gateway Lambda authorizer
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API Gateway Lambda授权程序
- en: The Amazon API Gateway Lambda authorizer is a simple AWS Lambda function that
    acts as an authorizer to control access to API Gateway resources. This is because
    the Lambda authorizer will be responsible for verifying requests via the bearer
    token form authorization header and returning a valid IAM policy. You can write
    your custom Lambda authorizer with different authentication strategies based on **JWT**
    (**JSON Web Token**), OAuth, or SAML.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon API Gateway Lambda授权程序是一个简单的AWS Lambda函数，作为授权程序来控制对API Gateway资源的访问。这是因为Lambda授权程序将负责通过bearer
    token形式的授权头验证请求，并返回有效的IAM策略。您可以根据**JWT**（JSON Web Token）、OAuth或SAML编写自定义的Lambda授权程序，具有不同的身份验证策略。
- en: You can add the authorizer from the API Gateway console, as mentioned in the
    official AWS documentation ([https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html)),
    or you can create the Lambda authorizer from a Lambda blueprint named `api-gateway-authorizer-python`
    ([https://github.com/awslabs/aws-apigateway-lambda-authorizer-blueprints/blob/master/blueprints/python/api-gateway-authorizer-python.py](https://github.com/awslabs/aws-apigateway-lambda-authorizer-blueprints/blob/master/blueprints/python/api-gateway-authorizer-python.py))
    and then associate this Lambda function as an authorizer to your API resource
    from the API Gateway console.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从API Gateway控制台添加授权程序，如官方AWS文档中所述([https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html))，或者您可以从名为`api-gateway-authorizer-python`的Lambda蓝图创建Lambda授权程序([https://github.com/awslabs/aws-apigateway-lambda-authorizer-blueprints/blob/master/blueprints/python/api-gateway-authorizer-python.py](https://github.com/awslabs/aws-apigateway-lambda-authorizer-blueprints/blob/master/blueprints/python/api-gateway-authorizer-python.py))，然后从API
    Gateway控制台将此Lambda函数关联为API资源的授权程序。
- en: Once you have configured the authorizer, the API Gateway expects a request along
    with a bearer token or parameters in the authorization header. It denies the request
    in the case of a missing authorization header. If a client sends a request with
    a bearer token in the authorization header to your API resource, then the API
    Gateway extracts the bearer token and other params from the request header and
    supplies them as event parameters to the Lambda authorizer function. The Lambda
    authorizer verifies the token with existing AWS IAM policies or the AWS Cognito
    users pool and then returns the IAM policies to authorize the request. The API
    Gateway maintains a session for subrequests by caching the return policy with
    the request token over a period of pre-configured **TTL** (**time-to-live**) from
    300 to 3,600 seconds, the default being 300 seconds.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您配置了授权者，API网关期望请求以及授权头中的持有者令牌或参数。如果缺少授权头，它将拒绝请求。如果客户端向您的API资源发送带有持有者令牌的请求授权头，那么API网关将从请求头中提取持有者令牌和其他参数，并将它们作为事件参数提供给Lambda授权者函数。Lambda授权者使用现有的AWS
    IAM策略或AWS Cognito用户池验证令牌，然后返回IAM策略以授权请求。API网关通过在预配置的**TTL**（**生存时间**）期间缓存请求令牌的返回策略来维护子请求的会话，从300到3600秒，
    默认为300秒。
- en: 'Zappa supports an easier way to configure the Lambda authorizer. You can define
    the authorizer attribute in the Zappa settings as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Zappa支持一种更简单的方法来配置Lambda授权者。您可以在Zappa设置中定义授权者属性如下：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can define the preceding attributes. Each attribute has its own specific
    usage in order to define a custom Lambda authorizer. Let''s explore these attributes
    in more detail:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义前面的属性。每个属性都有其自己的特定用途，以定义自定义Lambda授权者。让我们更详细地探讨这些属性：
- en: '`function`: This will be your own local function to execute token validation.
    Zappa will automatically create and map this function as an authorizer for your
    API in the API Gateway.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`function`：这将是您自己的本地函数，用于执行令牌验证。Zappa将自动创建并映射此函数作为API网关中的授权者。'
- en: '`arn`: This will be the `arn` of your existing Lambda function to verify the
    token. If you choose the blueprint Lambda authorizer function, `api-gateway-authorizer-python`
    ([https://github.com/awslabs/aws-apigateway-lambda-authorizer-blueprints/blob/master/blueprints/python/api-gateway-authorizer-python.py](https://github.com/awslabs/aws-apigateway-lambda-authorizer-blueprints/blob/master/blueprints/python/api-gateway-authorizer-python.py)),
    then you can put in the `arn` of your Lambda function that was created by the
    blueprint.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arn`：这将是您现有Lambda函数的`arn`，用于验证令牌。如果您选择蓝图Lambda授权者函数`api-gateway-authorizer-python`（[https://github.com/awslabs/aws-apigateway-lambda-authorizer-blueprints/blob/master/blueprints/python/api-gateway-authorizer-python.py](https://github.com/awslabs/aws-apigateway-lambda-authorizer-blueprints/blob/master/blueprints/python/api-gateway-authorizer-python.py)），那么您可以放入由蓝图创建的Lambda函数的`arn`。'
- en: '`result_ttl`: This is an optional attribute. It enables the **time-to-live** (**TTL**)
    period to cache the authorizer result via the API Gateway. By default, it is set
    to 300 seconds and you can set it to a maximum of 3,600 seconds.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`result_ttl`：这是一个可选属性。它通过API网关启用**生存时间**（**TTL**）周期来缓存授权者结果。默认情况下，它设置为300秒，您可以将其设置为最多3600秒。'
- en: '`token_header`: This is an optional attribute. It is used to set the name of
    the custom authorization header. It contains the token as part of a submitted
    request by the client.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`token_header`：这是一个可选属性。它用于设置自定义授权头的名称。它包含客户端提交的请求的一部分令牌。'
- en: '`validation_expression`: This is an optional attribute. It is used to set the
    validation expression of the token in the authorization header. By default, it
    supports the `"^Bearer \\w+$"` expression to validate the token expression.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validation_expression`：这是一个可选属性。它用于设置授权头中令牌的验证表达式。默认情况下，它支持`"^Bearer \\w+$"`表达式来验证令牌表达式。'
- en: This is how you can create a custom Lambda authorizer for your serverless API.
    This enables you to create a centralized authentication for all your distributed
    API microservices that are deployed by Zappa.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您可以为无服务器API创建自定义Lambda授权者的方法。这使您能够为Zappa部署的所有分布式API微服务创建集中式身份验证。
- en: Now, let's move ahead to the next section, where we will be exploring the tracing
    mechanism of AWS failure.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一节，我们将探讨AWS失败的跟踪机制。
- en: Tracing AWS Lambda failure with dead letter queues
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用死信队列跟踪AWS Lambda失败
- en: '**Dead letter queues** (**DLQ**) is a defined mechanism by Amazon to trace
    the failure of AWS Lambda functions executing asynchronously. AWS Lambda invokes
    asynchronous mode and retires it twice in case of failure before the event is
    discarded. DLQ is used to proceed this failure event to an Amazon SQS queue or
    Amazon SNS topic.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**死信队列**（**DLQ**）是亚马逊定义的机制，用于跟踪AWS Lambda函数在异步执行时的失败。AWS Lambda在事件被丢弃之前，会以异步模式调用并在失败的情况下重试两次。DLQ用于将此失败事件传递到Amazon
    SQS队列或Amazon SNS主题。'
- en: Manual DLQ configuration
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动DLQ配置
- en: 'DLQ can be configured by setting `TargetArn` (that is, the SQS queue ARN or
    SNS topic ARN) on the Lambda function''s `DeadLetterConfig` parameter, as mentioned
    here:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: DLQ可以通过在Lambda函数的`DeadLetterConfig`参数上设置`TargetArn`（即SQS队列ARN或SNS主题ARN）来进行配置，如下所述：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Automating DLQ configuration with Zappa
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Zappa自动化DLQ配置
- en: In order to automate this process, Zappa enables this feature by setting up
    the SQS queue/SNS topic ARN value to `dead_letter_arn`*.* We created an SNS topic
    in [Chapter 9](part0219.html#6GRB60-8241a43bed654018b51365a570bcef1d), *Asynchronous
    Task Execution on AWS Lambda,* which was named `UnhandledException`. So, let's
    use the existing SNS topic, which is already subscribed with my email. DQL will
    only trigger if an asynchronous Lambda function invocation fails and retires.
    Then, DQL will process the failure exception as a message to the configured SNS
    topic and we will receive the processed exception data on an subscribed email.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自动化这个过程，Zappa通过将SQS队列/SNS主题ARN值设置为`dead_letter_arn`来启用这个功能。我们在[第9章](part0219.html#6GRB60-8241a43bed654018b51365a570bcef1d)中创建了一个名为`UnhandledException`的SNS主题，让我们使用现有的SNS主题，它已经订阅了我的电子邮件。只有在异步Lambda函数调用失败和重试时，DQL才会触发。然后，DQL将把故障异常处理为消息发送到配置的SNS主题，我们将在订阅的电子邮件上收到处理后的异常数据。
- en: Now, the following code snippet is for the updated Zappa settings.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，以下代码片段是更新后的Zappa设置。
- en: 'File—`zappa_settings.json`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 文件-`zappa_settings.json`：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, I updated the `dead_letter_arn` attribute for the `dev` stage only. Hence,
    this feature will be available for the `dev` stage. Now, we are all set with DLQ
    with our `dev` stage Lambda function. Once you are done with this configuration,
    you are required to perform the deployment using the `zappa deploy` command. That's
    it! Now, we should have an asynchronous Lambda function mechanism in our code
    that raises an exception at runtime.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我只为`dev`阶段更新了`dead_letter_arn`属性。因此，这个功能将在`dev`阶段可用。现在，我们已经在`dev`阶段的Lambda函数中设置好了DLQ。完成配置后，您需要使用`zappa
    deploy`命令进行部署。就是这样！现在，我们的代码中应该有一个异步的Lambda函数机制，在运行时引发异常。
- en: Please note that for Lambda function-specific changes, you are required to redeploy
    your function using the `zappa deploy` command. The `zappa update` command will
    not work here as it is responsible for updating the existing code base, not Lambda
    configurations.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于特定Lambda函数的更改，您需要使用`zappa deploy`命令重新部署函数。`zappa update`命令在这里不起作用，因为它负责更新现有的代码库，而不是Lambda配置。
- en: Raising exceptions in the asynchronous Lambda function
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在异步Lambda函数中引发异常
- en: In order to raise an exception in the asynchronous Lambda invocation, we need
    to have a mechanism to instantiate an asynchronous Lambda function. Let's write
    a resource API and call an asynchronous task, which will raise an exception.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在异步Lambda调用中引发异常，我们需要有一个机制来实例化一个异步Lambda函数。让我们编写一个资源API并调用一个异步任务，这将引发异常。
- en: 'The following is the updated code of `resources.py`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`resources.py`的更新代码：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we created an `AsyncTaskResource` as a resource class for the `"/async-failure"`
    route. This route is defined with the HTTP `GET` request using the `on_get` method
    in the `AsyncTaskResource` class. We also created the `async_task` method as an
    asynchronous method using the task decorator. We have already seen the implementation
    of asynchronous tasks using Zappa in [Chapter 9](part0219.html#6GRB60-8241a43bed654018b51365a570bcef1d),
    *Asynchronous Task Execution on AWS Lambda*. The task decorator will asynchronously
    execute the method in a separate Lambda instance.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个`AsyncTaskResource`作为`"/async-failure"`路由的资源类。这个路由使用`AsyncTaskResource`类中的`on_get`方法定义了HTTP
    `GET`请求。我们还使用任务装饰器将`async_task`方法创建为一个异步方法。我们已经在[第9章](part0219.html#6GRB60-8241a43bed654018b51365a570bcef1d)中看到了使用Zappa执行异步任务的实现，任务装饰器将在单独的Lambda实例中异步执行该方法。
- en: From `async_task`, we are raising a `ValueError` exception. This will result
    in the asynchronous Lambda execution's failure and will raise the DLQ event on
    subsequent failure. DLQ will process the exception data to our configured SNS
    topic ARN. Finally, we will get the exception information in our email.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从`async_task`中，我们引发了一个`ValueError`异常。这将导致异步Lambda执行失败，并在随后的失败时引发DLQ事件。DLQ将把异常数据处理到我们配置的SNS主题ARN。最后，我们将在电子邮件中收到异常信息。
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We requested the `/async-failure` API, which responded immediately and instantiated
    the task in an asynchronous Lambda function. As we explicitly raised an exception
    in the `async_task` method, this will invoke the DLQ and process the exception
    information by publishing to the SNS topic. The following is a screenshot of the
    email notification received from the AWS Notification Message:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们请求了`/async-failure` API，它立即响应并在异步Lambda函数中实例化了任务。由于我们在`async_task`方法中明确引发了异常，这将调用DLQ并通过发布到SNS主题来处理异常信息。以下是从AWS通知消息收到的电子邮件通知的截图：
- en: '![](img/00103.jpeg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00103.jpeg)'
- en: This way, we can trace the unknown failure. This feature will help us improve
    the application's quality and reduce the failure rate. Let's move on to the next
    section, where we are going to explore analyzing the Zappa application using AWS
    X-Ray.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就可以追踪未知的故障。这个功能将帮助我们提高应用程序的质量并减少故障率。让我们继续下一节，我们将探讨如何使用AWS X-Ray分析Zappa应用程序。
- en: Analyzing the Zappa application with AWS X-Ray
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AWS X-Ray分析Zappa应用程序
- en: AWS X-Ray is an analytics service provided by Amazon Web Services. It helps
    developers to perform analysis on the application behavior and working flow. With
    the help of X-Ray, developers can understand the application's performance and
    trace the root cause in order to improve optimization.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: AWS X-Ray是亚马逊网络服务提供的分析服务。它帮助开发人员对应用程序的行为和工作流程进行分析。借助X-Ray，开发人员可以了解应用程序的性能并追踪根本原因以改进优化。
- en: AWS X-Ray can be enabled on any compute AWS services. Once you have enabled
    X-Ray, it starts to generate data segments based on application interaction. For
    example, if you make an HTTP request to your application, then X-Ray will generate
    data about the host, request, response, computed time, and errors. Based on these
    segments of data, X-Ray generates a service graph.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: AWS X-Ray可以在任何计算AWS服务上启用。一旦您启用了X-Ray，它就会根据应用程序的交互生成数据段。例如，如果您向应用程序发出HTTP请求，那么X-Ray将生成有关主机、请求、响应、计算时间和错误的数据。基于这些数据段，X-Ray生成了一个服务图。
- en: The service graph provides a visualized pattern for the developers to understand
    the application workflow and helps to determine its performance. Apart from the
    request and response data generation, X-Ray also generates records for your application
    interaction with AWS resource, microservices, databases, and HTTP Web API calls.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 服务图提供了一个可视化模式，供开发人员了解应用程序工作流程并帮助确定其性能。除了请求和响应数据生成外，X-Ray还为您的应用程序与AWS资源、微服务、数据库和HTTP
    Web API调用的交互生成记录。
- en: X-Ray manual integration with AWS Lambda
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS Lambda的X-Ray手动集成
- en: 'The AWS Lambda console has a privilege in that it can configure the Lambda
    function with AWS X-Ray. Hence, any interaction with AWS Lambda will be recorded
    by AWS X-Ray. You can enable X-Ray on your Lambda function by configuring the
    function from its console page, as shown in the following screenshot:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Lambda控制台具有特权，可以配置Lambda函数与AWS X-Ray。因此，任何与AWS Lambda的交互都将被AWS X-Ray记录。您可以通过从控制台页面配置函数来在Lambda函数上启用X-Ray，如下面的截图所示：
- en: '![](img/00104.jpeg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00104.jpeg)'
- en: 'Regarding the AWS Lambda console workflow, you are required to select AWS XRay.
    Then, you can configure its associated settings from the bottom panel of the main
    section, as shown in the following screenshot:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 关于AWS Lambda控制台工作流程，您需要选择AWS XRay。然后，您可以从主部分的底部面板配置其关联的设置，如下面的截图所示：
- en: '![](img/00105.jpeg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00105.jpeg)'
- en: Once you choose the X-Ray, the default execution role permissions will attach
    to your Lambda function. This way, AWS X-Ray will record the trace to your Lambda
    function API executions.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择了X-Ray，默认执行角色权限将附加到您的Lambda函数。这样，AWS X-Ray将记录对Lambda函数API执行的跟踪。
- en: Zappa configuration to enable AWS X-Ray support
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Zappa配置以启用AWS X-Ray支持
- en: Zappa is always here to avoid manual interactions in order to configure your
    Lambda function. Hence, Zappa provides an easy way to configure the AWS X-Ray
    with your Lambda function. You just need to set `"xray_tracing"` to `true` in
    your Zappa settings. This will automatically enable the X-Ray tracing support
    for your Lambda function.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Zappa始终在这里，以避免手动交互来配置您的Lambda函数。因此，Zappa提供了一种简单的方法来配置AWS X-Ray与您的Lambda函数。您只需在Zappa设置中将“xray_tracing”设置为`true`。这将自动为您的Lambda函数启用X-Ray跟踪支持。
- en: Let's create another stage of our existing API application. This stage will
    have a basic configuration without authentication and a custom domain, since we
    just want to demonstrate the X-Ray workflow. The following is the new stage configuration
    with X-Ray support.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建现有API应用的另一个阶段。这个阶段将具有基本配置，没有身份验证和自定义域，因为我们只是想演示X-Ray的工作流程。以下是具有X-Ray支持的新阶段配置。
- en: 'File—`zappa_settings.json`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 - `zappa_settings.json`：
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As mentioned previously, we've added a new stage named `"dev_xray"` with basic
    configuration and AWS X-Ray tracing support. Now, let's deploy this stage using
    the `zappa deploy` command.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们已经添加了一个名为“dev_xray”的新阶段，具有基本配置和AWS X-Ray跟踪支持。现在，让我们使用“zappa deploy”命令部署这个阶段。
- en: '[PRE34]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: That's it! Now, our Random Quote API is up and running with different stages.
    Once the application is deployed, Zappa generates a random API Gateway link, as
    mentioned in the preceding log snippet. Now, you can just hit the API using the
    curl tool.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！现在，我们的随机引用API已经在不同的阶段上线运行。一旦应用程序部署，Zappa将生成一个随机的API Gateway链接，如前面的日志片段中所述。现在，您可以使用curl工具来访问API。
- en: 'The following is the log snippet of the API''s execution:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是API执行的日志片段：
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We have integrated the AWS X-Ray, and so all our application''s interactions
    will be recorded as tracing segments by AWS X-Ray. The following is a screenshot
    of AWS X-Ray''s service map:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经集成了AWS X-Ray，因此我们应用程序的所有交互将被AWS X-Ray记录为跟踪段。以下是AWS X-Ray服务地图的截图：
- en: '![](img/00106.jpeg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00106.jpeg)'
- en: 'Here, you can see the tracing details of your application. These details are
    available as per the time frame on its console. AWS X-Ray supports the client
    SDK library, which enables the developer to persist these traces as per their
    requirements. AWS X-Ray''s client SDK has many implementations with languages
    and language-specific frameworks. You can read more about AWS X-Ray and its Python-based
    SDK library at the following links:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以查看应用程序的跟踪详细信息。这些详细信息根据其控制台上的时间范围可用。AWS X-Ray支持客户端SDK库，使开发人员能够根据其需求持久化这些跟踪。AWS
    X-Ray的客户端SDK具有许多实现，涵盖了多种语言和特定语言的框架。您可以在以下链接了解有关AWS X-Ray及其基于Python的SDK库的更多信息：
- en: '[https://docs.aws.amazon.com/xray/latest/devguide/aws-xray.html](https://docs.aws.amazon.com/xray/latest/devguide/aws-xray.html)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.aws.amazon.com/xray/latest/devguide/aws-xray.html](https://docs.aws.amazon.com/xray/latest/devguide/aws-xray.html)'
- en: '[https://github.com/aws/aws-xray-sdk-python](https://github.com/aws/aws-xray-sdk-python)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/aws/aws-xray-sdk-python](https://github.com/aws/aws-xray-sdk-python)'
- en: Let's move on to the next section, where we will be exploring AWS VPC integration
    with your AWS Lambda function.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续下一节，我们将探讨AWS VPC与AWS Lambda函数的集成。
- en: Securing your Zappa application using AWS VPC
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AWS VPC保护您的Zappa应用程序
- en: AWS **Virtual Private Cloud** (**VPC**) is an isolated virtual network service
    dedicated to AWS resources. It's similar to a traditional network mechanism in
    your own data center. AWS VPC enables you to secure your AWS resources from unauthorized
    access. AWS provides a default VPC for each region. The default VPC helps you
    configure all of your AWS resources.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: AWS **虚拟私有云**（**VPC**）是专门为AWS资源提供的隔离虚拟网络服务。它类似于您自己数据中心中的传统网络机制。AWS VPC使您能够保护AWS资源免受未经授权的访问。AWS为每个区域提供了默认VPC。默认VPC可帮助您配置所有AWS资源。
- en: AWS VPC is dedicated to your AWS account and enables an isolated layer. You
    can configure your AWS resources with the AWS VPC. Once you enable the VPC for
    your AWS resources, then you can specify the following components as per your
    requirements, such as IP address range, subnets, security groups, route tables,
    and others. These components are used to set up the networking policy and strategies.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: AWS VPC专门为您的AWS账户提供了隔离层。您可以使用AWS VPC配置您的AWS资源。启用VPC后，您可以根据需要指定以下组件，例如IP地址范围、子网、安全组、路由表等。这些组件用于设置网络策略和策略。
- en: Manual configuration of VPC
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VPC的手动配置
- en: 'AWS Lambda has the privilege of configuring the VPC. The following is a screenshot
    of the AWS Lambda configuration:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Lambda有配置VPC的特权。以下是AWS Lambda配置的屏幕截图：
- en: '![](img/00107.jpeg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00107.jpeg)'
- en: As shown in the preceding screenshot, we have selected a default VPC. We need
    to configure other components, such as subnets and security groups, that are mandatory.
    Subnets is a range of IP addresses in the VPC. You should use a public subnet
    for any resource which requires internet access. The private subnet is used for
    any resource that doesn't require that you connect to the internet.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，我们选择了默认VPC。我们需要配置其他组件，如子网和安全组，这是必需的。子网是VPC中的IP地址范围。对于需要互联网访问的任何资源，应使用公共子网。私有子网用于不需要连接到互联网的任何资源。
- en: Security groups, on the other hand, define the inbound and outbound rules for
    authorizing any protocol access.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，安全组定义了授权任何协议访问的入站和出站规则。
- en: AWS VPC has a complete implementation of the secure network layer. To understand
    each and every aspect of the VPC concept, you should read its official documentation
    [(](https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Introduction.html)[https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Introduction.html](https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Introduction.html)).
    We will be focusing on Zappa configuration to enable VPC in an automated way.
    Let's move on to the next section, where we will be configuring Zappa with VPC.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: AWS VPC具有完整的安全网络层实现。要了解VPC概念的每个方面，您应该阅读其官方文档[(](https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Introduction.html)[https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Introduction.html](https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Introduction.html))。我们将专注于Zappa配置，以便以自动化方式启用VPC。让我们继续下一节，在那里我们将配置Zappa与VPC。
- en: VPC configuration using Zappa
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Zappa进行VPC配置
- en: 'Zappa has an optimized way of automating the VPC with the deployed application.
    All you need to provide is the `vpc_config` attribute with subnet and security
    groups IDs, as mentioned here:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Zappa有一种优化的方式来自动化部署应用程序的VPC。您只需要提供`vpc_config`属性和子网和安全组ID，如此处所述：
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'I mentioned the default VPC in the previous section. You can get the default
    subnet IDs from the VPC dashboard page, as shown in the following screenshot:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我在前一节中提到了默认VPC。您可以从VPC仪表板页面获取默认子网ID，如下面的屏幕截图所示：
- en: '![](img/00108.jpeg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00108.jpeg)'
- en: 'You can get the security group IDs by selecting Security Groups from the left
    panel, as shown in the following screenshot:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过从左侧面板选择安全组来获取安全组ID，如下面的屏幕截图所示：
- en: '![](img/00109.jpeg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00109.jpeg)'
- en: Now, we are going to create another deployment stage with VPC configuration.
    You need to put the subnet IDs and security group IDs from the preceding screenshots
    and configure them using Zappa settings, as shown in the following code snippet.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建另一个带有VPC配置的部署阶段。您需要从前面的屏幕截图中放入子网ID和安全组ID，并使用Zappa设置进行配置，如下面的代码片段所示。
- en: 'File—`zappa_settings.json`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 文件—`zappa_settings.json`：
- en: '[PRE38]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'AWS VPC is an isolated network, hence any service running inside the VPC network
    will not have access to the public internet. In case, you require to have access
    for public internet for any resources then you must have at least two subnets.
    With following settings in VPC dashboard:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: AWS VPC是一个隔离的网络，因此在VPC网络内运行的任何服务都无法访问公共互联网。如果需要为任何资源访问公共互联网，则必须至少有两个子网。在VPC仪表板中使用以下设置：
- en: 'For `subnet-a`:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`subnet-a`：
- en: Select the NAT Gateway section and create a NAT Gateway.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 选择NAT网关部分并创建一个NAT网关。
- en: Select the Internet Gateway section and create an Internet Gateway.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 选择Internet网关部分并创建一个Internet网关。
- en: From the route table section, create a route named as `route-a` pointing the
    Internet Gateway to `0.0.0.0/0`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 从路由表部分，创建一个名为`route-a`的路由，将Internet网关指向`0.0.0.0/0`。
- en: 'For `subnet-b`:'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`subnet-b`：
- en: Configure your Lambda function with this subnet.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此子网配置您的Lambda函数。
- en: From the route table section, create a route named as `route-b` pointing the
    NAT that belongs to `subnet-a` to `0.0.0.0/0`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 从路由表部分，创建一个名为`route-b`的路由，将属于`subnet-a`的NAT指向`0.0.0.0/0`。
- en: '[PRE39]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: That's it. Now, our application has been configured with AWS VPC successfully.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。现在，我们的应用已成功配置了AWS VPC。
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about different security mechanisms and demonstrated
    their implementation with a small API-based application. AWS has a very good security
    architecture, but it involves manual interaction processes, whereas Zappa automates
    these processes and prevents manual interaction. We also covered tracing, analytics,
    and the notification process of optimizing the application's workflow.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了不同的安全机制，并演示了它们在一个小型基于API的应用程序中的实现。AWS拥有非常好的安全架构，但涉及手动交互过程，而Zappa自动化了这些过程并防止了手动交互。我们还涵盖了优化应用程序工作流程的跟踪、分析和通知过程。
- en: In the next chapter, we are going to explore Zappa development, along with Docker
    containerization. Stay tuned so that you can sharpen a new skill set.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Zappa开发，以及Docker容器化。请继续关注，以便您可以提升新的技能。
- en: Questions
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is an API Gateway authorizer?
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是API网关授权者？
- en: What is AWS Lambda DQL?
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是AWS Lambda DQL？
- en: Why is AWS VPC important?
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么AWS VPC很重要？
