- en: Chapter 10. Testing and Logging – Preparing for Bugs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。测试和日志 - 为错误做准备
- en: When programming, most developers plan a bit and immediately continue writing
    code. After all, we all expect to write bug-free code! Unfortunately, we don't.
    At some point, an incorrect assumption, a misinterpretation, or just a silly mistake
    is bound to happen. Debugging (covered in [Chapter 11](ch11.html "Chapter 11. Debugging
    – Solving the Bugs"), *Debugging – Solving the Bugs*) will always be required
    at some point, but there are several methods that you can use to prevent bugs
    or, at the very least, make it much easier to solve them when they do occur.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程时，大多数开发人员会稍微计划一下，然后立即继续编写代码。毕竟，我们都希望写出没有错误的代码！不幸的是，我们并没有。在某个时候，一个错误的假设、一个误解，或者只是一个愚蠢的错误都是不可避免的。调试（在[第11章](ch11.html
    "第11章。调试 - 解决错误")中讨论，*调试 - 解决错误*）总是需要的，但有几种方法可以用来预防错误，或者至少在发生错误时更容易解决它们。
- en: To prevent bugs from occurring in the first place, test-driven development or,
    at the very least, functional/regression/unit tests are very useful. The standard
    Python installation alone offers several options such as the `doctest`, `unittest`,
    and `test` modules. The `doctest` module allows you to combine tests with example
    documentation. The `unittest` module allows you to easily write regression tests.
    The `test` module is meant for internal usage only, so unless you are planning
    to modify the Python core, you probably won't need this one.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止错误发生，测试驱动开发或者至少是功能/回归/单元测试非常有用。标准的Python安装本身就提供了几个选项，比如`doctest`、`unittest`和`test`模块。`doctest`模块允许你将测试与示例文档结合起来。`unittest`模块允许你轻松编写回归测试。`test`模块仅用于内部使用，所以除非你打算修改Python核心，否则可能不需要这个模块。
- en: 'The test modules we will discuss in this chapter are:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章讨论以下测试模块：
- en: '`doctest`'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doctest`'
- en: '`py.test` (and why it''s more convenient than `unittest`)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`py.test`（以及为什么它比`unittest`更方便）'
- en: '`unittest.mock`'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unittest.mock`'
- en: The `py.test` module has roughly the same purpose as the `unittest` module,
    but it's much more convenient to use and has a few extra options.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`py.test`模块的目的与`unittest`模块大致相同，但使用起来更加方便，并且有一些额外的选项。'
- en: After learning how to avoid the bugs, it's time to take a look at logging so
    that we can inspect what is happening in our program and why. The logging module
    in Python is highly configurable and can be adjusted for just about any use case.
    If you've ever written Java code, you should feel right at home with the `logging`
    module, as its design is largely based on the `log4j` module and is very similar
    in both implementation and naming. The latter makes it a bit of an odd module
    in Python as well, as it is one of the few modules that do not follow the `pep8`
    naming standards.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习如何避免错误之后，现在是时候看看日志记录，以便我们可以检查程序中发生了什么以及为什么。Python中的日志记录模块是高度可配置的，可以根据几乎任何用例进行调整。如果你曾经编写过Java代码，你应该对`logging`模块感到非常熟悉，因为它的设计在很大程度上基于`log4j`模块，并且在实现和命名上非常相似。后者也使得它在Python中有点奇怪，因为它是少数几个不遵循`pep8`命名标准的模块之一。
- en: 'This chapter will explain the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将解释以下主题：
- en: Combining documentation with tests using `doctest`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`doctest`结合文档和测试
- en: Regression and unit tests using `py.test` and `unittest`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`py.test`和`unittest`进行回归和单元测试
- en: Testing with fake objects using `unittest.mock`
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`unittest.mock`使用虚假对象进行测试
- en: Using the `logging` module effectively
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效使用`logging`模块
- en: Combining `logging` and `py.test`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`logging`和`py.test`结合
- en: Using examples as tests with doctest
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用doctest作为测试的示例
- en: The `doctest` module is one of the most useful modules within Python. It allows
    you to combine documenting your code with tests to make sure that it keeps working
    as it is supposed to.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest`模块是Python中最有用的模块之一。它允许你将代码文档化和测试结合起来，以确保它能够按照预期的方式继续工作。'
- en: A simple doctest example
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的doctest示例
- en: 'Let''s start with a quick example: a function that squares the input. The following
    example is a fully functional command-line application, containing not only code
    but also functioning tests. The first few tests cover how the function is supposed
    to behave when executing normally, followed by a few tests to demonstrate the
    expected errors:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个快速示例开始：一个对输入进行平方的函数。以下示例是一个完全功能的命令行应用程序，包含了代码和运行测试。前几个测试覆盖了函数在正常执行时应该如何行为，然后是一些测试来演示预期的错误：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It can be executed as any Python script, but the regular command won''t give
    any output as all tests are successful. The `doctest.testmod` function takes verbosity
    parameters, luckily:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以像任何Python脚本一样执行，但是常规命令不会产生任何输出，因为所有测试都成功了。幸运的是，`doctest.testmod`函数接受冗长参数：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Additionally, since it uses the Google syntax (as discussed in [Chapter 9](ch09.html
    "Chapter 9. Documentation – How to Use Sphinx and reStructuredText"), *Documentation
    – How to Use Sphinx and reStructuredText*, the documentation chapter), we can
    generate pretty documentation using Sphinx:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于它使用了Google语法（如[第9章](ch09.html "第9章。文档 - 如何使用Sphinx和reStructuredText")中讨论的，*文档
    - 如何使用Sphinx和reStructuredText*，文档章节），我们可以使用Sphinx生成漂亮的文档：
- en: '![A simple doctest example](images/4711_10_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![一个简单的doctest示例](images/4711_10_01.jpg)'
- en: However, the code is not always correct, of course. What would happen if we
    modify the code so that the tests do not pass anymore?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，代码并不总是正确的。如果我们修改代码，使得测试不再通过，会发生什么？
- en: 'This time, instead of `n * n`, we use `n ** 2`. Both square a number right?
    So the results must be identical. Right? These are the types of assumptions that
    create bugs, and the types of assumptions that are trivial to catch using a few
    basic tests:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们使用`n ** 2`而不是`n * n`。两者都是对一个数字求平方，对吧？所以结果必须是相同的。对吧？这些是导致错误的假设类型，也是通过一些基本测试轻松捕捉到的假设类型：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'So let''s execute the test again and see what happens this time. For brevity,
    we will skip the verbosity flag this time:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次执行测试，看看这次会发生什么。为简洁起见，这次我们将跳过冗长标志：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The only modification we made to the code was replacing `n * n` with `n ** 2`,
    which translates to the power function. Since multiplication is not the same as
    taking the power of a number, the results are slightly different but similar enough
    in practice that most programmers wouldn't notice the difference.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对代码进行的唯一修改是用`n ** 2`替换了`n * n`，这相当于幂函数。由于乘法与取幂的操作不同，结果略有不同，但在实践中足够相似，以至于大多数程序员不会注意到这种差异。
- en: The only difference caused by the code change was that we now have a different
    exception—an innocent mistake, only breaking the tests in this case. But it shows
    how useful these tests are. When rewriting code, an incorrect assumption is easily
    made, and that is where tests are most useful—knowing you are breaking code as
    soon as you break it instead of finding out months later.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 代码更改导致的唯一区别是我们现在有了一个不同的异常——一个无辜的错误，在这种情况下只是破坏了测试。但它显示了这些测试是多么有用。在重写代码时，很容易做出错误的假设，这就是测试最有用的地方——知道您在破坏代码的同时破坏了它，而不是在几个月后发现。
- en: Writing doctests
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写doctest
- en: 'Perhaps, you have noticed from the preceding examples that the syntax is very
    similar to the regular Python console, and that is exactly the point. The `doctest`
    input is nothing more than the output of a regular Python shell session. This
    is what makes testing with this module so intuitive; simply write the code in
    the Python console and copy the output into a docstring to get tests. Here is
    an example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你已经注意到前面的示例中，语法与常规Python控制台非常相似，这正是重点所在。`doctest`输入只不过是常规Python shell会话的输出。这就是使用此模块进行测试如此直观的原因；只需在Python控制台中编写代码，然后将输出复制到文档字符串中进行测试。这里有一个例子：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That's why this is probably the easiest way to test code. With almost no effort,
    you can check whether your code is working as you would expect it, add tests,
    and add documentation at the same time. Simply copy the output from the interpreter
    to your function or class documentation and you have functioning doctests.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是测试代码的最简单方式。几乎不费吹灰之力，您就可以检查代码是否按您的预期工作，添加测试并同时添加文档。只需将解释器的输出复制到函数或类文档中，您就有了可用的doctest。
- en: Testing with pure documentation
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用纯文档进行测试
- en: 'The docstrings in functions, classes, and modules are usually the most obvious
    way to add doctests to your code, but they are not the only way. The Sphinx documentation,
    as we discussed in the previous chapter, also supports the `doctest` module. You
    might remember that when creating the Sphinx project, we enabled the `doctest`
    module:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 函数、类和模块中的文档字符串通常是向代码添加doctest的最明显方式，但并非唯一的方式。正如我们在上一章中讨论的，Sphinx文档也支持`doctest`模块。您可能还记得，在创建Sphinx项目时，我们启用了`doctest`模块：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This flag enables the `sphinx.ext.doctest` extension in Sphinx, which tells
    Sphinx to run those tests as well. Since not all the examples in the code are
    useful, let''s see whether we can split them between the ones that are actually
    useful and the ones that are only relevant for documentation. Moreover, to see
    the results, we will add an error to the documentation:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此标志在Sphinx中启用了`sphinx.ext.doctest`扩展，告诉Sphinx也要运行这些测试。由于代码中并非所有示例都有用，让我们看看是否可以将它们分为实际有用和仅与文档相关的示例。此外，为了查看结果，我们将在文档中添加一个错误：
- en: '**square.py**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**square.py**'
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**square.rst**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**square.rst**'
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, it''s time to execute the tests. In the case of Sphinx, there is a specific
    command for this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候执行测试了。对于Sphinx，有一个特定的命令：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As expected, we are getting an error for the incomplete `doctest`, but beyond
    that, all tests executed correctly. To make sure that the tests know what `square`
    is, we had to add the `testsetup` directive, and this still generates a pretty
    output:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，对于不完整的`doctest`，我们得到了一个错误，但除此之外，所有测试都执行正确。为了确保测试知道`square`是什么，我们必须添加`testsetup`指令，这仍然生成了一个漂亮的输出：
- en: '![Testing with pure documentation](images/4711_10_02.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![使用纯文档进行测试](images/4711_10_02.jpg)'
- en: The doctest flags
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: doctest标志
- en: 'The `doctest` module features several option flags. They affect how `doctest`
    processes the tests. These option flags can be passed globally using your test
    suite, through command-line parameters while running the tests, and through inline
    commands. For this book, I have globally enabled the following option flags through
    a `pytest.ini` file (we will cover more about `py.test` later in this chapter):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest`模块具有几个选项标志。它们影响`doctest`处理测试的方式。这些选项标志可以通过测试套件全局传递，通过运行测试时的命令行参数传递，以及通过内联命令传递。对于本书，我已经通过`pytest.ini`文件全局启用了以下选项标志（我们将在本章后面更多地介绍`py.test`）：'
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Without these option flags, some of the examples in this book will not function
    properly. This is because they have to be reformatted to fit. The next few paragraphs
    will cover the following option flags:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有这些选项标志，本书中的一些示例将无法正常运行。这是因为它们必须进行重新格式化以适应。接下来的几段将介绍以下选项标志：
- en: '`DONT_ACCEPT_TRUE_FOR_1`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DONT_ACCEPT_TRUE_FOR_1`'
- en: '`NORMALIZE_WHITESPACE`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NORMALIZE_WHITESPACE`'
- en: '`ELLIPSIS`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ELLIPSIS`'
- en: 'There are several other option flags available with varying degrees of usefulness,
    but these are better left to the Python documentation:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他几个选项标志可供选择，具有不同程度的有用性，但最好留给Python文档：
- en: '[https://docs.python.org/3/library/doctest.html#option-flags](https://docs.python.org/3/library/doctest.html#option-flags)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3/library/doctest.html#option-flags](https://docs.python.org/3/library/doctest.html#option-flags)'
- en: True and False versus 1 and 0
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: True和False与1和0的区别
- en: 'Having `True` evaluating to `1` and `False` evaluating to `0` is useful in
    most cases, but it can give unexpected results. To demonstrate the difference,
    we have these lines:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 将True评估为1，False评估为0，在大多数情况下是有用的，但可能会产生意想不到的结果。为了演示差异，我们有以下几行：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here are the results of the `DONT_ACCEPT_TRUE_FOR_1` flag:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`DONT_ACCEPT_TRUE_FOR_1`标志的结果：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, the `DONT_ACCEPT_TRUE_FOR_1` flag makes `doctest` reject `1`
    as a valid response for `True` as well as `0` for `False`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`DONT_ACCEPT_TRUE_FOR_1`标志使`doctest`拒绝`1`作为`True`的有效响应，以及`0`作为`False`的有效响应。
- en: Normalizing whitespace
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标准化空白
- en: 'Since doctests are used for both documentation and test purposes, it is pretty
    much a requirement to keep them readable. Without normalizing whitespace, this
    can be tricky, however. Consider the following example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于doctest用于文档和测试目的，因此保持可读性几乎是必需的。但是，如果不规范化空格，这可能有些棘手。考虑以下示例：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'While not all that bad, this output isn''t the best for readability. With whitespace
    normalizing, here is what we can do instead:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然并不是很糟糕，但这种输出对于可读性并不是最佳的。通过规范化空格，我们可以做到这一点：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Formatting the output in this manner is both more readable and convenient for
    keeping your line length less.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式格式化输出既更易读，又方便保持行长度较短。
- en: Ellipsis
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 省略号
- en: 'The `ELLIPSIS` flag is very useful but also a bit dangerous, as it can easily
    lead to incorrect matches. It makes `...` match any substring, which is very useful
    for exceptions but dangerous in other cases:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`ELLIPSIS`标志非常有用，但也有点危险，因为它很容易导致不正确的匹配。它使`...`匹配任何子字符串，在异常情况下非常有用，但在其他情况下危险：'
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: These cases are not too useful in real scenarios, but they demonstrate how the
    `ELLIPSIS` option flag functions. They also indicate the danger. Both `[1, 2,
    3, 4]` and `[1, 0, ... , 4]` match the `[1, ..., 4]` test, which is probably unintentional,
    so be very careful while using `ELLIPSIS`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些情况在实际场景中并不太有用，但它们演示了`ELLIPSIS`选项标志的功能。它们也指出了危险。`[1, 2, 3, 4]`和`[1, 0, ...
    , 4]`都匹配`[1, ..., 4]`测试，这可能是无意的，因此在使用`ELLIPSIS`时要非常小心。
- en: 'A more useful case is when documenting class instances:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在记录类实例时更有用：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Without the `ELLIPSIS` flag, the memory address (the `0x...` part) would never
    be what you expect. Let''s demonstrate an actual run in a normal CPython instance:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有`ELLIPSIS`标志，内存地址（`0x...`部分）永远不会是您期望的。让我们在正常的CPython实例中演示一个实际运行：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Doctest quirks
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Doctest怪癖
- en: The three option flags discussed earlier take care of quite a few quirks found
    in doctests, but there are several more cases that require care. In these cases,
    you just need to be a bit careful and work around the limitations of the `doctest`
    module. The `doctest` module effectively uses the representation string, and those
    are not always consistent.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 前面讨论的三个选项标志解决了doctest中发现的许多怪癖，但还有几种情况需要注意。在这些情况下，您只需要稍微小心，并解决`doctest`模块的限制。`doctest`模块有效地使用表示字符串，而这些表示字符串并不总是一致的。
- en: 'The most important cases are floating-point inaccuracies, dictionaries, and
    random values, such as timers. The following example will fail most of the time
    because certain types in Python have no consistent ordering and depend on external
    variables:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的情况是浮点不准确性、字典和随机值，例如计时器。以下示例大多数情况下会失败，因为Python中的某些类型没有一致的排序，并且取决于外部变量：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: All the problems have several possible solutions, which differ mostly in style
    and your personal preference.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所有问题都有几种可能的解决方案，主要在风格和个人偏好上有所不同。
- en: Testing dictionaries
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试字典
- en: The problem with dictionaries is that they are internally implemented as hash
    tables, resulting in an effectively random representation order. Since the `doctest`
    system requires a representation string that is identical in meaning (save for
    certain `doctest` flags, of course) to the `docstring`, this does not work. Naturally,
    there are several workaround options available and all have some advantages and
    disadvantages.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 字典的问题在于它们在内部实现为哈希表，导致有效的随机表示顺序。由于`doctest`系统要求表示字符串在含义上与`docstring`相同（当然除了某些`doctest`标志之外），这是行不通的。当然，有几种可用的解决方法，都有一些优点和缺点。
- en: 'The first is using the `pprint` library to format it in a pretty way:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是使用`pprint`库以漂亮的方式格式化它：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Since the `pprint` library always sorts the items before outputting, this solves
    the problem with random representation orders. However, it does require an extra
    import and function call, which some people prefer to avoid.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`pprint`库在输出之前总是对项目进行排序，这解决了随机表示顺序的问题。但是，这确实需要额外的导入和函数调用，有些人更喜欢避免。
- en: 'Another option is manual sorting of the items:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是手动对项目进行排序：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The downside here is that it is not visible from the output that `data` is a
    dictionary, which makes the output less readable.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的缺点是从输出中看不出`data`是一个字典，这使得输出不太可读。
- en: 'Lastly, comparing the `dict` with a different `dict` comprised of the same
    elements works as well:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将`dict`与由相同元素组成的不同`dict`进行比较也可以：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A perfectly okay solution, of course! But `True` is not really the clearest
    output, especially if the comparison doesn''t work:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一个完全可以的解决方案！但是`True`并不是最清晰的输出，特别是如果比较不起作用：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'On the other hand, the other options presented previously show both the expected
    value and the returned value correctly:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，先前提出的其他选项都正确显示了预期值和返回值：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Personally, out of the solutions presented, I would recommend using `pprint`,
    as I find it the most readable solution, but all the solutions have some merits
    to them.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 就我个人而言，在提出的解决方案中，我建议使用`pprint`，因为我认为这是最可读的解决方案，但所有解决方案都有其优点。
- en: Testing floating-point numbers
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试浮点数
- en: 'For the same reason as a floating-point comparison can be problematic (that
    is, `1/3 == 0.333`), a representation string comparison is also problematic. The
    easiest solution is to simply add some rounding/clipping to your code, but the
    `ELLIPSIS` flag is also an option here. Here is a list of several solutions:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于浮点比较可能存在问题（即`1/3 == 0.333`），表示字符串比较也存在问题。最简单的解决方案是在代码中添加一些四舍五入/裁剪，但在这里也可以使用`ELLIPSIS`标志。以下是几种解决方案的列表：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When the `ELLIPSIS` option flag is enabled globally anyhow, that would be the
    most obvious solution. In other cases, I recommend one of the alternative solutions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当全局启用`ELLIPSIS`选项标志时，这将是最明显的解决方案。在其他情况下，我建议使用其他解决方案之一。
- en: Times and durations
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间和持续时间
- en: 'For timings, the problems that you will encounter are quite similar to the
    floating-point issues. When measuring the duration execution time of a code snippet,
    there will always be some variation present. That''s why the most stable solution
    for tests, including time, is limiting the precision, although even that is no
    guarantee. Regardless, the simplest solution checks whether the delta between
    the two times is smaller than a certain number, as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于时间，您将遇到的问题与浮点问题非常相似。当测量代码片段的执行时间时，总会存在一些变化。这就是为测试包括时间的最稳定的解决方案是限制精度，尽管即使如此也不能保证。不过，最简单的解决方案是检查两个时间之间的差值是否小于某个数，如下所示：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'For the `timedelta` objects, however, it''s slightly more complicated. Yet,
    this is where the `ELLIPSIS` flag definitely comes in handy again:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于`timedelta`对象，情况稍微复杂一些。然而，这正是`ELLIPSIS`标志再次派上用场的地方：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The alternative to the `ELLIPSIS` option flag would be comparing the days, hours,
    minutes, and microseconds in `timedelta` separately.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与`ELLIPSIS`选项标志的替代方法是分别比较`timedelta`中的天、小时、分钟和微秒。
- en: In a later paragraph, we will see a completely stable solution for problems
    like these using mock objects. For doctests, however, that is generally overkill.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的段落中，我们将看到使用模拟对象的完全稳定的解决方案。然而，对于doctests来说，这通常是过度的。
- en: Testing with py.test
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用py.test进行测试
- en: The `py.test` tool makes it very easy to write tests and run them. There are
    a few other options such as `nose` and the bundled `unittest` module available,
    but the `py.test` library offers a very good combination of usability and active
    development. In the past, I was an avid `nose` user but have since switched to
    `py.test` as it tends to be easier to use and has better community support, in
    my experience at least. Regardless, `nose` is still a good choice, and if you're
    already using it, there is little reason to switch and rewrite all of your tests.
    When writing tests for a new project, however, `py.test` can be much more convenient.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`py.test`工具使编写测试和运行测试变得非常容易。还有一些其他选项，如`nose`和捆绑的`unittest`模块可用，但`py.test`库提供了非常好的可用性和积极的开发组合。过去，我是一个狂热的`nose`用户，但后来转而使用`py.test`，因为在我看来，它更容易使用并且有更好的社区支持。不过，`nose`仍然是一个不错的选择，如果你已经在使用它，就没有理由切换和重写所有的测试。然而，在为新项目编写测试时，`py.test`可能更加方便。'
- en: Now, we will run the doctests from the previously discussed `square.py` file
    using `py.test`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用`py.test`运行先前讨论的`square.py`文件中的doctests。
- en: 'First, start by installing `py.test`, of course:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当然要安装`py.test`：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now you can do a test run, so let''s give the doctests we have in `square.py`
    a try:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以进行一次测试运行，让我们尝试一下`square.py`中的doctests：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The difference between the unittest and py.test output
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试和py.test输出之间的区别
- en: We have the doctests in `square.py`. Let's create a new class called `cube`
    and create a proper set of tests outside of the code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`square.py`中有doctests。让我们创建一个名为`cube`的新类，并在代码之外创建一组适当的测试。
- en: 'First of all, we have the code of `cube.py`, similar to `square.py` but minus
    the doctests, since we don''t need them anymore:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有`cube.py`的代码，类似于`square.py`，但减去了doctests，因为我们不再需要它们：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now let''s start with the `unittest` example, `test_cube.py`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们从`unittest`示例`test_cube.py`开始：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This can be executed by executing the file itself:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过执行文件本身来执行：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Alternatively, it can be done through the module:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以通过模块来完成：
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This one is through `py.test`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过`py.test`执行的：
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We even have `nose`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至有`nose`：
- en: '[PRE33]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As long as all the results are successful, the differences between `unittest`
    and `py.test` are slim. In the case of `unittest` and `nose`, the results are
    identical. This time around, however, we are going to break the code to show the
    difference when it actually matters. Instead of the `cube` code, we will add the
    `square` code. So returning `n ** 2` instead of `n ** 3` from `square`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 只要所有的结果都成功，`unittest`和`py.test`之间的差异就很小。在`unittest`和`nose`的情况下，结果是相同的。然而，这一次，我们将打破代码以展示实际重要时的差异。我们将添加`square`代码而不是`cube`代码。所以从`square`返回`n
    ** 2`而不是`n ** 3`。
- en: 'First of all, we have the regular `unittest` output:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有常规的`unittest`输出：
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Not all that bad, as per each test returns a nice stack trace that includes
    the values and everything. Yet, we can observe a small difference here when compared
    with the `py.test` run:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试返回一个包含值和其他内容的漂亮的堆栈跟踪，这并不算太糟糕。然而，与`py.test`运行相比，我们可以观察到一个小差异：
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In small cases such as these, the difference is not all that apparent, but when
    testing complicated code with large stack traces, it becomes even more useful.
    However, for me personally, seeing the surrounding test code is a big advantage.
    In the example that was just discussed, the `self.assertEqual(...)` line shows
    the entire test, but in many other cases, you will need more information. The
    difference between the regular `unittest` module and the `py.test` module is that
    you can see the entire function with all of the code and the output. Later in
    this chapter, we will see how powerful this can be when writing more advanced
    tests.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些小案例中，差异并不是很明显，但是在测试具有大堆栈跟踪的复杂代码时，它变得更加有用。然而，对我个人来说，看到周围的测试代码是一个很大的优势。在刚刚讨论的例子中，`self.assertEqual(...)`行显示了整个测试，但在许多其他情况下，您将需要更多的信息。常规`unittest`模块和`py.test`模块之间的区别在于您可以看到包含所有代码和输出的整个函数。在本章的后面，我们将看到在编写更高级的测试时，这是多么强大。
- en: 'To truly appreciate the `py.test` output, we need to enable colors as well.
    The colors depend on your local color schemes, of course, but it''s useful to
    see them side by side at least once, as shown here:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正欣赏`py.test`的输出，我们还需要启用颜色。当然，颜色取决于您的本地颜色方案，但至少有一次将它们并排显示是有用的，如下所示：
- en: '![The difference between the unittest and py.test output](images/4711_10_03.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![单元测试和py.test输出之间的区别](images/4711_10_03.jpg)'
- en: Perhaps you are wondering now, "Is that all?" The only difference between `py.test`
    and `unittest` is a bit of color and a slightly different output? Well, far from
    it, there are many other differences, but this alone is enough reason to give
    it a try.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你现在想知道，“就这些吗？”`py.test`和`unittest`之间唯一的区别是一点颜色和略有不同的输出？远非如此，还有许多其他区别，但仅仅这一点就足以让你试一试。
- en: The difference between unittest and py.test tests
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: unittest和py.test测试之间的区别
- en: The improved output does help a bit, but the combination of improved output
    and a much easier way to write tests is what makes `py.test` so useful. There
    are quite a few methods for making the tests simpler and more legible, and in
    many cases, you can choose which you prefer. As always, readability counts, so
    choose wisely and try not to over-engineer the solutions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 改进的输出确实有所帮助，但改进的输出和更简单的编写测试的结合才是使`py.test`如此有用的原因。有许多方法可以使测试更简单、更易读，在许多情况下，您可以选择自己喜欢的方法。一如既往，可读性很重要，所以明智地选择，并尽量不要过度设计解决方案。
- en: Simplifying assertions
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简化断言
- en: Where the unittest library requires the usage of `self.assertEqual` to compare
    variables, `py.test` uses some magic to allow for simpler tests using regular
    `assert` statements.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: unittest库需要使用`self.assertEqual`来比较变量，而`py.test`使用一些魔法来允许使用常规的`assert`语句进行更简单的测试。
- en: 'The following test file contains both styles of tests, so they can be compared
    easily:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下测试文件包含了两种测试样式，因此它们可以很容易地进行比较：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'So what did we do? Well, we simply replaced `self.assertEqual` with `assert
    ... == ...` and `with self.assertRaises` with `with pytest.raises`. A minor improvement
    indeed, but the actual benefit is seen in the failure output. The first two use
    the `unittest` style and the latter two use the `py.test` style:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们做了什么？嗯，我们只是用`assert ... == ...`替换了`self.assertEqual`，用`with pytest.raises`替换了`with
    self.assertRaises`。确实是一个小改进，但实际的好处在于失败的输出。前两个使用了`unittest`风格，后两个使用了`py.test`风格：
- en: '[PRE37]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Therefore, in addition to seeing the values that were compared, we can actually
    see the function that was called and which input parameters it received. With
    the static numbers that we have here, it may not be that useful, but it is invaluable
    when using variables, as we'll see in the next paragraphs.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，除了看到被比较的值，我们实际上还可以看到调用的函数以及它接收的输入参数。对于我们这里的静态数字，可能并不那么有用，但在使用变量时，它是非常宝贵的，正如我们将在接下来的段落中看到的那样。
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding tests are all stored in a class. With `py.test`, that's completely
    optional, however. If readability or inheritance makes it useful to encapsulate
    the tests in a class, then feel free to do so, but as far as `py.test` is concerned,
    there is no advantage.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试都存储在一个类中。在`py.test`中，这是完全可选的。如果可读性或继承使得将测试封装在一个类中变得有用，那么请随意这样做，但就`py.test`而言，没有任何优势。
- en: 'The standard `py.test` behavior works for most test cases, but it may not be
    enough for some custom types. For example, let''s say that we have a `Spam` object
    with a `count` attribute that should be compared with the `count` attribute on
    another object. This part can easily be achieved by implementing the `__eq__`
    method on `Spam`, but it does not improve clarity. Since `count` is the attribute
    that we compare, it would be useful if the tests show `count` when errors are
    displayed. First is the class with two tests, one working and one broken to demonstrate
    the regular output:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的`py.test`行为适用于大多数测试用例，但对于一些自定义类型可能不够。例如，假设我们有一个`Spam`对象，它有一个应该与另一个对象上的`count`属性进行比较的`count`属性。通过在`Spam`上实现`__eq__`方法，可以轻松实现这一部分，但这并没有提高清晰度。由于我们比较的是`count`属性，如果测试显示错误时显示`count`将会很有用。首先是一个包含两个测试样式的类，一个工作正常，一个损坏以演示常规输出：
- en: '**test_spam.py**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**test_spam.py**'
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And here is the regular `py.test` output:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是常规的`py.test`输出：
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The default test output is still usable since the function is fairly straightforward,
    and the value for `count` is visible due to it being available in the constructor.
    However, it would have been more useful if we could explicitly see the value of
    `count`. By adding a `pytest_assertrepr_compare` function to the `conftest.py`
    file, we can modify the behavior of the `assert` statements.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的测试输出仍然可用，因为函数相当简单，而`count`的值也是可见的，因为它在构造函数中可用。然而，如果我们能明确看到`count`的值会更有用。通过在`conftest.py`文件中添加`pytest_assertrepr_compare`函数，我们可以修改`assert`语句的行为。
- en: Note
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: That's a special file for `py.test` that can be used to override or extend `py.test`.
    Note that this file will automatically be loaded by every test run in that directory,
    so we need to test the types of both the left-hand side and the right-hand side
    of the operator. In this case, it's `a` and `b`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个专门为`py.test`设计的特殊文件，可以用来覆盖或扩展`py.test`。请注意，该文件将自动加载该目录中的每个测试运行，因此我们需要测试操作符的左侧和右侧的类型。在这种情况下，它是`a`和`b`。
- en: '**conftest.py**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**conftest.py**'
- en: '[PRE40]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The preceding function will be used as the output for our test. So when it
    fails, this time we get our own, slightly more useful, output:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数将被用作我们的测试输出。所以当它失败时，这次我们会得到我们自己的，稍微更有用的输出：
- en: '[PRE41]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this case, we could have easily changed the `__repr__` function of `Spam`
    as well, but there are many cases where modifying the `py.test` output can be
    useful. Similar to this, there is specific support for many types, such as sets,
    dictionaries, and texts.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们也可以轻松地更改`Spam`的`__repr__`函数，但有许多情况下修改`py.test`的输出会很有用。类似于这样，对于许多类型，如集合、字典和文本，都有特定的支持。
- en: Parameterizing tests
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数化测试
- en: 'So far, we have specified every test separately, but we can simplify tests
    a lot by parameterizing them. Both the square and cube tests were very similar;
    a certain input gave a certain output. This is something that can easily be verified
    using a loop, of course, but using a loop in a test has a pretty big downside.
    It will be executed as a single test. This means that it will fail in its entirety
    if a single test iteration of the loop fails, and that is a problem. Instead of
    having an output for every version, you will get it only once, while they actually
    might be separate bugs. That''s where parameters help. You can simply create a
    list of parameters and the expected data and make it run the test function for
    every parameter separately:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经单独指定了每个测试，但是我们可以通过为其提供参数来简化测试。平方和立方测试非常相似；特定的输入产生特定的输出。当然，这是可以使用循环轻松验证的，但是在测试中使用循环有一个相当大的缺点。它将被执行为单个测试。这意味着如果循环的单个测试迭代失败，它将完全失败，这是一个问题。而不是为每个版本都有一个输出，你只会得到一次，而它们实际上可能是单独的错误。这就是参数的作用。你可以简单地创建一个参数列表和期望的数据，并使其为每个参数单独运行测试函数：
- en: '[PRE42]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This outputs the following, as you might have already expected:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经预料到的那样，这将输出以下内容：
- en: '[PRE43]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: With the parameterized tests, we can see the parameters clearly, which means
    we can see all inputs and outputs without any extra effort.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通过参数化测试，我们可以清楚地看到参数，这意味着我们可以在没有任何额外努力的情况下看到所有的输入和输出。
- en: Generating the list of tests dynamically at runtime is also possible with a
    global function. Similar to the `pytest_assertrepr_compare` function that we added
    to `conftest.py` earlier, we can add a `pytest_generate_tests` function, which
    generates tests.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时动态生成测试列表也是可能的，可以使用一个全局函数。类似于我们之前添加到`conftest.py`的`pytest_assertrepr_compare`函数，我们可以添加一个`pytest_generate_tests`函数，用于生成测试。
- en: Creating the `pytest_generate_tests` function can be useful only to test a subset
    of options depending on the configuration options. If possible, however, I recommend
    trying to configure selective tests using fixtures instead, as they are somewhat
    more explicit. The problem with functions such as `pytest_generate_tests` is that
    they are global and don't discriminate between specific tests, resulting in strange
    behavior if you are not expecting that.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`pytest_generate_tests`函数只有在根据配置选项测试子集时才有用。然而，如果可能的话，我建议尝试使用装置来配置选择性测试，因为它们更加明确。像`pytest_generate_tests`这样的函数的问题在于它们是全局的，并且不能区分特定的测试，如果你没有预料到，会导致奇怪的行为。
- en: Automatic arguments using fixtures
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用装置自动参数
- en: 'The fixture system is one of the most magical features of `py.test`. It magically
    executes a fixture function with the same name as your arguments. Because of this,
    the naming of the arguments becomes very important, as they can easily collide
    with other fixtures. To prevent collisions, the scope is set to `function` by
    default. However, `class`, `module`, and `session` are also valid options for
    the scope. There are several fixtures available by default, some of which you
    will use often, and others most likely never. A complete list can always be generated
    with the following command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 装置系统是`py.test`最神奇的功能之一。它会以与你的参数相同名称的装置函数来执行装置函数。因此，参数的命名变得非常重要，因为它们很容易与其他装置发生冲突。为了防止冲突，默认情况下将作用域设置为`function`。然而，`class`、`module`和`session`也是作用域的有效选项。默认情况下，有几个装置可用，其中一些你经常会使用，而其他一些则很可能永远不会使用。可以使用以下命令生成完整的列表：
- en: '[PRE44]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The standard fixtures are quite well documented, but a few examples never hurt.
    The next paragraphs demonstrate fixture usage.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的装置都有相当详细的文档，但是一些例子从来没有伤害过。下面的段落演示了装置的使用。
- en: Cache
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 缓存
- en: 'The cache fixture is as simple as it is useful; there is a `get` function and
    a `set` function, and it remains between sessions. This test, for example, will
    allow five executions and raise an error every time after that. While it is not
    the most useful and elaborate example, it does show how the `cache` function works:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存装置就像它一样简单又有用；有一个`get`函数和一个`set`函数，并且在会话之间保持不变。例如，这个测试将允许五次执行，并在此之后每次都会引发错误。虽然这不是最有用和精心设计的例子，但它确实展示了`cache`函数的工作原理：
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The default value (`0` in this case) is required for the `cache.get` function.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`cache.get`函数需要默认值（在这种情况下是`0`）。'
- en: The cache can be cleared through the `--cache-clear` command-line parameter,
    and all caches can be shown through `--cache-show`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过`--cache-clear`命令行参数清除缓存，并且可以通过`--cache-show`显示所有缓存。
- en: Custom fixtures
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自定义装置
- en: Bundled fixtures are quite useful, but within most projects, you will need to
    create your own fixtures to make things easier. Fixtures make it trivial to repeat
    code that is needed more often. You are most likely wondering how this is different
    from a regular function, context wrapper, or something else, but the special thing
    about fixtures is that they themselves can accept fixtures as well. So, if your
    function needs the `pytestconfig` variables, it can ask for it without needing
    to modify the calling functions.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 捆绑的装置非常有用，但在大多数项目中，你需要创建自己的装置来简化事情。装置使得重复需要的代码变得微不足道。你很可能想知道这与常规函数、上下文包装器或其他东西有何不同，但装置的特殊之处在于它们本身也可以接受装置。因此，如果你的函数需要`pytestconfig`变量，它可以在不需要修改调用函数的情况下请求它。
- en: 'The use cases for fixtures strongly depend on the projects, and because of
    that, it is difficult to generate a universally useful example, but a theoretical
    one is of course an option. The basic premise is simple enough, though: a function
    with the `pytest.fixture` decorator, which returns a value that will be passed
    along as an argument. Also, the function can take parameters and fixtures just
    as any test can. The only notable variation is `pytest.yield_fixture`. This fixture
    variation has one small difference; the actual test will be executed at the `yield`
    (more than one `yield` results in errors) and the code before/after functions
    as setup/teardown code. The most basic example of a `fixture` with `yield_fixture`
    looks like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: fixture的使用情况强烈依赖于项目，因此很难生成一个普遍有用的例子，但理论上是可行的。基本前提是相当简单的：一个带有`pytest.fixture`装饰器的函数，返回一个将作为参数传递的值。此外，该函数可以像任何测试一样接受参数和fixture。唯一值得注意的变化是`pytest.yield_fixture`。这个fixture变体有一个小的不同之处；实际测试将在`yield`时执行（多个`yield`会导致错误），并且在函数之前/之后的代码作为设置/拆卸代码。具有`yield_fixture`的`fixture`的最基本示例看起来像这样：
- en: '[PRE46]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'These fixtures take no parameters and simply pass a parameter to the `py.test`
    functions. A more useful example would be setting up a database connection and
    executing a query in a transaction:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这些fixture不带参数，只是将参数传递给`py.test`函数。一个更有用的例子是在事务中设置数据库连接并执行查询：
- en: '[PRE47]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Naturally, instead of using the `:memory:` database in `sqlite3`, we can use
    a different database name (or several) as well.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，我们可以使用不同的数据库名称（或多个）来代替在`sqlite3`中使用`:memory:`数据库。
- en: Print statements and logging
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打印语句和日志
- en: 'Even though print statements are generally not the most optimal way to debug
    code, I admit that it is still my default method of debugging. This means that
    when running and trying tests, I will include many print statements. However,
    let''s see what happens when we try this with `py.test`. Here is the testing code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管打印语句通常不是调试代码的最佳方式，但我承认这仍然是我的默认调试方法。这意味着在运行和尝试测试时，我会包含许多打印语句。然而，让我们看看当我们尝试在`py.test`中使用这个时会发生什么。这是测试代码：
- en: '[PRE48]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The following is the actual output:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是实际输出：
- en: '[PRE49]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: So, all of our print statements and logging got trashed? Well, not really. In
    this case, `py.test` assumed that it wouldn't be relevant to you, so it ignored
    the output. But what about the same test with an error?
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们所有的打印语句和日志都被丢弃了？嗯，并不完全是这样。在这种情况下，`py.test`假设这对您来说并不重要，因此忽略了输出。但是同样的测试出现错误会怎么样呢？
- en: '[PRE50]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: And the output with the error?
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 那么带有错误的输出呢？
- en: '[PRE51]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Wow! Do you see that? The `stdout`, `stderr`, and logging with a level of `WARNING`
    or higher do get output now. `DEBUG` and `INFO` still won't be visible, but we'll
    see more about that later in this chapter, in the logging section.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！你看到了吗？`stdout`，`stderr`和带有`WARNING`或更高级别的日志现在都有输出了。`DEBUG`和`INFO`仍然不可见，但我们稍后在本章的日志部分将会更多地了解到。
- en: Plugins
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 插件
- en: One of the most powerful features of `py.test` is the plugin system. Within
    `py.test`, nearly everything can be modified using the available hooks, the result
    of which is that writing plugins is almost simple. Actually, you already wrote
    a few plugins in the previous paragraphs without realizing it. By packaging `conftest.py`
    in a different package or directory, it becomes a `py.test` plugin. We will explain
    more about packaging in [Chapter 15](ch15.html "Chapter 15. Packaging – Creating
    Your Own Libraries or Applications"), *Packaging – Creating Your Own Libraries
    or Applications*. Generally, it won't be required to write your own plugin because
    the odds are that the plugins you seek are already available. A small list of
    plugins can be found on the `py.test` website at [https://pytest.org/latest/plugins.html](https://pytest.org/latest/plugins.html),
    and a longer list can be found through the Python package index at [https://pypi.python.org/pypi?%3Aaction=search&term=pytest-](https://pypi.python.org/pypi?%3Aaction=search&term=pytest-).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`py.test`最强大的功能之一是插件系统。在`py.test`中，几乎可以使用可用的钩子修改几乎所有内容，其结果是编写插件几乎是简单的。实际上，您在之前的段落中已经写了一些插件，而没有意识到。通过将`conftest.py`打包在不同的包或目录中，它就成为了一个`py.test`插件。我们将在[第15章](ch15.html
    "第15章。打包-创建自己的库或应用程序")中更多地解释打包，*打包-创建自己的库或应用程序*。通常情况下，不需要编写自己的插件，因为您寻找的插件很可能已经可用。可以在`py.test`网站的[https://pytest.org/latest/plugins.html](https://pytest.org/latest/plugins.html)上找到一小部分插件列表，也可以在Python包索引的[https://pypi.python.org/pypi?%3Aaction=search&term=pytest-](https://pypi.python.org/pypi?%3Aaction=search&term=pytest-)上找到更多插件列表。'
- en: 'By default, `py.test` does cover quite a bit of the desirable features, so
    you can easily do without plugins, but within the packages that I write myself,
    I generally default to the following list:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`py.test`确实涵盖了相当多的理想功能，因此您可以轻松地不使用插件，但在我自己编写的包中，我通常默认使用以下列表：
- en: '`pytest-cov`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pytest-cov`'
- en: '`pytest-pep8`'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pytest-pep8`'
- en: '`pytest-flakes`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pytest-flakes`'
- en: By using these plugins, it becomes much easier to maintain the code quality
    of your project. In order to understand why, we will take a closer look at these
    packages in the following paragraphs.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这些插件，可以更轻松地维护项目的代码质量。为了理解原因，我们将在以下段落中更仔细地看看这些包。
- en: pytest-cov
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: pytest-cov
- en: Using the `pytest-cov` package, you can see whether your code is properly covered
    by tests or not. Internally, it uses the `coverage` package to detect how much
    of the code is being tested. To demonstrate the principle, we will check the coverage
    of a `cube_root` function.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pytest-cov`包，您可以查看代码是否被测试覆盖。在内部，它使用`coverage`包来检测有多少代码被测试。为了演示原理，我们将检查`cube_root`函数的覆盖范围。
- en: Note
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Make sure you have `pytest-cov` installed:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已安装了`pytest-cov`：
- en: '[PRE52]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'First of all, let''s create a `.coveragerc` file with some useful defaults:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个`.coveragerc`文件，其中包含一些有用的默认值：
- en: '[PRE53]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here is the `cube_root.py` code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`cube_root.py`代码：
- en: '[PRE54]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'And the `test_cube_root.py` code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_cube_root.py`代码：'
- en: '[PRE55]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now let''s see what happens when we run this with the `--cov-report=html` parameter:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看当我们使用`--cov-report=html`参数运行时会发生什么：
- en: '[PRE56]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'What happened here? It looks like we forgot to test some part of the code:
    line `14` and the branch that goes from line `11` to line `14`. This output isn''t
    all that readable, and that''s why we specified the HTML output as well:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？看起来我们忘记测试代码的某些部分：第`14`行和从第`11`行到第`14`行的分支。这个输出并不那么易读，这就是为什么我们还指定了HTML输出：
- en: '![pytest-cov](images/4711_10_05.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![pytest-cov](images/4711_10_05.jpg)'
- en: Perfect! So now we know. We forgot to test for values smaller than `0`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在我们知道了。我们忘记测试小于`0`的值。
- en: 'The yellow line indicates that only one part of the branch was executed (`(n
    >= 0) == True`) and not the other (`(n >= 0) == False`), this occurs with `if`
    statements, loops, and other things where at least one of the branches is not
    covered. For example, if a loop over an empty array is an impossible scenario,
    then the test can be partially skipped:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 黄线表示只执行了分支的一部分(`(n >= 0) == True`)，而没有执行另一部分(`(n >= 0) == False`)，这发生在`if`语句、循环和其他至少有一个分支未覆盖的情况下。例如，如果对空数组进行循环是不可能的情况，那么测试可以部分跳过：
- en: '[PRE57]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'But since we know the problem, that is, the missing test for `ValueError`,
    let''s add the test case:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 但是既然我们知道问题，也就是缺少对`ValueError`的测试，让我们添加测试用例：
- en: '[PRE58]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then we run the test again:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们再次运行测试：
- en: '[PRE59]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Perfect! 100% coverage without a problem, and the HTML output is also exactly
    what we expect:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！100%的覆盖率没有问题，HTML输出也正是我们所期望的：
- en: '![pytest-cov](images/4711_10_06.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![pytest-cov](images/4711_10_06.jpg)'
- en: But what if the code was slightly different? Instead of raising a `ValueError`
    for values below `0`, what if we just raise a `NotImplementedError`?
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果代码稍有不同呢？如果不是为小于`0`的值引发`ValueError`，而是引发`NotImplementedError`呢？
- en: '[PRE60]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'And remove the extra test as well:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 并且也删除额外的测试：
- en: '[PRE61]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Run the test again:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试：
- en: '[PRE62]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You might wonder why we get 100% test coverage now though we actually didn''t
    cover `NotImplementedError`. This is because we added `raise NotImplementedError`
    to the ignore list in the `.coveragerc` file. This also gives us a different result
    in the HTML output:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道为什么现在我们获得了100%的测试覆盖率，尽管我们实际上并没有覆盖`NotImplementedError`。这是因为我们在`.coveragerc`文件中将`raise
    NotImplementedError`添加到了忽略列表中。这也使我们在HTML输出中得到了不同的结果：
- en: '![pytest-cov](images/4711_10_06.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![pytest-cov](images/4711_10_06.jpg)'
- en: Even if we add the test for `NotImplementedError` in the test file, the coverage
    report will still ignore the line.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在测试文件中添加了`NotImplementedError`的测试，覆盖报告仍将忽略该行。
- en: pytest-pep8 and pytest-flakes
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: pytest-pep8和pytest-flakes
- en: 'Pyflakes and pep8 are code quality testing tools that are very useful for making
    your code readable and pep8 compliant. The `pytest-pep8` and `pytest-flakes` modules
    automatically execute these checks before running the actual tests. To install
    them, simply execute this line:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Pyflakes和pep8是非常有用的代码质量测试工具，可以使您的代码可读且符合pep8。`pytest-pep8`和`pytest-flakes`模块在运行实际测试之前会自动执行这些检查。要安装它们，只需执行这行：
- en: '[PRE63]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'After that, you''ll be able to run both of them like this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您可以像这样运行它们：
- en: '[PRE64]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Configuring plugins
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 配置插件
- en: To make sure that all the plugins get executed and to configure them, simply
    add the settings to the `pytest.ini` file. The following example can be a reasonable
    default for development, but for production releases, you will probably want to
    care of the `UnusedImport` warnings.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保所有插件都被执行并进行配置，只需将设置添加到`pytest.ini`文件中。以下示例可以是开发的合理默认值，但对于生产版本，您可能希望处理`UnusedImport`警告。
- en: '**pytest.ini:**'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**pytest.ini:**'
- en: '[PRE65]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Tip
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When debugging to find out why a test is failing, it can be useful to simply
    look at the first test that fails. The `py.test` module offers both a `-x` flag
    to stop after the first failure and `--maxfail=n` to stop after *n* failures.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试中找出测试失败的原因时，简单地查看第一个失败的测试可能很有用。`py.test`模块提供了`-x`标志，在第一个失败后停止，以及`--maxfail=n`在*n*次失败后停止。
- en: Mock objects
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟对象
- en: 'When writing tests, this regularly occurs: you are testing not only your own
    code but also the interaction with external resources, such as hardware, databases,
    web hosts, servers, and others. Some of these can be run safely, but certain tests
    are too slow, too dangerous, or even impossible to run. In those cases, mock objects
    are your friends; they can be used to fake anything, so you can be certain that
    your code still returns the expected results without having any variation from
    external factors.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写测试时，经常会发生这种情况：您不仅在测试自己的代码，还在测试与外部资源的交互，如硬件、数据库、网络主机、服务器等。其中一些可以安全运行，但某些测试太慢、太危险，甚至无法运行。在这些情况下，模拟对象是您的朋友；它们可以用来伪造任何东西，因此您可以确信您的代码仍然返回预期的结果，而不会受到外部因素的任何变化的影响。
- en: Using unittest.mock
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用unittest.mock
- en: The `unittest.mock` library provides two base objects, `Mock` and `MagicMock`,
    to easily mock any external resources. The `Mock` object is just a general generic
    mock object and `MagicMock` is mostly the same, but it has all the magic methods
    such as `__contains__` and `__len__` defined. In addition to this, it can make
    your life even easier. This is because in addition to creating mock objects manually,
    it is possible to patch objects directly using the `patch` decorator/context manager.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest.mock`库提供了两个基本对象，`Mock`和`MagicMock`，可以轻松模拟任何外部资源。`Mock`对象只是一个通用的通用模拟对象，`MagicMock`大致相同，但它具有所有魔术方法，如`__contains__`和`__len__`。除此之外，它还可以让你的生活更轻松。这是因为除了手动创建模拟对象之外，还可以使用`patch`装饰器/上下文管理器直接修补对象。'
- en: 'The following function uses `random` to return `True` or `False` given governed
    by a certain probability distribution. Due to the random nature of a function
    like this, it is notoriously difficult to test, but not with `unittest.mock`.
    With the use of `unittest.mock,` it''s easy to get repeatable results:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数使用`random`返回`True`或`False`，由某种概率分布控制。由于这样的函数的随机性质，测试起来非常困难，但使用`unittest.mock`就不是了。使用`unittest.mock`，可以获得可重复的结果：
- en: '[PRE66]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Wonderful, isn''t it? Without having to modify the original code, we can make
    sure that `random.random` now returns `0.1` instead of some random number. For
    completeness, the version that uses a context manager is given here:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒，不是吗？在不修改原始代码的情况下，我们可以确保`random.random`现在返回`0.1`而不是随机数。为了完整起见，这里提供了使用上下文管理器的版本：
- en: '[PRE67]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The possibilities with mock objects are nearly endless. They vary from raising
    exceptions on access to faking entire APIs and returning different results on
    multiple calls. For example, let''s fake deleting a file:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模拟对象的可能性几乎是无穷无尽的。它们从在访问时引发异常到伪造整个API并在多次调用时返回不同的结果。例如，让我们伪造删除文件：
- en: '[PRE68]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Quite a bit of magic in this example! The `side_effect` parameter tells mock
    to return those values in that sequence, making sure that the first call to `os.path.exists`
    returns `True` and the other two return `False`. The `mock.patch` without arguments
    simply returns a callable that does nothing.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中有相当多的魔法！`side_effect`参数告诉模拟按照顺序返回这些值，确保对`os.path.exists`的第一次调用返回`True`，而其他两次返回`False`。没有参数的`mock.patch`简单地返回一个什么都不做的可调用对象。
- en: Using py.test monkeypatch
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用py.test monkeypatch
- en: 'The `monkeypatch` object in `py.test` is a fixture that allows mocking as well.
    While it may seem useless after seeing the possibilities with `unittest.mock`,
    in summary, it''s not. Some of the functionality does overlap, but while `unittest.mock`
    focuses on controlling and recording the actions of an object, the `monkeypatch`
    fixture focuses on simple and temporary environmental changes. Some examples of
    these are given in the following list:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`py.test`中的`monkeypatch`对象是一个允许模拟的fixture。虽然在看到`unittest.mock`的可能性后，它可能看起来毫无用处，但总的来说，它并不是。一些功能确实重叠，但`unittest.mock`专注于控制和记录对象的操作，而`monkeypatch`
    fixture专注于简单和临时的环境更改。以下是一些示例：'
- en: Setting and deleting attributes using `monkeypatch.setattr` and `monkeypatch.delattr`
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`monkeypatch.setattr`和`monkeypatch.delattr`设置和删除属性
- en: Setting and deleting dictionary items using `monkeypatch.setitem` and `monkeypatch.delitem`
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`monkeypatch.setitem`和`monkeypatch.delitem`设置和删除字典项
- en: Setting and deleting environment variables using `monkeypatch.setenv` and `monkeypatch.delenv`
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`monkeypatch.setenv`和`monkeypatch.delenv`设置和删除环境变量
- en: Inserting an extra path to `sys.path` before all others using `monkeypatch.syspath_prepend`
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有其他路径之前插入额外的路径到`sys.path`使用`monkeypatch.syspath_prepend`
- en: Changing the directory using `monkeypatch.chdir`
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`monkeypatch.chdir`更改目录
- en: To undo all modifications, simply use `monkeypatch.undo`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要撤消所有修改，只需使用`monkeypatch.undo`。
- en: 'For example, let''s say that for a certain test, we need to work from a different
    directory. With mock, your options would be to mock pretty much all file functions,
    including the `os.path` functions, and even in that case, you will probably forget
    about a few. So, it''s definitely not useful in this case. Another option would
    be to put the entire test into a `try…finally` block and just do an `os.chdir`
    before and after the testing code. This is quite a good and safe solution, but
    it''s a bit of extra work, so let''s compare the two methods:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设对于某个测试，我们需要从不同的目录中工作。使用模拟，你的选项将是模拟几乎所有文件函数，包括`os.path`函数，即使在这种情况下，你可能会忘记一些。因此，在这种情况下，它绝对没有用。另一个选择是将整个测试放入`try…finally`块中，并在测试代码之前和之后执行`os.chdir`。这是一个相当好的安全解决方案，但需要额外的工作，因此让我们比较这两种方法：
- en: '[PRE69]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: They effectively do the same, but one needs four lines of code whereas the other
    needs eight. All of these can easily be worked around with a few extra lines of
    code, of course, but the simpler the code is, the fewer mistakes you can make
    and the more readable it is.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 它们实际上是一样的，但一个需要四行代码，而另一个需要八行。当然，所有这些都可以很容易地通过几行额外的代码来解决，但代码越简单，你就会犯的错误就越少，可读性就越强。
- en: Logging
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志
- en: The Python logging module is one of those modules that are extremely useful,
    but it tends to be very difficult to use correctly. The result is often that people
    just disable logging completely and use print statements instead. This is insightful
    but a waste of the very extensive logging system in Python. If you've written
    Java code before, you might be familiar with the Log4j Java library. The Python
    logging module is largely and primarily based on that library.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Python日志模块是那些非常有用但很难正确使用的模块之一。结果通常是人们完全禁用日志记录并使用打印语句代替。这很有见地，但浪费了Python中非常庞大的日志系统。如果你以前写过Java代码，你可能熟悉Log4j
    Java库。Python日志模块在很大程度上主要基于该库。
- en: 'The most important objects of the logging module are the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 日志模块的最重要对象如下：
- en: '**Logger**: the actual logging interface'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Logger**：实际的日志接口'
- en: '**Handler**: This processes the log statements and outputs them'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Handler**：处理日志语句并输出它们'
- en: '**Formatter**: This formats the input data into a string'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Formatter**：将输入数据格式化为字符串'
- en: '**Filter**: This allows filtering of certain messages'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Filter**：允许过滤某些消息'
- en: 'Within these objects, you can set the logging levels to one of the default
    levels:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些对象中，你可以将日志级别设置为默认级别之一：
- en: '`CRITICAL: 50`'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CRITICAL: 50`'
- en: '`ERROR: 40`'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ERROR: 40`'
- en: '`WARNING: 30`'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WARNING: 30`'
- en: '`INFO: 20`'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INFO: 20`'
- en: '`DEBUG: 10`'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEBUG: 10`'
- en: '`NOTSET: 0`'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NOTSET: 0`'
- en: The numbers are the numeric values of these log levels. While you can generally
    ignore them, the order is obviously important while setting the minimum level.
    Also, when defining custom levels, you will have to overwrite existing levels
    if they have the same numeric value.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数字是这些日志级别的数值。虽然你通常可以忽略它们，但在设置最低级别时顺序显然很重要。此外，在定义自定义级别时，如果它们具有相同的数值，你将不得不覆盖现有级别。
- en: Configuration
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置
- en: There are several ways to configure the logging system, ranging from pure code
    to JSON files or even remote configuration. The examples will use parts of the
    logging module later discussed in this chapter, but the usage of the config system
    is all that matters here. If you are not interested in the internal workings of
    the logging module, you should be able to get by with just this paragraph of the
    logging section.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种配置日志系统的方法，从纯代码到JSON文件甚至远程配置。后面将在本章中讨论的日志模块的部分将使用这些示例，但这里只关注配置系统的使用。如果您对日志模块的内部工作不感兴趣，那么您应该能够通过日志部分的这一段来完成。
- en: Basic logging configuration
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本日志配置
- en: 'The most basic logging configuration is, of course, no configuration, but that
    will not get you much useful output:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的日志配置当然是没有配置，但这不会给您带来太多有用的输出：
- en: '[PRE70]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'With the default log level, you will only see a warning and up:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认日志级别，您只会看到警告和更高级别的日志：
- en: '[PRE71]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'A quick and easy start for a configuration is `basicConfig`. I recommend using
    this if you just need some quick logging for a script you''re writing, but not
    for a full-blown application. While you can configure pretty much anything you
    wish, once you get a more complicated setup, there are usually more convenient
    options. We will talk more about that in later paragraphs, but first, we have
    a `basicConfig` that configures our logger to display some more information, including
    the logger name:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 配置的快速简单开始是“basicConfig”。如果您只需要为您编写的脚本进行一些快速记录，而不是用于完整的应用程序，我建议使用这个。虽然您可以配置几乎任何您希望的东西，但一旦您获得更复杂的设置，通常会有更方便的选项。我们将在后面的段落中更多地讨论这一点，但首先，我们有一个“basicConfig”，它配置我们的记录器以显示一些更多的信息，包括记录器名称：
- en: '[PRE72]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We test the code:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试代码：
- en: '[PRE73]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This will give us the following output on our screen:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们的屏幕上给出以下输出：
- en: '[PRE74]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'And here is the output in the `debug.log` file:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这是“debug.log”文件中的输出：
- en: '[PRE75]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This configuration shows how log outputs can be configured with separate configurations,
    log levels, and, if you choose so, formatting. It tends to become unreadable though,
    which is why it's usually a better idea to use `basicConfig` only for simple configurations
    that don't involve multiple handlers.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置显示了如何使用单独的配置、日志级别以及（如果您选择）格式化来配置日志输出。但它往往变得难以阅读，这就是为什么通常最好只使用“basicConfig”来进行简单的配置，而不涉及多个处理程序。
- en: Dictionary configuration
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字典配置
- en: 'The `dictconfig` makes it possible to name all parts so that they can be reused
    easily, for example, a single formatter for multiple loggers and handlers. So
    let''s rewrite our previous configuration using `dictconfig`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: “dictconfig”使得可以命名所有部分，以便它们可以轻松地被重用，例如，多个记录器和处理程序的单个格式化程序。因此，让我们使用“dictconfig”重新编写我们之前的配置：
- en: '[PRE76]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The nice thing about the dictionary configuration is that it's very easy to
    extend and/or overwrite the logging configuration. For example, if you want to
    change the formatter for all of your logging, you can simply change the `standard`
    formatter or even loop through `handlers`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 字典配置的好处是非常容易扩展和/或覆盖日志配置。例如，如果您想要更改所有日志的格式化程序，您可以简单地更改“standard”格式化程序，甚至循环使用“handlers”。
- en: JSON configuration
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSON配置
- en: Since `dictconfig` takes any type of dictionary, it is actually quite simple
    to implement a different type of reader employing JSON or YAML files. This is
    especially useful as they tend to be a bit friendlier towards non-Python programmers.
    As opposed to Python files, they are easily readable and writable from outside
    of Python.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 由于“dictconfig”接受任何类型的字典，因此实际上可以很容易地实现使用JSON或YAML文件的不同类型的读取器。这是特别有用的，因为它们对非Python程序员来说更加友好。与Python文件相比，它们易于从Python之外进行读取和写入。
- en: 'Let''s assume that we have a `log_config.json` file such as the following:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个“log_config.json”文件，如下所示：
- en: '[PRE77]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We can simply use this code to read the config:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简单地使用这段代码来读取配置：
- en: '[PRE78]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Ini file configuration
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ini文件配置
- en: 'The file configuration is probably the most readable format for non-programmers.
    It uses the `ini-style` configuration format and uses the `configparser` module
    internally. The downside is that it is perhaps a little verbose, but it is clear
    enough and makes it easy to combine several configuration files without us having
    to worry too much about overwriting other configurations. Having said that, if
    `dictConfig` is an option, then it is most likely a better option. This is because
    `fileConfig` is slightly limited and awkward at times. Just look at the handlers
    as an example:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 文件配置可能是非程序员最可读的格式。它使用“ini-style”配置格式，并在内部使用“configparser”模块。缺点是它可能有点冗长，但它足够清晰，并且使得可以轻松地组合几个配置文件，而无需过多担心覆盖其他配置。话虽如此，如果“dictConfig”是一个选项，那么它很可能是一个更好的选项。这是因为“fileConfig”有时稍微有限且笨拙。只需看处理程序作为一个例子：
- en: '[PRE79]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Reading the files is extremely easy though:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，读取文件非常容易：
- en: '[PRE80]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: One thing to make note of, however, is that if you look carefully, you will
    see that this config is slightly different from the other configs. With `fileConfig`
    you can't just use keyword arguments alone. The `args` is required for both `FileHandler`
    and `StreamHandler`.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要注意的一点是，如果您仔细观察，您会发现这个配置与其他配置略有不同。使用“fileConfig”时，您不能仅仅使用关键字参数。对于“FileHandler”和“StreamHandler”，都需要“args”。
- en: The network configuration
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络配置
- en: The network configuration is both very convenient and a bit dangerous, because
    it allows you to configure your logger on the fly while your application/script
    is still running. The dangerous part is that the config is (partially) read by
    using the `eval` function, which allows people to potentially execute code within
    your application remotely. Even though `logging.config.listen` only listens to
    local connections, it can still be dangerous if you execute the code on a shared/unsafe
    host.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 网络配置既非常方便，又有点危险，因为它允许您在应用程序/脚本仍在运行时即时配置记录器。危险的部分是配置部分地使用了“eval”函数，这允许人们潜在地在您的应用程序中远程执行代码。即使“logging.config.listen”只监听本地连接，如果您在共享/不安全的主机上执行代码，它仍然可能是危险的。
- en: 'Luckily, since version Python 3.4, it is possible to add a `verify` parameter,
    which is a function that will be executed to convert the input into the output.
    The default is obviously something along the lines of `lambda config: config,`
    but it can be configured to return just about anything.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '幸运的是，自Python 3.4版本以来，可以添加一个`verify`参数，这是一个将被执行以将输入转换为输出的函数。默认值显然是类似于`lambda
    config: config`的东西，但可以配置为返回几乎任何内容。'
- en: 'To prove this point through an example, we need two scripts. One script will
    continuously print a few messages to the loggers and the other will change the
    logging configuration. We will start with the same test code that we had before
    but keep it running in an endless loop with a `sleep` in between:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过示例证明这一点，我们需要两个脚本。一个脚本将不断向记录器打印一些消息，另一个将更改日志配置。我们将从之前的相同测试代码开始，但保持它在无限循环中运行，并在其中间使用`sleep`：
- en: '[PRE81]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now comes the code that will send the configuration file:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来发送配置文件的代码：
- en: '[PRE82]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Next, let''s see the output. After the first execution of the loop, we will
    execute the second script to read the logging configuration:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看输出。在循环的第一次执行之后，我们将执行第二个脚本来读取日志配置：
- en: '[PRE83]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'You might be wondering where the rest of the output is. There is none. The
    `debug.log` file has been filled with messages like these, however:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道其余输出在哪里。没有。`debug.log`文件已经填满了这样的消息：
- en: '[PRE84]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'So what happened? This is where we see the pitfalls of custom loggers and configuration
    after using the loggers. The `logging.config.listen` function will modify the
    root logger as requested, but since the other loggers (`some` and `some.other`)
    weren''t specified, they weren''t modified. We modify the configuration to include
    them, as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 那么发生了什么？这就是我们在使用记录器后自定义记录器和配置的陷阱所在。`logging.config.listen`函数将根记录器按要求修改，但由于其他记录器（`some`和`some.other`）没有指定，它们没有被修改。我们修改配置以包括它们，如下所示：
- en: '[PRE85]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now it works as expected:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它按预期工作：
- en: '[PRE86]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: You will probably notice that we didn't add any handlers to the `some` logger.
    That's because the handler is already present—at the root level. However, without
    manually telling the logging module that the logger is there, it won't send it
    to the handler anymore. This is not problematic generally, but it's a dangerous
    pitfall when modifying logging configurations at runtime.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到我们没有向`some`记录器添加任何处理程序。那是因为处理程序已经存在-在根级别。但是，如果没有手动告诉日志模块记录器在那里，它就不会再将其发送到处理程序。这通常不是问题，但在运行时修改日志配置时，这是一个危险的陷阱。
- en: 'An alternative way to configure it without having this propagation issue is
    by disabling propagation altogether, but that will create an entirely new logger
    and will forget any configuration added to the root. So, if you have a handler
    for the error level at the root that gets sent to your error reporting system,
    it won''t arrive anymore. In this case, however, the config is slightly clearer:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种配置它的方法是完全禁用传播，但这将创建一个全新的记录器，并且会忘记添加到根记录器的任何配置。因此，如果您在根记录器上有一个处理错误级别的处理程序，将其发送到错误报告系统，那么它将不再到达。然而，在这种情况下，配置略微更清晰：
- en: '[PRE87]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Logger
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录器
- en: The main object that you will be using all the time with the `logging` module
    is the `Logger` object. This object contains all the APIs that you will need to
    do the actual logging. Most are simple enough but some require attention.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 您将一直使用`logging`模块的主要对象是`Logger`对象。此对象包含您需要执行实际记录的所有API。大多数都很简单，但有些需要注意。
- en: 'First of all, loggers inherit the parent settings by default. As we have seen
    previously with the propagate setting, by default, all settings will propagate
    from the parent. This is really useful when incorporating loggers within your
    files. Assuming your modules are using sane names and import paths, I recommend
    the following style of naming your loggers:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，记录器默认继承父设置。正如我们之前在传播设置中看到的那样，默认情况下，所有设置都将从父级传播。当在文件中合并记录器时，这非常有用。假设您的模块使用合理的名称和导入路径，我建议您使用以下样式命名您的记录器：
- en: '[PRE88]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'By using this style, your loggers will get names such as `main_module.sub_module.ClassName`.
    Not only does this make your logs easier to read, but also it is easily possible
    to enable or disable logging per module with the propagation of log settings.
    To create a new log file that logs everything from `main_module.sub_module`, we
    can simply do this:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这种风格，您的记录器将获得诸如`main_module.sub_module.ClassName`之类的名称。这不仅使您的日志更容易阅读，而且很容易通过日志设置的传播来启用或禁用每个模块的日志记录。要创建一个新的日志文件，记录来自`main_module.sub_module`的所有内容，我们只需这样做：
- en: '[PRE89]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Alternatively, you can configure it using your chosen configuration option,
    of course. The relevant point is that with sub-loggers, you have very fine-grained
    control over your loggers.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您也可以使用您选择的配置选项进行配置。相关的重点是，通过子记录器，您可以对记录器进行非常精细的控制。
- en: 'This includes increasing the log level:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括增加日志级别：
- en: '[PRE90]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Usage
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用法
- en: 'The usage of the `Logger` object is mostly identical to that of the bare `logging`
    module, but `Logger` actually supports a bit more. This is because the bare `logging`
    module just calls the functions on the root logger. It has a few very useful properties,
    although most of these are undocumented in the library:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`Logger`对象的使用方式与裸`logging`模块的使用方式基本相同，但`Logger`实际上支持更多。这是因为裸`logging`模块只是调用根记录器上的函数。它有一些非常有用的属性，尽管大多数在库中没有记录：'
- en: '`Propagate`: Whether to pass events to this logger or to the handlers of the
    parent loggers. Without this, a log message to `main_module.sub_module` won''t
    be logged by `main_module`.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`传播`：是否将事件传递给此记录器或父记录器的处理程序。如果没有这个，`main_module.sub_module`的日志消息将不会被`main_module`记录。'
- en: The `handle` method will keep looking for parent handlers as long as those loggers
    have `propagate` set to `true`, which is the default.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`handle`方法将继续寻找父处理程序，只要这些记录器的`propagate`设置为`true`，这是默认值。'
- en: '`Filters`: These are the filters attached to the logger. They can be added
    through `addFilter` and `removeFilter`, To see whether a message will be filtered,
    the `filter` method can be used.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Filters`：这些是附加到记录器的过滤器。它们可以通过`addFilter`和`removeFilter`添加。可以使用`filter`方法查看消息是否将被过滤。'
- en: '`Disabled`: By setting this property, it''s possible to disable a certain logger.
    The regular API only allows disabling of all loggers below a certain level. This
    offers some fine-grained control.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Disabled`：通过设置此属性，可以禁用特定的记录器。常规API只允许禁用某个级别以下的所有记录器。这提供了一些精细的控制。'
- en: '`Handlers`: These are the handlers attached to the logger. They can be added
    through `addHandler` and `removeHandler`. The existence of any (inherited) handlers
    can be checked through the `hasHandlers` function.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Handlers`：这些是附加到记录器的处理程序。它们可以通过`addHandler`和`removeHandler`添加。可以通过`hasHandlers`函数检查任何（继承的）处理程序的存在。'
- en: '`Level`: This is really an internal one as it simply has a numeric value and
    not a name. But beyond that, it doesn''t take inheritance into account, so it''s
    better to avoid the property and use the `getEffectiveLevel` function instead.
    To check whether the setting is enabled for a `DEBUG` for example, you can simply
    do `logger.isEnabledFor(logging.DEBUG)`. Setting the property is possible through
    the `setLevel` function, of course.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Level`：这实际上是一个内部属性，因为它只有一个数值，而不是一个名称。但除此之外，它不考虑继承，因此最好避免使用该属性，而是使用`getEffectiveLevel`函数。例如，要检查是否启用了`DEBUG`设置，只需执行`logger.isEnabledFor(logging.DEBUG)`。当然，可以通过`setLevel`函数设置该属性。'
- en: '`Name`: As this property''s name says, it is very useful for your own reference,
    of course.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Name`：正如此属性的名称所示，它对您自己的参考非常有用。'
- en: 'Now that you know about the properties, it is time to discuss the logging functions
    themselves. The functions you will use most often are the `log`, `debug`, `info`,
    `warning`, `error`, and `critical` log functions. They can be used quite simply,
    but they support string formatting as well, which is very useful:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了这些属性，是时候讨论日志记录函数本身了。您最常使用的函数是`log`、`debug`、`info`、`warning`、`error`和`critical`日志函数。它们可以很简单地使用，但也支持字符串格式化，这非常有用：
- en: '[PRE91]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: You might wonder why we don't simply use the regular string formatting with
    `%` or `string.format` instead. The reason is that when parameters are used instead
    of preformatted strings, the handler gets them as parameters. The result is that
    you can group log messages by the original string, which is what tools such as
    sentry ([https://github.com/getsentry/sentry](https://github.com/getsentry/sentry))
    use.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想为什么我们不简单地使用`%`或`string.format`进行常规字符串格式化。原因是当使用参数而不是预格式化的字符串时，处理程序会将它们作为参数。结果是您可以按原始字符串对日志消息进行分组，这就是诸如sentry（[https://github.com/getsentry/sentry](https://github.com/getsentry/sentry)）等工具使用的方法。
- en: 'There is more to it, however. In terms of parameters, `*args` are only for
    string formatting, but it''s possible to add extra parameters to a log object
    using the `extra` keyword parameter:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有更多内容。在参数方面，`*args`仅用于字符串格式化，但可以使用`extra`关键字参数向日志对象添加额外参数：
- en: '[PRE92]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'These `extra` parameters can be used in the logging formatter to display extra
    information just like the standard formatting options:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`extra`参数可以在日志格式化程序中使用，以显示额外信息，就像标准格式化选项一样：
- en: '[PRE93]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'This results in the following:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下结果：
- en: '[PRE94]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'However, one of the most useful features is the support for exceptions:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最有用的功能之一是对异常的支持：
- en: '[PRE95]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'This results in a stack trace for the exception, but it will not kill the code:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致异常的堆栈跟踪，但不会终止代码：
- en: '[PRE96]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Summary
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter showed us how to write `doctests`, make use of the shortcuts provided
    by `py.test`, and use the `logging` module. With testing, there is never a one-size-fits-all
    solution. While the `doctest` system is very useful in many cases for providing
    both documentation and tests at the same time, in many functions, there are edge
    cases that simply don't matter for documentation, but still need to be tested.
    This is where regular unit tests come in and where `py.test` helps a lot.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向我们展示了如何编写`doctests`，利用`py.test`提供的快捷方式，并使用`logging`模块。在测试中，从来没有一种适合所有情况的解决方案。虽然`doctest`系统在许多情况下非常有用，可以同时提供文档和测试，但在许多函数中，有一些边缘情况对于文档来说并不重要，但仍然需要进行测试。这就是常规单元测试和`py.test`发挥作用的地方。
- en: Because the `py.test` library is always evolving, this chapter cannot fully
    cover everything you will need, but it should provide you with enough of a basis
    to be able to use it effectively and extend it where needed.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`py.test`库一直在不断发展，本章无法完全涵盖您所需的一切，但它应该为您提供了足够的基础，能够有效地使用它，并在需要时进行扩展。
- en: The logging module is extremely useful but it's also a pain if configured incorrectly.
    Unfortunately, the right configuration can be a bit obscure when multiple modules
    are trying to configure logging simultaneously. The usage of the logging system
    should be clear enough for most of the common use cases now, and as long as you
    keep the `propagate` parameter in check, you should be fine when implementing
    a logging system.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录模块非常有用，但如果配置不正确，也会很麻烦。不幸的是，当多个模块同时尝试配置日志记录时，正确的配置可能有点难以理解。日志系统的使用现在应该对大多数常见用例足够清晰了，只要您保持`propagate`参数的检查，实现日志系统时应该没问题。
- en: Next up is debugging, where testing helps prevent bugs. We will see how to solve
    them effectively. In addition, the logging that we added in this chapter will
    help a lot in that area.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是调试，测试有助于防止错误。我们将看到如何有效地解决它们。此外，本章中添加的日志记录将在这方面帮助很多。
