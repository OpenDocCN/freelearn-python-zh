- en: Monitoring a Surfing Competition with Cloud-Based Real-Time MQTT Providers and
    Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基于云的实时MQTT提供程序和Python监控冲浪比赛
- en: 'In this chapter, we will write Python code to use the PubNub cloud-based real-time
    MQTT provider in combination with a Mosquitto MQTT server to monitor a surfing
    competition. We will build a solution from scratch by analyzing the requirements,
    and we will write Python code that will run on waterproof IoT boards connected
    to multiple sensors in surfboards. We will define the topics and commands, and
    we will work with a cloud-based MQTT server in combination with the Mosquitto
    MQTT server used in the previous chapters. We will cover the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将编写Python代码，使用PubNub基于云的实时MQTT提供程序与Mosquitto MQTT服务器结合，监控冲浪比赛。我们将通过分析需求从头构建解决方案，并编写Python代码，该代码将在连接到冲浪板中的多个传感器的防水IoT板上运行。我们将定义主题和命令，并与基于云的MQTT服务器以及在先前章节中使用的Mosquitto
    MQTT服务器一起工作。我们将涵盖以下内容：
- en: Understanding the requirements
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解要求
- en: Defining the topics and payloads
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义主题和有效载荷
- en: Coding a surfboard sensor emulator
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写冲浪板传感器仿真器
- en: Configuring PubNub MQTT interface
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置PubNub MQTT接口
- en: Publishing data retrieved from sensors to the cloud-based MQTT server
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将从传感器检索的数据发布到基于云的MQTT服务器
- en: Working with multiple MQTT servers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个MQTT服务器
- en: Building a web-based dashboard with freeboard
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用freeboard构建基于Web的仪表板
- en: Understanding the requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解要求
- en: 'Many surfers that are training for surfing competitions want us to build a
    real-time web-based dashboard with the data provided by an IoT board connected
    to multiple sensors in the surfboards. Each IoT board will provide the following
    data:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 许多为冲浪比赛训练的冲浪者希望我们构建一个实时基于Web的仪表板，该仪表板使用连接到冲浪板中的多个传感器的IoT板提供的数据。每个IoT板将提供以下数据：
- en: '**Status**: Many wearable wireless sensors embedded in each surfer''s wetsuit
    and other sensors included in the surfboard will provide data and the IoT board
    will perform a real-time analysis to indicate the status of the surfer'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态**：每个冲浪者的潜水服中嵌入了许多可穿戴无线传感器，冲浪板中还包括其他传感器，它们将提供数据，而IoT板将进行实时分析以指示冲浪者的状态'
- en: '**Speed**: A sensor will measure the surfboard''s speed in **miles per hour**
    (**mph**)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**：传感器将以**每小时英里**（**mph**）测量冲浪板的速度'
- en: '**Altitude**: A sensor will measure the surfboard''s altitude in feet'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**海拔**：传感器将以英尺测量冲浪板的海拔'
- en: '**Water temperature**: A sensor located in one of the surfboard''s fins will
    measure the water temperature in degrees Fahrenheit'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水温**：位于冲浪板鳍中的传感器将以华氏度测量水温'
- en: Third-party software is running on the IoT board and we cannot make changes
    to the code that publishes the data on different topics. We can provide the necessary
    certificates to configure the secured connection with our Mosquitto MQTT server
    and specify its host name and protocol. In addition, we can configure a name that
    identifies the surfboard and determines the topics in which the data will be published.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方软件正在IoT板上运行，我们无法更改发布不同主题数据的代码。我们可以提供必要的证书来配置与我们的Mosquitto MQTT服务器的安全连接，并指定其主机名和协议。此外，我们可以配置一个标识冲浪板并确定数据将被发布的主题的名称。
- en: Defining the topics and payloads
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义主题和有效载荷
- en: 'The IoT board uses the following topic names to publish data about a specific
    surfboard, where `surfboardname` must be replaced with a unique name assigned
    to a surfboard:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: IoT板使用以下主题名称发布有关特定冲浪板的数据，其中`sufboardname`必须替换为分配给冲浪板的唯一名称：
- en: '| **Variable** | **Topic name** |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| **变量** | **主题名称** |'
- en: '| Status | `surfboards/surfboardname/status` |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 状态 | `surfboards/surfboardname/status` |'
- en: '| Speed (mph) | `surfboards/surfboardname/speedmph` |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 速度（mph） | `surfboards/surfboardname/speedmph` |'
- en: '| Altitude (feet) | `surfboards/surfboardname/altitudefeet` |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 海拔（英尺） | `surfboards/surfboardname/altitudefeet` |'
- en: '| Water temperature (degrees Fahrenheit) | `surfboards/surfboardname/temperaturef`
    |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 水温（华氏度） | `surfboards/surfboardname/temperaturef` |'
- en: For example, if we assign `surfboard01` as the name for the surfboard, the client
    that wants to receive the actual speed for the surfboard has to subscribe to the
    `surfboards/surfboard01/speedmph` topic.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们将`sufboard01`指定为冲浪板的名称，那么想要接收冲浪板实际速度的客户端必须订阅`sufboards/surfboard01/speedmph`主题。
- en: 'The IoT board and its connected sensors are capable of distinguishing between
    the following five possible statuses of a surfer and their surfboard:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: IoT板及其连接的传感器能够区分冲浪者及其冲浪板的以下五种可能状态：
- en: '| **Status key** | **Meaning** |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| **状态键** | **含义** |'
- en: '| `0` | Idle |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `0` | 空闲 |'
- en: '| `1` | Paddling |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `1` | 划水 |'
- en: '| `2` | Riding |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `2` | 骑行 |'
- en: '| `3` | Ride finished |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `3` | 骑行结束 |'
- en: '| `4` | Wiped out |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `4` | 摔倒 |'
- en: The IoT board publishes the integer value specified in the status key column
    that indicates the current status of a surfer and their surfboard. For example,
    when a surfer is riding a wave, the board will publish `2` to the `surfboards/surfboard01/status`
    topic.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: IoT板发布指定在状态键列中的整数值，指示冲浪者及其冲浪板的当前状态。例如，当冲浪者在冲浪时，板将在`sufboards/surfboard01/status`主题中发布`2`。
- en: The board will publish floating-point values in the previously explained topics
    for speed, altitude, and water temperature. In this case, the IoT board will just
    publish either the integer or floating-point values as the payloads for the MQTT
    messages. The payload won't be JSON, as in our previous examples. The payload
    won't include any additional information about the unit of measurement. This information
    is included in the topic name.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 该板将在先前解释的主题中发布速度、海拔和水温的浮点值。在这种情况下，IoT板将只发布整数或浮点值作为MQTT消息的有效载荷。有效载荷不会是JSON，就像我们之前的例子一样。有效载荷不会包含有关测量单位的任何其他信息。此信息包含在主题名称中。
- en: The IoT board will publish the data in the previously explained topics every
    second.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: IoT板将在先前解释的主题中每秒发布数据。
- en: In the previous examples, we designed our solution from scratch. In this case,
    we have to interact with an IoT board that is already running code that we cannot
    change. Imagine that we have to start working on the solution without the IoT
    board; therefore, we will develop a surfboard sensor emulator in Python that will
    provide us with data so that we can receive the published data and develop the
    desired dashboard. In real-life projects, this is a very common scenario.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，我们是从零开始设计我们的解决方案。在这种情况下，我们必须与已经运行我们无法更改代码的物联网板进行交互。想象一下，我们必须在没有物联网板的情况下开始解决方案的工作；因此，我们将在Python中开发一个冲浪板传感器模拟器，以便为我们提供数据，以便我们可以接收发布的数据并开发所需的仪表板。在现实项目中，这是一个非常常见的情况。
- en: 'As we learned in the previous chapters, MQTT has become an extremely popular
    protocol for IoT projects in which many sensors have to publish data. Due to this
    increasing popularity, many cloud-based messaging infrastructures have included
    MQTT interfaces or bridges. For example, the PubNub data stream network provides
    a scalable MQTT interface. We can take advantage of everything we learned so far
    about MQTT to work with this cloud-based data stream network. You can read more
    about PubNub on its web page: [http://www.pubnub.com](http://www.pubnub.com).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的章节中学到的，MQTT已经成为物联网项目中非常流行的协议，其中许多传感器必须发布数据。由于其日益增长的流行度，许多基于云的消息基础设施已经包含了MQTT接口或桥接。例如，PubNub数据流网络提供了可扩展的MQTT接口。我们可以利用到目前为止我们所学到的关于MQTT的一切来使用这个基于云的数据流网络。您可以在其网页上了解更多关于PubNub的信息：[http://www.pubnub.com](http://www.pubnub.com)。
- en: A Python program will collect the data published by the IoT board by subscribing
    to the four topics and the code will build a complete status for the surfer and
    their surfboard every second. Then, the code will build a JSON message with the
    status, speed, altitude, and water temperature and it will publish it to a topic
    of the MQTT PubNub interface.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Python程序将通过订阅四个主题来收集物联网板发布的数据，并且代码将每秒构建一个完整的冲浪者及其冲浪板状态。然后，代码将构建一个包含状态、速度、海拔和水温的JSON消息，并将其发布到MQTT
    PubNub接口的一个主题。
- en: In our example, we will take advantage of the free services offered by PubNub
    and its MQTT interface. We won't use some advanced features and additional services
    that might empower our IoT project connectivity requirements, but also require
    a paid subscription.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将利用PubNub及其MQTT接口提供的免费服务。我们不会使用一些可能增强我们的物联网项目连接需求的高级功能和附加服务，但这些功能也需要付费订阅。
- en: 'We will take advantage of freeboard.io to visualize the data collected from
    the sensors and published to the PubNub MQTT interface in many gauges and make
    the dashboard available to different computers and devices all over the world.
    freeboard.io allows us to build a dashboard by selecting data sources and dragging
    and dropping customizable widgets. freeboard.io defines itself as a cloud-based
    service that allows us to visualize the Internet of Things. You can read more
    about freeboard.io in its web page: [http://freeboard.io](http://freeboard.io).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用freeboard.io来可视化从传感器收集的数据，并在PubNub MQTT接口中发布，以多个表盘的形式呈现，并且可以在全球范围内的不同计算机和设备上使用。freeboard.io允许我们通过选择数据源并拖放可定制的小部件来构建仪表板。freeboard.io定义自己为一个允许我们可视化物联网的基于云的服务。您可以在其网页上了解更多关于freeboard.io的信息：[http://freeboard.io](http://freeboard.io)。
- en: In our example, we will take advantage of the free services offered by freeboard.io
    and we won't use some advanced features that provide privacy for our dashboards,
    but also require a paid subscription. Our dashboard will be available to anyone
    that has the unique URL for it because we are not working with private dashboards.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将利用freeboard.io提供的免费服务，并且我们不会使用一些提供我们仪表板隐私的高级功能，但这些功能也需要付费订阅。我们的仪表板将对任何拥有其唯一URL的人可用，因为我们不使用私人仪表板。
- en: 'The following lines show an example of the payload for the message that provides
    the status of the surfer and their surfboard:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是提供冲浪者及其冲浪板状态的消息负载的示例。
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Freeboard.io allows us to easily select each key of the JSON message received
    in the PubNub MQTT interface as a data source for the dashboard. This way, we
    will easily build a web-based dashboard to provide us with the status, speed,
    altitude, and water temperature values in gauges.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Freeboard.io允许我们轻松地选择PubNub MQTT接口中接收的JSON消息的每个键作为仪表板的数据源。这样，我们将轻松地构建一个基于Web的仪表板，以提供给我们状态、速度、海拔和水温数值的表盘。
- en: 'To summarize, our solution will be composed of the following two Python programs:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们的解决方案将由以下两个Python程序组成：
- en: '**Surfboard sensor emulator**: This program will establish a secured connection
    to our Mosquitto MQTT server and it will publish status, speed, altitude, and
    water temperature values read from a **CSV** (short for **Comma Separated Values**)
    file to the appropriate topics every second. The program will work as if we had
    a real-life surfer with his wetsuit and surfboard sensors riding waves and publishing
    data.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冲浪板传感器模拟器**：该程序将与我们的Mosquitto MQTT服务器建立安全连接，并且将从**CSV**（逗号分隔值）文件中读取的状态、速度、海拔和水温数值发布到适当的主题。该程序将工作得就像我们有一个穿着潜水服和冲浪板传感器的真实冲浪者在冲浪并发布数据一样。'
- en: '**Surfboard monitor**: This program will establish a secured connection to
    our Mosquitto MQTT server and it will subscribe to the topics in which the surfboard
    sensor emulator publishes status, speed, altitude, and water temperature values.
    The surfboard monitor program will also establish a connection with the PubNub
    MQTT interface. The program will publish a single message with the key-value pairs
    that determine the status of a surfer and their surfboard to the PubNub MQTT interface
    every second.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冲浪板监视器**：该程序将与我们的Mosquitto MQTT服务器建立安全连接，并订阅冲浪板传感器模拟器发布的状态、速度、海拔和水温数值的主题。冲浪板监视器程序还将与PubNub
    MQTT接口建立连接。该程序将每秒向PubNub MQTT接口发布一个包含决定冲浪者及其冲浪板状态的键值对的单个消息。'
- en: Coding a surfboard sensor emulator
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写冲浪板传感器模拟器
- en: First, we will create a CSV file with many status, speed in mph, altitude in
    feet, and temperature in degrees Fahrenheit values separated by commas. Each line
    in the file will represent a set of values that the surfboard sensor emulator
    will publish to the appropriate topics. In this case, it is not convenient to
    work with random values because we want to emulate real-life scenarios for a surfer
    and his surfboard.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个CSV文件，其中包含许多状态、速度（以英里/小时为单位）、海拔（以英尺为单位）和温度（以华氏度为单位）的值，这些值用逗号分隔。文件中的每一行将代表冲浪板传感器模拟器将发布到相应主题的一组值。在这种情况下，使用随机值并不方便，因为我们希望模拟冲浪者和他的冲浪板的真实场景。
- en: Now, we will create a new file named `surfboard_sensors_data.csv` in the main
    virtual environment folder. The following lines show the code that defines the
    data retrieved from a short surfing session for the surfer and their surfboard.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在主虚拟环境文件夹中创建一个名为`surfboard_sensors_data.csv`的新文件。以下行显示了定义从冲浪者和他们的冲浪板中检索到的数据的代码。
- en: 'The values separated with commas from left to right are the following: speed
    in mph, altitude in feet, and temperature in degrees Fahrenheit. First, the surfer
    is idle, he increases the speed when paddling, he reaches the speed maximum value
    when riding the wave, and finally reduces speed when his status is set to ride
    finished. The code file for the sample is included in the `mqtt_python_gaston_hillar_06_01`
    folder, in the `surfboard_sensors_data.csv` file:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 从左到右用逗号分隔的值依次是：速度（以英里/小时为单位）、海拔（以英尺为单位）和温度（以华氏度为单位）。首先，冲浪者处于空闲状态，当划桨时增加速度，当冲浪时达到速度最大值，最后在状态设置为冲浪结束时减速。示例的代码文件包含在`mqtt_python_gaston_hillar_06_01`文件夹中的`surfboard_sensors_data.csv`文件中：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we will create a new Python file named `surfboard_config.py` in the main
    virtual environment folder. The following lines show the code for this file, which
    defines many configuration values that will be used to configure the topics to
    which the surfboard sensor emulator will publish the values retrieved from the
    sensors. The surfboard monitor will also need these topics to subscribe to them,
    and therefore it is convenient to include all the configuration values in a specific
    Python script. The code file for the sample is included in the `mqtt_python_gaston_hillar_06_01`
    folder, in the `surfboard_config.py` file:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在主虚拟环境文件夹中创建一个名为`surfboard_config.py`的新Python文件。以下行显示了此文件的代码，它定义了许多配置值，这些值将用于配置冲浪板传感器模拟器将发布从传感器检索到的值的主题。冲浪板监视器也将需要这些主题来订阅它们，因此将所有配置值包含在一个特定的Python脚本中是方便的。示例的代码文件包含在`mqtt_python_gaston_hillar_06_01`文件夹中的`surfboard_config.py`文件中：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The code defines the surfboard name and stores it in the `surfboard_name` variable.
    The `topic_format` variable holds a string that makes it easy to build different
    topics that have a common prefix. The following table summarizes the string values
    for the four variables that define the topic names for each sensor, based on a
    defined surfboard named `surfboard01`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码定义了冲浪板名称并将其存储在`surfboard_name`变量中。`topic_format`变量包含一个字符串，使得易于构建具有共同前缀的不同主题。以下表总结了四个变量的字符串值，这些变量定义了每个传感器的主题名称，基于一个名为`surfboard01`的定义的冲浪板：
- en: '| **Variable** | **Value** |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **变量** | **值** |'
- en: '| `status_topic` | `surfboards/surfboard01/status` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `status_topic` | `surfboards/surfboard01/status` |'
- en: '| `speed_mph_topic` | `surfboards/surfboard01/speedmph` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `speed_mph_topic` | `surfboards/surfboard01/speedmph` |'
- en: '| `altitude_feet_topic` | `surfboards/surfboard01/altitudefeet` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `altitude_feet_topic` | `surfboards/surfboard01/altitudefeet` |'
- en: '| `temperature_f_topic` | `surfboards/surfboard01/temperaturef` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `temperature_f_topic` | `surfboards/surfboard01/temperaturef` |'
- en: 'Now, we will create a new Python file named `surfboard_sensors_emulator.py`
    in the main virtual environment folder. The following lines show the code for
    this file, which establishes a connection with our Mosquitto MQTT server, reads
    the previously created `surfboard_sensors_data.csv` CSV file, and continuously
    publishes the values read from this file to the previously enumerated topics.
    The code file for the sample is included in the `mqtt_python_gaston_hillar_06_01`
    folder, in the `surfboard_sensors_emulator.py` file:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在主虚拟环境文件夹中创建一个名为`surfboard_sensors_emulator.py`的新Python文件。以下行显示了此文件的代码，它与我们的Mosquitto
    MQTT服务器建立连接，读取先前创建的`surfboard_sensors_data.csv` CSV文件，并持续发布从该文件中读取的值到先前枚举的主题。示例的代码文件包含在`mqtt_python_gaston_hillar_06_01`文件夹中的`surfboard_sensors_emulator.py`文件中：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In [Chapter 4](87908cb8-83ed-4b74-bfc5-dd0c4ddd93aa.xhtml), *Writing Code to
    Control a Vehicle with Python and MQTT Messages*, we created a Python file named
    `config.py` in the main virtual environment folder. In this file, we defined many
    configuration values that were used to establish a connection with the Mosquitto
    MQTT server. This way, all the configuration values were included in a specific
    Python script. If you need to make changes to this file to configure the surfboard
    emulator and the future surfboard monitor, make sure you review the explanations
    included in that chapter.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](87908cb8-83ed-4b74-bfc5-dd0c4ddd93aa.xhtml)中，*使用Python和MQTT消息编写控制车辆的代码*，我们在主虚拟环境文件夹中创建了一个名为`config.py`的Python文件。在这个文件中，我们定义了许多配置值，用于与Mosquitto
    MQTT服务器建立连接。这样，所有配置值都包含在一个特定的Python脚本中。如果您需要更改此文件以配置冲浪板模拟器和未来的冲浪板监视器，请确保您查看该章节中包含的解释。
- en: The first lines import the variables we have declared in the `config.py` file
    and in the previously coded `surfboard_config.py` file. In this case, we also
    import the `csv` module to enable us to easily read from the CSV file that contains
    the values for the emulated sensors. The code for the `on_connect` function is
    very similar to the one we used in our previous examples.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先导入了我们在`config.py`文件和先前编码的`surfboard_config.py`文件中声明的变量。在这种情况下，我们还导入了`csv`模块，以便我们可以轻松地从包含模拟传感器值的CSV文件中读取。`on_connect`函数的代码与我们在先前的示例中使用的代码非常相似。
- en: The `publish_value` function receives the MQTT client, the topic name, and the
    value that we want to publish in the `client`, `topic`, and `value` arguments.
    The function calls the `client.publish` method to publish the received value as
    the payload to the topic name received in the `topic` argument with a QoS level
    of 0.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`publish_value`函数接收MQTT客户端、主题名称和我们要在`client`、`topic`和`value`参数中发布的值。该函数调用`client.publish`方法，将接收到的值作为有效载荷发布到`topic`参数中接收到的主题名称，QoS级别为0。'
- en: The main block uses our very well-known code to establish a connection with
    the Mosquitto MQTT server. After calling the `client.connect` method, the code
    calls the `client.loop_start` method to start a new thread that processes the
    MQTT network traffic and frees up the main thread.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 主要代码块使用我们非常熟悉的代码与Mosquitto MQTT服务器建立连接。调用`client.connect`方法后，代码调用`client.loop_start`方法启动一个处理MQTT网络流量并释放主线程的新线程。
- en: Then, the codes enters in a continuous loop that opens the `surfboard_sensors_data.csv`
    CSV file and creates a `csv.reader` to read each row of comma-separated values
    into the `row` array. The code retrieves the string in `row[0]`, which represents
    the status value; converts it to an integer value; and saves the value in the
    `status_value` local variable. The next lines retrieve the strings for speed,
    altitude, and water temperature in `row[1]`, `row[2]`, and `row[3]`. The code
    converts these three values to floats and saves them in the `speed_mph_value`,
    `altitude_feet_value` and `water_temperature_f_value` local variables.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码进入一个连续循环，打开`surfboard_sensors_data.csv` CSV文件，并创建一个`csv.reader`来将逗号分隔的值的每一行读入`row`数组。代码检索`row[0]`中的字符串，该字符串代表状态值；将其转换为整数值；并将该值保存在`status_value`本地变量中。接下来的行检索`row[1]`、`row[2`和`row[3]`中的速度、海拔和水温的字符串。代码将这三个值转换为浮点数，并将它们保存在`speed_mph_value`、`altitude_feet_value`和`water_temperature_f_value`本地变量中。
- en: The next lines print debug messages with the values read for each emulated sensor
    from the CSV file and call the previously explained `publish_value` function for
    each of these values. Each call to the `publish_value` function uses the appropriate
    variable for the topic name that was configured in the `surfboard_config.py` file
    because each value is published to a different topic.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的行会打印调试消息，显示从CSV文件中读取的每个模拟传感器的值，并为每个值调用先前解释的`publish_value`函数。每次调用`publish_value`函数都会使用在`surfboard_config.py`文件中配置的主题名称的适当变量，因为每个值都会发布到不同的主题。
- en: After the code publishes the values for the four emulated sensors, it sleeps
    for one second and repeats the procedure for the next line in the CSV file. After
    the last line is read, the code starts the loop again until the user presses *Ctrl*
    + *C* and causes a `KeyboardInterrupt` exception to be thrown and captured. In
    this case, we capture this exception and call the `client.disconnect` and `client.loop_stop`
    methods to have an appropriate disconnection from the Mosquitto MQTT server. In
    previous examples, we didn't care about this exception.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码发布了四个模拟传感器的值后，它会休眠一秒钟，然后重复CSV文件中下一行的过程。在读取了最后一行后，代码会再次开始循环，直到用户按下*Ctrl* +
    *C*并引发`KeyboardInterrupt`异常被捕获。在这种情况下，我们捕获此异常并调用`client.disconnect`和`client.loop_stop`方法，以适当地从Mosquitto
    MQTT服务器断开连接。在以前的示例中，我们并不关心这个异常。
- en: Configuring the PubNub MQTT interface
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置PubNub MQTT接口
- en: PubNub requires us to sign up and create an account with a valid email and a
    password before we can create an application in PubNub, which allows us to start
    using their free services, including the PubNub MQTT interface for a device. We
    aren't required to enter any credit card or payment information. If you already
    have an account at PubNub, you can skip the next step.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用PubNub的免费服务之前，PubNub要求我们注册并创建一个带有有效电子邮件和密码的帐户，以便在PubNub中创建应用程序，包括设备的PubNub
    MQTT接口。我们不需要输入任何信用卡或付款信息。如果您已经在PubNub上有帐户，可以跳过下一步。
- en: Once you have created your account, PubNub will redirect you to the admin portal
    that lists your PubNub applications. It is necessary to generate your PubNub publish
    and subscribe keys in order to send and receive messages on the network. Click
    on CREATE NEW APP+, enter `MQTT` in App Name, and click CREATE.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 创建账户后，PubNub将重定向您到列出PubNub应用程序的管理门户。为了在网络上发送和接收消息，需要生成PubNub的发布和订阅密钥。点击CREATE
    NEW APP+，输入`MQTT`作为应用名称，然后点击CREATE。
- en: 'A new pane will represent the application in the admin portal. The following
    screenshot shows the MQTT application pane in the PubNub admin portal:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在管理门户中，一个新的窗格将代表应用程序。以下截图显示了PubNub管理门户中的MQTT应用程序窗格：
- en: '![](assets/9688a166-7994-4df1-93c5-9405719dbb2b.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9688a166-7994-4df1-93c5-9405719dbb2b.png)'
- en: 'Click on the MQTT pane and PubNub will display the Demo Keyset pane, which
    has been automatically generated for the application. Click on this pane and PubNub
    will display the Publish Key, Subscribe Key, and Secret key. We must copy and
    paste each of these keys to use them in our code that will use the PubNub MQTT
    interface to publish messages and the freeboard.io web-based dashboard that will
    subscribe to them. The following screenshot shows the prefixes for the keys. Notice
    that the remaining characters have been erased in the image:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 点击MQTT窗格，PubNub将显示自动生成的Demo Keyset窗格。点击此窗格，PubNub将显示Publish Key、Subscribe Key和Secret
    key。我们必须复制并粘贴这些密钥，以便在使用PubNub MQTT接口发布消息和订阅这些消息的freeboard.io基于Web的仪表板的代码中使用。以下截图显示了密钥的前缀。请注意，图像中的其余字符已被删除：
- en: '![](assets/1bd7d1cf-d2e7-4029-8689-cae606953d28.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1bd7d1cf-d2e7-4029-8689-cae606953d28.png)'
- en: In order to copy the Secret key, you must click on the eye icon at the right-hand
    side of the Secret key and PubNub will make all the characters visible.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了复制Secret key，您必须点击Secret key右侧的眼睛图标，PubNub将使所有字符可见。
- en: Publishing data retrieved from sensors to the cloud-based MQTT server
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从传感器检索的数据发布到基于云的MQTT服务器
- en: If we display the status of the surfer and his surfboard with numbers, it will
    be difficult to understand the real status. So, we will have to map the integer
    that represents the status into a string that explains the status.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用数字显示冲浪者和他的冲浪板的状态，那么理解真实状态将会很困难。因此，我们必须将表示状态的整数映射到解释状态的字符串。
- en: 'Now, we will create a new Python file named `surfboard_status.py` in the main
    virtual environment folder. The following lines show the code for this file, which
    defines constants for the different status numbers and a dictionary that maps
    these constants with integers to strings with the descriptions for the status.
    The code file for the sample is included in the `mqtt_python_gaston_hillar_06_01`
    folder, in the `surfboard_status.py` file:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在主虚拟环境文件夹中创建一个名为`surfboard_status.py`的新Python文件。以下行显示了此文件的代码，其中定义了不同状态数字的常量和将这些常量与整数映射到状态描述字符串的字典。示例的代码文件包含在`mqtt_python_gaston_hillar_06_01`文件夹中的`surfboard_status.py`文件中：
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we will write the code for the surfboard monitor. We will split the code
    into many code snippets to make it easier to understand each code section. Create
    a new Python file named `surfboard_monitor.py` in the main virtual environment
    folder. The following lines declare all the necessary imports and the variables
    that we will use to establish a connection with the PubNub MQTT interface. Don''t
    forget to replace the strings assigned to the `pubnub_publish_key` and `pubnub_subscribe_key`
    variables with the values you have retrieved from the previously explained PubNub
    key generation process. The code file for the sample is included in the `mqtt_python_gaston_hillar_06_01`
    folder, in the `surfboard_monitor.py` file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写冲浪板监视器的代码。我们将把代码分成许多代码片段，以便更容易理解每个代码部分。在主虚拟环境文件夹中创建一个名为`surfboard_monitor.py`的新Python文件。以下行声明了所有必要的导入和我们将用来与PubNub
    MQTT接口建立连接的变量。不要忘记用从先前解释的PubNub密钥生成过程中检索到的值替换分配给`pubnub_publish_key`和`pubnub_subscribe_key`变量的字符串。示例的代码文件包含在`mqtt_python_gaston_hillar_06_01`文件夹中的`surfboard_monitor.py`文件中：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The first lines import the variables we have declared in the `config.py` file
    and in the previously coded `surfboard_config.py` and `surfboard_status.py` files.
    Then, the code declares the following variables that we will use to establish
    a connection with the PubNub MQTT interface:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 首先导入了我们在`config.py`文件中声明的变量以及之前编写的`surfboard_config.py`和`surfboard_status.py`文件中的变量。然后，代码声明了以下变量，我们将使用这些变量与PubNub
    MQTT接口建立连接：
- en: '`pubnub_publish_key`: This string specifies the PubNub publish key.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pubnub_publish_key`：此字符串指定了PubNub发布密钥。'
- en: '`pubnub_subscribe_key`: This string specifies the PubNub subscribe key.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pubnub_subscribe_key`：此字符串指定了PubNub订阅密钥。'
- en: '`pubnub_mqtt_server_host`: This string specifies the PubNub MQTT server address.
    In order to use the PubNub MQTT interface, we must always establish a connection
    with the `mqtt.pndsn.com` host.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pubnub_mqtt_server_host`：此字符串指定了PubNub MQTT服务器地址。为了使用PubNub MQTT接口，我们必须始终与`mqtt.pndsn.com`主机建立连接。'
- en: '`pubnub_mqtt_server_port`: This number specifies the PubNub MQTT server port.
    In this case, we will establish an unsecured connection with the PubNub MQTT server,
    and therefore we will use port number `1883`. We want to keep the PubNub MQTT
    interface configuration simple for this example, and therefore we won''t use TLS.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pubnub_mqtt_server_port`：此数字指定了PubNub MQTT服务器端口。在这种情况下，我们将与PubNub MQTT服务器建立一个不安全的连接，因此我们将使用端口号`1883`。我们希望保持PubNub
    MQTT接口配置简单，因此在此示例中不使用TLS。'
- en: '`pubnub_mqtt_keepalive`: This number specifies the keep alive interval configuration
    for the connection with the PubNub MQTT interface.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pubnub_mqtt_keepalive`：此数字指定了与PubNub MQTT接口的连接的保持活动间隔配置。'
- en: '`device_id`: This string specifies the device identifier we want to use when
    we create an instance of the `Surfboard` class. The code assigns the `surfboard_name`
    value imported from the `surfboard_config.py` file. We will analyze the code for
    this class later.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device_id`：此字符串指定了我们在创建`Surfboard`类的实例时要使用的设备标识符。代码分配了从`surfboard_config.py`文件导入的`surfboard_name`值。我们稍后将分析此类的代码。'
- en: '`Pubnub_topic`: This string specifies the topic to which the surfboard monitor
    will publish the JSON payload with the key-value pairs that specify the status
    for the surfer and their surfboard. The code assigns the `surfboard_name` value
    imported from the `surfboard_config.py` file.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pubnub_topic`：此字符串指定了冲浪板监视器将向其发布JSON有效载荷的主题，该有效载荷包含指定冲浪者和他们的冲浪板状态的键值对。代码分配了从`surfboard_config.py`文件导入的`surfboard_name`值。'
- en: The surfboard monitor will establish a connection to the `mqtt.pndsn.com` host
    on port `1883`. So, we have to make sure that our firewall configuration has the
    appropriate inbound and outbound rules configurations to allow a connection on
    the specified port.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 冲浪板监视器将在端口`1883`上与`mqtt.pndsn.com`主机建立连接。因此，我们必须确保我们的防火墙配置具有适当的入站和出站规则配置，以允许在指定端口上建立连接。
- en: 'Add the following lines to the existing `surfboard_monitor.py` in the main
    virtual environment folder. The following lines declare the `Surfboard` class.
    The code file for the sample is included in the `mqtt_python_gaston_hillar_06_01`
    folder, in the `surfboard_monitor.py` file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下行添加到主虚拟环境文件夹中现有的`surfboard_monitor.py`中。以下行声明了`Surfboard`类。示例的代码文件包含在`mqtt_python_gaston_hillar_06_01`文件夹中的`surfboard_monitor.py`文件中：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have to specify a `device_id` and the initial values for the data that the
    sensors provide in the `device_id`, `status`, `speed_mph`, `altitude_feet`, and
    `water_temperature_f` required arguments. The constructor, that is, the `__init__`
    method, saves the received values in attributes with the same names.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须为传感器提供的数据的`device_id`、`status`、`speed_mph`、`altitude_feet`和`water_temperature_f`参数指定一个`device_id`和初始值。构造函数，即`__init__`方法，将接收到的值保存在同名的属性中。
- en: 'The code also saves a reference to this instance in the `active_instance` class
    attribute because we have to access the instance in many functions that we will
    specify as callbacks for the different events that two MQTT clients will fire:
    the PubNub MQTT client and the Mosquitto MQTT client. We will access the active
    instance with the `Surfboard.active_instance` class attribute after the code creates
    a `Surfboard` instance.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码还将引用保存在`active_instance`类属性中，因为我们必须在许多函数中访问该实例，这些函数将被指定为两个MQTT客户端触发的不同事件的回调：PubNub
    MQTT客户端和Mosquitto MQTT客户端。在代码创建`Surfboard`实例后，我们将使用`Surfboard.active_instance`类属性访问活动实例。
- en: The class declares the `build_json_message` method, which builds a message with
    the status for the surfboard and returns the JSON string with the key-value pairs
    that composes the status message. The code maps the number stored in the `status`
    attribute into the string that explains the status by using the `SURFBOARD_STATUS_DICTIONARY`
    declared in the `surfboard_status.py` file. The code uses the `speed_mph`, `altitude_feet`,
    and `water_temperature_f` attributes to provide the values for the other keys.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 该类声明了`build_json_message`方法，该方法构建了一个包含冲浪板状态的消息，并返回了由组成状态消息的键值对组成的JSON字符串。该代码使用`SURFBOARD_STATUS_DICTIONARY`在`surfboard_status.py`文件中声明的内容，将存储在`status`属性中的数字映射为解释状态的字符串。代码使用`speed_mph`，`altitude_feet`和`water_temperature_f`属性为其他键提供值。
- en: 'Add the following lines to the existing `surfboard_monitor.py` in the main
    virtual environment folder. The following lines declare the functions that we
    will use as callbacks and other functions that will be called by these callbacks.
    The code file for the sample is included in the `mqtt_python_gaston_hillar_06_01`
    folder, in the `surfboard_monitor.py` file:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在主虚拟环境文件夹中的现有`surfboard_monitor.py`中添加以下行。以下行声明了我们将用作回调的函数以及将由这些回调调用的其他函数。示例的代码文件包含在`mqtt_python_gaston_hillar_06_01`文件夹中的`surfboard_monitor.py`文件中：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The code declares the following functions that end with the `mosquitto` prefix:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码声明了以下以`mosquitto`前缀结尾的函数：
- en: '`on_connect_mosquitto`: This function is the callback that will be executed
    once a successful connection has been established with the Mosquitto MQTT server.
    The code checks the value of the `rc` argument that provides the `CONNACK` code
    returned by the Mosquitto MQTT server. If this value matches `mqtt.CONNACK_ACCEPTED`,
    it means that the Mosquitto MQTT server accepted the connection request, and therefore
    the code calls the `client.subscribe` method for the MQTT client received in the
    `client` argument to subscribe to the `surfboards/surfboard01/+` topic filter
    with a QoS level of 0\. This way, the MQTT client will receive the messages sent
    to the `surfboards/surfboard01/status`, `surfboards/surfboard01/speedmph`, `surfboards/surfboard01/altitudefeet`,
    and `surfboards/surfboard01/temperaturef` topics with the values retrieved from
    the different sensors.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on_connect_mosquitto`：这个函数是一旦与Mosquitto MQTT服务器建立了成功的连接，就会执行的回调。代码检查`rc`参数的值，该参数提供Mosquitto
    MQTT服务器返回的`CONNACK`代码。如果此值匹配`mqtt.CONNACK_ACCEPTED`，则意味着Mosquitto MQTT服务器接受了连接请求，因此代码调用`client.subscribe`方法，为`client`参数中接收的MQTT客户端订阅`surfboards/surfboard01/+`主题过滤器，QoS级别为0。这样，MQTT客户端将接收从不同传感器检索的值发送到`surfboards/surfboard01/status`，`surfboards/surfboard01/speedmph`，`surfboards/surfboard01/altitudefeet`和`surfboards/surfboard01/temperaturef`主题的消息。'
- en: '`on_subscribe_mosquitto`: This function will be called when the subscription
    to the `surfboards/surfboard01/+` topic filter has been successfully completed.
    As in previous examples, the function prints a message indicating the QoS level
    granted to the subscription.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on_subscribe_mosquitto`：当成功完成对`surfboards/surfboard01/+`主题过滤器的订阅时，将调用此函数。与之前的示例一样，该函数打印一条消息，指示订阅所授予的QoS级别。'
- en: '`print_received_message_mosquitto`: This function receives an `mqtt.MQTTMessage`
    instance in the `msg` argument and prints the topic and the payload of this message
    to help us understand what is happening in the application.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print_received_message_mosquitto`：此函数在`msg`参数中接收一个`mqtt.MQTTMessage`实例，并打印此消息的主题和负载，以帮助我们理解应用程序中发生的情况。'
- en: '`on_status_message_mosquitto`: This function will be called when a message
    to the `surfboards/surfboard01/status` topic arrives from the Mosquitto MQTT server.
    The function calls the `print_received_message_mosquitto` function with the received
    `mqtt.MQTTMessage` instance as an argument and sets the value of the `status`
    attribute of the `Surfboard` active instance to the conversion of the received
    message''s payload to an `int`.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on_status_message_mosquitto`：当来自Mosquitto MQTT服务器的消息到达`surfboards/surfboard01/status`主题时，将调用此函数。该函数使用接收到的`mqtt.MQTTMessage`实例作为参数调用`print_received_message_mosquitto`函数，并将`Surfboard`活动实例的`status`属性值设置为接收到的消息负载转换为`int`的值。'
- en: '`on_speed_mph_message_mosquitto`: This function will be called when a message
    to the `surfboards/surfboard01/speedmph` topic arrives from the Mosquitto MQTT
    server. The function calls the `print_received_message_mosquitto` function with
    the received `mqtt.MQTTMessage` instance as an argument and sets the value of
    the `speed_mph` attribute of the `Surfboard` active instance to the conversion
    of the received message''s payload to a `float`.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on_speed_mph_message_mosquitto`：当来自Mosquitto MQTT服务器的消息到达`surfboards/surfboard01/speedmph`主题时，将调用此函数。该函数使用接收到的`mqtt.MQTTMessage`实例作为参数调用`print_received_message_mosquitto`函数，并将`Surfboard`活动实例的`speed_mph`属性值设置为接收到的消息负载转换为`float`的值。'
- en: '`on_altitude_feet_message_mosquitto`: This function will be called when a message
    to the `surfboards/surfboard01/altitudefeet` topic arrives from the Mosquitto
    MQTT server. The function calls the `print_received_message_mosquitto` function
    with the received `mqtt.MQTTMessage` instance as an argument and sets the value
    of the `altitude_feet` attribute of the `Surfboard` active instance to the conversion
    of the received message''s payload to an `int`.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on_altitude_feet_message_mosquitto`：当从Mosquitto MQTT服务器接收到`surfboards/surfboard01/altitudefeet`主题的消息时，将调用此函数。
    该函数使用接收到的`mqtt.MQTTMessage`实例作为参数调用`print_received_message_mosquitto`函数，并将`Surfboard`活动实例的`altitude_feet`属性值设置为接收到的消息负载的整数转换。'
- en: '`on_water_temperature_f_message_mosquitto`: This function will be called when
    a message to the `surfboards/surfboard01/watertemperaturef` topic arrives from
    the Mosquitto MQTT server. The function calls the `print_received_message_mosquitto`
    function with the received `mqtt.MQTTMessage` instance as an argument and sets
    the value of the `water_temperature_f` attribute of the `Surfboard` active instance
    to the conversion of the received message''s payload to an `int`.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on_water_temperature_f_message_mosquitto`：当从Mosquitto MQTT服务器接收到`surfboards/surfboard01/watertemperaturef`主题的消息时，将调用此函数。
    该函数使用接收到的`mqtt.MQTTMessage`实例作为参数调用`print_received_message_mosquitto`函数，并将`Surfboard`活动实例的`water_temperature_f`属性值设置为接收到的消息负载的整数转换。'
- en: In this case, we don't have a single function that works as a callback to process
    all the incoming messages from the Mosquitto MQTT server. We work with a callback
    for each specific topic. This way, we don't have to check the topic for the message
    to determine the code that we have to run.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们没有一个单独的函数作为回调来处理来自Mosquitto MQTT服务器的所有传入消息。 我们为每个特定主题使用一个回调。 这样，我们就不必检查消息的主题以确定我们必须运行的代码。
- en: 'The code declares the following functions that end with the `pubnub` prefix:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 代码声明了以下以`pubnub`前缀结尾的函数：
- en: '`on_connect_pubnub`: This function is the callback that will be executed once
    a successful connection has been established with the PubNub MQTT server. The
    code checks the value of the `rc` argument that provides the `CONNACK` code returned
    by the PubNub MQTT server. If this value matches `mqtt.CONNACK_ACCEPTED`, it means
    that the PubNub MQTT server accepted the connection request, and therefore the
    code sets the value of the `is_pubnub_connected` attribute of the Surfboard active
    instance to `True`.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on_connect_pubnub`：一旦与PubNub MQTT服务器建立成功连接，将执行此回调函数。 该代码检查提供PubNub MQTT服务器返回的`CONNACK`代码的`rc`参数的值。
    如果此值与`mqtt.CONNACK_ACCEPTED`匹配，则表示PubNub MQTT服务器接受了连接请求，因此代码将Surfboard活动实例的`is_pubnub_connected`属性值设置为`True`。'
- en: '`on_disconnect_pubnub`: This function is the callback that will be executed
    if the client that was connected to the PubNub MQTT server loses the connection.
    The code sets the value of the `is_pubnub_connected` attribute of the Surfboard
    active instance to `False` and prints a message.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on_disconnect_pubnub`：如果连接到PubNub MQTT服务器的客户端失去连接，将执行此回调函数。 该代码将Surfboard活动实例的`is_pubnub_connected`属性值设置为`False`，并打印一条消息。'
- en: Working with multiple MQTT servers
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多个MQTT服务器
- en: 'Add the following lines to the existing `surfboard_monitor.py` in the main
    virtual environment folder. The following lines declare the main block. The code
    file for the sample is included in the `mqtt_python_gaston_hillar_06_01` folder,
    in the `surfboard_monitor.py` file:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在主虚拟环境文件夹中的现有`surfboard_monitor.py`中添加以下行。 以下行声明了主要块。 示例的代码文件包含在`mqtt_python_gaston_hillar_06_01`文件夹中的`surfboard_monitor.py`文件中：
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'First, the main block creates an instance of the `Surfboard` class and saves
    it in the `surfboard` local variable. Then, the code generates the client ID string
    that is required to establish a connection with the PubNub MQTT interface and
    saves it in the `pubnub_client_id` local variable. The PubNub MQTT interface requires
    us to use a client ID composed as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，主要块创建了`Surfboard`类的实例，并将其保存在`surfboard`本地变量中。 然后，代码生成了与PubNub MQTT接口建立连接所需的客户端ID字符串，并将其保存在`pubnub_client_id`本地变量中。
    PubNub MQTT接口要求我们使用以下组成的客户端ID：
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The code uses the values of the `pubnub_publish_key`, `pubnub_subscribe_key`,
    and `device_id` variables to build a client ID as required by the PubNub MQTT
    interface. Then, the code creates an instance of the `mqtt.Client` class (`paho.mqtt.client.Client`)
    named `pubnub_client`, which represents the PubNub MQTT interface client. We use
    this instance to communicate with the PubNub MQTT server.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用`pubnub_publish_key`，`pubnub_subscribe_key`和`device_id`变量的值构建了一个符合PubNub
    MQTT接口要求的客户端ID。 然后，代码创建了一个名为`pubnub_client`的`mqtt.Client`类（`paho.mqtt.client.Client`）的实例，该实例表示PubNub
    MQTT接口客户端。 我们使用此实例与PubNub MQTT服务器进行通信。
- en: 'Then, the code assigns functions to attributes. The following table summarizes
    these assignments:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码将函数分配给属性。 以下表总结了这些分配：
- en: '| **Attribute** | **Assigned function** |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **分配的函数** |'
- en: '| `pubnub_client.on_connect` | `on_connect_pubnub` |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `pubnub_client.on_connect` | `on_connect_pubnub` |'
- en: '| `pubnub_client.on_disconnect` | `on_disconnect_pubnub` |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `pubnub_client.on_disconnect` | `on_disconnect_pubnub` |'
- en: Then, the code calls the `pubnub_client.connect` method and specifies the values
    for the `host`, `port`, and `keepalive` arguments. This way, the code asks the
    MQTT client to establish a connection to the specified PubNub MQTT server. After
    calling the `pubnub_client.connect` method, the code calls the `pubnub_client.loop_start`
    method. This method starts a new thread that processes the MQTT network traffic
    related to the PubNub MQTT interface and frees up the main thread.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码调用`pubnub_client.connect`方法，并指定`host`，`port`和`keepalive`参数的值。 这样，代码要求MQTT客户端与指定的PubNub
    MQTT服务器建立连接。 调用`pubnub_client.connect`方法后，代码调用`pubnub_client.loop_start`方法。 此方法启动一个处理与PubNub
    MQTT接口相关的MQTT网络流量的新线程，并释放主线程。
- en: Then, the main block creates another instance of the `mqtt.Client` class (`paho.mqtt.client.Client`)
    named `mosquitto_client`, which represents the Mosquitto MQTT server client. We
    use this instance to communicate with the local Mosquitto MQTT server.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，主要块创建了`mqtt.Client`类（`paho.mqtt.client.Client`）的另一个实例`mosquitto_client`，代表Mosquitto
    MQTT服务器客户端。我们使用此实例与本地Mosquitto MQTT服务器进行通信。
- en: 'Then, the code assigns functions to attributes. The following table summarizes
    these assignments:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码将函数分配给属性。以下表总结了这些分配：
- en: '| **Attribute** | **Assigned function** |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **分配的函数** |'
- en: '| `mosquitto_client.on_connect` | `on_connect_mosquitto` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `mosquitto_client.on_connect` | `on_connect_mosquitto` |'
- en: '| `mosquitto_client.on_subscribe` | `on_subscribe_mosquitto` |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `mosquitto_client.on_subscribe` | `on_subscribe_mosquitto` |'
- en: 'Notice that in this case, the code doesn''t assign a function to `mosquitto_client.on_message`.
    The next lines call the `mosquitto_client.message_callback_add` method to specify
    the callback function that the client has to call when it receives a message in
    a specific topic. The following table summarizes the function that will be called
    based on the variable that defines the topic in which the message arrives:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这种情况下，代码没有将函数分配给`mosquitto_client.on_message`。接下来的行调用`mosquitto_client.message_callback_add`方法，以指定客户端在特定主题接收到消息时必须调用的回调函数。以下表总结了根据定义消息到达的主题的变量调用的函数：
- en: '| **Topic variable** | **Assigned function** |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| **主题变量** | **分配的函数** |'
- en: '| `status_topic` | `on_status_message_mosquitto` |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `status_topic` | `on_status_message_mosquitto` |'
- en: '| `speed_mph_topic` | `on_speed_mph_message_mosquitto` |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `speed_mph_topic` | `on_speed_mph_message_mosquitto` |'
- en: '| `altitude_feet_topic` | `on_altitude_feet_message_mosquitto` |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `altitude_feet_topic` | `on_altitude_feet_message_mosquitto` |'
- en: '| `water_temperature_f_topic` | `on_water_temperature_f_message_mosquitto`
    |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `water_temperature_f_topic` | `on_water_temperature_f_message_mosquitto`
    |'
- en: Whenever the client receives a message from any of the sensors, it will update
    the appropriate attribute for the `Surfboard` active instance. These assigned
    functions are responsible for updating the status of the `Surfboard` active instance.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 每当客户端从任何传感器接收到消息时，它将更新`Surfboard`活动实例的适当属性。这些分配的函数负责更新`Surfboard`活动实例的状态。
- en: Then, the code calls the well-known `mosquitto_client.tls_set` and `mosquitto_client.connect`
    methods. This way, the code asks the MQTT client to establish a connection to
    the specified Mosquitto MQTT server. After calling the `mosquitto_client.connect`
    method, the code calls the `mosquitto_client.loop_start` method. This method starts
    a new thread that processes the MQTT network traffic related to the Mosquitto
    MQTT server and frees up the main thread.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码调用了众所周知的`mosquitto_client.tls_set`和`mosquitto_client.connect`方法。这样，代码要求MQTT客户端与指定的Mosquitto
    MQTT服务器建立连接。调用`mosquitto_client.connect`方法后，代码调用`mosquitto_client.loop_start`方法。此方法启动一个处理与Mosquitto
    MQTT服务器相关的MQTT网络流量的新线程，并释放主线程。
- en: 'Notice that we made two calls to `loop_start`, and therefore we will have two
    threads processing MQTT network traffic: one for the PubNub MQTT server and the
    other for the Mosquitto MQTT server.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们对`loop_start`进行了两次调用，因此我们将有两个线程处理MQTT网络流量：一个用于PubNub MQTT服务器，另一个用于Mosquitto
    MQTT服务器。
- en: The next lines declare a `while` loop that runs forever until a `KeyboardInterrupt`
    exception occurs. The loop checks the value of the `Surfboard.active_instance.is_pubnub_connected`
    attribute to make sure that the connection to the PubNub MQTT server isn't broken.
    If the connection is alive, the code calls the `Surfboard.active_instance.build_json_message`
    method to build the JSON string based on the current values of the `Surfboard`
    attributes, which are being updated whenever a message with new values arrives
    from the sensors.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的行声明了一个`while`循环，该循环将一直运行，直到发生`KeyboardInterrupt`异常。循环检查`Surfboard.active_instance.is_pubnub_connected`属性的值，以确保与PubNub
    MQTT服务器的连接没有中断。如果连接是活动的，代码将调用`Surfboard.active_instance.build_json_message`方法，根据`Surfboard`属性的当前值构建JSON字符串，这些值在传感器传来具有新值的消息时被更新。
- en: The code saves the JSON string in the `payload` local variable and calls the
    `pubnub_client.publish` method to publish the `payload` JSON formatted string
    to the topic name saved in the `pubnub_topic` variable with a QoS level of 0\.
    This way, the message will be published by the thread responsible for processing
    the MQTT network events for the PubNub MQTT client, and the web-based dashboard
    that uses the PubNub MQTT server as a data source will be updated. The next line
    prints a message with the payload that is being published to the PubNub MQTT server.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将JSON字符串保存在`payload`本地变量中，并调用`pubnub_client.publish`方法将`payload` JSON格式的字符串发布到`pubnub_topic`变量中保存的主题名称，QoS级别为0。这样，负责处理PubNub
    MQTT客户端的MQTT网络事件的线程将发布消息，并使用PubNub MQTT服务器作为数据源的基于Web的仪表板将被更新。下一行打印了正在发布到PubNub
    MQTT服务器的负载的消息。
- en: Running multiple clients
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行多个客户端
- en: Now, we will run the surfboard sensor emulator and the surfboard monitor we
    recently coded. Make sure you run these Python programs after you have followed
    the necessary steps to activate the virtual environment in which we have been
    working.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将运行最近编写的冲浪板传感器模拟器和冲浪板监视器。确保在运行这些Python程序之前，您已经按照必要的步骤激活了我们一直在其中工作的虚拟环境。
- en: 'Execute the following line to start the surfboard sensor emulator example on
    any computer or device that you want to use as the MQTT client that works as the
    surfboard sensor emulator and uses Linux or macOS:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何您想要用作冲浪板传感器模拟器并使用Linux或macOS的MQTT客户端的计算机或设备上执行以下行以启动冲浪板传感器模拟器示例：
- en: '[PRE10]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In Windows, you must execute the following line:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，您必须执行以下行：
- en: '[PRE11]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After a few seconds, you will see the output shown in the next lines:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，您将看到下面显示的输出：
- en: '[PRE12]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The program will continue publishing messages for the topics to the Mosquitto
    MQTT server. Keep the code running on your local computer or on the IoT board
    you have chosen to use as the surfboard sensor emulator for this example.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将继续为主题发布消息到Mosquitto MQTT服务器。保持代码在您的本地计算机上运行，或者在您选择用作本示例冲浪板传感器模拟器的物联网板上运行。
- en: 'Then, execute the following line to start the surfboard monitor example on
    any computer or device that you want to use as the MQTT client that receives messages
    from the Mosquitto MQTT server and publishes messages to the PubNub MQTT server
    and uses Linux or macOS:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在任何您想要用作MQTT客户端的计算机或设备上执行以下命令，该客户端接收来自Mosquitto MQTT服务器的消息并发布消息到PubNub MQTT服务器，并使用Linux或macOS：
- en: '[PRE13]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In Windows, you must execute the following line:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，您必须执行以下命令：
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After a few seconds, you will see an output with messages similar to the next
    lines. Notice that the values will be different because the time at which you
    start running the program will make the values vary:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，您将看到类似下面几行的消息输出。请注意，值将不同，因为您开始运行程序的时间将使值变化：
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The program will continue receiving messages form the surfboard sensor emulator
    and publishing messages to the PubNub MQTT server. Keep the code running on your
    local computer or on the IoT board you have chosen to use as the surfboard monitor
    for this example.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将继续接收来自冲浪板传感器模拟器的消息，并将消息发布到PubNub MQTT服务器。保持代码在您的本地计算机上运行，或者在您选择用作本示例冲浪板监视器的物联网板上运行。
- en: 'The following screenshot shows two Terminal windows running on a computer with
    macOS. The Terminal on the left-hand side is displaying the messages shown by
    the Python client that works as the surfboard sensor emulator, that is, the `surfboard_sensors_emulator.py`
    script. The Terminal on the right-hand side displays the results of running the
    code for the Python client that works as the surfboard monitor, that is, the `surfboard_monitor.py`
    script:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图显示了在macOS计算机上运行的两个终端窗口。左侧的终端显示了作为冲浪板传感器模拟器的Python客户端显示的消息，即`surfboard_sensors_emulator.py`脚本。右侧的终端显示了作为冲浪板监视器的Python客户端运行代码的结果，即`surfboard_monitor.py`脚本：
- en: '![](assets/611ee552-ee5c-42ed-8915-edf10b548519.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/611ee552-ee5c-42ed-8915-edf10b548519.png)'
- en: Building a web-based dashboard with freeboard
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用freeboard构建基于网络的仪表板
- en: Now, we are ready to use the PubNub MQTT server as a data source to build a
    real-time web-based dashboard. As previously explained, we will take advantage
    of freeboard.io to visualize the surfer and surfboard data in many gauges.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备使用PubNub MQTT服务器作为数据源来构建实时的基于网络的仪表板。如前所述，我们将利用freeboard.io来在许多表盘中可视化冲浪者和冲浪板的数据。
- en: The freeboard.io requires us to sign up and create an account with a valid email
    and a password before we can build a web-based dashboard. We aren't required to
    enter any credit card or payment information. If you already have an account at
    freeboard.io, you can skip the next step.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: freeboard.io要求我们注册并创建一个带有有效电子邮件和密码的账户，然后我们才能构建基于网络的仪表板。我们不需要输入任何信用卡或付款信息。如果您已经在freeboard.io上有账户，可以跳过下一步。
- en: Go to [http://freeboard.io](http://freeboard.io) in your web browser and click
    Start Now. You can also go straight to [https://freeboard.io/signup](https://freeboard.io/signup).
    Enter your desired user name in Pick a Username, your email in Enter Your Email,
    and the desired password in Create a Password. Once you have filled in all the
    fields, click Create My Account.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中转到[http://freeboard.io](http://freeboard.io)，然后点击立即开始。您也可以直接转到[https://freeboard.io/signup](https://freeboard.io/signup)。在选择用户名中输入您想要的用户名，在输入您的电子邮件中输入您的电子邮件，在创建密码中输入所需的密码。填写完所有字段后，点击创建我的账户。
- en: Once you have created your account, you can go to [http://freeboard.io](http://freeboard.io)
    in your web browser and click Login. You can achieve the same goal by visiting
    [https://freeboard.io/login](https://freeboard.io/login). Then, enter your user
    name or email and password, and click Sign In. freeboard will display your freeboards,
    also known as dashboards.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完账户后，您可以在您的网络浏览器中转到[http://freeboard.io](http://freeboard.io)，然后点击登录。您也可以通过访问[https://freeboard.io/login](https://freeboard.io/login)来实现相同的目标。然后，输入您的用户名或电子邮件和密码，然后点击登录。freeboard将显示您的freeboard，也称为仪表板。
- en: 'Enter `Surfboard01` in the enter a name textbox on the left-hand side of the
    Create New button and then click on this button. freeboard.io will display an
    empty dashboard with many buttons that allow us to add panes and data sources,
    among other things. The following screenshot shows the empty dashboard:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新按钮的左侧的输入名称文本框中输入`Surfboard01`，然后单击此按钮。freeboard.io将显示一个空的仪表板，其中有许多按钮，可以让我们添加窗格和数据源等。下面的屏幕截图显示了空的仪表板：
- en: '![](assets/d7089651-6c62-4937-830d-7ecb05c946ba.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d7089651-6c62-4937-830d-7ecb05c946ba.png)'
- en: Click on Add below Datasources and the website will open the Datasource dialog
    box. Select PubNub in the Type dropdown and the dialog box will display the fields
    required to define a PubNub datasource.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 点击数据源下方的添加，网站将打开数据源对话框。在类型下拉菜单中选择PubNub，对话框将显示定义PubNub数据源所需的字段。
- en: Notice that it is also possible to use MQTT as a datasource for freeboard.io.
    However, this would require us to make our Mosquitto MQTT server publicly available.
    Instead, we take advantage of the PubNub MQTT interface which allows us to make
    the messages easily available on the PubNub network. However, you can definitely
    work with an MQTT server as a datasource in your projects that require a dashboard
    where freeboard.io provides you the with required features.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，也可以使用MQTT作为freeboard.io的数据源。但是，这将要求我们将我们的Mosquitto MQTT服务器公开可用。相反，我们利用PubNub
    MQTT接口，它允许我们轻松地在PubNub网络上提供消息。但是，在需要freeboard.io提供所需功能的项目中，您绝对可以使用MQTT服务器作为数据源来工作。
- en: Enter `surfboard01` in Name.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在名称中输入`surfboard01`。
- en: Enter the subscribe key you have copied from the PubNub settings. Remember that
    the subscribe key is the one that usually starts with the `sub-c` prefix.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 输入你从PubNub设置中复制的订阅密钥。请记住，订阅密钥通常以`sub-c`前缀开头。
- en: Enter `surfboard01` in Channel.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在频道中输入`surfboard01`。
- en: 'If any of the previous value names is wrong, the datasource won''t have the
    appropriate data. The following screenshot shows the configuration for the PubNub
    datasource with the subscribe displaying only the `sub-c` prefix:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果之前的任何数值名称错误，数据源将无法获得适当的数据。下面的截图显示了PubNub数据源的配置，订阅仅显示`sub-c`前缀：
- en: '![](assets/57fab197-993c-4ad3-b989-ef126e8dd77e.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/57fab197-993c-4ad3-b989-ef126e8dd77e.png)'
- en: Click Save and the datasource will appear listed below Datasources. As the surfboard
    sensor emulator and the surfboard monitor are running, the time shown below Last
    Updated will change every second. If the time doesn't change every second, it
    means that the datasource has the wrong configuration or that any of the Python
    programs is not running as expected.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 点击保存，数据源将显示在数据源下方。由于冲浪板传感器模拟器和冲浪板监视器正在运行，所以下方的“最后更新”时间将每秒变化一次。如果时间没有每秒变化，这意味着数据源配置错误，或者Python程序中的任何一个未按预期运行。
- en: Click on Add pane to add a new empty pane to the dashboard. Then, click on the
    plus sign (+) at the upper right corner of the new empty pane and freeboard will
    display the Widget dialog box.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“添加窗格”以在仪表板上添加一个新的空窗格。然后，点击新空窗格右上角的加号（+），freeboard将显示小部件对话框。
- en: Select Text in the Type dropdown and the dialog box will display the fields
    required to add a text widget to the pane within the dashboard. Enter `Status`
    in Title.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型下拉菜单中选择文本，并且对话框将显示添加文本小部件到仪表板窗格所需的字段。在标题中输入`Status`。
- en: 'Click + Datasource on the right-hand side of the Value textbox, select surfboard01,
    and then select Status. After you make the selections, the following text will
    appear in the Value textbox, `datasources ["surfboard01"] ["Status"]`, as shown
    in the next screenshot:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在值文本框的右侧点击+数据源，选择surfboard01，然后选择状态。做出选择后，值文本框中将出现以下文本：`datasources ["surfboard01"]
    ["Status"]`，如下一截图所示：
- en: '![](assets/4d75a58e-0dbd-4025-ae1d-eba3a29f2c02.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4d75a58e-0dbd-4025-ae1d-eba3a29f2c02.png)'
- en: 'Then, click Save and freeboard will close the dialog box and add the new gauge
    to the previously created pane within the dashboard. The gauge will display the
    latest value that the surfboard monitor published to the PubNub MQTT interface
    for the status, that is, the value for the `Status` key in the JSON data that
    the code has published for the last time. The following screenshot shows the surfboard01
    datasource displaying the last updated time and the gauge showing the latest value
    for the status:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，点击保存，freeboard将关闭对话框，并将新的仪表添加到仪表板中之前创建的窗格中。表盘将显示冲浪板监视器最后一次发布到PubNub MQTT接口的状态的最新数值，即代码上次发布的JSON数据中`Status`键的数值。下面的截图显示了surfboard01数据源显示的最后更新时间，以及仪表显示了状态的最新数值。
- en: '![](assets/f0a8e9fe-1230-4721-b40d-ef49df3aa008.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f0a8e9fe-1230-4721-b40d-ef49df3aa008.png)'
- en: Click on Add pane to add another new empty pane to the dashboard. Then, click
    on the plus sign (+) at the upper-right corner of the new empty pane and freeboard
    will display the Widget dialog box.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“添加窗格”以在仪表板上添加另一个新的空窗格。然后，点击新空窗格右上角的加号（+），freeboard将显示小部件对话框。
- en: Select Gauge in the Type dropdown and the dialog box will display the fields
    required to add a gauge widget to the pane within the dashboard. Enter `Speed`
    in Title.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型下拉菜单中选择仪表，并且对话框将显示添加仪表小部件到仪表板窗格所需的字段。在标题中输入`Speed`。
- en: 'Click + Datasource at the right-hand side of the Value textbox, select surfboard01,
    and then select Speed MPH. After you make the selections, the following text will
    appear in the Value textbox: `datasources ["surfboard01"] ["Speed MPH"]`.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在值文本框的右侧点击+数据源，选择surfboard01，然后选择速度MPH。做出选择后，值文本框中将出现以下文本：`datasources ["surfboard01"]
    ["Speed MPH"]`。
- en: Enter `MPH` in Units, `0` in Minimum, and `40` in Maximum. Then, click Save
    and freeboard will close the dialog box and add the new gauge to the previously
    created pane on the dashboard. The gauge will display the latest value that the
    surfboard monitor published to the PubNub MQTT interface for the speed, that is,
    the value for the `Speed MPH` key in the JSON data that the code has published
    for the last time.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在单位中输入`MPH`，最小值为`0`，最大值为`40`。然后，点击保存，freeboard将关闭对话框，并将新的表盘添加到仪表板上之前创建的窗格中。表盘将显示冲浪板监视器最后一次发布到PubNub
    MQTT接口的速度的最新数值，即代码上次发布的JSON数据中`Speed MPH`键的数值。
- en: The following screenshot shows the surfboard01 datasource displaying the last
    updated time and the added gauge showing the latest value for the speed in mph.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了surfboard01数据源显示的最后更新时间，以及添加的仪表显示了mph速度的最新数值。
- en: '![](assets/cacc5fe5-54e2-4cb2-8277-5692d568dd92.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cacc5fe5-54e2-4cb2-8277-5692d568dd92.png)'
- en: Click on Add pane to add another new empty pane to the dashboard. Then, click
    on the plus sign (+) at the upper-right corner of the new empty pane and freeboard
    will display the Widget dialog box.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“添加窗格”以在仪表板上添加另一个新的空窗格。然后，点击新空窗格右上角的加号（+），freeboard将显示小部件对话框。
- en: Select Gauge in the Type dropdown and the dialog box will display the fields
    required to add a gauge widget to the pane on the dashboard. Enter `Altitude`
    in Title.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型下拉菜单中选择仪表，并且对话框将显示添加仪表小部件到仪表板窗格所需的字段。在标题中输入`Altitude`。
- en: 'Click + Datasource at the right-hand side of the Value textbox, select surfboard01,
    and then select Altitude Feet. After you make the selections, the following text
    will appear in the Value textbox: `datasources ["surfboard01"] ["Altitude Feet"]`.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在值文本框的右侧点击+数据源，选择surfboard01，然后选择海拔英尺。做出选择后，值文本框中将出现以下文本：`datasources ["surfboard01"]
    ["Altitude Feet"]`。
- en: Enter `Feet` in Units, `0` in Minimum, and `30` in Maximum. Then, click Save
    and freeboard will close the dialog box and add the new gauge to the previously
    created pane on the dashboard. The gauge will display the latest value that the
    surfboard monitor published to the PubNub MQTT interface for the altitude, that
    is, the value for the `Altitude Feet` key in the JSON data that the code has published
    for the last time.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在单位中输入“英尺”，在最小值中输入“0”，在最大值中输入“30”。然后，单击“保存”，freeboard将关闭对话框，并将新的仪表添加到仪表板上以前创建的窗格中。仪表将显示冲浪板监视器最后一次发布到PubNub
    MQTT接口的海拔值，即代码为“Altitude Feet”键发布的JSON数据的最新值。
- en: Now, we will add the last pane. Click on Add pane to add another new empty pane
    to the dashboard. Then, click on the plus sign (+) at the upper-right corner of
    the new empty pane and freeboard will display the Widget dialog box.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加最后一个窗格。单击“添加窗格”以在仪表板上添加另一个新的空窗格。然后，单击新空窗格右上角的加号（+），freeboard将显示小部件对话框。
- en: Select Gauge in the Type dropdown and the dialog box will display the fields
    required to add a gauge widget to the pane on the dashboard. Enter `Water temperature`
    in Title.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型下拉菜单中选择仪表，对话框将显示添加仪表小部件到仪表板上的窗格所需的字段。在标题中输入“水温”。
- en: 'Click + Datasource at the right-hand side of the Value textbox, select surfboard01,
    and then select Water Temperature F. After you make the selections, the following
    text will appear in the Value textbox: `datasources ["surfboard01"] ["Water Temperature
    F"]`.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在值文本框的右侧点击+数据源，选择surfboard01，然后选择Water Temperature F。在进行选择后，值文本框中将显示以下文本：“datasources
    ["surfboard01"] ["Water Temperature F"]”。
- en: Enter `ºF` in Units, `0` in Minimum, and `80` in Maximum. Then, click Save and
    freeboard will close the dialog box and add the new gauge to the previously created
    pane on the dashboard. The gauge will display the latest value that the surfboard
    monitor published to the PubNub MQTT interface for the water temperature, that
    is, the value for the `Water Temperature F` key in the JSON data that the code
    has published for the last time.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在单位中输入“ºF”，在最小值中输入“0”，在最大值中输入“80”。然后，单击“保存”，freeboard将关闭对话框，并将新的仪表添加到仪表板上以前创建的窗格中。仪表将显示冲浪板监视器最后一次发布到PubNub
    MQTT接口的水温，即代码为“Water Temperature F”键发布的JSON数据的最新值。
- en: Drag and drop the panes to locate the panes with the layout shown in the next
    screenshot. The screenshot shows the dashboard we built with four panes and three
    gauges that refresh the data automatically every second when our surfboard monitor
    publishes data to the PubNub MQTT interface.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 拖放窗格以找到布局中显示的窗格。屏幕截图显示了我们使用四个窗格和三个仪表构建的仪表板，当我们的冲浪板监视器向PubNub MQTT接口发布数据时，这些仪表会每秒自动刷新数据。
- en: '![](assets/226d41e2-1a7c-46d7-a9c7-ae613fca5ce5.png)We can access the recently
    built dashboard on any device by entering the URL that our web browser displays
    at the time we are working with the dashboard. The URL is composed of the `https://freeboard.io/board/`
    prefix followed by letters and numbers. For example, if the URL is `https://freeboard.io/board/EXAMPLE`,
    we just need to enter it in any web browser running on any device or computer
    connected to the internet, and we can watch the gauges and they will be refreshed
    as new data is being published from our surfboard monitor.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过输入Web浏览器在我们使用仪表板时显示的URL来访问最近构建的仪表板。该URL由`https://freeboard.io/board/`前缀后跟字母和数字组成。例如，如果URL是`https://freeboard.io/board/EXAMPLE`，我们只需在任何连接到互联网的设备或计算机上的任何Web浏览器中输入它，我们就可以观看仪表，并且当新数据从我们的冲浪板监视器发布时，它们将被刷新。
- en: The combination of the PubNub as our datasource and freeboard.io as our web-based
    dashboard made it easy for us to monitor the data retrieved from the sensors in
    the surfer's wetsuit and his surfboard. We can monitor the data on any device
    that provides a web browser. The combination of these two cloud-based services
    for IoT is just one example of how we can easily combine different services with
    MQTT in our solutions.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 将PubNub作为我们的数据源，将freeboard.io作为我们的基于Web的仪表板，使我们能够轻松监视从冲浪者潜水服和冲浪板传感器检索的数据。我们可以在任何提供Web浏览器的设备上监视数据。这两个基于云的IoT服务的组合只是我们如何可以轻松地将不同的服务与MQTT结合在我们的解决方案中的一个例子。
- en: Test your knowledge
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: 'Let''s see whether you can answer the following questions correctly:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否能正确回答以下问题：
- en: 'The PubNub MQTT interface requires us to use a client ID composed as follows:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PubNub MQTT接口要求我们使用以下格式组成的客户端ID：
- en: '`publish_key/subscribe_key/device_id`'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “publish_key/subscribe_key/device_id”
- en: '`device_id/publish_key/subscribe_key`'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “device_id/publish_key/subscribe_key”
- en: '`publish_key/device_id`'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “publish_key/device_id”
- en: 'When we publish a message to the PubNub MQTT interface:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们向PubNub MQTT接口发布消息时：
- en: It is only available on the PubNub MQTT subnetwork
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它仅在PubNub MQTT子网络上可用
- en: It becomes available on the PubNub network
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它在PubNub网络上可用
- en: It requires a specific payload prefix to become available on the PubNub network
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要特定的有效负载前缀才能在PubNub网络上使用
- en: 'Which of the following methods of the `paho.mqtt.client.Client` instance allows
    us to specify the callback function that the client has to call when it receives
    a message in a specific topic:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下`paho.mqtt.client.Client`实例的哪种方法允许我们指定客户端在特定主题接收消息时必须调用的回调函数：
- en: '`message_callback_add`'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “message_callback_add”
- en: '`message_arrived_to_topic_callback`'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “message_arrived_to_topic_callback”
- en: '`message_on_topic`'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “message_on_topic”
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we combined everything we learned in the previous chapters
    to build a web-based dashboard with freeboard that displayed data in gauges every
    second. We built the solution from scratch. First, we analyzed the requirements
    and we understood how the IoT board embedded in a surfboard was going to provide
    us with the necessary data.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将前几章学到的知识结合起来，使用freeboard构建了一个基于Web的仪表板，每秒显示仪表中的数据。我们从头开始构建了解决方案。首先，我们分析了要求，了解了嵌入在冲浪板中的IoT板将如何为我们提供必要的数据。
- en: We coded a surfboard sensor emulator to work in the same way that the IoT board
    was working. Then, we configured the PubNub MQTT interface and we coded a surfboard
    monitor that collected data from the surfboard sensor emulator and published the
    data to the cloud-based PubNub MQTT interface. We coded a Python program that
    worked with two MQTT clients with two threaded loop interfaces.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了一个冲浪板传感器模拟器，以与物联网板相同的方式工作。然后，我们配置了PubNub MQTT接口，并编写了一个冲浪板监视器，收集来自冲浪板传感器模拟器的数据，并将数据发布到基于云的PubNub
    MQTT接口。我们编写了一个Python程序，与两个MQTT客户端一起使用两个线程循环接口。
- en: Finally, we could take advantage of the fact that the messages published to
    the PubNub MQTT interface are also available on the PubNub network to easily build
    a web-based dashboard with freeboard.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以利用这样一个事实：发布到PubNub MQTT接口的消息也可以在PubNub网络上轻松构建一个基于web的仪表板，使用freeboard。
- en: 'We were able to create code that was capable of running on the most popular
    and powerful IoT boards. We are ready to use MQTT in all kinds of projects, in
    one of the most popular and versatile programming languages: Python 3.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够创建能够在最流行和强大的物联网板上运行的代码。我们准备在各种项目中使用MQTT，使用最流行和多功能的编程语言之一：Python 3。
