- en: Chapter 8. Managing Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。管理代码
- en: Working on a software project that involves more than one person is tough. Everything
    slows down and gets harder. This happens for several reasons. This chapter will
    expose these reasons and will try to provide some ways to fight against them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在涉及多人的软件项目上工作是困难的。一切都变慢并变得更加困难。这是由于几个原因。本章将揭示这些原因，并尝试提供一些对抗它们的方法。
- en: 'This chapter is divided into two parts, which explain:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为两部分，分别解释：
- en: How to work with a version control system
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用版本控制系统
- en: How to set up continuous development processes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何建立持续开发流程
- en: First of all, a code base evolves so much that it is important to track all
    the changes that are made, even more so when many developers work on it. That
    is the role of a **version control system**.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码库的演变非常重要，需要跟踪所有的更改，尤其是当许多开发人员在其上工作时。这就是**版本控制系统**的作用。
- en: Next, several brains that are not directly wired together can still work on
    the same project. They have different roles and work on different aspects. Therefore,
    a lack of global visibility generates a lot of confusion about what is going on
    and what is being done by others. This is unavoidable, and some tools have to
    be used to provide continuous visibility and mitigate the problem. This is done
    by setting up a series of tools for continuous development processes such as **continuous
    integration** or **continuous delivery**.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，即使没有直接连接在一起的几个大脑仍然可以在同一个项目上工作。他们有不同的角色并且在不同的方面工作。因此，缺乏全局可见性会导致对其他人正在进行的工作和正在做的事情产生很多困惑。这是不可避免的，必须使用一些工具来提供持续的可见性并减轻问题。这是通过建立一系列持续开发流程的工具来实现的，如**持续集成**或**持续交付**。
- en: Now we will discuss these two aspects in detail.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将详细讨论这两个方面。
- en: Version control systems
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本控制系统
- en: '**Version control systems** (**VCS**) provide a way to share, synchronize,
    and back up any kind of file. They are categorized into two families:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**版本控制系统**（**VCS**）提供了一种分享、同步和备份任何类型文件的方法。它们分为两个家族：'
- en: Centralized systems
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集中式系统
- en: Distributed systems
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式系统
- en: Centralized systems
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集中式系统
- en: A centralized version control system is based on a single server that holds
    the files and lets people check in and check out the changes that are made to
    those files. The principle is quite simple—everyone can get a copy of the files
    on his/her system and work on them. From there, every user can *commit* his/her
    changes to the server. They will be applied and the *revision* number will be
    raised. The other users will then be able to get those changes by synchronizing
    their *repository* copy through an *update*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 集中式版本控制系统基于一个保存文件并允许人们检入和检出对这些文件所做更改的单个服务器。原则非常简单——每个人都可以在自己的系统上获取文件的副本并对其进行操作。从那里，每个用户都可以将他/她的更改提交到服务器。它们将被应用并且*修订*号将被提升。然后其他用户将能够通过*更新*来同步他们的*仓库*副本以获取这些更改。
- en: 'The repository evolves through all the commits, and the system archives all
    revisions into a database to undo any change or provide information on what has
    been done:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库通过所有的提交而发展，系统将所有修订版本存档到数据库中，以撤消任何更改或提供有关已完成的工作的信息：
- en: '![Centralized systems](graphics/5295_08_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![集中式系统](graphics/5295_08_01.jpg)'
- en: Figure 1
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图1
- en: 'Every user in this centralized configuration is responsible for synchronizing
    his/her local repository with the main one in order to get the other user''s changes.
    This means that some conflicts can occur when a locally modified file has been
    changed and checked in by someone else. A conflict resolution mechanism is carried
    out, in this case on the user system, as shown in the following figure:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种集中式配置中，每个用户都负责将他/她的本地仓库与主要仓库同步，以获取其他用户的更改。这意味着当本地修改的文件已被其他人更改并检入时，可能会发生一些冲突。在这种情况下，冲突解决机制是在用户系统上进行的，如下图所示：
- en: '![Centralized systems](graphics/5295_08_02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![集中式系统](graphics/5295_08_02.jpg)'
- en: Figure 2
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图2
- en: 'This will help you understand better:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这将帮助您更好地理解：
- en: Joe checks in a change.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Joe提交了一个更改。
- en: Pamela attempts to check in a change on the same file.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Pamela试图在同一个文件上进行更改检入。
- en: The server complains that her copy of the file is out of date.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器抱怨她的文件副本已经过时。
- en: Pamela updates her local copy. The version control software may or may not be
    able to merge the two versions seamlessly (that is, without a conflict).
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Pamela更新了她的本地副本。版本控制软件可能能够无缝地合并这两个版本（即，没有冲突）。
- en: Pamela commits a new version that contains the latest changes made by Joe and
    her own.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Pamela提交了一个包含Joe和她自己最新更改的新版本。
- en: 'This process is perfectly fine on small-sized projects that involve a few developers
    and a small number of files. But it becomes problematic for bigger projects. For
    instance, a complex change involves a lot of files, which is time consuming, and
    keeping everything local before the whole work is done is unfeasible. The problems
    of such approach are:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程在涉及少数开发人员和少量文件的小型项目中是完全可以的。但对于更大的项目来说就会有问题。例如，复杂的更改涉及大量文件，这是耗时的，并且在整个工作完成之前将所有内容保留在本地是不可行的。这种方法的问题包括：
- en: It is dangerous because the user may keep his/her computer changes that are
    not necessarily backed up
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是危险的，因为用户可能会保留他/她的计算机更改，而这些更改不一定被备份
- en: It is hard to share with others until it is checked in and sharing it before
    it is done would leave the repository in an unstable state, and so the other users
    would not want to share
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在检查之前很难与其他人分享，而在完成之前分享它会使仓库处于不稳定状态，因此其他用户不会想要分享
- en: Centralized VCS has resolved this problem by providing *branches* and *merges*.
    It is possible to fork from the main stream of revisions to work on a separated
    line and then to get back to the main stream.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 集中式版本控制系统通过提供*分支*和*合并*来解决了这个问题。可以从主要修订流中分叉出来，然后再回到主要流中。
- en: In *Figure 3*, Joe starts a new branch from revision 2 to work on a new feature.
    The revisions are incremented in the main stream and in his branch every time
    a change is checked in. At revision 7, Joe has finished his work and commits his
    changes into the trunk (the main branch). This requires, most of the time, some
    conflict resolution.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图3*中，乔从修订版2开始创建一个新的分支来开发一个新功能。每次检入更改时，主流和他的分支中的修订版都会增加。在第7个修订版，乔完成了他的工作，并将更改提交到主干（主分支）。这通常需要一些冲突解决。
- en: 'But in spite of their advantages, centralized VCS has several pitfalls:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，尽管它们有优势，集中式版本控制系统也有一些缺陷：
- en: Branching and merging is quite hard to deal with. It can become a nightmare.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分支和合并是非常难处理的。它可能变成一场噩梦。
- en: Since the system is centralized, it is impossible to commit changes offline.
    This can lead to a huge, single commit to the server when the user gets back online.
    Lastly, it doesn't work very well for projects such as Linux, where many companies
    permanently maintain their own branch of the software and there is no central
    repository that everyone has an account on.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于系统是集中式的，离线提交更改是不可能的。这可能导致用户在重新联机时向服务器进行大量的单一提交。最后，对于像Linux这样的项目来说，它并不适用得很好，许多公司永久地维护着软件的自己的分支，并且没有每个人都有账户的中央仓库。
- en: For the latter, some tools are making it possible to work offline, such as SVK,
    but a more fundamental problem is how the centralized VCS works.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于后者，一些工具使得离线工作成为可能，比如SVK，但更根本的问题是集中式版本控制系统的工作方式。
- en: '![Centralized systems](graphics/5295_08_03.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![集中式系统](graphics/5295_08_03.jpg)'
- en: Figure 3
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图3
- en: Despite these pitfalls, centralized VCS is still quite popular among many companies
    mainly due to inertia of corporate environments. The main examples of centralized
    VCSes used by many organizations are **Subversion** (**SVN**) and **Concurrent
    Version System** (**CVS**). The obvious issues with centralized architecture for
    version control systems is the reason why most of the open source communities
    have already switched to the more reliable architecture of **Distributed VCS**
    (**DVCS**).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在这些缺陷，集中式版本控制系统在许多公司中仍然非常受欢迎，主要是由于企业环境的惯性。许多组织使用的集中式版本控制系统的主要示例是**Subversion**（**SVN**）和**Concurrent
    Version System**（**CVS**）。集中式架构对版本控制系统的明显问题是为什么大多数开源社区已经转向更可靠的**分布式版本控制系统**（**DVCS**）的架构。
- en: Distributed systems
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分布式系统
- en: 'Distributed VCS is the answer to the centralized VCS deficiencies. It does
    not rely on a main server that people work with, but on peer-to-peer principles.
    Everyone can hold and manage his/her own independent repository for a project
    and synchronize it with other repositories:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式版本控制系统是对集中式版本控制系统缺陷的答案。它不依赖于人们使用的主服务器，而是依赖于点对点的原则。每个人都可以拥有和管理自己独立的项目仓库，并将其与其他仓库同步：
- en: '![Distributed systems](graphics/5295_08_04.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![分布式系统](graphics/5295_08_04.jpg)'
- en: Figure 4
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图4
- en: 'In *Figure 4*, we can see an example of such a system in use:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图4*中，我们可以看到这样一个系统的使用示例：
- en: Bill *pulls* the files from HAL's repository.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比尔从HAL的仓库*拉取*文件。
- en: Bill makes some changes on the files.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比尔对文件进行了一些更改。
- en: Amina *pulls* the files from Bill's repository.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阿米娜从比尔的仓库*拉取*文件。
- en: Amina changes the files too.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阿米娜也改变了文件。
- en: Amina *pushes* the changes to HAL.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阿米娜*推送*更改到HAL。
- en: Kenny *pulls* the files from HAL.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 肯尼从HAL*拉取*文件。
- en: Kenny makes changes.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 肯尼做出了改变。
- en: Kenny regularly *pushes* his changes to HAL.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 肯尼定期*推送*他的更改到HAL。
- en: The key concept is that people *push* and *pull* the files to or from other
    repositories, and this behavior changes according to the way people work and the
    way the project is managed. Since there is no main repository anymore, the maintainer
    of the project needs to define a strategy for people to *push* and *pull* the
    changes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 关键概念是人们*推送*和*拉取*文件到其他仓库，这种行为会根据人们的工作方式和项目管理方式而改变。由于不再有主要仓库，项目的维护者需要为人们*推送*和*拉取*更改定义一种策略。
- en: Furthermore, people have to be a bit smarter when they work with several repositories.
    In most distributed version control systems, revision numbers are local to each
    repository, and there are no global revision numbers anyone can refer to. Therefore,
    *tags* have to be used to make things clearer. They are textual labels that can
    be attached to a revision. Lastly, users are responsible for backing up their
    own repositories, which is not the case in a centralized infrastructure where
    the administrator usually sets back up strategies.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当人们使用多个仓库时，他们必须更加聪明。在大多数分布式版本控制系统中，修订号是针对每个仓库的，没有全局的修订号可以供任何人参考。因此，必须使用*标签*来使事情更清晰。它们是可以附加到修订版的文本标签。最后，用户需要负责备份他们自己的仓库，而在集中式基础设施中，通常是管理员设置备份策略。
- en: Distributed strategies
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分布式策略
- en: A central server is, of course, still desirable with a DVCS if you're working
    in a company setting with everyone working toward the same goal. But the purpose
    of that server is completely different than in centralized VCS. It is simply a
    hub that allows all developers to share their changes in a single place rather
    than pull and push between each other's repositories. Such a single central repository
    (often called *upstream*) serves also as a backup for all the changes tracked
    in the individual repositories of all team members.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在公司环境中，如果所有人都朝着同一个目标努力工作，使用分布式版本控制系统仍然需要一个中央服务器。但是，该服务器的目的与集中式版本控制系统中的完全不同。它只是一个中心，允许所有开发人员在一个地方共享他们的更改，而不是在彼此的仓库之间进行拉取和推送。这样一个单一的中央仓库（通常称为*上游*）也作为所有团队成员个人仓库中跟踪的所有更改的备份。
- en: Different approaches can be applied to sharing code with the central repository
    in DVCS. The simplest one is to set up a server that acts like a regular centralized
    server, where every member of the project can push his/her changes into a common
    stream. But this approach is a bit simplistic. It does not take full advantage
    of the distributed system, since people will use push and pull commands in the
    same way as they would with a centralized system.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 可以采用不同的方法与DVCS中央存储库共享代码。最简单的方法是设置一个像常规集中式服务器一样运行的服务器，项目的每个成员都可以将自己的更改推送到一个公共流中。但这种方法有点简单化。它没有充分利用分布式系统，因为人们将使用推送和拉取命令的方式与集中式系统相同。
- en: 'Another approach consists of providing several repositories on a server with
    different levels of access:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是在服务器上提供几个具有不同访问级别的存储库：
- en: An **unstable** **repository** is where everyone can push changes.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不稳定** **存储库**是每个人都可以推送更改的地方。'
- en: A **stable** **repository** is read-only for all members except the release
    managers. They are allowed to pull changes from the unstable repository and decide
    what should be merged.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**稳定** **存储库**对于除发布经理之外的所有成员都是只读的。他们被允许从不稳定的存储库中拉取更改并决定应该合并什么。'
- en: Various **release** **repositories** correspond to the releases and are read-only,
    as we will see later in the chapter.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种**发布** **存储库**对应于发布，并且是只读的，正如我们将在本章后面看到的那样。
- en: This allows people to contribute, and managers to review, the changes before
    they make it to the stable repository. Anyway, depending on the tools used, this
    may be too much of an overhead. In many distributed version control systems, this
    can also be handled with a proper branching strategy.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这使人们可以贡献，管理者可以审查更改，然后再将其提交到稳定的存储库。无论如何，根据所使用的工具，这可能是太多的开销。在许多分布式版本控制系统中，这也可以通过适当的分支策略来处理。
- en: The other strategies can be made up, since DVCS provides infinite combinations.
    For instance, the Linux Kernel, which is using Git ([http://git-scm.com/](http://git-scm.com/)),
    is based on a star model, where Linus Torvalds is maintaining the official repository
    and pulls the changes from a set of developers he trusts. In this model, people
    who wish to push changes to the kernel will, hopefully, try to push them to the
    trusted developers so that they reach Linus through them.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 其他策略可以根据DVCS提供的无限组合进行制定。例如，使用Git（[http://git-scm.com/](http://git-scm.com/)）的Linux内核基于星型模型，Linus
    Torvalds维护官方存储库，并从一组他信任的开发人员那里拉取更改。在这种模型中，希望向内核推送更改的人将尝试将它们推送给受信任的开发人员，以便通过他们达到Linus。
- en: Centralized or distributed?
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集中式还是分布式？
- en: Just forget about the centralized version control systems.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 忘记集中式版本控制系统。
- en: Let's be honest. Centralized version control systems are relict of the past.
    In a time when most of us have the opportunity to work remotely full-time, it
    is unreasonable to be constrained by all the deficiencies of centralized VCS.
    For instance, with CVS or SVN you can't track the changes when offline. And that's
    silly. What should you do when the Internet connection at your workplace is temporarily
    broken or the central repository goes down? Should you forget about all your workflow
    and just allow changes to pile up until the situation changes and then just commit
    it as a one huge blob of unstructured updates? No!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们诚实一点。集中式版本控制系统是过去的遗物。在大多数人都有全职远程工作的机会时，受到集中式VCS所有缺陷的限制是不合理的。例如，使用CVS或SVN时，您无法在离线时跟踪更改。这太愚蠢了。当您的工作场所的互联网连接暂时中断或中央存储库崩溃时，您该怎么办？您应该忘记所有的工作流程，只允许更改堆积直到情况改变，然后将其作为一个巨大的非结构化更新提交吗？不！
- en: Also, most of the centralized version control systems do not handle branching
    schemes efficiently. And branching is a very useful technique that allows you
    to limit the number of merge conflicts in the projects where many people work
    on multiple features. Branching in SVN is so ridiculous that most of the developers
    try to avoid it at all costs. Instead, most of the centralized VCS provides some
    file-locking primitives that should be considered the anti-pattern for any version
    control system. The sad truth about every version control tool is that if it contains
    a dangerous option, someone in your team will start using it on a daily basis
    eventually. And locking is one such feature that in return of fewer merge conflicts
    will drastically reduce the productivity of your whole team. By choosing a version
    control system that does not allow for such bad workflows, you are making a situation,
    which makes it more likely that your developers will use it effectively.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，大多数集中式版本控制系统无法有效处理分支方案。分支是一种非常有用的技术，可以让您在许多人在多个功能上工作的项目中限制合并冲突的数量。在SVN中，分支是如此荒谬，以至于大多数开发人员都尽量避免使用它。相反，大多数集中式VCS提供了一些文件锁定原语，应该被视为任何版本控制系统的反模式。关于每个版本控制工具的悲哀事实是，如果它包含危险的选项，您团队中的某个人最终将开始每天使用它。锁定是这样一个功能，它虽然减少了合并冲突，但会极大地降低整个团队的生产力。通过选择不允许这种糟糕工作流的版本控制系统，您正在创造一种更有可能使您的开发人员有效使用它的情况。
- en: Use Git if you can
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果可以，请使用Git
- en: Git is currently the most popular distributed version control system. It was
    created by Linus Torvalds for maintaining versions of the Linux kernel when its
    core developers needed to resign from proprietary BitKeeper that was used previously.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Git目前是最流行的分布式版本控制系统。它是由Linus Torvalds创建的，用于维护Linux内核的版本，当其核心开发人员需要从之前使用的专有BitKeeper辞职时。
- en: If you have not used any of the version control systems then you should start
    with Git from the beginning. If you already use some other tools for version control,
    learn Git anyway. You should definitely do that even if your organization is unwilling
    to switch to Git in the near future, otherwise you risk becoming a living fossil.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未使用任何版本控制系统，则应从头开始使用Git。如果您已经使用其他工具进行版本控制，请无论如何学习Git。即使您的组织在不久的将来不愿切换到Git，您也应该这样做，否则您可能会成为一个活化石。
- en: I'm not saying that Git is the ultimate and best DVCS version control system.
    It surely has some disadvantages. Most of all, it is not an easy-to-use tool and
    is very challenging for newcomers. Git's steep learning curve is already a source
    of many jokes online. There may be some version control systems that may perform
    better for a lot of projects and the full list of open source Git contenders would
    be quite long. Anyway, Git is currently the most popular DVCS, so the *network
    effect* really works in its favor.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不是说Git是最终和最好的DVCS版本控制系统。它肯定有一些缺点。最重要的是，它不是一个易于使用的工具，对新手来说非常具有挑战性。Git的陡峭学习曲线已经成为网络上许多笑话的来源。可能有一些版本控制系统对许多项目表现更好，开源Git竞争者的完整列表会相当长。无论如何，Git目前是最受欢迎的DVCS，因此*网络效应*确实对它有利。
- en: Briefly speaking, the network effect causes that the overall benefit of using
    popular tools is greater than using others, even if slightly better, precisely
    due to its high popularity (this is how VHS killed Betamax). It is very probable
    that people in your organization, as well as new hires, are somewhat proficient
    with Git, so the cost of integrating exactly this DVCS will be lower than trying
    something less popular.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，网络效应导致使用流行工具的整体效益大于使用其他工具，即使稍微更好，也是因为其高度的流行（这就是VHS击败Betamax的原因）。很可能你的组织中的人，以及新员工，对Git都有一定的熟练程度，因此集成这个DVCS的成本会比尝试一些不那么流行的工具要低。
- en: Anyway, it is still always good to know something more and familiarizing yourself
    with other DVCS won't hurt you. The most popular open source rivals of Git are
    Mercurial, Bazaar, and Fossil. The first one is especially neat because it is
    written in Python and was the official version control system for CPython sources.
    There are some signs that it may change in the near future, so CPython developers
    may already use Git by the time you read this book. But it really does not matter.
    Both systems are great. If there would be no Git, or it were less popular, I would
    definitely recommend Mercurial. There is evident beauty in its design. It's definitely
    not as powerful as Git, but a lot easier to master for beginners.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，了解更多并熟悉其他分布式版本控制系统总是好的。Git最受欢迎的开源竞争对手是Mercurial、Bazaar和Fossil。第一个特别好，因为它是用Python编写的，并且是CPython源代码的官方版本控制系统。有迹象表明，这种情况可能会在不久的将来发生变化，所以当你读到这本书的时候，CPython开发人员可能已经在使用Git了。但这并不重要。这两个系统都很棒。如果没有Git，或者它不那么受欢迎，我肯定会推荐Mercurial。它的设计显然很美。它肯定没有Git那么强大，但对初学者来说更容易掌握。
- en: Git flow and GitHub flow
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Git flow和GitHub flow
- en: 'The very popular and standardized methodology for working with Git is simply
    called **Git flow**. Here is the brief description of the main rules of that flow:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 与Git一起工作的非常流行和标准化的方法简称为**Git flow**。以下是该流程的主要规则的简要描述：
- en: There is a main working branch, usually called `develop`, where all the developments
    for the latest version of the application occurs.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常有一个主要的工作分支，通常称为`develop`，所有最新版本应用的开发都在这里进行。
- en: New project features are implemented in separate branches called *feature branches*
    that always start from the `develop` branch. When work on a feature is finished
    and the code is properly tested, this branch is merged back to `develop`.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新项目功能是在称为*功能分支*的单独分支上实现的，这些分支总是从`develop`分支开始。当功能完成并且代码经过适当测试后，该分支会合并回`develop`。
- en: When the code in `develop` is stabilized (without known bugs) and there is a
    need for new application release, a new *release branch* is created. This release
    branch usually requires additional tests (extensive QA tests, integration tests,
    and so on) so new bugs will be definitely found. If additional changes (such as
    bug fixes) are included in a release branch, they need to eventually be merged
    back to the `develop` branch.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`develop`中的代码稳定下来（没有已知的错误）并且需要发布新的应用程序版本时，会创建一个新的*发布分支*。这个发布分支通常需要额外的测试（广泛的QA测试、集成测试等），所以一定会发现新的错误。如果发布分支包括额外的更改（如错误修复），它们最终需要合并回`develop`分支。
- en: When code on a *release branch* is ready to be deployed/released, it is merged
    to the `master` branch and the latest commit on the `master` is labeled with an
    appropriate version tag. No other branches but `release` branches can be merged
    to the `master`. The only exceptions are hot fixes that need to be immediately
    deployed or released.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当*发布分支*上的代码准备部署/发布时，它会合并到`master`分支，并且`master`上的最新提交会被标记为适当的版本标签。除了`release`分支，没有其他分支可以合并到`master`。唯一的例外是需要立即部署或发布的紧急修复。
- en: Hot fixes that require urgent release are always implemented on separate branches
    that start from the `master`. When the fix is done, it is merged to both the `develop`
    and `master` branches. Merging of the hot fix branch is done like it were an ordinary
    release branch, so it must be properly tagged and the application version identifier
    should be modified accordingly.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要紧急发布的热修复总是在从`master`开始的单独分支上实现。修复完成后，它会合并到`develop`和`master`分支。热修复分支的合并就像普通的发布分支一样进行，因此必须正确标记，并相应地修改应用程序版本标识符。
- en: The visual example of *Git flow* in action is presented in *Figure 5*. For those
    that have never worked in such a way, and have also never used distributed version
    control systems, this may be a bit overwhelming. Anyway, it is really worth trying
    in your organization if you don't have any formalized workflow. It has multiple
    benefits and also solves real problems. It is especially useful for teams of multiple
    programmers that are working on many separate features and when continuous support
    for multiple releases needs to be provided.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5*中展示了*Git flow*的视觉示例。对于那些从未以这种方式工作过，也从未使用过分布式版本控制系统的人来说，这可能有点压倒性。无论如何，如果你的组织没有任何正式的工作流程，值得尝试。它有多重好处，也解决了真正的问题。对于多名程序员团队，他们正在开发许多独立功能，并且需要为多个版本提供持续支持时，它尤其有用。'
- en: This methodology is also handy if you want to implement continuous delivery
    using continuous deployment processes because it is always clear in your organization
    and which version of code represents a deliverable release of your application
    or service. It is also a great tool for open source projects because it provides
    great transparency to both the users and the active contributors.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用持续部署流程来实现持续交付，这种方法也很方便，因为在您的组织中始终清楚哪个代码版本代表了您的应用程序或服务的可交付版本。对于开源项目来说，它也是一个很好的工具，因为它为用户和活跃的贡献者提供了很好的透明度。
- en: '![Git flow and GitHub flow](graphics/5295_08_05.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![Git流程和GitHub流程](graphics/5295_08_05.jpg)'
- en: Figure 5 Visual presentation of Git flow in action
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图5 展示了Git流程的视觉呈现
- en: So, if you think that this short summary of *Git flow* makes a bit of sense
    and it did not scare you yet, then you should dig deeper into online resources
    on that topic. It is really hard to say who the original author of the preceding
    workflow is, but most online sources point to Vincent Driessen. Thus, the best
    starting material to learn about *Git flow* is his online article titled *A successful
    Git* *branching model* (refer to [http://nvie.com/posts/a-successful-git-branching-model/](http://nvie.com/posts/a-successful-git-branching-model/)).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您认为这个对*Git流程*的简短总结有点意义，并且还没有吓到您，那么您应该深入研究该主题的在线资源。很难说出这个工作流的原始作者是谁，但大多数在线来源都指向Vincent
    Driessen。因此，学习*Git流程*的最佳起点材料是他的在线文章，标题为*成功的Git* *分支模型*（参考[http://nvie.com/posts/a-successful-git-branching-model/](http://nvie.com/posts/a-successful-git-branching-model/)）。
- en: Like every other popular methodology, *Git flow* gained a lot of criticism over
    the Internet from programmers that do not like it. The most commented thing about
    Vincent Driessen's article is the rule (strictly technical) saying that every
    merge should create a new artificial commit representing that merge. Git has an
    option to do *fast forward* merges and Vincent discourages that option. This is,
    of course, an unsolvable problem because the best way to perform merges is a completely
    subjective matter to the organization Git is being used in. Anyway, the real issue
    of *Git flow* is that it is noticeably complicated. The full set of rules is really
    long, so it is easy to make some mistakes. It is very probable that you would
    like to choose something simpler.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 像其他流行的方法一样，*Git流程*在互联网上受到了很多程序员的批评。Vincent Driessen的文章中最受评论的事情是（严格技术性的）规则，即每次合并都应该创建一个代表该合并的新人工提交。Git有一个选项可以进行*快进*合并，Vincent不鼓励使用该选项。当然，这是一个无法解决的问题，因为执行合并的最佳方式完全是组织Git正在使用的主观问题。无论如何，*Git流程*的真正问题在于它显然很复杂。完整的规则集非常长，因此很容易犯一些错误。您很可能希望选择一些更简单的东西。
- en: 'One such flow is used at GitHub and described by Scott Chacon on his blog (refer
    to [http://scottchacon.com/2011/08/31/github-flow.html](http://scottchacon.com/2011/08/31/github-flow.html)).
    It is referred to as **GitHub flow** and is very similar to *Git flow*:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub使用了这样的流程，并由Scott Chacon在他的博客上描述（参考[http://scottchacon.com/2011/08/31/github-flow.html](http://scottchacon.com/2011/08/31/github-flow.html)）。它被称为**GitHub流程**，与*Git流程*非常相似：
- en: Anything in the master branch is deployable
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主分支中的任何内容都可以部署
- en: The new features are implemented on separate branches
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新功能是在单独的分支上实现的
- en: The main difference from *Git flow* is simplicity. There is only one main development
    branch (`master`) and it is always stable (in contrast to the `develop` branch
    in *Git flow*). There are also no release branches and a big emphasis is placed
    on tagging the code. There is no such need at GitHub because, as they say, when
    something is merged into the master it is usually deployed to production immediately.
    Diagram presenting an example b flow in action is shown in *Figure 6*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与*Git流程*的主要区别在于简单性。只有一个主要开发分支（`master`），它始终是稳定的（与*Git流程*中的`develop`分支相反）。也没有发布分支，而且非常强调对代码进行标记。在GitHub上没有这样的需要，因为他们说，当某些东西合并到主分支时，通常会立即部署到生产环境。图6展示了GitHub流程示例的图表。
- en: 'GitHub flow seems like a good and lightweight workflow for teams that want
    to have a continuous deployment process setup for their project. Such a workflow
    is, of course, not viable for any project that has a strong notion of release
    (with strict version numbers)—at least without any modifications. It is important
    to know that the main assumption of the *always deployable* `master` branch is
    that it cannot be ensured without proper automated testing and a building procedure.
    This is what continuous integration systems take care of and we will discuss that
    a bit later. The following is a diagram presenting an example of GitHub flow in
    action:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub流程似乎是一个适合希望为其项目设置持续部署流程的团队的良好且轻量级的工作流。当然，这样的工作流对于具有严格版本号概念的任何项目来说都是不可行的，至少没有进行任何修改。重要的是要知道*始终可部署*
    `master`分支的主要假设是，没有适当的自动化测试和构建程序就无法保证。这就是持续集成系统要处理的问题，我们稍后会讨论这个问题。以下是一个展示GitHub流程示例的图表：
- en: '![Git flow and GitHub flow](graphics/5295_08_06.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![Git流程和GitHub流程](graphics/5295_08_06.jpg)'
- en: Figure 6 Visual presentation of GitHub flow in action
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图6 展示了GitHub流程的视觉呈现
- en: Note that both *Git flow* and *GitHub flow* are only branching strategies, so
    despite having *Git* in their names, they are not limited to that single DVCS
    solution. It's true that the official article describing *Git flow* mentions specific
    `git` command parameters that should be used when performing a merge, but the
    general idea can be easily applied to almost any other distributed version control
    system. In fact, due to the way it is suggested to handle merges, Mercurial seems
    like a better tool to use for this specific branching strategy! The same applies
    to *GitHub flow*. This is the only branching strategy sprinkled with a bit of
    specific development culture, so it can be used in any version control system
    that allows you to easily create and merge branches of code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，*Git flow*和*GitHub flow*都只是分支策略，所以尽管它们的名字中都有*Git*，但它们并不局限于单一的分布式版本控制系统。*Git
    flow*的官方文章提到了在执行合并时应该使用的特定`git`命令参数，但这个基本思想几乎可以轻松应用于几乎任何其他分布式版本控制系统。事实上，由于它建议如何处理合并，Mercurial似乎是更好的工具来使用这种特定的分支策略！*GitHub
    flow*也是一样。这是唯一一种带有一点特定开发文化的分支策略，因此它可以在任何允许你轻松创建和合并代码分支的版本控制系统中使用。
- en: As a last comment, remember that no methodology is carved in stone and no one
    forces you to use it. They are created to solve some existing problems and keep
    you from making common mistakes. You can take all of their rules or modify some
    of them to your own needs. They are great tools for beginners that may easily
    get into common pitfalls. If you are not familiar with any version control system,
    you should then start with a lightweight methodology like *GitHub flow* without
    any custom modification. You should start thinking about more complex workflows
    only when you get enough experience with Git, or any other tool of your choice.
    Anyway, as you will gain more and more proficiency, you will eventually realize
    that there is no perfect workflow that suits every project. What works well in
    one organization does not need to work well in others.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点要记住的是，没有一种方法论是铁板一块，也没有人强迫你使用它。它们被创造出来是为了解决一些现有的问题，并防止你犯一些常见的错误。你可以接受它们的所有规则，或者根据自己的需要修改其中一些。它们是初学者的好工具，可以轻松地避开常见的陷阱。如果你不熟悉任何版本控制系统，那么你应该从像*GitHub
    flow*这样的轻量级方法开始，不做任何自定义修改。只有当你对Git或你选择的其他工具有足够的经验时，你才应该考虑更复杂的工作流。无论如何，随着你的熟练程度越来越高，你最终会意识到没有一种完美的工作流适用于每个项目。在一个组织中运行良好的东西不一定在其他组织中也能运行良好。
- en: Continuous development processes
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续开发过程
- en: There are some processes that can greatly streamline your development and reduce
    a time in getting the application ready to be released or deployed to the production
    environment. They often have `continuous` in their name, and we will discuss the
    most important and popular ones in this section. It is important to highlight
    that they are strictly technical processes, so they are almost unrelated to project
    management technologies, although they can highly dovetail with the latter.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些过程可以极大地简化你的开发，并减少将应用程序准备好发布或部署到生产环境所需的时间。它们的名字中经常带有`continuous`，我们将在本节讨论最重要和最受欢迎的过程。需要强调的是，它们是严格的技术过程，因此它们几乎与项目管理技术无关，尽管它们可以与后者高度契合。
- en: 'The most important processes we will mention are:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提到的最重要的过程是：
- en: Continuous integration
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续集成
- en: Continuous delivery
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续交付
- en: Continuous deployment
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续部署
- en: The order of listing is important because each one of them is an extension of
    the previous one. Continuous deployment could be simply considered even a variation
    of continuous delivery. We will discuss them separately anyway, because what is
    only a minor difference for one organization may be critical in others.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列出顺序很重要，因为它们中的每一个都是前一个的延伸。持续部署甚至可以简单地被认为是持续交付的变体。无论如何，我们将分别讨论它们，因为对一个组织来说只是一个微小的差异，对其他组织来说可能是至关重要的。
- en: The fact that these are technical processes means that their implementation
    strictly depends on the usage of proper tools. The general idea behind each of
    them is rather simple, so you could build your own continuous integration/delivery/deployment
    tools, but the best approach is to choose something that is already built. This
    way, you can focus more on building your product instead of the tool chain for
    continuous development.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是技术过程的事实意味着它们的实施严格依赖于适当工具的使用。它们背后的基本思想都相当简单，所以你可以构建自己的持续集成/交付/部署工具，但最好的方法是选择已经构建好的工具。这样，你就可以更多地专注于构建产品，而不是持续开发的工具链。
- en: Continuous integration
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续集成
- en: '**Continuous integration**, often abbreviated as **CI**, is a process that
    takes benefit from automated testing and version control systems to provide a
    fully automatic integration environment. It can be used with centralized version
    control systems but in practice it spreads its wings only when a good DVCS tool
    is being used to manage the code.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续集成**，通常缩写为**CI**，是一种利用自动化测试和版本控制系统来提供完全自动化集成环境的过程。它可以与集中式版本控制系统一起使用，但在实践中，只有在使用良好的分布式版本控制系统来管理代码时，它才能充分发挥作用。'
- en: Setting up a repository is the first step towards continuous integration, which
    is a set of software practices that have emerged from **eXtreme** **Programming**
    (**XP**). The principles are clearly described on Wikipedia ([http://en.wikipedia.org/wiki/Continuous_integration#The_Practices](http://en.wikipedia.org/wiki/Continuous_integration#The_Practices))
    and define a way to make sure the software is easy to build, test, and deliver.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 设置仓库是持续集成的第一步，这是一组从**极限编程**(**XP**)中出现的软件实践。这些原则在维基百科上清楚地描述了([http://en.wikipedia.org/wiki/Continuous_integration#The_Practices](http://en.wikipedia.org/wiki/Continuous_integration#The_Practices))，并定义了一种确保软件易于构建、测试和交付的方式。
- en: The first and most important requirement to implement continuous integration
    is to have a fully automated workflow that can test the whole application in the
    given revision in order to decide if it is technically correct. Technically correct
    means that it is free of known bugs and that all the features work as expected.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 实施持续集成的第一个和最重要的要求是拥有一个完全自动化的工作流程，可以在给定的修订版中测试整个应用程序，以决定其是否在技术上正确。技术上正确意味着它没有已知的错误，并且所有功能都按预期工作。
- en: The general idea behind CI is that tests should always be run before merging
    to the mainstream development branch. This could be handled only through formal
    arrangements in the development team, but practice shows that this is not a reliable
    approach. The problem is that, as programmers, we tend to be overconfident and
    are unable to look critically at our code. If continuous integration is built
    only on team arrangements, it will inevitably fail because some of the developers
    will eventually skip their testing phase and commit possibly faulty code to the
    mainstream development branch that should always remain stable. And, in reality,
    even simple changes can introduce critical issues.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: CI的一般理念是在合并到主流开发分支之前始终运行测试。这只能通过开发团队中的正式安排来处理，但实践表明这不是一种可靠的方法。问题在于，作为程序员，我们倾向于过于自信，无法对我们的代码进行批判性的审视。如果持续集成仅建立在团队安排上，它将不可避免地失败，因为一些开发人员最终会跳过他们的测试阶段，并将可能有缺陷的代码提交到应始终保持稳定的主流开发分支。而且，实际上，即使是简单的更改也可能引入关键问题。
- en: The obvious solution is to utilize a dedicated build server that automatically
    runs all the required application tests whenever the codebase changes. There are
    many tools that streamline this process and they can be easily integrated with
    version control hosting services such as GitHub or Bitbucket and self-hosted services
    such as GitLab. The benefit of using such tools is that the developer may locally
    run only the selected subset of tests (that, according to him, are related to
    his current work) and leave a potentially time consuming whole suite of integration
    tests for the build server. This really speeds up the development but still reduces
    the risk that new features will break the existing stable code found in the mainstream
    code branch.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 明显的解决方案是利用专用构建服务器，它在代码库发生更改时自动运行所有必需的应用程序测试。有许多工具可以简化这个过程，并且它们可以很容易地集成到诸如GitHub或Bitbucket等版本控制托管服务以及GitLab等自托管服务中。使用这些工具的好处是开发人员可以在本地仅运行与他当前工作相关的选定测试子集，并将潜在耗时的整个集成测试套件留给构建服务器。这确实加快了开发速度，但仍然减少了新功能破坏主流代码分支中现有稳定代码的风险。
- en: Another plus of using a dedicated build server is that tests can be run in the
    environment that is closer to the production. Developers should also use environments
    that match the production as closely as possible and there are great tools for
    that (Vagrant, for instance); it is, however, hard to enforce this in any organization.
    You can easily do that on one dedicated build server or even on a cluster of build
    servers. Many CI tools make that even less problematic by utilizing various virtualization
    tools that help to ensure that tests are run always in the same, and completely
    fresh, testing environment.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用专用构建服务器的另一个好处是可以在接近生产环境的环境中运行测试。开发人员还应尽可能使用与生产环境尽可能匹配的环境，并且有很好的工具可以做到这一点（例如Vagrant）；然而，在任何组织中强制执行这一点是很困难的。您可以在一个专用的构建服务器上甚至在一个构建服务器集群上轻松实现这一点。许多CI工具通过利用各种虚拟化工具来确保测试始终在相同的、完全新鲜的测试环境中运行，使这一点变得更加不成问题。
- en: Having a build server is also a must if you create desktop or mobile applications
    that must be delivered to users in binary form. The obvious thing to do is to
    always perform such a building procedure in the same environment. Almost every
    CI system takes into account the fact that applications often need to be downloaded
    in binary form after testing/building is done. Such building results are commonly
    referred to as **build artifacts**.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个构建服务器对于创建必须以二进制形式交付给用户的桌面或移动应用程序也是必不可少的。显而易见的做法是始终在相同的环境中执行这样的构建过程。几乎每个CI系统都考虑到应用程序通常需要在测试/构建完成后以二进制形式下载。这样的构建结果通常被称为**构建产物**。
- en: Because CI tools originated in times where most of the applications were written
    in compiled languages, they mostly use the term "building" to describe their main
    activity. For languages such as C or C++, this is obvious because applications
    cannot be run and tested if it is not built (compiled). For Python, this makes
    a bit less sense because most of the programs are distributed in a source form
    and can be run without any additional building step. So, in the scope of our language,
    the *building* and *testing* terms are often used interchangeably when talking
    about continuous integration.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因为CI工具起源于大多数应用程序都是用编译语言编写的时代，它们大多使用术语“构建”来描述它们的主要活动。对于诸如C或C ++之类的语言，这是显而易见的，因为如果不构建（编译）应用程序，则无法运行和测试。对于Python来说，这就显得有点不合理，因为大多数程序以源代码形式分发，并且可以在没有任何额外构建步骤的情况下运行。因此，在我们的语境中，当谈论持续集成时，“构建”和“测试”这两个术语经常可以互换使用。
- en: Testing every commit
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试每次提交
- en: The best approach to continuous integration is to perform the whole test suite
    on every change pushed to the central repository. Even if one programmer pushed
    a series of multiple commits in a single branch, it very often makes sense to
    test each change separately. If you decide to test only the latest changeset in
    a single repository push, then it will be harder to find sources of possible regression
    problems introduced somewhere in the middle.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成的最佳方法是在每次更改推送到中央存储库时对整个测试套件进行测试。即使一个程序员在单个分支中推送了一系列多个提交，通常也有意义对每个更改进行单独测试。如果您决定仅测试单个存储库推送中的最新更改集，那么将更难找到可能在中间某个地方引入的潜在回归问题的源头。
- en: Of course, many DVCS such as Git or Mercurial allow you to limit time spent
    on searching regression sources by providing commands to *bisect* the history
    of changes, but in practice it is much more convenient to do that automatically
    as part of your continuous integration process.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，许多分布式版本控制系统，如Git或Mercurial，允许你通过提供*二分*历史更改的命令来限制搜索回归源的时间，但实际上，将其作为持续集成过程的一部分自动完成会更加方便。
- en: Of course there is the issue of projects that have very long running test suites
    that may require tens of minutes or even hours to complete. One server may be
    not enough to perform all the builds on every commit made in the given time frame.
    This will make waiting for results even longer. In fact, long running tests is
    a problem on its own that will be described later in the *Problem 2 – too long
    building time* section. For now, you should know that you should always strive
    to test every commit pushed to the repository. If you have no power to do that
    on a single server, then set up the whole building cluster. If you are using a
    paid service, then pay for a higher pricing plan with more parallel builds. Hardware
    is cheap. Your developers' time is not. Eventually, you will save more money by
    having faster parallel builds and a more expensive CI setup than you would save
    on skipping tests for selected changes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有一个问题是，一些测试套件运行时间非常长，可能需要数十分钟甚至数小时才能完成。一个服务器可能无法在给定时间内处理每次提交的所有构建。这将使等待结果的时间更长。事实上，长时间运行的测试本身就是一个问题，稍后将在*问题2-构建时间过长*部分进行描述。现在，你应该知道，你应该始终努力测试推送到仓库的每次提交。如果你没有能力在单个服务器上做到这一点，那么就建立整个构建集群。如果你使用的是付费服务，那么就支付更高价格的计划，进行更多并行构建。硬件是便宜的，你开发人员的时间不是。最终，通过拥有更快的并行构建和更昂贵的CI设置，你将节省更多的钱，而不是通过跳过对选定更改的测试来节省钱。
- en: Merge testing through CI
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过CI进行合并测试
- en: Reality is complicated. If the code on a feature branch passes all the tests,
    it does not mean that the build will not fail when it is merged to a stable mainstream
    branch. Both of the popular branching strategies mentioned in the *Git flow and
    GitHub flow* sections assume that code merged to the `master` branch is always
    tested and deployable. But how can you be sure that this assumption is met if
    you have not perform the merge yet? This is a lesser problem for *Git flow* (if
    implemented well and used precisely) due to its emphasis on release branches.
    But it is a real problem for the simple *GitHub flow* where merging to `master`
    is often related with conflicts and is very likely to introduce regressions in
    tests. Even for *Git flow*, this is a serious concern. This is a complex branching
    model, so for sure people will make mistakes when using it. So, you can never
    be sure that the code on `master` will pass the tests after merging if you won't
    take the special precautions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现实是复杂的。如果功能分支上的代码通过了所有测试，并不意味着当它合并到稳定主干分支时构建不会失败。在*Git flow*和*GitHub flow*部分提到的两种流行的分支策略都假设合并到`master`分支的代码总是经过测试并可部署。但是如果你还没有执行合并，你怎么能确定这个假设是成立的呢？对于*Git
    flow*来说，这个问题相对较小（如果实施得当并且使用得当），因为它强调发布分支。但对于简单的*GitHub flow*来说，这是一个真正的问题，因为合并到`master`通常会导致冲突，并且很可能会引入测试回归。即使对于*Git
    flow*来说，这也是一个严重的问题。这是一个复杂的分支模型，所以当人们使用它时肯定会犯错误。因此，如果你不采取特殊预防措施，你永远无法确定合并后`master`上的代码是否会通过测试。
- en: One of the solutions to this problem is to delegate the duty of merging feature
    branches into a stable mainstream branch to your CI system. In many CI tools,
    you can easily set up an on-demand building job that will locally merge a specific
    feature branch to the stable branch and push it to the central repository only
    if it passed all the tests. If the build fails, then such a merge will be reverted,
    leaving the stable branch untouched. Of course, this approach gets more complex
    in fast paced projects where many feature branches are developed simultaneously
    because there is a high risk of conflicts that can't be resolved automatically
    by any CI system. There are, of course, solutions to that problem, like rebasing
    in Git.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一个方法是将合并功能分支到稳定主干分支的责任委托给你的CI系统。在许多CI工具中，你可以轻松地设置一个按需构建作业，该作业将在本地合并特定功能分支到稳定分支，并且只有在通过了所有测试后才将其推送到中央仓库。如果构建失败，那么这样的合并将被撤销，使稳定分支保持不变。当然，在快节奏的项目中，这种方法会变得更加复杂，因为同时开发许多功能分支会存在高风险的冲突，这些冲突无法被任何CI系统自动解决。当然，针对这个问题也有解决方案，比如在Git中进行变基。
- en: Such an approach to merging anything into the stable branch in a version control
    system is practically a must if you are thinking about going further and implementing
    continuous delivery processes. It is also required if you have a strict rule in
    your workflow stating that everything in a stable branch is releasable.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑进一步实施持续交付流程，或者如果你的工作流程严格规定稳定分支中的所有内容都是可发布的，那么将任何东西合并到版本控制系统的稳定分支中实际上是必须的。
- en: Matrix testing
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 矩阵测试
- en: Matrix testing is a very useful tool if your code needs to be tested in different
    environments. Depending on your project needs, the direct support of such a feature
    in your CI solution may be less or more required.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码需要在不同的环境中进行测试，矩阵测试是一个非常有用的工具。根据你的项目需求，你的CI解决方案对这种功能的直接支持可能更或更少需要。
- en: The easiest way to explain the idea of matrix testing is to take the example
    of some open source Python package. Django, for instance, is the project that
    has a strictly specified set of supported Python language versions. The 1.9.3
    version lists the Python 2.7, Python 3.4, and Python 3.5 versions as required
    in order to run Django code. This means that every time Django core developers
    make a change to the project, the full tests suite must be executed on these three
    Python versions in order to back this claim. If even a single test fails on one
    environment, the whole build must be marked as failed because the backwards compatibility
    constraint was possibly broken. For such a simple case, you do not need any support
    from CI. There is a great Tox tool (refer to [https://tox.readthedocs.org/](https://tox.readthedocs.org/))
    that, among other features, allows you to easily run test suites in different
    Python versions in isolated virtual environments. This utility can also be easily
    used in local development.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 解释矩阵测试的最简单方法是以一些开源的Python软件包为例。例如，Django是一个严格指定支持的Python语言版本的项目。1.9.3版本列出了运行Django代码所需的Python
    2.7、Python 3.4和Python 3.5版本。这意味着每次Django核心开发人员对项目进行更改时，必须在这三个Python版本上执行完整的测试套件，以支持这一说法。如果在一个环境中甚至有一个测试失败，整个构建必须标记为失败，因为可能违反了向后兼容性约束。对于这样一个简单的情况，你不需要CI的任何支持。有一个很棒的Tox工具（参见[https://tox.readthedocs.org/](https://tox.readthedocs.org/)），除了其他功能外，它还允许你在隔离的虚拟环境中轻松运行不同Python版本的测试套件。这个实用程序也可以很容易地用于本地开发。
- en: 'But this was only the simplest example. It is not uncommon that the application
    must be tested in multiple environments where completely different parameters
    must be tested. To name a few:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 但这只是最简单的例子。不少应用程序必须在多个环境中进行测试，其中必须测试完全不同的参数。举几个例子：
- en: Different operating systems
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的操作系统
- en: Different databases
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的数据库
- en: Different versions of backing services
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同版本的后备服务
- en: Different types of filesystems
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同类型的文件系统
- en: The full set of combinations forms a multi-dimensional environment parameter
    matrix, and this is why such a setup is called matrix testing. When you need such
    a deep testing workflow, it is very possible that you require some integrated
    support for matrix testing in your CI solution. With a large number of possible
    combinations, you will also require a highly parallelizable building process because
    every run over the matrix will require a large amount of work from your building
    server. In some cases, you will be forced to do some tradeoff if your test matrix
    has too many dimensions.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的组合形成了一个多维环境参数矩阵，这就是为什么这样的设置被称为矩阵测试。当你需要这样一个深层测试工作流程时，很可能需要一些集成支持来进行矩阵测试。对于可能的组合数量很大，你还需要一个高度可并行化的构建过程，因为每次在矩阵上运行都需要大量的工作来自你的构建服务器。在某些情况下，如果你的测试矩阵有太多维度，你将被迫做一些权衡。
- en: Continuous delivery
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续交付
- en: Continuous delivery is a simple extension of the continuous integration idea.
    This approach to software engineering aims to ensure that the application can
    be released reliably at any time. The goal of continuous delivery is to release
    software in short circles. It generally reduces both costs and the risk of releasing
    software by allowing the incremental delivery of changes to the application in
    production.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 持续交付是持续集成思想的一个简单延伸。这种软件工程方法旨在确保应用程序可以随时可靠地发布。持续交付的目标是在短时间内发布软件。它通常通过允许将应用程序的变更逐步交付到生产环境中来降低成本和发布软件的风险。
- en: 'The main prerequisites for building successful continuous delivery processes
    are:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 构建成功的持续交付过程的主要先决条件是：
- en: A reliable continuous integration process
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可靠的持续集成过程
- en: An automated process of deployment to the production environment (if the project
    has a notion of the production environment)
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动部署到生产环境的流程（如果项目有生产环境的概念）
- en: A well-defined version control system workflow or branching strategy that allows
    you to easily define what version of software represents releasable code
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个明确定义的版本控制系统工作流程或分支策略，允许你轻松定义哪个软件版本代表可发布的代码
- en: In many projects, the automated tests are not enough to reliably tell if the
    given version of the software is really ready to be released. In such cases, the
    additional manual user acceptance tests are usually performed by skilled QA staff.
    Depending on your project management methodology, this may also require some approval
    from the client. This does not mean that you can't use *Git flow*, *GitHub flow*,
    or a similar branching strategy, if some of your acceptance tests must be performed
    manually by humans. This only changes the semantics of your stable and release
    branches from *ready to be deployed* to *ready for user acceptance tests and approval*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多项目中，自动化测试并不足以可靠地告诉你软件的给定版本是否真的准备好发布。在这种情况下，通常由熟练的QA人员执行额外的手动用户验收测试。根据你的项目管理方法论，这可能还需要客户的批准。这并不意味着如果你的验收测试必须由人工手动执行，你就不能使用*Git
    flow*、*GitHub flow*或类似的分支策略。这只是将你的稳定和发布分支的语义从*准备部署*更改为*准备进行用户验收测试和批准*。
- en: Also, the previous paragraph does not change the fact that code deployment should
    always be automated. We already discussed some of the tools and benefits of automation
    in [Chapter 6](ch06.html "Chapter 6. Deploying Code"), *Deploying Code*. As stated
    there, it will always reduce the cost and risk of a new release. Also, most of
    the available CI tools allow you to set up special build targets that, instead
    of testing, will perform automated deployment for you. In most continuous delivery
    processes, this is usually triggered manually (on demand) by authorized staff
    members when they are sure there is required approval and all acceptance tests
    ended with success.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，前面的段落并不改变代码部署应始终自动化的事实。我们已经在[第6章](ch06.html "第6章。部署代码")中讨论了一些工具和自动化的好处，*部署代码*。正如在那里所述，它将始终降低新版本发布的成本和风险。此外，大多数可用的CI工具都允许你设置特殊的构建目标，而不是测试，将为你执行自动化部署。在大多数持续交付过程中，这通常是由授权人员手动触发的，当他们确信已经获得了必要的批准并且所有验收测试都以成功结束时。
- en: Continuous deployment
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续部署
- en: Continuous deployment is a process that takes continuous delivery to the next
    level. It is a perfect approach for projects where all acceptance tests are automated
    and there is no need for manual approval from the client. In short, once code
    is merged to the stable branch (usually `master`), it is automatically deployed
    to the production environment.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 持续部署是将持续交付推向更高水平的过程。对于所有验收测试都是自动化的项目来说，这是一个完美的方法，而且不需要客户的手动批准。简而言之，一旦代码合并到稳定分支（通常是`master`），它就会自动部署到生产环境。
- en: This approach seems to be very nice and robust but is not often used because
    it is very hard to find a project that does not need manual QA testing and someone's
    approval before a new version is released. Anyway, it is definitely doable and
    some companies claim to be working in that way.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法似乎非常好和稳健，但并不经常使用，因为很难找到一个不需要在发布新版本之前进行手动QA测试和某人批准的项目。无论如何，这是可行的，一些公司声称他们正在以这种方式工作。
- en: In order to implement continuous deployment, you need the same basic prerequisites
    as the continuous delivery process. Also, a more careful approach to merging into
    a stable branch is very often required. What gets merged into the `master` in
    continuous integration usually goes instantly to the production. Because of that,
    it is reasonable to handoff the merging task to your CI system, as explained in
    the *Merge testing through CI* section.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现持续部署，你需要与持续交付过程相同的基本先决条件。此外，对合并到稳定分支的更加谨慎的方法通常是必需的。在持续集成中合并到`master`的内容通常会立即进入生产环境。因此，将合并任务交给你的CI系统是合理的，就像在*通过CI进行合并测试*部分中所解释的那样。
- en: Popular tools for continuous integration
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续集成的流行工具
- en: There is a tremendous variety of choices for CI tools nowadays. They greatly
    vary on ease of use and available features, and almost each one of them has some
    unique features that others will lack. So, it is hard to give a good general recommendation
    because each project has completely different needs and also a different development
    workflow. There are, of course, some great free and open source projects, but
    paid hosted services are also worth researching. It's because although open source
    software such as Jenkins or Buildbot are freely available to install without any
    fee, it is false thinking that they are free to run. Both hardware and maintenance
    are added costs of having your own CI system. In some circumstances, it may be
    less expensive to pay for such a service instead of paying for additional infrastructure
    and spending time on resolving any issues in open source CI software. Still, you
    need to make sure that sending your code to any third-party service is in line
    with security policies at your company.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有大量的持续集成工具可供选择。它们在易用性和可用功能上有很大的差异，几乎每一个都有一些其他工具缺乏的独特功能。因此，很难给出一个好的一般性建议，因为每个项目的需求完全不同，开发工作流也不同。当然，有一些很棒的免费开源项目，但付费托管服务也值得研究。这是因为尽管像Jenkins或Buildbot这样的开源软件可以免费安装，但错误地认为它们是免费运行的。拥有自己的CI系统还需要硬件和维护成本。在某些情况下，支付这样的服务可能比支付额外的基础设施成本和花费时间解决开源CI软件中的任何问题更便宜。但是，你需要确保将代码发送到任何第三方服务是否符合公司的安全政策。
- en: Here we will review some of the popular free open source tools, as well as paid
    hosted services. I really don't want to advertise any vendor, so we will discuss
    only those that are available without any fees for open source projects to justify
    this rather subjective selection. No best recommendation will be given, but we
    will point out both the good and bad sides of any solution. If you are still in
    doubt, the next section that describes common continuous integration pitfalls
    should help you in making good decisions.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将回顾一些流行的免费开源工具，以及付费托管服务。我真的不想为任何供应商做广告，所以我们只讨论那些对开源项目免费提供的工具，以证明这种相当主观的选择。我们不会给出最佳建议，但我们会指出任何解决方案的优缺点。如果你还在犹豫不决，下一节描述常见持续集成陷阱的部分应该能帮助你做出明智的决定。
- en: Jenkins
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Jenkins
- en: Jenkins ([https://jenkins-ci.org](https://jenkins-ci.org)) seems to be the most
    popular tool for continuous integration. It is also one of the oldest open source
    projects in this field, in pair with Hudson (the development of these two projects
    split and Jenkins is a fork of Hudson).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins ([https://jenkins-ci.org](https://jenkins-ci.org)) 似乎是最受欢迎的持续集成工具。它也是这一领域最古老的开源项目之一，与Hudson一起（这两个项目的开发分离，Jenkins是Hudson的一个分支）。
- en: '![Jenkins](graphics/5295_08_07.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![Jenkins](graphics/5295_08_07.jpg)'
- en: Figure 7 Preview of Jenkins main interface
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图7 Jenkins主界面预览
- en: Jenkins is written in Java and was initially designed mainly for building projects
    written in the Java language. It means that for Java developers, it is a perfect
    CI system, but you will need to struggle a bit if you want to use it with other
    technology stack.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins是用Java编写的，最初主要用于构建用Java语言编写的项目。这意味着对于Java开发人员来说，它是一个完美的CI系统，但如果您想将其与其他技术栈一起使用，可能需要花费一些精力。
- en: One big advantage of Jenkins is its very extensive list of features that Jenkins
    have implemented straight out of the box. The most important one, from the Python
    programmer's point of view, is the ability to understand test results. Instead
    of giving only plain binary information about build success, Jenkins is able to
    present the results of all tests that were executed during a run in the form of
    tables and graphs. This will, of course, not work automatically and you need to
    provide those results in a specific format (by default, Jenkins understands JUnit
    files) during your build. Fortunately, a lot of Python testing frameworks are
    able to export results in a machine-readable format.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins的一个重大优势是其非常广泛的功能列表，这些功能已经直接实现在Jenkins中。从Python程序员的角度来看，最重要的功能是能够理解测试结果。Jenkins不仅提供有关构建成功的简单二进制信息，还能够以表格和图形的形式呈现运行期间执行的所有测试的结果。当然，这不会自动工作，您需要以特定格式提供这些结果（默认情况下，Jenkins理解JUnit文件）在构建期间。幸运的是，许多Python测试框架能够以机器可读的格式导出结果。
- en: 'The following is an example presentation of unit test results in Jenkins in
    its web UI:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Jenkins在其Web UI中单元测试结果的示例演示：
- en: '![Jenkins](graphics/5295_08_08.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![Jenkins](graphics/5295_08_08.jpg)'
- en: Figure 8 Presentation of unit test results in Jenkins
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图8 展示了Jenkins中单元测试结果
- en: 'The following screenshot illustrates how Jenkins presents additional build
    information such as trends or downloadable artifacts:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图说明了Jenkins如何呈现额外的构建信息，例如趋势或可下载的构建产物：
- en: '![Jenkins](graphics/5295_08_09.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![Jenkins](graphics/5295_08_09.jpg)'
- en: Figure 9 Test result trends graph on example Jenkins project
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图9 示例Jenkins项目上的测试结果趋势图
- en: Surprisingly, most of Jenkins' power does not come from its built-in features
    but from a huge repository of free plugins. What is available from clean installation
    may be great for Java developers but programmers using different technologies
    will need to spend a lot of time to make it suited for their project. Even support
    for Git is provided by some plugin.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，Jenkins的大部分功能并不来自其内置功能，而是来自一个庞大的免费插件库。从干净的安装中可用的内容对于Java开发人员可能很棒，但使用不同技术的程序员将需要花费大量时间使其适用于其项目。甚至对Git的支持也是由一些插件提供的。
- en: It is great that Jenkins is so easily extendable, but this has also some serious
    downsides. You will eventually depend on installed plugins to drive your continuous
    integration process and these are developed independently from Jenkins core. Most
    authors of popular plugins try to keep them up to date and compatible with the
    latest releases of Jenkins. Nevertheless, the extensions with smaller communities
    will be updated less frequently, and some day you may be either forced to resign
    from them or postpone the update of the core system. This may be a real problem
    when there is urgent need for an update (security fix, for instance), but some
    of the plugins that are critical for your CI process will not work with the new
    version.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins如此易于扩展是很棒的，但这也有一些严重的缺点。您最终将依赖于安装的插件来驱动您的持续集成过程，这些插件是独立于Jenkins核心开发的。大多数流行插件的作者都会尽力使其与Jenkins的最新版本保持兼容并及时更新。然而，较小社区的扩展将更新频率较低，有一天您可能不得不放弃它们或推迟核心系统的更新。当需要紧急更新（例如安全修复）时，这可能是一个真正的问题，但您的CI过程中一些关键插件将无法与新版本一起使用。
- en: The basic Jenkins installation that provides you with a master CI server is
    also capable of performing builds. This is different from other CI systems that
    put more emphasis on distribution and create a strict separation from master and
    slave build servers. This is both good and bad. On the one side, it allows you
    to set up a wholly working CI server in a few minutes. Jenkins, of course, supports
    deferring work to build slaves, so you can scale out in future whenever it is
    needed. On the other hand, it is very common that Jenkins is underperforming because
    it is deployed in single-server settings, and its users complain regarding performance
    without providing it enough resources. It is not hard to add new building nodes
    to the Jenkins cluster. It seems that this is rather a mental challenge than a
    technical problem for those that got used to the single-server setup.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 提供主CI服务器的基本Jenkins安装也能够执行构建。这与其他CI系统不同，其他系统更加注重分发并严格区分主构建服务器和从构建服务器。这既有利也有弊。一方面，它允许您在几分钟内设置一个完全工作的CI服务器。当然，Jenkins支持将工作推迟到构建从节点，因此在未来需要时可以进行扩展。另一方面，Jenkins通常性能不佳，因为它部署在单服务器设置中，其用户抱怨性能问题而未为其提供足够的资源。向Jenkins集群添加新的构建节点并不困难。对于那些习惯于单服务器设置的人来说，这似乎更多是一种心理挑战而不是技术问题。
- en: Buildbot
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Buildbot
- en: 'Buildbot ([http://buildbot.net/](http://buildbot.net/)) is a software written
    in Python that automates the compile and test cycles for any kind of software
    project. It is configurable in a way that every change made on a source code repository
    generates some builds and launches some tests and then provides some feedback:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Buildbot ([http://buildbot.net/](http://buildbot.net/))是一个用Python编写的软件，可以自动化任何类型的软件项目的编译和测试周期。它可以配置为对源代码存储库上的每个更改生成一些构建，启动一些测试，然后提供一些反馈：
- en: '![Buildbot](graphics/5295_08_10.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![Buildbot](graphics/5295_08_10.jpg)'
- en: Figure 10 Buildbot's Waterfall view for CPython 3.x branch
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图10 CPython 3.x分支的Buildbot瀑布视图
- en: This tool is used, for instance, by CPython core and can be seen at [http://buildbot.python.org/all/waterfall?&category=3.x.stable](http://buildbot.python.org/all/waterfall?&category=3.x.stable).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，CPython核心使用此工具，可以在[http://buildbot.python.org/all/waterfall?&category=3.x.stable](http://buildbot.python.org/all/waterfall?&category=3.x.stable)中找到。
- en: 'The default Buildbot''s representation of build results is a Waterfall view,
    as shown in *Figure 10*. Each column corresponds to a **build** composed of **steps**
    and is associated with some **build** **slaves**. The whole system is driven by
    the build master:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Buildbot的默认构建结果表示是一个瀑布视图，如*图10*所示。每一列对应一个**构建**，由**步骤**组成，并与一些**构建** **从机**相关联。整个系统由构建主机驱动：
- en: The build master centralizes and drives everything
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建主机集中和驱动一切
- en: A build is a sequence of steps used to build an application and run tests over
    it
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建是用于构建应用程序并对其运行测试的一系列步骤
- en: 'A **step** is an atomic command, for example:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**步骤**是一个原子命令，例如：
- en: Check out the files of a project
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检出项目的文件
- en: Build the application
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建应用程序
- en: Run tests
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行测试
- en: A build slave is a machine that is in charge of running a build. It can be located
    anywhere as long as it can reach the build master. Thanks to this architecture,
    Buildbot scales very well. All of heavy lifting is done on build slaves and you
    can have as many of them as you want.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 构建从机是负责运行构建的机器。只要它能够连接到构建主机，它可以位于任何位置。由于这种架构，Buildbot的扩展性非常好。所有繁重的工作都是在构建从机上完成的，你可以拥有任意数量的构建从机。
- en: Very simple and clear design makes Buildbot very flexible. Each build step is
    just a single command. Buildbot is written in Python but it is completely language
    agnostic. So the build step can be absolutely anything. The process exit code
    is used to decide if the step ended as a success and all standard output of the
    step command is captured by default. Most of the testing tools and compilers follow
    good design practices, and they indicate failures with proper exit codes and return
    readable error/warning messages on `sdout` or `stderr` output streams. If it's
    not true, you can usually easily wrap them with a Bash script. In most cases,
    this is a simple task. Thanks to this, a lot of projects can be integrated with
    Buildbot with only minimal effort.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Buildbot的设计非常简单和清晰，使其非常灵活。每个构建步骤只是一个单独的命令。Buildbot是用Python编写的，但它完全与语言无关。因此，构建步骤可以是任何东西。进程退出代码用于决定步骤是否以成功结束，步骤命令的所有标准输出默认情况下都会被捕获。大多数测试工具和编译器遵循良好的设计实践，并使用适当的退出代码指示失败，并在`stdout`或`stderr`输出流中返回可读的错误/警告消息。如果这不是真的，通常可以很容易地用Bash脚本包装它们。在大多数情况下，这是一个简单的任务。由于这个原因，许多项目可以只需很少的努力就可以与Buildbot集成。
- en: 'The next advantage of Buildbot is that it supports many version control systems
    out of the box without the need to install any additional plugins:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Buildbot的另一个优势是，它支持许多版本控制系统，无需安装任何额外的插件：
- en: CVS
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CVS
- en: Subversion
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Subversion
- en: Perforce
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Perforce
- en: Bzr
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bzr
- en: Darcs
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Darcs
- en: Git
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git
- en: Mercurial
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mercurial
- en: Monotone
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Monotone
- en: The main disadvantage of Buildbot is its lack of higher-level presentation tools
    for presenting build results. For instance, other projects, such as Jenkins, can
    take the notion of unit tests run during the build. If you feed them with test
    results data presented in the proper format (usually XML), they can present all
    the tests in a readable form like tables and graphs. Buildbot does not have such
    a built-in feature and this is the price it pays for its flexibility and simplicity.
    If you need some extra bells and whistles, you need to build them by yourself
    or search for some custom extension. On the other hand, thanks to such simplicity,
    it is easier to reason about Buildbot's behavior and maintain it. So, there is
    always a tradeoff.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Buildbot的主要缺点是缺乏用于呈现构建结果的高级呈现工具。例如，其他项目（如Jenkins）可以考虑在构建过程中运行的单元测试。如果你用适当的格式（通常是XML）呈现测试结果数据，它们可以以表格和图形的形式呈现所有测试。Buildbot没有这样的内置功能，这是它为了灵活性和简单性所付出的代价。如果你需要一些额外的功能，你需要自己构建它们或者寻找一些定制的扩展。另一方面，由于这种简单性，更容易推理Buildbot的行为并维护它。因此，总是有一个权衡。
- en: Travis CI
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Travis CI
- en: Travis CI ([https://travis-ci.org/](https://travis-ci.org/)) is a continuous
    integration system sold in Software as a Service form. It is a paid service for
    enterprises but can be used completely for free in open source projects hosted
    on GitHub.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Travis CI ([https://travis-ci.org/](https://travis-ci.org/))是一个以软件即服务形式出售的持续集成系统。对企业来说是付费服务，但在GitHub上托管的开源项目中可以完全免费使用。
- en: '![Travis CI](graphics/5295_08_11.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![Travis CI](graphics/5295_08_11.jpg)'
- en: Figure 11 Travis CI page for django-userena project showing failed builds in
    its build matrix
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图11 django-userena项目的Travis CI页面显示了构建矩阵中的失败构建
- en: Naturally, this is the free part of its pricing plan that made it very popular.
    Currently, it is one of the most popular CI solutions for projects hosted on GitHub.
    But the biggest advantage over older projects such as Buildbot or Jenkins, is
    how the build configuration is stored. All build definition is provided in a single
    `.travis.yml` file in the root of the project repository. Travis works only with
    GitHub, so if you have enabled such integration, your project will be tested on
    every commit if there is only a `.travis.yml` file.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是它定价计划中的免费部分，这使它非常受欢迎。目前，它是GitHub上托管的项目中最受欢迎的CI解决方案之一。但与Buildbot或Jenkins等旧项目相比，最大的优势在于构建配置的存储方式。所有构建定义都在项目存储库的根目录中的一个`.travis.yml`文件中提供。Travis只与GitHub一起工作，因此如果你启用了这样的集成，你的项目将在每次提交时进行测试，只要有一个`.travis.yml`文件。
- en: Having the whole CI configuration for a project in its code repository is really
    a great approach. This makes the whole process a lot clearer for the developers
    and also allows for more flexibility. In systems where build configuration must
    be provided to build a server separately (using web interface or through server
    configuration), there is always some additional friction when something new needs
    to be added to the testing rig. In some organizations, where only selected staff
    are authorized to maintain the CI system, this really slows the process of adding
    new build steps down. Also, sometimes there is a need to test different branches
    of the code with completely different procedures. When build configuration is
    available in project sources, it is a lot easier to do so.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的代码存储库中拥有整个CI配置确实是一个很好的方法。这使得整个过程对开发人员来说更加清晰，也允许更灵活性。在必须提供构建配置以单独构建服务器的系统中（使用Web界面或通过服务器配置），当需要向测试装置添加新内容时，总会有一些额外的摩擦。在一些只有选定员工被授权维护CI系统的组织中，这确实减慢了添加新构建步骤的过程。而且，有时需要使用完全不同的程序测试代码的不同分支。当构建配置在项目源代码中可用时，这样做就容易得多。
- en: The other great feature of Travis is the emphasis it puts on running builds
    in clean environments. Every build is executed in a completely fresh virtual machine,
    so there is no risk of some persisted state that would affect build results. Travis
    uses a rather big virtual machine image, so you have a lot of open source software
    and programming environments available without the need of additional installs.
    In this isolated environment, you have full administrative rights so you can download
    and install anything you need to perform your build and the syntax of the `.travis.yml`
    file makes it very easy. Unfortunately, you do not have a lot of choice over the
    operating system available as the base of your testing environment. Travis does
    not allow to provide your own virtual machine images, so you must rely on the
    very limited options provided. Usually there is no choice at all and all the builds
    must be done in some version of Ubuntu or Mac OS X (still experimental at the
    time of writing the book). Sometimes there is an option to select some legacy
    version of the system or the preview of the new testing environment, but such
    a possibility is always temporary. There is always a way to bypass this. You can
    run another virtual machine inside of the one provided by Travis. This should
    be something that allows you to easily encode VM configuration in your project
    sources such as Vagrant or Docker. But this will add more time to your builds,
    so it is not the best approach you will take. Stacking virtual machines that way
    may not be the best and most efficient approach if you need to perform tests under
    different operating systems. If this is an important feature for you, then this
    is a sign that Travis is not a service for you.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Travis的另一个重要特性是它强调在干净的环境中运行构建。每个构建都在一个完全新的虚拟机中执行，因此没有一些持久状态会影响构建结果的风险。Travis使用一个相当大的虚拟机镜像，因此您可以使用许多开源软件和编程环境，而无需额外安装。在这个隔离的环境中，您拥有完全的管理权限，因此可以下载和安装任何您需要执行构建的东西，而`.travis.yml`文件的语法使其非常容易。不幸的是，您对可用的操作系统没有太多选择。Travis不允许提供自己的虚拟机镜像，因此您必须依赖提供的非常有限的选项。通常根本没有选择，所有构建都必须在某个版本的Ubuntu或Mac
    OS X中进行（在撰写本书时仍处于实验阶段）。有时可以选择系统的某个旧版本或新测试环境的预览，但这种可能性总是暂时的。总是有办法绕过这一点。您可以在Travis提供的虚拟机内运行另一个虚拟机。这应该是一些允许您在项目源代码中轻松编码虚拟机配置的东西，比如Vagrant或Docker。但这将增加构建的时间，因此这不是您将采取的最佳方法。以这种方式堆叠虚拟机可能不是在不同操作系统下执行测试的最佳和最有效的方法。如果这对您很重要，那么这表明Travis不适合您。
- en: The biggest downside of Travis is that it is completely locked to GitHub. If
    you would like to use it in your open source project, then this is not a big deal.
    For enterprises and closed source projects, this is mostly an unsolvable issue.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Travis最大的缺点是它完全锁定在GitHub上。如果您想在开源项目中使用它，那么这不是什么大问题。对于企业和闭源项目，这基本上是一个无法解决的问题。
- en: GitLab CI
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GitLab CI
- en: GitLab CI is a part of a larger GitLab project. It is available as both a paid
    service (Enterprise Edition) and an open source project that you may host on your
    own infrastructure (Community Edition). The open source edition lacks some of
    the paid service features, but in most cases is everything that any company needs
    from the software that manages version control repositories and continuous integration.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab CI是GitLab项目的一部分。它既可以作为付费服务（企业版）提供，也可以作为您自己基础设施上托管的开源项目（社区版）提供。开源版本缺少一些付费服务功能，但在大多数情况下，它是任何公司从管理版本控制存储库和持续集成的软件中所需要的一切。
- en: GitLab CI is very similar in feature sets to the Travis. It is even configured
    with a very similar YAML syntax stored in the `.gitlab-ci.yml` file. The biggest
    difference is that the GitLab Enterprise Edition pricing model does not provide
    you with free accounts for open source projects. The Community Edition is open
    source by itself but you need to have some own infrastructure in order to run
    it.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab CI在功能集方面与Travis非常相似。它甚至使用存储在`.gitlab-ci.yml`文件中的非常相似的YAML语法进行配置。最大的区别在于，GitLab企业版定价模型不为开源项目提供免费帐户。社区版本身是开源的，但您需要拥有一些自己的基础设施才能运行它。
- en: When compared with Travis, the GitLab has an obvious advantage of having more
    control over the execution environment. Unfortunately, in the area of environment
    isolation, the default build runner in GitLab is a bit inferior. The process called
    Gitlab Runner executes all the build steps in the same environment it is run in,
    so it works more like Jenkins' or Buildbot's slave servers. Fortunately, it plays
    well with Docker, so you can easily add more isolation with container-based virtualization,
    but this will require some effort and additional setup. In Travis, you get full
    isolation out of the box.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 与Travis相比，GitLab在执行环境上具有明显的优势。不幸的是，在环境隔离方面，GitLab的默认构建运行程序略逊一筹。名为Gitlab Runner的进程在相同的环境中执行所有构建步骤，因此它更像Jenkins或Buildbot的从属服务器。幸运的是，它与Docker兼容，因此你可以通过基于容器的虚拟化轻松添加更多隔离，但这需要一些努力和额外的设置。在Travis中，你可以立即获得完全隔离。
- en: Choosing the right tool and common pitfalls
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择合适的工具和常见陷阱
- en: As already said, there is no perfect CI tool that will suit every project and,
    most importantly, every organization and workflow it uses. I can give only a single
    suggestion for open source projects hosted on GitHub. For small code bases with
    platform independent code, **Travis CI** seems like the best choice. It is easy
    to start with and will give you almost instant gratification with a minimal amount
    of work.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面所说，没有完美的CI工具适用于每个项目，更重要的是，适用于每个组织和使用的工作流。我只能为托管在GitHub上的开源项目提供一个建议。对于平台无关代码的小型代码库，Travis
    CI似乎是最佳选择。它易于开始，并且几乎可以立即获得最小量的工作的满足感。
- en: For projects with closed sources, the situation is completely different. It
    is possible that you will need to evaluate a few CI systems in various setups
    until you are able decide which one is best for you. We discussed only four of
    the popular tools but it should be a rather representative group. To make your
    decision a bit easier, we will discuss some of the common problems related to
    continuous integration systems. In some of the available CI systems, it is more
    possible to make certain kinds of mistakes than in others. On the other hand,
    some of the problems may not be important to every application. I hope that by
    combining the knowledge of your needs with this short summary, it will be easier
    to make your first decision the right one.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 对于闭源项目来说，情况完全不同。可能需要在不同的设置中评估几个CI系统，直到能够决定哪一个最适合你。我们只讨论了四种流行的工具，但这应该是一个相当代表性的群体。为了让你的决定变得更容易一些，我们将讨论一些与持续集成系统相关的常见问题。在一些可用的CI系统中，可能会比其他系统更容易犯某些类型的错误。另一方面，一些问题可能对每个应用程序都不重要。我希望通过结合你的需求的知识和这个简短的总结，能够更容易地做出正确的第一个决定。
- en: Problem 1 – too complex build strategies
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题1 - 构建策略太复杂
- en: 'Some organizations like to formalize and structure things beyond the reasonable
    levels. In companies that create computer software, this is especially true in
    two areas: project management tools and build strategies on CI servers.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一些组织喜欢在合理的水平之外正式化和结构化事物。在创建计算机软件的公司中，这在两个领域尤其真实：项目管理工具和CI服务器上的构建策略。
- en: 'Excessive configuration of project management tools usually ends with issue
    processing workflows on JIRA (or any other management software) so complicated
    that they will never fit a single wall when expressed as graphs. If your manager
    has such configuration/control mania, you can either talk to him or switch him
    for another manager (read: quit your current job). Unfortunately, this does not
    reliably ensure any improvement in that matter.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 过度配置项目管理工具通常会导致在JIRA（或任何其他管理软件）上处理问题工作流程变得如此复杂，以至于无法用图表表示。如果你的经理有这种配置/控制狂，你可以和他谈谈，或者换一个经理（即：辞职）。不幸的是，这并不能可靠地保证在这方面有任何改进。
- en: 'But when it comes to CI, we can do more. Continuous integration tools are usually
    maintained and configured by us: developers. These are OUR tools that are supposed
    to improve OUR work. If someone has irresistible temptation to toggle every switch
    and turn every knob possible, then he should be kept away from configuration of
    CI systems, especially if his main job is to talk the whole day and make decisions.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当涉及到CI时，我们可以做更多。持续集成工具通常由我们开发人员维护和配置。这些是我们的工具，应该改善我们的工作。如果有人对每个开关和旋钮都有无法抗拒的诱惑，那么他应该远离CI系统的配置，尤其是如果他的主要工作是整天说话和做决定。
- en: There is really no need for making complex strategies to decide which commit
    or branch should be tested. No need to limit testing to specific tags. No need
    to queue commits in order to perform larger builds. No need to disable building
    via custom commit messages. Your continuous integration process should be simple
    to reason about. Test everything! Test always! That's all! If there are not enough
    hardware resources to test every commit, then add more hardware. Remember that
    the programmer's time is more expensive than silicon chips.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要制定复杂的策略来决定哪个提交或分支应该被测试。也不需要将测试限制在特定的标签上。也不需要排队提交以执行更大的构建。也不需要通过自定义提交消息禁用构建。你的持续集成过程应该简单易懂。测试一切！一直测试！就这样！如果没有足够的硬件资源来测试每个提交，那就增加更多的硬件。记住，程序员的时间比硅片更贵。
- en: Problem 2 – too long building time
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题2 - 构建时间太长
- en: Long building times is a thing that kills performance of any developer. If you
    need to wait hours to know if your work was done properly, then there is no way
    you can be productive. Of course, having something else to do when your feature
    is being tested helps a lot. Anyway, as humans, we are really terrible at multitasking.
    Switching between different problems takes time and, in the end, reduces our programming
    performance to zero. It's simply hard to keep focus when working on multiple problems
    at once.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 长时间的构建是任何开发人员的性能杀手。如果你需要等待几个小时才能知道你的工作是否做得正确，那么你就无法高效地工作。当然，在测试功能时有其他事情要做会有所帮助。无论如何，作为人类，我们真的很擅长多任务处理。在不同问题之间切换需要时间，并且最终会将我们的编程性能降至零。在同时处理多个问题时，保持专注是非常困难的。
- en: 'The solution is very simple: keep your builds fast at any price. At first,
    try to find bottlenecks and optimize them. If the performance of build servers
    is the problem, then try to scale out. If this does not help, then split each
    build into smaller parts and parallelize.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案非常简单：不惜一切代价保持构建速度快。首先，尝试找到瓶颈并对其进行优化。如果构建服务器的性能是问题，那么尝试扩展。如果这没有帮助，那么将每个构建拆分成较小的部分并并行化。
- en: There are plenty of solutions to speed up slow build tests, but sometimes nothing
    can be done about that problem. For instance, if you have automated browser tests
    or need to perform long running calls to external services, then it is very hard
    to improve performance beyond some hard limit. For instance, when speed of automated
    acceptance test in your CI becomes a problem, then you can loosen the *test everything,
    test always* rule a bit. What matters the most for programmers are usually unit
    tests and static analysis. So, depending on your workflow, the slow browser tests
    may be sometimes deferred in time to the moment when release is being prepared.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多解决方案可以加快缓慢的构建测试，但有时候这个问题无法解决。例如，如果你有自动化的浏览器测试或需要对外部服务进行长时间调用，那么很难在某个硬性限制之外提高性能。例如，当你的CI中自动接受测试的速度成为问题时，你可以放松*测试一切，始终测试*的规则。对程序员来说，最重要的通常是单元测试和静态分析。因此，根据你的工作流程，缓慢的浏览器测试有时可以推迟到准备发布时。
- en: The other solution to slow build runs is rethinking the overall architecture
    design of your application. If testing the application takes a lot of time, it
    is very often a sign that it should be split into a few independent components
    that can be developed and tested separately. Writing software as huge monoliths
    is one of the shortest paths to failure. Usually any software engineering process
    breaks on software that is not modularized properly.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 解决缓慢构建运行的另一个方法是重新思考应用程序的整体架构设计。如果测试应用程序需要很长时间，很多时候这是一个信号，表明它应该被拆分成几个可以独立开发和测试的组件。将软件编写为庞大的单体是通往失败的最短路径之一。通常，任何软件工程过程都会因为软件没有适当模块化而失败。
- en: Problem 3 – external job definitions
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题3 - 外部作业定义
- en: Some continuous integration systems, especially Jenkins, allow you to set up
    most of the build configurations and testing processes completely through web
    UI, without the need to touch the code repository. But you should really avoid
    putting anything more than simple entry points to the build steps/commands into
    externals systems. This is the kind of CI anti-pattern that can cause nothing
    more than troubles.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一些持续集成系统，特别是Jenkins，允许你完全通过Web UI设置大部分构建配置和测试过程，而无需触及代码存储库。但你真的应该避免将除构建步骤/命令的简单入口之外的任何东西放入外部系统。这是一种可能会带来麻烦的CI反模式。
- en: Your building and testing process is usually tightly tied to your codebase.
    If you store its whole definition in external system such as Jenkins or Buildbot,
    then it will be really hard to introduce changes to that process.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你的构建和测试过程通常与你的代码库紧密相关。如果你将其整个定义存储在Jenkins或Buildbot等外部系统中，那么要对该过程进行更改将非常困难。
- en: 'As an example of a problem introduced by global external build definition,
    let''s assume that we have some open source project. The initial development was
    hectic and we did not care for any style guidelines. Our project was successful,
    so the development required another major release. After some time, we moved from
    `0.x` version to `1.0` and decided to reformat all of your code to conform to
    PEP 8 guidelines. It is a good approach to have a static analysis check as part
    of CI builds, so we decided to add the execution of the `pep8` tool to our build
    definition. If we had only a global external build configuration, then there would
    be a problem if some improvement needs to be done to the code in older versions.
    Let''s say that there is a critical security issue that needs to be fixed in both
    branches of the application: `0.x` and `1.y`. We know that anything below version
    1.0 wasn''t compliant with the style guide and the newly introduced check against
    PEP 8 will mark the build as failed.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 举一个由全局外部构建定义引入的问题的例子，假设我们有一些开源项目。最初的开发很忙碌，我们并不关心任何样式指南。我们的项目很成功，所以开发需要另一个重大发布。过了一段时间，我们从`0.x`版本移动到`1.0`，并决定重新格式化所有代码以符合PEP
    8指南。将静态分析检查作为CI构建的一部分是一个很好的方法，所以我们决定将`pep8`工具的执行添加到我们的构建定义中。如果我们只有一个全局外部构建配置，那么如果需要对旧版本的代码进行改进，就会出现问题。假设应用程序的两个分支：`0.x`和`1.y`都需要修复一个关键的安全问题。我们知道1.0版本以下的任何内容都不符合样式指南，而新引入的针对PEP
    8的检查将标记构建为失败。
- en: 'The solution to the problem is to keep the definition of your build process
    as close to the source as possible. With some CI systems (Travis CI and GitLab
    CI), you get that workflow by default. With other solutions (Jenkins and Buildbot)
    you need to take additional care in order to ensure that most of the build processes
    are included in your code instead of some external tool configuration. Fortunately,
    you have a lot of choices that allow that kind of automation:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 解决问题的方法是尽可能将构建过程的定义与源代码保持接近。对于一些 CI 系统（如 Travis CI 和 GitLab CI），您默认就可以得到这样的工作流程。对于其他解决方案（如
    Jenkins 和 Buildbot），您需要额外小心，以确保大部分构建过程都包含在您的代码中，而不是一些外部工具配置中。幸运的是，您有很多选择可以实现这种自动化。
- en: Bash scripts
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bash 脚本
- en: Makefiles
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Makefiles
- en: Python code
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 代码
- en: Problem 4 – lack of isolation
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题4 - 缺乏隔离
- en: We have discussed the importance of isolation when programming in Python many
    times already. We know that the best approach to isolate Python execution environment
    on the package level is to use virtual environments with `virtualenv` or `python
    -m venv`. Unfortunately, when testing code for the purpose of continuous integration
    processes, it is usually not enough. The testing environment should be as close
    as possible to the production environment and it is really hard to achieve that
    without additional system-level virtualization.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次讨论了在 Python 编程时隔离的重要性。我们知道在包级别上隔离 Python 执行环境的最佳方法是使用 `virtualenv` 或 `python
    -m venv`。不幸的是，在测试代码以进行持续集成流程的目的时，通常还不够。测试环境应尽可能接近生产环境，而要在没有额外的系统级虚拟化的情况下实现这一点确实很困难。
- en: 'The main issues you may experience when not ensuring proper system-level isolation
    when building your application are:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建应用程序时，如果不确保适当的系统级隔离，可能会遇到的主要问题有：
- en: Some state persisted between builds either on the filesystem or in backing services
    (caches, databases, and so on)
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建之间持久存在的一些状态，无论是在文件系统上还是在后备服务中（缓存、数据库等）
- en: Multiple builds or tests interfacing with each other through the environment,
    filesystem or backing services
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过环境、文件系统或后备服务进行多个构建或测试的接口
- en: Problems that would occur due to specific characteristics of the production
    operating system not caught on the build server
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于生产操作系统的特定特性而可能发生的问题没有在构建服务器上被捕捉到
- en: The preceding issues are particularly troublesome if you need to perform concurrent
    builds of the same application or even parallelize single builds.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要对同一应用程序执行并发构建，甚至并行化单个构建，上述问题尤为棘手。
- en: Some Python frameworks (mostly Django) provide some additional level of isolation
    for databases that try to ensure the storage will be cleaned before running tests.
    There is also quite a useful extension for `py.test` called `pytest-dbfixtures`
    (refer to [https://github.com/ClearcodeHQ/pytest-dbfixtures](https://github.com/ClearcodeHQ/pytest-dbfixtures))
    that allows you to achieve that even more reliably. Anyway, such solutions add
    even more complexity to your builds instead of reducing it. Always clearing the
    virtual machine on every build (in the style of Travis CI) seems like a more elegant
    and simpler approach.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Python 框架（主要是 Django）为数据库提供了一些额外的隔离级别，试图确保在运行测试之前存储将被清理。`py.test` 还有一个非常有用的扩展叫做
    `pytest-dbfixtures`（参见 [https://github.com/ClearcodeHQ/pytest-dbfixtures](https://github.com/ClearcodeHQ/pytest-dbfixtures)），它甚至可以更可靠地实现这一点。无论如何，这样的解决方案会增加构建的复杂性，而不是减少它。始终在每次构建时清除虚拟机（类似于
    Travis CI 的风格）似乎是一种更优雅、更简单的方法。
- en: Summary
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'We have learned the following things in this chapter:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中学到了以下内容：
- en: What is the difference between centralized and distributed version control systems
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集中式和分布式版本控制系统之间有什么区别
- en: Why you should prefer distributed version control systems over centralized
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么您应该更喜欢分布式版本控制系统而不是集中式
- en: Why Git should be your first choice for DVCS
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么 Git 应该是您选择分布式版本控制系统的首选
- en: What are the common workflows and branching strategies for Git
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git 的常见工作流程和分支策略是什么
- en: What is continuous integration/delivery/deployment and what are the popular
    tools that allow you to implement these processes
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是持续集成/交付/部署，以及允许您实施这些流程的流行工具是什么
- en: The next chapter will explain how to clearly document your code.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将解释如何清晰地记录您的代码。
