- en: Developing RESTful APIs and Microservices with Flask 1.0.2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Flask 1.0.2 开发 RESTful API 和微服务
- en: In this chapter, we will start our journey toward RESTful Web APIs with Python
    3.7 and four different web frameworks. Python is one of the most popular and versatile
    programming languages. There are thousands of Python packages, and these allow
    you to extend Python capabilities to any kind of domain you can imagine, such
    as web development, **Internet of Things** (**IoT**), artificial intelligence,
    machine learning, and scientific computing. We can work with many different web
    frameworks and packages to easily build simple and complex RESTful Web APIs with
    Python, and we can combine these frameworks with other Python packages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 Python 3.7 和四个不同的网络框架开始我们的 RESTful Web API 之旅。Python 是最受欢迎和最通用的编程语言之一。有成千上万的
    Python 包，这些包允许你将 Python 的能力扩展到任何你能想象到的领域，例如网络开发、**物联网**（**IoT**）、人工智能、机器学习和科学计算。我们可以使用许多不同的网络框架和包，用
    Python 轻松构建简单和复杂的 RESTful Web API，并且我们可以将这些框架与其他 Python 包结合起来。
- en: We can leverage our existing knowledge of Python and all of its ...
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用我们对 Python 及其所有 ... 的现有知识。
- en: Designing a RESTful API to interact with a simple data source
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计一个与简单数据源交互的 RESTful API
- en: Imagine that we have to configure the notification messages to be displayed
    in an **OLED** (short for **Organic Light Emitting Diode**) display wired to an
    IoT device. The IoT device is capable of running Python 3.7.1, Flask 1.0.2, and
    other Python packages. There is a team writing code that retrieves string messages
    that represent notifications from a dictionary and displays them in the OLED display
    wired to the IoT device. We have to start working on a mobile app and a website
    that has to interact with a RESTful API to perform CRUD operations with string
    messages that represent notifications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们必须配置要在连接到物联网设备的 **OLED**（有机发光二极管）显示器上显示的通知消息。该物联网设备能够运行 Python 3.7.1、Flask
    1.0.2 和其他 Python 包。有一个团队正在编写代码，从字典中检索表示通知的字符串消息，并在连接到物联网设备的 OLED 显示器上显示它们。我们必须开始开发一个移动应用和网站，它们必须与
    RESTful API 交互，以执行表示通知的字符串消息的 CRUD 操作。
- en: We don't need an **ORM** (short for **Object-Relational Mapping**) because we
    won't persist the notifications on a database. We will just work with an in-memory
    dictionary as our data source. It is one of the requirements we have for this
    RESTful API. In this case, the RESTful Web Service will be running on the IoT
    device; that is, we will run the Flask development service on the IoT device.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要 **ORM**（对象关系映射的缩写），因为我们不会在数据库中持久化通知。我们只需使用内存字典作为我们的数据源。这是我们对该 RESTful
    API 的一项要求。在这种情况下，RESTful 网络服务将在物联网设备上运行；也就是说，我们将在物联网设备上运行 Flask 开发服务。
- en: We will definitely lose scalability for our RESTful API because we have the
    in-memory data source in the service, and therefore we cannot run the RESTful
    API in another IoT device. However, we will work with another example that is
    related to a more complex data source that will be able to scale in the RESTful
    way later. The first example is going to allow us to understand how Flask and
    Flask-RESTful work together with a very simple in-memory data source.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在服务中有一个内存中的数据源，因此我们将失去我们的 RESTful API 的可伸缩性。然而，我们将与另一个相关联的例子一起工作，该例子涉及更复杂的数据源，稍后将以
    RESTful 方式进行扩展。第一个例子将使我们能够了解 Flask 和 Flask-RESTful 如何与一个非常简单的内存数据源一起工作。
- en: We have chosen Flask because it is an extremely lightweight framework, we don't
    need to configure an ORM, and we want to start running the RESTful API on the
    IoT device as soon as possible to allow all the teams to interact with it. We
    consider that there will be a website that will be coded with Flask too, and therefore,
    we want to use the same web micro-framework to power the website and the RESTful
    Web Service. In addition, Flask is an appropriate choice to create a microservice
    that can run our RESTful API on the cloud.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择 Flask 是因为它是一个非常轻量级的框架，我们不需要配置 ORM，并且我们希望尽快在物联网设备上运行 RESTful API，以便所有团队都能与之交互。我们认为还将有一个用
    Flask 编码的网站，因此，我们希望使用相同的网络微框架来驱动网站和 RESTful 网络服务。此外，Flask 是创建一个可以在云上运行我们的 RESTful
    API 的微服务的合适选择。
- en: There are many extensions available for Flask that make it easier to perform
    specific tasks with the Flask micro-framework. We will take advantage of Flask-RESTful,
    an extension that will allow us to encourage best practices while building our
    RESTful API. In this case, we will work with a Python dictionary as the data source.
    As previously explained, we will work with more complex data sources in forthcoming
    examples.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 可用于 Flask 的扩展有很多，这些扩展使得使用 Flask 微型框架执行特定任务变得更加容易。我们将利用 Flask-RESTful 扩展，这个扩展将允许我们在构建
    RESTful API 的同时鼓励最佳实践。在这种情况下，我们将使用 Python 字典作为数据源。正如之前所解释的，在未来的示例中，我们将使用更复杂的数据源。
- en: 'First, we must specify the requirements for our main resource—a notification.
    We need the following attributes or fields for a notification:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须指定我们主要资源——通知的要求。对于通知，我们需要以下属性或字段：
- en: An integer identifier.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个整数标识符。
- en: A string message.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个字符串消息。
- en: A **TTL** (short for **Time to Live**), that is, a duration in seconds that
    will indicate the time the notification message has to be displayed on the OLED
    display.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 **TTL**（即 **生存时间**），表示通知消息在 OLED 显示上显示的时间长度（以秒为单位）。
- en: A creation date and time. The timestamp will be added automatically when adding
    a new notification to the collection.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建日期和时间。当将新通知添加到集合时，时间戳将自动添加。
- en: A notification category description, such as *Warning* or *Information*.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个通知类别描述，例如 *警告* 或 *信息*。
- en: An integer counter that indicates the times when the notification message has
    been displayed on the OLED display.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个整数计数器，表示通知消息在 OLED 显示上显示的次数。
- en: A Boolean value that indicates whether the notification message was displayed
    at least once on the OLED display.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个布尔值，表示通知消息是否至少在 OLED 显示上显示过一次。
- en: 'The following table shows the HTTP verbs, the scope, and the semantics for
    the methods that our first version of the API must support. Each method is composed
    of an HTTP verb and a scope, and all the methods have a well-defined meaning for
    all notifications and collections. In our API, each notification has its own unique
    URL:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了我们的 API 第一版必须支持的 HTTP 动词、作用域和语义。每个方法由一个 HTTP 动词和一个作用域组成，并且所有方法对所有通知和集合都有一个明确定义的意义。在我们的
    API 中，每个通知都有自己的唯一 URL：
- en: '| HTTP verb | Scope | Semantics |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| HTTP 动词 | 作用域 | 语义 |'
- en: '| `GET` | Collection of notifications | Retrieve all the stored notifications
    in the collection. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 通知集合 | 获取集合中存储的所有通知。|'
- en: '| `GET` | Notification | Retrieve a single notification. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 通知 | 获取单个通知。|'
- en: '| `POST` | Collection of notifications | Create a new notification in the collection.
    |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 通知集合 | 在集合中创建一个新的通知。|'
- en: '| `PATCH` | Notification | Update one or more fields for an existing notification.
    |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | 通知 | 更新现有通知的一个或多个字段。|'
- en: '| `DELETE` | Notification | Delete an existing notification. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 通知 | 删除现有的通知。|'
- en: Understanding the tasks performed by each HTTP method
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解每个 HTTP 方法执行的任务
- en: Let's consider that `http://localhost:5000/service/notifications/` is the URL
    for the collection of notifications. If we add a number to the previous URL, we
    identify a specific notification whose ID is equal to the specified numeric value.
    For example, `http://localhost:5000/service/notifications/5` identifies the notification
    whose ID is equal to `5`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑 `http://localhost:5000/service/notifications/` 是通知集合的 URL。如果我们向之前的 URL
    添加一个数字，我们就可以识别一个特定的通知，其 ID 等于指定的数值。例如，`http://localhost:5000/service/notifications/5`
    识别 ID 等于 `5` 的通知。
- en: We want our API to differentiate collections from a single resource of the collection
    in the URLs. When we refer to a collection, we will use a slash (`/`) as the last
    character for the URL, as in `http://localhost:5000/service/notifications/`. When
    we refer to a single resource of the collection, we won't use a slash (`/`) as
    the last character for ...
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的 API 能够在 URL 中区分集合和集合的单个资源。当我们提到集合时，我们将使用斜杠（`/`）作为 URL 的最后一个字符，例如 `http://localhost:5000/service/notifications/`。当我们提到集合的单个资源时，我们不会使用斜杠（`/`）作为
    URL 的最后一个字符 ...
- en: Understanding microservices
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解微服务
- en: In the last few years, many large and complex applications started shifting
    from a monolithic architecture to a microservices architecture. Instead of working
    with large and extremely complex web services, the microservices architecture
    proposes developing a collection of smaller, loosely-coupled services to implement
    all the features required by complex applications in a way that enables and simplifies
    continuous delivery.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，许多大型且复杂的应用程序开始从单体架构转向微服务架构。微服务架构建议开发一系列较小、松散耦合的服务，以实现复杂应用程序所需的所有功能，这种方式既支持又简化了持续交付，而不是与大型且极其复杂的Web服务一起工作。
- en: RESTful APIs are essential pieces of the microservices architecture, and Python
    is extremely popular when shifting to this architecture. Each microservice can
    encapsulate a RESTful API that fulfills a specific and limited purpose. The microservice
    is self-contained, it is easy to maintain, and it helps to support continuous
    delivery.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API是微服务架构的必要组成部分，Python在转向这种架构时非常流行。每个微服务可以封装一个RESTful API，以实现特定的和有限的目的。微服务是自包含的，易于维护，并有助于支持持续交付。
- en: As happens with any architecture, there are several ways to implement the microservices
    architecture. We will learn to encapsulate a RESTful API developed with Flask
    and Python into a microservice. This way, we will be able to leverage our skills
    by developing RESTful APIs and using them as the essential pieces to build self-contained
    and easy-to-maintain microservices.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何架构一样，实现微服务架构有几种方法。我们将学习如何将使用Flask和Python开发的RESTful API封装到微服务中。这样，我们将能够通过开发RESTful
    API并使用它们作为构建自包含且易于维护的微服务的必要组件来利用我们的技能。
- en: Working with lightweight virtual environments
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用轻量级虚拟环境
- en: Throughout this book, we will be working with different frameworks, packages,
    and libraries to create RESTful Web APIs and microservices, and therefore, it
    is convenient to work with Python virtual environments to isolate each development
    environment. Python 3.3 introduced lightweight virtual environments and they were
    improved in subsequent Python versions. We will work with these virtual environments
    and, therefore, you will need Python 3.7.1 or higher. You can read more about
    the PEP 405 Python virtual environment, which introduced the `venv` module, at
    [https://www.python.org/dev/peps/pep-0405](https://www.python.org/dev/peps/pep-0405).
    All the examples for this book were tested on Python 3.7.1 on Linux, macOS, and
    Windows.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将使用不同的框架、包和库来创建RESTful Web API和微服务，因此，使用Python虚拟环境来隔离每个开发环境是方便的。Python
    3.3引入了轻量级虚拟环境，并在后续的Python版本中得到了改进。我们将使用这些虚拟环境，因此，你需要Python 3.7.1或更高版本。你可以在[https://www.python.org/dev/peps/pep-0405](https://www.python.org/dev/peps/pep-0405)上阅读更多关于PEP
    405 Python虚拟环境的介绍，它引入了`venv`模块。本书的所有示例都在Linux、macOS和Windows上的Python 3.7.1上进行了测试。
- en: In case you ...
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您...
- en: Setting up a virtual environment with Flask and Flask-RESTful
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Flask和Flask-RESTful设置虚拟环境
- en: We have followed the necessary steps to create and activate a virtual environment.
    Now, we will create a `requirements.txt` file to specify the set of packages that
    our application requires to be installed in any supported platform. This way,
    it will be extremely easy to repeat the installation of the specified packages
    with their versions in any new virtual environment.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经遵循了创建和激活虚拟环境的必要步骤。现在，我们将创建一个`requirements.txt`文件来指定我们的应用程序在任何支持平台上需要安装的包集合。这样，在任意新的虚拟环境中重复安装指定包及其版本将变得极其容易。
- en: 'Use your favorite editor to create a new text file, named `requirements.txt`,
    within the root folder of the recently created virtual environment. The following
    lines show the content of the file that declares the packages and the versions
    that our API requires. The code file for the sample is included in the `restful_python_2_01_01`
    folder, in the `Flask01/requirements.txt` file:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您喜欢的编辑器在最近创建的虚拟环境的根目录下创建一个名为`requirements.txt`的新文本文件。以下行显示了声明我们的API所需的包及其版本的文件内容。示例的代码文件包含在`restful_python_2_01_01`文件夹中的`Flask01/requirements.txt`文件中：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Each line in the `requirements.txt` file indicates the package and the version
    that needs to be installed. In this case, we are working with exact versions by
    using the `==` operator because we want to make sure that the specified version
    is installed. The following table summarizes the packages and the version numbers
    that we specified as requirements:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`requirements.txt` 文件中的每一行都指示需要安装的包和版本。在这种情况下，我们通过使用 `==` 操作符使用精确版本，因为我们想确保安装了指定的版本。以下表格总结了我们所指定的作为要求的包和版本号：'
- en: '| Package name | Version to be installed |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 包名 | 要安装的版本 |'
- en: '| `Flask` | 1.0.2 |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `Flask` | 1.0.2 |'
- en: '| `flask-restful` | 0.3.6 |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `flask-restful` | 0.3.6 |'
- en: '| `httpie` | 1.0.0 |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `httpie` | 1.0.0 |'
- en: 'Now, we must run the following command on macOS, Linux, or Windows to install
    the packages and the versions explained in the previous table with `pip` by using
    the recently created `requirements.txt` file. Notice that Flask is a dependency
    for Flask-RESTful. Make sure you are located in the folder that has the `requirements.txt`
    file before running the following command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须在 macOS、Linux 或 Windows 上运行以下命令，使用 `pip` 通过最近创建的 `requirements.txt` 文件安装上一表格中解释的包和版本。请注意，Flask
    是 Flask-RESTful 的依赖项。在运行以下命令之前，请确保您位于包含 `requirements.txt` 文件的文件夹中：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The last lines for the output will indicate all the packages that have been
    successfully installed, including `Flask`, `flask-restful`, and `httpie`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示所有成功安装的包，包括 `Flask`、`flask-restful` 和 `httpie`：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Declaring status codes for the responses with an enumerable
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可枚举的声明响应的状态码
- en: Neither Flask nor Flask-RESTful includes the declaration of variables for the
    different HTTP status codes. We don't want to return numbers as status codes.
    We want our code to be easy to read and understand, and therefore, we will use
    descriptive HTTP status codes. Specifically, we will take advantage of the support
    for enumerations added in Python 3.4 to declare a class that defines unique sets
    of names and values that represent the different HTTP status codes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 和 Flask-RESTful 都不包括不同 HTTP 状态码的变量声明。我们不希望返回数字作为状态码。我们希望我们的代码易于阅读和理解，因此我们将使用描述性的
    HTTP 状态码。具体来说，我们将利用 Python 3.4 中添加的对枚举的支持来声明一个类，该类定义了代表不同 HTTP 状态码的唯一名称和值集合。
- en: First, create a `service` folder within the root folder for the recently created
    virtual environment. Create a new `http_status.py` file within the `service` folder.
    The following lines show the code that declares the `HttpStatus ...`
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在最近创建的虚拟环境的根文件夹内创建一个 `service` 文件夹。在 `service` 文件夹内创建一个新的 `http_status.py`
    文件。以下行显示了声明 `HttpStatus ...` 的代码。
- en: Creating the model
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模型
- en: 'Now, we will create a simple `NotificationModel` class that we will use to
    represent notifications. Remember that we won''t be persisting the model in any
    database or file, and therefore, in this case, our class will just provide the
    required attributes and no mapping information. Create a new `models.py` file
    in the `service` folder. The following lines show the code that creates a `NotificationModel`
    class in the `service/models.py` file. The code file for the sample is included
    in the `restful_python_2_01_01` folder, in the `Flask01/service/models.py` file:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个简单的 `NotificationModel` 类，我们将使用它来表示通知。请记住，我们不会在数据库或文件中持久化模型，因此在这种情况下，我们的类将仅提供所需的属性，而不提供映射信息。在
    `service` 文件夹中创建一个新的 `models.py` 文件。以下行显示了在 `service/models.py` 文件中创建 `NotificationModel`
    类的代码。示例代码文件包含在 `restful_python_2_01_01` 文件夹中，位于 `Flask01/service/models.py` 文件中：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `NotificationModel` class just declares a constructor, that is, the `__init__`
    method. This method receives many arguments and uses them to initialize the attributes
    with the same names: `message`, `ttl`, `creation_date`, and `notification_category`.
    The `id` attribute is set to `0`, `displayed_times` is set to `0`, and `displayed_once`
    is set to `False`. We will automatically increment the identifier for each new
    notification generated with API calls.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`NotificationModel` 类仅声明了一个构造函数，即 `__init__` 方法。此方法接收许多参数，并使用它们来初始化具有相同名称的属性：`message`、`ttl`、`creation_date`
    和 `notification_category`。`id` 属性设置为 `0`，`displayed_times` 设置为 `0`，`displayed_once`
    设置为 `False`。我们将自动通过 API 调用为每个新生成的通知递增标识符。'
- en: Using a dictionary as a repository
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用字典作为存储库
- en: 'Now, we will create a `NotificationManager` class that we will use to persist
    the `NotificationModel` instances in an in-memory dictionary. Our API methods
    will call methods for the `NotificationManager` class to retrieve, insert, update,
    and delete `NotificationModel` instances. Create a new `service.py` file in the
    `service` folder. The following lines show the code that creates a `NotificationManager`
    class in the `service/service.py` file. In addition, the following lines declare
    all the `imports` we will need for all the code we will write in this file. The
    code file for the sample is included in the `restful_python_2_01_01` folder, in
    the `Flask01/service/service.py` file:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个`NotificationManager`类，我们将使用它来在内存字典中持久化`NotificationModel`实例。我们的API方法将调用`NotificationManager`类的相关方法来检索、插入、更新和删除`NotificationModel`实例。在`service`文件夹中创建一个新的`service.py`文件。以下行显示了在`service/service.py`文件中创建`NotificationManager`类的代码。此外，以下行声明了我们将需要用于此文件中所有代码的所有`导入`。示例代码文件包含在`restful_python_2_01_01`文件夹中，位于`Flask01/service/service.py`文件：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Configuring output fields
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置输出字段
- en: 'Now, we will create a `notification_fields` dictionary that we will use to
    control the data that we want Flask-RESTful to render in our responses when we
    return `NotificationModel` instances. Open the `service/service.py` file created
    previously and add the following lines to the existing code. The code file for
    the sample is included in the `restful_python_2_01_01` folder, in the `Flask01/service/service.py`
    file:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个`notification_fields`字典，我们将使用它来控制我们想要Flask-RESTful在返回`NotificationModel`实例时渲染的数据。打开之前创建的`service/service.py`文件，并将以下行添加到现有代码中。示例代码文件包含在`restful_python_2_01_01`文件夹中，位于`Flask01/service/service.py`文件：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We declared the `notification_fields` dictionary (`dict`) with key-value pairs
    of strings and classes declared in the `flask_restful.fields` module. The keys
    are the names of the attributes we want to render from the `NotificationModel`
    class, and the values are the classes that format and return the value for the
    field. In the previous code, we worked with the following classes that format
    and return the value for the specified field in the key:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了`notification_fields`字典（`dict`），其中包含字符串和类的键值对，这些类是在`flask_restful.fields`模块中声明的。键是我们想要从`NotificationModel`类中渲染的属性名称，而值是格式化和返回字段值的类。在之前的代码中，我们使用了以下类来格式化和返回键中指定字段的值：
- en: '`fields.Integer`: Outputs an integer value.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields.Integer`: 输出一个整数值。'
- en: '`fields.Url`: Generates a string representation of a URL. By default, this
    class generates a relative URI for the resource that is being requested. The code
    specifies `''notification_endpoint''` for the `endpoint` argument. This way, the
    class will use the specified endpoint name. We will declare this endpoint later
    in the `service.py` file. We don''t want to include the hostname in the generated
    URI and, therefore, we use the default value for the `absolute` Boolean attribute,
    which is `False`.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields.Url`: 生成一个URL的字符串表示形式。默认情况下，此类为请求的资源生成一个相对URI。代码指定了`''notification_endpoint''`作为`endpoint`参数。这样，该类将使用指定的端点名称。我们将在`service.py`文件中稍后声明此端点。我们不希望在生成的URI中包含主机名，因此我们使用`absolute`布尔属性的默认值，即`False`。'
- en: '`fields.DateTime`: Outputs a formatted date and time string in UTC, in the
    default RFC 822 format.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields.DateTime`: 以UTC格式输出格式化的日期和时间字符串，默认为RFC 822格式。'
- en: '`fields.Boolean`: Generates a string representation of a Boolean value.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields.Boolean`: 生成一个布尔值的字符串表示形式。'
- en: The `'uri'` field uses `fields.Url` and is related to the specified endpoint
    instead of being associated with an attribute of the `NotificationModel` class.
    It is the only case in which the specified field name doesn't have an attribute
    in the `NotificationModel` class. The other strings specified as keys indicate
    all the attributes we want to be rendered in the output when we use the `notification_fields`
    dictionary to make up the final serialized response output.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`''uri''`字段使用`fields.Url`，与指定的端点相关联，而不是与`NotificationModel`类的属性相关联。这是唯一一种指定字段名称在`NotificationModel`类中没有属性的情况。其他指定的字符串键表示我们希望在输出中渲染的所有属性，当我们使用`notification_fields`字典来组成最终的序列化响应输出时。'
- en: After we declare the `notification_fields` dictionary, the next line of code
    creates an instance of the `NotificationManager` class created previously, named
    `notification_manager`. We will use this instance to create, retrieve, and delete
    `NotificationModel` instances.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们声明`notification_fields`字典之后，下一行代码创建了一个之前创建的`NotificationManager`类的实例，命名为`notification_manager`。我们将使用此实例来创建、检索和删除`NotificationModel`实例。
- en: Working with resourceful routing on top of Flask pluggable views
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Flask可插拔视图之上进行资源路由操作
- en: Flask-RESTful uses resources built on top of Flask pluggable views as the main
    building block for a RESTful API. We just need to create a subclass of the `flask_restful.Resource`
    class and declare the methods for each supported HTTP verb.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Flask-RESTful使用基于Flask的可插拔视图构建的资源作为RESTful API的主要构建块。我们只需创建`flask_restful.Resource`类的子类并声明每个支持的HTTP动词的方法。
- en: A subclass of `flask_restful.Resource` represents a RESTful resource and, therefore,
    we will have to declare one class to represent the collection of notifications
    and another one to represent the notification resource.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`flask_restful.Resource`的子类代表一个RESTful资源，因此我们将不得不声明一个类来表示通知集合，另一个类来表示通知资源。'
- en: First, we will create a `Notification` class that we will use to represent the
    notification resource. Open the `service/service.py` file created previously and
    add the following lines. The code file for the sample is included in the ...
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个`Notification`类，我们将使用它来表示通知资源。打开之前创建的`service/service.py`文件并添加以下行。示例的代码文件包含在
    ...
- en: Configuring resource routing and endpoints
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置资源路由和端点
- en: 'We must make the necessary resource routing configurations to call the appropriate
    methods and pass them all the necessary arguments by defining URL rules. The following
    lines create the main entry point for the application, initialize it with a Flask
    application, and configure the resource routing for the service. Open the previously
    created `service/service.py` file and add the following lines. The code file for
    the sample is included in the `restful_python_2_01_01` folder, in the `Flask01/service/service.py`
    file:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须通过定义URL规则来配置必要的资源路由，以调用适当的方法，并通过传递所有必要的参数。以下行创建应用程序的主要入口点，使用Flask应用程序初始化它，并配置服务的资源路由。打开之前创建的`service/service.py`文件并添加以下行。示例的代码文件包含在`restful_python_2_01_01`文件夹中的`Flask01/service/service.py`文件：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The code creates an instance of the `flask_restful.Api` class and saves it in
    the `service` variable. Each call to the `service.add_resource` method routes
    a URL to a resource, specifically to one of the previously declared subclasses
    of the `flask_restful.Resource` superclass. When there is a request to the service
    and the URL matches one of the URLs specified in the `service.add_resource` method,
    Flask will call the method that matches the HTTP verb in the request for the specified
    class. The method follows standard Flask routing rules.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 代码创建了一个`flask_restful.Api`类的实例，并将其保存在`service`变量中。每次调用`service.add_resource`方法都会将一个URL路由到一个资源，具体到之前声明的`flask_restful.Resource`超类的一个子类。当有请求到服务并且URL与`service.add_resource`方法中指定的URL之一匹配时，Flask将调用与请求中指定的类中的HTTP动词匹配的方法。该方法遵循标准的Flask路由规则。
- en: 'For example, the following line will make an HTTP `GET` request to `/service/notifications/`
    without any additional parameters to call the `NotificationList.get` method:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下行将发出一个不带任何附加参数的HTTP `GET`请求到`/service/notifications/`，以调用`NotificationList.get`方法：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Flask will pass the URL variables to the called method as arguments. For example,
    the following line will make an HTTP `GET` request to `/service/notifications/26`
    to call the `Notification.get` method, with `26` passed as the value for the `id`
    argument:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Flask会将URL变量作为参数传递给被调用的方法。例如，以下行将发出一个HTTP `GET`请求到`/service/notifications/26`以调用`Notification.get`方法，其中`26`作为`id`参数的值传递：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In addition, we can specify a string value for the endpoint argument to make
    it easy to reference the specified route in the `fields.Url` fields. We pass the
    same endpoint name, `'notification_endpoint'`, as an argument in the `uri` field
    declared as `fields.Url` in the `notification_fields` dictionary that we use to
    render each `NotificationModel` instance. This way, `fields.Url` will generate
    a URI that considers this route.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以为端点参数指定一个字符串值，以便在`fields.Url`字段中轻松引用指定的路由。我们将相同的端点名称`'notification_endpoint'`作为`notification_fields`字典中声明的`fields.Url`字段的参数传递，我们使用该字典来渲染每个`NotificationModel`实例。这样，`fields.Url`将生成考虑此路由的URI。
- en: 'We just required a few lines of code to configure resource routing and endpoints.
    The last line just calls the `app.run` method to start the Flask application,
    with the `debug` argument set to `True` to enable debugging. In this case, we
    start the application by calling the `run` method to immediately launch a local
    server. We could also achieve the same goal by using the `flask` command-line
    script. However, this option would require us to configure environment variables
    and the instructions are different for the platforms that we are covering in this
    book: macOS, Windows, and Linux.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需几行代码即可配置资源路由和端点。最后一行只是调用`app.run`方法来启动Flask应用程序，将`debug`参数设置为`True`以启用调试。在这种情况下，我们通过调用`run`方法立即启动本地服务器。我们也可以通过使用`flask`命令行脚本来达到相同的目的。然而，这个选项需要我们配置环境变量，而且在这个书中我们涵盖的平台（macOS、Windows和Linux）的说明是不同的。
- en: As with any other web framework, you should never enable debugging in a production
    environment.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他Web框架一样，你永远不应该在生产环境中启用调试。
- en: Making HTTP requests to the Flask API
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向Flask API发送HTTP请求
- en: 'Now, we can run the `service/service.py` script that launches Flask''s development
    server to compose and send HTTP requests to our unsecured and simple web API (we
    will definitely add security later). Execute the following command. Make sure
    you have the virtual environment activated:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行`service/service.py`脚本，该脚本启动Flask的开发服务器，以组合和发送HTTP请求到我们的未加密和简单的Web
    API（我们肯定会添加安全功能）。执行以下命令。确保你已经激活了虚拟环境：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following lines show the output after we execute the previous command.
    The development server is listening at port `5000`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了执行上一条命令后的输出。开发服务器正在监听端口`5000`：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Working with the curl and httpie command-line tools
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用curl和httpie命令行工具
- en: We will start with command-line tools. One of the key advantages of command-line
    tools is that we can easily run again the HTTP requests after we build them for
    the first time, and we don't need to use the mouse or to tap the screen to run
    requests. We can also easily build a script with batch requests and run them.
    As happens with any command-line tool, it can take more time to perform the first
    requests compared with GUI tools, but it becomes easier once we've performed many
    requests and we can easily reuse the commands we have written in the past to compose
    new requests.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从命令行工具开始。命令行工具的一个关键优势是，我们可以在第一次构建HTTP请求后轻松地再次运行它们，我们不需要使用鼠标或触摸屏幕来运行请求。我们还可以轻松地构建一个包含批量请求的脚本并运行它们。与任何命令行工具一样，与GUI工具相比，第一次执行请求可能需要更多时间，但一旦我们执行了许多请求，它就会变得更容易，我们可以轻松地重用我们以前编写的命令来组合新的请求。
- en: '**Curl**, also known as **cURL**, is a very popular open source command-line
    tool and library that allows us to easily transfer data. We can use the `curl`
    command-line tool to easily compose and send HTTP requests and check their responses.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**Curl**，也称为**cURL**，是一个非常流行的开源命令行工具和库，它允许我们轻松地传输数据。我们可以使用`curl`命令行工具轻松地组合和发送HTTP请求并检查它们的响应。'
- en: In macOS or Linux, you can open a Terminal and start using `curl` from the command
    line.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS或Linux中，你可以打开一个终端并从命令行开始使用`curl`。
- en: In Windows, you can work with `curl` in the Command Prompt or you can install
    `curl` as part of the Cygwin package installation option and execute it from the
    Cygwin terminal. In case you decide to use the `curl` command within the Command
    Prompt, download and unzip the latest version at [http://curl.haxx.se/download.html](http://curl.haxx.se/download.html).
    Then, make sure you include the folder in which the `curl.exe` file is included
    in your path to make it easy to run the command.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，你可以在命令提示符中处理`curl`，或者你可以将`curl`作为Cygwin包安装选项的一部分进行安装，并在Cygwin终端中执行它。如果你决定在命令提示符中使用`curl`命令，请从[http://curl.haxx.se/download.html](http://curl.haxx.se/download.html)下载并解压最新版本。然后，确保将包含`curl.exe`文件的文件夹包含在你的路径中，以便更容易运行命令。
- en: You can read more about the Cygwin terminal and its installation procedure at
    [http://cygwin.com/install.html](http://cygwin.com/install.html). In case you
    decide to use the Cygwin terminal, use it whenever you have to run the `curl`
    command instead of working with the Command Prompt.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://cygwin.com/install.html](http://cygwin.com/install.html)了解更多关于Cygwin终端及其安装过程的信息。如果你决定使用Cygwin终端，每次你需要运行`curl`命令而不是使用命令提示符时，都要使用它。
- en: Notice that Windows PowerShell includes the `curl` alias that calls the `Inovoke-WebRequest`
    command. Thus, in case you decide to work with Windows PowerShell, you will have
    to remove the `curl` alias to use the `curl` utility we use in this book.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Windows PowerShell 包含一个名为 `curl` 的别名，该别名调用 `Invoke-WebRequest` 命令。因此，如果你决定使用
    Windows PowerShell，你必须删除 `curl` 别名才能使用本书中使用的 `curl` 工具。
- en: We used the `requirements.txt` file to install the packages for our virtual
    environment. In this file, we specified `httpie` as one of the required packages.
    This way, we installed **HTTPie**, a command-line HTTP client written in Python
    that makes it easy to send HTTP requests and uses a syntax that is easier than
    `curl`. One of the great advantages of HTTPie is that it displays colorized output
    and uses multiple lines to display the response details. Thus, HTTPie makes it
    easier to understand the responses than the `curl` utility. However, it is very
    important to mention that HTTPie is slower than `curl`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `requirements.txt` 文件安装虚拟环境中的包。在这个文件中，我们将 `httpie` 指定为一个必需的包。这样，我们安装了 **HTTPie**，这是一个用
    Python 编写的命令行 HTTP 客户端，它使得发送 HTTP 请求变得容易，并使用比 `curl` 更简单的语法。HTTPie 的一个巨大优点是它显示彩色输出，并使用多行来显示响应细节。因此，HTTPie
    使得理解响应比 `curl` 工具更容易。然而，非常重要的一点是要提到 HTTPie 比 `curl` 慢。
- en: 'Whenever we compose HTTP requests with the command line, we will use two versions
    of the same command: the first one with HTTPie, and the second one with `curl`.
    This way, you will be able to use the one that is most convenient for you.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们使用命令行编写 HTTP 请求时，我们将使用同一命令的两个版本：第一个使用 HTTPie，第二个使用 `curl`。这样，您将能够使用最方便的一种。
- en: 'Make sure you leave the Flask development server running. Don''t close the
    Terminal or Command Prompt that is running this development server. Open a new
    Terminal in macOS or Linux, or a Command Prompt in Windows, and run the following
    command. It is very important that you enter the ending slash (`/`) when specified
    because `/service/notifications` won''t match any of the configured URL routes.
    Thus, we must enter `/service/notifications/`, including the ending slash (`/`).
    We will compose and send an HTTP request to create a new notification. The code
    file for the sample is included in the `restful_python_2_01_02` folder, in the
    `Flask01/cmd01.txt` file:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您让 Flask 开发服务器继续运行。不要关闭运行此开发服务器的终端或命令提示符。在 macOS 或 Linux 中打开一个新的终端，或在 Windows
    中打开一个命令提示符，并运行以下命令。非常重要的一点是，当指定时，您必须输入结束斜杠（`/`），因为 `/service/notifications` 不会匹配任何配置的
    URL 路由。因此，我们必须输入 `/service/notifications/`，包括结束斜杠（`/`）。我们将组合并发送一个 HTTP 请求来创建一个新的通知。示例代码文件包含在
    `restful_python_2_01_02` 文件夹中，位于 `Flask01/cmd01.txt` 文件：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following is the equivalent `curl` command. It is very important to use
    the `-H "Content-Type: application/json"` option to tell `curl` to send the data
    specified after the `-d` option as `application/json` instead of the default `application/x-www-form-urlencoded`
    option.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '以下是对应的 `curl` 命令。非常重要的一点是使用 `-H "Content-Type: application/json"` 选项告诉 `curl`
    将 `-d` 选项之后指定的数据作为 `application/json` 发送，而不是默认的 `application/x-www-form-urlencoded`
    选项。'
- en: 'The code file for the sample is included in the `restful_python_2_01_02` folder,
    in the `Flask01/cmd02.txt` file:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码文件包含在 `restful_python_2_01_02` 文件夹中，位于 `Flask01/cmd02.txt` 文件：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The previous commands will compose and send the `POST http://localhost:5000/service/notifications/`
    HTTP request with the following JSON key-value pairs:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组合并发送带有以下 JSON 键值对的 `POST http://localhost:5000/service/notifications/`
    HTTP 请求：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The request specifies `/service/notifications/` and, therefore, it will match
    `''/service/notifications/''` and run the `NotificationList.post` method. The
    method doesn''t receive arguments because the URL route doesn''t include any parameters.
    As the HTTP verb for the request is `POST`, Flask calls the `post` method. If
    the new `NotificationModel` was successfully persisted in the dictionary, the
    function returns an HTTP `201 Created` status code and the recently persisted
    `NotificationModel` serialized to JSON in the response body. The following lines
    show an example response for the HTTP request, with the new `NotificationModel`
    object in the JSON response:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请求指定了 `/service/notifications/`，因此它将匹配 `'/service/notifications/'` 并运行 `NotificationList.post`
    方法。由于 URL 路由不包含任何参数，该方法不接收任何参数。由于请求的 HTTP 动词是 `POST`，Flask 调用 `post` 方法。如果新的 `NotificationModel`
    成功保存在字典中，函数将返回 HTTP `201 Created` 状态码，并将最近持久化的 `NotificationModel` 序列化为 JSON 格式放在响应体中。以下行显示了
    HTTP 请求的示例响应，其中包含 JSON 响应中的新 `NotificationModel` 对象：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will compose and send an HTTP request to create another notification. Go
    back to the Command Prompt in Windows, or the Terminal in macOS or Linux, and
    run the following command. The code file for the sample is included in the `restful_python_2_01_02`
    folder, in the `Flask01/cmd03.txt` file:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将组合并发送一个 HTTP 请求以创建另一个通知。返回到 Windows 的命令提示符，或在 macOS 或 Linux 的终端中运行以下命令。示例代码文件包含在
    `restful_python_2_01_02` 文件夹中，在 `Flask01/cmd03.txt` 文件中：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_01_02` folder, in the `Flask01/cmd04.txt`
    file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令。示例代码文件包含在 `restful_python_2_01_02` 文件夹中，在 `Flask01/cmd04.txt`
    文件中：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The previous commands will compose and send the `POST http://localhost:5000/service/notifications/`
    HTTP request with the following JSON key-value pairs:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组合并发送带有以下 JSON 键值对的 `POST http://localhost:5000/service/notifications/`
    HTTP 请求：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following lines show an example response for the HTTP request, with the
    new `NotificationModel` object in the JSON response:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了 HTTP 请求的示例响应，其中包含 JSON 响应中的新 `NotificationModel` 对象：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We will compose and send an HTTP request to retrieve all the notifications.
    Go back to the Command Prompt in Windows, or the Terminal in macOS or Linux, and
    run the following command. The code file for the sample is included in the `restful_python_2_01_02`
    folder, in the `Flask01/cmd05.txt` file:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将组合并发送一个 HTTP 请求以检索所有通知。返回到 Windows 的命令提示符，或在 macOS 或 Linux 的终端中运行以下命令。示例代码文件包含在
    `restful_python_2_01_02` 文件夹中，在 `Flask01/cmd05.txt` 文件中：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_01_02` folder, in the `Flask01/cmd06.txt`
    file:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令。示例代码文件包含在 `restful_python_2_01_02` 文件夹中，在 `Flask01/cmd06.txt`
    文件中：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The previous commands will compose and send the `GET http://localhost:5000/service/notifications/`
    HTTP request. The request specifies `/service/notifications/` and, therefore,
    it will match `'/service/notifications/'` and run the `NotificationList.get` method.
    The method doesn't receive arguments because the URL route doesn't include any
    parameters. As the HTTP verb for the request is `GET`, Flask calls the `get` method.
    The method retrieves all the `NotificationModel` objects and generates a JSON
    response with all of these `NotificationModel` objects serialized.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组合并发送 `GET http://localhost:5000/service/notifications/` HTTP 请求。该请求指定了
    `/service/notifications/`，因此它将匹配 `'/service/notifications/'` 并运行 `NotificationList.get`
    方法。由于 URL 路由不包含任何参数，该方法不接收任何参数。由于请求的 HTTP 动词是 `GET`，Flask 调用 `get` 方法。该方法检索所有
    `NotificationModel` 对象，并生成包含所有这些 `NotificationModel` 对象序列化的 JSON 响应。
- en: 'The following lines show an example response for the HTTP request. The first
    lines show the HTTP response headers, including the status (`200 OK)` and the
    content type (`application/json`). After the HTTP response headers, we can see
    the details for the two `NotificationModel` objects in the JSON response:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了 HTTP 请求的示例响应。前几行显示了 HTTP 响应头，包括状态（`200 OK`）和内容类型（`application/json`）。在
    HTTP 响应头之后，我们可以看到 JSON 响应中两个 `NotificationModel` 对象的详细信息：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After we run the three requests, we will see the following lines in the window
    that is running the Flask development server. The output indicates that the service
    received three HTTP requests, specifically two `POST` requests and one `GET` request
    with `/service/notifications/` as the URI. The service processed the three HTTP
    requests, and returned the `201` status code for the first two requests and `200`
    for the last request:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行了三个请求之后，我们将在运行 Flask 开发服务器的窗口中看到以下行。输出表明服务接收了三个 HTTP 请求，具体是两个 `POST` 请求和一个带有
    `/service/notifications/` 作为 URI 的 `GET` 请求。服务处理了这三个 HTTP 请求，并返回了前两个请求的 `201`
    状态码和最后一个请求的 `200` 状态码：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following screenshot shows two Terminal windows side by side on macOS.
    The Terminal window on the left-hand side is running the Flask development server
    and displays the received and processed HTTP requests. The Terminal window on
    the right-hand side is running `http` commands to generate the HTTP requests.
    It is a good idea to use a similar configuration to check the output while we
    compose and send the HTTP requests:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 macOS 上并排的两个终端窗口。左侧的终端窗口正在运行 Flask 开发服务器并显示接收和处理的 HTTP 请求。右侧的终端窗口正在运行
    `http` 命令以生成 HTTP 请求。在我们组合和发送 HTTP 请求时，使用类似的配置来检查输出是一个好主意：
- en: '![](img/d02d1b9f-018b-4800-9f1b-1ba875372560.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d02d1b9f-018b-4800-9f1b-1ba875372560.png)'
- en: 'Now, we will compose and send an HTTP request to retrieve a notification that
    doesn''t exist. For example, in the previous list, there is no notification with
    an `id` value equal to `78`. Run the following command to try to retrieve this
    notification. Make sure you use an `id` value that doesn''t exist. We must make
    sure that the utilities display the headers as part of the response to see the
    returned status code. The code file for the sample is included in the `restful_python_2_01_02`
    folder, in the `Flask01/cmd07.txt` file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写并发送一个HTTP请求来检索一个不存在的通知。例如，在上一个列表中，没有`id`值等于`78`的通知。运行以下命令尝试检索此通知。确保你使用一个不存在的`id`值。我们必须确保工具将标题作为响应的一部分显示，以查看返回的状态码。示例代码文件包含在`restful_python_2_01_02`文件夹中的`Flask01/cmd07.txt`文件中：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_01_02` folder, in the `Flask01/cmd08.txt`
    file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令。示例代码文件包含在`restful_python_2_01_02`文件夹中的`Flask01/cmd08.txt`文件中：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The previous commands will compose and send the `GET http://localhost:5000/service/notifications/78`
    HTTP request. The request is the same as the previous one we analyzed, with a
    different number for the `id` parameter. The service will run the `Notification.get`
    method, with `78` as the value for the `id` argument. The method will execute
    the code that retrieves the `NotificationModel` object whose ID matches the `id`
    value received as an argument. However, the first line in the `NotificationList.get`
    method calls the `abort_if_notification_not_found` method, which won''t find the
    ID in the dictionary keys, and it will call the `flask_restful.abort` function
    because there is no notification with the specified `id` value. Thus, the code
    will return an HTTP `404 Not Found` status code. The following lines show an example
    header response for the HTTP request and the message included in the body. In
    this case, we just leave the default message. Of course, we can customize it based
    on our specific needs:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将编写并发送`GET http://localhost:5000/service/notifications/78` HTTP请求。该请求与之前分析的那个相同，只是`id`参数的数字不同。服务将运行`Notification.get`方法，将`78`作为`id`参数的值。该方法将执行检索与作为参数接收的`id`值匹配的`NotificationModel`对象的代码。然而，`NotificationList.get`方法中的第一行调用了`abort_if_notification_not_found`方法，它无法在字典键中找到ID，并将调用`flask_restful.abort`函数，因为没有指定`id`值的该通知。因此，代码将返回HTTP
    `404 Not Found`状态码。以下行显示了HTTP请求的示例响应头和体中包含的消息。在这种情况下，我们只是保留默认消息。当然，我们可以根据我们的具体需求进行自定义：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We provide an implementation for the `PATCH` method to make it possible for
    our API to update a single field for an existing resource. For example, we can
    use the `PATCH` method to update two fields for an existing notification and set
    the value for its `displayed_once` field to `true` and `displayed_times` to `1`.
    We don't want to use the `PUT` method because this method is meant to replace
    an entire notification.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`PATCH`方法提供了一个实现，以便我们的API能够更新现有资源的单个字段。例如，我们可以使用`PATCH`方法更新现有通知的两个字段，并将`displayed_once`字段的值设置为`true`，将`displayed_times`设置为`1`。我们不希望使用`PUT`方法，因为这个方法旨在替换整个通知。
- en: The `PATCH` method is meant to apply a delta to an existing notification and,
    therefore, it is the appropriate method to just change the value of the `displayed_once`
    and `displayed_times` fields.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`PATCH`方法旨在对现有通知应用一个增量，因此它是仅更改`displayed_once`和`displayed_times`字段值的适当方法。'
- en: 'Now, we will compose and send an HTTP request to update an existing notification,
    specifically, to update the value of two fields. Make sure you replace `2` with
    the ID of an existing notification in your configuration. The code file for the
    sample is included in the `restful_python_2_01_02` folder, in the `Flask01/cmd09.txt`
    file:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写并发送一个HTTP请求来更新现有的通知，具体来说，是更新两个字段的值。确保你将配置中的`2`替换为现有通知的ID。示例代码文件包含在`restful_python_2_01_02`文件夹中的`Flask01/cmd09.txt`文件中：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_01_02` folder, in the `Flask01/cmd10.txt`
    file:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令。示例代码文件包含在`restful_python_2_01_02`文件夹中的`Flask01/cmd10.txt`文件中：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The previous command will compose and send a `PATCH` HTTP request with the
    specified JSON key-value pairs. The request has a number after `/service/notifications/` and,
    therefore, it will match `''/service/notifications/<int:id>''` and run the `Notification.patch`
    method, that is, the `patch` method for the `Notification` class. If a `NotificationModel`
    instance with the specified ID exists and was successfully updated, the call to
    the method will return an HTTP `200 OK` status code and the recently updated `NotificationModel`
    instance serialized to JSON in the response body. The following lines show a sample
    response:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将编写并发送一个带有指定 JSON 键值对的 `PATCH` HTTP 请求。请求在 `/service/notifications/` 后面有一个数字，因此它将匹配
    `'/service/notifications/<int:id>'` 并运行 `Notification.patch` 方法，即 `Notification`
    类的 `patch` 方法。如果存在具有指定 ID 的 `NotificationModel` 实例并且已成功更新，该方法调用将返回 HTTP `200 OK`
    状态码，并且最近更新的 `NotificationModel` 实例序列化为 JSON 格式在响应体中。以下行显示了示例响应：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The IoT device will execute the previously explained HTTP request when it displays
    the notification for the first time. Then, it will make additional `PATCH` requests
    to update the value for the `displayed_times` field.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当物联网设备首次显示通知时，它将执行之前解释的 HTTP 请求。然后，它将执行额外的 `PATCH` 请求来更新 `displayed_times` 字段的值。
- en: 'Now, we will compose and send an HTTP request to delete an existing notification,
    specifically, the last one we added. As happened in our last HTTP requests, we
    have to check the value assigned to `id` in the previous response and replace
    `2` in the command with the returned value. The code file for the sample is included
    in the `restful_python_2_01_02` folder, in the `Flask01/cmd11.txt` file:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写并发送一个 HTTP 请求来删除一个现有的通知，具体来说，是我们最后添加的那个。就像我们之前的 HTTP 请求一样，我们必须检查前一个响应中分配给
    `id` 的值，并将命令中的 `2` 替换为返回的值。示例的代码文件包含在 `restful_python_2_01_02` 文件夹中的 `Flask01/cmd11.txt`
    文件里：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_01_02` folder, in the `Flask01/cmd12.txt`
    file:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令。示例的代码文件包含在 `restful_python_2_01_02` 文件夹中的 `Flask01/cmd12.txt`
    文件里：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The previous commands will compose and send the `DELETE http://localhost:5000/service/notifications/2`
    HTTP request. The request has a number after `/service/notifications/` and, therefore,
    it will match `''/service/notifications/<int:id>''` and run the `Notification.delete`
    method, that is, the `delete` method for the `Notification` class. If a `NotificationModel`
    instance with the specified ID exists and was successfully deleted, the call to
    the method will return an HTTP `204 No Content` status code. The following lines
    show a sample response:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将编写并发送 `DELETE http://localhost:5000/service/notifications/2` 的 HTTP 请求。请求在
    `/service/notifications/` 后面有一个数字，因此它将匹配 `'/service/notifications/<int:id>'` 并运行
    `Notification.delete` 方法，即 `Notification` 类的 `delete` 方法。如果存在具有指定 ID 的 `NotificationModel`
    实例并且已成功删除，该方法调用将返回 HTTP `204 No Content` 状态码。以下行显示了示例响应：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Working with GUI tools – Postman and others
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GUI 工具 – Postman 及其他
- en: 'So far, we have been working with two terminal-based, or command-line, tools
    to compose and send HTTP requests to our Flask development server: cURL and HTTPie.
    Now, we will work with a **GUI** (short for **Graphical User Interface**) tool.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用两个基于终端的或命令行工具来编写并发送 HTTP 请求到我们的 Flask 开发服务器：cURL 和 HTTPie。现在，我们将使用一个
    **GUI**（代表 **图形用户界面**）工具。
- en: Postman is a very popular API testing suite GUI tool that allows us to easily
    compose and send HTTP requests, among other features. Postman is available as
    a Chrome App and as a Macintosh App. We can execute it in Windows, Linux, and
    macOS as a native app. You can download the versions of the Postman app at [https://www.getpostman.com/apps](https://www.getpostman.com/apps).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Postman 是一个非常流行的 API 测试套件 GUI 工具，它允许我们轻松地编写并发送 HTTP 请求，以及其他功能。Postman 可作为 Chrome
    App 和 Macintosh App 提供。我们可以在 Windows、Linux 和 macOS 上作为原生应用执行它。您可以在 [https://www.getpostman.com/apps](https://www.getpostman.com/apps)
    下载 Postman 应用程序的版本。
- en: You can download and install Postman for free to compose and send HTTP requests
    to our RESTful APIs. You just need to sign up to ...
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以免费下载并安装 Postman 来编写并发送 HTTP 请求到我们的 RESTful API。您只需注册 ...
- en: Consuming the API with other programming languages
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用其他编程语言消费 API
- en: We've built our first RESTful Web Service that is capable of running as a microservice
    with Flask and Python. We can consume the API with any modern programming language
    that can compose and send HTTP requests to the resources and verbs supported by
    the API and work easily with JSON content.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经构建了我们第一个RESTful Web Service，它能够使用Flask和Python作为微服务运行。我们可以使用任何现代编程语言来消费API，这些语言能够组合并发送HTTP请求到API支持的资源和动词，并且可以轻松地处理JSON内容。
- en: It is extremely important to make sure that we set the content type for the
    HTTP request as we did when working with the `curl` and `http` command-line utilities.
    We just need to check which is the most convenient way of doing so in the programming
    language that we have to use as a client.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 确保我们在使用`curl`和`http`命令行工具时设置HTTP请求的内容类型非常重要。我们只需要检查在我们要使用的编程语言中，哪种方式最为方便。
- en: The fact that we can easily run a Flask development server and check its console
    output whenever a new request is processed makes it easy to check which requests
    arrive at the server. In this case, we are working with a basic and unsecured
    API. However, we will work with secure and more advanced APIs in the forthcoming
    chapters.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松运行Flask开发服务器并检查其控制台输出，每当处理新的请求时，这使得检查到达服务器的请求变得容易。在这种情况下，我们正在处理一个基本且未加密的API。然而，在接下来的章节中，我们将处理安全且更高级的API。
- en: Test your knowledge
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: 'Let''s see whether you can answer the following questions correctly:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否能正确回答以下问题：
- en: 'HTTPie is a:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTTPie是一个：
- en: Command-line HTTP server written in Python that makes it easy to create a RESTful
    Web Server
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用Python编写的命令行HTTP服务器，使得创建RESTful Web Server变得容易
- en: Command-line utility that allows us to run queries against a SQLite database
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令行实用工具，允许我们对SQLite数据库运行查询
- en: Command-line HTTP client written in Python that makes it easy to compose and
    send HTTP requests
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用Python编写的命令行HTTP客户端，使得组合和发送HTTP请求变得容易
- en: 'Flask-RESTful uses which of the following as the main building block for a
    RESTful API:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Flask-RESTful使用以下哪个作为RESTful API的主要构建块：
- en: Resources built on top of Flask pluggable views
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立在Flask可插拔视图之上的资源
- en: Statuses built on top of Flask resource views
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立在Flask资源视图之上的状态
- en: Resources built on top of Flask pluggable controllers
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立在Flask可插拔控制器之上的资源
- en: To process an HTTP `PATCH` request on a resource, which method should we declare
    in a subclass of `flask_restful.Resource`?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要处理资源上的HTTP `PATCH`请求，我们应该在`flask_restful.Resource`的子类中声明哪个方法？
- en: '`patch_restful ...`'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`patch_restful ...`'
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we designed a RESTful API to interact with a simple dictionary
    that acted as a data repository and performed CRUD operations with notifications,
    to be used as a baseline for a microservice. We defined the requirements for our
    API and understood the tasks performed by each HTTP method. We set up a virtual
    environment with Flask and Flask-RESTful. We followed best practices to generate
    a reproducible virtual environment.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们设计了一个RESTful API来与一个简单的字典交互，该字典充当数据存储库并执行与通知相关的CRUD操作，作为微服务的基线。我们定义了API的要求并理解了每个HTTP方法执行的任务。我们使用Flask和Flask-RESTful设置了一个虚拟环境。我们遵循最佳实践来生成可重复的虚拟环境。
- en: We created a model to represent and persist notifications. We learned how to
    configure the serialization of notifications into JSON representations with the
    features included in Flask-RESTful. We wrote classes that represent resources
    and process the different HTTP requests, and we configured the URL patterns to
    route URLs to classes.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个模型来表示和持久化通知。我们学习了如何使用Flask-RESTful中的功能配置通知的序列化为JSON表示。我们编写了代表资源并处理不同HTTP请求的类，并配置了URL模式将URL路由到类。
- en: Finally, we started the Flask development server and we used command-line tools
    to compose and send HTTP requests to our RESTful API and analyzed how each HTTP
    requests was processed in our code. We also worked with many useful GUI tools
    to compose and send HTTP requests.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们启动了Flask开发服务器，并使用命令行工具来组合和发送HTTP请求到我们的RESTful API，并分析了我们的代码中如何处理每个HTTP请求。我们还使用了许多有用的GUI工具来组合和发送HTTP请求。
- en: Now that we understand the basics of the combination of Flask and Flask-RESTful
    to create RESTful APIs that we can encapsulate in microservices, in the next chapter,
    we will expand the capabilities of the RESTful Web API by taking advantage of
    the advanced features included in Flask-RESTful and related ORMs.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何结合 Flask 和 Flask-RESTful 创建可以封装在微服务中的 RESTful API 的基础知识，在下一章中，我们将通过利用
    Flask-RESTful 和相关 ORM 包含的高级功能来扩展 RESTful Web API 的功能。
