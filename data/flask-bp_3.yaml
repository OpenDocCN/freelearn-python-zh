- en: Chapter 3. Snap – the Code Snippet Sharing Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。Snap - 代码片段共享应用程序
- en: In this chapter, we will build our first fully functional, database-backed application.
    This application, codenamed Snap, will allow users to create an account with a
    username and password. Users will be allowed to login, logout, add and list the
    so-called semiprivate *snaps* of text that can be shared with others.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建我们的第一个完全功能的、基于数据库的应用程序。这个应用程序，代号Snap，将允许用户使用用户名和密码创建帐户。用户将被允许登录、注销、添加和列出所谓的半私密*snaps*文本，这些文本可以与其他人分享。
- en: 'For this chapter, you should be familiar with at least one of the following
    relational database systems: PostgreSQL, MySQL, or SQLite. Additionally, some
    knowledge of the SQLAlchemy Python library, which acts as an abstraction layer
    and object-relational mapper for these (and several other) databases, will be
    an asset. If you are not well versed in the usage of SQLAlchemy, fear not. We
    will have a gentle introduction to the library that will bring new developers
    up to speed and serve as a refresher for the more experienced.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，您应该熟悉以下至少一种关系数据库系统：PostgreSQL、MySQL或SQLite。此外，对SQLAlchemy Python库的一些了解将是一个优势，它充当这些（以及其他几个）数据库的抽象层和对象关系映射器。如果您对SQLAlchemy的使用不熟悉，不用担心。我们将对该库进行简要介绍，以帮助新开发人员迅速上手，并为经验丰富的开发人员提供复习。
- en: From this point on, in the book, the SQLite database will be our relational
    database of choice. The other database systems that we listed are all client/server-based
    with a multitude of configuration options that may need adjustment depending on
    the system they are installed in, while SQLite's default mode of operation is
    self-contained, serverless, and zero-configuration.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，在本书中，SQLite数据库将是我们选择的关系数据库。我们列出的其他数据库系统都是基于客户端/服务器的，具有多种配置选项，可能需要根据安装的系统进行调整，而SQLite的默认操作模式是独立、无服务器和零配置。
- en: We suggest that you use SQLite to work with this project and the projects in
    the following chapters, but any major relational database supported by SQLAlchemy
    will do.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您使用SQLite来处理这个项目和接下来的章节中的项目，但SQLAlchemy支持的任何主要关系数据库都可以。
- en: Getting started
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'To make sure we start things correctly, let''s create a folder where this project
    will exist and a virtual environment to encapsulate any dependencies that we will
    require:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们正确开始，让我们创建一个项目存在的文件夹和一个虚拟环境来封装我们将需要的任何依赖项：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will create a folder called `snap` at the given path and take us to this
    newly created folder. It will then create the snap virtual environment and install
    Flask in this environment.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在给定路径创建一个名为`snap`的文件夹，并带我们到这个新创建的文件夹。然后它将在这个环境中创建snap虚拟环境并安装Flask。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that the `mkvirtualenv` tool will create the virtual environment, which
    will be the default set of locations to install the packages from `pip`, but the
    `mkvirtualenv` command does not create the project folder for you. This is why
    we will run a command to create the project folder first and then create the virtual
    environment. Virtual environments, by virtue of the `$PATH` manipulation that
    is performed after the environments are activated, are completely independent
    of the location of your project files in the file system.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`mkvirtualenv`工具将创建虚拟环境，这将是从`pip`安装软件包的默认位置集，但`mkvirtualenv`命令不会为您创建项目文件夹。这就是为什么我们将首先运行一个命令来创建项目文件夹，然后再创建虚拟环境。虚拟环境通过激活环境后执行的`$PATH`操作完全独立于文件系统中项目文件的位置。
- en: 'We will then create our basic blueprint-based project layout with an empty
    users blueprint. The contents of all the files are nearly the same as we described
    at the end of the previous chapter, and the layout should resemble the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用基本的基于蓝图的项目布局创建一个空的用户蓝图。所有文件的内容几乎与我们在上一章末尾描述的内容相同，布局应该如下所示：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Flask-SQLAlchemy
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flask-SQLAlchemy
- en: 'Once the above files and folders have been created, we need to install the
    next important set of dependencies: SQLAlchemy, and the Flask extension that makes
    interacting with this library a bit more Flask-like, Flask-SQLAlchemy:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦上述文件和文件夹被创建，我们需要安装下一个重要的一组依赖项：SQLAlchemy和使与该库交互更类似于Flask的Flask扩展，Flask-SQLAlchemy：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will install the Flask extension to SQLAlchemy along with the base distribution
    of the latter and several other necessary dependencies in case they are not already
    present.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装Flask扩展到SQLAlchemy以及后者的基本分发和其他几个必要的依赖项，以防它们尚未存在。
- en: Now, if we were using a relational database system other than SQLite, this is
    the point where we would create the database entity in, say, PostgreSQL, along
    with the proper users and permissions so that our application can create tables
    and modify the contents of these tables. SQLite, however, does not require any
    of that. Instead, it assumes that any user that has access to the filesystem location
    of the database should also have permission to modify the contents of this database.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们使用的是除SQLite之外的关系数据库系统，这就是我们将在其中创建数据库实体的时刻，比如在PostgreSQL中，以及创建适当的用户和权限，以便我们的应用程序可以创建表并修改这些表的内容。然而，SQLite不需要任何这些。相反，它假设任何可以访问数据库文件系统位置的用户也应该有权限修改该数据库的内容。
- en: 'Later on in this chapter, we will see how the SQLite database file can be created
    automatically via SQLAlchemy. For the sake of completeness, however, here is how
    one would create an empty database in the current folder of your filesystem:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面，我们将看到如何通过SQLAlchemy自动创建SQLite数据库文件。然而，为了完整起见，这里是如何在文件系统的当前文件夹中创建一个空数据库：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As mentioned previously, we will be using SQLite as the database for our example
    applications and the directions given will assume that SQLite is being used; the
    exact name of the binary may differ on your system. You can substitute the equivalent
    commands to create and administer the database of your choice if anything other
    than SQLite is being used.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将使用SQLite作为示例应用程序的数据库，并且给出的指示将假定正在使用SQLite；二进制文件的确切名称可能在您的系统上有所不同。如果使用的不是SQLite，您可以替换等效的命令来创建和管理您选择的数据库。
- en: Now, we can begin the basic configuration of the Flask-SQLAlchemy extension.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始对Flask-SQLAlchemy扩展进行基本配置。
- en: Configuring Flask-SQLAlchemy
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置Flask-SQLAlchemy
- en: 'First, we must register the Flask-SQLAlchemy extension with the `application`
    object in the `application/__init__.py` file:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须在`application/__init__.py`文件中将Flask-SQLAlchemy扩展注册到`application`对象中：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The value of `app.config[''SQLALCHEMY_DATABASE_URI'']` is the escaped relative
    path to the `snap.db SQLite` database that we created previously. Once this simple
    configuration is in place, we will be able to create the SQLite database automatically
    via the `db.create_all()` method, which can be invoked in an interactive Python
    shell:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.config[''SQLALCHEMY_DATABASE_URI'']`的值是我们之前创建的`snap.db SQLite`数据库的转义相对路径。一旦这个简单的配置就位，我们就能够通过`db.create_all()`方法自动创建SQLite数据库，这可以在交互式Python
    shell中调用：'
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is an idempotent operation, which means that nothing would change even
    if the database already exists. If the local database file did not exist, however,
    it would be created. This also applies to adding new data models: running `db.create_all()`
    will add their definitions to the database, ensuring that the relevant tables
    have been created and are accessible. It does not, however, take into account
    the modification of an existing model/table definition that already exists in
    the database. For this, you will need to use the relevant tools (for example,
    the sqlite CLI, or a migration tool such as Alembic, which we discuss in a later
    chapter) to modify the corresponding table definitions to match those that have
    been updated in your models.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个幂等操作，这意味着即使数据库已经存在，也不会发生任何变化。然而，如果本地数据库文件不存在，它将被创建。这也适用于添加新的数据模型：运行`db.create_all()`将它们的定义添加到数据库，确保相关表已被创建并且可访问。然而，它并不考虑已经存在于数据库中的现有模型/表定义的修改。为此，您需要使用相关工具（例如sqlite
    CLI，或者迁移工具如Alembic，我们将在后面的章节中讨论）来修改相应的表定义，以匹配您模型中已更新的定义。
- en: SQLAlchemy basics
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQLAlchemy基础知识
- en: SQLAlchemy is, first and foremost, a toolkit to interact with the relational
    databases in Python.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy首先是一个与Python中的关系数据库进行交互的工具包。
- en: While it provides an incredible number of features—including the SQL connection
    handling and pooling for various database engines, ability to handle custom datatypes,
    and a comprehensive SQL expression API—the one feature that most developers are
    familiar with is the Object Relational Mapper. This mapper allows a developer
    to connect a Python object definition to a SQL table in the database of their
    choice, thus enabling them with the flexibility to control the domain models in
    their own application and requiring only minimal coupling to the database product
    and the engine-specific SQLisms that each of them exposes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它提供了令人难以置信的多种功能，包括各种数据库引擎的SQL连接处理和连接池、处理自定义数据类型的能力以及全面的SQL表达式API，但大多数开发人员熟悉的功能是对象关系映射器。这个映射器允许开发人员将Python对象定义与他们选择的数据库中的SQL表连接起来，从而使他们能够灵活地控制自己应用程序中的领域模型，并且只需要最小的耦合到数据库产品和引擎特定的SQL特性。
- en: 'While debating the usefulness (or the lack thereof) of an object relational
    mapper is outside the scope of this chapter, for those who are unfamiliar with
    SQLAlchemy we will provide a list of benefits that using this tool brings to the
    table, as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在本章讨论对象关系映射器的有用性（或缺乏有用性）超出了范围，但对于那些不熟悉SQLAlchemy的人，我们将提供使用这个工具带来的好处清单，如下所示：
- en: Your domain models are written to interface with one of the most well-respected,
    tested, and deployed Python packages ever created—SQLAlchemy.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的领域模型是为了与最受尊敬、经过测试和部署的Python包之一——SQLAlchemy进行交互而编写的。
- en: Onboarding new developers to a project becomes an order of magnitude easier
    due to the extensive documentation, tutorials, books, and articles that have been
    written about using SQLAlchemy.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于有关使用SQLAlchemy的广泛文档、教程、书籍和文章，将新开发人员引入项目变得更加容易。
- en: The validation of queries is accomplished using the SQLAlchemy expression language
    at module import time instead of executing each query string against the database
    to determine if there is a syntax error present. The expression language is in
    Python and can thus be validated with your usual set of tools and IDE.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询的验证是在模块导入时使用SQLAlchemy表达式语言完成的，而不是针对数据库执行每个查询字符串以确定是否存在语法错误。表达式语言是用Python编写的，因此可以使用您通常的一套工具和IDE进行验证。
- en: Thanks to the implementation of design patterns such as the Unit of Work, the
    Identity Map, and various lazy loading features, the developer can often be saved
    from performing more database/network roundtrips than necessary. Considering that
    the majority of a request/response cycle in a typical web application can easily
    be attributed to network latency of one type or another, minimizing the number
    of database queries in a typical response is a net performance win on many fronts.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于实现了设计模式，如工作单元、身份映射和各种延迟加载特性，开发人员通常可以避免执行比必要更多的数据库/网络往返。考虑到典型Web应用程序中请求/响应周期的大部分很容易归因于各种类型的网络延迟，最小化典型响应中的数据库查询数量在多个方面都是性能上的胜利。
- en: While many successful, performant applications can be built entirely on the
    ORM, SQLAlchemy does not force it upon you. If, for some reason, it is preferable
    to write raw SQL query strings or to use the SQLAlchemy expression language directly,
    then you can do that and still benefit from the connection pooling and the Python
    DBAPI abstraction functionality that is the core of SQLAlchemy itself.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然许多成功的高性能应用程序可以完全建立在ORM上，但SQLAlchemy并不强制要求这样做。如果出于某种原因，更倾向于编写原始的SQL查询字符串或直接使用SQLAlchemy表达语言，那么您可以这样做，并仍然从SQLAlchemy本身的连接池和Python
    DBAPI抽象功能中受益。
- en: Now that we've given you several reasons why you should be using this database
    query and domain data abstraction layer, let's look at how we would go about defining
    a basic data model.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经给出了几个理由，说明为什么应该使用这个数据库查询和领域数据抽象层，让我们看看如何定义一个基本的数据模型。
- en: Declarative mapping and Flask-SQLAlchemy
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 声明式映射和Flask-SQLAlchemy
- en: SQLAlchemy implements a design pattern known as a **data mapper**. Fundamentally,
    the job of this data mapper is to bridge the definition and manipulation of a
    data model in code (in our case, Python class definitions) and the representation
    of this data model in a database. The mapper should know how code-related actions
    (for example, object construction, attribute modifications, and so on) relate
    to the SQL-specific statements in a database of our choice, ensuring that actions
    performed on our mapped Python objects are properly synchronized with the database
    table(s) they are linked to.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy实现了一种称为**数据映射器**的设计模式。基本上，这个数据映射器的工作是在代码中桥接数据模型的定义和操作（在我们的情况下，Python类定义）以及数据库中这个数据模型的表示。映射器应该知道代码相关的操作（例如，对象构造、属性修改等）如何与我们选择的数据库中的SQL特定语句相关联，确保在我们映射的Python对象上执行的操作与它们关联的数据库表正确同步。
- en: 'There are two ways in which we can integrate SQLAlchemy into our application:
    through the use of the declarative mapping that provides a consistent integration
    of tables, Python objects and the data mapper that glues them together, or by
    manually specifying these relations ourselves. Additionally, it is also possible
    to use the so-called SQLAlchemy "core", which eschews the data domain-centric
    approach for one based on the SQL expression language constructs that are included
    within SQLAlchemy.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两种方式将SQLAlchemy集成到我们的应用程序中：通过使用提供表、Python对象和数据映射一致集成的声明式映射，或者通过手动指定这些关系。此外，还可以使用所谓的SQLAlchemy“核心”，它摒弃了基于数据域的方法，而是基于SQL表达语言构造，这些构造包含在SQLAlchemy中。
- en: For the purposes of this (and future) chapters, we will be utilizing the declarative
    approach.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章（以及将来的章节）中，我们将使用声明式方法。
- en: 'To use the declarative mapping functionality, we need to ensure that any model
    classes that we define will inherit from the declarative base `Model` class that
    Flask-SQLAlchemy makes available to us (once we have initialized the extension):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用声明式映射功能，我们需要确保我们定义的任何模型类都将继承自Flask-SQLAlchemy提供给我们的声明基类`Model`类（一旦我们初始化了扩展）：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This `Model` class is, essentially, an instance of a `sqlalchemy.ext.declarative.declarative_base`
    class (with some additional defaults and useful functionalities), which provides
    the object with a metaclass that will handle the appropriate mapping constructs.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Model`类本质上是`sqlalchemy.ext.declarative.declarative_base`类的一个实例（带有一些额外的默认值和有用的功能），它为对象提供了一个元类，该元类将处理适当的映射构造。
- en: 'Once we have our model class definition in place, we will define the details
    about the related SQL table that will be mapped via the class-level attributes
    utilizing `Column` object instances. The first argument to a Column invocation
    is the type constraint that we want to impose on the attribute (which corresponds
    to a specific schema data type supported by the database), along with any optional
    arguments that the type supports, such as the size of the field. Additional arguments
    can be provided to indicate the constraints on the resulting table field definition:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在适当的位置定义了我们的模型类定义，我们将通过使用`Column`对象实例来定义通过类级属性映射的相关SQL表的详细信息。Column调用的第一个参数是我们想要对属性施加的类型约束（对应于数据库支持的特定模式数据类型），以及类型支持的任何可选参数，例如字段的大小。还可以提供其他参数来指示对生成的表字段定义的约束：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As indicated previously, simply defining the attributes will not automatically
    translate into new tables and columns in our database. For this, we will need
    to call `db.create_all()` to initialize the table and column definitions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，仅仅定义属性并不会自动转换为数据库中的新表和列。为此，我们需要调用`db.create_all()`来初始化表和列的定义。
- en: 'We can easily create an instance of this model and assign some values to the
    attributes that we declared in our class definition:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地创建此模型的实例，并为我们在类定义中声明的属性分配一些值：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may have noticed that our user model does not define a `__init__` method,
    yet we are able to pass the `email` and `username` arguments to the object constructor
    when instantiating the above example. This is a feature of the SQLAlchemy declarative
    base class, which automatically assigns the named arguments at object construction
    time to their object attribute counterparts. As a result, defining a concrete
    constructor method for your data models is generally not necessary.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，我们的用户模型没有定义`__init__`方法，但当实例化上面的示例时，我们能够将`email`和`username`参数传递给对象构造函数。这是SQLAlchemy声明基类的一个特性，它会自动将命名参数在对象构造时分配给它们的对象属性对应项。因此，通常不需要为数据模型定义一个具体的构造方法。
- en: 'The instantiation of a model object does not imply that it has been persisted
    to the database. For that, we need to inform the SQLAlchemy session that we wish
    to add a new object to be tracked and have it committed to the database:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 模型对象的实例化并不意味着它已经持久化到数据库中。为此，我们需要通知SQLAlchemy会话，我们希望添加一个新对象以进行跟踪，并将其提交到数据库中：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Once the object has been committed, the `id` attribute will obtain the value
    of the primary key that the underlying database engine has assigned to it:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦对象被提交，`id`属性将获得底层数据库引擎分配给它的主键值：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we want to modify the value of an attribute, for example, change the e-mail
    address of a particular user, we simply need to assign the new value and then
    commit the change:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想修改属性的值，例如，更改特定用户的电子邮件地址，我们只需要分配新值，然后提交更改：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'At this point, you may have noticed that there has not been a single line of
    SQL written for any of the previous operations and might be getting a bit concerned
    that the information embedded in the objects that you''ve created is not being
    persisted to the database. A cursory inspection of the database should put your
    mind at ease:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您可能已经注意到在任何以前的操作中都没有编写过一行SQL，并且可能有点担心您创建的对象中嵌入的信息没有持久保存到数据库中。对数据库的粗略检查应该让您放心：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that the exact name of the SQLite binary may differ on your operating
    system of choice. Additionally, if you chose a database engine other than SQLite
    to follow along with these examples, the relevant commands and results may be
    wildly different.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，SQLite二进制文件的确切名称可能会因您选择的操作系统而异。此外，如果您选择了除SQLite之外的数据库引擎来跟随这些示例，相关的命令和结果可能会大相径庭。
- en: 'And there we have it: SQLAlchemy has successfully managed the relevant SQL
    INSERT and UPDATE statements behind the scenes, letting us work with native Python
    objects and signaling the session when we are ready to persist the data to the
    database.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样：SQLAlchemy成功地在幕后管理了相关的SQL INSERT和UPDATE语句，让我们可以使用本机Python对象，并在准备将数据持久保存到数据库时通知会话。
- en: 'We are not limited to defining class attributes, of course. In many instances
    it may prove useful to declare instance methods on our models so that we can perform
    more complex data manipulations. For example, imagine that we need to obtain the
    primary key ID of a given user and determine whether or not it is an even or odd
    integer. The method declaration would be just as you expect it to be:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不仅限于定义类属性。在许多情况下，声明模型上的实例方法可能会证明很有用，以便我们可以执行更复杂的数据操作。例如，想象一下，我们需要获取给定用户的主键ID，并确定它是偶数还是奇数。方法声明将如你所期望的那样：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The instance method call can be performed as usual with the caveat that before
    the object is committed to the session, the primary key value will be none:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 实例方法调用可以像往常一样执行，但在将对象提交到会话之前，主键值将为none：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Of course, the preceding implementation is trivial and somewhat meaningless
    in the context of most web applications. However, the ability to define model
    instance methods in order to encode business logic is quite convenient and we
    will see some of this with the Flask-Login extension later on in this chapter.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在大多数Web应用程序的上下文中，前面的实现是微不足道且有些毫无意义的。然而，定义模型实例方法以编码业务逻辑的能力非常方便，我们将在本章后面看到Flask-Login扩展中的一些内容。
- en: Snap data models
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 快照数据模型
- en: 'Now that we''ve explored the basics of the SQLAlchemy declarative base and
    the Flask-SQLAlchemy extension using a somewhat simplified model, our next step
    is to flesh out a user data model that is the cornerstone of almost any web application.
    We''ll create this model in the users blueprint in a new `users/models.py` module,
    and utilize the knowledge that we''ve gained regarding SQLAlchemy models to add
    the fields for a user `password` and a `created_on` field to store when the record
    was created. Additionally, we''ll define a few instance methods:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探索了SQLAlchemy声明基础和Flask-SQLAlchemy扩展的基础知识，使用了一个简化的模型，我们的下一步是完善一个用户数据模型，这是几乎任何Web应用程序的基石。我们将在用户蓝图中创建这个模型，在一个新的`users/models.py`模块中利用我们对SQLAlchemy模型的知识，为用户`password`和`created_on`字段添加字段，以存储记录创建的时间。此外，我们将定义一些实例方法：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `is_authenticated`, `is_active`, `is_anonymous`, and `get_id` methods may
    seem arbitrary at the moment but are required for the next step, which will be
    installing and setting up the Flask-Login extension in order to help us manage
    our user authentication system.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`is_authenticated`、`is_active`、`is_anonymous`和`get_id`方法目前可能看起来是任意的，但它们是下一步所需的，即安装和设置Flask-Login扩展，以帮助我们管理用户身份验证系统。'
- en: Flask-Login and Flask-Bcrypt for authentication
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flask-Login和Flask-Bcrypt用于身份验证
- en: 'As we''ve done several times already with other libraries, we will install
    the extensions in our current project''s virtual environment:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次使用其他库进行了安装扩展，我们将在当前项目的虚拟环境中安装这些扩展：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first is a Flask-specific library to normalize much of the standard user
    login process that nearly every web application requires, and the latter will
    allow us to ensure that the user passwords we store in our database are hashed
    using an industry standard algorithm.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是一个特定于Flask的库，用于规范几乎每个Web应用程序都需要的标准用户登录过程，后者将允许我们确保我们在数据库中存储的用户密码使用行业标准算法进行哈希处理。
- en: 'Once installed, we need to instantiate and configure the extension in the usual
    manner. For this, we will add to the `application/__init__.py` module:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，我们需要以通常的方式实例化和配置扩展。为此，我们将添加到`application/__init__.py`模块中：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In order to function correctly, the Flask-Login extension must also know how
    to load a user from your database given only the ID of this user. We must decorate
    a function that will accomplish this, and we''ll insert it at the very end of
    the `application/__init__.py` module for the sake of simplicity:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确运行，Flask-Login扩展还必须知道如何仅通过用户的ID从数据库中加载用户。我们必须装饰一个函数来完成这个任务，并为简单起见，我们将它插入到`application/__init__.py`模块的最后：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now that we've set up the model and required methods/function so that Flask-Login
    can operate correctly, our next step will be to allow users to log in as they
    would on almost any web application using a form.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了模型和所需的方法/函数，以便Flask-Login可以正确运行，我们的下一步将是允许用户像几乎任何Web应用程序一样登录使用表单。
- en: Flask-WTF – form validation and rendering
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flask-WTF - 表单验证和呈现
- en: 'The Flask-WTF ([https://flask-wtf.readthedocs.org/en/latest/](https://flask-wtf.readthedocs.org/en/latest/))
    extension wraps the WTForms library, an incredibly flexible tool for managing
    and validating forms, and makes it readily available for use in Flask applications.
    Let''s install this now and then we''ll define our first form to handle user logins:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Flask-WTF（https://flask-wtf.readthedocs.org/en/latest/）扩展包装了WTForms库，这是一个非常灵活的管理和验证表单的工具，并且可以在Flask应用程序中方便地使用。让我们现在安装它，然后我们将定义我们的第一个表单来处理用户登录：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we will define our first form in our `users/views.py` module:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在我们的`users/views.py`模块中定义我们的第一个表单：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here we defined `LoginForm`, a subclass of `Form`, with the class attributes
    of `username` and `password`. The values of these attributes are `StringField`
    and `PasswordField`, each with their own set of validators to indicate that the
    form data of both fields is required to be non-empty and the password field itself
    should be at least six characters long in order to be considered valid.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了`LoginForm`，它是`Form`的子类，具有`username`和`password`的类属性。这些属性的值分别是`StringField`和`PasswordField`，每个都有自己的验证器集，指示这两个字段的表单数据都需要非空，并且密码字段本身应至少为六个字符长才能被视为有效。
- en: 'Our `LoginForm` class will be utilized in two different ways, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`LoginForm`类将以两种不同的方式被使用，如下所示：
- en: It will render the required form fields in our `login.html` template
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将在我们的`login.html`模板中呈现所需的表单字段
- en: It will validate the POST'ed form data that we will require to complete a successful
    login from a user
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将验证我们需要完成用户成功登录所需的POST表单数据
- en: 'To accomplish the first, we will need to define our HTML layout in `application/templates/layout.html`,
    using the Jinja2 templating language. Note the use of the `current_user` object
    proxy that is made available in all Jinja templates via the Flask-Login extension
    which allows us to determine whether the person who is browsing is already authenticated,
    and if so, then this person should be presented with a slightly different page
    content:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现第一个，我们需要在`application/templates/layout.html`中定义我们的HTML布局，使用Jinja2模板语言。请注意使用`current_user`对象代理，它通过Flask-Login扩展在所有Jinja模板中提供，这使我们能够确定正在浏览的人是否已经认证，如果是，则应该向这个人呈现略有不同的页面内容：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now that we have our extremely basic layout, we need to create our `login.html`
    page at `application/users/templates/users/login.html`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了极其基本的布局，我们需要在“application/users/templates/users/login.html”中创建我们的“login.html”页面：
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The somewhat convoluted path of `application/users/templates/users/index.html`
    is required when using Blueprints due to the manner in which the default template
    loader searches the registered template paths; it allows for some relatively simple
    overriding of blueprint templates in your main application template folder at
    the cost of some additional file tree complexity.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用蓝图时，`application/users/templates/users/index.html`的相对复杂路径是必需的，因为默认模板加载程序搜索注册的模板路径的方式，它允许相对简单地在主应用程序模板文件夹中覆盖蓝图模板，但会增加一些额外的文件树复杂性。
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding code will extend the basic application-level `layout.html` that
    we defined previously and insert the hidden form fields (required for the built-in
    CSRF protection that Flask-WTF offers), form labels, form inputs, and submit button.
    We will also display the inline errors returned to us by WTForms in the event
    that our submitted data does not pass our form validators for the fields in question.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将扩展我们之前定义的基本应用程序级`layout.html`，并插入隐藏的表单字段（Flask-WTF提供的内置CSRF保护所需），表单标签，表单输入和提交按钮。我们还将显示WTForms返回的内联错误，以防我们提交的数据未通过相关字段的表单验证器。
- en: '**Cross-Site Request Forgery** (**CSRF**) *is a type of attack that occurs
    when a malicious website, email, blog, instant message, or program causes a user''s
    web browser to perform an unwanted* *action on a trusted site in which the user
    is currently authenticated. OWASP definition of CSRF*'
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**跨站请求伪造**（**CSRF**）*是一种攻击类型，当恶意网站、电子邮件、博客、即时消息或程序导致用户的网络浏览器在用户当前已认证的受信任站点上执行不需要的操作时发生。OWASP对CSRF的定义*'
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The most common way of preventing a cross-site request forgery is to include
    a token with each HTML form that is sent to the user, which can then be validated
    against a matching token in the session of the authenticated user. If the token
    does not validate, then the form data is rejected, as there is a chance that the
    currently authenticated user did not willingly submit the form data in question.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 防止跨站请求伪造最常见的方法是在发送给用户的每个HTML表单中包含一个令牌，然后可以针对已认证用户的会话中的匹配令牌进行验证。如果令牌无法验证，那么表单数据将被拒绝，因为当前认证用户可能并不是自愿提交相关表单数据。
- en: 'Now that we have created the `login.html` template, we can next hook up a route
    view handler in `application/users/views.py` to process the login and form logic:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了“login.html”模板，接下来我们可以在“application/users/views.py”中挂接一个路由视图处理程序来处理登录和表单逻辑：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Hashing user passwords
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 哈希用户密码
- en: We will update our user model in order to ensure that the passwords are encrypted
    by Flask-Bcrypt when the `password` field is updated. In order to accomplish this,
    we will use a feature of SQLAlchemy that is similar in spirit and functionality
    to the Python `@property` decorator (and the associated `property.setter` method),
    named hybrid attributes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更新我们的用户模型，以确保密码在更新“密码”字段时由Flask-Bcrypt加密。为了实现这一点，我们将使用SQLAlchemy的一个功能，它类似于Python的@property装饰器（以及相关的property.setter方法），名为混合属性。
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Hybrid attributes are so named because they can provide distinctly different
    behaviors when invoked at the class level or instance level. The SQLAlchemy documentation
    is a great place to learn about the various roles that they can fulfill in your
    domain modeling.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 混合属性之所以被命名为混合属性，是因为当在类级别或实例级别调用时，它们可以提供完全不同的行为。SQLAlchemy文档是了解它们在领域建模中可以扮演的各种角色的好地方。
- en: 'We will simply rename the password class-level attribute with `_password` so
    that our hybrid attribute methods do not conflict. Subsequently, we add the hybrid
    attribute methods which encapsulate the password hashing logic on attribute assignment:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简单地将密码类级属性重命名为`_password`，以便我们的混合属性方法不会发生冲突。随后，我们添加了封装了密码哈希逻辑的混合属性方法，以在属性分配时使用：
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In addition to the hybrid property approach, our requirements for password hashing
    on assignment could also be satisfied using a SQLAlchemy TypeDecorator, which
    allows us to augment the existing types (for example, a String column type) with
    additional behaviors.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 除了混合属性方法之外，我们对分配密码哈希的要求也可以通过使用SQLAlchemy TypeDecorator来满足，这允许我们增加现有类型（例如，String列类型）的附加行为。
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In order to generate a user for testing purposes (and to verify that our password
    was hashed on instance construction/attribute assignment), let''s load the Python
    console and create a user instance ourselves using the model that we defined and
    the SQLAlchemy database connection that we created:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成一个用于测试目的的用户（并验证我们的密码是否在实例构造/属性分配时被哈希），让我们加载Python控制台，并使用我们定义的模型和我们创建的SQLAlchemy数据库连接自己创建一个用户实例：
- en: Tip
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember to initialize the database with `db.create_all()` if you `haven't already.`
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有，不要忘记使用`db.create_all()`来初始化数据库。
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Configure an application SECRET_KEY
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置应用程序SECRET_KEY
- en: 'The last little bit that we need is to define an application-wide `SECRET_KEY`
    that will be used by Flask-WTF to sign a token to be used for the prevention of
    CSRF attacks. We will add this key to the application configuration in `application/__init__.py`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的最后一点是定义一个应用程序范围的`SECRET_KEY`，Flask-WTF将使用它来签署用于防止CSRF攻击的令牌。我们将在`application/__init__.py`中的应用程序配置中添加此密钥：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Of course, you'll want to use your own unique secret key; the easiest way to
    accomplish this would be to use your system kernel's random number device via
    `/dev/urandom, available` for most Linux distributions. In python, you can use
    the `os.urandom` method to get a random string with *n* bytes of entropy.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您会想要使用您自己的唯一密钥；最简单的方法是通过`/dev/urandom`来使用您系统内核的随机数设备，对于大多数Linux发行版都是可用的。在Python中，您可以使用`os.urandom`方法来获得一个具有*n*字节熵的随机字符串。
- en: Hook up the blueprint
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接蓝图
- en: 'Before we can run the application, we need to register our newly created users
    blueprint with the Flask application object. This necessitates a slight modification
    to `application/__init__.py`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行应用程序之前，我们需要使用Flask应用程序对象注册我们新创建的用户蓝图。这需要对`application/__init__.py`进行轻微修改：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Let's run this thing
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让我们运行这个东西
- en: 'Now that we''ve put all the little pieces together, let''s run the application
    and make things happen. We will use a similar `run.py` file that we used in the
    previous chapter, which has been adapted to work with our application factory:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经把所有小部件放在一起，让我们运行应用程序并让事情发生。我们将使用一个类似于我们在上一章中使用的`run.py`文件，它已经适应了我们的应用程序工厂的工作方式：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This file is placed as a sibling to the `application` folder and then invoked
    in the usual way:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件被放置在`application`文件夹的同级目录下，然后以通常的方式调用：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Visit `http://localhost:5000/users/login` and you should be presented with
    the `username` and `password` input fields that we created. If you attempt to
    input invalid fields (for example, a username that does not exist), the page will
    render with the relevant error message. If you attempt to log in with the user
    credentials that we created at the interactive prompt earlier, then you should
    be greeted with the text: `Success! You logged in`.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 访问`http://localhost:5000/users/login`，您应该会看到我们创建的`username`和`password`输入字段。如果您尝试输入无效字段（例如，不存在的用户名），页面将显示相关的错误消息。如果您尝试使用我们在交互提示中创建的用户凭据登录，那么您应该会看到文本：`Success!
    You logged in`。
- en: The data model for snaps
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快照的数据模型
- en: Now that we've created our bare bones user models, view functions, and hooked
    up our authentication system, let's create the model required to store our Snaps
    in a new blueprint, under `application/snaps/models.py`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经创建了我们的基本用户模型、视图函数，并连接了我们的身份验证系统，让我们创建一个新的蓝图来存储我们的快照所需的模型，在`application/snaps/models.py`下。
- en: Tip
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Don't forget to create `application/snaps/__init__.py`, otherwise the folder
    will not be recognized as a package!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记创建`application/snaps/__init__.py`，否则该文件夹将无法被识别为一个包！
- en: 'This model will be very similar to our User model but will contain additional
    information regarding the relationships between a user and their snaps. In SQLAlchemy,
    we will describe the relations between records in tables via the use of `ForeignKey`
    objects and the `relationship` methods:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型将与我们的用户模型非常相似，但将包含有关用户和他们的快照之间关系的附加信息。在SQLAlchemy中，我们将通过使用`ForeignKey`对象和`relationship`方法来描述表中记录之间的关系：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Most of this model should be relatively familiar; it is not that much different
    from the one we constructed previously for our User schema. For our snaps, we
    will require a few mandatory attributes, as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型大部分应该是相对熟悉的；它与我们之前为用户模式构建的模型并没有太大的不同。对于我们的快照，我们将需要一些强制属性，如下所示：
- en: '`user_id`: This is the ID of the user who has created the snap. As our current
    implementation will require a user to be authenticated in order to create a snap,
    all the resulting snaps will be tied to the user who posted them. This will also
    make it trivial to extend the system at a later time so as to include the user
    profiles, personal snap statistics, and ability to delete a snap.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user_id`：这是创建快照的用户的ID。由于我们当前的实现将要求用户进行身份验证才能创建快照，所有生成的快照都将与发布它们的用户相关联。这也将使我们在以后轻松扩展系统，以包括用户个人资料、个人快照统计信息和删除快照的能力。'
- en: '`created_on`: This is set in the constructor to be the current UTC timestamp
    and will be used to sort the snaps in descending order to display them in a list
    on our landing page.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`created_on`：这在构造函数中设置为当前的UTC时间戳，并将用于按降序排序以在我们的首页上以列表形式显示它们。'
- en: '`hash_key`: This attribute is also set in the constructor and is the cryptographic
    hash of the contents of the snap concatenated with the timestamp it was created
    on. This gives us a unique, secure ID that is not easily guessable that we can
    use in order to refer to the snap at a later time.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hash_key`：这个属性也在构造函数中设置，是快照内容与创建时间戳的加密哈希。这给了我们一个不容易猜测的唯一安全ID，我们可以用它来在以后引用快照。'
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Even though the conditions that we described for the preceding `hash_key` do
    not guarantee that the value is unique, The uniqueness of the snap hash key is
    also enforced at the database level via a unique index constraint.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们为前面的`hash_key`描述的条件并不保证该值是唯一的，快照哈希键的唯一性也通过数据库级别的唯一索引约束得到了强制。
- en: '`content`: This is the content of the snap itself—the meat and potatoes of
    the model.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content`：这是快照本身的内容——模型的主要部分。'
- en: '`extension`: This is the file extension of the snap, so that we can include
    simple syntax highlighting if we so desire.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extension`：这是快照的文件扩展名，这样我们就可以包含简单的语法高亮。'
- en: '`name`: This is the name of the snap, which is not required to be unique.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：这是快照的名称，不需要是唯一的。'
- en: '`user`: This is a special attribute to declare that every snap instance is
    related to a user instance and will allow us to access the data of the user who
    has created a snap. The `backref` option also specifies that the reverse should
    be possible: that is, accessing all the snaps created by a user via the snaps
    attribute on a user instance.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user`：这是一个特殊属性，声明每个快照实例都与一个用户实例相关联，并允许我们访问创建快照的用户的数据。`backref`选项还指定了反向应该是可能的：也就是说，通过用户实例上的快照属性访问用户创建的所有快照。'
- en: Better defaults with content-sensitive default functions
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用内容敏感的默认函数更好的默认值
- en: 'One improvement that can be made to the preceding model is the removal of the
    explicit `__init__` method. The only reason that it was defined initially was
    to ensure that the `hash_key` field could be constructed from the value of the
    content field. While in most instances the explicit object constructor that was
    defined would be good enough, SQLAlchemy provides us with the functionality that
    will allow us to set the default value of one field based on the contents of another.
    This is known as a **Context–Sensitive Default Function** and can be declared
    as such at the top of the `application/snaps/models.py` module:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对前面的模型可以进行的一个改进是删除显式的`__init__`方法。最初定义它的唯一原因是确保可以从内容字段的值构造`hash_key`字段。虽然在大多数情况下，定义的显式对象构造函数已经足够好了，但SQLAlchemy提供了功能，允许我们根据另一个字段的内容设置一个字段的默认值。这被称为**上下文敏感的默认函数**，可以在`application/snaps/models.py`模块的顶部声明为这样：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Once this method exists, we can define the default argument of the `hash_key`
    column to be our `content_hash` content-sensitive default:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦存在这个方法，我们就可以将`hash_key`列的默认参数定义为我们的`content_hash`内容敏感的默认值：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Snap view handlers
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快照视图处理程序
- en: 'Continuing on, we will now create the views and templates that are required
    to list and add snaps. To this end, we will instantiate a `Blueprint` object in
    our `application/snaps/views.py` and declare our route handlers:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建所需的视图和模板，以列出和添加快照。为此，我们将在`application/snaps/views.py`中实例化一个`Blueprint`对象，并声明我们的路由处理程序：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that we have wrapped our `add()` route handler with a `@login_required`
    decorator, which will prevent unauthenticated users from accessing this endpoint
    for all defined HTTP verbs (GET and POST, in this case) and return a 401.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经用`@login_required`装饰器包装了我们的`add()`路由处理程序，这将阻止未经身份验证的用户访问此端点的所有定义的HTTP动词（在本例中为GET和POST），并返回401。
- en: Note
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Instead of having the server return an HTTP 401 Unauthorized, Flask-Login can
    be configured to redirect the unauthenticated user to the login page by setting
    the `login_manager.login_view` attribute to the `url_for` compatible location
    of the login page itself, which in our case would be `users.login`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 与其让服务器返回HTTP 401未经授权，不如配置Flask-Login将未经身份验证的用户重定向到登录页面，方法是将`login_manager.login_view`属性设置为登录页面本身的`url_for`兼容位置，而在我们的情况下将是`users.login`。
- en: 'Now, let''s create the WTForm object to represent a snap and place it in the
    `application/snaps/views.py` module:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建WTForm对象来表示一个快照，并将其放在`application/snaps/views.py`模块中：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Tip
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: While it is somewhat a matter of personal preference, the forms created with
    WTForms (or any other similar abstraction) could be placed alongside the models
    instead of the views. Or, to go a step further, if you have many different forms
    with complex data relationships, it may also be advisable to put all the declared
    forms in their own module in your application.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这在某种程度上是个人偏好的问题，但使用WTForms（或任何其他类似的抽象）创建的表单可以放在模型旁边，而不是视图。或者，更进一步地，如果您有许多不同的表单与复杂的数据关系，也许将所有声明的表单放在应用程序的自己的模块中也是明智的。
- en: 'Our snaps require a name, an extension, and the content of the snap itself,
    and we''ve encapsulated these basic requirements in the preceding Form declaration.
    Let''s implement our `add()` route handler:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的快照需要一个名称、一个扩展名和快照本身的内容，我们已经在前面的表单声明中封装了这些基本要求。让我们实现我们的`add()`路由处理程序：
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Briefly, we will validate the submitted POST data in order to ensure that it
    satisfies the validators that we specified in the `SnapForm` class declaration
    and then proceed to instantiate a `Snap` object with the supplied form data and
    ID of the currently authenticated user. Once built, we will add this object to
    the current SQLAlchemy session and then attempt to commit it to the database.
    If a SQLAlchemy exception occurs (all SQLAlchemy exceptions inherit from `salalchemy.exc.SQLALchemyError`),
    we will log an exception to the default application log handler and set a flash
    message so that the user is alerted that something unexpected has occurred.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们将验证提交的POST数据，以确保它满足我们在`SnapForm`类声明中指定的验证器，然后继续使用提供的表单数据和当前认证用户的ID来实例化一个`Snap`对象。构建完成后，我们将将此对象添加到当前的SQLAlchemy会话中，然后尝试将其提交到数据库。如果发生SQLAlchemy异常（所有SQLAlchemy异常都继承自`salalchemy.exc.SQLALchemyError`），我们将记录异常到默认的应用程序日志处理程序，并设置一个闪存消息，以便提醒用户发生了意外情况。
- en: 'For the sake of completeness, we will include the extremely simple `application/snaps/templates/snaps/add.html`
    Jinja template here:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，我们将在这里包括极其简单的`application/snaps/templates/snaps/add.html` Jinja模板：
- en: '[PRE36]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Once we''ve completed the `add()` handler and associated template, now it''s
    time to move on to the `listing()` handler, which will incidentally be the landing
    page for our application. The listing page will, somewhat unimaginatively, show
    a listing of the 20 most recent snaps which have been posted, in reverse chronological
    order:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了`add()`处理程序和相关模板后，现在是时候转向`listing()`处理程序了，这将偶然成为我们应用程序的登陆页面。列表页面将以相反的时间顺序显示最近发布的20个快照：
- en: '[PRE37]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `application/snaps/templates/snaps/add.html` Jinja template renders the
    snaps that we''ve queried from the database:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`application/snaps/templates/snaps/add.html` Jinja模板呈现了我们从数据库中查询到的快照：'
- en: '[PRE38]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, we must ensure that the snaps blueprint that we''ve created is loaded
    in the application and prefixed to the root/URI path by adding it to the `application/__init__.py`
    module:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须确保我们创建的快照蓝图已加载到应用程序中，并通过将其添加到`application/__init__.py`模块来添加到根/URI路径：
- en: '[PRE39]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In order to test our new functionality, we''ll need to add the newly created
    snap model to our database. We can accomplish this by executing the `db.create_all()`
    function that we described earlier in the chapter. As we tend to run this command
    quite a lot, let''s put it in a script sibling to our main application package
    folder and name the file `database.py`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的新功能，我们需要将新创建的快照模型添加到我们的数据库中。我们可以通过执行我们在本章前面描述的`db.create_all()`函数来实现这一点。由于我们经常运行这个命令，让我们将其放在与我们的主应用程序包文件同级的脚本中，并将文件命名为`database.py`：
- en: '[PRE40]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Once in place, we can simply execute the script with the Python interpreter
    in order to create the new snap model in our database:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦就位，我们可以简单地使用Python解释器执行脚本，以在我们的数据库中创建新的快照模型：
- en: '[PRE41]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now that our database should be up to date with our model definitions, let''s
    ensure that the application runs as expected:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的数据库应该已经根据我们的模型定义更新了，让我们确保应用程序按预期运行：
- en: '[PRE42]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Assuming that there were no errors, you should be able to visit the URL that
    is displayed and log in with the credentials of one of the users that we created
    earlier in the chapter. You can, of course, create a new user via the interactive
    Python interpreter and then use these credentials so as to test the authentication
    functionality of the application:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 假设没有错误，您应该能够访问显示的URL，并使用我们在本章早些时候创建的用户之一的凭据登录。当然，您可以通过交互式Python解释器创建一个新用户，然后使用这些凭据来测试应用程序的身份验证功能：
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: After having gone through this chapter and building the Snap application, we
    have seen several facets of how Flask may be augmented with the use of extensions,
    such as Flask-WTF (for web form creation and validation), Flask-SQLAlchemy (for
    simple integration with the SQLAlchemy database abstraction library), Flask-Bcrypt
    (for password hashing), and Flask-Login (to abstract much of the standard implementation
    requirements for a simple user login system). While Flask itself is relatively
    spartan, the ecology of extensions that are available make it such that building
    a fully fledged user-authenticated application may be done quickly and relatively
    painlessly.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过阅读本章并构建Snap应用程序，我们已经看到了Flask如何通过使用扩展来增强，例如Flask-WTF（用于Web表单创建和验证）、Flask-SQLAlchemy（用于与SQLAlchemy数据库抽象库的简单集成）、Flask-Bcrypt（用于密码哈希）和Flask-Login（用于简单用户登录系统的标准实现要求的抽象）。虽然Flask本身相对简洁，但可用的扩展生态系统使得构建一个完全成熟的用户认证应用程序可以快速且相对轻松地完成。
- en: We explored the aforementioned extensions and their usefulness, including Flask-WTF
    and Flask-SQLAlchemy, and architected a simple blueprint-based application that
    integrated all of the above components. While the Snap application itself is quite
    simple and leaves much to be implemented, it lends itself very easily to updates
    and additional features.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了上述扩展及其有用性，包括Flask-WTF和Flask-SQLAlchemy，并设计了一个基于蓝图的简单应用程序，集成了上述所有组件。虽然Snap应用程序本身非常简单，还有很多功能需要实现，但它非常容易更新和添加其他功能。
- en: In the next chapter, we will build an application with a more complex data model
    and include some social features that are common among today's web apps. Moreover,
    it will be built and set up for unit and functional testing, something that no
    trivial application should go without.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建一个具有更复杂数据模型的应用程序，并包含一些在今天的Web应用程序中常见的社交功能。此外，它将被构建和设置为单元和功能测试，这是任何微不足道的应用程序都不应该缺少的功能。
