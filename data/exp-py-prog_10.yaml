- en: Chapter 10. Test-Driven Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章 测试驱动开发
- en: '**Test-Driven Development** (**TDD**) is a simple technique to produce high
    quality software. It is widely used in the Python community, but it is also very
    popular in other communities.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试驱动开发**（**TDD**）是一种生产高质量软件的简单技术。它在Python社区中被广泛使用，但在其他社区中也很受欢迎。'
- en: Testing is especially important in Python due to its dynamic nature. It lacks
    static typing so many, even minute, errors won't be noticed until the code is
    run and each of its line is executed. But the problem is not only how types in
    Python work. Remember that most bugs are not related to bad syntax usage, but
    rather to logical errors and subtle misunderstandings that can lead to major failures.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python的动态特性，测试尤为重要。它缺乏静态类型，因此许多甚至微小的错误直到代码运行并执行每一行时才会被注意到。但问题不仅仅在于Python中类型的工作方式。请记住，大多数错误与不良语法使用无关，而是与逻辑错误和微妙的误解有关，这可能导致重大故障。
- en: 'This chapter is split into two parts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为两个部分：
- en: '*I don''t test*, which advocates TDD and quickly describes how to do it with
    the standard library'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*我不测试*，倡导TDD并快速描述如何使用标准库进行测试'
- en: '*I do test*, which is intended for developers who practice tests and wish to
    get more out of them'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*我进行测试*，这是为那些进行测试并希望从中获得更多的开发人员设计的'
- en: I don't test
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我不测试
- en: If you have already been convinced to TDD, you should move to the next section.
    It will focus on advanced techniques and tools for making your life easier when
    working with tests. This part is mainly intended for those who are not using this
    approach and tries to advocate its usage.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经被说服使用TDD，您应该转到下一节。它将专注于高级技术和工具，以使您在处理测试时的生活更轻松。这部分主要是为那些不使用这种方法并试图倡导其使用的人而设计的。
- en: Test-driven development principles
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试驱动开发原则
- en: 'The test-driven development process, in its simplest form, consists of three
    steps:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发过程，最简单的形式包括三个步骤：
- en: Writing automated tests for a new functionality or improvement that has not
    been implemented yet.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为尚未实现的新功能或改进编写自动化测试。
- en: Providing minimal code that just passes all the defined tests.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供最小的代码，只需通过所有定义的测试即可。
- en: Refactoring code to meet the desired quality standards.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重构代码以满足期望的质量标准。
- en: The most important fact to remember about this development cycle is that tests
    should be written before implementation. It is not an easy task for unexperienced
    developers, but it is the only approach which guarantees that the code you are
    going to write will be testable.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个开发周期最重要的事实是，在实现之前应该先编写测试。这对于经验不足的开发人员来说并不容易，但这是唯一保证您要编写的代码是可测试的方法。
- en: 'For example, a developer who is asked to write a function that checks whether
    the given number is a prime number, writes a few examples on how to use it and
    what the expected results are:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个被要求编写一个检查给定数字是否为质数的函数的开发人员，会写一些关于如何使用它以及预期结果的示例：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The developer that implements the feature does not need to be the only one responsible
    for providing tests. The examples can be provided by another person as well. For
    instance, very often the official specifications of network protocols or cryptography
    algorithms provide test vectors that are intended to verify correctness of implementation.
    These are a perfect basis for test cases.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 实现功能的开发人员不需要是唯一负责提供测试的人。示例也可以由其他人提供。例如，网络协议或密码算法的官方规范经常提供旨在验证实现正确性的测试向量。这些是测试用例的完美基础。
- en: 'From there, the function can be implemented until the preceding examples work:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，函数可以被实现，直到前面的示例起作用：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A bug or an unexpected result is a new example of usage the function should
    be able to deal with:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 错误或意外结果是函数应该能够处理的新用法示例：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The code can be changed accordingly, until the new test passes:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可以相应地更改，直到新的测试通过：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And more cases show that the implementation is still incomplete:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多情况表明实现仍然不完整：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The updated code is as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的代码如下：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'From there, all tests can be gathered in a test function, which is run every
    time the code evolves:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，所有测试可以被收集在一个测试函数中，每当代码发展时运行：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Every time we come up with a new requirement, the `test_is_prime()` function
    should be updated first to define the expected behavior of the `is_prime()` function.
    Then, the test is run to check if the implementation delivers the desired results.
    Only if the tests are known to be failing, there is a need to update code for
    the tested function.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们提出一个新的需求时，“test_is_prime（）”函数应该首先更新以定义“is_prime（）”函数的预期行为。然后，运行测试以检查实现是否提供了期望的结果。只有当已知测试失败时，才需要更新经过测试的函数的代码。
- en: 'Test-driven development provides a lot of benefits:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发提供了许多好处：
- en: It helps to prevent software regression
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有助于防止软件回归
- en: It improves software quality
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提高了软件质量
- en: It provides a kind of low-level documentation of code behavior
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了代码行为的一种低级文档
- en: It allows you to produce robust code faster in short development cycles
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许您在短时间内更快地生成健壮的代码
- en: The best convention to deal in with test is to gather all of them in a single
    module or package (usually named `tests`) and have an easy way to run the whole
    suite using a single shell command. Fortunately, there is no need to build whole
    test tool chains all by yourself. Both Python standard library and Python Package
    Index come with plenty of test frameworks and utilities that allow you to build,
    discover, and run tests in a convenient way. We will discuss the most notable
    examples of such packages and modules later in this chapter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 处理测试的最佳约定是将它们全部收集在一个单独的模块或包中（通常命名为“tests”），并且有一种简单的方法可以使用单个shell命令运行整个测试套件。幸运的是，没有必要自己构建整个测试工具链。Python标准库和Python软件包索引都提供了大量的测试框架和实用工具，可以让您以方便的方式构建、发现和运行测试。我们将在本章后面讨论这些包和模块中最值得注意的例子。
- en: Preventing software regression
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 防止软件回归
- en: We all face software regression issues in our developer lives. Software regression
    is a new bug introduced by a change. It manifests when features or functionalities
    that were known to be working in the previous versions of the software get broken
    and stop working at some point during project development.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在开发人员生活中都会面临软件回归问题。软件回归是由更改引入的新错误。它表现为在软件先前版本中已知的功能或功能在项目开发过程中的某个时刻出现故障并停止工作。
- en: The main reason for regressions is high complexity of software. At some point,
    it is impossible to guess what a single change in the codebase might lead to.
    Changing some code might break some other features and sometimes lead to vicious
    side effects, such as silently corrupting data. And high complexity is not only
    the problem of huge codebases. There is, of course, obvious correlation between
    the amount of code and its complexity, but even small projects (few hundredths/thousands
    lines of code) may have such convoluted architecture that it is hard to predict
    all consequences of relatively small changes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 回归的主要原因是软件的复杂性。在某个时刻，不可能猜测代码库中的单个更改可能导致什么结果。更改某些代码可能会破坏其他功能，有时会导致恶意副作用，比如悄悄地损坏数据。高复杂性不仅是庞大代码库的问题。当然，代码量和复杂性之间存在明显的相关性，但即使是小型项目（几百/几千行代码）的架构也可能如此复杂，以至于很难预测相对较小的更改的所有后果。
- en: To avoid regression, the whole set of features the software provides should
    be tested every time a change occurs. Without this, you are not able to reliably
    tell difference between bugs that have always existed in your software from the
    new ones introduced to parts that were working correctly just some time ago.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免回归，软件提供的整套功能应该在每次更改发生时进行测试。如果没有这样做，你将无法可靠地区分软件中一直存在的错误和最近在正确工作的部分引入的新错误。
- en: Opening up a codebase to several developers amplifies the problem, since each
    person will not be fully aware of all the development activities. While having
    a version control system prevents conflicts, it does not prevent all unwanted
    interactions.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 向多个开发人员开放代码库会加剧这个问题，因为每个人都不会完全了解所有的开发活动。虽然版本控制系统可以防止冲突，但它并不能阻止所有不必要的交互。
- en: TDD helps reduce software regression. The whole software can be automatically
    tested after each change. This will work as long as each feature has the proper
    set of tests. When TDD is properly done, the testbase grows together with the
    codebase.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: TDD有助于减少软件回归。每次更改后，整个软件都可以自动测试。只要每个功能都有适当的测试集，这种方法就有效。当TDD正确执行时，测试基础会随着代码基础一起增长。
- en: Since a full test campaign can last for quite a long time, it is a good practice
    to delegate it to some continuous integration system which can do the work in
    the background. We discussed such solutions already in [Chapter 8](ch08.html "Chapter 8. Managing
    Code"), *Managing Code*. Nevertheless, the local re-launching of the tests should
    be performed manually by the developer too, at least for the concerned modules.
    Relying only on continuous integration will have a negative effect on the developers'
    productivity. Programmers should be able to run selections of tests easily in
    their environments. This is the reason why you should carefully choose testing
    tools for the project.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于完整的测试活动可能需要相当长的时间，将其委托给一些可以在后台执行工作的持续集成系统是一个好的做法。我们在[第8章](ch08.html "第8章 管理代码")“管理代码”中已经讨论过这样的解决方案。然而，开发人员也应该手动执行测试的本地重新启动，至少对于相关模块来说是如此。仅依赖持续集成会对开发人员的生产力产生负面影响。程序员应该能够在其环境中轻松地运行测试的选择。这就是为什么你应该仔细选择项目的测试工具。
- en: Improving code quality
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提高代码质量
- en: 'When a new module, class, or a function is written, a developer focuses on
    how to write it and how to produce the best piece of code he or she can. But while
    he or she is concentrating on algorithms, he or she might lose the user''s point
    of view: How and when will his or her function be used? Are the arguments easy
    and logical to use? Is the name of the API right?'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写新的模块、类或函数时，开发人员会专注于如何编写以及如何产生最佳的代码。但是，当他们专注于算法时，他们可能会失去用户的视角：他们的函数将如何被使用？参数是否易于使用和合乎逻辑？API的名称是否正确？
- en: This is done by applying the tips described in the previous chapters, such as
    [Chapter 4](ch04.html "Chapter 4. Choosing Good Names"), *Choosing Good Names*.
    But the only way to do it efficiently is to write usage examples. This is the
    moment when the developer realizes if the code he or she wrote is logical and
    easy to use. Often, the first refactoring occurs right after the module, class,
    or function is finished.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过应用前几章描述的技巧来完成的，比如[第4章](ch04.html "第4章 选择好的名称")，“选择好的名称”。但要高效地做到这一点，唯一的方法就是写使用示例。这是开发人员意识到他或她编写的代码是否合乎逻辑且易于使用的时刻。通常，在模块、类或函数完成后，第一次重构就会发生。
- en: Writing tests, which are use cases for the code, helps in having a user point
    of view. Developers will, therefore, often produce a better code when they use
    TDD. It is difficult to test gigantic functions and huge monolithic classes. Code
    that is written with testing in mind tends to be architected more cleanly and
    modularly.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试，这些测试是代码的用例，有助于从用户的角度进行思考。因此，当开发人员使用TDD时，通常会产生更好的代码。测试庞大的函数和庞大的单块类是困难的。考虑测试的代码往往更清晰、更模块化。
- en: Providing the best developer documentation
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提供最佳的开发人员文档
- en: Tests are the best place for a developer to learn how software works. They are
    the use cases the code was primarily created for. Reading them provides a quick
    and deep insight into how the code works. Sometimes an example is worth a thousand
    words.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是开发人员了解软件运行方式的最佳途径。它们是代码最初创建的用例。阅读它们可以快速深入地了解代码的运行方式。有时，一个例子胜过千言万语。
- en: The fact that these tests are always up to date with the codebase makes them
    the best developer documentation that a piece of software can have. Tests don't
    go stale in the same way documentation does, otherwise they would fail.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试始终与代码库保持最新，使它们成为软件可以拥有的最佳开发人员文档。测试不会像文档一样过时，否则它们会失败。
- en: Producing robust code faster
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更快地生成健壮的代码
- en: Writing without testing leads to long debugging sessions. A consequence of a
    bug in one module might manifest itself in a completely different part of the
    software. Since you don't know who to blame, you spend an inordinate amount of
    time debugging. It's better to fight small bugs one at a time when a test fails,
    because you'll have a better clue as to where the real problem is. And testing
    is often more fun than debugging because it is coding.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 没有测试的编写会导致长时间的调试会话。一个模块中的错误可能会在软件的完全不同部分表现出来。由于您不知道该责怪谁，您会花费大量时间进行调试。当测试失败时，最好一次只解决一个小错误，因为这样您会更好地了解真正的问题所在。测试通常比调试更有趣，因为它是编码。
- en: If you measure the time taken to fix the code together with the time taken to
    write it, it will usually be longer than the time a TDD approach would take. This
    is not obvious when you start a new piece of code. This is because the time taken
    to set up a test environment and write the first few tests is extremely long compared
    to the time taken just to write the first pieces of code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您测量修复代码所花费的时间以及编写代码所花费的时间，通常会比TDD方法所需的时间长。当您开始编写新的代码时，这并不明显。这是因为设置测试环境并编写前几个测试所花费的时间与仅编写代码的时间相比极长。
- en: But there are some test environments that are really hard to set up. For instance,
    when your code interacts with an LDAP or an SQL server, writing tests is not obvious
    at all. This is covered in the *Fakes and mocks* section in this chapter.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，有些测试环境确实很难设置。例如，当您的代码与LDAP或SQL服务器交互时，编写测试根本不明显。这在本章的*伪造和模拟*部分中有所涵盖。
- en: What kind of tests?
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么样的测试？
- en: There are several kinds of tests that can be made on any software. The main
    ones are **acceptance tests** (or **functional tests**) and **unit tests**, and
    these are the ones that most people think of when discussing the topic of software
    testing. But there are a few other kinds of tests that you can use in your project.
    We will discuss some of them shortly in this section.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 任何软件都可以进行几种测试。主要的是**验收测试**（或**功能测试**）和**单元测试**，这是大多数人在讨论软件测试主题时所考虑的。但是在您的项目中，还有一些其他测试类型可以使用。我们将在本节中简要讨论其中一些。
- en: Acceptance tests
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验收测试
- en: An acceptance test focuses on a feature and deals with the software like a black
    box. It just makes sure that the software really does what it is supposed to do,
    using the same media as that of the users and controlling the output. These tests
    are usually written out of the development cycle to validate that the application
    meets the requirements. They are usually run as a checklist over the software.
    Often, these tests are not done through TDD and are built by managers, QA staff,
    or even customers. In that case, they are often called **user acceptance tests**.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 验收测试侧重于功能，并处理软件就像黑匣子一样。它只是确保软件确实做了它应该做的事情，使用与用户相同的媒体并控制输出。这些测试通常是在开发周期之外编写的，以验证应用程序是否满足要求。它们通常作为软件的检查表运行。通常，这些测试不是通过TDD进行的，而是由经理、QA人员甚至客户构建的。在这种情况下，它们通常被称为**用户验收测试**。
- en: Still, they can and they should be done with TDD principles. Tests can be provided
    before the features are written. Developers get a pile of acceptance tests, usually
    made out of the functional specifications, and their job is to make sure the code
    will pass all of them.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，它们可以并且应该遵循TDD原则。在编写功能之前可以提供测试。开发人员通常会得到一堆验收测试，通常是由功能规格书制作的，他们的工作是确保代码能够通过所有这些测试。
- en: 'The tools used to write those tests depend on the user interface the software
    provides. Some popular tools used by Python developers are:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 编写这些测试所使用的工具取决于软件提供的用户界面。一些Python开发人员使用的流行工具包括：
- en: '| Application type | Tool |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 应用程序类型 | 工具 |'
- en: '| --- | --- |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Web application | Selenium (for Web UI with JavaScript) |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| Web应用程序 | Selenium（用于带有JavaScript的Web UI）|'
- en: '| Web application | `zope.testbrowser` (doesn''t test JS) |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: Web应用程序 | `zope.testbrowser`（不测试JS）|
- en: '| WSGI application | `paste.test.fixture` (doesn''t test JS) |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| WSGI应用程序 | `paste.test.fixture`（不测试JS）|'
- en: '| Gnome Desktop application | dogtail |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| Gnome桌面应用程序 | dogtail |'
- en: '| Win32 Desktop application | pywinauto |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| Win32桌面应用程序 | pywinauto |'
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For an extensive list of functional testing tools, Grig Gheorghiu maintains
    a wiki page at [https://wiki.python.org/moin/PythonTestingToolsTaxonomy](https://wiki.python.org/moin/PythonTestingToolsTaxonomy).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于功能测试工具的广泛列表，Grig Gheorghiu在[https://wiki.python.org/moin/PythonTestingToolsTaxonomy](https://wiki.python.org/moin/PythonTestingToolsTaxonomy)上维护了一个wiki页面。
- en: Unit tests
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit tests are low-level tests that perfectly fit test-driven development. As
    the name suggests, they focus on testing software units. A software unit can be
    understood as the smallest testable piece of the application code. Depending on
    the application, the size may vary from whole modules to a single method or function,
    but usually unit tests are written for the smallest fragments of code possible.
    Unit tests usually isolate the tested unit (module, class, function, and so on)
    from the rest of the application and other units. When external dependencies are
    required, such as web APIs or databases, they are often replaced by fake objects
    or mocks.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是完全适合测试驱动开发的低级测试。顾名思义，它们专注于测试软件单元。软件单元可以理解为应用程序代码的最小可测试部分。根据应用程序的不同，大小可能从整个模块到单个方法或函数不等，但通常单元测试是针对可能的最小代码片段编写的。单元测试通常会将被测试的单元（模块、类、函数等）与应用程序的其余部分和其他单元隔离开来。当需要外部依赖项时，例如Web
    API或数据库，它们通常会被伪造对象或模拟替换。
- en: Functional tests
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 功能测试
- en: Functional tests focus on whole features and functionalities instead of small
    code units. They are similar in their purpose to acceptance tests. The main difference
    is that functional tests do not necessarily need to use the same interface that
    a user does. For instance, when testing web applications, some of the user interactions
    (or its consequences) can be simulated by synthetic HTTP requests or direct database
    access, instead of simulating real page loading and mouse clicks.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 功能测试侧重于整个功能和功能，而不是小的代码单元。它们在目的上类似于验收测试。主要区别在于功能测试不一定需要使用用户相同的界面。例如，在测试Web应用程序时，一些用户交互（或其后果）可以通过合成的HTTP请求或直接数据库访问来模拟，而不是模拟真实页面加载和鼠标点击。
- en: This approach is often easier and faster than testing with tools used in *user
    acceptance tests*. The downside of limited functional tests is that they tend
    not to cover enough parts of the application where different abstraction layers
    and components meet. Tests that focus on such *meeting points* are often called
    integration tests.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法通常比使用*用户验收测试*中使用的工具进行测试更容易和更快。有限功能测试的缺点是它们往往不能涵盖应用程序的足够多的部分，其中不同的抽象层和组件相遇。侧重于这种*相遇点*的测试通常被称为集成测试。
- en: Integration tests
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成测试
- en: Integration tests represent a higher level of testing than unit tests. They
    test bigger parts of code and focus on situations where many application layers
    or components meet and interact with each other. The form and scope of integration
    tests varies depending on the project's architecture and complexity. For example,
    in small and monolithic projects, this may be as simple as running more complex
    functional tests and allowing them to interact with real backing services (databases,
    caches, and so on) instead of mocking or faking them. For complex scenarios or
    products that are built from multiple services, the real integration tests may
    be very extensive and even require running the whole project in a big distributed
    environment that mirrors the production.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试代表了比单元测试更高级的测试水平。它们测试代码的更大部分，并侧重于许多应用层或组件相遇和相互交互的情况。集成测试的形式和范围取决于项目的架构和复杂性。例如，在小型和单片项目中，这可能只是运行更复杂的功能测试，并允许它们与真实的后端服务（数据库、缓存等）进行交互，而不是模拟或伪造它们。对于复杂的场景或由多个服务构建的产品，真正的集成测试可能非常广泛，甚至需要在模拟生产环境的大型分布式环境中运行整个项目。
- en: Integration tests are often very similar to functional tests and the border
    between them is very blurry. It is very common that integration tests are also
    logically testing separate functionalities and features.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试通常与功能测试非常相似，它们之间的边界非常模糊。很常见的是，集成测试也在逻辑上测试独立的功能和特性。
- en: Load and performance testing
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 负载和性能测试
- en: Load tests and performance tests provide objective information about code efficiency
    rather than its correctness. The terms of load testing and performance testing
    are used by some interchangeably but the first one in fact refers to a limited
    aspect of performance. Load testing focuses on measuring how code behaves under
    some artificial demand (load). This is a very popular way of testing web applications
    where load is understood as web traffic from real users or programmatic clients.
    It is important to note that load tests tend to cover whole requests to the application
    so are very similar to integration and functional tests. This makes it important
    to be sure that tested application components are fully verified to be working
    correctly. Performance tests are generally all the tests that aim to measure code
    performance and can target even small units of code. So, load tests are only a
    specific subtype of performance tests.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 负载测试和性能测试提供的是关于代码效率而不是正确性的客观信息。负载测试和性能测试这两个术语有时可以互换使用，但实际上前者指的是性能的有限方面。负载测试侧重于衡量代码在某种人为需求（负载）下的行为。这是测试Web应用程序的一种非常流行的方式，其中负载被理解为来自真实用户或程序化客户端的Web流量。重要的是要注意，负载测试往往涵盖了对应用程序的整个请求，因此与集成和功能测试非常相似。这使得确保被测试的应用程序组件完全验证工作正常非常重要。性能测试通常是旨在衡量代码性能的所有测试，甚至可以针对代码的小单元。因此，负载测试只是性能测试的一个特定子类型。
- en: They are special kind of tests because they do not provide binary results (failure/success)
    but only some performance quality measurement. This means that single results
    need to be interpreted and/or compared with results of different test runs. In
    some cases, the project requirements may set some hard time or resource constraints
    on the code but this does not change the fact that there is always some arbitrary
    interpretation involved in these kinds of testing approaches.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是一种特殊类型的测试，因为它们不提供二进制结果（失败/成功），而只提供一些性能质量的测量。这意味着单个结果需要被解释和/或与不同测试运行的结果进行比较。在某些情况下，项目要求可能对代码设置一些严格的时间或资源约束，但这并不改变这些测试方法中总是涉及某种任意解释的事实。
- en: Load performance tests are a great tool during the development of any software
    that needs to fulfill some **Service** **Level Agreements** because it helps to
    reduce the risk of compromising the performance of critical code paths. Anyway,
    it should not be overused.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 负载性能测试是任何需要满足一些**服务****级别协议**的软件开发过程中的一个重要工具，因为它有助于降低关键代码路径性能受损的风险。无论如何，不应该过度使用。
- en: Code quality testing
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码质量测试
- en: 'Code quality does not have the arbitrary scale that would say for definite
    if it is bad or good. Unfortunately, the abstract concept of code quality cannot
    be measured and expressed in the form of numbers. But instead, we can measure
    various metrics of the software that are known to be highly correlated with the
    quality of code. To name a few:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 代码质量没有一个确定的任意刻度，可以明确地说它是好还是坏。不幸的是，代码质量这个抽象概念无法用数字形式来衡量和表达。但相反，我们可以测量与代码质量高度相关的软件的各种指标。举几个例子：
- en: The number of code style violations
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码风格违规的数量
- en: The amount of documentation
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档的数量
- en: Complexity metrics, such as McCabe's cyclomatic complexity
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂度度量，如McCabe的圈复杂度
- en: The number of static code analysis warnings
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态代码分析警告的数量
- en: Many projects use code quality testing in their continuous integration workflows.
    The good and popular approach is to test at least basic metrics (static code analysis
    and code style violations) and not allow the merging of any code to the mainstream
    that makes these metrics lower.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 许多项目在其持续集成工作流程中使用代码质量测试。一个良好且流行的方法是至少测试基本指标（静态代码分析和代码风格违规），并且不允许将任何代码合并到主流中使这些指标降低。
- en: Python standard test tools
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python标准测试工具
- en: 'Python provides two main modules in the standard library to write tests:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了标准库中的两个主要模块来编写测试：
- en: '`unittest` ([https://docs.python.org/3/library/unittest.html](https://docs.python.org/3/library/unittest.html)):
    This is the standard and most common Python unit testing framework based on Java''s
    JUnit and was originally written by Steve Purcell (formerly `PyUnit`)'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unittest` ([https://docs.python.org/3/library/unittest.html](https://docs.python.org/3/library/unittest.html))：这是基于Java的JUnit的标准和最常见的Python单元测试框架，最初由Steve
    Purcell（以前是`PyUnit`）编写'
- en: '`doctest` ([https://docs.python.org/3/library/doctest.html](https://docs.python.org/3/library/doctest.html)):
    This is a literate programing testing tool with interactive usage examples'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doctest` ([https://docs.python.org/3/library/doctest.html](https://docs.python.org/3/library/doctest.html))：这是一个具有交互式使用示例的文学编程测试工具'
- en: unittest
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: unittest
- en: '`unittest` basically provides what JUnit does for Java. It offers a base class
    called `TestCase`, which has an extensive set of methods to verify the output
    of function calls and statements.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest`基本上提供了Java的JUnit所提供的功能。它提供了一个名为`TestCase`的基类，该类具有一系列广泛的方法来验证函数调用和语句的输出。'
- en: This module was created to write unit tests, but acceptance tests can also be
    written with it as long as the test uses the user interface. For instance, some
    testing frameworks provide helpers to drive tools such as Selenium on top of `unittest`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块是为了编写单元测试而创建的，但只要测试使用了用户界面，也可以用它来编写验收测试。例如，一些测试框架提供了辅助工具来驱动诸如Selenium之类的工具，这些工具是建立在`unittest`之上的。
- en: 'Writing a simple unit test for a module using `unittest` is done by subclassing
    `TestCase` and writing methods with the `test` prefix. The final example from
    the *Test-driven development principles* section will look like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`unittest`为模块编写简单的单元测试是通过子类化`TestCase`并编写以`test`前缀开头的方法来完成的。*测试驱动开发原则*部分的最终示例将如下所示：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `unittest.main()` function is the utility that allows to make the whole
    module to be executable as a test suite:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest.main()`函数是一个实用程序，允许将整个模块作为测试套件来执行：'
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `unittest.main()` function scans the context of the current module and looks
    for classes that subclass `TestCase`. It instantiates them, then runs all methods
    that start with the `test` prefix.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest.main()`函数扫描当前模块的上下文，并寻找子类为`TestCase`的类。它实例化它们，然后运行所有以`test`前缀开头的方法。'
- en: 'A good test suite follows the common and consistent naming conventions. For
    instance, if the `is_prime` function is included in the `primes.py` module, the
    test class could be called `PrimesTests` and put into the `test_primes.py` file:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一个良好的测试套件遵循常见和一致的命名约定。例如，如果`is_prime`函数包含在`primes.py`模块中，测试类可以被称为`PrimesTests`，并放入`test_primes.py`文件中：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: From there, every time the `utils` module evolves, the `test_utils` module gets
    more tests.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，每当`utils`模块发展时，`test_utils`模块就会得到更多的测试。
- en: In order to work, the `test_primes` module needs to have the `primes` module
    available in the context. This can be achieved either by having both modules in
    the same package by adding a tested module explicitly to the Python path. In practice,
    the `develop` command of `setuptools` is very helpful here.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了工作，`test_primes`模块需要在上下文中有`primes`模块可用。这可以通过将两个模块放在同一个包中，或者通过将被测试的模块显式添加到Python路径中来实现。在实践中，`setuptools`的`develop`命令在这里非常有帮助。
- en: Running tests over the whole application presupposes that you have a script
    that builds a **test campaign** out of all test modules. `unittest` provides a
    `TestSuite` class that can aggregate tests and run them as a test campaign, as
    long as they are all instances of `TestCase` or `TestSuite`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个应用程序上运行测试假设您有一个脚本，可以从所有测试模块构建一个**测试运行**。`unittest`提供了一个`TestSuite`类，可以聚合测试并将它们作为一个测试运行来运行，只要它们都是`TestCase`或`TestSuite`的实例。
- en: 'In Python''s past, there was convention that test module provides a `test_suite`
    function that returns a `TestSuite` instance either used in the `__main__` section,
    when the module is called by Command Prompt, or used by a test runner:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python的过去，有一个约定，测试模块提供一个返回`TestSuite`实例的`test_suite`函数，该实例在模块被命令提示符调用时在`__main__`部分中使用，或者由测试运行器使用：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Running this module from the shell will print the test campaign output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从shell中运行这个模块将打印测试运行结果：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding approach was required in the older versions of Python when the
    `unittest` module did not have proper test discovery utilities. Usually, running
    of all tests was done by a global script that browses the code tree looking for
    tests and runs them. This is called **test discovery** and will be covered more
    extensively later in this chapter. For now, you should only know that `unittest`
    provides a simple command that can discover all tests from modules and packages
    with a `test` prefix:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧版本的Python中，当`unittest`模块没有适当的测试发现工具时，需要使用前面的方法。通常，所有测试的运行是由一个全局脚本完成的，该脚本浏览代码树寻找测试并运行它们。这称为**测试发现**，稍后在本章中将更详细地介绍。现在，您只需要知道`unittest`提供了一个简单的命令，可以从带有`test`前缀的模块和包中发现所有测试：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you use the preceding command, then there is no requirement to manually define
    the `__main__` sections and invoke the `unittest.main()` function.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用了前面的命令，那么就不需要手动定义`__main__`部分并调用`unittest.main()`函数。
- en: doctest
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: doctest
- en: '`doctest` is a module that extracts snippets in the form of interactive prompt
    sessions from docstrings or text files and replays them to check whether the example
    output is the same as the real one.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest`是一个模块，它从文档字符串或文本文件中提取交互式提示会话的片段，并重放它们以检查示例输出是否与真实输出相同。'
- en: 'For instance, the text file with the following content could be run as a test:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下内容的文本文件可以作为测试运行：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s assume this documentation file is stored in the filesystem under `test.rst`
    name. The `doctest` module provides some functions to extract and run the tests
    from such documentation:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这个文档文件存储在文件系统中，文件名为`test.rst`。`doctest`模块提供了一些函数，用于从这样的文档中提取并运行测试：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Using `doctest` has many advantages:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`doctest`有很多优点：
- en: Packages can be documented and tested through examples
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包可以通过示例进行文档和测试
- en: Documentation examples are always up to date
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档示例始终是最新的
- en: Using examples in doctests to write a package helps to maintain the user's point
    of view
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用doctests中的示例来编写一个包有助于保持用户的观点
- en: However, doctests do not make unit tests obsolete; they should be used only
    to provide human-readable examples in documents. In other words, when the tests
    are concerning low-level matters or need complex test fixtures that would obfuscate
    the document, they should not be used.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，doctests并不会使单元测试过时；它们只应该用于在文档中提供可读的示例。换句话说，当测试涉及低级问题或需要复杂的测试装置，这些测试装置会使文档变得晦涩时，就不应该使用它们。
- en: Some Python frameworks such as Zope use doctests extensively, and they are at
    times criticized by people who are new to the code. Some doctests are really hard
    to read and understand, since the examples break one of the rules of technical
    writing—they cannot be taken and run in a simple prompt, and they need extensive
    knowledge. So, documents that are supposed to help newcomers are really hard to
    read because the code examples, which are doctests built through TDD, are based
    on complex test fixtures or even specific test APIs.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Python框架，如Zope，广泛使用doctests，并且有时会受到对代码不熟悉的人的批评。有些doctests真的很难阅读和理解，因为这些示例违反了技术写作的规则之一——它们不能在简单的提示符下运行，并且需要广泛的知识。因此，那些本应帮助新手的文档变得很难阅读，因为基于复杂测试装置或特定测试API构建的doctests的代码示例很难阅读。
- en: Note
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As explained in [Chapter 9](ch09.html "Chapter 9. Documenting Your Project"),
    *Documenting Your Project*, when you use doctests that are part of the documentation
    of your packages, be careful to follow the seven rules of technical writing.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第9章](ch09.html "第9章. 项目文档")中所解释的，*项目文档*，当你使用doctests作为你的包文档的一部分时，要小心遵循技术写作的七条规则。
- en: At this stage, you should have a good overview of what TDD brings. If you are
    still not convinced, you should give it a try over a few modules. Write a package
    using TDD and measure the time spent on building, debugging, and then refactoring.
    You should find out quickly that it is truly superior.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你应该对TDD带来的好处有一个很好的概述。如果你还不确定，你应该在几个模块上试一试。使用TDD编写一个包，并测量构建、调试和重构所花费的时间。你会很快发现它确实是优越的。
- en: I do test
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我进行测试
- en: If you are coming from the *I don't test* section and are now convinced to do
    test-driven development, then congratulations! You know the basics of test-driven
    development, but there are some more things you should learn before you will be
    able to efficiently use this methodology.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自*我不测试*部分，并且现在已经确信要进行测试驱动开发，那么恭喜你！你已经了解了测试驱动开发的基础知识，但在能够有效地使用这种方法之前，你还有一些东西需要学习。
- en: This section describes a few problems developers bump into when they write tests
    and some ways to solve them. It also provides a quick review of popular test runners
    and tools available in the Python community.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了开发人员在编写测试时遇到的一些问题，以及解决这些问题的一些方法。它还提供了Python社区中流行的测试运行器和工具的快速回顾。
- en: unittest pitfalls
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试的缺陷
- en: The `unittest` module was introduced in Python 2.1 and has been massively used
    by developers since then. But some alternative test frameworks were created in
    the community by people who were frustrated with the weaknesses and limitations
    of `unittest`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest`模块是在Python 2.1中引入的，并且自那时以来一直被开发人员广泛使用。但是一些替代的测试框架由社区中一些对`unittest`的弱点和限制感到沮丧的人创建。'
- en: 'These are the common criticisms that are often made:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是经常提出的常见批评：
- en: 'The **framework is heavy to use** because:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**框架使用起来很繁重**，因为:'
- en: You have to write all your tests in subclasses of `TestCase`
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须在`TestCase`的子类中编写所有测试
- en: You have to prefix the method names with `test`
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须在方法名前加上`test`前缀
- en: You are encouraged to use assertion methods provided in `TestCase` instead of
    plain `assert` statements and existing methods may not cover every use case
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鼓励使用`TestCase`提供的断言方法，而不是简单的`assert`语句，现有的方法可能无法覆盖每种情况
- en: The framework is hard to extend because it requires massive subclassing of its
    base classes or tricks such as decorators.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个框架很难扩展，因为它需要大量地对基类进行子类化或者使用装饰器等技巧。
- en: Test fixtures are sometimes hard to organize because the `setUp` and `tearDown`
    facilities are tied to the `TestCase` level, though they run once per test. In
    other words, if a test fixture concerns many test modules, it is not simple to
    organize its creation and cleanup.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时测试装置很难组织，因为`setUp`和`tearDown`设施与`TestCase`级别相关联，尽管它们每次测试运行时只运行一次。换句话说，如果一个测试装置涉及许多测试模块，那么组织它的创建和清理就不简单。
- en: It is not easy to run a test campaign over Python software. The default test
    runner (`python -m unittest`) indeed provides some test discovery but does not
    provide enough filtering capabilities. In practice, extra scripts have to be written
    to collect the tests, aggregate them, and then run them in a convenient way.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python软件上运行测试活动并不容易。默认的测试运行器（`python -m unittest`）确实提供了一些测试发现，但并没有提供足够的过滤能力。实际上，需要编写额外的脚本来收集测试，汇总它们，然后以方便的方式运行它们。
- en: A lighter approach is needed to write tests without suffering from the rigidity
    of a framework that looks too much like its big Java brother, JUnit. Since Python
    does not require working with a 100% class-based environment, it is preferable
    to provide a more Pythonic test framework that is not based on subclassing.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一种更轻量的方法来编写测试，而不会受到太像其大型Java兄弟JUnit的框架的限制。由于Python不要求使用100%基于类的环境，因此最好提供一个更符合Python风格的测试框架，而不是基于子类化。
- en: 'A common approach would be:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的方法是：
- en: To provide a simple way to mark any function or any class as a test
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一种简单的方法来标记任何函数或任何类作为测试
- en: To extend the framework through a plug-in system
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过插件系统扩展框架
- en: 'To provide a complete test fixture environment for all test levels: the whole
    campaign, a group of tests at module level, and at test level'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为所有测试级别提供完整的测试装置环境：整个活动、模块级别的一组测试和测试级别
- en: To provide a test runner based on test discovery with an extensive set of options
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于测试发现提供测试运行器，具有广泛的选项集
- en: unittest alternatives
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: unittest替代方案
- en: Some third-party tools try to solve the problems just mentioned by providing
    extra features in the shape of `unittest` extensions.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一些第三方工具尝试通过提供`unittest`扩展的形式来解决刚才提到的问题。
- en: 'Python wiki provides a very long list of various testing utilities and frameworks
    (refer to [https://wiki.python.org/moin/PythonTestingToolsTaxonomy](https://wiki.python.org/moin/PythonTestingToolsTaxonomy)),
    but there are just two projects that are especially popular:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Python维基提供了各种测试实用工具和框架的非常长的列表（参见[https://wiki.python.org/moin/PythonTestingToolsTaxonomy](https://wiki.python.org/moin/PythonTestingToolsTaxonomy)），但只有两个项目特别受欢迎：
- en: '`nose`: [http://nose.readthedocs.org](http://nose.readthedocs.org)'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nose`：[http://nose.readthedocs.org](http://nose.readthedocs.org)'
- en: '`py.test`: [http://pytest.org](http://pytest.org)'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`py.test`：[http://pytest.org](http://pytest.org)'
- en: nose
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: nose
- en: '`nose` is mainly a test runner with powerful discovery features. It has extensive
    options that allow running all kind of test campaigns in a Python application.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`nose`主要是一个具有强大发现功能的测试运行器。它具有广泛的选项，允许在Python应用程序中运行各种测试活动。'
- en: 'It is not a part of standard library but is available on PyPI and can be easily
    installed with pip:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 它不是标准库的一部分，但可以在PyPI上找到，并可以使用pip轻松安装：
- en: '[PRE15]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Test runner
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试运行器
- en: 'After installing nose, a new command called `nosetests` is available at the
    prompt. Running the tests presented in the first section of the chapter can be
    done directly with it:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 安装nose后，一个名为`nosetests`的新命令可以在提示符下使用。可以直接使用它来运行本章第一节中介绍的测试：
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`nose` takes care of discovering the tests by recursively browsing the current
    directory and building a test suite on its own. The preceding example at first
    glance does not look like any improvement over the simple `python -m unittest`.
    The difference will be noticeable if you run this command with the `--help` switch.
    You will notice that nose provides tens of parameters that allow you to control
    test discovery and execution.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`nose`通过递归浏览当前目录并自行构建测试套件来发现测试。乍一看，前面的例子看起来并不像简单的`python -m unittest`有什么改进。如果你使用`--help`开关运行此命令，你会注意到nose提供了数十个参数，允许你控制测试的发现和执行。'
- en: Writing tests
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写测试
- en: '`nose` goes a step further by running all classes and functions whose name
    matches the regular expression `((?:^|[b_.-])[Tt]est)` located in modules that
    match it too. Roughly, all callables that start with `test` and are located in
    a module that match the pattern will also be executed as a test.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`nose`更进一步，通过运行所有类和函数，其名称与正则表达式`((?:^|[b_.-])[Tt]est)`匹配的模块中的测试。大致上，所有以`test`开头并位于匹配该模式的模块中的可调用项也将作为测试执行。'
- en: 'For instance, this `test_ok.py` module will be recognized and run by `nose`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这个`test_ok.py`模块将被`nose`识别并运行：
- en: '[PRE17]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Regular `TestCase` classes and `doctests` are executed as well.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 还会执行常规的`TestCase`类和`doctests`。
- en: Last, `nose` provides assertion functions that are similar to `TestCase` methods.
    But these are provided as functions that follow the PEP 8 naming conventions,
    rather than using the Java convention `unittest` uses (refer to [http://nose.readthedocs.org/](http://nose.readthedocs.org/)).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`nose`提供了类似于`TestCase`方法的断言函数。但这些是作为遵循PEP 8命名约定的函数提供的，而不是使用`unittest`使用的Java约定（参见[http://nose.readthedocs.org/](http://nose.readthedocs.org/)）。
- en: Writing test fixtures
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写测试装置
- en: '`nose` supports three levels of fixtures:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`nose`支持三个级别的装置：'
- en: '**Package level**: The `setup` and `teardown` functions can be added in the
    `__init__.py` module of a test''s package containing all test modules'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包级别**：`__init__.py`模块中可以添加`setup`和`teardown`函数，其中包含所有测试模块的测试包'
- en: '**Module level**: A test module can have its own `setup` and `teardown` functions'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块级别**：测试模块可以有自己的`setup`和`teardown`函数'
- en: '**Test level**: The callable can also have fixture functions using the `with_setup`
    decorator provided'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试级别**：可调用项也可以使用提供的`with_setup`装饰器具有装置函数'
- en: 'For instance, to set a test fixture at the module and test level, use this
    code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要在模块和测试级别设置测试装置，请使用以下代码：
- en: '[PRE18]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Integration with setuptools and a plug-in system
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 与setuptools的集成和插件系统
- en: 'Last, `nose` integrates smoothly with `setuptools` and so the `test` command
    can be used with it (`python setup.py test`). This integration is done by adding
    the `test_suite` metadata in the `setup.py` script:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`nose`与`setuptools`完美集成，因此可以使用`test`命令（`python setup.py test`）。这种集成是通过在`setup.py`脚本中添加`test_suite`元数据来完成的：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`nose` also uses `setuptool''s` entry point machinery for developers to write
    `nose` plugins. This allows you to override or modify every aspect of the tool
    from test discovery to output formatting.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`nose`还使用`setuptool''s`入口机制，供开发人员编写`nose`插件。这允许你从测试发现到输出格式化覆盖或修改工具的每个方面。'
- en: Note
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A list of `nose` plugins is maintained at [https://nose-plugins.jottit.com](https://nose-plugins.jottit.com).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://nose-plugins.jottit.com](https://nose-plugins.jottit.com)上维护了一个`nose`插件列表。
- en: Wrap-up
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 总结
- en: '`nose` is a complete testing tool that fixes many of the issues `unittest`
    has. It is still designed to use implicit prefix names for tests, which remains
    a constraint for some developers. While this prefix can be customized, it still
    requires one to follow a convention.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`nose`是一个完整的测试工具，修复了`unittest`存在的许多问题。它仍然设计为使用测试的隐式前缀名称，这对一些开发人员来说仍然是一个约束。虽然这个前缀可以定制，但仍然需要遵循一定的约定。'
- en: This convention over configuration statement is not bad and is a lot better
    than the boiler-plate code required in `unittest`. But using explicit decorators,
    for example, could be a nice way to get rid of the `test` prefix.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这种约定优于配置的说法并不坏，比在`unittest`中需要的样板代码要好得多。但是，例如使用显式装饰器可能是摆脱`test`前缀的好方法。
- en: Also, the ability to extend `nose` with plugins makes it very flexible and allows
    a developer to customize the tool to meet his/her needs.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过插件扩展`nose`的能力使其非常灵活，并允许开发人员定制工具以满足其需求。
- en: 'If your testing workflow requires overriding a lot of nose parameters, you
    can easily add a `.noserc` or a `nose.cfg` file in your home directory or project
    root. It will specify the default set of options for the `nosetests` command.
    For instance, a good practice is to automatically look for doctests during test
    run. An example of the `nose` configuration file that enables running doctests
    is as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的测试工作流程需要覆盖很多nose参数，您可以在主目录或项目根目录中轻松添加`.noserc`或`nose.cfg`文件。它将指定`nosetests`命令的默认选项集。例如，一个很好的做法是在测试运行期间自动查找doctests。启用运行doctests的`nose`配置文件示例如下：
- en: '[PRE20]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: py.test
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: py.test
- en: '`py.test` is very similar to `nose`. In fact, the latter was inspired by `py.test`,
    so we will focus mainly on details that make these tools different from each other.
    The tool was born as part of a larger package called `py` but now these are developed
    separately.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`py.test`与`nose`非常相似。事实上，后者是受`py.test`启发的，因此我们将主要关注使这些工具彼此不同的细节。该工具诞生于一个名为`py`的更大软件包的一部分，但现在它们是分开开发的。'
- en: 'Like every third-party package mentioned in this book, `py.test` is available
    on PyPI and can be installed with `pip` as `pytest`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 像本书中提到的每个第三方软件包一样，`py.test`可以在PyPI上获得，并且可以通过`pip`安装为`pytest`：
- en: '[PRE21]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'From there, a new `py.test` command is available at the prompt that can be
    used exactly like `nosetests`. The tool uses similar pattern-matching and a test
    discovery algorithm to catch tests to be run. The pattern is stricter than that
    which `nose` uses and will only catch:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，一个新的`py.test`命令在提示符下可用，可以像`nosetests`一样使用。该工具使用类似的模式匹配和测试发现算法来捕获要运行的测试。该模式比`nose`使用的模式更严格，只会捕获：
- en: Classes that start with `Test`, in a file that starts with `test`
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以`Test`开头的类，在以`test`开头的文件中
- en: Functions that start with `test`, in a file that starts with `test`
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以`test`开头的函数，在以`test`开头的文件中
- en: Note
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Be careful to use the right character case. If a function starts with a capital
    "T", it will be taken as a class, and thus ignored. And if a class starts with
    a lowercase "t", `py.test` will break because it will try to deal with it as a
    function.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要小心使用正确的字符大小写。如果一个函数以大写的“T”开头，它将被视为一个类，因此会被忽略。如果一个类以小写的“t”开头，`py.test`将会中断，因为它会尝试将其视为一个函数。
- en: 'The advantages of `py.test` are:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`py.test`的优点包括：'
- en: The ability to easily disable some test classes
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻松禁用一些测试类的能力
- en: A flexible and original mechanism for dealing with fixtures
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理fixtures的灵活和独特机制
- en: The ability to distribute tests among several computers
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将测试分发到多台计算机的能力
- en: Writing test fixtures
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写测试fixtures
- en: '`py.test` supports two mechanisms to deal with fixtures. The first one, modeled
    after xUnit framework, is similar to `nose`. Of course semantics differ a bit.
    `py.test` will look for three levels of fixtures in each test module as shown
    in following example:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`py.test`支持两种处理fixtures的机制。第一种是模仿xUnit框架的，类似于`nose`。当然，语义有些不同。`py.test`将在每个测试模块中查找三个级别的fixtures，如下例所示：'
- en: '[PRE22]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Each function will get the current module, class, or method as an argument.
    The test fixture will, therefore, be able to work on the context without having
    to look for it, as with `nose`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数将以当前模块、类或方法作为参数。因此，测试fixture将能够在上下文中工作，而无需查找它，就像`nose`一样。
- en: The alternative mechanism for writing fixtures with `py.test` is to build on
    the concept of dependency injection, allowing to maintain the test state in a
    more modular and scalable way. The non xUnit-style fixtures (setup/teardown procedures)
    always have unique names and need to be explicitly activated by declaring their
    use in test functions, methods, and modules in classes.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`py.test`编写fixtures的另一种机制是建立在依赖注入的概念上，允许以更模块化和可扩展的方式维护测试状态。非xUnit风格的fixtures（setup/teardown过程）总是具有唯一的名称，并且需要通过在类中的测试函数、方法和模块中声明它们的使用来显式激活它们。'
- en: 'The simplest implementation of fixtures takes the form of a named function
    declared with the `pytest.fixture()` decorator. To mark a fixture as used in the
    test, it needs to be declared as a function or method argument. To make it more
    clear, consider the previous example of the test module for the `is_prime` function
    rewritten with the use of `py.test` fixtures:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: fixtures的最简单实现采用了使用`pytest.fixture()`装饰器声明的命名函数的形式。要将fixture标记为在测试中使用，需要将其声明为函数或方法参数。为了更清楚，考虑使用`py.test`
    fixtures重写`is_prime`函数的测试模块的先前示例：
- en: '[PRE23]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Disabling test functions and classes
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 禁用测试函数和类
- en: '`py.test` provides a simple mechanism to disable some tests upon certain conditions.
    This is called skipping, and the `pytest` package provides the `.skipif` decorator
    for that purpose. If a single test function or a whole test class decorator needs
    to be skipped upon certain conditions, it needs to be defined with this decorator
    and with some value provided that verifies if the expected condition was met.
    Here is an example from the official documentation that skips running the whole
    test case class on Windows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`py.test` 提供了一个简单的机制，可以在特定条件下禁用一些测试。这称为跳过，`pytest` 包提供了 `.skipif` 装饰器来实现这一目的。如果需要在特定条件下跳过单个测试函数或整个测试类装饰器，就需要使用这个装饰器，并提供一些值来验证是否满足了预期条件。以下是官方文档中跳过在
    Windows 上运行整个测试用例类的示例：'
- en: '[PRE24]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can, of course, predefine the skipping conditions in order to share them
    across your testing modules:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以预先定义跳过条件，以便在测试模块之间共享：
- en: '[PRE25]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If a test is marked in such a way, it will not be executed at all. However,
    in some cases, you want to run such a test and want to execute it, but you know,
    it is expected to fail under known conditions. For this purpose, a different decorator
    is provided. It is `@mark.xfail` and ensures that the test is always run, but
    it should fail at some point if the predefined condition occurs:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个测试以这种方式标记，它将根本不会被执行。然而，在某些情况下，您希望运行这样的测试，并希望执行它，但是您知道，在已知条件下它应该失败。为此，提供了一个不同的装饰器。它是
    `@mark.xfail`，确保测试始终运行，但如果预定义条件发生，它应该在某个时候失败：
- en: '[PRE26]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Using `xfail` is much stricter than `skipif`. Test is always executed and if
    it does not fail when it is expected to, then the whole `py.test` run will result
    in a failure.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `xfail` 比 `skipif` 更严格。测试始终会被执行，如果在预期情况下没有失败，那么整个 `py.test` 运行将会失败。
- en: Automated distributed tests
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自动化分布式测试
- en: An interesting feature of `py.test` is its ability to distribute the tests across
    several computers. As long as the computers are reachable through SSH, `py.test`
    will be able to drive each computer by sending tests to be performed.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`py.test` 的一个有趣特性是它能够将测试分布到多台计算机上。只要计算机可以通过 SSH 访问，`py.test` 就能够通过发送要执行的测试来驱动每台计算机。'
- en: However, this feature relies on the network; if the connection is broken, the
    slave will not be able to continue working since it is fully driven by the master.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这一特性依赖于网络；如果连接中断，从属端将无法继续工作，因为它完全由主控端驱动。
- en: Buildbot, or other continuous integration tools, is preferable when a project
    has long test campaigns. But the `py.test` distributed model can be used for the
    ad hoc distribution of tests when you are working on an application that consumes
    a lot of resources to run the tests.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个项目有长时间的测试活动时，Buildbot 或其他持续集成工具更可取。但是，当您在开发一个运行测试需要大量资源的应用程序时，`py.test` 分布模型可以用于临时分发测试。
- en: Wrap-up
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 总结
- en: '`py.test` is very similar to `nose` since no boilerplate code is needed to
    aggregate the tests in it. It also has a good plugin system and there are a great
    number of extensions available on PyPI.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`py.test` 与 `nose` 非常相似，因为它不需要聚合测试的样板代码。它还有一个很好的插件系统，并且在 PyPI 上有大量的扩展可用。'
- en: Lastly, `py.test` focuses on making the tests run fast and is truly superior
    compared to the other tools in this area. The other notable feature is the original
    approach to fixtures that really helps in managing a reusable library of fixtures.
    Some people may argue that there is too much magic involved but it really streamlines
    the development of a test suite. This single advantage of `py.test` makes it my
    tool of choice, so I really recommend it.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`py.test` 专注于使测试运行速度快，与这一领域的其他工具相比确实更加优越。另一个显著特性是对夹具的原始处理方式，这确实有助于管理可重用的夹具库。有些人可能会认为其中涉及了太多魔法，但它确实简化了测试套件的开发。`py.test`
    的这一单一优势使其成为我的首选工具，因此我真的推荐它。
- en: Testing coverage
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试覆盖
- en: '**Code coverage** is a very useful metric that provides objective information
    on how well project code is tested. It is simply a measurement of how many and
    which lines of code are executed during all test executions. It is often expressed
    as a percentage and 100% coverage means that every line of code was executed during
    tests.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码覆盖** 是一个非常有用的度量标准，它提供了关于项目代码测试情况的客观信息。它只是衡量了在所有测试执行期间执行了多少行代码以及哪些行代码。通常以百分比表示，100%
    的覆盖率意味着在测试期间执行了每一行代码。'
- en: 'The most popular code coverage tool is called simply coverage and is freely
    available on PyPI. The usage is very simple and consists only of two steps. The
    first step is to run the coverage run command in your shell with the path to your
    script/program that runs all the tests as an argument:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最流行的代码覆盖工具简称为 coverage，并且可以在 PyPI 上免费获得。使用非常简单，只有两个步骤。第一步是在您的 shell 中运行 coverage
    run 命令，并将运行所有测试的脚本/程序的路径作为参数：
- en: '[PRE27]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The coverage run also accepts `-m` parameter that specifies a runnable module
    name instead of a program path that may be better for some testing frameworks:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: coverage run 还接受 `-m` 参数，该参数指定可运行的模块名称，而不是程序路径，这对于某些测试框架可能更好：
- en: '[PRE28]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The next step is to generate a human-readable report of your code coverage
    from results cashed in the `.coverage` file. The `coverage` package supports a
    few output formats and the simplest one just prints an ASCII table in your terminal:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是从 `.coverage` 文件中缓存的结果生成可读的代码覆盖报告。`coverage` 包支持几种输出格式，最简单的一种只在您的终端中打印 ASCII
    表格：
- en: '[PRE29]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The other useful coverage report format is HTML that can be browsed in your
    web browser:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的覆盖报告格式是 HTML，可以在您的 Web 浏览器中浏览：
- en: '[PRE30]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The default output folder of this HTML report is `htmlcov/` in your working
    directory. The real advantage of the `coverage html` output is that you can browse
    annotated sources of your project with highlighted parts that have missing test
    coverage (as shown in *Figure 1*):'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此 HTML 报告的默认输出文件夹是您的工作目录中的 `htmlcov/`。`coverage html` 输出的真正优势在于您可以浏览项目的带有缺失测试覆盖部分的注释源代码（如
    *图1* 所示）：
- en: '![Testing coverage](graphics/B05295_10_01.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![测试覆盖](graphics/B05295_10_01.jpg)'
- en: Figure 1 Example of annotated sources in coverage HTML report
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图1 覆盖率HTML报告中带注释的源代码示例
- en: You should remember that while you should always strive to ensure 100% test
    coverage, it is never a guarantee that code is tested perfectly and there is no
    place where code can break. It means only that every line of code was reached
    during execution, but not necessarily every possible condition was tested. In
    practice, it may be relatively easy to ensure full code coverage, but it is really
    hard to make sure that every branch of code was reached. This is especially true
    for the testing of functions that may have multiple combinations of `if` statements
    and specific language constructs like `list`/`dict`/`set` comprehensions. You
    should always care for good test coverage, but you should never treat its measurement
    as the final answer of how good your testing suite is.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该记住，虽然您应该始终努力确保100%的测试覆盖率，但这并不意味着代码被完美测试，也不意味着代码不会出错的地方。这只意味着每行代码在执行过程中都被执行到了，但并不一定测试了每种可能的条件。实际上，确保完整的代码覆盖率可能相对容易，但确保每个代码分支都被执行到则非常困难。这对于可能具有多个`if`语句和特定语言构造（如`list`/`dict`/`set`推导）组合的函数的测试尤其如此。您应该始终关注良好的测试覆盖率，但您不应该将其测量视为测试套件质量的最终答案。
- en: Fakes and mocks
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 伪造和模拟
- en: 'Writing unit tests presupposes that you isolate the unit of code that is being
    tested. Tests usually feed the function or method with some data and verify its
    return value and/or the side effects of its execution. This is mainly to make
    sure the tests:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 编写单元测试预设了对正在测试的代码单元进行隔离。测试通常会向函数或方法提供一些数据，并验证其返回值和/或执行的副作用。这主要是为了确保测试：
- en: Are concerning an atomic part of the application, which can be a function, method,
    class, or interface
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 涉及应用程序的一个原子部分，可以是函数、方法、类或接口
- en: Provide deterministic, reproducible results
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供确定性、可重现的结果
- en: Sometimes, the proper isolation of the program component is not obvious. For
    instance, if the code sends e-mails, it will probably call Python's `smtplib`
    module, which will work with the SMTP server through a network connection. If
    we want our tests to be reproducible and are just testing if e-mails have the
    desired content, then probably this should not happen. Ideally, unit tests should
    run on any computer with no external dependencies and side effects.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，程序组件的正确隔离并不明显。例如，如果代码发送电子邮件，它可能会调用Python的`smtplib`模块，该模块将通过网络连接与SMTP服务器进行通信。如果我们希望我们的测试是可重现的，并且只是测试电子邮件是否具有所需的内容，那么可能不应该发生这种情况。理想情况下，单元测试应该在任何计算机上运行，而不需要外部依赖和副作用。
- en: Thanks to Python's dynamic nature, it is possible to use **monkey patching**
    to modify the runtime code from the test fixture (that is, modify software dynamically
    at runtime without touching the source code) to **fake** the behavior of a third-party
    code or library.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python的动态特性，可以使用**monkey patching**来修改测试装置中的运行时代码（即在运行时动态修改软件而不触及源代码）来**伪造**第三方代码或库的行为。
- en: Building a fake
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建一个伪造
- en: A fake behavior in the tests can be created by discovering the minimal set of
    interactions needed for the tested code to work with the external parts. Then,
    the output is manually returned or uses a real pool of data that has been previously
    recorded.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中创建伪造行为可以通过发现测试代码与外部部分交互所需的最小交互集。然后，手动返回输出，或者使用先前记录的真实数据池。
- en: This is done by starting an empty class or function and using it as a replacement.
    The test is then launched, and the fake is iteratively updated until it behaves
    correctly. This is possible thanks to nature of a Python type system. The object
    is considered compatible with the given type as long as it behaves as the expected
    type and does not need to be its ancestor via subclassing. This approach to typing
    in Python is called duck typing—if something behaves like a duck, it can be treated
    like a duck.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过启动一个空类或函数并将其用作替代来完成的。然后启动测试，并迭代更新伪造，直到其行为正确。这是由于Python类型系统的特性。只要对象的行为与预期的类型相匹配，并且不需要通过子类化成为其祖先，它就被认为与给定类型兼容。这种在Python中的类型化方法被称为鸭子类型——如果某物的行为像鸭子，那么它就可以被当作鸭子对待。
- en: 'Let''s take an example with a function called `send` in a module called `mailer`
    that sends e-mails:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个名为`mailer`的模块中的名为`send`的函数为例，该函数发送电子邮件：
- en: '[PRE31]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`py.test` will be used to demonstrate fakes and mocks in this section.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`py.test`将用于在本节中演示伪造和模拟。'
- en: 'The corresponding test can be:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的测试可以是：
- en: '[PRE32]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This test will pass and work as long as there is an SMTP server on the local
    host. If not, it will fail like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 只要本地主机上有SMTP服务器，这个测试就会通过并工作。如果没有，它会失败，就像这样：
- en: '[PRE33]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'A patch can be added to fake the SMTP class:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 可以添加一个补丁来伪造SMTP类：
- en: '[PRE34]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the preceding code, we have used a new `pytest.yield_fixture()` decorator.
    It allows us to use a generator syntax to provide both setup and teardown procedures
    in a single fixture function. Now our test suite can be run again with the patched
    version of `smtplib`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了一个新的`pytest.yield_fixture()`装饰器。它允许我们使用生成器语法在单个fixture函数中提供设置和拆卸过程。现在我们的测试套件可以使用`smtplib`的修补版本再次运行：
- en: '[PRE35]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As we can see from the preceding transcript, our `FakeSMTP` class implementation
    is not complete. We need to update its interface to match the original SMTP class.
    According to the duck typing principle, we need only to provide interfaces that
    are required by the tested `send()` function:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的对话记录中可以看出，我们的`FakeSMTP`类实现并不完整。我们需要更新其接口以匹配原始的SMTP类。根据鸭子类型原则，我们只需要提供被测试的`send()`函数所需的接口：
- en: '[PRE36]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Of course, the fake class can evolve with new tests to provide more complex
    behaviors. But it should be as short and simple as possible. The same principle
    can be used with more complex outputs, by recording them to serve them back through
    the fake API. This is often done for third-party servers such as LDAP or SQL.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，虚假类可以随着新的测试而发展，以提供更复杂的行为。但它应该尽可能短小简单。相同的原则可以用于更复杂的输出，通过记录它们来通过虚假API返回它们。这通常用于LDAP或SQL等第三方服务器。
- en: 'It is important to know that special care should be taken when monkey patching
    any built-in or third-party module. If not done properly, such an approach might
    leave unwanted side effects that will propagate between tests. Fortunately, many
    testing frameworks and tools provide proper utilities that make the patching of
    any code units safe and easy. In our example, we did everything manually and provided
    a custom `patch_smtplib()` fixture function with separated setup and teardown
    steps. A typical solution in `py.test` is much easier. This framework comes with
    a built-in monkey patch fixture that should satisfy most of our patching needs:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当猴子补丁任何内置或第三方模块时，需要特别小心。如果操作不当，这种方法可能会留下意想不到的副作用，会在测试之间传播。幸运的是，许多测试框架和工具提供了适当的实用工具，使得对任何代码单元进行补丁变得安全且容易。在我们的例子中，我们手动完成了所有操作，并提供了一个自定义的`patch_smtplib()`
    fixture函数，其中包括了分离的设置和拆卸步骤。在`py.test`中的典型解决方案要简单得多。这个框架带有一个内置的猴子补丁fixture，应该满足我们大部分的补丁需求。
- en: '[PRE37]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You should know that *fakes* have real limitations. If you decide to fake an
    external dependency, you might introduce bugs or unwanted behaviors the real server
    wouldn't have or vice versa.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该知道，*虚假*有真正的局限性。如果决定虚假一个外部依赖，可能会引入真实服务器不会有的错误或意外行为，反之亦然。
- en: Using mocks
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用模拟
- en: Mock objects are generic fake objects that can be used to isolate the tested
    code. They automate the building process of the object's input and output. There
    is a greater use of mock objects in statically typed languages, where monkey patching
    is harder, but they are still useful in Python to shorten the code to mimic external
    APIs.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象是通用的虚假对象，可以用来隔离被测试的代码。它们自动化了对象的输入和输出的构建过程。在静态类型的语言中，模拟对象的使用更多，因为猴子补丁更难，但它们在Python中仍然很有用，可以缩短代码以模拟外部API。
- en: 'There are a lot of mock libraries available in Python, but the most recognized
    one is `unittest.mock` and is provided in the standard library. It was created
    as a third-party package and not as a part of the Python distribution but was
    shortly included into the standard library as a provisional package (refer to
    [https://docs.python.org/dev/glossary.html#term-provisional-api](https://docs.python.org/dev/glossary.html#term-provisional-api)).
    For Python versions older than 3.3, you will need to install it from PyPI:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Python中有很多模拟库可用，但最受认可的是`unittest.mock`，它是标准库中提供的。它最初是作为第三方包创建的，而不是作为Python发行版的一部分，但很快就被包含到标准库中作为一个临时包（参见[https://docs.python.org/dev/glossary.html#term-provisional-api](https://docs.python.org/dev/glossary.html#term-provisional-api)）。对于早于3.3版本的Python，您需要从PyPI安装它：
- en: '[PRE38]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In our example, using `unittest.mock` to patch SMTP is way simpler than creating
    a fake from scratch:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，使用`unittest.mock`来补丁SMTP比从头开始创建一个虚假对象要简单得多。
- en: '[PRE39]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `return_value` argument of a mock object or method allows you to define
    what value is returned by the call. When the mock object is used, every time an
    attribute is called by the code, it creates a new mock object for the attribute
    on the fly. Thus, no exception is raised. This is the case (for instance) for
    the `quit` method we wrote earlier that does not need to be defined anymore.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象或方法的`return_value`参数允许您定义调用返回的值。当使用模拟对象时，每次代码调用属性时，它都会即时为属性创建一个新的模拟对象。因此，不会引发异常。这就是我们之前编写的`quit`方法的情况，它不需要再定义了。
- en: 'In the preceding example, we have in fact created two mocks:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，实际上我们创建了两个模拟对象：
- en: The first one that mocks the SMTP class object and not its instance. This allows
    you to easily create a new object regardless of the expected `__init__()` method.
    Mocks by default return new `Mock()` objects if treated as callable. This is why
    we needed to provide another mock as its `return_value` keyword argument to have
    control on the instance interface.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个模拟了SMTP类对象而不是它的实例。这使您可以轻松地创建一个新对象，而不管预期的`__init__()`方法是什么。如果将模拟对象视为可调用，默认情况下会返回新的`Mock()`对象。这就是为什么我们需要为其`return_value`关键字参数提供另一个模拟对象，以便对实例接口进行控制。
- en: The second one that mocks the actual instance returned on the patched `smtplib.SMTP()`
    call. In this mock, we control the behavior of the `sendmail()`method.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个模拟了在补丁`smtplib.SMTP()`调用上返回的实际实例。在这个模拟中，我们控制了`sendmail()`方法的行为。
- en: 'In our example, we have used the monkey-patching utility available from the
    `py.test` framework, but `unittest.mock` provides its own patching utilities.
    In some situations (like patching class objects), it may be simpler and faster
    to use them instead of your framework-specific tools. Here is example of monkey
    patching with the `patch()` context manager provided by `unittest.mock` module:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们使用了`py.test`框架提供的猴子补丁实用程序，但`unittest.mock`提供了自己的补丁实用程序。在某些情况下（比如补丁类对象），使用它们可能比使用特定于框架的工具更简单更快。以下是使用`unittest.mock`模块提供的`patch()`上下文管理器进行猴子补丁的示例：
- en: '[PRE40]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Testing environment and dependency compatibility
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试环境和依赖兼容性
- en: The importance of environment isolation has already been mentioned in this book
    many times. By isolating your execution environment on both application level
    (virtual environments) and system level (system virtualization), you are able
    to ensure that your tests run under repeatable conditions. This way, you protect
    yourself from rare and obscure problems caused by broken dependencies.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中已经多次提到了环境隔离的重要性。通过在应用程序级别（虚拟环境）和系统级别（系统虚拟化）上隔离执行环境，您可以确保您的测试在可重复的条件下运行。这样，您就可以保护自己免受由于损坏的依赖关系引起的罕见和隐晦的问题。
- en: The best way to allow the proper isolation of a test environment is to use good
    continuous integration systems that support system virtualization. There are good
    free solutions for open source projects such as Travis CI (Linux and OS X) or
    AppVeyor (Windows), but if you need such a thing for testing proprietary software,
    it is very likely that you will need to spend some time on building such a solution
    by yourself on top of some existing open source CI tools (GitLab CI, Jenkins,
    and Buildbot).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 允许适当隔离测试环境的最佳方式是使用支持系统虚拟化的良好持续集成系统。对于开源项目，有很好的免费解决方案，比如Travis CI（Linux和OS X）或AppVeyor（Windows），但如果你需要为测试专有软件构建这样的解决方案，很可能需要花费一些时间在一些现有的开源CI工具（GitLab
    CI、Jenkins和Buildbot）的基础上构建这样的解决方案。
- en: Dependency matrix testing
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖矩阵测试
- en: Testing matrixes for open source Python projects in most cases focus only on
    different Python versions and rarely on different operating systems. Not doing
    your tests and builds on different systems is completely OK for projects that
    are purely Python and where there are no expected system interoperability issues.
    But some projects, especially when distributed as compiled Python extensions,
    should be definitely tested on various target operating systems. For open source
    projects, you may even be forced to use a few independent CI systems to provide
    builds for just the three most popular ones (Windows, Linux, and Mac OS X). If
    you are looking for a good example, you can take a look at the small pyrilla project
    (refer to [https://github.com/swistakm/pyrilla](https://github.com/swistakm/pyrilla))
    that is a simple C audio extension for Python. It uses both Travis CI and AppVeyor
    in order to provide compiled builds for Windows and Mac OS X and a large range
    of CPython versions.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，针对开源Python项目的测试矩阵主要关注不同的Python版本，很少关注不同的操作系统。对于纯粹是Python的项目，没有预期的系统互操作性问题，不在不同系统上进行测试和构建是完全可以的。但是一些项目，特别是作为编译Python扩展进行分发的项目，绝对应该在各种目标操作系统上进行测试。对于开源项目，甚至可能被迫使用几个独立的CI系统，为仅仅提供三种最流行的系统（Windows、Linux和Mac
    OS X）的构建。如果你正在寻找一个很好的例子，可以看一下小型的pyrilla项目（参考[https://github.com/swistakm/pyrilla](https://github.com/swistakm/pyrilla)），这是一个简单的用于Python的C音频扩展。它同时使用了Travis
    CI和AppVeyor来为Windows和Mac OS X提供编译构建，并支持大量的CPython版本。
- en: 'But dimensions of test matrixes do not end on systems and Python versions.
    Packages that provide integration with other software such as caches, databases,
    or system services very often should be tested on various versions of integrated
    applications. A good tool that makes such testing easy is tox (refer to [http://tox.readthedocs.org](http://tox.readthedocs.org)).
    It provides a simple way to configure multiple testing environments and run all
    tests with a single `tox` command. It is a very powerful and flexible tool but
    is also very easy to use. The best way to present its usage is to show you an
    example of a configuration file that is in fact the core of tox. Here is the `tox.ini`
    file from the django-userena project (refer to [https://github.com/bread-and-pepper/django-userena](https://github.com/bread-and-pepper/django-userena)):'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 但是测试矩阵的维度不仅仅局限于系统和Python版本。提供与其他软件集成的包，比如缓存、数据库或系统服务，往往应该在各种集成应用的版本上进行测试。一个很好的工具，可以让这样的测试变得容易，是tox（参考[http://tox.readthedocs.org](http://tox.readthedocs.org)）。它提供了一种简单的方式来配置多个测试环境，并通过单个`tox`命令运行所有测试。它是一个非常强大和灵活的工具，但也非常容易使用。展示其用法的最佳方式是向您展示一个配置文件的示例，实际上这个配置文件是tox的核心。以下是django-userena项目的`tox.ini`文件（参考[https://github.com/bread-and-pepper/django-userena](https://github.com/bread-and-pepper/django-userena)）：
- en: '[PRE41]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This configuration allows you to test `django-userena` on five different versions
    of Django and six versions of Python. Not every Django version will work on every
    Python version and the `tox.ini` file makes it relatively easy to define such
    dependency constraints. In practice, the whole build matrix consists of 21 unique
    environments (including a special environment for code coverage collection). It
    would require tremendous effort to create each testing environment manually or
    even using shell scripts.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置允许在五个不同版本的Django和六个版本的Python上测试`django-userena`。并非每个Django版本都能在每个Python版本上运行，`tox.ini`文件使得定义这样的依赖约束相对容易。实际上，整个构建矩阵包括21个独特的环境（包括一个用于代码覆盖收集的特殊环境）。手动创建每个测试环境，甚至使用shell脚本，都需要巨大的工作量。
- en: 'Tox is great but its usage gets more complicated if we would like to change
    other elements of the testing environment that are not plain Python dependencies.
    This is a situation when we need to test under different versions of system packages
    and backing services. The best way to solve this problem is again to use good
    continuous integration systems that allow you to easily define matrixes of environment
    variables and install system software on virtual machines. A good example of doing
    that using Travis CI is provided by the `ianitor` project (refer to [https://github.com/ClearcodeHQ/ianitor/](https://github.com/ClearcodeHQ/ianitor/))
    that was already mentioned in [Chapter 9](ch09.html "Chapter 9. Documenting Your
    Project"), *Documenting Your Project*. It is a simple utility for the Consul discovery
    service. The Consul project has a very active community and many new versions
    of its code are released every year. This makes it very reasonable to test against
    various versions of that service. This makes sure that the `ianitor` project is
    still up to date with the latest version of that software but also does not break
    compatibility with previous Consul versions. Here is the content of the `.travis.yml`
    configuration file for Travis CI that allows you to test against three different
    Consul versions and four Python interpreter versions:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Tox很棒，但是如果我们想要更改不是纯Python依赖的测试环境的其他元素，它的使用就会变得更加复杂。这是一个情况，当我们需要在不同版本的系统软件包和后备服务下进行测试时。解决这个问题的最佳方法是再次使用良好的持续集成系统，它允许您轻松地定义环境变量的矩阵，并在虚拟机上安装系统软件。使用Travis
    CI进行这样做的一个很好的例子是`ianitor`项目（参见[https://github.com/ClearcodeHQ/ianitor/](https://github.com/ClearcodeHQ/ianitor/)），它已经在[第9章](ch09.html
    "第9章。记录您的项目")中提到过，*记录您的项目*。这是Consul发现服务的一个简单实用程序。Consul项目有一个非常活跃的社区，每年都会发布许多新版本的代码。这使得对该服务的各种版本进行测试非常合理。这确保了`ianitor`项目仍然与该软件的最新版本保持最新，但也不会破坏与以前的Consul版本的兼容性。以下是Travis
    CI的`.travis.yml`配置文件的内容，它允许您对三个不同的Consul版本和四个Python解释器版本进行测试：
- en: '[PRE42]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The preceding example provides 14 unique test environments (including `pep8`
    and `coverage` builds) for the `ianitor` code. This configuration also uses tox
    to create actual testing virtual environments on Travis VMs. This is actually
    a very popular approach to integrate tox with different CI systems. By moving
    as much of a test environment configuration as possible to tox, you are reducing
    the risk of locking yourself to a single vendor. Things like the installation
    of new services or defining system environment variables are supported by most
    of the Travis CI competitors, so it should be relatively easy to switch to a different
    service provider if there is a better product available on the market or Travis
    will change their pricing model for open source projects.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子为`ianitor`代码提供了14个独特的测试环境（包括`pep8`和`coverage`构建）。这个配置还使用tox在Travis VM上创建实际的测试虚拟环境。这实际上是将tox与不同的CI系统集成的一种非常流行的方法。通过尽可能多地将测试环境配置移动到tox，您可以减少将自己锁定到单个供应商的风险。像安装新服务或定义系统环境变量这样的事情，大多数Travis
    CI的竞争对手都支持，因此如果市场上有更好的产品可用，或者Travis会改变其针对开源项目的定价模式，切换到不同的服务提供商应该相对容易。
- en: Document-driven development
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档驱动开发
- en: '*doctests* are a real advantage in Python compared to other languages. The
    fact that documentation can use code examples that are also runnable as tests
    changes the way TDD can be done. For instance, a part of the documentation can
    be done through `doctests` during the development cycle. This approach also ensures
    that the provided examples are always up to date and really working.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他语言相比，*文档测试*在Python中是一个真正的优势。文档可以使用代码示例，这些示例也可以作为测试运行，这改变了TDD的方式。例如，在开发周期中，文档的一部分可以通过`doctests`来完成。这种方法还确保提供的示例始终是最新的并且确实有效。
- en: Building software through doctests rather than regular unit tests is called
    **Document-Driven Development** (**DDD**). Developers explain what the code is
    doing in plain English while they are implementing it.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 通过文档测试构建软件而不是常规单元测试被称为**文档驱动开发**（**DDD**）。开发人员在实现代码时用简单的英语解释代码的功能。
- en: Writing a story
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 写故事
- en: Writing doctests in DDD is done by building a story about how a piece of code
    works and should be used. The principles are described in plain English and then
    a few code usage examples are distributed throughout the text. A good practice
    is to start to write text on how the code works and then add some code examples.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在DDD中编写文档测试是通过构建关于代码如何工作和应该如何使用的故事来完成的。首先用简单的英语描述原则，然后在文本中分布一些代码使用示例。一个好的做法是先写关于代码如何工作的文本，然后添加一些代码示例。
- en: 'To see an example of doctests in practice, let''s look at the `atomisator`
    package (refer to [https://bitbucket.org/tarek/atomisator](https://bitbucket.org/tarek/atomisator)).
    The documentation text for its `atomisator.parser` subpackage (under `packages/atomisator.parser/atomisator/parser/docs/README.txt`)
    is as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 要看一个实际的文档测试的例子，让我们看一下`atomisator`软件包（参见[https://bitbucket.org/tarek/atomisator](https://bitbucket.org/tarek/atomisator)）。其`atomisator.parser`子软件包的文档文本（位于`packages/atomisator.parser/atomisator/parser/docs/README.txt`）如下：
- en: '[PRE43]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Later, the doctest will evolve to take into account new elements or the required
    changes. This doctest is also a good documentation for developers who want to
    use the package and should be changed with this usage in mind.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，文档测试将会发展，以考虑新元素或所需的更改。这个文档测试也是开发人员想要使用该软件包的良好文档，并且应该根据这种用法进行更改。
- en: A common pitfall in writing tests in a document is to transform it into an unreadable
    piece of text. If this happens, it should not be considered as part of the documentation
    anymore.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在文档中编写测试的一个常见陷阱是将其转化为一段难以阅读的文本。如果发生这种情况，就不应再将其视为文档的一部分。
- en: 'That said, some developers that are working exclusively through doctests often
    group their doctests into two categories: the ones that are readable and usable
    so that they can be a part of the package documentation, and the ones that are
    unreadable and are just used to build and test the software.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，一些开发人员专门通过doctests工作，通常将他们的doctests分为两类：可读和可用的，可以成为软件包文档的一部分，以及不可读的，仅用于构建和测试软件。
- en: Many developers think that doctests should be dropped for the latter in favor
    of regular unit tests. Others even use dedicated doctests for bug fixes.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发人员认为应该放弃后者，转而使用常规单元测试。其他人甚至为错误修复使用专门的doctests。
- en: So, the balance between doctests and regular tests is a matter of taste and
    is up to the team, as long as the published part of the doctests is readable.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，doctests和常规测试之间的平衡是一种品味问题，由团队决定，只要doctests的已发布部分是可读的。
- en: Note
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When DDD is used in a project, focus on the readability and decide which doctests
    are eligible to be a part of the published documentation.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目中使用DDD时，专注于可读性，并决定哪些doctests有资格成为已发布文档的一部分。
- en: Summary
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'This chapter advocated the usage of TDD and provided more information on:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提倡使用TDD，并提供了更多关于：
- en: '`unittest` pitfalls'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unittest`陷阱'
- en: 'Third-party tools: `nose` and `py.test`'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方工具：`nose`和`py.test`
- en: How to build fakes and mocks
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构建伪造和模拟
- en: Documentation-driven development
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档驱动开发
- en: Since we already know how to build, package, and test software, in the next
    two chapters we will focus on ways to find performance bottlenecks and optimize
    your programs.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经知道如何构建、打包和测试软件，在接下来的两章中，我们将专注于寻找性能瓶颈并优化您的程序的方法。
