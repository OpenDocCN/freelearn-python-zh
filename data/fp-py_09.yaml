- en: Chapter 9. More Itertools Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。更多迭代工具技术
- en: Functional programming emphasizes stateless programming. In Python, this leads
    us to work with generator expressions, generator functions, and iterables. In
    this chapter, we'll continue our study of the `itertools` library, with numerous
    functions to help us work with iterable collections.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程强调无状态编程。在Python中，这导致我们使用生成器表达式、生成器函数和可迭代对象。在本章中，我们将继续研究`itertools`库，其中包含许多函数，帮助我们处理可迭代集合。
- en: 'In the previous chapter, we looked at three broad groupings of iterator functions.
    They are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看了三种广泛的迭代器函数分组。它们如下：
- en: Functions that work with infinite iterators can be applied to any iterable or
    an iterator over any collection; they will consume the entire source
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与无限迭代器一起工作的函数可以应用于任何可迭代对象或任何集合上的迭代器；它们将消耗整个源
- en: Functions that work with finite iterators can either accumulate a source multiple
    times, or they produce a reduction of the source
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与有限迭代器一起工作的函数可以多次累积源，或者它们可以产生源的减少
- en: The `tee()` iterator function clones an iterator into several copies that can
    each be used independently
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tee()`迭代器函数将一个迭代器克隆成几个独立可用的副本'
- en: 'In this chapter, we''ll look at the `itertools` functions that work with permutations
    and combinations. These include several functions and a few recipes built on these
    functions. The functions are as follows:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究与排列和组合一起工作的`itertools`函数。这些包括几个函数和一些基于这些函数构建的配方。这些函数如下：
- en: '`product()`: This function forms a Cartesian product equivalent to the nested
    `for` loops'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product()`: 此函数形成一个等同于嵌套`for`循环的笛卡尔积'
- en: '`permutations()`: This function emits tuples of length *r* from a universe
    *p* in all possible orderings; there are no repeated elements'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`permutations()`: 此函数按所有可能的顺序从宇宙*p*中发出长度为*r*的元组；没有重复的元素'
- en: '`combinations()`: This function emits tuples of length *r* from a universe
    *p* in sorted order; there are no repeated elements'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`combinations()`: 此函数按排序顺序从宇宙*p*中发出长度为*r*的元组；没有重复的元素'
- en: '`combinations_with_replacement()`: This function emits tuples of length *r*
    from *p* in a sorted order, with repeated elements'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`combinations_with_replacement()`: 此函数按照排序顺序从*p*中发出长度为*r*的元组，其中包含重复的元素'
- en: These functions embody algorithms that iterate over potentially large result
    sets from small collections of input data. Some kinds of problems have exact solutions
    based on exhaustively enumerating a potentially gigantic universe of permutations.
    The functions make it simple to emit a large number of permutations; in some cases,
    the simplicity isn't actually optimal.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数体现了从输入数据的小集合迭代可能非常大的结果集的算法。某些问题的解决方案基于详尽地枚举可能庞大的排列组合的宇宙。这些函数使得发出大量的排列组合变得简单；在某些情况下，这种简单实际上并不是最优的。
- en: Enumerating the Cartesian product
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举笛卡尔积
- en: The term Cartesian product refers to the idea of enumerating all the possible
    combinations of elements drawn from a number of sets.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 笛卡尔积这个术语指的是枚举从多个集合中抽取的所有可能组合的想法。
- en: 'Mathematically, we might say that the product of two sets, ![Enumerating the
    Cartesian product](graphics/B03652_09_01.jpg), has 52 pairs as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学上讲，我们可能会说两个集合的乘积，![枚举笛卡尔积](graphics/B03652_09_01.jpg)，有52对如下：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can produce the preceding results by executing the following commands:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行以下命令来产生前述结果：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The calculation of a product can be extended to any number of iterable collections.
    Using a large number of collections can lead to a very large result set.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 产品的计算可以扩展到任意数量的可迭代集合。使用大量的集合可能会导致非常大的结果集。
- en: Reducing a product
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少一个乘积
- en: 'In relational database theory, a join between tables can be thought of as a
    filtered product. A SQL `SELECT` statement that joins tables without a `WHERE`
    clause will produce a Cartesian product of rows in the tables. This can be thought
    of as the worst-case algorithm: a product without any filtering to pick the proper
    results.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系数据库理论中，表之间的连接可以被视为一个经过筛选的乘积。一个没有`WHERE`子句的SQL `SELECT`语句将产生表中行的笛卡尔积。这可以被认为是最坏情况的算法：一个没有任何过滤来选择正确结果的乘积。
- en: 'We can use the `join()` function to join two tables, as shown in the following
    commands:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`join()`函数来连接两个表，如下所示的命令：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: All combinations of the two iterables, `t1` and `t2`, are computed. The `filter()`
    function will apply the given `where` function to pass or reject items that didn't
    fit the given condition to match appropriate rows from each iterable. This will
    work when the `where` function returns a simple Boolean.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 计算两个可迭代对象`t1`和`t2`的所有组合。`filter()`函数将应用给定的`where`函数来通过或拒绝不符合给定条件的项目，以匹配每个可迭代对象的适当行。当`where`函数返回一个简单的布尔值时，这将起作用。
- en: In some cases, we don't have a simple Boolean matching function. Instead, we're
    forced to search for a minimum or maximum of some distance between items.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们没有一个简单的布尔匹配函数。相反，我们被迫搜索项目之间的某种距离的最小值或最大值。
- en: 'Assume that we have a table of `Color` objects as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个`Color`对象的表如下：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For more information, see [Chapter 6](ch06.html "Chapter 6. Recursions and Reductions"),
    *Recursions and Reductions*, where we showed you how to parse a file of colors
    to create `namedtuple` objects. In this case, we've left the RGB as a triple,
    instead of decomposing each individual field.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参见[第6章](ch06.html "第6章。递归和减少")，*递归和减少*，在那里我们向您展示了如何解析颜色文件以创建`namedtuple`对象。在这种情况下，我们将RGB保留为三元组，而不是分解每个单独的字段。
- en: 'An image will have a collection of pixels:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一幅图像将有一个像素集合：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As a practical matter, the **Python Imaging Library** (**PIL**) package presents
    the pixels in a number of forms. One of these is the mapping from (*x*, *y*) coordinate
    to RGB triple. For more information, visit [https://pypi.python.org/pypi/Pillow](https://pypi.python.org/pypi/Pillow)
    for the Pillow project documentation.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，**Python Imaging Library**（**PIL**）包以多种形式呈现像素。其中之一是从（*x*，*y*）坐标到RGB三元组的映射。有关更多信息，请访问[Pillow项目文档](https://pypi.python.org/pypi/Pillow)。
- en: 'Given a `PIL.Image` object, we can iterate over the collection of pixels with
    something like the following commands:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个`PIL.Image`对象，我们可以使用以下命令迭代像素集合：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We've determined the range of each coordinate based on the image size. The calculation
    of the `product(range(w), range(h))` method creates all the possible combinations
    of coordinates. It is, effectively, two nested `for` loops.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定了每个坐标的范围，基于图像大小。`product(range(w), range(h))`方法的计算创建了所有可能的坐标组合。实际上，这是两个嵌套的`for`循环。
- en: This has the advantage of providing each pixel with its coordinates. We can
    then process the pixels in no particular order and still reconstruct an image.
    This is particularly handy when using multiprocessing or multithreading to spread
    the workload among several cores or processors. The `concurrent.futures` module
    provides an easy way to distribute work among cores or processors.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的好处是为每个像素提供其坐标。然后我们可以以任意顺序处理像素，仍然可以重建图像。当使用多核或多线程来分配工作负载时，这是非常方便的。`concurrent.futures`模块提供了一种在多个核心或处理器之间分配工作的简单方法。
- en: Computing distances
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算距离
- en: A number of decision-making problems require that we find a close-enough match.
    We might not be able to use a simple equality test. Instead, we have to use a
    distance metric and locate items with the shortest distance to our target. For
    text, we might use the Levenshtein distance; this shows how many changes are required
    to get from a given block of text to our target.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 许多决策问题要求我们找到一个足够接近的匹配。我们可能无法使用简单的相等测试。相反，我们必须使用距离度量，并找到与我们目标的最短距离的项目。对于文本，我们可能使用Levenshtein距离；这显示了从给定文本块到我们目标需要多少更改。
- en: We'll use a slightly simpler example. This will involve very simple math. However,
    even though it's simple, it doesn't work out well if we approach it naively.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个稍微简单的例子。这将涉及非常简单的数学。然而，即使它很简单，如果我们天真地对待它，它也不会很好地解决问题。
- en: When doing color matching, we won't have a simple equality test. We're rarely
    able to check for the exact equality of pixel colors. We're often forced to define
    a minimal distance function to determine whether two colors are close enough,
    without being the same three values of R, G, and B. There are several common approaches,
    including the Euclidean distance, Manhattan distance, and yet other complex weightings
    based on visual preferences.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行颜色匹配时，我们不会有一个简单的相等测试。我们很少能够检查像素颜色的确切相等。我们经常被迫定义一个最小距离函数，以确定两种颜色是否足够接近，而不是相同的R、G和B三个值。有几种常见的方法，包括欧几里得距离、曼哈顿距离，以及基于视觉偏好的其他复杂加权。
- en: 'Here are the Euclidean and Manhattan distance functions:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是欧几里得距离和曼哈顿距离函数：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The Euclidean distance measures the hypotenuse of a right-angled triangle among
    the three points in an RGB space. The Manhattan distance sums the edges of each
    leg of the right-angled triangle among the three points. The Euclidean distance
    offers precision where the Manhattan distance offers calculation speed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 欧几里得距离测量RGB空间中三个点之间直角三角形的斜边。曼哈顿距离对三个点之间的直角三角形的每条边求和。欧几里得距离提供了精度，而曼哈顿距离提供了计算速度。
- en: 'Looking forward, we''re aiming for a structure that looks like this. For each
    individual pixel, we can compute the distance from that pixel''s color to the
    available colors in a limited color set. The results of this calculation for a
    single pixel might look like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 展望未来，我们的目标是一个看起来像这样的结构。对于每个单独的像素，我们可以计算该像素颜色与有限颜色集中可用颜色之间的距离。单个像素的这种计算结果可能如下所示：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We''ve shown an overall tuple that consists of a number of four tuples. Each
    of the four tuples contains the following contents:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了一个包含多个四元组的整体元组。每个四元组包含以下内容：
- en: The pixel's coordinates, for example, (0,0)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像素的坐标，例如(0,0)
- en: The pixel's original color, for example, (92, 139, 195)
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像素的原始颜色，例如(92, 139, 195)
- en: A `Color` object from our set of seven colors, for example, Color(rgb=(239,
    222, 205),name='Almond')
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，我们从七种颜色中选择一个`Color`对象，比如Color(rgb=(239, 222, 205),name='Almond')
- en: The Euclidean distance between the original color and the given `Color` object
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始颜色与给定的`Color`对象之间的欧几里得距离
- en: 'We can see that the smallest Euclidean distance is the closest match color.
    This kind of reduction is done easily with the `min()` function. If the overall
    tuple is assigned to a variable name, `choices`, the pixel-level reduction would
    look like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到最小的欧几里得距离是最接近的匹配颜色。这种缩减很容易用`min()`函数实现。如果将整个元组分配给一个变量名`choices`，像素级的缩减将如下所示：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We've called each four tuple an xypcd, that is, an xy coordinate, pixel, color,
    and distance. The minimum distance calculation will then pick a single four tuple
    as the optimal match between pixel and color.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称每个四元组为xypcd，即xy坐标、像素、颜色和距离。然后，最小距离计算将选择一个单个的四元组作为像素和颜色之间的最佳匹配。
- en: Getting all pixels and all colors
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取所有像素和所有颜色
- en: How do we get to the structure that contains all pixels and all colors? The
    answer is simple but, as we'll see, less than optimal.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何得到包含所有像素和所有颜色的结构？答案很简单，但正如我们将看到的那样，不够理想。
- en: 'One way to map pixels to colors is to enumerate all pixels and all colors using
    the `product()` function:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 将像素映射到颜色的一种方法是使用`product()`函数枚举所有像素和所有颜色：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The core of this is the `product(pixel_iter(img), colors)` method that creates
    all pixels combined with all colors. We will do a bit of restructuring of the
    data to flatten it out. We will apply the `euclidean()` function to compute distances
    between pixel colors and `Color` objects.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个核心是`product(pixel_iter(img), colors)`方法，它创建了所有像素与所有颜色的组合。我们将对数据进行一些重组以使其扁平化。我们将应用`euclidean()`函数来计算像素颜色和`Color`对象之间的距离。
- en: 'The final selection of colors uses the `groupby()` function and the `min(choices,...)`
    expression, as shown in the following command snippet:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最终颜色的选择使用了`groupby()`函数和`min(choices,...)`表达式，如下面的命令片段所示：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The overall product of pixels and colors is a long, flat iterable. We grouped
    the iterable into smaller collections where the coordinates match. This will break
    the big iterable into smaller iterables of just colors associated with a single
    pixel. We can then pick the minimal color distance for each color.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 像素和颜色的整体乘积是一个长而扁平的可迭代对象。我们将可迭代对象分组成小集合，其中坐标匹配。这将把大的可迭代对象分成小的可迭代对象，每个对象只与一个像素相关联的颜色。然后我们可以为每种颜色选择最小的颜色距离。
- en: In a picture that's 3,648×2,736 with 133 Crayola colors, we have an iterable
    with 1,327,463,424 items to be evaluated. Yes. That's a billion combinations created
    by this `distances` expression. The number is not necessarily impractical. It's
    well within the limits of what Python can do. However, it reveals an important
    flaw in the naïve use of the `product()` function.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个3,648×2,736像素，有133种Crayola颜色的图片中，我们有一个可迭代的项数为1,327,463,424。是的。这是由这个`distances`表达式创建的十亿种组合。这个数字并不一定是不切实际的。它完全在Python可以处理的范围内。然而，它揭示了对`product()`函数的天真使用的一个重要缺陷。
- en: 'We can''t trivially do this kind of large-scale processing without some analysis
    to see how large it is. Here are some `timeit` numbers for these that do each
    of these calculations only 1,000,000 times:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能轻易地进行这种大规模处理，而不进行一些分析来看看它有多大。这些只对每个计算进行了1,000,000次的`timeit`数字如下：
- en: Euclidean 2.8
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欧几里德2.8
- en: Manhattan 1.8
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 曼哈顿1.8
- en: Scaling up from 1 million to 1 billion means 1,800 seconds, that is, about half
    an hour for the Manhattan distance and 46 minutes to calculate the Euclidean distance.
    It appears that the core arithmetic operations of Python are too slow for this
    kind of naïve bulk processing.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从100万扩展到10亿意味着1,800秒，也就是说，曼哈顿距离需要大约半小时，而计算欧几里德距离需要46分钟。看来Python的核心算术运算对于这种天真的大规模处理来说太慢了。
- en: More importantly, we're doing it wrong. This kind of *width×height×color* processing
    is simply a bad design. In many cases, we can do much better.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，我们做错了。这种*宽度×高度×颜色*的处理方法只是一个糟糕的设计。在许多情况下，我们可以做得更好。
- en: Performance analysis
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能分析
- en: A key feature of any big data algorithm is locating a way to execute some kind
    of a divide-and-conquer strategy. This is true of functional programming design
    as well as imperative design.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 任何大数据算法的一个关键特征是找到一种执行某种分而治之策略的方法。这对于函数式编程设计和命令式设计都是正确的。
- en: 'We have three options to speed up this processing; they are as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三种选项来加速这个处理；它们如下：
- en: We can try to use parallelism to do more of the calculations concurrently. On
    a four-core processor, the time can be cut to approximately ¼. This cuts the time
    to 8 minutes for Manhattan distances.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以尝试使用并行处理来同时进行更多的计算。在一个四核处理器上，时间可以缩短到大约1/4。这将把曼哈顿距离的时间缩短到8分钟。
- en: We can see if caching intermediate results will reduce the amount of redundant
    calculation. The question arises of how many colors are the same and how many
    colors are unique.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以看看缓存中间结果是否会减少冗余计算的数量。问题是有多少颜色是相同的，有多少颜色是唯一的。
- en: We can look for a radical change in the algorithm.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以寻找算法上的根本变化。
- en: We'll combine the last two points by computing all the possible comparisons
    between source colors and target colors. In this case, as in many other contexts,
    we can easily enumerate the entire mapping and avoid redundant calculation when
    done on a pixel-by-pixel basis. We'll also change the algorithm from a series
    of comparisons to a series of simple lookups in a mapping object.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过计算源颜色和目标颜色之间的所有可能比较来结合最后两点。在这种情况下，与许多其他情境一样，我们可以轻松枚举整个映射，并避免在像素级别上进行冗余计算。我们还将把算法从一系列比较改为一系列简单的查找在一个映射对象中。
- en: 'When looking at this idea of precomputing all transformations for source color
    to target color, we need some overall statistics for an arbitrary image. The code
    associated with this book includes `IMG_2705.jpg`. Here is a basic algorithm to
    collect some data from the specified image:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑预先计算从源颜色到目标颜色的所有转换时，我们需要一些任意图像的整体统计数据。与本书相关的代码包括`IMG_2705.jpg`。以下是从指定图像收集一些数据的基本算法：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We collected all pixels of a given color into a list organized by color. From
    this, we''ll learn the first of the following facts:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有给定颜色的像素收集到一个按颜色组织的列表中。从中，我们将学到以下事实中的第一个：
- en: The total number of pixels is 9,980,928\. This is not surprising for a 10 megapixel
    image.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像素的总数是9,980,928。对于一个1000万像素的图像来说，这并不奇怪。
- en: The total number of colors is 210,303\. If we try to compute the Euclidean distance
    between actual colors and the 133 colors, we would merely do 27,970,299 calculations,
    which might take about 76 seconds.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 颜色的总数是210,303。如果我们尝试计算实际颜色和133种颜色之间的欧几里德距离，我们只需要进行27,970,299次计算，可能需要大约76秒。
- en: Using a 3-bit mask, `0b11100000`, there are 214 colors used out of a possible
    512.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用3位掩码`0b11100000`，512种可能颜色中使用了214种。
- en: Using a 4-bit mask, `0b11110000`, there are 1,150 colors used out of 4,096.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用4位掩码`0b11110000`，4,096种颜色中使用了1,150种。
- en: Using a 5-bit mask, `0b11111000`, there are 5,845 colors used out of 32,768.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用5位掩码`0b11111000`，32,768种颜色中使用了5,845种。
- en: Using a 6-bit mask, `0b11111100`, there are 27,726 colors out of 262,144.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用6位掩码`0b11111100`，262,144种颜色中有27,726种颜色。
- en: This gives us some insight into how we can rearrange the data structure, calculate
    the matching colors quickly, and then rebuild the image without doing a billion
    comparisons.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们一些关于如何重新排列数据结构、快速计算匹配颜色，然后重建图像而不进行10亿次比较的见解。
- en: 'We can apply mask values to the RGB bytes with the following piece of command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令片段将掩码值应用于RGB字节：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will pick out the most significant 3 bits of red, green, and blue values.
    If we use this instead of the original color to create a `Counter` object, we'll
    see that we have 214 distinct values.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这将挑选出红色、绿色和蓝色值的最重要的3位。如果我们使用这个来创建一个“Counter”对象，我们会看到我们有214个不同的值。
- en: Rearranging the problem
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新排列问题
- en: The naïve use of the `product()` function to compare all pixels and all colors
    was a bad idea. There are 10 million pixels, but only 200,000 unique colors. When
    mapping the source colors to target colors, we only have to save 200,000 values
    in a simple map.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对所有像素和所有颜色使用“product()”函数进行比较是一个坏主意。有1000万个像素，但只有20万种独特的颜色。在将源颜色映射到目标颜色时，我们只需要在一个简单的映射中保存20万个值。
- en: 'We''ll approach it as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按以下方式处理：
- en: 'Compute the source to target color mapping. In this case, let''s use 3-bit
    color values as output. Each R, G, and B value comes from the eight values in
    the `range(0, 256, 32)` method. We can use this expression to enumerate all the
    output colors:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算源到目标颜色的映射。在这种情况下，让我们使用3位颜色值作为输出。每个R、G和B值来自“range(0, 256, 32)”方法中的八个值。我们可以使用这个表达式来枚举所有的输出颜色：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can then compute the Euclidean distance to the nearest color in our source
    palette, doing just 68,096 calculations. This takes about 0.14 seconds. It's done
    one time only and computes the 200,000 mappings.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们可以计算到源调色板中最近颜色的欧几里得距离，只需计算68,096次。这大约需要0.14秒。这只需要做一次，就可以计算出20万个映射。
- en: In one pass through the image, build a new image using the revised color table.
    In some cases, we can exploit the truncation of integer values. We can use an
    expression such as (`0b11100000&r`, `0b11100000&g`, `0b11100000&b`) to remove
    the least significant bits of an image color. We'll look at this additional reduction
    in computation later.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在图像的一次遍历中，使用修改后的颜色表构建一个新的图像。在某些情况下，我们可以利用整数值的截断。我们可以使用这样的表达式（`0b11100000&r`，`0b11100000&g`，`0b11100000&b`）来去除图像颜色的最不重要的位。我们稍后将看到这种额外的计算减少。
- en: This will replace a billion Euclidean distance calculations with 10 million
    dictionary lookups. This will replace 30 minutes of calculation with about 30
    seconds of calculation.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将用1亿次欧几里得距离计算替换成1000万次字典查找。这将用大约30秒的计算替换30分钟的计算。
- en: Instead of doing color mapping for all pixels, we'll create a static mapping
    from input to output values. We can build the image building using simple lookup
    mapping from original color to new color.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再为所有像素进行颜色映射，而是从输入到输出值创建一个静态映射。我们可以使用简单的查找映射从原始颜色到新颜色来构建图像。
- en: Once we have the palette of all 200,000 colors, we can apply the fast Manhattan
    distance to locate the nearest color in an output, such as the Crayola colors.
    This will use the algorithm for color matching shown earlier to compute the mapping
    instead of a result image. The difference will center on using the `palette.keys()`
    function instead of the `pixel_iter()` function.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了所有20万种颜色的调色板，我们就可以应用快速的曼哈顿距离来找到输出中最接近的颜色，比如蜡笔颜色。这将使用早期显示的颜色匹配算法来计算映射，而不是结果图像。区别将集中在使用“palette.keys()”函数而不是“pixel_iter()”函数。
- en: 'We''ll fold in yet another optimization: truncation. This will give us an even
    faster algorithm.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次引入另一个优化：截断。这将给我们一个更快的算法。
- en: Combining two transformations
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结合两个转换
- en: When combining multiple transformations, we can build a more complex mapping
    from source through intermediate targets to the result. To illustrate this, we'll
    truncate the colors as well as apply a mapping.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在结合多个转换时，我们可以从源到中间目标再到结果构建一个更复杂的映射。为了说明这一点，我们将截断颜色并应用映射。
- en: In some problem contexts, truncation can be difficult. In other cases, it's
    often quite simple. For example, truncating US postal ZIP codes from 9 to 5 characters
    is common. Postal codes can be further truncated to three characters to determine
    a regional facility that represents a larger geography.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些问题情境中，截断可能很困难。在其他情况下，它通常很简单。例如，将美国邮政编码从9位截断为5位是常见的。邮政编码可以进一步截断为三个字符，以确定代表更大地理区域的区域设施。
- en: For colors, we can use the bit-masking shown previously to truncate colors form
    three 8-bit values (24 bits, 16 million colors) to three 3-bit values (9 bits,
    512 colors).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于颜色，我们可以使用之前显示的位掩码来将三个8位值的颜色（24位，1600万种颜色）截断为三个3位值（9位，512种颜色）。
- en: 'Here is a way to build a color map that combines both distances to a given
    set of colors and truncation of the source colors:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一种构建颜色映射的方法，它同时结合了到给定一组颜色的距离和源颜色的截断：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We created a `range` object, `bit3`, that will iterate through all eight of
    the 3-bit color values.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个“range”对象“bit3”，它将遍历所有8个3位颜色值。
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `range` objects aren't like ordinary iterators; they can be used multiple
    times. As a result of this, the `product(bit3, bit3, bit3)` expression will produce
    all 512 color combinations that we'll use as the output colors.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: “range”对象不像普通的迭代器；它们可以被多次使用。因此，“product(bit3, bit3, bit3)”表达式将产生我们将用作输出颜色的所有512种颜色组合。
- en: For each truncated RGB color, we created a three tuple that has (0) the distance
    from all crayon colors, (1) the RGB color, and (2) the crayon `Color` object.
    When we ask for the minimum value of this collection, we'll get the closest crayon
    `Color` object to the truncated RGB color.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个截断的RGB颜色，我们创建了一个三元组，其中包括（0）与所有蜡笔颜色的距离，（1）RGB颜色和（2）蜡笔“颜色”对象。当我们要求这个集合的最小值时，我们将得到最接近截断的RGB颜色的蜡笔“颜色”对象。
- en: We built a dictionary that maps from the truncated RGB color to the closest
    crayon. In order to use this mapping, we'll truncate a source color before looking
    up the nearest crayon in the mapping. This use of truncation coupled with the
    precomputed mapping shows how we might need to combine mapping techniques.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建立了一个字典，将截断的RGB颜色映射到最接近的蜡笔。为了使用这个映射，我们将在查找映射中最接近的蜡笔之前截断源颜色。这种截断与预先计算的映射的结合显示了我们可能需要结合映射技术。
- en: 'The following are the commands for the image replacement:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是图像替换的命令：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This simply uses a number of PIL features to replace all of the pixels in a
    picture with other pixels.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是使用一些PIL功能来用其他像素替换图片中的所有像素。
- en: What we've seen is that the naïve use of some functional programming tools can
    lead to algorithms that are expressive and succinct, but also inefficient. The
    essential tools to compute the complexity of a calculation—sometimes called Big-O
    analysis—is just as important for functional programming as it is for imperative
    programming.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，一些函数式编程工具的天真使用可能导致表达力和简洁的算法，但也可能效率低下。计算计算复杂度的基本工具——有时被称为大O分析——对于函数式编程和命令式编程一样重要。
- en: The problem is not that the `product()` function is inefficient. The problem
    is that we can use the `product()` function in an inefficient algorithm.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 问题不在于`product()`函数效率低下。问题在于我们可以在一个低效的算法中使用`product()`函数。
- en: Permuting a collection of values
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排列一组值
- en: When we permute a collection of values, we'll elaborate all the possible orders
    for the items. There are ![Permuting a collection of values](graphics/B03652_09_02.jpg)
    ways to permute ![Permuting a collection of values](graphics/B03652_09_03.jpg)
    items. We can use permutations as a kind of brute-force solution to a variety
    of optimization problems.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们排列一组值时，我们将详细说明所有项目的可能顺序。有![排列一组值](graphics/B03652_09_02.jpg)种排列![排列一组值](graphics/B03652_09_03.jpg)项的方法。我们可以使用排列作为各种优化问题的一种蛮力解决方案。
- en: By visiting [http://en.wikipedia.org/wiki/Combinatorial_optimization](http://en.wikipedia.org/wiki/Combinatorial_optimization),
    we can see that the exhaustive enumeration of all permutations isn't appropriate
    for larger problems. The use of the `itertools.permutations()` function is a handy
    way to explore very small problems.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过访问[http://en.wikipedia.org/wiki/Combinatorial_optimization](http://en.wikipedia.org/wiki/Combinatorial_optimization)，我们可以看到对于更大的问题，穷举所有排列并不合适。使用`itertools.permutations()`函数是探索非常小问题的方便方法。
- en: One popular example of these combinatorial optimization problems is the assignment
    problem. We have *n* agents and *n* tasks, but the cost of each agent performing
    a given task is not equal. Imagine that some agents have trouble with some details,
    while other agents excel at these details. If we can properly assign tasks to
    agents, we can minimize the costs.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组合优化问题的一个常见例子是分配问题。我们有*n*个代理人和*n*个任务，但每个代理人执行给定任务的成本并不相等。想象一下，一些代理人在某些细节上有困难，而其他代理人在这些细节上表现出色。如果我们能正确分配任务给代理人，我们就可以最小化成本。
- en: We can create a simple grid that shows how well a given agent is able to perform
    a given task. For a small problem of a half-dozen agents and tasks, there will
    be a grid of 36 costs. Each cell in the grid shows agents 0 to 5 performing tasks
    A to F.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个简单的网格，显示给定代理人执行给定任务的能力。对于半打代理人和任务的小问题，将有一个36个成本的网格。网格中的每个单元格显示代理人0到5执行任务A到F。
- en: We can easily enumerate all the possible permutations. However, this approach
    doesn't scale well. 10! is 3,628,800\. We can see this sequence of 3 million items
    with the `list(permutations(range(10)))` method.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松列举所有可能的排列。然而，这种方法不具有良好的可扩展性。10！等于3,628,800。我们可以使用`list(permutations(range(10)))`方法查看这个包含300万项的序列。
- en: 'We would expect to solve a problem of this size in a few seconds. If we double
    the size of the problem to 20!, we would have a bit of a scalability problem:
    there would be 2,432,902,008,176,640,000 permutations. If it takes about 0.56
    seconds to generate 10! permutations, then to generate 20! permutations, it would
    take about 12,000 years.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望在几秒钟内解决这样大小的问题。如果我们将问题规模扩大到20！，我们将会遇到可扩展性问题：将有2,432,902,008,176,640,000种排列。如果生成10！排列大约需要0.56秒，那么生成20！排列将需要大约12,000年。
- en: 'Assume that we have a cost matrix with 36 values that show the costs of six
    agents and six tasks. We can formulate the problem as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个包含36个值的成本矩阵，显示了六个代理人和六个任务的成本。我们可以将问题表述如下：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We've created all permutations of tasks for our six agents. We've computed the
    sums of all the costs in our cost matrix for each task assigned to each agent.
    The minimum cost is the optimal solution. In many cases, there might be multiple
    optimal solutions; we'll locate all of them.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了六个代理人的所有任务的排列。我们已经计算了分配给每个代理人的每个任务的成本矩阵的所有成本之和。最小成本就是最佳解决方案。在许多情况下，可能会有多个最佳解决方案；我们将找到所有这些解决方案。
- en: For small text-book examples, this is very fast. For larger examples, an approximation
    algorithm is more appropriate.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小型教科书示例，这是非常快的。对于较大的示例，逼近算法更合适。
- en: Generating all combinations
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成所有组合
- en: The `itertools` module also supports computing all combinations of a set of
    values. When looking at combinations, the order doesn't matter, so there are far
    fewer combinations than permutations. The number of combinations is often stated
    as ![Generating all combinations](graphics/B03652_09_04.jpg). This is the number
    of ways that we can take combinations of `r` things at a time from a universe
    of `p` items overall.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`itertools`模块还支持计算一组值的所有组合。在查看组合时，顺序并不重要，因此组合远少于排列。组合的数量通常表示为![生成所有组合](graphics/B03652_09_04.jpg)。这是我们可以从整体上取`p`个项目中的`r`个项目的组合方式。'
- en: 'For example, there are 2,598,960 5-card poker hands. We can actually enumerate
    all 2 million hands by executing the following command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，有2,598,960种5张牌的扑克手。我们可以通过执行以下命令列举所有200万手：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'More practically, we have a dataset with a number of variables. A common exploratory
    technique is to determine the correlation among all pairs of variables in a set
    of data. If there are *v* variables, then we will enumerate all variables that
    must be compared by executing the following command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 更实际的是，我们有一个包含多个变量的数据集。一个常见的探索技术是确定数据集中所有变量对之间的相关性。如果有*v*个变量，那么我们将枚举必须通过执行以下命令进行比较的所有变量：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s get some sample data from [http://www.tylervigen.com](http://www.tylervigen.com)
    to show how this will work. We''ll pick three datasets with the same time range:
    numbers 7, 43, and 3890\. We''ll simply laminate the data into a grid, repeating
    the year column.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从[http://www.tylervigen.com](http://www.tylervigen.com)获取一些样本数据，以展示这将如何工作。我们将选择三个具有相同时间范围的数据集：数字7、43和3890。我们将简单地将数据层压成网格，重复年份列。
- en: 'This is how the first and the remaining rows of the yearly data will look:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是年度数据的第一行和剩余行的样子：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is how we can use the `combinations()` function to emit all the combinations
    of the nine variables in this dataset, taken two at a time:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何使用`combinations()`函数来生成数据集中九个变量的所有组合，每次取两个：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There are 36 possible combinations. We'll have to reject the combinations that
    involve `year` and `year`. These will trivially correlate with a value of 1.00.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有36种可能的组合。我们将不得不拒绝涉及`year`和`year`的组合。这些将与值1.00显然相关。
- en: 'Here is a function that picks a column of data out of our dataset:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个从我们的数据集中挑选数据列的函数：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This allows us to use the `corr()` function from [Chapter 4](ch04.html "Chapter 4. Working
    with Collections"), *Working with Collections*, to compare two columns of data.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够使用[第4章](ch04.html "第4章。与集合一起工作")中的`corr()`函数，比较两列数据。
- en: 'This is how we can compute all combinations of correlations:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何计算所有相关组合的方法：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: For each combination of columns, we've extracted the two columns of data from
    our data set and used multiple assignments to separate the header from the remaining
    rows of data. If the headers match, we're comparing a variable to itself. This
    will be `True` for the three combinations of `year` and `year` that stem from
    the redundant year columns.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一列的组合，我们从数据集中提取了两列数据，并使用多重赋值将标题与剩余的数据行分开。如果标题匹配，我们正在比较一个变量与自身。这将对来自冗余年份列的`year`和`year`的三种组合为`True`。
- en: Given a combination of columns, we will compute the correlation function and
    then print the two headings along with the correlation of the columns. We've intentionally
    chosen some datasets that show spurious correlations with a dataset that doesn't
    follow the same pattern. In spite of this, the correlations are remarkably high.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一组列的组合，我们将计算相关函数，然后打印两个标题以及列的相关性。我们故意选择了一些显示与不遵循相同模式的数据集的虚假相关性的数据集。尽管如此，相关性仍然非常高。
- en: 'The results look like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It's not at all clear what this pattern means. We used a simple expression,
    `combinations(range(9), 2)`, to enumerate all the possible combinations of data.
    This kind of succinct, expressive technique makes it easier to focus on the data
    analysis issues instead of the Combinatoric algorithm considerations.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的含义一点也不清楚。我们使用了一个简单的表达式`combinations(range(9), 2)`，来枚举所有可能的数据组合。这种简洁、表达力强的技术使我们更容易专注于数据分析问题，而不是组合算法的考虑。
- en: Recipes
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例
- en: The itertools chapter of the Python library documentation is outstanding. The
    basic definitions are followed by a series of recipes that are extremely clear
    and helpful. Since there's no reason to reproduce these, we'll reference them
    here. They are the required reading materials on functional programming in Python.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Python库文档中的itertools章节非常出色。基本定义后面是一系列非常清晰和有用的示例。由于没有理由重复这些，我们将在这里引用它们。它们是Python中函数式编程的必读材料。
- en: Section *10.1.2*, *Itertools Recipes*, of *Python Standard Library* is a wonderful
    resource. Visit [https://docs.python.org/3/library/itertools.html#itertools-recipes](https://docs.python.org/3/library/itertools.html#itertools-recipes)
    more details.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python标准库*的*10.1.2*节*Itertools Recipes*是一个很好的资源。访问[https://docs.python.org/3/library/itertools.html#itertools-recipes](https://docs.python.org/3/library/itertools.html#itertools-recipes)获取更多详细信息。'
- en: These function definitions aren't importable functions in the `itertools` modules.
    These are ideas that need to be read and understood and then, perhaps, copied
    or modified before inclusion in an application.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数定义不是`itertools`模块中可导入的函数。这些是需要阅读和理解的想法，然后可能在应用程序中复制或修改的想法。
- en: 'The following table summarizes some recipes that show functional programming
    algorithms built from the itertools basics:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表总结了一些从itertools基础构建的函数式编程算法的示例：
- en: '| Function Name | Arguments | Results |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 函数名称 | 参数 | 结果 |'
- en: '| --- | --- | --- |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `powerset` | `(iterable)` | This generates all the subsets of the iterable.
    Each subset is actually a `tuple` object, not a set instance. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `powerset` | `(iterable)` | 这会生成可迭代对象的所有子集。每个子集实际上是一个`tuple`对象，而不是一个集合实例。'
- en: '| `random_product` | `(*args, repeat=1)` | This randomly selects from `itertools.product(*args,
    **kwds)`. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `random_product` | `(*args, repeat=1)` | 这从`itertools.product(*args, **kwds)`中随机选择。'
- en: '| `random_permutation` | `(iterable, r=None)` | This randomly selects from
    `itertools.permutations(iterable, r)`. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '`random_permutation` | `(iterable, r=None)` | 这从`itertools.permutations(iterable,
    r)`中随机选择。'
- en: '| `random_combination` | `(iterable, r)` | This randomly selects from `itertools.combinations(iterable,
    r)`. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `random_combination` | `(iterable, r)` | 这从`itertools.combinations(iterable,
    r)`中随机选择。'
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at a number of functions in the `itertools` module.
    This library module provides a number of functions that help us work with iterators
    in sophisticated ways.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了`itertools`模块中的许多函数。这个库模块提供了许多帮助我们以复杂的方式处理迭代器的函数。
- en: We looked at the `product()` function that will compute all the possible combinations
    of the elements chosen from two or more collections. The `permutations()` function
    gives us different ways to reorder a given set of values. The `combinations()`
    function returns all the possible subsets of the original set.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看了`product()`函数，它将计算从两个或多个集合中选择的元素的所有可能组合。`permutations()`函数给我们提供了重新排列给定一组值的不同方式。`combinations()`函数返回原始集合的所有可能子集。
- en: We also looked at ways in which the `product()` and `permutations()` functions
    can be used naïvely to create extremely large result sets. This is an important
    cautionary note. A succinct and expressive algorithm can also involve a vast amount
    of computation. We must perform basic complexity analysis to be sure that the
    code will finish in a reasonable amount of time.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看了`product()`和`permutations()`函数可以天真地用来创建非常大的结果集的方法。这是一个重要的警示。简洁而富有表现力的算法也可能涉及大量的计算。我们必须进行基本的复杂性分析，以确保代码能在合理的时间内完成。
- en: In the next chapter, we'll look at the `functools` module. This module includes
    some tools to work with functions as first-class objects. This builds on some
    material shown in [Chapter 2](ch02.html "Chapter 2. Introducing Some Functional
    Features"), *Introducing Some Functional Features*, and [Chapter 5](ch05.html
    "Chapter 5. Higher-order Functions"), *Higher-order Functions*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看一下`functools`模块。这个模块包括一些用于处理函数作为一等对象的工具。这是建立在[第2章](ch02.html "第2章。介绍一些函数特性")
    *介绍一些函数特性*和[第5章](ch05.html "第5章。高阶函数") *高阶函数*中展示的一些材料上。
