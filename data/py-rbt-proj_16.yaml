- en: Machine Learning
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器学习
- en: Robots and computers from its primitive days to even right now are being programmed
    to do a set of activities. These activities can be very large. Hence, to develop
    complex programs, there is a need for a lot of software engineers who work day
    and night to achieve a certain functionality. This is workable when the problem
    is well defined. But what about situations when the problem is also way complex?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从其原始时期到如今，机器人和计算机都在被编程执行一系列活动。这些活动可能非常庞大。因此，为了开发复杂的程序，需要大量的软件工程师日夜工作以实现特定的功能。当问题定义得很好时，这是可行的。但是，当问题也非常复杂时怎么办呢？
- en: Learning is something that has made us humans what we are. Our experiences molded
    us to adapt to situations in a better and a more efficient way. Every time we
    do something, we know more. This makes us better at doing that task over a period
    of time. It is said practice makes a man perfect, and it is learning through doing
    things again and again that makes us better.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 学习是我们人类之所以成为我们的原因。我们的经验塑造了我们以更好地、更有效地适应情况。每次我们做某事，我们就知道得更多。这使得我们在一段时间内更好地完成这项任务。俗话说，熟能生巧，而通过反复做事情来学习使我们变得更好。
- en: However, let us step back and define what learning is? I would like to quote
    Google here according to it, *It is a knowledge acquired through study, experience
    or being taught*. So, learning is basically a way of acquiring information from
    our surroundings to understand a process and its nature.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们退一步来定义什么是学习？我想引用谷歌的定义，*它是通过学习、经验或被教导获得的知识*。因此，学习基本上是一种从我们的周围环境中获取信息以理解过程及其本质的方式。
- en: Now, you must be thinking, wait a minute, haven't we made our system learn a
    lot of vision data in previous chapters when we were making the guard robot. You
    would be absolutely correct to think so. However, the learning can be done in
    different ways. What may work for one kind of problem can be futile for some other
    kind of problem. Hence, there are various types of learning algorithms and their
    principles. In this chapter, we will be focusing on an algorithm named **k-nearest
    neighbor**. It's named the **lazy algorithm**. I love this algorithm personally
    for classification. Why? Because technically there is no training phase. How?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能正在想，等等，我们不是在制作守卫机器人的前几章中使我们的系统学习了很多视觉数据吗？你的想法完全正确。然而，学习可以通过不同的方式进行。可能适用于一种类型的问题的方法可能对其他类型的问题毫无用处。因此，存在各种类型的机器学习算法及其原理。在本章中，我们将重点关注一个名为**k-最近邻**的算法。它被称为**懒惰算法**。我个人非常喜欢这个算法用于分类。为什么？因为从技术上讲，没有训练阶段。怎么呢？
- en: k-nearest neighbor is actually a smart algorithm. Rather than computing a regression
    of data provided and do a lot of mathematics calculations, it simply takes a structured
    data from the dataset provided. Whenever there is new data that has come in for
    prediction, then it simply searches the closest *k* match of the data provided
    by the user to the database based on its classification given. So, in this chapter,
    we will learn how this algorithm will work and how we can use it to make our home
    smart.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: k-最近邻实际上是一个智能算法。它不是对提供的数据进行回归计算并进行大量的数学计算，而是简单地从提供的数据集中获取结构化数据。每当有新的数据用于预测时，它就会根据用户提供的数据的分类，在数据库中简单地搜索与用户提供的数据最接近的*k*个匹配项。因此，在本章中，我们将学习这个算法是如何工作的，以及我们如何使用它来使我们的家庭智能化。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Making a dataset
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作数据集
- en: Prediction using dataset
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据集进行预测
- en: Making your home learn
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使你的家庭学会学习
- en: Home learning and automation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 家庭学习和自动化
- en: Making a dataset
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作数据集
- en: Like in [Chapter 10](f5d8044d-e608-4ab6-adca-52ec2689f115.xhtml), *Making a
    Guard Robot*, we have used multiple images for the user to train the model to
    find out whether the object in the image is a man or something else. In a very
    similar way, we would have to make a dummy dataset so that the machine learning
    algorithm can predict based on that data what should be done.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在第10章[制作守卫机器人](f5d8044d-e608-4ab6-adca-52ec2689f115.xhtml)中一样，我们使用了多张图片来训练模型，以确定图像中的物体是人还是其他东西。以非常相似的方式，我们不得不制作一个虚拟数据集，这样机器学习算法就可以根据这些数据预测应该做什么。
- en: To make a dataset, we need to understand what data is being considered. In this
    chapter, we will be making a machine learning algorithm based on time and the
    temperature to predict whether the fan should be on or off. Hence, there are at
    least two things that should be provided by us to the system one being `Temperature`,
    and the other would be `Time` so that the prediction can take place. But one thing
    to remember is that we are talking about a supervised learning algorithm, so to
    train the model, we need to also give the outcome of `Temperature` and `Time`
    onto the state of the fan. Here, the state of the fan would be either on or off.
    Hence, we can depict it using `0` or `1`. Now let's go ahead and make a dataset
    by ourselves.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个数据集，我们需要了解正在考虑哪些数据。在本章中，我们将基于时间和温度创建一个机器学习算法，以预测风扇应该开启还是关闭。因此，至少有两件事应该由我们提供给系统，一个是`Temperature`，另一个是`Time`，以便进行预测。但有一点要记住，我们正在谈论一个监督学习算法，因此为了训练模型，我们还需要提供`Temperature`和`Time`的输出到风扇的状态。在这里，风扇的状态将是开启或关闭。因此，我们可以用`0`或`1`来表示它。现在让我们自己创建一个数据集。
- en: 'Now, to make a dataset, you simply have to open Microsoft Excel and start writing
    the dataset as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要创建一个数据集，你只需打开Microsoft Excel并按照以下方式开始编写数据集：
- en: '![](img/f96de387-2d29-4a30-a656-6aabaaf3b3ab.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f96de387-2d29-4a30-a656-6aabaaf3b3ab.png)'
- en: It is always better to have a dataset of more than 20 sets of data. Also, its
    important that the data has a distinct characteristic and its not random data.
    For example, in the preceding case, you can see that at `12.44` when the temperature
    is `28`, the fan will be on; however, at the same time, when the time is `12.13`
    and temperature is `21`, then the fan is off.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个包含超过20组数据的数据集总是更好的。此外，数据必须具有独特的特征，而不是随机数据。例如，在前面的例子中，你可以看到当温度为`28`时，在`12.44`时风扇是开启的；然而，在相同的时间，当时间是`12.13`且温度为`21`时，风扇是关闭的。
- en: Once you have created a dataset, then you must save it with the name `dataset` in
    the CSV format. There may be some users who would not use a Microsoft Excel, in
    which case you can write the data with the same format in text editor and finally
    save it in the CSV format.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了一个数据集，你必须以`dataset`的名称将其保存为CSV格式。可能会有一些用户不会使用Microsoft Excel，在这种情况下，你可以在文本编辑器中以相同的格式写入数据，最后以CSV格式保存。
- en: Once you have the `dataset.csv` files, then you must go ahead and copy them
    into the place where you will be saving the upcoming code. Once you are done,
    then we can move on to the next step.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了`dataset.csv`文件，你必须将它们复制到将要保存即将到来的代码的地方。一旦你完成，我们就可以继续下一步。
- en: Remember that the better the quality of data, the better the learning process.
    So you may take some time and carefully craft your dataset so that it does make
    sense.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，数据的质量越好，学习过程就越好。所以你可能需要花一些时间，仔细制作你的数据集，以确保它有意义。
- en: Predicting using a dataset
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据集进行预测
- en: 'Without much talking, let''s take a look at the following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 不多说了，让我们看看下面的代码：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'So, let''s see what we are doing here:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们看看我们在做什么：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We are importing `numpy` to our program; this helps us handle lists and matrices:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`numpy`导入到我们的程序中；这有助于我们处理列表和矩阵：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we are importing a library named `pandas`; this helps us read files in
    comma-separated values or in other words, CSV files. We will be using CSV files
    to store our data and access it for learning process:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们导入了一个名为`pandas`的库；这有助于我们读取以逗号分隔的值文件，换句话说，CSV文件。我们将使用CSV文件来存储我们的数据，并在学习过程中访问它：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, we are importing `KneighborsClassifier` from the library `sklearn`. `sklearn`
    itself is a huge library; hence, we are importing only a part of it as we will
    not be using all of it in this program:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们从`sklearn`库中导入`KneighborsClassifier`。`sklearn`本身是一个庞大的库；因此，我们只导入其中的一部分，因为我们不会在这个程序中使用它：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, we are giving value to variable `knn` wherein the value would be `KNeighborsClassifer(n_neighbors
    =5)`; what this means is that it is using the `KneighborsClassifer()` function
    with the argument as `n_neighbors=5`. This argument tells the `KneighborsClassifer`
    function that we will be having five neighbors in the algorithm. Further to this
    using this declaration, the whole function can be called using `knn`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们给变量`knn`赋值，其值将是`KNeighborsClassifer(n_neighbors =5)`；这意味着我们正在使用带有参数`n_neighbors=5`的`KneighborsClassifer()`函数。这个参数告诉`KneighborsClassifer`函数，在算法中我们将有五个邻居。进一步来说，使用这个声明，整个函数可以通过`knn`来调用：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we are providing value to a variable called `data` and the value passed
    is `pd.read_csv(''dataset.csv'')`; what this means is that whenever `data` is
    called, then a `pd.read_csv()` function from the `pandas` library will be called.
    The purpose of this function is to read data from the CSV files. Here, the argument
    passed is `dataset.csv`; hence, it is indicating which data would be read by the
    function. In our case, it will read from a file name: `dataset.csv`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在为名为`data`的变量赋值，传递的值是`pd.read_csv('dataset.csv')`；这意味着每当调用`data`时，就会调用来自`pandas`库的`pd.read_csv()`函数。该函数的目的是从CSV文件中读取数据。在这里，传递的参数是`dataset.csv`；因此，它指示函数将读取哪些数据。在我们的例子中，它将从一个名为`dataset.csv`的文件中读取：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the following line, we are passing value to the variable `x`, and the value
    being passed is `np.array(data[[''Time, ''Temp'']])`. Now the `np.array` function
    to make an array through the `numpy` library. This array will store the data by
    the name of `Time` and `Temp`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行中，我们正在将值传递给变量`x`，传递的值是`np.array(data[['Time', 'Temp']])`。现在，使用`numpy`库的`np.array`函数创建一个数组。这个数组将按`Time`和`Temp`的名称存储数据：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Just like the previous time, we are storing `State` in an array made through
    the `numpy` library `.ravel()` function at the end would transpose the array.
    This is done so that the mathematical functions can be done between two arrays—`x`
    and `y`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，我们使用`numpy`库的`.ravel()`函数将`State`存储在一个数组中。这样做是为了使数学函数可以在两个数组——`x`和`y`之间进行操作：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this small line, we are using the function from the `knn` library called `fit()`
    what it is doing is fitting the model using the `x` as the primary data and `y`
    as the output resultant data:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这短短的一行中，我们使用`knn`库中的`fit()`函数，它的作用是使用`x`作为主要数据，`y`作为输出结果数据来拟合模型：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this line, we are requesting the data from the user. In the first line, we
    will be printing `Enter time` and thereafter wait for user to enter the time.
    After user has entered the time, it will be stored in the variable named `time`.
    Once that is done, then it would move on to the next line; the code and it would
    print `Enter temp` once that is prompted to the user it would wait for data to
    be collected. Once data is fetched by the user, it will store that data in the
    variable called `temp:`
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行中，我们请求用户的数据。在第一行，我们将打印`Enter time`，然后等待用户输入时间。用户输入时间后，它将被存储在名为`time`的变量中。一旦完成，然后就会进入下一行；代码将打印`Enter
    temp`。一旦提示用户，它将等待收集数据。一旦用户收集到数据，它将把数据存储在名为`temp`的变量中：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we are making an empty list by the name of `data`; this list will be
    used for calculating the resultant state of the output. As all the machine learning
    algorithm is working in list data type. Hence, the input must be given for decision
    in the form of a list itself:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为`data`的空列表；这个列表将用于计算输出结果的状态。因为所有的机器学习算法都是在列表数据类型上工作的。因此，输入必须以列表的形式给出，以便进行决策：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, we are adding data to the list that we just created with the name `data`.
    First, `time` will be added, followed by `temp`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将数据添加到我们刚刚创建的名为`data`的列表中。首先，添加`time`，然后是`temp`：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once that is done, a function named `predict` from the `knn` algorithm will
    be used to predict the output based on the list provided with the name of `data`.
    The output of the prediction algorithm is fetched to a variable by the name  `a`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，将使用名为`predict`的`knn`算法中的函数来根据名为`data`的列表预测输出。预测算法的输出被检索到一个名为`a`的变量中：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Finally, once the prediction is done, then we would read the value of   `a` and
    remember that all the data I/O is happening in the form of lists. Hence, the data
    output given by the prediction algorithm would also be in the list format. Hence,
    we are printing the first element of the list.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦完成预测，我们就会读取`a`的值，并记住所有数据输入/输出都是以列表的形式发生的。因此，预测算法给出的数据输出也将以列表格式。因此，我们正在打印列表的第一个元素。
- en: This output will predict which state will be of the fan according to the dataset
    given by the user. So, go ahead and give a temperature and a time and let the
    system predict the outcome for you. See if it works fine or not. If it doesn't,
    then try adding some more datasets to the CSV files or see whether the values
    in the dataset actually make any sense. I am sure that you end up with a wonderful
    predictive system.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出将预测根据用户提供的数据集，风扇将处于哪种状态。所以，请继续提供一个温度和时间，让系统为您预测结果。看看它是否工作正常。如果不正常，那么尝试向CSV文件中添加更多的数据集，或者看看数据集中的值是否有意义。我相信你最终会得到一个出色的预测系统。
- en: Making your home learn
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让你的家学会
- en: 'Once this constitution is done, go ahead and wire it up, as shown here:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成这一宪法，就可以按照下面的图示进行接线：
- en: '![](img/855c4bae-d685-44b1-bb0c-5926da8035a2.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/855c4bae-d685-44b1-bb0c-5926da8035a2.png)'
- en: 'Once that is set, it is time for us to write the following code on to our Raspberry
    Pi:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置好，就轮到我们将在我们的树莓派上编写以下代码：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, let''s see what we have done here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们在这里做了什么：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this line of the code, we have assigned the value `open("dataset.csv", "a+")`
    to the variable `f`. Thereafter, the `open()` function will open the file that
    is passed on to its argument, which in our case is `dataset.csv`; the argument `a+`
    stands for appending the value at the end of the CSV file. Hence, what this line
    will do is to open the file `dataset.csv` and add a value that we will pass later
    on:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行代码中，我们将`open("dataset.csv", "a+")`的值赋给了变量`f`。之后，`open()`函数将打开传递给其参数的文件，在我们的例子中是`dataset.csv`；参数`a+`表示在CSV文件的末尾追加值。因此，这一行将打开`dataset.csv`文件，并添加我们稍后传递的值：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We are declaring an empty string by the name of `data`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过名为`data`的名称声明了一个空字符串：
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We are adding values of hours and minutes to the string, separated by a dot
    in between for differentiation. Hence, the data will look like `HH.MM`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在将小时和分钟的值添加到字符串中，中间用点分隔以示区别。因此，数据将看起来像`HH.MM`：
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We are using this line to read the humidity and temperature reading from the
    DHT 11 sensor and the values that would be passed on to the variables `humidity`
    and `temperature`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这一行来读取DHT 11传感器的湿度和温度读数，并将这些值传递给变量`humidity`和`temperature`：
- en: '[PRE19]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once the data is read, we are adding temperature to the variable `data` as
    well. Hence, now the data would look like this `HH.MM` and `TT.TT`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦读取数据，我们将温度也添加到变量`data`中。因此，现在数据将看起来像这样`HH.MM`和`TT.TT`：
- en: '[PRE20]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, we have defined different types of states which are corresponding to
    the switch combinations. The table for it is as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了不同类型的与开关组合相对应的状态。相应的表格如下：
- en: '| **Switch 1** | **Switch 2** | **State** |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **开关 1** | **开关 2** | **状态** |'
- en: '| `0` | `0` | `0` |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `0` |'
- en: '| `0` | `1` | `1` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `1` |'
- en: '| `1` | `0` | `2` |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `2` |'
- en: '| `1` | `1` | `3` |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `3` |'
- en: 'Hence, by the value of state, we can understand which switch would be turned
    on and which would be turned off:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过状态值，我们可以理解哪个开关会被打开，哪个会被关闭：
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, the value of state is also added to the variable named `data`. Now,
    finally, the data would look like `HH.MM`, `TT.TT`, and `S`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将状态值也添加到名为`data`的变量中。现在，数据将看起来像`HH.MM`，`TT.TT`和`S`：
- en: '[PRE22]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, using the `write()` function, we are writing the value of data to the file
    that we have already defined by the value `f` earlier.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`write()`函数，我们将数据的值写入我们之前通过值`f`定义的文件。
- en: 'Hence, with every single switch on or off, the data would be collected, and
    the value would be recorded with the time stamp in that file. This data can then
    be used to predict the state of the home at any given time without any intervention:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每当单个开关打开或关闭时，数据都会被收集，并且值会记录在该文件中的时间戳。然后，可以使用这些数据来预测在任何给定时间家里的状态，而不需要任何干预：
- en: '[PRE23]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we are comparing the state with the `prev_state` as you can see in our
    program. The previous state is calculated at the start of our program. So, if
    there is any change in the state of the system, then the value of `prev_state`
    and `state` would be different. This will lead to the `if` statement to be true.
    When that happens, the data would be written onto our file using the `write()`
    function. The argument passed is the value that needs to be written. Finally,
    the value of count is increased by `1`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在将状态与`prev_state`进行比较，正如你在我们的程序中看到的那样。上一个状态是在我们程序开始时计算的。所以，如果系统状态有任何变化，那么`prev_state`和`state`的值就会不同。这将导致`if`语句为真。当这种情况发生时，数据将通过`write()`函数写入我们的文件。传递的参数是需要写入的值。最后，计数器的值增加`1`。
- en: Once this is left running for a few hours or may be days, then it would collect
    some really useful data regarding your switching pattern of the lights and fan.
    Thereafter, this data can be fetched to the previous program wherein it would
    be able to to take its own decision based on the time and temperature.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这个程序运行几个小时或者可能是几天，它就会收集一些关于你的灯光和风扇开关模式的有用数据。然后，这些数据可以被检索到之前的程序中，它将能够根据时间和温度做出自己的决定。
- en: Home learning and automation
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 家庭学习和自动化
- en: 'Now that in the previous section we have understood how the learning works,
    it''s time to use this concept to make a robot that will automatically understand
    how we function and make decisions. Based on our decisions, the system will judge
    what should be done. But this time, rather than giving a set of data by the user,
    let''s make this program create the data for itself. Once the data seems sufficient
    for itself to function. So, without much explanation, let''s get right into it:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 既然在前一节我们已经了解了学习是如何工作的，现在是时候使用这个概念来制作一个能够自动理解我们如何运作和做决定的机器人了。基于我们的决定，系统将判断应该做什么。但这次，我们不是通过用户提供一组数据，而是让这个程序自己生成数据。一旦数据看起来足够它自己运作，那么，不多做解释，让我们直接进入正题：
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now let''s see what we have done here. In this program, the first part of the
    program inside the condition `while count < 200:` is exactly the same as what
    we have done in the last code. So, it is just doing the things according to the
    user, and at the same time, it''s taking in the values from the users to understand
    their working behavior:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们在这里做了什么。在这个程序中，`while count < 200:`条件下的程序的第一部分与我们之前所做的代码完全相同。所以它只是在按照用户的要求做事，同时，它正在从用户那里获取值以了解他们的工作行为：
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Thereafter, we have the second part of the code that will start to execute
    when the count is beyond `200` that is inside the preceding loop:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，当计数器超过`200`时，将开始执行代码的第二部分，这部分代码位于前面的循环中：
- en: '[PRE26]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In this line, we are forming an empty string by the name of time where we would
    be storing the value of time:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行中，我们创建了一个名为`time`的空字符串，我们将在这里存储时间的值：
- en: '[PRE27]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We are storing the values of time into the variable named `H` and `M`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将时间的值存储在名为`H`和`M`的变量中：
- en: '[PRE28]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We are now storing the value of time in the string `time`. This would include
    both hours and minutes:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将时间的值存储在字符串`time`中。这将包括小时和分钟：
- en: '[PRE29]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'For the sake of ease of calculations and reducing the computing load on the
    system, we are reducing the size of the temperature variable . We are doing it
    by removing the decimal places. To do that `TT.TT`; we are simply eliminating
    the decimal point and converting it into integer. This is done by the function
    named `int()`. The value of temperature in `int` will be stored in the variable
    named `temp`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便计算和减少系统计算负载，我们正在减小温度变量的尺寸。我们通过删除小数点来实现这一点。为了做到这一点，`TT.TT`；我们只是消除了小数点，将其转换为整数。这是通过名为`int()`的函数完成的。温度的整数值将存储在名为`temp`的变量中：
- en: '[PRE30]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here, we are adding the value of the time and the temperature to a list named `test_set`
    if you look in the program, then you will see the declaration of an empty set
    in the mid of the program. So, now this `test_set` has the value of `time` and `temp`, which
    can be further used by the prediction algorithm to predict the state:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将时间和温度的值添加到名为`test_set`的列表中，如果你查看程序，你会看到程序中间声明了一个空集合。所以，现在这个`test_set`包含了`time`和`temp`的值，这些值可以被预测算法进一步用于预测状态：
- en: '[PRE31]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Using the simple function named `predict()` from the `knn` function, we can
    predict the value of the state. All we need to do is to pass on the data or `test_set`
    list over to the predict function. The output of this function will be a list
    that will be stored in a variable named `a`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`knn`函数中的简单函数`predict()`，我们可以预测状态值。我们所需做的只是将数据或`test_set`列表传递给预测函数。该函数的输出将是一个列表，将被存储在一个名为`a`的变量中：
- en: '[PRE32]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The value of `Out` will be set to the first element of the list `a`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Out`的值将被设置为列表`a`的第一个元素：'
- en: '[PRE33]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Using the preceding code block, we are able to switch on the light and fans
    selectively based on the state predicted by the algorithm. Hence, using this,
    the program would be able to automatically predict and switch on or off the light
    and the fans without your intervention.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的代码块，我们能够根据算法预测的状态来选择性地打开灯和风扇。因此，使用这种方法，程序能够在没有你的干预下自动预测并打开或关闭灯和风扇。
- en: Summary
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we understood how machine learning works even without learning.
    We understood how datasets can be provided, and we can create a new dataset using
    the existing system. Finally, we understood how the system can work seamlessly
    to collect data, learn from that data, and finally, provide the input. Want to
    build a wheeled self-balancing robot? Well, then see you in the next chapter!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了即使不学习也能如何进行机器学习。我们了解了如何提供数据集，以及我们可以如何使用现有系统创建一个新的数据集。最后，我们了解了系统如何无缝地收集数据、从数据中学习，并最终提供输入。想要构建一个轮式自平衡机器人？那么，下一章见！
