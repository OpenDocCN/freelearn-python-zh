- en: '[*Chapter 8*](B16119_08_Final_PD_ePub.xhtml#_idTextAnchor227): Business Logic
    – Supporting Business Processes'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第8章*](B16119_08_Final_PD_ePub.xhtml#_idTextAnchor227)：业务逻辑 - 支持业务流程'
- en: In the previous chapters, we learned how to use models to build the application
    data structures, and then how to explore and interact with that data using the
    ORM API and recordsets.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了如何使用模型来构建应用程序数据结构，然后如何使用ORM API和记录集探索和交互数据。
- en: In this chapter, we will put all this together to implement business logic patterns
    that are common in applications. We will learn about the several ways business
    logic can be triggered, as well as some common patterns that are used to support
    them. We will also learn about important development techniques, such as logging,
    debugging, and testing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将把这些内容结合起来实现应用程序中常见的业务逻辑模式。我们将了解业务逻辑可以触发的几种方式，以及一些常用的支持模式。我们还将了解重要的开发技术，如日志记录、调试和测试。
- en: 'We''ll cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论以下主题：
- en: Learning project – the book checkout module
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习项目 - 书籍借阅模块
- en: Ways to trigger business logic
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发业务逻辑的方法
- en: Understanding ORM method decorators for recordsets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解ORM方法装饰器用于记录集
- en: Exploring useful data model patterns
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索有用的数据模型模式
- en: Using the ORM built-in methods
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ORM内置方法
- en: Adding onchange user interface logic
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加onchange用户界面逻辑
- en: The message and activity features
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息和活动功能
- en: Creating a wizard
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建向导
- en: Raising exceptions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出异常
- en: Writing unit tests
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写单元测试
- en: Using log messages
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用日志消息
- en: Learning about the available developer tools
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解可用的开发者工具
- en: By the end of this chapter, you should be confident in designing and implementing
    business logic automation and know how to test and debug your code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该对设计和实现业务逻辑自动化充满信心，并知道如何测试和调试你的代码。
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will create a new `library_checkout` add-on module. It depends
    on the `library_app` and `library_member` add-on modules, which we created in
    the previous chapters.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个新的`library_checkout`附加模块。它依赖于我们在前几章中创建的`library_app`和`library_member`附加模块。
- en: The code for these add-on modules can be found in this book's GitHub repository,
    at [https://github.com/PacktPublishing/Odoo-15-Development-Essentials-Fifth-Edition](https://github.com/PacktPublishing/Odoo-15-Development-Essentials-Fifth-Edition),
    in the `ch08` directory.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些附加模块的代码可以在本书的GitHub仓库中找到，在[https://github.com/PacktPublishing/Odoo-15-Development-Essentials-Fifth-Edition](https://github.com/PacktPublishing/Odoo-15-Development-Essentials-Fifth-Edition)的`ch08`目录下。
- en: Both of these add-on modules need to be available in the Odoo add-ons path so
    that they can be installed and used.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个附加模块需要在Odoo附加模块路径中可用，以便它们可以被安装和使用。
- en: Learning project – the book checkout module
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习项目 - 书籍借阅模块
- en: The master data structures for the library application are in place. Now, we
    want to add transactions to our system. We would like library members to be able
    to borrow books. This means we should keep track of book availability and returns.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图书馆应用程序的主数据结构已经就绪。现在，我们希望向我们的系统中添加交易。我们希望图书馆会员能够借阅书籍。这意味着我们应该跟踪书籍的可用性和归还情况。
- en: Each book checkout has a life cycle, from the moment they are created to the
    moment when the books are returned. It is a simple workflow that can be represented
    as a Kanban board, where the several stages are presented as columns, and the
    work items from the left-hand column are sent to the right until they are completed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 每本书的借阅都有一个生命周期，从它们被创建的那一刻到书籍归还的那一刻。这是一个简单的流程，可以用看板（Kanban）板表示，其中几个阶段作为列呈现，来自左侧列的工作项被发送到右侧直到完成。
- en: This chapter focuses on the data model and business logic that are needed to
    support this feature.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍支持此功能所需的数据模型和业务逻辑。
- en: The basic user interface will be discussed in [*Chapter 10*](B16119_10_Final_PD_ePub.xhtml#_idTextAnchor287),
    *Backend Views – Designing the User Interface*, while the Kanban views will be
    discussed in [*Chapter 11*](B16119_11_Final_PD_ePub.xhtml#_idTextAnchor324), *Kanban
    Views and Client-Side QWeb*. Let's quickly have a rundown of the data model.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 基本用户界面将在[*第10章*](B16119_10_Final_PD_ePub.xhtml#_idTextAnchor287)，“后端视图 - 设计用户界面”中进行讨论，而看板视图将在[*第11章*](B16119_11_Final_PD_ePub.xhtml#_idTextAnchor324)，“看板视图和客户端QWeb”中进行讨论。让我们快速了解一下数据模型。
- en: Preparing the data model
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备数据模型
- en: The first thing we must do is plan the data model that's needed for the book
    checkout feature.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做的第一件事是为书籍借阅功能规划所需的数据模型。
- en: 'The **book checkout** model should have the following fields:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**图书借阅**模型应具有以下字段：'
- en: '**Library member** borrowing books (required)'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图书馆会员**借阅图书（必需）'
- en: '**Checkout date** (defaults to today)'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**借阅日期**（默认为今天）'
- en: '**Responsible person** for the checkout (defaults to the current user)'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负责人**（默认为当前用户）负责结账'
- en: '**Checkout lines**, with the books requested (one or more)'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**借阅条目**，请求的图书（一个或多个）'
- en: 'To support the book checkout life cycle, we will also have the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持图书借阅生命周期，我们还将有以下内容：
- en: '**Stage** of the request—draft, open, borrowed, returned, or canceled'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求阶段**—草稿、开放、借出、归还或取消'
- en: '**Due date**, when the books are due to be returned'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**到期日期**，图书应归还的日期'
- en: '**Returned date**, when the books were returned'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**归还日期**，图书归还的日期'
- en: We will start by creating the new `library_checkout` module and implementing
    an initial version of the library checkout model. This will not introduce anything
    new compared to the previous chapters but will provide the foundation to build
    the features that are relevant for this chapter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建新的`library_checkout`模块并实现图书馆借阅模型的初始版本。与前面的章节相比，这不会引入任何新内容，但将为构建本章相关功能提供基础。
- en: Creating the module
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建模块
- en: 'The `library_checkout` module needs to be created, similar to what we did in
    the previous chapters. Follow these steps to do this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`library_checkout`模块需要创建，类似于我们在前面的章节中所做的那样。按照以下步骤进行操作：'
- en: Create a new `library_checkout` directory in the same directory as the other
    add-on modules of the library project. This is where the following files should
    be added.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与图书馆项目其他附加模块相同的目录中创建一个新的`library_checkout`目录。以下文件应添加到此目录。
- en: 'Add the `__manifest__.py`  file and ensure it has the following content:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`__manifest__.py`文件并确保其包含以下内容：
- en: '[PRE0]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the main `__init__.py` file with the following line of code:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加主`__init__.py`文件，包含以下代码行：
- en: '[PRE1]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the `models/__init__.py` file with the following line of code:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`models/__init__.py`文件，包含以下代码行：
- en: '[PRE2]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the model definition file, `models/library_checkout.py`, as follows:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加模型定义文件，`models/library_checkout.py`，如下所示：
- en: '[PRE3]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, we should add the data files, including the access rule, the menu items,
    and some basic views so that the module can be used.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应该添加数据文件，包括访问规则、菜单项和一些基本视图，以便模块可以使用。
- en: 'Add the access security configuration to the `security/ir.model.access.``csv`
    file:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将访问安全配置添加到`security/ir.model.access.csv`文件中：
- en: '[PRE4]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, the `views/library_menu.xml` file needs to be added for implementing
    the menu items:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，需要添加`views/library_menu.xml`文件以实现菜单项：
- en: '[PRE5]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The views are implemented in the `views/checkout_view.xml` file:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视图在`views/checkout_view.xml`文件中实现：
- en: '[PRE6]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that the module contains the preceding files, it can be installed in our
    development database:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在模块包含上述文件后，可以在我们的开发数据库中安装：
- en: '![Figure 8.1 – The initial Library Checkout feature'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1 – 初始图书馆借阅功能'
- en: '](img/Figure_8.1_B16119.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.1_B16119.jpg)'
- en: Figure 8.1 – The initial Library Checkout feature
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 初始图书馆借阅功能
- en: Now, we can start adding more interesting features.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始添加更多有趣的功能。
- en: Throughout this project, we will be adding pieces of business logic to different
    places to showcase the several possibilities that Odoo provides. The next section
    will discuss these options.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个项目中，我们将向不同位置添加业务逻辑片段，以展示Odoo提供的多种可能性。下一节将讨论这些选项。
- en: Exploring ways to trigger business logic
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索触发业务逻辑的方法
- en: Once the data model is in place, business logic is needed to perform some automatic
    actions on it. Business logic can either be directly initiated by the user, with
    an action such as a button click, or it can be triggered automatically when an
    event occurs, such as a write on a record.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据模型就绪，就需要业务逻辑来执行一些自动操作。业务逻辑可以由用户直接启动，例如通过按钮点击，或者当发生事件时自动触发，例如在记录上写入。
- en: Much of this business logic will involve reading and writing on recordsets.
    The details and techniques for this were discussed in [*Chapter 7*](B16119_07_Final_PD_ePub.xhtml#_idTextAnchor194),
    *Recordsets – Working with Model Data*, where we provided the tools for the actual
    business logic implementation.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分业务逻辑将涉及对记录集的读取和写入。这些细节和技术在[*第7章*](B16119_07_Final_PD_ePub.xhtml#_idTextAnchor194)，*记录集
    – 与模型数据交互*中进行了讨论，我们提供了实际业务逻辑实现所需的工具。
- en: The next question is how the business logic should be triggered. This will depend
    on when and why the business logic should be triggered. Here is a summary of the
    several options.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个问题是如何触发业务逻辑。这取决于何时以及为什么应该触发业务逻辑。以下是几个选项的总结。
- en: 'Some business logic is tightly connected to the model field definitions. Some
    of the instances of **model definition-related business logic** are as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一些业务逻辑与模型字段定义紧密相关。以下是一些与模型定义相关的业务逻辑实例：
- en: '`@api.constrains`.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@api.constrains`。'
- en: '`@api.depends` and assigned to the `compute` field attribute.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@api.depends` 和分配给 `compute` 字段属性。'
- en: '`@api.model` and assigned to the `default` field attribute.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@api.model` 和分配给 `default` 字段属性。'
- en: This model definition logic was discussed in detail in [*Chapter 6*](B16119_06_Final_PD_ePub.xhtml#_idTextAnchor164),
    *Models – Structuring the Application Data*. Some examples can be found in the
    *Data model patterns* section. The *ORM method decorators for recordsets* section
    provides a recap of the several ORM decorators mentioned here.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模型定义逻辑在第6章中进行了详细讨论，*模型 – 结构化应用程序数据*。一些示例可以在*数据模型模式*部分找到。*ORM 方法装饰器对记录集*部分提供了此处提到的几个
    ORM 装饰器的回顾。
- en: 'We also have **model event-related business logic**, which is related to business
    workflows. It can be attached to the following record-related events:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有与业务工作流相关的 **model event-related business logic**，它可以附加到以下记录相关事件：
- en: '**Create, write, and unlink** business logic can be added to these events,
    for the cases where the other, more elegant approaches are not possible.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建、写入和解除链接**业务逻辑可以添加到这些事件，在无法使用其他更优雅的方法的情况下。'
- en: '**Onchange** logic can be applied to user interface views so that we have some
    field values that are changed as a consequence of changes being made to other
    fields.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Onchange** 逻辑可以应用于用户界面视图，以便我们有一些字段值会因其他字段的变化而改变。'
- en: 'For actions that are directly initiated by the user, the following options
    are available:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于直接由用户发起的操作，以下选项可用：
- en: A `button` view element for calling an object method. The button can be on a
    form or tree of the Kanban view.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于调用对象方法的 `button` 视图元素。按钮可以位于看板视图的表单或树中。
- en: A `server` action, which is available from a menu item or in the `Action` context
    menu.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `server` 动作，可以从菜单项或 `Action` 上下文菜单中访问。
- en: A `window` action for opening a wizard form, where input can be collected from
    the user and a button will call the business logic. This allows for richer user
    interaction.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于打开向导表单的 `window` 动作，用户可以从其中收集输入，按钮将调用业务逻辑。这允许更丰富的用户交互。
- en: These techniques will be presented throughout this chapter. The supporting methods
    will often use API decorators, so it is important to understand the different
    available ones. For clarity, the next section provides an overview of them.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术将在本章中介绍。辅助方法通常会使用 API 装饰器，因此理解不同的可用装饰器很重要。为了清晰起见，下一节提供了它们的概述。
- en: Understanding ORM method decorators for recordsets
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 ORM 方法装饰器对记录集的影响
- en: The method definition can be preceded by an `@`, which applies a decorator to
    it. These decorators add specific behaviors for these methods and depending on
    the purpose of a method, different decorators can be used.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 方法定义可以由一个 `@` 开头，这将对它应用一个装饰器。这些装饰器为这些方法添加特定的行为，并且根据方法的目的，可以使用不同的装饰器。
- en: Decorators for computed fields and validation methods
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算字段和验证方法的装饰器
- en: 'A few decorators are useful for validation logic and computed fields. They
    are listed here:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一些装饰器对验证逻辑和计算字段很有用。它们在此列出：
- en: '`@api.depends(fld1,...)` is used for computed field functions to identify what
    changes the (re)calculation should be triggered on. It must set values on the
    computed fields; otherwise, an error will be shown.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@api.depends(fld1,...)` 用于计算字段函数，以确定应触发（重新）计算的更改。它必须在计算字段上设置值；否则，将显示错误。'
- en: '`@api.constrains(fld1,...)` is used for model validation functions and performs
    checks for when any of the mentioned fields are changed. It should not write changes
    in the data. If the checks fail, an exception should be raised.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@api.constrains(fld1,...)` 用于模型验证函数，并在提到的任何字段发生变化时进行检查。它不应在数据中写入更改。如果检查失败，应引发异常。'
- en: These were discussed in detail in [*Chapter 6*](B16119_06_Final_PD_ePub.xhtml#_idTextAnchor164),
    *Models – Structuring the Application Data*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这些内容在[*第6章*](B16119_06_Final_PD_ePub.xhtml#_idTextAnchor164)中进行了详细讨论，*模型 – 结构化应用程序数据*。
- en: Another group of decorators affect the `self` recordset behavior and are relevant
    when you're implementing other kinds of business logic.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 另一组装饰器会影响 `self` 记录集的行为，并且当你实现其他类型的业务逻辑时是相关的。
- en: Decorators that affect the self recordset
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 影响self记录集的装饰器
- en: By default, methods are expected to act on a recordset that's provided by the
    self `first` argument. The method code will usually include a `for` statement
    that loops through each of the records in the `self` recordset.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，方法预期作用于由 `self` 的第一个参数提供的记录集。方法代码通常会包含一个 `for` 语句，该语句遍历 `self` 记录集中的每个记录。
- en: Changes in Odoo 14
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Odoo 14 的变化
- en: The `@api.multi` decorator was removed from Odoo 14\. In previous Odoo versions,
    it was used to explicitly signal that the decorated method expects a recordset
    in the `self` parameter. This is already the default behavior for methods, so
    its use is only for clarity. The `@api.one` decorator has been deprecated since
    Odoo 9 and was also removed in Odoo 14\. It handled the record loop for you so
    that the method code would be called once for each record, and the `self` argument
    would always be a singleton. Since Odoo 14, both decorators must be removed from
    the code since they are not supported anymore.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`@api.multi` 装饰器在 Odoo 14 中已被移除。在之前的 Odoo 版本中，它被用来明确表示被装饰的方法期望在 `self` 参数中有一个记录集。这对于方法来说已经是默认行为，因此它的使用只是为了清晰。`@api.one`
    装饰器自 Odoo 9 起已被弃用，并在 Odoo 14 中被移除。它为你处理记录循环，使得方法代码对每个记录只调用一次，并且 `self` 参数始终是一个单例。从
    Odoo 14 开始，这两个装饰器都必须从代码中移除，因为它们不再被支持。'
- en: In some cases, the method is expected to work at the class level and not on
    particular records, behaving like a `@api.model` and, in this case, the `self`
    method parameter should be used as a reference to the model; it is not expected
    to contain records.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，方法预期在类级别上工作，而不是在特定记录上，表现得像 `@api.model`，在这种情况下，`self` 方法参数应该用作模型的引用；它不期望包含记录。
- en: For example, the `create()` method uses `@api.model` – it does not expect records
    as input, only a values dictionary, which will be used to create and return a
    record. The methods that are used to calculate default values should also use
    the `@api.model` decorator.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`create()` 方法使用 `@api.model` – 它不期望输入记录，只期望一个值字典，该字典将被用来创建并返回一个记录。用于计算默认值的方法也应该使用
    `@api.model` 装饰器。
- en: Before we can go deeper into the business logic's implementation, we must add
    more depth to the data model and, in the process, provide examples of a couple
    of common data model patterns.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以深入到业务逻辑实现之前，我们必须使数据模型更加深入，在这个过程中，提供一些常见数据模型模式的示例。
- en: Exploring useful data model patterns
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索有用的数据模型模式
- en: There are a few data structures that are often needed for models that represent
    business documents. These can be seen in several Odoo apps, such as **Sales Orders**
    or **Invoices**.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于表示业务文档的模型，通常需要一些数据结构。这些可以在几个 Odoo 应用程序中看到，例如 **销售订单** 或 **发票**。
- en: A common pattern is the header/lines data structure. It will be used for a checkout
    request so that you can have several books. Another pattern is to use states or
    stages. These two have differences, and we will discuss them and provide a reference
    implementation shortly.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的模式是表头/行数据结构。它将用于结账请求，以便你可以有多个书籍。另一个模式是使用状态或阶段。这两个有区别，我们将在稍后讨论它们并提供一个参考实现。
- en: Finally, the ORM API provides a few methods that are relevant for the user interface.
    These will also be discussed in this section.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，ORM API 提供了一些与用户界面相关的几个方法。这些方法也将在本节中讨论。
- en: Using header and lines models
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用表头和行模型
- en: A common need for form views is to have header-line data structures. For example,
    a sales order includes several lines for the ordered items. In the case of the
    checkout feature, a checkout request can have several request lines, one for each
    of the borrowed items.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 表单视图的一个常见需求是拥有表头行数据结构。例如，销售订单包括几个订单项的行。在结账功能的案例中，一个结账请求可以有多个请求行，每个请求行对应一个借出的物品。
- en: With Odoo, it is simple to implement this. Two models are needed for a header-line
    form view – one for the document header and another for the document lines. The
    line model has a many-to-one field to identify the header it belongs to, while
    the header model has a one-to-many field listing the lines in that document.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Odoo，实现这一点很简单。需要一个表头行表视图的两种模型 – 一个用于文档表头，另一个用于文档行。行模型有一个多对一字段来标识它所属的表头，而表头模型有一个一对多字段列出该文档中的行。
- en: 'The `library_checkout` module was already added to the checkout model, so now,
    we want to add the lines. Follow these steps to do so:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`library_checkout`模块已经添加到结账模型中，因此现在我们想要添加行。按照以下步骤进行操作：'
- en: 'Edit the `models/library_checkout.py` file to add the one-to-many field for
    the checkout lines:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`models/library_checkout.py`文件，为结账行添加多对一字段：
- en: '[PRE7]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the file for the new model to `models/__init__.py`, as follows:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新模型的文件添加到`models/__init__.py`中，如下所示：
- en: '[PRE8]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, add the Python file for declaring the checkout lines model, `models/library_checkout_line.py`,
    with the following content:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加声明结账行模型的Python文件，`models/library_checkout_line.py`，内容如下：
- en: '[PRE9]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We must also add access security configuration. Edit the `security/ir.model.access.csv`
    file and add the following highlighted line:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还必须添加访问安全配置。编辑`security/ir.model.access.csv`文件，并添加以下突出显示的行：
- en: '[PRE10]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we want to add the checkout lines to the form. We will be adding it as
    the first page of a notebook widget. Edit the `views/checkout_view.xml` file and,
    just before the `</sheet>` element, add the following code:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们想要将结账行添加到表单中。我们将将其添加为笔记本小部件的第一页。编辑`views/checkout_view.xml`文件，并在`</sheet>`元素之前添加以下代码：
- en: '[PRE11]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The Checkouts form will look as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 结账表单将如下所示：
- en: '![Figure 8.2 – The Checkouts form with the notebook widget'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.2 – 带有笔记本小部件的结账表单'
- en: '](img/Figure_8.2_B16119.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.2_B16119.jpg)'
- en: Figure 8.2 – The Checkouts form with the notebook widget
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 带有笔记本小部件的结账表单
- en: The line's one-to-many field displays a list view that's nested in the parent
    form view. By default, Odoo will look up a list view definition to use for rendering,
    which is typical for any list view. If none are found, a default one will be automatically
    generated.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 该行的多对一字段显示一个嵌套在父表单视图中的列表视图。默认情况下，Odoo将查找用于渲染的列表视图定义，这对任何列表视图都是典型的。如果没有找到，将自动生成一个默认视图。
- en: It is also possible to declare specific views inside `<field>`. We did this
    in the preceding code. Inside the `line_ids` field element, there is a nested
    `<tree>` view definition that will be used for this form.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以在`<field>`内部声明特定的视图。我们在前面的代码中就是这样做的。在`line_ids`字段元素内部，有一个嵌套的`<tree>`视图定义，将用于此表单。
- en: Using stages and states for document-centered workflows
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用阶段和状态进行以文档为中心的工作流程
- en: In Odoo, we can implement workflows that are centered on documents. What we
    refer to as documents can be things such as sales orders, project tasks, or HR
    applicants. All of these are expected to follow a certain life cycle since they're
    created until they conclude. Each work item is recorded in a document that will
    progress through a list of possible stages until it is completed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在Odoo中，我们可以实现以文档为中心的工作流程。我们所说的文档可以是销售订单、项目任务或人力资源申请人等。所有这些在创建到完成的过程中都应遵循一定的生命周期。每个工作项都记录在将经过一系列可能阶段的文档中，直到完成。
- en: If we present these stages as columns in a board, and the documents as items
    in those columns, we get a Kanban board, providing a quick view of all the work
    in progress.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这些阶段作为看板中的列，并将文档作为这些列中的项目，我们就会得到一个看板，提供所有进行中工作的快速视图。
- en: 'There are two approaches to implementing these progress steps – **states**
    and **stages**:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这些进度步骤有两种方法 – **状态**和**阶段**：
- en: '`state` special field name, making it convenient to use. The closed states
    list is a disadvantage, in that it can''t easily accommodate custom process steps.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state`特殊字段名称，使其使用方便。关闭状态列表的缺点在于它不能轻易地容纳自定义流程步骤。'
- en: '`stage_id` field name. The list of available stages is easy to modify as you
    can remove, add, or reorder them. It has the disadvantage of not being reliable
    for process automation. Since the list of stages can be changed, automation rules
    can''t rely on particular stage IDs or descriptions.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stage_id`字段名称。可用的阶段列表容易修改，因为您可以删除、添加或重新排序它们。它的缺点是对于流程自动化来说不可靠。由于阶段列表可以更改，自动化规则不能依赖于特定的阶段ID或描述。'
- en: When we're designing the data model, we need to decide whether it should use
    stages or states. If triggering business logic is more important than the ability
    to configure the process steps, states should be preferred; otherwise, stages
    should be the preferred choice.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设计数据模型时，我们需要决定是否应该使用阶段或状态。如果触发业务逻辑比配置流程步骤的能力更重要，则应优先选择状态；否则，阶段应该是首选选择。
- en: 'If you can''t decide, there is an approach that can provide the best of both
    worlds: we can use stages and map each stage to a corresponding state. The list
    of process steps can easily be configured by users, and since each stage will
    be linked to some reliable state code, it can also be confidently used to automate
    business logic.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您无法决定，有一种方法可以提供两种世界的最佳结合：我们可以使用阶段并将每个阶段映射到相应的状态。流程步骤的列表可以很容易地由用户进行配置，并且由于每个阶段都将与某些可靠的状态代码相关联，因此也可以自信地用于自动化业务逻辑。
- en: 'This combined approach will be used for the library checkout feature. To implement
    the checkout stages, we will add the `library.checkout.stage` model. The fields
    that are needed to describe a stage are as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结合的方法将被用于图书馆借阅功能。为了实现借阅阶段，我们将添加`library.checkout.stage`模型。描述阶段所需的字段如下：
- en: '**Name**, or title.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**，或标题。'
- en: '**Sequence**, which is used to order the stage columns.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顺序**，用于对阶段列进行排序。'
- en: '**Fold**, to be used by the Kanban view to decide what columns should be folded
    by default. We usually want to set this on inactive item columns, such as *Done*
    or *Canceled*.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**折叠**，用于Kanban视图决定默认应该折叠哪些列。我们通常希望将此设置在非活动项列上，例如*完成*或*取消*。'
- en: '**Active**, to allow archived or no-longer-used stages, in case the process
    is changed.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**激活**，允许存档或不再使用的阶段，以防流程发生变化。'
- en: '**State**, a closed selection list, which is used to map each stage to a fixed
    state.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态**，一个封闭的选择列表，用于将每个阶段映射到固定状态。'
- en: 'To implement the preceding fields, we should start adding the **Stages** model,
    including the model definition, views, menus, and access security:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现前面的字段，我们应该开始添加**阶段**模型，包括模型定义、视图、菜单和访问安全：
- en: 'Add the `models/library_checkout_stage.py` file and ensure it contains the
    following model definition code:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`models/library_checkout_stage.py`文件并确保它包含以下模型定义代码：
- en: '[PRE12]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding code shouldn't be surprising to you. Stages have a logical sequence,
    so the order in which they are presented is important. This is ensured by `_order="sequence"`.
    We can also see the `state` field mapping each stage to a basic state, which can
    be safely used by the business logic.
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码不应让您感到惊讶。阶段有一个逻辑顺序，因此它们呈现的顺序很重要。这通过`_order="sequence"`得到保证。我们还可以看到`state`字段将每个阶段映射到基本状态，这可以安全地用于业务逻辑。
- en: 'As usual, the new code file must be added to the `models/__init__.py` file,
    which should then look like this:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如同往常，新的代码文件必须添加到`models/__init__.py`文件中，该文件应如下所示：
- en: '[PRE13]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Access security rules are also needed. Stages contain setup data, and it should
    only be editable by the `security/ir.model.access.csv` file:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要访问安全规则。阶段包含设置数据，并且只能通过`security/ir.model.access.csv`文件进行编辑：
- en: '[PRE14]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, a menu item is needed, to navigate to the stage''s setup. This should
    be under the `library_app` module does not provide one yet, so let''s edit it
    to add this. Edit the `library_app/views/library_menu.xml` file and add the following
    XML:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，需要一个菜单项，用于导航到阶段的设置。由于`library_app`模块尚未提供，让我们编辑它以添加此功能。编辑`library_app/views/library_menu.xml`文件并添加以下XML：
- en: '[PRE15]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, the `library_checkout/views/library_menu.xml` file and add the following
    XML:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`library_checkout/views/library_menu.xml`文件中添加以下XML：
- en: '[PRE16]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We need some stages to work with, so let''s add some default data to the module.
    Create the `data/library_checkout_stage.xml` file with the following code:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一些阶段来工作，因此让我们向模块添加一些默认数据。创建`data/library_checkout_stage.xml`文件，并包含以下代码：
- en: '[PRE17]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Before this can take effect, it needs to be added to the `library_checkout/__manifest__.py`
    file, as follows:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此生效之前，需要将其添加到`library_checkout/__manifest__.py`文件中，如下所示：
- en: '[PRE18]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following screenshot shows what the Stages list view is expected to look
    like:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了预期的阶段列表视图：
- en: '![Figure 8.3 – The Stages list view'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3 – 阶段列表视图'
- en: '](img/Figure_8.3_B16119.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.3_B16119.jpg)'
- en: Figure 8.3 – The Stages list view
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 阶段列表视图
- en: This takes care of all the components that are needed to add the Stages model
    to `library_checkout` and allow users to configure it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这处理了添加阶段模型到`library_checkout`并允许用户配置它所需的所有组件。
- en: Adding stage workflow support to models
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向模型添加阶段工作流支持
- en: 'Next, the stage field should be added to the library checkout model. For a
    proper user experience, two more things should be taken care of:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，应将阶段字段添加到图书馆借阅模型中。为了提供良好的用户体验，还应注意以下两点：
- en: The default stage to assign should be the first with a `new` state.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应分配的默认阶段应该是具有`new`状态的第一个。
- en: When grouping by stage, all the available stages should be present, even if
    there are no checkouts in each of the stages.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当按阶段分组时，所有可用的阶段都应该存在，即使每个阶段都没有结账。
- en: These should be added to the `library_checkout/models/library_checkout.py` file,
    in the `Checkout` class.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这些应该添加到`library_checkout/models/library_checkout.py`文件中的`Checkout`类。
- en: 'The function for finding the default stage should return the record that will
    be used as the default value:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 查找默认阶段的函数应返回将用作默认值的记录：
- en: '[PRE19]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This returns the first record in the stage model. Since the stage model is ordered
    by sequence, it will return the one with the lowest sequence number.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回阶段模型中的第一条记录。由于阶段模型按顺序排序，它将返回具有最低序列号的记录。
- en: 'When we''re grouping by stages, we would like to see all the possible stages
    rather than only the ones with checkout records. The method that''s used for this
    should return a recordset to use for the groups. In this case, it is appropriate
    to return all the active stages:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们按阶段分组时，我们希望看到所有可能的阶段，而不仅仅是具有结账记录的阶段。用于此的方法应返回用于分组的记录集。在这种情况下，返回所有活动阶段是合适的：
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, the `stage_id` field we wish to add to the checkout model can use
    the preceding methods for the `default` and `group_expand` attributes:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望添加到结账模型的`stage_id`字段可以使用前面提到的`default`和`group_expand`属性的方法：
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`stage_id` has a many-to-one relationship with the stages model. The default
    value is calculated by the `_default_stage_id` method function, and the groupby
    on `stage_id` will use the result of the `_group_expand_stage_id` method function.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`stage_id`与阶段模型具有多对一的关系。默认值由`_default_stage_id`方法函数计算，`stage_id`上的groupby将使用`_group_expand_stage_id`方法函数的结果。'
- en: Changes in Odoo 10
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Odoo 10的变化
- en: The `group_expand` field attribute was introduced in Odoo 10 and is not available
    in previous versions.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`group_expand`字段属性是在Odoo 10中引入的，在之前的版本中不可用。'
- en: The `group_expand` parameter overrides the way grouping works on the field.
    The default behavior for grouping operations is to only see the stages that are
    being used; the stages with no checkout document won't be shown. But in the case
    of the `stage_id` field, we want to see all the available stages, even if some
    don't have any items.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`group_expand`参数覆盖了字段上分组的方式。分组操作的默认行为是只看到正在使用的阶段；没有结账文档的阶段不会显示。但在`stage_id`字段的情况下，我们希望看到所有可用的阶段，即使其中一些没有任何项目。'
- en: The `_group_expand_stage_id()` helper function returns the list of group records
    that the grouping operation should use. In this case, it returns all the existing
    stages, regardless of having library checkouts in that stage or not.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`_group_expand_stage_id()`辅助函数返回分组操作应使用的分组记录列表。在这种情况下，它返回所有现有阶段，无论该阶段是否有图书馆结账。'
- en: Note
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `group_expand` attribute must be a string with a method name. This is unlike
    other attributes, such as `default`, which can be either strings or direct references
    to the method name.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`group_expand`属性必须是一个包含方法名称的字符串。这与其他属性不同，例如`default`，它可以是要字符串或直接引用方法名称。'
- en: The `state` field was also added. It simply makes the stage-related `state`
    field in this model available so that it can be used in views. This will use the
    special support for `state` that views have available.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 也添加了`state`字段。它只是使此模型中与阶段相关的`state`字段可用，以便可以在视图中使用。这将使用视图可用的特殊`state`支持。
- en: Methods to support the user interface
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持用户界面的方法
- en: 'The following methods are mostly used by the web client to render the user
    interface and perform basic interaction:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法主要用于网络客户端以渲染用户界面和执行基本交互：
- en: '`name_get()` computes the `(ID, name)` tuples, along with the ID. It is the
    default computation for the `display_name` value and can be extended to implement
    custom display representations, such as displaying an identifier code along with
    the record name.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name_get()`计算`(ID, name)`元组，以及ID。它是`display_name`值的默认计算，可以扩展以实现自定义显示表示，例如在记录名称旁边显示标识代码。'
- en: '`name_search(name="", args=None, operator="ilike", limit=100)` performs a search
    on the display name. It is used on views when the user is typing in a relationship
    field to produce a list containing the suggested records that match the typed
    text. It returns a list of `(ID, name)` tuples.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name_search(name="", args=None, operator="ilike", limit=100)`在显示名称上执行搜索。当用户在关系字段中键入时用于视图，以生成包含与键入文本匹配的建议记录的列表。它返回`(ID,
    name)`元组的列表。'
- en: '`name_create(name)` creates a new record that only has a name as input. It
    is used in Kanban views with `on_create="quick_create"`, where you can quickly
    create a related record by just providing its name. It can be extended to provide
    specific defaults for the new records that are created through this feature.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name_create(name)`创建一个只接受名称作为输入的新记录。它在`on_create="quick_create"`的看板视图中使用，您只需提供其名称即可快速创建相关记录。它可以扩展以提供通过此功能创建的新记录的特定默认值。'
- en: '`default_get([fields])` returns the default values for a new record to be created,
    as a dictionary. The default values may depend on variables, such as the current
    user or the session context. This can be extended to add additional default values.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default_get([fields])`返回要创建的新记录的默认值，作为一个字典。默认值可能取决于变量，例如当前用户或会话上下文。这可以扩展以添加额外的默认值。'
- en: '`fields_get()` is used to describe the model''s field definitions.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields_get()`用于描述模型的字段定义。'
- en: '`fields_view_get()` is used by the web client to retrieve the structure of
    the UI view to render. It can be given the ID of the view as an argument, or the
    type of view we want using `view_type="form"`. For example, `self.fields_view_get(view_type="tree")`
    will return the tree view XML architecture to be rendered for the `self` model.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields_view_get()`由Web客户端用于检索UI视图的结构以进行渲染。它可以提供一个视图的ID作为参数，或者使用`view_type="form"`来指定我们想要的视图类型。例如，`self.fields_view_get(view_type="tree")`将返回用于渲染`self`模型的树视图XML架构。'
- en: These built-in ORM models can be helpful as extension points to implement model-specific
    business logic.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这些内置ORM模型可以作为实现特定模型业务逻辑的扩展点。
- en: The next section will discuss how business logic can be triggered by record
    operations, such as creating or writing on a record.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将讨论如何通过记录操作（如创建或写入记录）触发业务逻辑。
- en: Using the ORM built-in methods
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ORM内置方法
- en: The model definition-related methods can do many things, but some business logic
    is not possible through them, so it needs to be attached to the ORM record writing
    operations.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 模型定义相关的方法可以执行许多操作，但某些业务逻辑无法通过它们实现，因此需要附加到ORM记录写操作上。
- en: ORM provides methods to perform **Create**, **Read**, **Update**, and **Delete**
    (**CRUD**) operations on our model data. Let's explore these write operations
    and how they can be extended to support custom logic.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ORM提供了执行**创建**、**读取**、**更新**和**删除**（**CRUD**）操作的方法，这些操作针对我们的模型数据。让我们探讨这些写操作以及如何扩展以支持自定义逻辑。
- en: To read data, the main methods that are provided are `search()` and `browse()`,
    as discussed in [*Chapter 7*](B16119_07_Final_PD_ePub.xhtml#_idTextAnchor194),
    *Recordsets – Working with Model Data*.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取数据，提供的主要方法是`search()`和`browse()`，如在第[*第7章*](B16119_07_Final_PD_ePub.xhtml#_idTextAnchor194)中所述，*记录集
    – 与模型数据交互*。
- en: Methods for writing model data
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写入模型数据的方法
- en: 'The ORM provides three methods for the three basic write operations, shown
    as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ORM提供了三种基本写操作的方法，如下所示：
- en: '`<Model>.create(values)` creates a new record on the model. It returns the
    created record. `values` can be a dictionary or a list of dictionaries for mass-creating
    records.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<Model>.create(values)`在模型上创建一个新的记录。它返回创建的记录。`values`可以是一个字典或字典列表，用于批量创建记录。'
- en: '`<Recordset>.write(values)` updates the recordset with the `values` dictionary.
    It returns nothing.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<Recordset>.write(values)`使用`values`字典更新记录集。它不返回任何内容。'
- en: '`<Recordset>.unlink()` deletes the records from the database. It returns nothing.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<Recordset>.unlink()`从数据库中删除记录。它不返回任何内容。'
- en: The `values` argument is a dictionary that maps field names to values to write.
    These methods are decorated with `@api.multi`, except for the `create()` method,
    which is decorated with `@api.model`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`values`参数是一个将字段名称映射到要写入的值的字典。这些方法除了`create()`方法外，都带有`@api.multi`装饰器，而`create()`方法则带有`@api.model`装饰器。'
- en: Changes in Odoo 12
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Odoo 12的变化
- en: Being able to use `create()` to access a list of dictionaries, instead of a
    single dictionary object, was introduced in Odoo 12\. This also allows us to create
    records in batches. This capability is supported through the special `@api.model_create_multi`
    decorator.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在Odoo 12中引入了能够使用`create()`访问字典列表，而不是单个字典对象的能力。这也允许我们批量创建记录。这种能力是通过特殊的`@api.model_create_multi`装饰器支持的。
- en: In some cases, these methods need to be extended to run some specific business
    logic when they are triggered. This business logic can be run before or after
    the main method operations are executed.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，这些方法需要扩展以在触发时运行一些特定的业务逻辑。这个业务逻辑可以在主方法操作执行前后运行。
- en: Example of extending create()
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展create()的示例
- en: Let's look at an example that makes use of this. We want to prevent new checkout
    records from being created directly in the `Borrowed` or `Returned` states. Usually,
    validations should be implemented in specific methods that are decorated with
    `@api.constrains`. But this particular case is tied to the create record event
    and is hard to implement as a regular validation.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个利用这个特性的例子。我们希望防止在`Borrowed`或`Returned`状态下直接创建新的出借记录。通常，验证应该在用`@api.constrains`装饰的特定方法中实现。但这个特定的情况与创建记录事件相关联，并且很难作为一个常规验证来实现。
- en: 'Edit the `library_checkout/models/library_checkout.py` file and add the `create()`
    extension method:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`library_checkout/models/library_checkout.py`文件并添加`create()`扩展方法：
- en: '[PRE22]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The new record is created by the `super().create()` call. Before this, the new
    record is not available to use in the business logic – only the `values` dictionary
    can be used, or even changed, to force values on the to-be-created record.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 新记录是通过`super().create()`调创建的。在此之前，新记录在业务逻辑中不可用 – 只能使用`values`字典，或者甚至可以更改它，以强制对即将创建的记录设置值。
- en: The code after `super().create()` does have access to the new record that's
    been created and can use record features, such as accessing related records using
    dot-notation chains. The preceding example uses `new_record.stage_id.state` to
    access the state that corresponds to the new record stage. States are not user-configurable
    and provide a reliable list of values to use in business logic. So, we can look
    for `open` or `done` states and raise an error if any of them are found.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`super().create()`之后的代码可以访问已创建的新记录，并可以使用记录功能，例如使用点符号链访问相关记录。前面的示例使用`new_record.stage_id.state`来访问与新记录阶段相对应的状态。状态不是用户可配置的，并提供了一组可靠的业务逻辑中使用的值。因此，我们可以查找`open`或`done`状态，并在发现任何这些状态时引发错误。'
- en: Example of extending write()
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展write()的示例
- en: 'Let''s look at another example. The `Checkout` model should keep track of the
    date when the books were borrowed, `Checkout Date`, and the date when they were
    returned, `Close Date`. This can''t be done using computed fields. Instead, the
    `write()` method should be extended to detect changes on the checkout state and
    then update the dates that have been filed at the right moment: when changing
    into the `open` or `close` states.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个例子。`Checkout`模型应记录书籍被借阅的日期，即`Checkout Date`，以及它们被归还的日期，即`Close Date`。这不能使用计算字段来完成。相反，应扩展`write()`方法以检测出借状态的更改，并在适当的时候更新已记录的日期：当状态变为`open`或`close`时。
- en: 'Before we implement this logic, the two date fields must be created. Edit the
    `library_checkout/models/library_checkout.py` file and add the following code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现这个逻辑之前，必须创建两个日期字段。编辑`library_checkout/models/library_checkout.py`文件并添加以下代码：
- en: '[PRE23]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When a record is modified, the `checkout_date` and `close_date` fields should
    be set when the checkout record enters the appropriated states. For this, we will
    use a custom `write()` method, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当一条记录被修改时，当出借记录进入适当的状态时，应设置`checkout_date`和`close_date`字段。为此，我们将使用自定义的`write()`方法，如下所示：
- en: '[PRE24]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding example, the extension code was added before the `super()`
    call; so, *before* the write operation is done on the `self` record. To know what
    change is about to be made to the record, we can inspect the `vals` parameter.
    The `stage_id` value in the `vals` dictionary is an ID number, not a record, so
    it needs to be browsed to get the corresponding record, and then read the corresponding
    `state`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，扩展代码是在`super()`调用之前添加的；因此，*在*对`self`记录执行写操作之前。为了知道将要对该记录进行什么更改，我们可以检查`vals`参数。`vals`字典中的`stage_id`值是一个ID号，而不是一个记录，因此需要浏览以获取相应的记录，然后读取相应的`state`。
- en: The old and new states are compared to trigger the date value update at the
    appropriate moment. Whenever possible, we prefer to change the values to write
    before the `super().write()` instruction and modify the `vals` dictionary instead
    of setting the field value directly. We'll see why in the next section.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 比较新旧状态以在适当的时候触发日期值的更新。尽可能的情况下，我们更喜欢在`super().write()`指令之前更改要写入的值，并修改`vals`字典，而不是直接设置字段值。我们将在下一节中看到原因。
- en: Example of extending write() that sets values on fields
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展write()的示例，设置字段值
- en: The previous code only modifies the values to use for the write; it does not
    assign values directly to the model fields. This is safe to do, but it may not
    be enough in some cases.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码仅修改用于写入的值；它没有直接将值分配给模型字段。这样做是安全的，但在某些情况下可能不够。
- en: 'Assigning a model field value inside a `write()` method leads to an infinite
    recursion loop: the assignment triggers the write method again, which then repeats
    the assignment, triggering yet another write call. This will repeat until Python
    returns a recursion error.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `write()` 方法内部分配模型字段值会导致无限递归循环：赋值会再次触发写方法，然后重复赋值，触发另一个写调用。这将一直重复，直到 Python
    返回递归错误。
- en: There is a technique to avoid this recursion loop, making it possible for `write()`
    methods to set values on its record fields. The trick is to set a unique marker
    in the environment's `context` before setting the values, and only run the setting
    values code when that marker is not present.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种技术可以避免这种递归循环，使得 `write()` 方法能够在其记录字段上设置值。诀窍是在设置值之前在环境 `context` 中设置一个唯一的标记，并且仅在不存在该标记时运行设置值的代码。
- en: 'An example will help make this clear. Let''s rewrite the previous example so
    that the updates are done after calling `super()`, rather than before:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子将有助于使这一点更清楚。让我们重写前面的例子，以便在调用 `super()` 之后而不是之前执行更新：
- en: '[PRE25]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With this technique, the extension code is guarded by an `if` statement and
    only runs if a specific marker is not found in the context. Furthermore, the additional
    `self.write()` operations use the `with_context` method to set that marker before
    doing the write. This combination ensures that the custom login inside the `if`
    statement runs only once and is not triggered on further `write()` calls, avoiding
    the infinite loop.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术，扩展代码由一个 `if` 语句保护，并且仅在上下文中找不到特定标记时才运行。此外，额外的 `self.write()` 操作使用 `with_context`
    方法在执行写操作之前设置该标记。这种组合确保 `if` 语句中的自定义登录只运行一次，并且不会在进一步的 `write()` 调用中触发，从而避免无限循环。
- en: When (not) to extend the create() and write() methods
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 何时扩展 create() 和 write() 方法
- en: Extending the `create()` or `write()` methods should be carefully considered.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展 `create()` 或 `write()` 方法应仔细考虑。
- en: 'In most cases, some validation must be performed, or some value must be automatically
    computed when the record is saved. For these common cases, there are better options,
    as listed here:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，必须在记录保存时执行某些验证，或者必须自动计算某些值。对于这些常见情况，这里列出了更好的选项：
- en: For field values that are automatically calculated based on other fields, use
    computed fields. For example, you should calculate a header total when the values
    of the lines are changed.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于基于其他字段自动计算的字段值，请使用计算字段。例如，当行值更改时，应计算一个标题总计。
- en: For non-fixed field default values, use a function as the default field value.
    It will be evaluated and used to assign the default value.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于非固定字段默认值，请使用函数作为默认字段值。它将被评估并用于分配默认值。
- en: To have other field values change when some field is changed, use the `onchange`
    methods, if this is expected to be done on the user interface, or use the new
    `onchange` methods, this only works on form view interaction, not on direct write
    calls, though computed writable fields work in both cases. The *Adding onchange
    user interface logic* section will provide more detail about this.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在其他字段值更改时更改某些字段的值，请使用 `onchange` 方法，如果预期在用户界面中执行此操作，或者使用新的 `onchange` 方法，这仅在表单视图交互中起作用，而不是在直接写调用中，尽管计算可写字段在这两种情况下都起作用。*添加
    onchange 用户界面逻辑*部分将提供更多关于此的信息。
- en: For validations, use `constraint` functions. These are automatically triggered
    when the field value changes and are expected to raise errors if the validation
    conditions fail.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于验证，请使用 `constraint` 函数。这些函数在字段值更改时自动触发，如果验证条件失败，则预期会引发错误。
- en: There are still cases where none of these options will work and extending `create()`
    or `write()` is needed, such as when the default values to set depend on the other
    fields of the record that's being created. In this case, a default value function
    won't work because it does not have access to the other field values of the new
    record.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然存在一些情况，这些选项中的任何一个都无法工作，需要扩展 `create()` 或 `write()` 方法，例如当设置的默认值依赖于正在创建的记录的其他字段时。在这种情况下，默认值函数将不起作用，因为它无法访问新记录的其他字段值。
- en: Methods for data import and export
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据导入和导出方法
- en: 'Data import and export, as discussed in [*Chapter 5*](B16119_05_Final_PD_ePub.xhtml#_idTextAnchor146),
    *Importing, Exporting, and Module Data*, is also available from the ORM API, through
    the following methods:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如在第 [*5章*](B16119_05_Final_PD_ePub.xhtml#_idTextAnchor146) 中讨论的，数据导入和导出（*Importing,
    Exporting, and Module Data*），也通过以下方法从 ORM API 中提供：
- en: '`load([fields], [data])` is used to import data and is used by Odoo when importing
    CSV or spreadsheet data into Odoo. The first argument is the list of fields to
    import, and it maps directly to a CSV top row. The second argument is a list of
    records, where each record is a list of string values to parse and import. It
    maps directly to the CSV data rows and columns and implements the features of
    CSV data import, such as external identifiers support.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load([fields], [data])` 用于导入数据，并在 Odoo 导入 CSV 或电子表格数据到 Odoo 时使用。第一个参数是要导入的字段列表，它直接映射到
    CSV 的顶部行。第二个参数是记录列表，其中每个记录都是要解析和导入的字符串值列表。它直接映射到 CSV 数据的行和列，并实现了 CSV 数据导入的功能，如外部标识符支持。'
- en: '`export_data([fields])` is used by the web client''s `Export` function. It
    returns a dictionary with a `datas` key containing the data; that is, a list of
    rows. The field names can use the `.id` and `/id` suffixes that are used in CSV
    files, and the data is in a format that''s compatible with an importable CSV file.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`export_data([fields])` 由网络客户端的 `Export` 函数使用。它返回一个包含 `datas` 键的字典，其中包含数据；即，行列表。字段名称可以使用在
    CSV 文件中使用的 `.id` 和 `/id` 后缀，数据格式与可导入的 CSV 文件兼容。'
- en: It is also possible to implement automation on the user interface, while the
    user is editing data. We'll learn about this in the next section.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 用户在编辑数据时，也可以在用户界面中实现自动化。我们将在下一节中了解这一点。
- en: Adding onchange user interface logic
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 `onchange` 用户界面逻辑
- en: It is possible to make changes to the web client view while the user is editing
    it. This mechanism is known as `@api.onchange`, and they are triggered by the
    user interface view when the user edits a value on a particular field.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 用户在编辑时，也可以更改网络客户端视图。这种机制被称为 `@api.onchange`，它们在用户界面视图触发时被触发，当用户在特定字段上编辑值时。
- en: Since Odoo 13, the same effect can be achieved by using a particular form of
    computed fields, called **computed writable fields**. This ORM improvement aims
    to avoid some limitations of the classic onchange mechanism, and in the long run,
    it should replace it completely.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Odoo 13 以来，可以通过使用一种称为 **计算可写字段** 的特定计算字段形式来实现相同的效果。这种 ORM 改进旨在避免经典 `onchange`
    机制的一些限制，从长远来看，它应该完全取代它。
- en: Classic onchange methods
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 经典的 `onchange` 方法
- en: Onchange methods can change other field values in the form, perform a validation,
    show a message to the user, or set a domain filter in relation fields, limiting
    the available options.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`onchange` 方法可以更改表单中的其他字段值，执行验证，向用户显示消息，或在相关字段中设置域过滤器，限制可用的选项。'
- en: The onchange method is called asynchronously and returns data that's being used
    by the web client to update the fields in the current view.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`onchange` 方法是异步调用的，并返回数据，这些数据被网络客户端用于更新当前视图中的字段。'
- en: Onchange methods are linked to the triggering fields, which are passed as arguments
    to the `@api.onchange("fld1", "fld2", ...)` decorator.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`onchange` 方法与触发字段相关联，这些字段作为 `@api.onchange("fld1", "fld2", ...)` 装饰器的参数传递。'
- en: Note
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `api.onchange` arguments do not support dot notation; for example, `"partner_id.name"`.
    If used, it will be ignored.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`api.onchange` 参数不支持点符号表示法；例如，`"partner_id.name"`。如果使用，它将被忽略。'
- en: Inside the method, the `self` argument is a virtual record that contains the
    current form data. It is virtual because it can be a new or changed record that
    is still being edited and hasn't been saved to the database yet. If values are
    set on this `self` record, these will be changed on the user interface form. Notice
    that it doesn't write to database records; instead, it provides information so
    that you can change the data in the UI form.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法内部，`self` 参数是一个虚拟记录，它包含当前表单数据。它是虚拟的，因为它可以是一个新记录或更改记录，它仍在被编辑，尚未保存到数据库中。如果在这个
    `self` 记录上设置了值，这些值将在用户界面表单上更改。请注意，它不会写入数据库记录；相反，它提供信息，以便您可以在 UI 表单中更改数据。
- en: Note
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Other restrictions apply to onchange methods, as documented at [https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html#odoo.api.onchange](https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html#odoo.api.onchange).Computed
    writable fields can be used as a full-featured alternative to onchanges. See the
    *The new onchange, with computed writable fields* section for more information.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`onchange` 方法有一些限制，如文档所述 [https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html#odoo.api.onchange](https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html#odoo.api.onchange)。计算可写字段可以用作
    `onchange` 的功能齐全的替代品。有关更多信息，请参阅 *新的 `onchange`，使用计算可写字段* 部分。'
- en: No return value is needed, but a `dict` structure may be returned with a warning
    message to display in the user interface, or a domain filter to be set on form
    fields.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要返回值，但可以返回一个`dict`结构，其中包含要在用户界面中显示的警告消息或要在表单字段上设置的域过滤器。
- en: Let's work with an example. On the checkout form, when the library member is
    selected, the request date will be set to `today`. If the date changed, a warning
    message will be shown to the user, alerting them about it.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子来说明。在结账表单上，当选择图书馆成员时，请求日期将被设置为`今天`。如果日期发生变化，将向用户显示一个警告消息，提醒他们这一点。
- en: 'To implement this, edit the `library_checkout/models/library_checkout.py` file
    and add the following method:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，编辑`library_checkout/models/library_checkout.py`文件并添加以下方法：
- en: '[PRE26]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The previous `onchange` method is triggered when the `member_id` field is set
    on the user interface. The actual method name is not relevant, but the convention
    is for its name to begin with the `onchange_` prefix.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的`onchange`方法在用户界面上的`member_id`字段设置时触发。实际的方法名称并不重要，但惯例是它的名称以`onchange_`前缀开始。
- en: Inside an `onchange` method, `self` represents a single virtual record containing
    all of the fields that have currently been set in the record being edited, and
    we can interact with them.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onchange`方法内部，`self`代表一个包含所有当前在编辑的记录中已设置的字段的单个虚拟记录，并且我们可以与之交互。
- en: The method code checks whether the current `request_date` needs to be changed.
    If it does, `request_date` is set to today so that the user will see that change
    in the form. Then, a non-blocking warning message is returned to the user.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 方法代码检查当前的`request_date`是否需要更改。如果需要，则将`request_date`设置为今天，以便用户能在表单中看到这一变化。然后，返回一个非阻塞的警告信息给用户。
- en: 'The `onchange` methods do not need to return anything, but they can return
    a dictionary containing a warning or a domain key, as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`onchange`方法不需要返回任何内容，但它们可以返回一个包含警告或域键的字典，如下所示：'
- en: 'The warning key should describe a message to show in a dialog window, such
    as `{"title": "Message Title", "message": "Message Body"}`.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '警告键应该描述一个要在对话框窗口中显示的消息，例如`{"title": "消息标题", "message": "消息正文"}`。'
- en: 'The domain key can set or change the domain attribute of other fields. This
    allows you to build more user-friendly interfaces; having a to-many field only
    makes the options that make sense at that moment available. The value for the
    domain key looks like `{"user_id": [("email", "!=", False)]}`.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '域键可以设置或更改其他字段的域属性。这允许你构建更用户友好的界面；仅当此时有意义的选项才可用。域键的值看起来像`{"user_id": [("email",
    "!=", False)]}`。'
- en: The new onchange, with computed writable fields
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的`onchange`，包含计算可写字段
- en: The classic onchange mechanism has a key role in the user experience that's
    provided by the Odoo framework. However, it has a few important limitations.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 经典`onchange`机制在Odoo框架提供的用户体验中扮演着关键角色。然而，它有几个重要的限制。
- en: One is that it works disconnected from the server-side events. Onchange is only
    played when requested by the form view and is not called as a consequence of an
    actual `write()` value change. This forces the server-side business logic to explicitly
    replay the relevant onchange methods.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 其中之一是它从服务器端事件中独立工作。`onchange`仅在表单视图请求时播放，不会因为实际的`write()`值变化而调用。这迫使服务器端业务逻辑明确重新播放相关的`onchange`方法。
- en: Another limitation is that onchange is attached to the triggering fields and
    not to the change-affected fields. In non-trivial cases, this becomes hard to
    extend and makes it difficult to track the source of the changes.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个限制是`onchange`附加到触发字段上，而不是受影响的更改字段上。在非平凡的情况下，这变得难以扩展，并使得追踪更改的来源变得困难。
- en: To address these issues, the Odoo framework expanded the computed field capabilities
    so that it can also address the onchange use case. We will call this technique
    **computed writable fields**. The classic onchange is still supported and used,
    but it is expected to be replaced by computed fields and become deprecated in
    future versions.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，Odoo框架扩展了计算字段的特性，使其也能处理`onchange`用例。我们将这种技术称为**计算可写字段**。经典`onchange`仍然被支持和使用，但预计将在未来的版本中被计算字段取代并成为弃用。
- en: Changes in Odoo 13
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Odoo 13中的更改
- en: Computed writable fields were introduced in Odoo 13 and are available for that
    version and later ones.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 计算可写字段是在Odoo 13中引入的，并且适用于该版本及以后的版本。
- en: Computed writable fields have compute methods assigned to them, must be stored,
    and must have the **readonly=False** attribute.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 计算可写字段分配了计算方法，必须存储，并且必须有**readonly=False**属性。
- en: 'Let''s implement the previous onchange using this technique instead. This is
    how the `request_date` field definition should be changed:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这种技术来实现之前的onchange。以下是`request_date`字段定义应该如何更改：
- en: '[PRE27]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is a regular stored and writable field, but it has attached a compute method
    that can be triggered in particular conditions. For example, the computed method
    should be triggered when the `member_id` field changes.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个常规的存储和可写字段，但它附加了一个可以在特定条件下触发的计算方法。例如，当`member_id`字段发生变化时，应该触发计算方法。
- en: 'This is the code for the compute method, `_compute_request_date_onchange`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这是计算方法的代码，`_compute_request_date_onchange`：
- en: '[PRE28]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`@api.depends` works as usual for computed fields and declares the fields to
    watch for changes. The actual field list to provide is the same as the one that''s
    used by the classic `@api.onchange`.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`@api.depends`对于计算字段来说与往常一样工作，并声明了要监视其变化的字段。实际提供的字段列表与经典`@api.onchange`使用的相同。'
- en: The method code can be very similar to the equivalent onchange method. In this
    particular case, it is identical. Note that the computed field is not ensured
    to be set a value on every method call. This only happens when some conditions
    are met. In this case, the original request date is different from today's date.
    This goes against regular computed field rules but is allowed for computed writable
    fields.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 方法代码可以非常类似于等效的onchange方法。在这个特定情况下，它们是相同的。请注意，计算字段并不保证在每次方法调用时都会设置一个值。这只有在满足某些条件时才会发生。在这种情况下，原始请求日期与今天的日期不同。这违反了常规的计算字段规则，但对于可计算的可写字段是允许的。
- en: Particularly relevant to business processes is the ability to send emails or
    notify users. The next section discusses the features that Odoo provides for this.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 特别与业务流程相关的是发送电子邮件或通知用户的能力。下一节将讨论Odoo为此提供的功能。
- en: The message and activity features
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息和活动功能
- en: Odoo has global messaging and activity planning features available, all of which
    are provided by the `mail` technical name.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Odoo提供了全局消息和活动计划功能，所有这些功能都是由`mail`技术名称提供的。
- en: The messaging features are added by the `mail.thread` model and make a message
    widget on form views available, also known as C*hatter*. This widget allows you
    to log notes or send messages to other people. It also keeps a history of the
    messages that have been sent, and it is also used by automatic processes to log
    progress tracking messages.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 消息功能是通过`mail.thread`模型添加的，并在表单视图中提供了一个消息小部件，也称为C*hatter*。这个小部件允许你记录笔记或向其他人发送消息。它还保存了已发送消息的历史记录，并且也被自动过程用于记录进度跟踪消息。
- en: The same app also provides activity management features through the `mail.activity.mixin`
    model. The activity widget can be added to the form view to allow users to schedule
    and track the history of activities.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的应用程序还通过`mail.activity.mixin`模型提供活动管理功能。可以将活动小部件添加到表单视图中，以便用户安排和跟踪活动的历史记录。
- en: Adding message and activity features
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加消息和活动功能
- en: The mail module provides the `mail.thread` abstract class, which is used to
    add the messaging features to any model, and `mail.activity.mixin`, which does
    the same for the planned activity features. In [*Chapter 4*](B16119_04_Final_PD_ePub.xhtml#_idTextAnchor119),
    *Extending Modules*, we explained how to add these inherited features to models
    using the inheritance from mixin abstract classes.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 邮件模块提供了`mail.thread`抽象类，用于将消息功能添加到任何模型中，以及`mail.activity.mixin`，它为计划活动功能做同样的事情。在[*第4章*](B16119_04_Final_PD_ePub.xhtml#_idTextAnchor119)
    *扩展模块*中，我们解释了如何使用从混合抽象类继承的方式来添加这些继承功能到模型中。
- en: 'Let''s go through the necessary steps:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过必要的步骤来了解：
- en: 'Add the `mail` module dependency to the `library_checkout` add-on module by
    editing the `''depends''` key in the `library_checkout/__manifest__.py` file,
    as follows:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过编辑`library_checkout/__manifest__.py`文件中的`'depends'`键，将`mail`模块依赖项添加到`library_checkout`附加模块中，如下所示：
- en: '[PRE29]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To have the `library.checkout` model inherit from the message and activity
    abstract classes, edit the `library_checkout/models/library_checkout.py` files,
    as follows:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使`library.checkout`模型继承消息和活动抽象类，编辑`library_checkout/models/library_checkout.py`文件，如下所示：
- en: '[PRE30]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To add the message and activity fields to the checkout form view, edit the
    `library_checkout/` and `views/checkout_view.xml` files:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将消息和活动字段添加到结账表单视图中，编辑`library_checkout/`和`views/checkout_view.xml`文件：
- en: '[PRE31]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Having done this, the checkout model will have the message and activity fields
    and their features available.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作后，结账模型将具有消息和活动字段及其功能。
- en: Message and activity fields and models
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息和活动字段和模型
- en: The message and activity features add new fields to the models that inherit
    the `mail.thread` and `mail.activity.mixin` classes, along with all the supporting
    models for these features. These are the basic data structures that have been
    added.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 消息和活动功能向继承`mail.thread`和`mail.activity.mixin`类的模型添加了新字段，以及所有这些功能的支持模型。这些都是已添加的基本数据结构。
- en: 'The `mail.thread` mixin class makes two new fields available:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`mail.thread`混合类使两个新字段可用：'
- en: '`message_follower_ids` has a one-to-many relationship with `mail.followers`
    and stores the message followers that should receive notifications. Followers
    can either be partners or channels. A **partner** represents a specific person
    or organization. A **channel** is not a particular person and instead represents
    a subscription list.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`message_follower_ids`与`mail.followers`具有一对一关系，并存储应接收通知的消息跟随者。跟随者可以是合作伙伴或渠道。**合作伙伴**代表特定的人或组织。**渠道**不是一个特定的人，而是代表订阅列表。'
- en: '`message_ids` has a one-to-many relationship with `mail.message` records and
    lists the record message history.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`message_ids`与`mail.message`记录具有一对一关系，并列出记录的消息历史。'
- en: 'The `mail.activity.mixin` mixin class adds the following new field:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`mail.activity.mixin`混合类添加了以下新字段：'
- en: '`activity_ids` has a one-to-many relationship with `mail.activity` and stores
    activities that have been completed or planned.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`activity_ids`与`mail.activity`具有一对一关系，并存储已完成或计划的活动。'
- en: Message subtypes
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息子类型
- en: Messages can be assigned a **subtype**. Subtypes can identify particular events,
    such as a task being created or closed, and are useful for fine-tuning what notifications
    should be sent to whom.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 消息可以分配一个**子类型**。子类型可以识别特定事件，例如任务的创建或关闭，并且对于微调应发送给谁的通知非常有用。
- en: Subtypes are stored in the `mail.message.subtype` model and can be configured
    in the **Settings** | **Technical** | **Email** | **Subtypes** menu.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 子类型存储在`mail.message.subtype`模型中，可以在**设置** | **技术** | **电子邮件** | **子类型**菜单中进行配置。
- en: 'The basic message subtypes that are available are as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的基本消息子类型如下：
- en: '`mail.mt_comment` XML ID, are used for the messages that are sent through the
    **Send message** option in the message widget. Followers will be sent a message
    notification about this.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mail.mt_comment` XML ID，用于通过消息小部件中的**发送消息**选项发送的消息。跟随者将收到有关此消息的通知。'
- en: '`mail.mt_note` XML ID, is used by the messages that are created with the **Log
    note** XML ID, which do not send out notifications.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mail.mt_note` XML ID，用于使用**日志笔记**XML ID创建的消息，这些消息不会发送通知。'
- en: '`mail.mt_activities` XML ID, are used for the messages that are created with
    the `Schedule activity` link. It is not intended to send a notification.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mail.mt_activities` XML ID，用于使用`安排活动`链接创建的消息。它不打算发送通知。'
- en: Apps can add their own subtypes, which are usually linked to relevant events.
    For example, the `Quotation sent` and `Sales Order Confirmed`. These are used
    by the app's business logic when you're logging these events in the message history.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以添加自己的子类型，这些子类型通常与相关事件相关联。例如，`报价已发送`和`销售订单已确认`。这些在消息历史中记录这些事件时，由应用程序的业务逻辑使用。
- en: 'Subtypes allow you to determine when notifications should be sent out and to
    whom. The followers menu, at the top right of the messages widget, allows you
    to add or remove followers, as well as selecting the particular subtypes they
    will receive notifications about. The following screenshot shows the subtype selection
    form for a specific follower – *Deco Addict*, in this case:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 子类型允许您确定何时发送通知以及发送给谁。消息小部件右上角的跟随者菜单允许您添加或删除跟随者，以及选择他们将接收通知的特定子类型。以下截图显示了特定跟随者（在这种情况下为*Deco
    Addict*）的子类型选择表单：
- en: '![Figure 8.4 – Followers widget to select the active message subtypes'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.4 – 选择活动消息子类型的跟随者小部件'
- en: '](img/Figure_8.4_B16119.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.4_B16119.jpg)'
- en: Figure 8.4 – Followers widget to select the active message subtypes
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 选择活动消息子类型的跟随者小部件
- en: The subtype subscription flags can be edited manually, and their default value
    is configured on editing the **Subtype** definition to check the **Default** field.
    When it is set, the followers on new records will receive notifications by default.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 子类型订阅标志可以手动编辑，其默认值在编辑**子类型**定义时配置，以检查**默认**字段。当它被设置时，新记录的跟随者将默认接收通知。
- en: Other than the built-in subtypes, add-on modules add their own subtypes. A subtype
    can be global or intended for a particular model. In the latter case, the subtype's
    `res_model` field identifies the model it applies to.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 除了内置的子类型外，附加模块还会添加它们自己的子类型。子类型可以是全局的或针对特定模型。在后一种情况下，子类型的 `res_model` 字段标识了它应用的模型。
- en: Posting messages
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布消息
- en: Module business logic can make use of the messaging system to send notifications
    to users.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 模块业务逻辑可以利用消息系统向用户发送通知。
- en: 'The `message_post()` method is used to post a message. Here is an example:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`message_post()` 方法用于发布消息。以下是一个示例：'
- en: '[PRE32]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The preceding code adds a simple text message but sends no notification to the
    followers. This is because, by default, messages are posted using `subtype="mail.mt_note"`
    parameter.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码添加了一条简单的文本消息，但没有向关注者发送通知。这是因为，默认情况下，消息是通过使用 `subtype="mail.mt_note"` 参数发布的。
- en: 'To have the message send a notification as well, the `mail.mt_comment` subtype
    should be used, as shown in the following example:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 要使消息发送通知，应使用 `mail.mt_comment` 子类型，如下例所示：
- en: '[PRE33]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The message body is HTML, so we can include markup for text effects, such as
    `<b>` for bold text or `<i>` for italics.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 消息体是HTML格式，因此我们可以包括用于文本效果的标记，例如 `<b>` 用于粗体文本或 `<i>` 用于斜体。
- en: The message body will be sanitized for security reasons, so some particular
    HTML elements may not make it to the final message.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 消息体将出于安全原因进行清理，因此某些特定的HTML元素可能无法出现在最终消息中。
- en: Adding followers
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加关注者
- en: 'Also useful from a business logic viewpoint is the ability to automatically
    add followers to a document so that they can then get the corresponding notifications.
    There are a few methods available to add followers, as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 从业务逻辑角度来看，自动将关注者添加到文档中以便他们可以接收相应的通知也非常有用。有一些方法可以添加关注者，如下所示：
- en: '`message_subscribe(partner_ids=<list of int IDs>)` adds partners'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`message_subscribe(partner_ids=<list of int IDs>)` 添加合作伙伴'
- en: '`message_subscribe(channel_ids=<list of int IDs>)` adds channels'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`message_subscribe(channel_ids=<list of int IDs>)` 添加渠道'
- en: '`message_subscribe_users(user_ids=<list of int IDs>)` adds users'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`message_subscribe_users(user_ids=<list of int IDs>)` 添加用户'
- en: The default subtypes will be applied to each subscriber. To force a user to
    subscribe to a specific list of subtypes, you can add the `subtype_ids=<list of
    int IDs>` attribute, which lists the specific subtypes to enable for the subscription.
    If this is used, it will also reset the existing follower-subscribed subtypes
    to the specified ones.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 默认子类型将应用于每个订阅者。要强制用户订阅特定的子类型列表，您可以添加 `subtype_ids=<list of int IDs>` 属性，该属性列出了要启用订阅的特定子类型。如果使用此属性，它还将重置现有的关注者订阅的子类型到指定的子类型。
- en: Creating a wizard
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建向导
- en: '**Wizards** are user interface patterns that provide rich interaction for the
    user, usually to provide input for an automated process.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '**向导**是用户界面模式，为用户提供丰富的交互，通常用于为自动化流程提供输入。'
- en: As an example, the `checkout` module will provide a wizard for library users
    to mass email borrowers. For example, they could select the oldest checkouts with
    borrowed books and send them all a message, requesting for the books to be returned.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`checkout` 模块将为图书馆用户提供向借阅者群发电子邮件的向导。例如，他们可以选择最旧的借阅记录和借阅的书籍，并向他们发送消息，要求归还书籍。
- en: Users start by going to the checkouts list view, selecting the checkout records
    to use, and then selecting a **Send Messages** option from the **Action** context
    menu. This will open the wizard form, allowing them to write the message subject
    and body. Clicking the **Send** button will send an email to each person that
    borrowed the selected checkouts.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 用户首先访问借阅列表视图，选择要使用的借阅记录，然后从**操作**上下文菜单中选择**发送消息**选项。这将打开向导表单，允许他们编写消息主题和正文。点击**发送**按钮将向每个借阅所选借阅记录的人发送电子邮件。
- en: The wizard model
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向导模型
- en: A wizard displays a form view to the user, usually as a dialog window, with
    some fields to be filled in and buttons to trigger some business logic. These
    will then be used for the wizard's logic.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 向导向用户显示表单视图，通常是一个对话框窗口，其中包含一些需要填写的字段和按钮来触发某些业务逻辑。然后，这些将被用于向导的逻辑。
- en: This is implemented using the same model/view architecture that's used for regular
    views, but the supporting model is based on `models.TransientModel` instead of
    `models.Model`. This type of model has a database representation too, which is
    used to store the wizard's state. The wizard data is temporary, to allow the wizard
    to complete its work. A scheduled job regularly cleans up the old data from the
    wizard database tables.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过使用与常规视图相同的模型/视图架构实现的，但支持模型基于`models.TransientModel`而不是`models.Model`。此类模型也有数据库表示，用于存储向导的状态。向导数据是临时的，以便向导完成其工作。一个计划任务会定期清理向导数据库表中的旧数据。
- en: 'The `library_checkout/wizard/library_checkout_massmessage.py` file will create
    the model data structure that''s needed for the user interaction: the list of
    checkout records to be notified, the message subject, and the message body.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`library_checkout/wizard/library_checkout_massmessage.py`文件将创建用户交互所需的数据结构模型：要通知的借阅记录列表、消息主题和消息正文。'
- en: 'Follow these steps to add the wizard to the `library_checkout` module:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将向导添加到`library_checkout`模块中：
- en: 'First, edit the `library_checkout/__init__.py` file to import the code into
    the `wizard/` subdirectory, as follows:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，编辑`library_checkout/__init__.py`文件，将代码导入到`wizard/`子目录中，如下所示：
- en: '[PRE34]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Add the `wizard/__init__.py` file with the following line of code:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`wizard/__init__.py`文件，包含以下代码行：
- en: '[PRE35]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, create the actual `wizard/checkout_mass_message.py` file, as follows:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建实际的`wizard/checkout_mass_message.py`文件，如下所示：
- en: '[PRE36]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: With that, we have prepared the basic data structures that are needed for the
    wizard.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就准备好了向导所需的基本数据结构。
- en: Note that regular models shouldn't have relationship fields that use transient
    models.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，常规模型不应有使用瞬态模型的关联字段。
- en: The consequence of this is that transient models shouldn't have one-to-many
    relationships with regular models. The reason for this is that the one-to-many
    relationship on the transient model would require the regular model to have the
    inverse many-to-one relationship with the transient model, which would cause issues
    with automatically cleaning up transient records.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着瞬态模型不应与常规模型有一对多关系。原因是瞬态模型上的一对多关系将要求常规模型与瞬态模型有反向多对一关系，这会导致自动清理瞬态记录时出现问题。
- en: The alternative to this is to use a many-to-many relationship. Many-to-many
    relationships are stored in a dedicated table, and the rows in this table are
    automatically deleted when either side of the relationship is deleted.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的替代方案是使用多对多关系。多对多关系存储在专用表中，并且当关系任一侧被删除时，该表中的行会自动删除。
- en: The wizard's access security
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向导的访问安全
- en: Just like regular models, transient models also need access security rules to
    be defined on them. This is done in the same way as it is for regular modules
    – usually, in the `security/ir.model.access.csv` file.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 正如常规模型一样，瞬态模型也需要定义访问安全规则。这可以通过与常规模块相同的方式进行，通常在`security/ir.model.access.csv`文件中完成。
- en: Changes in Odoo 13
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: Odoo 13的变化
- en: Up until Odoo 12, transient models did not need access security rules. This
    changed in Odoo 13, so now, transient models require access rules, just like regular
    models do.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 直到Odoo 12，瞬态模型不需要访问安全规则。这在Odoo 13中发生了变化，因此现在瞬态模型需要访问规则，就像常规模型一样。
- en: 'To add ACLs for the wizard''s model, edit the `security/ir.model.access.csv`
    file and add the following highlighted line:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 要为向导模型添加ACL，编辑`security/ir.model.access.csv`文件并添加以下突出显示的行：
- en: '[PRE37]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Adding one line is enough to add full access to the Library User group; no specific
    access rights are needed for the Library Manager group.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 只需添加一行即可为图书馆用户组添加完全访问权限；对于图书馆管理员组不需要特定的访问权限。
- en: The wizard form
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向导表单
- en: 'The wizard form views are defined in the same way as they are for regular models,
    except for two specific elements:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 向导表单视图的定义方式与常规模型相同，除了两个特定元素：
- en: A `<footer>` section can be used to replace the action buttons.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`<footer>`部分来替换操作按钮。
- en: A `special="cancel"` button is available to interrupt the wizard without performing
    any action.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个`special="cancel"`按钮可以用来中断向导而不执行任何操作。
- en: 'The following is the content of the `wizard/checkout_mass_message_wizard_view.xml`
    file:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`wizard/checkout_mass_message_wizard_view.xml`文件的内容：
- en: '[PRE38]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The previous XML code adds two data records – one for the wizard form view and
    another for the action to open the wizard.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的XML代码添加了两个数据记录——一个用于向导表单视图，另一个用于打开向导的操作。
- en: The `ir.actions.act_window` window action record is made available in the `binding_model_id`
    field value.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`ir.actions.act_window` 窗口操作记录在 `binding_model_id` 字段值中可用。'
- en: 'Remember to add this file to the manifest file:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 记得将此文件添加到清单文件中：
- en: '[PRE39]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The wizard form will look as follows:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 向导表单将如下所示：
- en: '![Figure 8.5 – The Send Messages wizard form'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.5 – 发送消息向导表单'
- en: '](img/Figure_8.5_B16119.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.5_B16119.jpg)'
- en: Figure 8.5 – The Send Messages wizard form
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – 发送消息向导表单
- en: To open the wizard, the user should select one or more records on the checkout
    list view and choose the **Send Messages** option via the **Action** menu, which
    is available at the top of the list view.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开向导，用户应在检查列表视图中选择一个或多个记录，并通过列表视图顶部的 **操作** 菜单选择 **发送消息** 选项。
- en: The wizard business logic
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向导业务逻辑
- en: At this point, the action opens the wizard form, but it is not capable of performing
    any operations on the records yet. To start with, we would like the wizard to
    present the list of records that were selected in the checkout list view.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，操作打开向导表单，但还不能对记录执行任何操作。首先，我们希望向导显示在检查列表视图中选择的记录列表。
- en: When the wizard form is opened, it displays an empty form. It is not a record
    yet; this will only happen when you click on a button that's calling a method.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 当打开向导表单时，它显示一个空表单。它还不是一条记录；这只会发生在你点击一个调用方法的按钮时。
- en: Note
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: When the wizard form is opened, we have an empty record. The `create()` method
    hasn't been invoked yet; this will only happen when we press a button. So, it
    can't be used to set the initial values to be presented in a wizard form.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 当打开向导表单时，我们有一个空记录。`create()` 方法尚未被调用；这只会发生在我们按下按钮时。因此，它不能用来设置在向导表单中展示的初始值。
- en: 'It is still possible to populate data on the empty form by setting default
    values on the fields. `default_get()` is an ORM API method that''s in charge of
    computing the default values for a record. It can be extended to add custom logic,
    like so:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然可以通过在字段上设置默认值来在空表单上填充数据。`default_get()` 是一个ORM API方法，负责计算记录的默认值。它可以扩展以添加自定义逻辑，如下所示：
- en: '[PRE40]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The preceding method function can be used to add the default value for the `checkout_ids`
    field. But we still need to know how to access the list of records that will be
    selected in the origin list view.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法函数可以用来为 `checkout_ids` 字段添加默认值。但我们仍然需要知道如何访问原始列表视图中将要选择的记录列表。
- en: 'When you''re navigating from a client window to the next, the web client stores
    some data about the origin view in the environment''s `context`. This data is
    as follows:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 当从客户端窗口导航到下一个窗口时，Web客户端会在环境的 `context` 中存储一些关于原始视图的数据。这些数据如下：
- en: '`Active_model`, which is the technical name of the model'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Active_model`，这是模型的官方名称'
- en: '`Active_id`, which is the ID of the form active record or the tree view''s
    first record, if you''re navigating from a list'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Active_id`，这是表单活动记录的ID或从列表导航时的树视图的第一个记录'
- en: '`active_ids`, which is a list that contains the selected records or just one
    element if you''re navigating from a form'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`active_ids`，这是一个包含所选记录的列表，如果你是从表单导航，则可能只有一个元素'
- en: '`active_domain`, if the action is triggered from a form view'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`active_domain`，如果操作是从表单视图中触发的'
- en: 'In this case, `active_ids` can be used to get the record IDs that have been
    selected in the list view and set the default value on the `checkout_ids` field.
    This is what the `default_get` method looks like:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，可以使用 `active_ids` 获取在列表视图中选择的记录ID，并在 `checkout_ids` 字段上设置默认值。`default_get`
    方法看起来是这样的：
- en: '[PRE41]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: First, `super()` is used to call the framework's `default_get()` implementation,
    which returns a dictionary containing default values. Then, the `checkout_id`
    key is added to `defaults_dict`, with the `active_ids` value read from the environment's
    context.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用 `super()` 调用框架的 `default_get()` 实现方法，该方法返回一个包含默认值的字典。然后，将 `checkout_id`
    键添加到 `defaults_dict` 中，并从环境上下文中读取 `active_ids` 值。
- en: With this, when the wizard form is opened, the `checkout_ids` field will be
    automatically populated with the records that have been selected. Next, the logic
    for the form's **Send Messages** button needs to be implemented.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一来，当打开向导表单时，`checkout_ids` 字段将自动填充已选择的记录。接下来，需要实现表单的 **发送消息** 按钮的逻辑。
- en: 'Upon inspecting the form XML code, we can see that `button_send` is the name
    of the function that''s called by the button. It should be defined in the `wizard/checkout_mass_message.py`
    file, as shown in the following code:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查表单 XML 代码时，我们可以看到 `button_send` 是按钮调用的函数名称。它应该定义在 `wizard/checkout_mass_message.py`
    文件中，如下面的代码所示：
- en: '[PRE42]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The method is designed to work with a single record and would not work correctly
    if `self` was a recordset instead of a singleton. To make this explicit, `self.ensure_one()`
    is being used.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法设计为与单个记录一起工作，如果 `self` 是一个记录集而不是单例，则不会正确工作。为了明确这一点，使用了 `self.ensure_one()`。
- en: Here, `self` represents the wizard record data, which was created when the button
    was pressed. It contains the data that was entered on the wizard form. Validation
    is performed to ensure a message body text is provided by the user.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`self` 代表向导记录数据，它在按钮被按下时创建。它包含在向导表单上输入的数据。进行验证以确保用户提供了消息体文本。
- en: The `checkout_id` field is accessed, and a loop iterates through each of its
    records. For each checkout record, a message is posted using the `mail.thread`
    API. The `mail.mt_comment` subtype must be used for a notification email to be
    sent to the record followers. The message's `body` and `subject` are taken from
    the `self` record fields.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 `checkout_id` 字段，并通过循环遍历其记录中的每一个。对于每个结账记录，使用 `mail.thread` API 发送消息。必须使用
    `mail.mt_comment` 子类型来发送通知邮件给记录的跟踪者。消息的 `body` 和 `subject` 来自 `self` 记录字段。
- en: It is good practice for methods to always return something – the `True` value
    at the very least. The sole reason for this is that some XML-RPC clients don't
    support `None` values. When a Python function has no explicit `return`, it implicitly
    returns the `None` value. In practice, you may not be aware of the issue because
    the web client uses JSON-RPC, not XML-RPC, but it is still a good practice to
    follow.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 对于方法来说，始终返回一些内容是一个好习惯——至少是 `True` 值。这样做的原因仅仅是因为一些 XML-RPC 客户端不支持 `None` 值。当一个
    Python 函数没有明确的 `return` 语句时，它隐式地返回 `None` 值。在实践中，你可能不会意识到这个问题，因为网络客户端使用的是 JSON-RPC，而不是
    XML-RPC，但遵循这个好习惯仍然很重要。
- en: Wizards are the most complex tools in our business logic toolbox and close out
    the list of techniques that will be presented in this chapter.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 向导是我们业务逻辑工具箱中最复杂的工具，也是本章将要介绍的技术列表的结束。
- en: Business logic also involves testing if the right conditions are being met before
    or after running some operation. The next section explains how to trigger exceptions
    when this doesn't happen.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 业务逻辑还涉及在运行某些操作之前或之后测试是否满足正确的条件。下一节将解释如何在这种情况下触发异常。
- en: Raising exceptions
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抛出异常
- en: There are times where the inputs are inappropriate for the task to perform,
    and the code needs to warn the user about it and interrupt the program's execution
    with an error message. This is done by raising an exception. Odoo provides exception
    classes that should be used in these situations.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，输入不适合执行的任务，代码需要警告用户并使用错误消息中断程序的执行。这是通过抛出异常来完成的。Odoo 提供了在这些情况下应该使用的异常类。
- en: 'The most useful Odoo exceptions are as follows:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 最有用的 Odoo 异常如下：
- en: '[PRE43]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `ValidationError` exception should be used for validations in Python code,
    such as the ones in `@api.constrains` decorated methods.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 应该在 Python 代码中的验证中使用 `ValidationError` 异常，例如在 `@api.constrains` 装饰的方法中。
- en: The `UserError` exception should be used in all other cases where some action
    should not be allowed because it goes against business logic.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 应该在所有其他情况下使用 `UserError` 异常，在这些情况下，某些操作不应该被允许，因为它违反了业务逻辑。
- en: As a general rule, all data manipulation that's done during method execution
    is done in a database transaction and rolled back when an exception occurs. This
    means that, when an exception is raised, all of the previous data changes are
    canceled.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般规则，在方法执行期间所做的所有数据操作都是在数据库事务中完成的，并在发生异常时回滚。这意味着，当抛出异常时，所有之前的数据更改都会被取消。
- en: Let's look at an example of using the wizard's `button_send` method. If we think
    about it, it doesn't make any sense to run the send message's logic if no checkout
    document was selected. And it doesn't make sense to send messages with no message
    body. Let's warn the user if any of these things happen.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用向导的 `button_send` 方法的例子。如果我们仔细想想，如果没有选择任何结账文档，运行发送消息的逻辑就没有任何意义。同样，发送没有消息体的消息也没有意义。如果发生这些情况之一，我们应该警告用户。
- en: 'To do so, edit the `button_send()` method and add the following highlighted
    code:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，编辑 `button_send()` 方法并添加以下突出显示的代码：
- en: '[PRE44]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: When you're using exceptions, make sure that the `from odoo import exceptions`
    instruction is added to the top of the code file. Adding validations is as simple
    as checking that some conditions have been met and raising an exception if they
    haven't been.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用异常时，请确保在代码文件顶部添加了`from odoo import exceptions`指令。添加验证就像检查某些条件是否满足，如果没有满足则抛出异常一样简单。
- en: The next section discusses the development tools that every Odoo developer should
    be familiar with. We will start with automated tests.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将讨论每个Odoo开发者都应该熟悉的开发工具。我们将从自动化测试开始。
- en: Writing unit tests
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写单元测试
- en: Automated tests are generally accepted as a best practice in software. They
    not only help ensure code is correctly implemented, but more importantly, they
    provide a safety net for future code changes or rewrites.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试通常被视为软件开发的最佳实践。它们不仅有助于确保代码正确实现，更重要的是，它们为未来的代码更改或重写提供了一个安全网。
- en: In the case of dynamic programming languages, such as Python, there is no compilation
    step and syntax errors can go unnoticed. Ensuring there's test code coverage is
    particularly important for detecting code writing mistakes, such as a mistyped
    identifier name.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在动态编程语言（如Python）的情况下，没有编译步骤，语法错误可能被忽略。确保有测试代码覆盖率对于检测代码编写错误（如误拼的标识符名称）尤为重要。
- en: These two goals provide a guiding light to test writing. One goal should be
    test coverage – writing test cases that run all your lines of code.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个目标为测试编写提供了指导。一个目标应该是测试覆盖率——编写运行所有代码行的测试用例。
- en: This alone will usually make good progress on the second goal, which is to verify
    the correctness of the code. This is because, after working on code coverage tests,
    we will surely have a great starting point to build additional test cases for
    non-trivial use cases.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 仅此一项通常就能在第二个目标上取得良好进展，即验证代码的正确性。这是因为，在完成代码覆盖率测试后，我们将有一个很好的起点来构建非平凡用例的附加测试用例。
- en: Changes in Odoo 12
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: Odoo 12中的更改
- en: In earlier Odoo versions, tests could also be described using YAML data files.
    With Odoo 12, the YAML data file engine was removed, and this type of file is
    not supported anymore. The last piece of documentation on it is available at https://doc.odoo.com/v6.0/contribute/15_guidelines/coding_guidelines_testing/.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在较早的Odoo版本中，测试也可以使用YAML数据文件来描述。随着Odoo 12的发布，YAML数据文件引擎已被移除，此类文件不再受支持。有关它的最后一份文档可在https://doc.odoo.com/v6.0/contribute/15_guidelines/coding_guidelines_testing/找到。
- en: Next, we will learn how to add unit tests to a module and then run them.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何向模块中添加单元测试并运行它们。
- en: Adding unit tests
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加单元测试
- en: Add-on module tests must be added to a `tests/` subdirectory. The test runner
    will automatically discover tests in the subdirectories with this particular name,
    and the module's top `__init__.py` file should *not* import them.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 附加模块测试必须添加到`tests/`子目录中。测试运行器将自动发现具有此特定名称的子目录中的测试，并且模块的顶级`__init__.py`文件不应导入它们。
- en: 'To add tests for the wizard logic that was created in the `library_checkout`
    add-on module, we will start by creating the `tests/__init__.py` file and importing
    the test files to be used. In this case, it should contain the following line
    of code:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 要为在`library_checkout`附加模块中创建的向导逻辑添加测试，我们首先需要创建`tests/__init__.py`文件并将要使用的测试文件导入。在这种情况下，它应该包含以下代码行：
- en: '[PRE45]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, we must create the `tests/test_checkout_mass_message.py` file and ensure
    it has the basic skeleton for the unit test code:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须创建`tests/test_checkout_mass_message.py`文件并确保它具有单元测试代码的基本框架：
- en: '[PRE46]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Odoo provides a few classes to use for tests, as follows:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: Odoo提供了一些用于测试的类，如下所示：
- en: '`TransactionCase` uses a different transaction for each test, which is automatically
    rolled back at the end.'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TransactionCase`为每个测试使用不同的事务，并在测试结束时自动回滚。'
- en: '`SingleTransactionCase` runs all the tests in a single transaction, which are
    only rolled back at the end of the last test. This can speed up tests significantly,
    but the individual tests need to be written in such a way that they are compatible.'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SingleTransactionCase`在一个事务中运行所有测试，这些测试只在最后一个测试结束时回滚。这可以显著加快测试速度，但单个测试需要以兼容的方式编写。'
- en: These test classes are wrappers around the `unittest` test cases, which are
    part of the Python standard library. For more details on this, you can refer to
    the official documentation at https://docs.python.org/3/library/unittest.html.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试类是围绕Python标准库中的`unittest`测试用例的包装器。有关更多详细信息，您可以参考官方文档：https://docs.python.org/3/library/unittest.html。
- en: The `setUp()` method is where test data is prepared and is usually stored as
    class attributes so that it is available to the test methods.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '`setUp()`方法是在这里准备测试数据的地方，通常存储为类属性，以便在测试方法中使用。'
- en: Tests are implemented as class methods, such as the `test_01_button_send()`
    example in the previous code. The test case method names must begin with the `test_`
    prefix. This is what allows them to be discovered by the test runner. Test methods
    are run in the order of the test function names.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 测试作为类方法实现，例如在前面代码中的`test_01_button_send()`示例。测试用例方法名称必须以`test_`前缀开头。这就是允许测试运行器发现它们的原因。测试方法按测试函数名称的顺序运行。
- en: The `docstring` method is printed to the server log when the tests are run and
    should be used to provide a short description of the test that's being performed.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行测试时，`docstring`方法会被打印到服务器日志中，并应用来提供正在执行的测试的简短描述。
- en: Running tests
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行测试
- en: Once the tests have been written, it is time to run them. For that, you must
    upgrade or install the modules to test (`-I` or `-u`) and add the–`-test-enable`
    option to the Odoo `server` command.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编写了测试，就是时候运行它们了。为此，您必须升级或安装要测试的模块（`-I`或`-u`），并将`-test-enable`选项添加到Odoo `server`命令中。
- en: 'The command will look like this:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 命令看起来像这样：
- en: '[PRE47]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Only the installed or upgraded modules will be tested – that's why the `-u`
    option was used. If some dependencies need to be installed, their tests will run
    too. If you don't want this to happen, then install the new modules and then run
    the tests while upgrading (`-u`) the module to test.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 只会测试已安装或升级的模块 - 这就是为什么使用了`-u`选项。如果需要安装某些依赖项，它们的测试也会运行。如果您不希望发生这种情况，那么请安装新模块，然后在升级（`-u`）测试模块时运行测试。
- en: 'Although the module contains testing code, this code doesn''t test anything
    yet and should run successfully. If we take a closer look at the server log, there
    should be `INFO` messages reporting the test runs, similar to this:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然该模块包含测试代码，但这些代码还没有进行任何测试，应该能够成功运行。如果我们仔细查看服务器日志，应该有报告测试运行的`INFO`消息，类似于以下内容：
- en: '[PRE48]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The test code skeleton is ready. Now, the actual testing code needs to be added.
    We should start with setting up the data.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码框架已经准备好了。现在，需要添加实际的测试代码。我们应该从设置数据开始。
- en: Setting up tests
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置测试
- en: The first step when writing tests is to prepare the data to use. This is typically
    done in the `setUp` method. For our example, a checkout record is needed so that
    it can be used in the wizard tests.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试的第一步是准备要使用的数据。这通常在`setUp`方法中完成。在我们的例子中，需要一个结账记录，以便在向导测试中使用。
- en: It is convenient to perform the test actions as a specific user to also test
    that access control has been configured properly. This can be achieved using the
    `sudo(<user>)` model method. Recordsets carry that information with them, so after
    being created using `sudo()`, later operations in the same recordset will be performed
    using that same context.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 将测试操作作为特定用户执行以测试访问控制是否已正确配置是很方便的。这可以通过使用`sudo(<user>)`模型方法来实现。Recordsets会携带这些信息，因此在使用`sudo()`创建后，同一recordset中的后续操作将使用相同的上下文执行。
- en: 'This is the code for the `setUp` method:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`setUp`方法的代码：
- en: '[PRE49]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now, we can use the `self.checkout0` record and the `self.Wizard` model for
    our tests.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`self.checkout0`记录和`self.Wizard`模型来进行我们的测试。
- en: Writing test cases
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写测试用例
- en: Now, let's expand the `test_button_test()` method that we saw in the initial
    skeleton to implement the tests.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们扩展我们在初始框架中看到的`test_button_test()`方法，以实现测试。
- en: A basic test runs some code on the tested object, gets a result, and then uses
    an `assert` statement to compare it with an expected result. The message posting
    logic does not return any value to check, so a different approach is needed.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 基本测试会在测试对象上运行一些代码，得到一个结果，然后使用`assert`语句将其与预期结果进行比较。消息发布逻辑不会返回任何值以进行检查，因此需要不同的方法。
- en: 'The `button_send()` method adds a message to the message history. One way to
    check if this happened is to count the number of messages before and after running
    the method. The test code can count the number of messages before and after the
    wizard. The following code adds this:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '`button_send()`方法向消息历史记录中添加一条消息。检查这发生的一种方法是在运行方法前后计算消息的数量。测试代码可以在向导前后计算消息的数量。以下代码添加了这一点：'
- en: '[PRE50]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The check for verifying whether the test succeeded or failed is the `self.assertEqual`
    statement. It compares the number of messages before and after running the wizard.
    It is expected to find one more message than it did previously. The last parameter
    provides an optional but recommended message that's printed when the test fails.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 验证测试是否成功或失败的检查是`self.assertEqual`语句。它比较运行向导前后的消息数量。预期会发现比之前多一条消息。最后一个参数提供了一个可选但推荐的消息，当测试失败时打印出来。
- en: The `assertEqual` function is just one of the assert methods that's available.
    The appropriate assert function should be selected for the check to perform. The
    `unittest` documentation provides a good reference for all of the methods. It
    can be found at https://docs.python.org/3/library/unittest.html#test-cases.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertEqual`函数只是可用的断言方法之一。应根据要执行的检查选择适当的断言函数。《unittest》文档提供了所有方法的良好参考，可以在https://docs.python.org/3/library/unittest.html#test-cases找到。'
- en: Running the wizard is not straightforward, and the user interface workflow needs
    to be mimicked. Recall that the environment's context is used to pass data to
    the wizard, on the `active_ids` key. We must create a wizard record with the values
    that have been filled in the wizard form for the message subject and body and
    then run the `button_send` method.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 运行向导并不简单，用户界面工作流程需要被模拟。回想一下，环境上下文被用来通过`active_ids`键向向导传递数据。我们必须创建一个带有消息主题和正文已填写值的向导记录，然后运行`button_send`方法。
- en: 'The complete code looks like this:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码如下所示：
- en: '[PRE51]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `with_context` model method is used to add `active_ids` to the environment's
    context. Then, the `create()` method is used to create the wizard record and add
    the user-entered data. Finally, the `button_send` method is called.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`with_context`模型方法将`active_ids`添加到环境上下文中。然后，使用`create()`方法创建向导记录并添加用户输入的数据。最后，调用`button_send`方法。
- en: More test cases are added with additional methods for the test class. Remember,
    with `TransactionCase` tests, a rollback is done at the end of each test and the
    operations that were performed in the previous test are reverted. With `SingleTransactionCase`,
    tests build each other up, and the test run sequence is important. Since tests
    are run in alphabetical order, the names that are chosen for the test methods
    are relevant. To make this clearer, it is a good practice to add a number at the
    beginning of the test method names, as we did in the preceding example.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 为测试类添加更多测试用例，并使用额外的测试方法。记住，对于`TransactionCase`测试，每个测试结束时都会进行回滚，并且前一个测试中执行的操作会被撤销。对于`SingleTransactionCase`，测试会依次构建，测试运行顺序很重要。由于测试是按字母顺序运行的，因此为测试方法选择的名字是相关的。为了使这一点更清晰，一个好的做法是在测试方法名前添加一个数字，就像我们在前面的例子中所做的那样。
- en: Testing exceptions
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试异常
- en: In some cases, the code is expected to raise an exception, and that should also
    be tested. For example, we can test whether validation is being performed correctly.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，代码预期会引发异常，这也应该被测试。例如，我们可以测试验证是否被正确执行。
- en: Continuing with the wizard tests, validation is performed to check for an empty
    message body. A test can be added to check that this validation is done properly.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 继续进行向导测试，执行验证以检查消息正文是否为空。可以添加一个测试来检查此验证是否正确执行。
- en: To check whether an exception has been raised, the corresponding code must be
    placed inside a `with self.assertRaises()` code block.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查是否引发了异常，相应的代码必须放在`with self.assertRaises()`代码块内。
- en: 'Another method should be added for this test, as follows:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 应该为这个测试添加另一种方法，如下所示：
- en: '[PRE52]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If the `button_send()` method doesn't raise `UserException`, the test will fail.
    If it does raise that exception, the test will succeed. The exception that's raised
    is stored in the `e` variable, which could be inspected by additional method commands
    – for example, to verify the content of the error message.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`button_send()`方法没有引发`UserException`，则测试将失败。如果它确实引发了该异常，则测试将成功。引发的异常存储在`e`变量中，可以通过额外的方法命令进行检查——例如，以验证错误消息的内容。
- en: Using log messages
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用日志消息
- en: Writing messages to the log file is useful for monitoring and auditing running
    systems. It can also help with code maintenance, making it easier to get debug
    information from running processes, without the need to change code.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 将消息写入日志文件对于监控和审计运行系统很有用。它还可以帮助代码维护，使得从运行过程中获取调试信息更容易，而无需更改代码。
- en: 'To use logging in Odoo code, first, a logger object must be prepared. For this,
    add the following code lines at the top of the `library_checkout/wizard/checkout_mass_message.py`
    file:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Odoo 代码中使用日志记录，首先，必须准备一个记录器对象。为此，在 `library_checkout/wizard/checkout_mass_message.py`
    文件顶部添加以下代码行：
- en: '[PRE53]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `logging` Python standard library module is being used here. The `_logger`
    object is initialized using the name of the current code file, `__name__`. With
    this, the log messages will include information about the file that generated
    them.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的是 `logging` Python 标准库模块。使用当前代码文件的名称 `__name__` 初始化 `_logger` 对象。这样，日志消息将包括生成它们的文件信息。
- en: 'There are several levels available for log messages. These are as follows:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 日志消息有几种可用级别。具体如下：
- en: '[PRE54]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We can now use the logger to write messages to the Odoo server log.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用记录器将消息写入 Odoo 服务器日志。
- en: 'This log can be added to the `button_send` wizard method. Add the following
    instruction before the ending line; that is, `return True`:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 此日志可以添加到 `button_send` 向导方法中。在结束行之前添加以下指令；即，`return True`：
- en: '[PRE55]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'With this code, when the wizard is used to send messages, a message similar
    to the following will be printed to the server log:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码，当使用向导发送消息时，服务器日志将打印出类似以下的消息：
- en: '[PRE56]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Notice that Python string interpolation – that is, using the `%` operator –
    was not used in the log message. More specifically, instead of `_logger.info("Hello
    %s" % "World")`, what was used was something like `_logger.info("Hello %s", "World")`.
    Not using interpolation means one less task for the code to perform at runtime,
    which makes logging more efficient. So, the variables should always be provided
    as additional log parameters.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在日志消息中没有使用 Python 字符串插值 - 即，使用 `%` 操作符。更具体地说，而不是 `_logger.info("Hello %s"
    % "World")`，使用的是类似 `_logger.info("Hello %s", "World")` 的方式。不使用插值意味着代码在运行时有一个更少的任务要执行，这使得日志记录更高效。因此，变量应始终作为额外的日志参数提供。
- en: The timestamps of server log messages always use UTC. This may come as a surprise
    and comes from the fact that the Odoo server internally handles all dates in UTC.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器日志消息的时间戳始终使用 UTC。这可能会让人惊讶，这源于 Odoo 服务器内部处理所有日期都使用 UTC 的事实。
- en: 'For debug-level log messages, `_logger.debug()` is used. As an example, add
    the following debug log message right after the `checkout.message_post()` instruction:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 对于调试级别的日志消息，使用 `_logger.debug()`。例如，在 `checkout.message_post()` 指令之后立即添加以下调试日志消息：
- en: '[PRE57]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: By default, this won't print anything to the server log, since the default log
    level is `INFO`. The log level needs to be set to `DEBUG` for the debug messages
    to be printed to the log.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这不会将任何内容打印到服务器日志中，因为默认日志级别是 `INFO`。需要将日志级别设置为 `DEBUG` 才能将调试消息打印到日志中。
- en: The Odoo `--log-level` command option sets the general log level. For example,
    adding `--log-level=debug` to the command line enables all debug log messages.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: Odoo 的 `--log-level` 命令选项设置了一般的日志级别。例如，将 `--log-level=debug` 添加到命令行中可以启用所有调试日志消息。
- en: This can be fine-tuned and have a specific log level set only for particular
    modules. To enable debug messages only for this wizard code, use the `--log-handler`
    option. This can be used several times to set the log level for several modules.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过微调并只为特定模块设置特定的日志级别来进行优化。要只为这个向导代码启用调试消息，使用 `--log-handler` 选项。这可以多次使用来设置多个模块的日志级别。
- en: 'For example, the Python module for the wizard is `odoo.addons.library_checkout.wizard.checkout_mass_message`,
    as shown in the `INFO` log messages. To set a debug log level for it, use the
    following command-line option:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，向导的 Python 模块是 `odoo.addons.library_checkout.wizard.checkout_mass_message`，如
    `INFO` 日志消息所示。要为其设置调试日志级别，使用以下命令行选项：
- en: '[PRE58]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The complete reference to the Odoo server logging options can be found in the
    official documentation: [https://www.odoo.com/documentation/15.0/developer/misc/other/cmdline.html](https://www.odoo.com/documentation/15.0/developer/misc/other/cmdline.html).'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: Odoo 服务器日志选项的完整参考可以在官方文档中找到：[https://www.odoo.com/documentation/15.0/developer/misc/other/cmdline.html](https://www.odoo.com/documentation/15.0/developer/misc/other/cmdline.html)。
- en: Tip
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'If you want to get into the nitty-gritty details of Python logging, the official
    documentation is a good place to start: [https://docs.python.org/3/library/logging.html](https://docs.python.org/3/library/logging.html).'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想深入了解 Python 日志记录，官方文档是一个很好的起点：[https://docs.python.org/3/library/logging.html](https://docs.python.org/3/library/logging.html)。
- en: Logging is a useful tool, but it's short when it comes to debugging. There are
    a few tools and techniques that are available to help developers with their work.
    We'll look at these in the next section.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 记录日志是一个有用的工具，但在调试方面比较简短。有一些工具和技术可以帮助开发者完成工作。我们将在下一节中探讨这些工具。
- en: Learning about the available developer tools
  id: totrans-475
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解可用的开发者工具
- en: There are a few tools to ease developers' work. The web interface's **Developer
    Mode**, which we introduced earlier in this book, is one of them. A server developer
    mode option is also available that provides some developer-friendly features.
    It will be explained in more detail next. After that, we will discuss how to debug
    code on the server.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 几种工具可以简化开发者的工作。我们在这本书中之前介绍过的网页界面的**开发者模式**就是其中之一。还有一个服务器开发者模式选项，它提供了一些对开发者友好的功能。接下来将详细介绍这些功能。之后，我们将讨论如何在服务器上调试代码。
- en: Server development options
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器开发选项
- en: 'The Odoo server provides a `--dev` option, which enables developer features
    to speed up the development cycle, such as the following:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: Odoo服务器提供了一个`--dev`选项，该选项启用开发者功能以加快开发周期，例如以下功能：
- en: Entering the debugger when an exception is found in an add-on module. This is
    done by setting a debugger. `pdb` is the default one.
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在发现附加模块中的异常时进入调试器。这是通过设置调试器完成的。`pdb`是默认的。
- en: Reloading Python code automatically when a Python code file is saved, avoiding
    a manual server restart. This can be enabled with the `reload` option.
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当Python代码文件保存时自动重新加载Python代码，避免手动重启服务器。这可以通过`reload`选项启用。
- en: Reading view definitions directly from XML files, avoiding manual module upgrades.
    This can be enabled with the `xml` option.
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接从XML文件中读取视图定义，避免手动模块升级。这可以通过`xml`选项启用。
- en: A Python debugging interface is used directly in the web browser. This can be
    enabled with the `werkzeug` option.
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接在网页浏览器中使用Python调试接口。这可以通过`werkzeug`选项启用。
- en: The `--dev` option accepts a comma-separated list of options. The `all` option
    can be used to conveniently enable all of these options using `--dev=all`.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '`--dev`选项接受一个以逗号分隔的选项列表。可以使用`all`选项，通过`--dev=all`方便地启用所有这些选项。'
- en: 'When you''re enabling a debugger, the Odoo server will use `pdb` by default,
    but other options can be used if they''ve been installed in your system. The supported
    alternatives are as follows:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启用调试器时，Odoo服务器默认使用`pdb`，但如果你的系统中已安装其他选项，也可以使用。支持的替代选项如下：
- en: '`ipdb`; see [https://pypi.org/project/ipdb](https://pypi.org/project/ipdb)
    for details.'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ipdb`；有关详细信息，请参阅[https://pypi.org/project/ipdb](https://pypi.org/project/ipdb)。'
- en: '`pudb`; see [https://pypi.org/project/pudb](https://pypi.org/project/pudb)
    for details.'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pudb`；有关详细信息，请参阅[https://pypi.org/project/pudb](https://pypi.org/project/pudb)。'
- en: '`wdb`; see [https://pypi.org/project/wdb](https://pypi.org/project/wdb) for
    details.'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wdb`；有关详细信息，请参阅[https://pypi.org/project/wdb](https://pypi.org/project/wdb)。'
- en: When you're editing Python code, the server needs to be restarted every time
    the code is changed so that the latest code is reloaded and used by Odoo. The
    `--dev=reload` option automates this reloading. When enabled, the Odoo server
    detects changes that have been made to code files and automatically triggers code
    reloading, making the code changes effective immediately.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编辑Python代码时，每次代码更改都需要重新启动服务器，以便重新加载并使用Odoo的最新代码。`--dev=reload`选项可以自动化这一过程。启用后，Odoo服务器会检测到对代码文件的更改，并自动触发代码重新加载，使代码更改立即生效。
- en: 'For the code reload to work, the `watchdog` Python package is required. It
    can be installed with the following command:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码重新加载生效，需要`watchdog`Python包。可以使用以下命令进行安装：
- en: '[PRE59]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `--dev=all` server command option also enables `reload`, and it is what
    is used most of the time:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '`--dev=all`服务器命令选项还启用了`reload`，这是最常用的方式：'
- en: '[PRE60]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note that this is only useful for Python code changes. For other changes, such
    as changing the model's data structure, a module upgrade is needed; reloading
    it is not enough.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这仅适用于Python代码更改。对于其他更改，例如更改模型的数据结构，需要模块升级；仅重新加载是不够的。
- en: Debugging
  id: totrans-494
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试
- en: A big part of a developer's work is debugging code. For this, it is convenient
    to be able to set breakpoints and run the code step by step.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者工作中的一大部分是调试代码。为此，能够设置断点和逐步运行代码是非常方便的。
- en: Odoo is a server that runs Python code that waits for client requests, which
    are processed by the relevant server code, and then returns a response to the
    client. This means that Python code debugging is done on the server side. Breakpoints
    are activated in the server, pausing the server's execution on that line of code.
    So, the developer needs access to the terminal window running the server both
    to set breakpoints and to operate the debugger when those breakpoints are triggered.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: Odoo 是一个运行 Python 代码的服务器，它等待客户端请求，这些请求由相关服务器代码处理，然后向客户端返回响应。这意味着 Python 代码的调试是在服务器端进行的。断点在服务器上激活，暂停代码执行到该行。因此，开发者需要访问运行服务器的终端窗口，以便设置断点和在触发断点时操作调试器。
- en: The Python debugger
  id: totrans-497
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python 调试器
- en: The simplest debugging tool that's available is the Python integrated debugger,
    `pdb`. However, other options are available that provide a richer user interface,
    closer to what sophisticated IDEs usually provide.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的最简单的调试工具是 Python 集成调试器 `pdb`。然而，还有其他选项提供更丰富的用户界面，更接近于复杂 IDE 通常提供的界面。
- en: There are two ways a debugger prompt can be triggered.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器提示符可以触发的有两种方式。
- en: One is when an unhandled exception is raised and the `--dev=all` option is enabled.
    The debugger will stop the code's execution at the instruction causing the exception.
    The developer can then inspect the variables and program state at that moment,
    to gain a better understanding of what is causing it.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 一种是当抛出一个未处理的异常并且启用了 `--dev=all` 选项时。调试器将在引发异常的指令处停止代码执行。开发者可以检查那一刻的变量和程序状态，以更好地理解导致异常的原因。
- en: 'The other way is to manually set a breakpoint by editing the code and adding
    the following line where the execution should pause:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方式是通过编辑代码并添加以下行来手动设置断点，以便在执行应暂停的位置：
- en: '[PRE61]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This does not require the `–dev` mode to be enabled. An Odoo server reload is
    needed for the changed code to be used. When the program execution reaches the
    `pdb.set_trace()` command, a `(pdb)` Python prompt will be shown in the server's
    terminal window, waiting for input.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 这不需要启用 `–dev` 模式。需要重新加载 Odoo 服务器以使用更改后的代码。当程序执行到达 `pdb.set_trace()` 命令时，服务器终端窗口将显示
    `(pdb)` Python 提示符，等待输入。
- en: The `(pdb)` prompt works as a Python shell and can run any expression or command
    in the current execution context. This means that the current variables can be
    inspected and even modified.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '`(pdb)` 提示符充当 Python shell，可以在当前执行上下文中运行任何表达式或命令。这意味着可以检查当前变量，甚至修改它们。'
- en: 'A few debugger-specific commands are also available. These are the most important
    commands that are available:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 一些调试器特定的命令也是可用的。这些是最重要的可用命令：
- en: '`h` (help) displays a summary of the available `pdb` commands.'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`h`（帮助）显示可用 `pdb` 命令的摘要。'
- en: '`p` (print) evaluates and prints an expression.'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`p`（打印）评估并打印一个表达式。'
- en: '`pp` (pretty-print) is useful to print data structures, such as dictionaries
    or lists.'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pp`（pretty-print）用于打印数据结构，如字典或列表。'
- en: '`l` (list) lists the code around the instruction to be executed next.'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`l`（列表）列出将要执行的下一条指令周围的代码。'
- en: '`n` (next) steps over to the next instruction.'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n`（下一步）跳过到下一条指令。'
- en: '`s` (step) steps into the current instruction.'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s`（步进）进入当前指令。'
- en: '`c` (continue) continues execution normally.'
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c`（继续）正常继续执行。'
- en: '`u` (up) moves up in the execution stack.'
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u`（向上）在执行栈中向上移动。'
- en: '`d` (down) moves down in the execution stack.'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d`（向下）在执行栈中向下移动。'
- en: '`bt` (backtrace) shows the current execution stack.'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bt`（backtrace）显示当前执行栈。'
- en: 'The Python official documentation includes a complete description of the `pdb`
    commands: [https://docs.python.org/3/library/pdb.html#debugger-commands](https://docs.python.org/3/library/pdb.html#debugger-commands).'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: Python 官方文档包括 `pdb` 命令的完整描述：[https://docs.python.org/3/library/pdb.html#debugger-commands](https://docs.python.org/3/library/pdb.html#debugger-commands)。
- en: A sample debugging session
  id: totrans-517
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个示例调试会话
- en: To understand how to use the debugger's features, let's see what a debugging
    session looks like.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用调试器的功能，让我们看看一个调试会话的样子。
- en: 'Start by adding a debugger breakpoint to the first line of the `button_send()`
    wizard method, as follows:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 首先在 `button_send()` 工作表方法的第 一行添加调试器断点，如下所示：
- en: '[PRE62]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: After performing a server reload, open the `button_send()` method on the server,
    which will pause at the breakpoint. The web client will stay in a **Loading…**
    state while it is waiting for the server's response.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行服务器重新加载后，打开服务器上的 `button_send()` 方法，这将暂停在断点处。当它等待服务器的响应时，Web 客户端将保持在 **加载中…**
    状态。
- en: 'At that point, the terminal window where the server is running should display
    something similar to this:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个时刻，运行服务器的终端窗口应该显示类似以下内容：
- en: '[PRE63]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This is the `pdb` debugger prompt, and the two previous lines provide information
    about where the Python code execution was paused. The first line shows the file,
    line number, and function name, while the second line is the code in that line
    that will be run next.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `pdb` 调试器提示符，前两行提供了有关 Python 代码执行暂停位置的信息。第一行显示文件、行号和函数名，而第二行是下一行将要运行的代码。
- en: Tip
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: During a debug session, server log messages can creep in. Most of these are
    from the `werkzeug` module. They can be silenced by adding the `--log-handler=werkzeug:WARNING`
    option to the Odoo command. Another option is to lower the general log verbosity
    using `--log-level=warn`.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试会话期间，服务器日志消息可能会悄悄出现。其中大部分来自 `werkzeug` 模块。可以通过向 Odoo 命令添加 `--log-handler=werkzeug:WARNING`
    选项来静音这些消息。另一种选择是使用 `--log-level=warn` 降低日志的一般详细程度。
- en: Typing `h` shows a quick reference of the available commands. Typing `l` shows
    the current line of code and the surrounding lines of code.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 `h` 会显示可用命令的快速参考。输入 `l` 会显示当前代码行及其周围的代码行。
- en: Typing `n` runs the current line of code and moves to the next one. Pressing
    *Enter* repeats the previous command.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 `n` 会运行当前代码行并移动到下一行。按下 *Enter* 重复上一个命令。
- en: 'The `p` debug command prints out the result of an expression, while `pp` does
    the same but formats the output to be more readable, especially the `dict` and
    `list` data structures. For example, to print the value for the `checkout_ids`
    field that''s used in the wizard, type the following:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '`p` 调试命令会打印出一个表达式的结果，而 `pp` 命令则执行相同的操作，但将输出格式化得更加易读，特别是对于 `dict` 和 `list` 数据结构。例如，要打印用于向导中的
    `checkout_ids` 字段值，请输入以下命令：'
- en: '[PRE64]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The debug prompt can run Python commands and expressions. Any Python expressions
    are allowed, even variable assignments.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 调试提示符可以运行 Python 命令和表达式。允许任何 Python 表达式，甚至变量赋值。
- en: When you're done with a debugging session, type `c` to continue the normal program
    execution. In some cases, you may want to interrupt the execution, and `q` can
    be used to quit.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成调试会话后，输入 `c` 以继续正常程序执行。在某些情况下，你可能想要中断执行，此时可以使用 `q` 来退出。
- en: Tip
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: When you go back from the debugger to the terminal prompt, the terminal may
    look unresponsive, and any typed text won't be printed to the terminal. This can
    be solved by using the `reset` command; that is, by typing `<enter>reset<enter>`.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从调试器返回到终端提示符时，终端可能会看起来无响应，并且任何输入的文本都不会打印到终端。这可以通过使用 `reset` 命令来解决；即通过输入 `<enter>reset<enter>`。
- en: Alternative Python debuggers
  id: totrans-535
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他 Python 调试器
- en: While `pdb` has the advantage of being available out of the box, it can be quite
    terse. Fortunately, a few more comfortable options exist.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `pdb` 有现成可用的优势，但它可能相当简洁。幸运的是，还有一些更舒适的选项存在。
- en: 'The IronPython debugger, `ipdb`, is a popular choice that uses the same commands
    as `pdb` but adds improvements such as tab completion and syntax highlighting
    for more comfortable usage. It can be installed with the following command:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: IronPython 调试器 `ipdb` 是一个流行的选择，它使用与 `pdb` 相同的命令，但增加了如自动补全和语法高亮等改进，使用起来更加舒适。可以使用以下命令进行安装：
- en: '[PRE65]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'To add a breakpoint, use the following command:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加断点，请使用以下命令：
- en: '[PRE66]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Another alternative debugger is `pudb`. It also supports the same commands as
    `pdb` and works in text terminals, but it uses a window-like graphical display.
    Useful information, such as the variables in the current context and their values,
    is readily available on the screen in separate windows.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个替代的调试器是 `pudb`。它也支持与 `pdb` 相同的命令，并在文本终端中工作，但它使用类似窗口的图形显示。有用的信息，如当前上下文中的变量及其值，可以在屏幕上的单独窗口中轻松获取。
- en: 'It can be installed either through the system package manager or through `pip`,
    as shown here:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以通过系统包管理器或通过 `pip` 安装，如下所示：
- en: '[PRE67]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'A breakpoint can be added in a way similar to `pdb`:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 可以以类似于 `pdb` 的方式添加断点：
- en: '[PRE68]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'A short version is also available:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 也有简短版本可用：
- en: '[PRE69]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The preceding code can be typed faster and also provides the intended effect
    – to add a code execution breakpoint.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码可以更快地输入，同时也提供了预期的效果——添加代码执行断点。
- en: Note
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Since Python 3.7, breakpoints can be simplified by using the `breakpoint()`
    function instead of `pdb.set_trace()`. Debugging libraries can overwrite the `breakpoint()`
    behavior to directly call them. However, at the time of writing, `pudb` and `ipdb`
    aren't doing this, so there is no benefit to using `breakpoint()` with them.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Python 3.7 以来，可以通过使用 `breakpoint()` 函数而不是 `pdb.set_trace()` 来简化断点的设置。调试库可以覆盖
    `breakpoint()` 的行为，直接调用它们。然而，在撰写本文时，`pudb` 和 `ipdb` 并没有这样做，因此使用 `breakpoint()`
    与它们一起没有好处。
- en: Printing messages and logging
  id: totrans-551
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打印消息和记录日志
- en: Sometimes, we just need to inspect the values of some variables or check whether
    some code blocks are being executed. A Python `print()` instruction can do the
    job perfectly without stopping the flow of execution. Note that the printed text
    is sent to the standard output and won't be stored in the server log if it is
    being written to a file.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们只需要检查一些变量的值或检查某些代码块是否正在执行。Python 的 `print()` 指令可以完美地完成这项工作，而不会停止执行流程。请注意，打印的文本被发送到标准输出，如果它被写入文件，则不会存储在服务器日志中。
- en: The `print()` function is only being used as a development aid and should not
    make its way to the final code, ready to be deployed. If the `print` statements
    can also help investigate issues in a production system, consider converting them
    into debug-level log messages.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '`print()` 函数仅用作开发辅助工具，不应出现在最终代码中，准备部署。如果 `print` 语句还能帮助调查生产系统中的问题，考虑将它们转换为调试级别的日志消息。'
- en: Inspecting and killing running processes
  id: totrans-554
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查和终止正在运行的进程
- en: There are also a few tricks that allow us to inspect running Odoo processes.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几个技巧可以让我们检查正在运行的 Odoo 进程。
- en: 'First, find the server instance''s **process ID** (**PID**). This number is
    printed with each log message, right after the timestamp. Another way to find
    the PID is to run the following command in another terminal window:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，找到服务器实例的 **进程 ID**（**PID**）。这个数字在每个日志消息中打印出来，紧随时间戳之后。另一种找到 PID 的方法是，在另一个终端窗口中运行以下命令：
- en: '[PRE70]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Here is a sample output:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例输出：
- en: '[PRE71]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The first column in the output is the PID of the processes. In this example,
    `21688` is the Odoo process PID.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第一列是进程的 PID。在这个例子中，`21688` 是 Odoo 进程的 PID。
- en: Now that we know the process PID, signals can be sent to that Odoo server process.
    The `kill` command is used to send these signals. By default, `kill` sends a signal
    to terminate a process, but it can also send other, friendlier signals.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了进程的 PID，可以向该 Odoo 服务器进程发送信号。`kill` 命令用于发送这些信号。默认情况下，`kill` 发送一个信号来终止进程，但它也可以发送其他更友好的信号。
- en: 'The Odoo server will print out the stack trace at the code currently being
    executed if it''s sent a `SIGQUIT` or `-3` signal:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 如果向 Odoo 服务器发送 `SIGQUIT` 或 `-3` 信号，Odoo 服务器将打印出当前正在执行的代码的堆栈跟踪：
- en: '[PRE72]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: After sending `SIGQUIT`, the Odoo server log will display a stack trace. This
    can be useful for understanding what code was being executed at that point. This
    information is printed for each of the threads being used.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 发送 `SIGQUIT` 后，Odoo 服务器日志将显示堆栈跟踪。这有助于了解当时正在执行哪些代码。这些信息为每个正在使用的线程打印出来。
- en: It is used by some code profiling approaches to track where the server is spending
    time and profile the code's execution. Some useful information on code profiling
    is given in the official documentation at [https://www.odoo.com/documentation/15.0/howtos/profilecode.html](https://www.odoo.com/documentation/15.0/howtos/profilecode.html).
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 它被一些代码分析方法用来跟踪服务器在哪里花费时间，并分析代码的执行。有关代码分析的有用信息可以在官方文档中找到，见 [https://www.odoo.com/documentation/15.0/howtos/profilecode.html](https://www.odoo.com/documentation/15.0/howtos/profilecode.html)。
- en: 'Other signals we can send to the Odoo server process include `HUP`, to reload
    the server, and `INT` or `TERM` to force the server to shut down, as follows:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向 Odoo 服务器进程发送的其他信号包括 `HUP`，用于重新加载服务器，以及 `INT` 或 `TERM`，用于强制服务器关闭，如下所示：
- en: '[PRE73]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The HUP signal can be particularly useful for reloading the Odoo configuration
    without stopping the server.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '`HUP` 信号在无需停止服务器的情况下重新加载 Odoo 配置时特别有用。'
- en: Summary
  id: totrans-569
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the various features of the ORM API and how to
    use them to create dynamic applications that react to users, which helps them
    avoid errors and automate tedious tasks.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 ORM API 的各种功能以及如何使用它们来创建对用户做出反应的动态应用程序，这有助于他们避免错误并自动化繁琐的任务。
- en: The model validations and computed fields can cover a lot of use cases, but
    not all. We learned how to extend the API's create, write, and unlink methods
    to cover further use cases.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 模型验证和计算字段可以覆盖很多用例，但并非全部。我们学习了如何扩展 API 的创建、写入和解除链接方法以覆盖更多用例。
- en: For rich user interaction, we used the `mail` core add-on mixins to add features
    for users to communicate about documents and plan activities on them. Wizards
    allow the application to dialogue with the user and gather the data that's needed
    to run particular processes. Exceptions allow the application to abort incorrect
    operations, informing the user of the problem and rolling back intermediate changes,
    keeping the system consistent.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 为了丰富的用户交互，我们使用了 `mail` 核心插件混入来添加用户关于文档的通信和在其上计划活动的功能。向导允许应用程序与用户进行对话并收集运行特定流程所需的数据。异常允许应用程序中止不正确的操作，通知用户问题并回滚中间更改，保持系统一致性。
- en: 'We also discussed the tools that are available for developers to create and
    maintain their applications: logging messages, debugging tools, and unit tests.'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了开发者创建和维护应用程序可用的工具：日志消息、调试工具和单元测试。
- en: 'In the next chapter, we will still be working with the ORM, but we will be
    looking at this from the point of view of an external application: we will be
    working with the Odoo server as a backend for storing data and running business
    processes.'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们仍然会使用 ORM，但我们将从外部应用的角度来审视它：我们将使用 Odoo 服务器作为后端来存储数据和运行业务流程。
- en: Further reading
  id: totrans-575
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following are the most relevant reference materials for the topics that
    were discussed in this chapter:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在本章讨论的主题中最相关的参考资料：
- en: 'ORM reference: [https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html](https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html)'
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ORM 参考：[https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html](https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html)
- en: 'Message and activities features: [https://www.odoo.com/documentation/15.0/developer/reference/backend/mixins.html](https://www.odoo.com/documentation/15.0/developer/reference/backend/mixins.html)'
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息和活动功能：[https://www.odoo.com/documentation/15.0/developer/reference/backend/mixins.html](https://www.odoo.com/documentation/15.0/developer/reference/backend/mixins.html)
- en: 'Odoo tests reference: [https://www.odoo.com/documentation/15.0/developer/reference/backend/testing.html](https://www.odoo.com/documentation/15.0/developer/reference/backend/testing.html)'
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Odoo 测试参考：[https://www.odoo.com/documentation/15.0/developer/reference/backend/testing.html](https://www.odoo.com/documentation/15.0/developer/reference/backend/testing.html)
- en: 'Python `unittest` reference: [https://docs.python.org/3/library/unittest.html#module-unittest](https://docs.python.org/3/library/unittest.html#module-unittest)'
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python `unittest` 参考：[https://docs.python.org/3/library/unittest.html#module-unittest](https://docs.python.org/3/library/unittest.html#module-unittest)
