- en: Chapter 1 – Getting started
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1章-入门
- en: In this chapter we’ll cover obtaining and installing Python on your system for
    Windows, Ubuntu Linux, and macOS. We’ll also write our first basic Python code
    and become a acquainted with the essentials Python programming culture, such as
    the Zen of Python, while never forgetting the comical origins of the name of the
    language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍如何在Windows、Ubuntu Linux和macOS上获取和安装Python。我们还将编写我们的第一个基本Python代码，并熟悉Python编程文化的基本知识，比如Python之禅，同时永远不要忘记语言名称的滑稽起源。
- en: Obtaining and installing Python 3
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取和安装Python 3
- en: There are two major versions of the Python language, *Python 2* which is the
    widely deployed legacy language and *Python 3* which is the present and future
    of the language. Much Python code will work without modification between the last
    version of Python 2 (which is [Python 2.7](https://www.python.org/download/releases/2.7/))
    and recent versions of Python 3, such as [Python 3.5](https://www.python.org/download/releases/3.5.1/).
    However, there are some key differences between the major versions, and in a strict
    sense the languages are incompatible. We’ll be using Python 3.5 for this book,
    but we’ll point out key differences with Python 2 as we go. It’s also very likely
    that, this being a book on Python fundamentals, everything we present will apply
    to future versions of Python 3, so don’t be afraid to try those as they become
    available.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Python语言有两个主要版本，*Python 2*是广泛部署的传统语言，*Python 3*是语言的现在和未来。许多Python代码在Python 2的最后一个版本（即[Python
    2.7](https://www.python.org/download/releases/2.7/)）和Python 3的最新版本之间可以无需修改地工作，比如[Python
    3.5](https://www.python.org/download/releases/3.5.1/)。然而，主要版本之间存在一些关键差异，严格意义上来说，这两种语言是不兼容的。我们将在本书中使用Python
    3.5，但在介绍过程中我们将指出与Python 2的主要差异。此外，很可能，作为一本关于Python基础知识的书，我们所介绍的一切都适用于未来版本的Python
    3，因此不要害怕在这些版本推出时尝试它们。
- en: Before we can start programming in Python we need to get hold of a Python environment.
    Python is a highly portable language and is available on all major operating systems.
    You will be able to work through this book on Windows, Mac or Linux, and the only
    major section where we diverge into platform specifics is coming right up — as
    we install Python 3\. As we cover the three platforms, feel free to skip over
    the sections which aren’t relevant for you.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用Python进行编程之前，我们需要获得一个Python环境。Python是一种高度可移植的语言，可在所有主要操作系统上使用。您将能够在Windows、Mac或Linux上阅读本书，并且我们只有在安装Python
    3时才会涉及到平台特定的主要部分。当我们涵盖这三个平台时，可以随意跳过对您不相关的部分。
- en: Windows
  id: totrans-5
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Windows
- en: For Windows you need to visit the [official Python website](http://python.org),
    and then head to the Download page by clicking the link on the left. For Windows
    you should choose one of the MSI installers depending on whether you’re running
    on a 32- or 64-bit platform.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于Windows，您需要访问[官方Python网站](http://python.org)，然后通过单击左侧的链接转到下载页面。对于Windows，您应该根据您的计算机是32位还是64位选择其中一个MSI安装程序。
- en: Download and run the installer.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并运行安装程序。
- en: In the installer, decide whether you only want to install Python for yourself,
    or for all users of your machine.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在安装程序中，决定您是只为自己安装Python，还是为计算机上的所有用户安装Python。
- en: Choose a location for the Python distribution. The default will be in `C:\Python35`
    in the root of the `C:` drive. We don’t recommended installing Python into `Program
    Files` because the virtualized file store used to isolate applications from each
    other in Windows Vista and later can interfere with easily installing third-party
    Python packages.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择Python分发的位置。默认位置将在`C:\Python35`中，位于`C:`驱动器的根目录下。我们不建议将Python安装到`Program Files`中，因为Windows
    Vista及更高版本中用于隔离应用程序的虚拟化文件存储可能会干扰轻松安装第三方Python包。
- en: On the *Customize Python* page of the wizard we recommend keeping the defaults,
    which use less than 40 MB of space.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在向导的*自定义Python*页面上，我们建议保持默认设置，这将使用不到40MB的空间。
- en: In addition to installing the Python runtime and standard library, the installer
    will register various file types, such as `*.py` files, with the Python interpreter.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了安装Python运行时和标准库外，安装程序还将使用Python解释器注册各种文件类型，例如`*.py`文件。
- en: Once Python has been installed, you’ll need to add Python to your system `PATH`
    environment variable. To do this, from the Control Panel choose *System and Security*,
    then *System*. Another way to get here easily is to hold down your Windows key
    and press the Break key on your keyboard. Using the task pane on the left choose
    *Advanced System Settings* to open the *Advanced* tab of the *System Properties*
    dialog. Click *Environment variables* to open the child dialog.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python安装完成后，您需要将Python添加到系统的`PATH`环境变量中。要做到这一点，从控制面板中选择*系统和安全*，然后选择*系统*。另一种更简单的方法是按住Windows键，然后按键盘上的Break键。在左侧的任务窗格中选择*高级系统设置*以打开*系统属性*对话框的*高级*选项卡。单击*环境变量*以打开子对话框。
- en: If you have Administrator privileges you should be able to add the paths `C:\Python35`
    and `C:\Python35\Scripts` to the semicolon separated list of entries associated
    with the `PATH` system variable. If not, you should be able to create, or append
    to, a `PATH` variable specific to your user containing the same value.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您拥有管理员权限，您应该能够将路径`C:\Python35`和`C:\Python35\Scripts`添加到与`PATH`系统变量关联的分号分隔的条目列表中。如果没有，您应该能够创建或附加到特定于您的用户的`PATH`变量，其中包含相同的值。
- en: 'Now open a *new* console window — either Powershell or cmd will work fine —
    and verify that you can run python from the command line:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开一个*新*的控制台窗口——Powershell或cmd都可以——并验证您是否可以从命令行运行python：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Welcome to Python!**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**欢迎使用Python！**'
- en: The triple arrow prompt shows you that Python is waiting for your input.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 三角箭头提示您Python正在等待您的输入。
- en: At this point you might want to skip forward whilst we show how to install Python
    on Mac and Linux.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您可能想要跳过，同时我们展示如何在Mac和Linux上安装Python。
- en: macOS
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: macOS
- en: For macOS you need to visit the official Python website at [http://python.org](http://python.org).
    Head to the Download page by clicking the link on the left. On the Download page,
    find the macOS installer matching your version of macOS and click the link to
    download it.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于macOS，您需要访问官方Python网站[http://python.org](http://python.org)。点击左侧的链接进入下载页面。在下载页面上，找到与您的macOS版本匹配的macOS安装程序，并单击链接下载它。
- en: A DMG Disk Image file downloads, which you open from your Downloads stack or
    from the Finder.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个DMG磁盘映像文件将被下载，您可以从下载堆栈或Finder中打开它。
- en: In the Finder window that opens you will see the file `Python.mpkg` multipackage
    installer file. Use the “secondary” click action to open the context menu for
    that file. From that menu, select “Open”.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开的Finder窗口中，您将看到文件`Python.mpkg`多包安装程序文件。使用“次要”点击操作打开该文件的上下文菜单。从该菜单中，选择“打开”。
- en: On some versions of macOS you will now be told that the file is from an unidentified
    developer. Press the “Open” button on this dialog to continue with the installation.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在某些版本的macOS上，您现在可能会收到文件来自未知开发者的通知。按下此对话框上的“打开”按钮以继续安装。
- en: You are now in the Python installer program. Follow the directions, clicking
    through the wizard.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在在Python安装程序中。按照说明，通过向导进行点击。
- en: There is no need to customize the install, and you should keep the standard
    settings. When it’s available, click the “Install” button to install Python. You
    may be asked for your password to authorize the installation. Once the installation
    completes click “Close” to close the installer.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无需定制安装，并且应保持标准设置。当可用时，单击“安装”按钮安装Python。您可能会被要求输入密码以授权安装。安装完成后，单击“关闭”以关闭安装程序。
- en: 'Now that Python 3 is installed, open a terminal window and verify that you
    can run Python 3 from the command line:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在Python 3已安装，请打开一个终端窗口并验证您是否可以从命令行运行Python 3：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Welcome to Python!**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**欢迎使用Python！**'
- en: The triple arrow prompt shows that Python is waiting for your input.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 三重箭头提示显示Python正在等待您的输入。
- en: Linux
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Linux
- en: To install Python on Linux you will want to use your system’s package manager.
    We’ll show how to install Python on a recent version of Ubuntu, but the process
    is very similar on most other modern Linux distributions.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在Linux上安装Python，您需要使用系统的软件包管理器。我们将展示如何在最新版本的Ubuntu上安装Python，但在大多数其他现代Linux发行版上，该过程非常相似。
- en: On Ubuntu, first start the “Ubuntu Software Center”. This can usually be run
    by clicking on it’s icon in the launcher. Alternatively, you can run it from the
    dashboard by searching on “Ubuntu Software Center” and clicking the selection.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Ubuntu上，首先启动“Ubuntu软件中心”。通常可以通过单击启动器中的图标来运行。或者，您可以在仪表板上搜索“Ubuntu软件中心”并单击选择来运行它。
- en: Once you’re in the software center, enter the search term “python 3.5” in the
    search bar in the upper right-hand corner and press return.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦进入软件中心，在右上角的搜索栏中输入搜索词“python 3.5”并按回车键。
- en: One of the results you’ll get will say “Python (v3.5)” with “Python Interpreter
    (v3.5)” in smaller type beneath it. Select this entry and click the “Install”
    button that appears.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将获得一个结果，上面写着“Python（v3.5）”，下面以较小的字体写着“Python解释器（v3.5）”。选择此条目并单击出现的“安装”按钮。
- en: You may need to enter your password to install the software at this point.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时可能需要输入密码来安装软件。
- en: You should now see a progress indicator appear, which will disappear when installation
    is complete.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您应该看到一个进度指示器出现，安装完成后将消失。
- en: 'Open a terminal (using `Ctrl-Alt-T`) and verify that you can run Python 3.5
    from the command line:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端（使用`Ctrl-Alt-T`）并验证您是否可以从命令行运行Python 3.5：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Welcome to Python!**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**欢迎使用Python！**'
- en: The triple arrow prompt shows you that Python is waiting for your input.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 三重箭头提示显示Python正在等待您的输入。
- en: Starting Python command line REPL
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动Python命令行REPL
- en: Now that Python is installed and running, you can immediately start using it.
    This is a good way to get to know the language, as well as a useful tool for experimentation
    and quick testing during normal development.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Python已安装并运行，您可以立即开始使用它。这是了解语言的好方法，也是正常开发过程中进行实验和快速测试的有用工具。
- en: This Python command line environment is a *Read-Eval-Print-Loop*. Python will
    **READ** whatever input we type in, **EVAL**uate it, **PRINT** the result and
    then **LOOP** back to the beginning. You’ll often hear it referred to by the acronymn
    “REPL”.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Python命令行环境是一个*读取-求值-打印-循环*。Python将**读取**我们输入的任何内容，**求值**它，**打印**结果，然后**循环**回到开始。您经常会听到它被缩写为“REPL”。
- en: When started, the REPL will print some information about the version of Python
    you’re running, and then it will give you a triple-arrow prompt. This prompt tells
    you that Python is waiting for you to type something.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 启动时，REPL将打印有关您正在运行的Python版本的一些信息，然后会给出一个三重箭头提示。此提示告诉您Python正在等待您输入。
- en: 'Within an interactive Python session you can enter fragments of Python programs
    and see instant results. Let’s start with some simple arithmetic:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在交互式Python会话中，您可以输入Python程序的片段并立即看到结果。让我们从一些简单的算术开始：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, Python reads our input, evaluates it, prints the result, and
    loops around to do the same again.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，Python读取我们的输入，对其进行求值，打印结果，并循环执行相同的操作。
- en: 'We can assign to variables in the REPL:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在REPL中为变量赋值：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'print their contents by typing their name:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入它们的名称打印它们的内容：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'and refer to them in expressions:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 并在表达式中引用它们：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Within the REPL you can use the special underscore variable to refer to the
    most recently printed value, this being one of very few obscure shortcuts in Python:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在REPL中，您可以使用特殊的下划线变量来引用最近打印的值，这是Python中非常少数的晦涩快捷方式之一：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Or you can use the special underscore variable in an expression:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可以在表达式中使用特殊的下划线变量：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that not all statements have a return value. When we assigned 5 to `x`
    there was no return value, only the side-effect of bringing the variable `x` into
    being. Other statements have more visible side-effects.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，并非所有语句都有返回值。当我们将5赋给`x`时，没有返回值，只有将变量`x`带入的副作用。其他语句具有更明显的副作用。
- en: 'Try:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You’ll see that Python immediately evaluates and executes this command, printing
    the string “Hello, Python” and returning you to another prompt. It’s important
    to understand that the response here is not the result of the expression evaluated
    and displayed by the REPL, but is a side-effect of the `print()` function.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现Python立即评估并执行此命令，打印字符串“Hello, Python”，然后返回到另一个提示符。重要的是要理解，这里的响应不是由REPL评估和显示的表达式结果，而是`print()`函数的副作用。
- en: Leaving the REPL
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 离开REPL
- en: At this point, we should show you how to exit the REPL and get back to your
    system shell prompt. We do this by sending the *end-of-file* control character
    to Python, although unfortunately the means of sending this character varies across
    platforms.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们应该向您展示如何退出REPL并返回到系统shell提示符。我们通过向Python发送*文件结束*控制字符来实现这一点，尽管不幸的是，发送此字符的方式在不同平台上有所不同。
- en: Windows
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Windows
- en: If you’re on Windows, press `Ctrl-Z` to exit.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Windows上，按`Ctrl-Z`退出。
- en: Unix
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Unix
- en: If you’re on Mac or Linux, press `Ctrl-D` to exit.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Mac或Linux上，按`Ctrl-D`退出。
- en: 'If you regularly switch between platforms and you accidentally press `Ctrl-Z`
    on a Unix-a-like system, you will inadvertently suspend the Python interpreter
    and return to your operating system shell. To reactivate Python by making it a
    foreground process again, run the `fg` command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您经常在不同平台之间切换，而在类Unix系统上意外按下`Ctrl-Z`，您将意外地挂起Python解释器并返回到操作系统shell。要通过再次使Python成为前台进程来重新激活Python，请运行`fg`命令：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'and press `Enter` and couple of times to get the triple arrow Python prompt
    back:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按`Enter`键几次，以获取三角形箭头Python提示符：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Code structure and significant indentation
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码结构和重要缩进
- en: 'Start your Python 3 interpreter:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Python 3解释器：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'on Windows or:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上或：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: on Mac or Linux.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac或Linux上。
- en: 'The control flow structures of Python, such as for-loops, while-loops, and
    if-statements, are all introduced by statements which are terminated by a colon,
    indicating that the body of the construct is to follow. For example, for-loops
    require a body, so if you enter:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Python的控制流结构，如for循环、while循环和if语句，都是由以冒号结尾的语句引入的，表示后面要跟着构造的主体。例如，for循环需要一个主体，所以如果您输入：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Python will present you with a prompt of three dots to request that you provide
    the body.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Python会向您显示三个点的提示，要求您提供主体。
- en: One distinctive (and sometimes controversial) aspect of Python is that leading
    whitespace is syntactically significant. What this means is that Python uses indentation
    levels, rather the braces used by other languages, to demarcate code blocks. By
    convention, contemporary Python code is indented by four spaces for each level.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Python一个与众不同的（有时是有争议的）方面是，前导空格在语法上是有意义的。这意味着Python使用缩进级别来标示代码块，而不是其他语言使用的大括号。按照惯例，当代Python代码每个级别缩进四个空格。
- en: 'So when Python present us with the three dot prompt, we provide those four
    spaces and a statement to form the body of the loop:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当Python向我们显示三个点的提示时，我们提供这四个空格和一个语句来形成循环的主体：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Our loop body will contain a second statement, so after pressing `Return` at
    the next three dot prompt we’ll enter another four spaces followed by a call to
    the built-in `print()` function:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的循环主体将包含第二个语句，因此在下一个三点提示符处按`Return`后，我们将输入另外四个空格，然后调用内置的`print()`函数：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To terminate our block, we must enter a blank line into the REPL:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要终止我们的块，我们必须在REPL中输入一个空行：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With the block complete, Python executes the pending code, printing out the
    multiples of 10 less than 50:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 块完成后，Python执行挂起的代码，打印出小于50的10的倍数：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '* * *'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Looking at at screenful of Python code, we can see how the indentation clearly
    matches — and in fact *must* match — the structure of the program.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 看着屏幕上的Python代码，我们可以看到缩进清晰地匹配 - 实际上*必须*匹配 - 程序的结构。
- en: '![Python source code](images/m01----significant_whitespace_code.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![Python源代码](images/m01----significant_whitespace_code.png)'
- en: Python source code
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Python源代码
- en: Even if we replace the code by gray lines, the structure of the program is clear.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们用灰色线代替代码，程序的结构也是清晰的。
- en: '![Grayed out code](images/m01----significant_whitespace_bars.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![灰色的代码](images/m01----significant_whitespace_bars.png)'
- en: Grayed out code
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 灰色的代码
- en: Each statement terminated by a colon starts a new line and introduces an additional
    level of indentation, which continues until a dedent restores the indentation
    to a previous level. Each level of indent is typically four spaces, although we’ll
    cover the rules in more detail in a moment.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 每个以冒号结尾的语句都会开始一个新行，并引入一个额外的缩进级别，直到取消缩进将缩进恢复到先前的级别。每个缩进级别通常是四个空格，尽管我们稍后会更详细地介绍规则。
- en: 'Python’s approach to significant whitespace has three great advantages:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Python对重要空白的处理方式有三个很大的优势：
- en: It forces developers to use a single level of indentation in a code-block. This
    is generally considered good practice in any language because it makes code much
    more readable.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它强制开发人员在代码块中使用单一级别的缩进。这通常被认为是任何语言中的良好实践，因为它使代码更易读。
- en: Code with significant whitespace doesn’t need to be cluttered with unnecessary
    braces, and you never need to have code-standard debates about where the braces
    should go. All code-blocks in Python code are easily identifiable and everyone
    writes them the same way.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 具有重要空白的代码不需要被不必要的大括号混乱，您也不需要就大括号应该放在哪里进行代码标准的辩论。Python代码中的所有代码块都很容易识别，每个人都以相同的方式编写它们。
- en: Significant whitespace requires that a consistent interpretation must be given
    to the structure of the code by the author, the Python runtime system and future
    maintainers who need to read the code. As a result you can never have code that
    contains a block from Python’s point of view, but which doesn’t look like it contains
    a block from a cursory human perspective.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重要的空白要求作者、Python运行时系统和未来需要阅读代码的维护者对代码的结构给出一致的解释。因此，你永远不会有从Python的角度来看包含一个代码块，但从肤浅的人类角度来看却不像包含代码块的代码。
- en: '* * *'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: The rules for Python indentation can seem complex, but they are quite straightforward
    in practice.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Python缩进的规则可能看起来复杂，但在实践中它们是非常简单的。
- en: The whitespace you use can be either spaces or tabs. The general consensus is
    that *spaces are preferable to tabs*, and *four spaces has become a standard in
    the Python community*.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你使用的空白可以是空格或制表符。一般的共识是*空格优于制表符*，*四个空格已经成为Python社区的标准*。
- en: One essential rule is **NEVER** to mix spaces and tabs. The Python interpreter
    will complain, and your colleagues will hunt you down.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个基本的规则是**绝对不要**混合使用空格和制表符。Python解释器会抱怨，你的同事会追捕你。
- en: You are allowed to use different amounts of indentation at different times if
    you wish. The essential rule is that *consecutive lines of code at the same indentation
    level are considered to be part of the same code block*.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以在不同的时间使用不同数量的缩进。基本规则是*相同缩进级别的连续代码行被认为是同一个代码块的一部分*。
- en: There are some exceptions to these rules, but they almost always have to do
    with improving code readability in other ways, for example by breaking up necessarily
    long statements over multiple lines.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些规则有一些例外，但它们几乎总是与以其他方式改善代码可读性有关，例如通过将必要的长语句分成多行。
- en: This rigorous approach to code formatting is “Programming as Guido intended
    it” or, perhaps more appropriately, “as Guido *indented* it”! A philosophy of
    placing a high value on code qualities such as readability gets to the very heart
    of Python culture, something we’ll take a short break to explore now.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这种严格的代码格式化方法是“Guido所期望的编程”或者更恰当地说是“Guido所*打算的编程”！重视代码质量，如可读性的哲学贯穿于Python文化的核心，现在我们将暂停一下来探讨一下。
- en: Python culture
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python文化
- en: Many programming languages are at the center of a cultural movement. They have
    their own communities, values, practices, and philosophy, and Python is no exception.
    The development of the Python language itself is managed through a series of documents
    called *Python Enhancement Proposals*, or *PEPs*. One of the PEPs, called PEP
    8, explains how you should format your code, and we follow its guidelines throughout
    this book. For example, it is PEP 8 which recommends that we use four spaces for
    indentation in new Python code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编程语言都处于文化运动的中心。它们有自己的社区、价值观、实践和哲学，Python也不例外。Python语言本身的发展是通过一系列称为*Python增强提案*或*PEPs*的文件来管理的。其中一份PEP，称为PEP
    8，解释了你应该如何格式化你的代码，我们在本书中遵循它的指导方针。例如，PEP 8建议我们在新的Python代码中使用四个空格进行缩进。
- en: 'Another of these PEPs, called PEP 20 is called “The Zen of Python”. It refers
    to 20 aphorisms describing the guiding principles of Python, only 19 of which
    have been written down. Conveniently, the Zen of Python is never further away
    than the nearest Python interpreter, as it can always be accessed from the REPL
    by typing:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个PEP，称为PEP 20，被称为“Python的禅宗”。它涉及到20条格言，描述了Python的指导原则，其中只有19条被写下来。方便的是，Python的禅宗从来都不会比最近的Python解释器更远，因为它总是可以通过在REPL中输入来访问：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Throughout this book we’ll be highlighting particular nuggets of wisdom from
    the Zen of Python in *moments of zen* to understand how they apply to what we
    have learned. As we’ve just introduced Python significant indentation, this is
    a good time for our first *moment of zen*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将突出显示Python禅宗中的特定智慧之处，以了解它们如何适用于我们所学到的知识。由于我们刚刚介绍了Python的重要缩进，现在是我们第一个禅宗时刻的好时机。
- en: '* * *'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '![](images/m01----zen-readability-counts.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](images/m01----zen-readability-counts.png)'
- en: In time, you’ll come to appreciate Python’s significant whitespace for the elegance
    it brings to *your* code, and the ease with which you can read *other’s*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，你会开始欣赏Python的重要空白，因为它为*你的*代码带来了优雅，以及你可以轻松阅读*他人的*代码。
- en: '* * *'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Importing standard library modules
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入标准库模块
- en: As mentioned earlier, Python comes with an extensive standard library, an aspect
    of Python that is often referred to as “batteries included”. The standard library
    is structured as *modules*, a topic we’ll discuss in depth later. What’s important
    at this stage is to know that you gain access to standard library modules by using
    the `import` keyword.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Python附带了一个庞大的标准库，这是Python的一个重要方面，通常被称为“电池包括在内”。标准库被组织为*模块*，这是我们将在后面深入讨论的一个主题。在这个阶段重要的是要知道，你可以通过使用`import`关键字来访问标准库模块。
- en: 'The basic form of importing a module is the `import` keyword followed by a
    space and the name of the module. For example, lets see how we can use the standard
    library’s `math` module to compute square roots. At the triple-arrow prompt we
    type:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 导入模块的基本形式是`import`关键字后跟一个空格和模块的名称。例如，让我们看看如何使用标准库的`math`模块来计算平方根。在三角箭头提示下，我们输入：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Since `import` is a statement which doesn’t return a value, Python doesn’t
    print anything if the import succeeds, and we’re immediately returned to the prompt.
    We can access the contents of the imported module by using the name of the module,
    followed by a dot, followed by the name of the attribute in the module that you
    need. Like many object oriented languages the dot operator is used to drill down
    into object structures. Being expert Pythonistas, we have inside knowledge that
    the `math` module contains a function called `sqrt()`. Let’s try to use it:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`import`是一个不返回值的语句，如果导入成功，Python不会打印任何内容，我们会立即返回到提示符。我们可以通过使用模块的名称，后跟一个点，后跟您需要的模块中的属性的名称，来访问导入模块的内容。与许多面向对象的语言一样，点运算符用于深入到对象结构中。作为Python专家，我们知道`math`模块包含一个名为`sqrt()`的函数。让我们尝试使用它：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Getting `help()`
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取`help()`
- en: But how can we find out what other functions are available in the `math` module?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们如何找出`math`模块中还有哪些其他函数可用？
- en: The REPL has a special function `help()` which can retrieve any embedded documentation
    from objects for which documentation has been provided, such as standard library
    modules.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: REPL有一个特殊的函数`help()`，它可以检索已提供文档的对象的任何嵌入式文档，例如标准库模块。
- en: 'To get help, type “help” at the prompt:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取帮助，请在提示符处输入“help”：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We’ll leave you to explore the first form — for interactive help — in your
    own time. Here we’ll go for the second option and pass the `math` module as the
    object for which we want help:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将让您在自己的时间里探索第一种形式——交互式帮助。在这里，我们将选择第二个选项，并将`math`模块作为我们想要帮助的对象传递：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can use the space-bar to page through the help, and if you’re on Mac or
    Linux use the arrow keys to scroll up and down.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用空格键翻页帮助，如果您使用的是Mac或Linux，则可以使用箭头键上下滚动。
- en: Browsing through the functions, you’ll can see that there’s a math function,
    `factorial`, for computing factorials. Press ‘q’ to exit the help browser, and
    return us to the Python REPL.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览函数时，您会发现有一个名为`factorial`的数学函数，用于计算阶乘。按“q”退出帮助浏览器，返回到Python REPL。
- en: 'Now practice using `help()` to request specific help on the `factorial` function:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在练习使用`help()`来请求`factorial`函数的特定帮助：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Press ‘q’ to return to the REPL.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 按“q”返回到REPL。
- en: 'Let’s use `factorial()` a bit. The function accepts an integer argument and
    return an integer value:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微使用一下`factorial()`。该函数接受一个整数参数并返回一个整数值：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice how we need to qualify the function name with the module namespace. This
    is generally good practice, as it makes it abundantly clear where the function
    is coming from. That said, it can result in code that is excessively verbose.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们需要使用模块命名空间来限定函数名。这通常是一个很好的做法，因为它清楚地表明了函数的来源。尽管如此，它可能导致代码过于冗长。
- en: Counting fruit with `math.factorial()`
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用`math.factorial()`计算水果的数量
- en: 'Let’s use factorials to compute how many ways there are to draw three fruit
    from a set of five fruit using some math we learned in school:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用阶乘来计算从五种水果中抽取三种水果的方式，使用我们在学校学到的一些数学：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This simple expression is quite verbose with all those references to the math
    module. The Python `import` statement has an alternative form that allows us to
    bring a specific function from a module into the current namespace by using the
    `from` keyword:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的表达式对于所有这些对math模块的引用来说相当冗长。Python的`import`语句有一种替代形式，允许我们使用`from`关键字将模块中的特定函数引入当前命名空间：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is a good improvement, but is still a little long-winded for such a simple
    expression.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的改进，但对于这样一个简单的表达式来说仍然有点冗长。
- en: 'A third form of the import statement allows us to rename the imported function.
    This can be useful for reasons of readability, or to avoid a namespace clash.
    Useful as it is, though, we recommend that this feature be used infrequently and
    judiciously:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 导入语句的第三种形式允许我们重命名导入的函数。这对于可读性或避免命名空间冲突是有用的。尽管它很有用，但我们建议尽量少地和审慎地使用这个功能：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Different types of numbers
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不同类型的数字
- en: 'Remember that when we used `factorial()` alone it returned an integer. But
    our more complex expression above for calculating combinations is producing a
    floating point number. This is because we’ve used `/`, Python’s floating-point
    division operator. Since we know our operation will only ever return integral
    results, we can improve our expression by using `//`, Python’s integer division
    operator:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当我们单独使用`factorial()`时，它返回一个整数。但是我们上面用于计算组合的更复杂的表达式产生了一个浮点数。这是因为我们使用了`/`，Python的浮点除法运算符。由于我们知道我们的操作只会返回整数结果，我们可以通过使用`//`，Python的整数除法运算符来改进我们的表达式：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'What’s notable is that many other programming languages would fail on the above
    expression for even moderate values of `n`. In most programming languages, regular
    garden variety signed integers can only store values less than ![2^{31}](images/leanpub_equation_0.png):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，许多其他编程语言在上面的表达式中会在`n`的中等值上失败。在大多数编程语言中，常规的有符号整数只能存储小于![2^{31}](images/leanpub_equation_0.png)的值：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'However, factorials grow so fast that the largest factorial you can fit into
    a 32-bit signed integer is 12! since 13! is too large:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，阶乘增长得如此之快，以至于您可以将最大的阶乘放入32位有符号整数中为12！因为13！太大了：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In most widely used programming languages you would need either more complex
    code or more sophisticated mathematics merely to compute how many ways there are
    to draw three fruits from a set of thirteen.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数广泛使用的编程语言中，您要么需要更复杂的代码，要么需要更复杂的数学来计算从13个水果中抽取三个水果的方式。
- en: 'Python encounters no such problems and can compute with arbitrarily large integers,
    limited only by the memory in your computer. To demonstrate this further, let’s
    try the larger problem of computing how many different pairs of fruit we can pick
    from 100 different fruits (assuming we can lay our hands on so many fruit!):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Python遇到这样的问题，并且可以计算任意大的整数，仅受计算机内存的限制。为了进一步证明这一点，让我们尝试计算从100种不同的水果中挑选多少种不同的水果对（假设我们可以拿到这么多水果！）：
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Just to emphasize how large the size of the first term of that expression is,
    calculate 100! on it’s own:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了强调一下表达式的第一项的大小有多大，计算100!：
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This number is vastly larger even than the number of atoms in the known universe,
    with an awful lot of digits. If, like us, you’re curious to know exactly how many
    digits, we can convert our integer to a text string and count the number of characters
    in it like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数字甚至比已知宇宙中的原子数量还要大得多，有很多数字。如果像我们一样，你很好奇到底有多少位数字，我们可以将整数转换为文本字符串，并像这样计算其中的字符数：
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: That’s definitely a lot of digits. And a lot of fruit. It also starts to show
    how Python’s different data types — in this case, integers, floating point numbers,
    and text strings — work together in natural ways. In the next section we’ll build
    on this experience and look at integers, strings, and other built-in types in
    more detail.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对是很多数字。还有很多水果。它也开始展示了Python的不同数据类型——在这种情况下，整数、浮点数和文本字符串——如何以自然的方式协同工作。在下一节中，我们将在此基础上继续深入研究整数、字符串和其他内置类型。
- en: 'Scalar data types: integers, floats, None and bool'
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标量数据类型：整数、浮点数、None和布尔值
- en: Python comes with a number of built-in datatypes. These include primitive scalar
    types like integers as well as collection types like dictionaries. These built-in
    types are powerful enough to be used alone for many programming needs, and they
    can be used as building blocks for creating more complex data types.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Python带有许多内置数据类型。这些包括像整数这样的原始标量类型，以及像字典这样的集合类型。这些内置类型足够强大，可以单独用于许多编程需求，并且它们可以用作创建更复杂数据类型的构建块。
- en: 'The basic built-in scalar types we’ll look at are:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要看的基本内置标量类型是：
- en: '`int` — signed, unlimited precision integers'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`——有符号、无限精度整数'
- en: '`float` — IEEE 754 floating-point numbers'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`——IEEE 754浮点数'
- en: '`None` — a special, singular null value'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`None`——特殊的、唯一的空值'
- en: '`bool` — true/false boolean values'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool`——true/false布尔值'
- en: For now we’ll just be looking at their basic details, showing their literal
    forms and how to create them.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只会看一下它们的基本细节，展示它们的文字形式以及如何创建它们。
- en: '`int`'
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`int`'
- en: We’ve already seen Python integers in action quite a lot. Python integers are
    signed and have, for all practical purposes, unlimited precision. This means that
    there is no pre-defined limit to the magnitude of the values they can hold.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到Python整数的很多用法。Python整数是有符号的，对于所有实际目的来说，具有无限精度。这意味着它们可以容纳的值的大小没有预定义的限制。
- en: 'Integer literals in Python are typically specified in decimal:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的整数字面量通常以十进制指定：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'They may also be specified in binary with a `0b` prefix:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也可以用`0b`前缀指定为二进制：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'octal, with a `0o` prefix:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 八进制，使用`0o`前缀：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'or hexadecimal with a `0x` prefix:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 或十六进制，使用`0x`前缀：
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can also construct integers by a call to the `int` constructor which can
    convert from other numeric types, such as floats, to integers:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过调用`int`构造函数来构造整数，该构造函数可以将其他数字类型（如浮点数）转换为整数：
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Note that, when using the `int` constructor, the rounding is always towards
    zero:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当使用`int`构造函数时，四舍五入总是朝着零的方向进行：
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can also convert strings to integers:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将字符串转换为整数：
- en: '[PRE41]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Be aware, though, that Python will throw an exception (much more on those later!)
    if the string doesn’t represent an integer.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 但要注意，如果字符串不表示整数，Python会抛出异常（稍后会更多地讨论这些！）。
- en: 'You can even supply an optional number base when converting from a string.
    For example, to convert from base 3 simply pass 3 as the second argument to the
    constructor:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在从字符串转换时，甚至可以提供一个可选的数字基数。例如，要从基数3转换，只需将3作为构造函数的第二个参数传递：
- en: '[PRE42]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: float
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 浮点数
- en: Floating point numbers are supported in Python by the `float` type. Python floats
    are implemented as [IEEE-754 double-precision floating point numbers](https://en.wikipedia.org/wiki/IEEE_floating_point)
    with 53 bits of binary precision. This is equivalent to between 15 and 16 significant
    digits in decimal.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Python通过`float`类型支持浮点数。Python浮点数实现为[IEEE-754双精度浮点数](https://en.wikipedia.org/wiki/IEEE_floating_point)，具有53位二进制精度。这相当于十进制中15到16个有效数字。
- en: 'Any literal number containing a decimal point is interpreted by Python as a
    `float`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 任何包含小数点的文字数字都会被Python解释为`float`：
- en: '[PRE43]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Scientific notation can be used, so for large numbers — such as ![3\times10^8](images/leanpub_equation_1.png),
    the approximate speed of light in metres per second — we can write:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 科学计数法可以使用，因此对于大数字——例如![3\times10^8](images/leanpub_equation_1.png)，即每秒米数的光速的近似值——我们可以写成：
- en: '[PRE44]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'and for small numbers like Planck’s constant ![1.616\times10^{ - 35}](images/leanpub_equation_2.png)
    we can enter:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像普朗克常数![1.616\times10^{ - 35}](images/leanpub_equation_2.png)这样的小数字，我们可以输入：
- en: '[PRE45]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Notice how Python automatically switches the display representation to the most
    readable form.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Python会自动切换显示表示形式为最可读的形式。
- en: 'As for integers, we can convert to floats from other numeric or string types
    using the `float` constructor. For example, the constructor can accept an `int`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 至于整数，我们可以使用`float`构造函数从其他数字或字符串类型转换为浮点数。例如，构造函数可以接受一个`int`：
- en: '[PRE46]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'or a string:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 或一个字符串：
- en: '[PRE47]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Special floating point values
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 特殊浮点值
- en: 'By passing certain strings to the `float` constructor, we can create the special
    floating point value `NaN` (short for **N**ot **a** **N**umber) and also positive
    and negative infinity:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将某些字符串传递给`float`构造函数，我们可以创建特殊的浮点值`NaN`（缩写为**N**ot **a** **N**umber），以及正无穷大和负无穷大：
- en: '[PRE48]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Promotion to float
  id: totrans-205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提升为浮点数
- en: 'The result of any calculation involving `int` and `float` is promoted to a
    `float`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 任何涉及`int`和`float`的计算结果都会提升为`float`：
- en: '[PRE49]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: You can read more about Python’s number types [in the Python documentation](http://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Python文档中了解更多关于Python数字类型的信息（http://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex）。
- en: '`None`'
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`None`'
- en: 'Python has a special null value called `None`, spelled with a capital “N”.
    `None` is frequently used to represent the absence of a value. The Python REPL
    never prints `None` results, so typing `None` into the REPL has no effect:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个特殊的空值叫做`None`，拼写为大写的“N”。`None`经常用来表示值的缺失。Python REPL从不打印`None`结果，因此在REPL中键入`None`没有任何效果：
- en: '[PRE50]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`None` can be bound to variable names just like any other object:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`None`可以绑定到变量名，就像任何其他对象一样：'
- en: '[PRE51]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'and we can test whether an object is `None` by using Python’s `is` operator:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Python的`is`运算符测试对象是否为`None`：
- en: '[PRE52]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We can see here that the response is `True`, which brings us conveniently on
    to the `bool` type.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这里的响应是`True`，这方便我们进入`bool`类型。
- en: bool
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: bool
- en: The `bool` type represents logical states and plays an important role in several
    of Python’s control flow structures, as we’ll see shortly.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`bool`类型表示逻辑状态，并在Python的几个控制流结构中扮演重要角色，我们很快就会看到。'
- en: 'As you would expect there are two bool values, `True` and `False`, both spelled
    with initial capitals:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所期望的那样，有两个bool值，`True`和`False`，都以大写字母开头：
- en: '[PRE53]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'There is also a `bool` constructor which can be used to convert from other
    types to `bool`. Let’s look at how it works. For `int`s, zero is considered “falsey”
    and all other values “truthy”:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个`bool`构造函数，可以用于将其他类型转换为`bool`。让我们看看它是如何工作的。对于`int`，零被认为是“falsey”，所有其他值都被认为是“truthy”：
- en: '[PRE54]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We see the same behavior with `float`s where only zero is considered “falsey”:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`float`中看到相同的行为，只有零被认为是“falsey”：
- en: '[PRE55]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'When converting from collections, such as strings or lists, only empty collections
    are treated as “falsey”. When converting from lists — which we’ll look at shortly
    — we see that only the empty list (shown here in it’s literal form of `[]`) evaluates
    to `False`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在从集合（例如字符串或列表）转换时，只有空集合被视为“falsey”。在从列表转换时，我们看到只有空列表（在这里以`[]`的文字形式显示）被评估为`False`：
- en: '[PRE56]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Similarly, with strings only the empty string, `""`, evaluates to `False` when
    passed to `bool`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，对于字符串，只有空字符串`""`在传递给`bool`时才会被评估为`False`：
- en: '[PRE57]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In particular, you cannot use the `bool` constructor to convert from string
    representations of `True` and `False`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，您不能使用`bool`构造函数来从`True`和`False`的字符串表示中进行转换：
- en: '[PRE58]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Since the string “False” is not empty, it will evaluate to `True`!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字符串“False”不为空，它将被评估为`True`！
- en: These conversions to `bool` are important because they are widely used in Python
    if-statements and while-loops which accept `bool` values in their condition.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这些转换为`bool`非常重要，因为它们在Python的if语句和while循环中被广泛使用，这些结构接受它们的条件中的`bool`值。
- en: Relational operators
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关系运算符
- en: Boolean values are commonly produced by Python’s relational operators which
    can be used for comparing objects.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值通常由Python的关系运算符产生，这些运算符可用于比较对象。
- en: Two of the most widely used relational operators are Python’s equality and inequality
    tests, which actually test for equivalence or inequivalence of values. That is,
    two objects are *equivalent* if one could use used in place of the other. We’ll
    learn more about the notion of object equivalence later in the book. For now,
    we’ll compare simple integers.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 两个最常用的关系运算符是Python的相等和不相等测试，实际上是测试值的等价或不等价。也就是说，如果一个对象可以用于替代另一个对象，则两个对象是*等价的。我们将在本书的后面学习更多关于对象等价的概念。现在，我们将比较简单的整数。
- en: 'Let’s start by assigning — or binding — a value to a variable `g`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先给变量`g`赋值或绑定一个值：
- en: '[PRE59]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We test for equality with `==`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`==`来测试相等：
- en: '[PRE60]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'or for inequality using `!=`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用`!=`进行不等式比较：
- en: '[PRE61]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Rich comparison operators
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 丰富的比较运算符
- en: 'We can also compare the order of quantities using the rich comparison operators.
    Use `<` to determine if the first argument is less than the second:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用丰富的比较运算符来比较数量的顺序。使用`<`来确定第一个参数是否小于第二个参数：
- en: '[PRE62]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Likewise, use `>` to determine if the first is greater than the second:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，使用`>`来确定第一个是否大于第二个：
- en: '[PRE63]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You can test less-than or equal-to with `<=`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`<=`来测试小于或等于：
- en: '[PRE64]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'and greater-than or equal-to with `>=`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 大于或等于使用`>=`：
- en: '[PRE65]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: If you have experience with relational operators from other languages, then
    Python’s operators are probably not surprising at all. Just remember that these
    operators are comparing equivalence, not identity, a distinction we’ll cover in
    detail in coming chapters.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对来自其他语言的关系运算符有经验，那么Python的运算符可能一点也不令人惊讶。只需记住这些运算符正在比较等价性，而不是身份，这是我们将在接下来的章节中详细介绍的区别。
- en: 'Control flow: if-statements and while-loops'
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制流：if语句和while循环
- en: 'Now that we’ve examined some basic built-in types, let’s look at two important
    control flow structures which depend on conversions to the `bool` type: if-statements
    and while-loops.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经检查了一些基本的内置类型，让我们看看两个依赖于`bool`类型转换的重要控制流结构：if语句和while循环。
- en: 'Conditional control flow: the if-statement'
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 条件控制流：if语句
- en: 'Conditional statements allow us to branch execution based on the value of an
    expression. The form of the statement is the `if` keyword, followed by an expression,
    terminated by a colon to introduce a new block. Let’s try this at the REPL:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句允许我们根据表达式的值来分支执行。语句的形式是`if`关键字，后跟一个表达式，以冒号结束以引入一个新的块。让我们在REPL中尝试一下：
- en: '[PRE66]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Remembering to indent four spaces within the block, we add some code to be
    executed if the condition is `True`, followed by a blank line to terminate the
    block:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 记住在块内缩进四个空格，我们添加一些代码，如果条件为`True`，则执行该代码，然后跟一个空行来终止该块：
- en: '[PRE67]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'At this point the block will execute, because self-evidently the condition
    is `True`. Conversely, if the condition is `False`, the code in the block does
    not execute:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，该块将被执行，因为显然条件是`True`。相反，如果条件是`False`，则块中的代码不会执行：
- en: '[PRE68]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The expression used with the if-statement will be converted to a `bool` just
    as if the `bool()` constructor had been used, so:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 与`bool()`构造函数一样，与if语句一起使用的表达式将被转换为`bool`，因此：
- en: '[PRE69]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'is exactly equivalent to:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 与以下内容完全等价：
- en: '[PRE70]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Thanks to this useful shorthand, explicit conversion to `bool` using the `bool`
    constructor is rarely used in Python.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种有用的简写，使用`bool`构造函数进行显式转换为`bool`在Python中很少使用。
- en: '`if...else`'
  id: totrans-266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`if...else`'
- en: 'The if-statement supports an optional “else” clause which goes in a block introduced
    by the `else` keyword (followed by a colon) which is indented to the same level
    as the `if` keyword. Let’s start by creating (but not finishing) an if-block:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: if语句支持一个可选的“else”子句，该子句放在由`else`关键字引入的块中（后跟一个冒号），并且缩进到与`if`关键字相同的级别。让我们首先创建（但不完成）一个if块：
- en: '[PRE71]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'To start the `else` block in this case, we just omit the indentation after
    the three dots:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下开始`else`块，我们只需在三个点之后省略缩进：
- en: '[PRE72]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '`if...elif...else`'
  id: totrans-271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`if...elif...else`'
- en: 'For multiple conditions you might be tempted to do something like this:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多个条件，您可能会尝试做这样的事情：
- en: '[PRE73]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Whenever you find yourself with an else-block containing a nested if-statement,
    like this, you should consider using Python’s `elif` keyword which is a combined
    `else-if`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您发现自己有一个包含嵌套if语句的else块时，就像这样，您应该考虑使用Python的`elif`关键字，它是一个组合的`else-if`。
- en: 'As the Zen of Python reminds us, “Flat is better than nested”:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python的禅宗中提醒我们，“平面比嵌套更好”：
- en: '[PRE74]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This version is altogether easier to read.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本读起来更容易。
- en: 'Conditional repetition: the while-loop'
  id: totrans-278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 条件重复：while循环
- en: 'Python has two types of loop: for-loops and while-loops. We’ve already briefly
    encountered for-loops back when we introduced significant whitespace, and we’ll
    return to them soon, but right now we’ll cover while-loops.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Python有两种类型的循环：for循环和while循环。我们已经在介绍重要的空格时简要遇到了for循环，并且很快会回到它们，但现在我们将介绍while循环。
- en: While-loops in Python are introduced by the `while` keyword, which is followed
    by a boolean expression. As with the condition for if-statements, the expression
    is implicitly converted to a boolean value as if it has been passed to the `bool()`
    constructor. The `while` statement is terminated by a colon because it introduces
    a new block.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，while循环由`while`关键字引入，后面跟着一个布尔表达式。与if语句的条件一样，表达式被隐式转换为布尔值，就好像它已经传递给了`bool()`构造函数。`while`语句以冒号结束，因为它引入了一个新的块。
- en: 'Let’s write a loop at the REPL which counts down from five to one. We’ll initialize
    a counter variable called `c` to five, and keep looping until we reach zero. Another
    new language feature here is the use of an augmented-assignment operator, `-=`,
    to subtract one from the value of the counter on each iteration. Similar augmented
    assignment operators exist for the other basic math operations such as addition
    and multiplication:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在REPL中编写一个循环，从五倒数到一。我们将初始化一个名为`c`的计数器变量，循环直到达到零为止。这里的另一个新语言特性是使用增强赋值运算符`-=`，在每次迭代中从计数器的值中减去一。类似的增强赋值运算符也适用于其他基本数学运算，如加法和乘法：
- en: '[PRE75]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Because the condition — or predicate — will be implicitly converted to `bool`,
    just as if a call to the `bool()` constructor were present, we could replace the
    above code with the following version:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 因为条件 - 或谓词 - 将被隐式转换为`bool`，就像存在对`bool()`构造函数的调用一样，我们可以用以下版本替换上面的代码：
- en: '[PRE76]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This works because the conversion of the integer value of `c` to `bool` results
    in `True` until we get to zero which converts to `False`. That said, to use this
    short form in this case might be described as un-Pythonic, because, referring
    back to the Zen of Python, explicit is better than implicit. We place higher value
    of the readability of the first form over the concision of the second form.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为将`c`的整数值转换为`bool`的结果为`True`，直到我们达到零，转换为`False`。也就是说，在这种情况下使用这种简短形式可能被描述为非Pythonic，因为根据Python的禅宗，显式优于隐式。我们更看重第一种形式的可读性，而不是第二种形式的简洁性。
- en: 'While-loops are often used in Python where an infinite loop is required. We
    achieve this by passing `True` as the predicate expression to the while construct:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，while循环经常用于需要无限循环的情况。我们通过将`True`作为谓词表达式传递给while结构来实现这一点：
- en: '[PRE77]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now you’re probably wondering how we get out of this loop and regain control
    of our REPL! Simply press `Ctrl-C`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可能想知道我们如何走出这个循环并重新控制我们的REPL！只需按`Ctrl-C`：
- en: '[PRE78]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Python intercepts the key stroke and raises a special exception which terminates
    the loop. We’ll be talking much more about what exceptions are, and how to use
    them, later in Chapter 6.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Python拦截按键并引发一个特殊的异常，该异常终止循环。我们将在第6章后面更详细地讨论异常是什么，以及如何使用它们。
- en: Exiting loops with `break`
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用`break`退出循环
- en: Many programming languages support a loop construct which places the predicate
    test at the end of the loop rather than at the beginning. For example, C, C++,
    C# and Java support the do-while construct. Other languages have repeat-until
    loops instead or as well. This is not the case in Python, where the idiom is to
    use `while True` together with an early exit, facilitated by the `break` statement.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编程语言支持一个循环结构，该结构将谓词测试放在循环的末尾而不是开头。例如，C、C++、C#和Java支持do-while结构。其他语言也有重复-直到循环。在Python中不是这种情况，Python的习惯用法是使用`while
    True`以及通过`break`语句实现早期退出。
- en: The `break` statement jumps out of the loop — and only the innermost loop if
    severals loops have been nested — continuing execution immediately after the loop
    body.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`语句跳出循环 - 如果有多个循环被嵌套，只跳出最内层的循环 - 并在循环体之后立即继续执行。'
- en: 'Let’s look at an example of `break`, introducing a few other Python features
    along the way, and examine it line-by-line:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个`break`的例子，一路上介绍一些其他Python特性，并逐行检查它：
- en: '[PRE79]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We start with a `while True:` for an infinite loop. On the first statement of
    the while block we use the built-in `input()` function to request a string from
    the user. We assign that string to a variable called `response`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`while True:`开始一个无限循环。在while块的第一条语句中，我们使用内置的`input()`函数从用户那里请求一个字符串。我们将该字符串赋给一个名为`response`的变量。
- en: We now use an if-statement to test whether the value provided is divisible by
    seven. We convert the response string to an integer using the `int()` constructor
    and then use the modulus operator, `%`, to divide by seven and give the remainder.
    If the remainder is equal to zero, the response was divisible by seven, and we
    enter the body of the if-block.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用if语句来测试提供的值是否能被七整除。我们使用`int()`构造函数将响应字符串转换为整数，然后使用取模运算符`%`来除以七并给出余数。如果余数等于零，则响应可以被七整除，我们进入if块的主体。
- en: Within the if-block, now two levels of indentation deep, we start with eight
    spaces and use the `break` keyword. `break` terminates the inner-most loop — in
    this case the while-loop — and causes execution to jump to the first statement
    after the loop.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在if块内，现在有两个缩进级别，我们从八个空格开始并使用`break`关键字。`break`终止最内层的循环 - 在本例中是while循环 - 并导致执行跳转到循环后的第一条语句。
- en: Here, that “statement” is the end of the program. We enter a blank line at the
    three dots prompt to close both the if-block and the while-block.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，“语句”是程序的结尾。我们在三个点的提示符下输入一个空行，以关闭if块和while块。
- en: 'Our loop will start executing, and will pause at the call to `input()` waiting
    for us to enter a number. Let’s try a few:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的循环将开始执行，并将在调用`input()`时暂停，等待我们输入一个数字。让我们试试几个：
- en: '[PRE80]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: As soon as we enter a number divisible by seven the predicate becomes `True`,
    we enter the if-block, and then we literally break out of the loop to the end
    of program, returning us to the REPL prompt.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们输入一个可以被七整除的数字，谓词就变为`True`，我们进入if块，然后我们真正地跳出循环到程序的末尾，返回到REPL提示符。
- en: Summary
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: Starting out with Python
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Python开始
- en: Obtaining and installing Python 3
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取和安装Python 3
- en: Starting the Read-Eval-Print-Loop or REPL
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始读取-求值-打印循环或REPL
- en: Simple arithmetic
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的算术
- en: Creating variables by binding objects to names
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将对象绑定到名称创建变量
- en: Printing with the built-in `print()` function
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内置的`print()`函数打印
- en: Exiting the REPL with `Ctrl-Z` (Windows) or `Ctrl-D` (Unix)
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Ctrl-Z`（Windows）或`Ctrl-D`（Unix）退出REPL
- en: Being Pythonic
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成为Pythonic
- en: Significant indentation
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重要的缩进
- en: PEP 8 - The Style Guide for Python Code
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PEP 8 - Python代码风格指南
- en: PEP 20 - The Zen of Python
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PEP 20 - Python之禅
- en: Importing modules with the import statement in various forms
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以各种形式使用import语句导入模块
- en: Finding and browsing `help()`
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找和浏览`help()`
- en: Basic types and control flow
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本类型和控制流
- en: '`int`s, `float`s, `None`, and `bool`, plus conversions between them'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`，`float`，`None`和`bool`，以及它们之间的转换'
- en: Relational operators for equality and ordering tests
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于相等性和排序测试的关系运算符
- en: if-statements with `else` and `elif` blocks
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有`else`和`elif`块的if语句
- en: while-loops with implicit conversion to `bool`
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有隐式转换为`bool`的while循环
- en: Interrupting infinite loops with `Ctrl-C`
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Ctrl-C`中断无限循环
- en: Breaking out of loops with `break`
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`break`跳出循环
- en: Requesting text from the user with `input()`
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`input()`从用户那里请求文本
- en: Augmented assignment operators
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强赋值运算符
