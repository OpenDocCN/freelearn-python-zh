- en: Chapter 3. Iterating and Making Decisions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章。迭代和决策
- en: '|   | *"Insanity: doing the same thing over and over again and expecting different
    results."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *"Insanity: doing the same thing over and over again and expecting different
    results."* |   |'
- en: '|   | --*Albert Einstein* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*阿尔伯特·爱因斯坦* |'
- en: In the previous chapter, we've seen Python built-in data types. Now that you're
    familiar with data in its many forms and shapes, it's time to start looking at
    how a program can use it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了 Python 的内置数据类型。现在你已经熟悉了各种形式和形状的数据，是时候开始了解程序如何使用它了。
- en: 'According to Wikipedia:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 根据维基百科：
- en: '*In computer science, control flow (or alternatively, flow of control) refers
    to the specification of the order in which the individual statements, instructions
    or function calls of an imperative program are executed or evaluated.*'
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*在计算机科学中，控制流（或称为控制流程）指的是指定 imperative 程序中各个语句、指令或函数调用的执行或评估的顺序*。'
- en: 'In order to control the flow of a program, we have two main weapons: **conditional
    programming** (also known as **branching**) and **looping**. We can use them in
    many different combinations and variations, but in this chapter, instead of going
    through all possible various forms of those two constructs in a "documentation"
    fashion, I''d rather give you the basics and then I''ll write a couple of small
    scripts with you. In the first one, we''ll see how to create a rudimentary prime
    number generator, while in the second one, we''ll see how to apply discounts to
    customers based on coupons. This way you should get a better feeling about how
    conditional programming and looping can be used.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制程序的流程，我们有两个主要的工具：**条件编程**（也称为**分支**）和**循环**。我们可以用许多不同的组合和变化来使用它们，但在这个章节中，我更愿意先给你讲解基础知识，然后我会和你一起编写几个小脚本。在第一个脚本中，我们将看到如何创建一个基本的素数生成器，而在第二个脚本中，我们将看到如何根据优惠券为客户应用折扣。这样你应该能更好地理解条件编程和循环是如何被使用的。
- en: Conditional programming
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件编程
- en: 'Conditional programming, or branching, is something you do every day, every
    moment. It''s about evaluating conditions: *if the light is green, then I can
    cross*, *if it''s raining, then I''m taking the umbrella*, and *if I''m late for
    work, then I''ll call my manager*.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 条件编程，或者说分支，是我们每天都在做、每时每刻都在做的事情。它涉及到条件的评估：*如果灯是绿色的，那么我可以过马路*，*如果下雨了，那么我会带伞*，*如果我上班迟到了，那么我会给经理打电话*。
- en: 'The main tool is the `if` statement, which comes in different forms and colors,
    but basically what it does is evaluate an expression and, based on the result,
    choose which part of the code to execute. As usual, let''s see an example:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 主要工具是`if`语句，它有不同的形式和颜色，但基本上它所做的就是评估一个表达式，并根据结果选择执行代码的哪个部分。像往常一样，让我们看一个例子：
- en: '`conditional.1.py`'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`conditional.1.py`'
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is possibly the simplest example: when fed to the `if` statement, `late`
    acts as a conditional expression, which is evaluated in a Boolean context (exactly
    like if we were calling `bool(late)`). If the result of the evaluation is `True`,
    then we enter the body of code immediately after the `if` statement. Notice that
    the `print` instruction is indented: this means it belongs to a scope defined
    by the `if` clause. Execution of this code yields:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是最简单的例子：当输入到`if`语句时，`late`作为一个条件表达式，在布尔上下文中被评估（就像我们调用`bool(late)`一样）。如果评估的结果是`True`，那么我们就立即进入`if`语句之后的代码块。注意，`print`指令是缩进的：这意味着它属于由`if`子句定义的作用域。执行此代码的结果是：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Since `late` is `True`, the `print` statement was executed. Let''s expand on
    this example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`late`是`True`，所以执行了`print`语句。让我们扩展这个例子：
- en: '`conditional.2.py`'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`conditional.2.py`'
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This time I set `late = False`, so when I execute the code, the result is different:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我设置了`late = False`，所以当我执行代码时，结果就不同了：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Depending on the result of evaluating the `late` expression, we can either enter
    block `#1` or block `#2`, *but not both*. Block `#1` is executed when `late` evaluates
    to `True`, while block `#2` is executed when `late` evaluates to `False`. Try
    assigning `False/True` values to the `late` name, and see how the output for this
    code changes accordingly.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 根据评估`late`表达式的结果，我们可以进入块`#1`或块`#2`，*但不能同时进入两个块*。当`late`评估为`True`时，执行块`#1`，而当`late`评估为`False`时，执行块`#2`。尝试将`False/True`值分配给`late`名称，并观察此代码的输出如何相应地改变。
- en: The preceding example also introduces the `else` clause, which becomes very
    handy when we want to provide an alternative set of instructions to be executed
    when an expression evaluates to `False` within an `if` clause. The else clause
    is optional, as it's evident by comparing the preceding two examples.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的例子还介绍了`else`子句，当我们在`if`子句中想要提供一个当表达式评估为`False`时的替代指令集时，它变得非常有用。`else`子句是可选的，正如通过比较前两个例子所显示的那样。
- en: 'A specialized else: elif'
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '特殊的`else`: `elif`'
- en: 'Sometimes all you need is to do something if a condition is met (simple `if`
    clause). Other times you need to provide an alternative, in case the condition
    is `False` (`if`/`else` clause), but there are situations where you may have more
    than two paths to choose from, so, since calling the manager (or not calling them)
    is kind of a binary type of example (either you call or you don''t), let''s change
    the type of example and keep expanding. This time we decide tax percentages. If
    my income is less then 10k, I won''t pay any taxes. If it is between 10k and 30k,
    I''ll pay 20% taxes. If it is between 30k and 100k, I''ll pay 35% taxes, and over
    100k, I''ll (gladly) pay 45% taxes. Let''s put this all down into beautiful Python
    code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，只要满足一个条件，你只需要做某件事情（简单的`if`子句）。其他时候，你可能需要提供一个替代方案，以防条件为`False`（`if`/`else`子句），但有时你可能需要从多个路径中选择，所以，既然联系经理（或不联系他们）是一种二进制类型的例子（要么联系要么不联系），那么让我们改变例子类型并继续扩展。这次我们决定税率。如果我的收入低于10k，我不会缴纳任何税费。如果它在10k到30k之间，我将缴纳20%的税费。如果它在30k到100k之间，我将缴纳35%的税费，超过100k，我将（乐意地）缴纳45%的税费。让我们把这些都写进漂亮的Python代码中：
- en: '`taxes.py`'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`taxes.py`'
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Executing the preceding code yields:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的代码会产生：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s go through the example line by line: we start by setting up the income
    value. In the example, my income is 15k. We enter the `if` clause. Notice that
    this time we also introduced the `elif` clause, which is a contraction for `else-if`,
    and it''s different from a bare `else` clause in that it also has its own condition.
    So, the `if` expression `income < 10000`, evaluates to `False`, therefore block
    `#1` is not executed. The control passes to the next condition evaluator: `elif
    income < 30000`. This one evaluates to `True`, therefore block `#2` is executed,
    and because of this, Python then resumes execution after the whole `if`/`elif`/`elif`/`else`
    clause (which we can just call `if` clause from now on). There is only one instruction
    after the `if` clause, the `print` call, which tells us I will pay 3k in taxes
    this year (*15k * 20%*). Notice that the order is mandatory: `if` comes first,
    then (optionally) as many `elif` as you need, and then (optionally) an `else`
    clause.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析这个例子：我们首先设置收入值。在这个例子中，我的收入是15k。我们进入`if`子句。注意，这次我们还引入了`elif`子句，它是`else-if`的缩写，它与裸`else`子句不同，因为它也有自己的条件。所以，`if`表达式`income
    < 10000`评估为`False`，因此块`#1`没有被执行。控制权传递到下一个条件评估器：`elif income < 30000`。这个评估为`True`，因此块`#2`被执行，因此Python随后在执行完整个`if`/`elif`/`elif`/`else`子句（从现在起我们可以简单地称之为`if`子句）之后继续执行。`if`子句之后只有一个指令，即`print`调用，它告诉我们今年我将缴纳3k的税费（*15k
    * 20%*）。注意，顺序是强制性的：`if`首先，然后（可选地）需要多少个`elif`，最后（可选地）一个`else`子句。
- en: Interesting, right? No matter how many lines of code you may have within each
    block, when one of the conditions evaluates to `True`, the associated block is
    executed and then execution resumes after the whole clause. If none of the conditions
    evaluates to `True` (for example, `income = 200000`), then the body of the `else`
    clause would be executed (block `#4`). This example expands our understanding
    of the behavior of the `else` clause. Its block of code is executed when none
    of the preceding `if`/`elif`/.../`elif` expressions has evaluated to `True`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣，对吧？无论每个代码块中有多少行代码，只要其中一个条件评估为`True`，相关的代码块就会被执行，然后执行继续到整个子句之后。如果没有一个条件评估为`True`（例如，`income
    = 200000`），那么`else`子句的主体就会被执行（块`#4`）。这个例子扩展了我们对于`else`子句行为的理解。它的代码块在先前的`if`/`elif`/.../`elif`表达式都没有评估为`True`时执行。
- en: Try to modify the value of `income` until you can comfortably execute all blocks
    at your will (one per execution, of course). And then try the **boundaries**.
    This is crucial, whenever you have conditions expressed as **equalities** or **inequalities**
    (`==`, `!=`, `<`, `>`, `<=`, `>=`), those numbers represent boundaries. It is
    essential to test boundaries thoroughly. Should I allow you to drive at 18 or
    17? Am I checking your age with `age < 18`, or `age <= 18`? You can't imagine
    how many times I had to fix subtle bugs that stemmed from using the wrong operator,
    so go ahead and experiment with the preceding code. Change some `<` to `<=` and
    set income to be one of the boundary values (10k, 30k, 100k) as well as any value
    in between. See how the result changes, get a good understanding of it before
    proceeding.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试修改`income`的值，直到你可以随意执行所有代码块（每次执行一个，当然）。然后尝试**边界值**。这非常重要，无论你将条件表达为**等式**或**不等式**（`==`、`!=`、`<`、`>`、`<=`、`>=`），这些数字都代表边界。彻底测试边界是至关重要的。我应该允许你在18岁或17岁时开车吗？我是用`age
    < 18`还是`age <= 18`来检查你的年龄？你无法想象我不得不多少次修复由使用错误的运算符引起的微妙错误，所以请继续实验前面的代码。将一些`<`改为`<=`，并将收入设置为边界值之一（10k、30k、100k）以及任何介于这些值之间的值。看看结果如何变化，在继续之前，对它有一个良好的理解。
- en: 'Before we move to the next topic, let''s see another example that shows us
    how to nest `if` clauses. Say your program encounters an error. If the alert system
    is the console, we print the error. If the alert system is an e-mail, we send
    it according to the severity of the error. If the alert system is anything other
    than console or e-mail, we don''t know what to do, therefore we do nothing. Let''s
    put this into code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们转到下一个主题之前，让我们看看另一个例子，这个例子展示了如何嵌套`if`语句。假设你的程序遇到一个错误。如果警报系统是控制台，我们打印错误。如果警报系统是电子邮件，我们根据错误的严重性发送它。如果警报系统不是控制台或电子邮件，我们不知道该怎么办，因此我们什么也不做。让我们把这个写成代码：
- en: '`errorsalert.py`'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`errorsalert.py`'
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding example is quite interesting, in its silliness. It shows us two
    nested `if` clauses (**outer** and **inner**). It also shows us the outer `if`
    clause doesn't have any `else`, while the inner one does. Notice how indentation
    is what allows us to nest one clause within another one.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子非常有趣，其荒谬之处在于它向我们展示了两个嵌套的`if`语句（**外层**和**内层**）。它还展示了外层的`if`语句没有`else`部分，而内层有。注意缩进是如何使我们能够在另一个语句内部嵌套一个语句的。
- en: If `alert_system == 'console'`, body `#1` is executed, and nothing else happens.
    On the other hand, if `alert_system == 'email'`, then we enter into another `if`
    clause, which we called inner. In the inner `if` clause, according to `error_severity`,
    we send an e-mail to either an admin, first-level support, or second-level support
    (blocks `#2`, `#3`, and `#4`). The `send_email` function is not defined in this
    example, therefore trying to run it would give you an error. In the source code
    of the book, which you can download from the website, I included a trick to redirect
    that call to a regular `print` function, just so you can experiment on the console
    without actually sending an e-mail. Try changing the values and see how it all
    works.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '如果`alert_system == ''console''`，则执行`body #1`，其他什么也不发生。另一方面，如果`alert_system
    == ''email''`，那么我们将进入另一个`if`语句，我们称之为内层。在内层`if`语句中，根据`error_severity`，我们将向管理员、一级支持或二级支持发送电子邮件（`blocks
    #2`、`#3`和`#4`）。在这个例子中，`send_email`函数没有定义，因此尝试运行它会给你一个错误。在本书的源代码中，你可以从网站上下载，我包括了一个技巧来将那个调用重定向到一个普通的`print`函数，这样你就可以在控制台上进行实验，而不必实际发送电子邮件。尝试更改值，看看它如何工作。'
- en: The ternary operator
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 三元运算符
- en: 'One last thing I would like to show you before moving on to the next subject,
    is the **ternary operator** or, in layman''s terms, the short version of an `if`/`else`
    clause. When the value of a name is to be assigned according to some condition,
    sometimes it''s easier and more readable to use the ternary operator instead of
    a proper `if` clause. In the following example, the two code blocks do exactly
    the same thing:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续下一个主题之前，我想向你展示最后一件事，就是**三元运算符**，或者用通俗的话说，是`if`/`else`语句的简短版本。当要根据某个条件为某个名称赋值时，有时使用三元运算符而不是正确的`if`语句更容易、更易读。在下面的例子中，两个代码块做了完全相同的事情：
- en: '`ternary.py`'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`ternary.py`'
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For simple cases like this, I find it very nice to be able to express that logic
    in one line instead of four. Remember, as a coder, you spend much more time reading
    code then writing it, so Python conciseness is invaluable.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种简单的情况，我发现能够在一行中表达这种逻辑而不是四行非常好。记住，作为一个程序员，你花在阅读代码上的时间比写作代码的时间要多得多，所以Python的简洁性是无价的。
- en: Are you clear on how the ternary operator works? Basically is `name = something
    if condition else something-else`. So `name` is assigned `something` if `condition`
    evaluates to `True`, and `something-else` if `condition` evaluates to `False`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你清楚三元运算符的工作原理吗？基本上是`name = something if condition else something-else`。所以，如果`condition`评估为`True`，则`name`被分配`something`，如果`condition`评估为`False`，则分配`something-else`。
- en: 'Now that you know everything about controlling the path of the code, let''s
    move on to the next subject: looping.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了控制代码路径的所有内容，让我们继续下一个主题：循环。
- en: Looping
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: If you have any experience with looping in other programming languages, you
    will find Python's way of looping a bit different. First of all, what is looping?
    **Looping** means being able to repeat the execution of a code block more than
    once, according to the loop parameters we're given. There are different looping
    constructs, which serve different purposes, and Python has distilled all of them
    down to just two, which you can use to achieve everything you need. These are
    the **for** and **while** statements.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在其他编程语言中有循环的经验，你会发现Python的循环方式略有不同。首先，什么是循环？**循环**意味着能够根据我们给出的循环参数多次重复执行代码块。有不同的循环结构，它们有不同的用途，Python将它们精简为只有两个，你可以使用它们来实现所需的一切。这些是**for**和**while**语句。
- en: While it's definitely possible to do everything you need using either of them,
    they serve different purposes and therefore they're usually used in different
    contexts. We'll explore this difference thoroughly through this chapter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然确实可以使用其中任何一个来完成所有需要的功能，但它们有不同的用途，因此通常在不同的上下文中使用。我们将通过本章彻底探讨这种差异。
- en: The for loop
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`for`循环'
- en: The `for` loop is used when looping over a sequence, like a list, tuple, or
    a collection of objects. Let's start with a simple example that is more like C++
    style, and then let's gradually see how to achieve the same results in Python
    (you'll love Python's syntax).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要遍历序列，如列表、元组或对象集合时，会使用`for`循环。让我们从一个类似于C++风格的简单示例开始，然后逐步了解如何在Python中实现相同的结果（你会喜欢Python的语法的）。
- en: '`simple.for.py`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`simple.for.py`'
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This simple snippet of code, when executed, prints all numbers from 0 to 4\.
    The `for` loop is fed the list `[0, 1, 2, 3, 4]` and at each iteration, `number`
    is given a value from the sequence (which is iterated sequentially, in order),
    then the body of the loop is executed (the print line). `number` changes at every
    iteration, according to which value is coming next from the sequence. When the
    sequence is exhausted, the `for` loop terminates, and the execution of the code
    resumes normally with the code after the loop.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这段简单的代码片段在执行时，会打印出从0到4的所有数字。`for`循环接收列表`[0, 1, 2, 3, 4]`，并在每次迭代中，`number`变量被赋予序列中的下一个值（按顺序迭代），然后执行循环体（打印行）。`number`变量在每次迭代中都会改变，根据下一个来自序列的值。当序列耗尽时，`for`循环结束，代码的正常执行继续进行循环之后的代码。
- en: Iterating over a range
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历范围
- en: 'Sometimes we need to iterate over a range of numbers, and it would be quite
    unpleasant to have to do so by hardcoding the list somewhere. In such cases, the
    `range` function comes to the rescue. Let''s see the equivalent of the previous
    snippet of code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们需要遍历一系列数字，如果必须通过硬编码列表来实现，那将会相当不愉快。在这种情况下，`range`函数就派上用场了。让我们看看之前代码片段的等效代码：
- en: '`simple.for.py`'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`simple.for.py`'
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The range function is used extensively in Python programs when it comes to
    creating sequences: you can call it by passing one value, which acts as `stop`
    (counting from 0), or you can pass two values (`start` and `stop`), or even three
    (`start`, `stop`, and `step`). Check out the following example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python程序中，当涉及到创建序列时，`range`函数被广泛使用：你可以通过传递一个值来调用它，这个值作为`stop`（从0开始计数），或者你可以传递两个值（`start`和`stop`），甚至三个值（`start`、`stop`和`step`）。查看以下示例：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For the moment, ignore that we need to wrap `range(...)` within a `list`. The
    `range` object is a little bit special, but in this case we''re just interested
    in understanding what are the values it will return to us. You see that the deal
    is the same with slicing: `start` is included, `stop` excluded, and optionally
    you can add a `step` parameter, which by default is 1.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，忽略我们需要在`list`中包装`range(...)`的事实。`range`对象有点特殊，但在这个例子中，我们只是想了解它将返回给我们哪些值。你看到的情况与切片相同：`start`包含在内，`stop`排除在外，你可以选择添加一个`step`参数，默认值为1。
- en: Try modifying the parameters of the `range()` call in our `simple.for.py` code
    and see what it prints, get comfortable with it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试修改我们`simple.for.py`代码中`range()`调用的参数，看看它打印了什么，熟悉一下。
- en: Iterating over a sequence
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代序列
- en: 'Now we have all the tools to iterate over a sequence, so let''s build on that
    example:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了迭代序列的所有工具，所以让我们在此基础上构建：
- en: '`simple.for.2.py`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`simple.for.2.py`'
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code adds a little bit of complexity to the game. Execution will
    show this result:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码给游戏增加了一点点复杂性。执行结果将显示：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s use the **inside-out** technique to break it down, ok? We start from
    the innermost part of what we''re trying to understand, and we expand outwards.
    So, `len(surnames)` is the length of the `surnames` list: `3`. Therefore, `range(len(surnames))`
    is actually transformed into `range(3)`. This gives us the range [0, 3), which
    is basically a sequence `(0, 1, 2)`. This means that the `for` loop will run three
    iterations. In the first one, `position` will take value `0`, while in the second
    one, it will take value `1`, and finally value `2` in the third and last iteration.
    What is `(0, 1, 2)`, if not the possible indexing positions for the `surnames`
    list? At position `0` we find `''Rivest''`, at position `1`, `''Shamir''`, and
    at position `2`, `''Adleman''`. If you are curious about what these three men
    created together, change `print(position, surnames[position])` to `print(surnames[position][0],
    end='''')` add a final `print()` outside of the loop, and run the code again.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用**内外反转**技术来分解它，好吗？我们从我们试图理解的内部最深处开始，然后向外扩展。所以，`len(surnames)`是`surnames`列表的长度：`3`。因此，`range(len(surnames))`实际上被转换成了`range(3)`。这给我们的是范围[0,
    3)，这基本上是一个序列`(0, 1, 2)`。这意味着`for`循环将运行三次迭代。在第一次迭代中，`position`将取值`0`，在第二次迭代中，它将取值`1`，最后在第三次和最后一次迭代中取值`2`。`(0,
    1, 2)`如果不是`surnames`列表的可能索引位置，那会是什么？在位置`0`我们找到`'Rivest'`，在位置`1`，`'Shamir'`，在位置`2`，`'Adleman'`。如果你对这三位男士共同创造了什么感到好奇，将`print(position,
    surnames[position])`改为`print(surnames[position][0], end='')`，并在循环外添加一个`print()`，然后再次运行代码。
- en: 'Now, this style of looping is actually much closer to languages like Java or
    C++. In Python it''s quite rare to see code like this. You can just iterate over
    any sequence or collection, so there is no need to get the list of positions and
    retrieve elements out of a sequence at each iteration. It''s expensive, needlessly
    expensive. Let''s change the example into a more Pythonic form:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这种循环风格实际上更接近Java或C++等语言。在Python中，很少看到这样的代码。你可以直接迭代任何序列或集合，因此没有必要在每次迭代中获取位置列表并从序列中检索元素。这是昂贵的，不必要的昂贵。让我们将示例改为更Python化的形式：
- en: '`simple.for.3.py`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`simple.for.3.py`'
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now that's something! It's practically English. The `for` loop can iterate over
    the `surnames` list, and it gives back each element in order at each interaction.
    Running this code will print the three surnames, one at a time. It's much easier
    to read, right?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候了！这几乎就像是英语。`for`循环可以迭代`surnames`列表，并在每次交互中按顺序返回每个元素。运行此代码将逐个打印出三个姓氏。它更容易阅读，对吧？
- en: 'What if you wanted to print the position as well though? Or what if you actually
    needed it for any reason? Should you go back to the `range(len(...))` form? No.
    You can use the `enumerate` built-in function, like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要打印位置怎么办？或者，如果你实际上需要它用于任何原因，你应该回到`range(len(...))`的形式吗？不。你可以使用内置的`enumerate`函数，如下所示：
- en: '`simple.for.4.py`'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`simple.for.4.py`'
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code is very interesting as well. Notice that enumerate gives back a 2-tuple
    `(position, surname)` at each iteration, but still, it's much more readable (and
    more efficient) than the `range(len(...))` example. You can call `enumerate` with
    a `start` parameter, like `enumerate(iterable, start)`, and it will start from
    `start`, rather than `0`. Just another little thing that shows you how much thought
    has been given in designing Python so that it makes your life easy.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码也非常有趣。注意，`enumerate`在每次迭代中返回一个2元组`(position, surname)`，但即便如此，它仍然比`range(len(...))`示例更易读（并且更高效）。你可以用`start`参数调用`enumerate`，例如`enumerate(iterable,
    start)`，它将从`start`开始，而不是从`0`开始。这只是另一个小细节，展示了在Python的设计中投入了多少思考，以便让生活变得更简单。
- en: Using a `for` loop it is possible to iterate over lists, tuples, and in general
    anything that in Python is called iterable. This is a very important concept,
    so let's talk about it a bit more.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`for`循环可以迭代列表、元组，以及Python中称为可迭代对象的一切。这是一个非常重要的概念，所以让我们多谈谈它。
- en: Iterators and iterables
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器和可迭代对象
- en: 'According to the Python documentation, an iterable is:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Python文档，一个可迭代对象是：
- en: '*"An object capable of returning its members one at a time. Examples of iterables
    include all sequence types (such as `list`, `str`, and tuple) and some non-sequence
    types like `dict`, `file` objects, and objects of any classes you define with
    an `__iter__()` or `__getitem__()` method. Iterables can be used in a `for` loop
    and in many other places where a sequence is needed (`zip()`, `map()`, ...). When
    an iterable object is passed as an argument to the built-in function `iter()`,
    it returns an iterator for the object. This iterator is good for one pass over
    the set of values. When using iterables, it is usually not necessary to call `iter()`
    or deal with iterator objects yourself. The `for` statement does that automatically
    for you, creating a temporary unnamed variable to hold the iterator for the duration
    of the loop."*'
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“一个能够一次返回其成员的对象。可迭代的例子包括所有序列类型（如 `list`、`str` 和 `tuple`）以及一些非序列类型，如 `dict`、`file`
    对象，以及任何具有 `__iter__()` 或 `__getitem__()` 方法的类定义的对象。可迭代的可以在 `for` 循环和许多其他需要序列的地方使用（`zip()`、`map()`
    等）。当一个可迭代对象作为参数传递给内置函数 `iter()` 时，它返回该对象的一个迭代器。这个迭代器适用于对值集进行一次遍历。在使用可迭代对象时，通常不需要调用
    `iter()` 或自己处理迭代器对象。`for` 语句会为你自动完成这些操作，创建一个临时未命名的变量来在循环期间持有迭代器。”*'
- en: 'Simply put, what happens when you write `for k in sequence: ... body ...`,
    is that the `for` loop asks `sequence` for the next element, it gets something
    back, it calls that something `k`, and then executes its body. Then, once again,
    the `for` loop asks `sequence` again for the next element, it calls it `k` again,
    and executes the body again, and so on and so forth, until the sequence is exhausted.
    Empty sequences will result in zero executions of the body.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '简单来说，当你编写 `for k in sequence: ... body ...` 时发生的情况是，`for` 循环会向 `sequence` 请求下一个元素，它得到一些东西，并将其称为
    `k`，然后执行其主体。然后，再次，`for` 循环再次向 `sequence` 请求下一个元素，再次将其称为 `k`，并再次执行主体，以此类推，直到序列耗尽。空序列将导致主体执行零次。'
- en: Some data structures, when iterated over, produce their elements in order, like
    lists, tuples, and strings, while some others don't, like sets and dictionaries.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数据结构在迭代时按顺序产生它们的元素，如列表、元组和字符串，而另一些则不会，如集合和字典。
- en: 'Python gives us the ability to iterate over iterables, using a type of object
    called **iterator**. According to the official documentation, an iterator is:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Python 给我们提供了使用称为 **迭代器** 的对象来迭代可迭代对象的能力。根据官方文档，迭代器是：
- en: '*"An object representing a stream of data. Repeated calls to the iterator''s
    `__next__()` method (or passing it to the built-in function `next()`) return successive
    items in the stream. When no more data are available a `StopIteration` exception
    is raised instead. At this point, the iterator object is exhausted and any further
    calls to its `__next__()` method just raise `StopIteration` again. Iterators are
    required to have an `__iter__()` method that returns the iterator object itself
    so every iterator is also iterable and may be used in most places where other
    iterables are accepted. One notable exception is code which attempts multiple
    iteration passes. A container object (such as a `list`) produces a fresh new iterator
    each time you pass it to the `iter()` function or use it in a `for` loop. Attempting
    this with an iterator will just return the same exhausted iterator object used
    in the previous iteration pass, making it appear like an empty container."*'
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“一个表示数据流的对象。对迭代器的 `__next__()` 方法（或将其传递给内置函数 `next()`）的重复调用将返回数据流中的连续项。当没有更多数据可用时，将引发
    `StopIteration` 异常。此时，迭代器对象已耗尽，对其 `__next__()` 方法的任何进一步调用都将再次引发 `StopIteration`。迭代器必须有一个
    `__iter__()` 方法，该方法返回迭代器对象本身，因此每个迭代器也是可迭代的，可以在接受其他可迭代对象的大多数地方使用。一个值得注意的例外是尝试多次迭代遍历的代码。容器对象（如
    `list`）每次你将其传递给 `iter()` 函数或用于 `for` 循环时，都会产生一个新的迭代器。尝试使用迭代器这样做只会返回在先前迭代遍历中使用的同一个耗尽的迭代器对象，使其看起来像一个空容器。”*'
- en: Don't worry if you don't fully understand all the preceding legalese, you will
    in due time. I put it here as a handy reference for the future.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对前面的法律术语不完全理解，不要担心，你会在适当的时候理解。我把它们放在这里，作为未来方便的参考。
- en: In practice, the whole iterable/iterator mechanism is somewhat hidden behind
    the code. Unless you need to code your own iterable or iterator for some reason,
    you won't have to worry about this too much. But it's very important to understand
    how Python handles this key aspect of control flow because it will shape the way
    you will write your code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，整个可迭代/迭代器机制在代码背后是有些隐藏的。除非你出于某种原因需要自己编写可迭代或迭代器，否则你不必太担心这个问题。但是，理解Python如何处理这个关键的控制流方面非常重要，因为它将塑造你编写代码的方式。
- en: Iterating over multiple sequences
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历多个序列
- en: Let's see another example of how to iterate over two sequences of the same length,
    in order to work on their respective elements in pairs. Say we have a list of
    people and a list of numbers representing the age of the people in the first list.
    We want to print a pair person/age on one line for all of them. Let's start with
    an example and let's refine it gradually.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个例子，说明如何迭代两个长度相同的序列，以便成对地处理它们的各自元素。比如说，我们有一个包含人的列表和一个表示第一个列表中人的年龄的数字列表。我们想要打印出所有人的姓名/年龄对。让我们从一个例子开始，然后逐步改进它。
- en: '`multiple.sequences.py`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiple.sequences.py`'
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'By now, this code should be pretty straightforward for you to understand. We
    need to iterate over the list of positions (0, 1, 2, 3) because we want to retrieve
    elements from two different lists. Executing it we get the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经能够理解这段代码了。我们需要遍历位置列表（0，1，2，3），因为我们想要从两个不同的列表中检索元素。执行它我们得到以下结果：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This code is both inefficient and not Pythonic. Inefficient because retrieving
    an element given the position can be an expensive operation, and we''re doing
    it from scratch at each iteration. The mail man doesn''t go back to the beginning
    of the road each time he delivers a letter, right? He moves from house to house.
    From one to the next one. Let''s try to make it better using enumerate:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码既低效又不符合Python风格。低效是因为给定位置检索元素可能是一个昂贵的操作，而且我们每次迭代都是从零开始做的。邮递员每次送信时不会回到路的起点，对吧？他是从一栋房子走到另一栋。让我们尝试使用enumerate来让它变得更好：
- en: '`multiple.sequences.enumerate.py`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiple.sequences.enumerate.py`'
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Better, but still not perfect. And still a bit ugly. We're iterating properly
    on `people`, but we're still fetching `age` using positional indexing, which we
    want to lose as well. Well, no worries, Python gives you the `zip` function, remember?
    Let's use it!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 更好，但仍然不完美。而且仍然有点丑。我们正确地迭代了`people`，但我们仍然使用位置索引来获取`age`，这是我们想要丢弃的。嗯，不用担心，Python给你提供了`zip`函数，记得吗？让我们来用它！
- en: '`multiple.sequences.zip.py`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiple.sequences.zip.py`'
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Ah! So much better! Once again, compare the preceding code with the first example
    and admire Python''s elegance. The reason I wanted to show this example is twofold.
    On the one hand, I wanted to give you an idea of how shorter the code in Python
    can be compared to other languages where the syntax doesn''t allow you to iterate
    over sequences or collections as easily. And on the other hand, and much more
    importantly, notice that when the `for` loop asks `zip(sequenceA, sequenceB)`
    for the next element, it gets back a `tuple`, not just a single object. It gets
    back a `tuple` with as many elements as the number of sequences we feed to the
    `zip` function. Let''s expand a little on the previous example in two ways: using
    explicit and implicit assignment:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 啊！好多了！再次比较前面的代码和第一个例子，欣赏一下Python的优雅。我想展示这个例子的原因有两个。一方面，我想让你了解Python的代码相比其他语言可以多么简短，在其他语言中，语法不允许你像在Python中那样轻松地对序列或集合进行迭代。另一方面，更重要的是，注意当`for`循环请求`zip(sequenceA,
    sequenceB)`的下一个元素时，它返回的是一个`tuple`，而不仅仅是一个单一的对象。它返回一个`tuple`，其中的元素数量与我们提供给`zip`函数的序列数量相同。让我们从两个方面对前面的例子进行扩展：使用显式和隐式赋值：
- en: '`multiple.sequences.explicit.py`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiple.sequences.explicit.py`'
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding code, we added the nationalities list. Now that we feed three
    sequences to the `zip` function, the for loop gets back a *3-tuple* at each iteration.
    Notice that the position of the elements in the tuple respects the position of
    the sequences in the `zip` call. Executing the code will yield the following result:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了国籍列表。现在我们向`zip`函数提供了三个序列，for循环在每次迭代时都会返回一个*3-tuple*。注意，元组中元素的位置与`zip`调用中序列的位置相匹配。执行代码将产生以下结果：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Sometimes, for reasons that may not be clear in a simple example like the preceding
    one, you may want to explode the tuple within the body of the `for` loop. If that
    is your desire, it's perfectly possible to do so.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，可能由于前面的简单示例中不明显的原因，你可能想在`for`循环体内部展开元组。如果你有这个愿望，这样做是完全可能的。
- en: '`multiple.sequences.implicit.py`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiple.sequences.implicit.py`'
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'It''s basically doing what the `for` loop does automatically for you, but in
    some cases you may want to do it yourself. Here, the 3-tuple `data` that comes
    from `zip(...)`, is exploded within the body of the `for` loop into three variables:
    `person`, `age`, and `nationality`.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 它基本上是在做`for`循环自动为你做的事情，但在某些情况下，你可能想自己来做。在这里，来自`zip(...)`的3元组`data`在`for`循环体内部展开成三个变量：`person`、`age`和`nationality`。
- en: The while loop
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`while`循环'
- en: In the preceding pages, we saw the `for` loop in action. It's incredibly useful
    when you need to loop over a sequence or a collection. The key point to keep in
    mind, when you need to be able to discriminate which looping construct to use,
    is that the `for` loop rocks when you have to iterate over a finite amount of
    elements. It can be a huge amount, but still, something that at some point ends.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的页面中，我们看到了`for`循环的实际应用。当你需要遍历一个序列或集合时，它非常有用。当你需要能够区分使用哪种循环结构时，需要记住的关键点是，当你需要遍历有限数量的元素时，`for`循环非常出色。它可以是非常大的数量，但仍然，在某一点上会结束。
- en: There are other cases though, when you just need to loop until some condition
    is satisfied, or even loop indefinitely until the application is stopped. Cases
    where we don't really have something to iterate on, and therefore the `for` loop
    would be a poor choice. But fear not, for these cases Python provides us with
    the `while` loop.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有其他情况，你可能只需要循环直到满足某个条件，或者无限循环直到应用程序停止。在这些情况下，我们实际上没有可以迭代的，因此`for`循环可能不是一个好的选择。但不要担心，对于这些情况，Python为我们提供了`while`循环。
- en: The `while` loop is similar to the `for` loop, in that they both loop and at
    each iteration they execute a body of instructions. What is different between
    them is that the `while` loop doesn't loop over a sequence (it can, but you have
    to manually write the logic and it wouldn't make any sense, you would just want
    to use a `for` loop), rather, it loops as long as a certain condition is satisfied.
    When the condition is no longer satisfied, the loop ends.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环与`for`循环类似，因为它们都循环，并且在每次迭代中执行一组指令。它们之间的不同之处在于，`while`循环不是遍历一个序列（它可以，但你需要手动编写逻辑，这不会有什么意义，你只会想使用`for`循环），而是只要满足某个条件就循环。当条件不再满足时，循环结束。'
- en: As usual, let's see an example which will clarify everything for us. We want
    to print the binary representation of a positive number. In order to do so, we
    repeatedly divide the number by two, collecting the remainder, and then produce
    the inverse of the list of remainders. Let me give you a small example using number
    6, which is 110 in binary.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，让我们看一个例子，这个例子将为我们澄清一切。我们想要打印一个正数的二进制表示。为了做到这一点，我们反复将数字除以2，收集余数，然后生成余数列表的逆序。让我给你一个使用数字6的小例子，它在二进制中表示为110。
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s write some code to calculate the binary representation for number 39:
    100111[2].'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码来计算数字39的二进制表示：100111[2]。
- en: '`binary.py`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`binary.py`'
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding code, I highlighted two things: `n > 0`, which is the condition
    to keep looping, and `remainders[::-1]` which is a nice and easy way to get the
    reversed version of a list (missing `start` and `end` parameters, `step = -1`,
    produces the same list, from `end` to `start`, in reverse order). We can make
    the code a little shorter (and more Pythonic), by using the `divmod` function,
    which is called with a number and a divisor, and returns a tuple with the result
    of the integer division and its remainder. For example, `divmod(13, 5)` would
    return `(2, 3)`, and indeed *5 * 2 + 3 = 13*.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我强调了两个要点：`n > 0`，这是保持循环的条件，以及`remainders[::-1]`，这是一个获取列表反转的好方法（缺少`start`和`end`参数，`step
    = -1`会产生相同的列表，从`end`到`start`，以相反的顺序）。我们可以通过使用`divmod`函数使代码更短（并且更Pythonic），该函数用一个数和一个除数调用，并返回一个包含整数除法结果及其余数的元组。例如，`divmod(13,
    5)`将返回`(2, 3)`，确实*5 * 2 + 3 = 13*。
- en: '`binary.2.py`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`binary.2.py`'
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding code, we have reassigned n to the result of the division by
    2, and the remainder, in one single line.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将`n`重新赋值为除以2的结果，以及余数，都在一行中完成。
- en: Notice that the condition in a `while` loop is a condition to continue looping.
    If it evaluates to `True`, then the body is executed and then another evaluation
    follows, and so on, until the condition evaluates to `False`. When that happens,
    the loop is exited immediately without executing its body.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`while`循环中的条件是一个继续循环的条件。如果它评估为`True`，则执行主体，然后进行另一次评估，依此类推，直到条件评估为`False`。当这种情况发生时，循环会立即退出，而不会执行其主体。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If the condition never evaluates to `False`, the loop becomes a so called **infinite
    loop**. Infinite loops are used for example when polling from network devices:
    you ask the socket if there is any data, you do something with it if there is
    any, then you sleep for a small amount of time, and then you ask the socket again,
    over and over again, without ever stopping.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件永远不会评估为`False`，循环就变成了所谓的**无限循环**。无限循环在例如从网络设备轮询时使用：你询问套接字是否有数据，如果有，你处理它，然后你睡一小会儿，然后你再次询问套接字，一次又一次，永不停止。
- en: Having the ability to loop over a condition, or to loop indefinitely, is the
    reason why the `for` loop alone is not enough, and therefore Python provides the
    `while` loop.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 能够根据条件循环或无限循环，是为什么仅仅`for`循环不足以满足需求，因此Python提供了`while`循环。
- en: Tip
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: By the way, if you need the binary representation of a number, checkout the
    `bin` function.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，如果你需要数字的二进制表示，可以查看`bin`函数。
- en: Just for fun, let's adapt one of the examples (`multiple.sequences.py`) using
    the while logic.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 只为了好玩，让我们使用while逻辑修改一个例子（`multiple.sequences.py`）。
- en: '`multiple.sequences.while.py`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiple.sequences.while.py`'
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code, I have highlighted the *initialization*, *condition*,
    and *update* of the variable `position`, which makes it possible to simulate the
    equivalent `for` loop code by handling the iteration variable manually. Everything
    that can be done with a `for` loop can also be done with a `while` loop, even
    though you can see there's a bit of boilerplate you have to go through in order
    to achieve the same result. The opposite is also true, but simulating a never
    ending `while` loop using a `for` loop requires some real trickery, so why would
    you do that? Use the right tool for the job, and 99.9% of the times you'll be
    fine.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我已经突出显示了变量`position`的*初始化*、*条件*和*更新*，这使得通过手动处理迭代变量来模拟等效的`for`循环代码成为可能。你可以用`for`循环完成的事情，也可以用`while`循环完成，尽管你可以看到为了达到相同的结果，你必须经历一些样板代码。相反的情况也是真实的，但是使用`for`循环模拟一个永不结束的`while`循环需要一些真正的技巧，所以你为什么要这样做呢？使用适合的工具，99.9%的情况下你会没事的。
- en: So, to recap, use a `for` loop when you need to iterate over one (or a combination
    of) iterable, and a `while` loop when you need to loop according to a condition
    being satisfied or not. If you keep in mind the difference between the two purposes,
    you will never choose the wrong looping construct.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结一下，当你需要遍历一个（或多个）可迭代对象时，使用`for`循环；当你需要根据条件是否满足来循环时，使用`while`循环。如果你记住这两个目的之间的区别，你就永远不会选择错误的循环结构。
- en: Let's now see how to alter the normal flow of a loop.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何改变循环的正常流程。
- en: The break and continue statements
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`break`和`continue`语句'
- en: According to the task at hand, sometimes you will need to alter the regular
    flow of a loop. You can either skip a single iteration (as many times you want),
    or you can break out of the loop entirely. A common use case for skipping iterations
    is for example when you're iterating over a list of items and you need to work
    on each of them only if some condition is verified. On the other hand, if you're
    iterating over a collection of items, and you have found one of them that satisfies
    some need you have, you may decide not to continue the loop entirely and therefore
    break out of it. There are countless possible scenarios, so it's better to see
    a couple of examples.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 根据当前任务，有时你可能需要改变循环的正常流程。你可以跳过单个迭代（多次你想跳过的次数），或者你可以完全跳出循环。跳过迭代的常见用例，例如当你遍历一个项目列表，并且只有当某些条件得到验证时，你才需要处理每个项目。另一方面，如果你正在遍历一个项目集合，并且你已经找到了满足你需求的一个项目，你可能会决定不继续整个循环，因此跳出它。可能存在无数种可能的场景，所以最好看看几个例子。
- en: Let's say you want to apply a 20% discount to all products in a basket list
    for those which have an expiration date of today. The way you achieve this is
    to use the **continue** statement, which tells the looping construct (`for` or
    `while`) to immediately stop execution of the body and go to the next iteration,
    if any. This example will take us a little deeper down the rabbit whole, so be
    ready to jump.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要对购物车列表中今天过期的所有产品应用20%的折扣。你实现这一点的办法是使用 **continue** 语句，它告诉循环结构（`for` 或 `while`）立即停止执行体并转到下一次迭代，如果有的话。这个例子将带我们深入到兔子洞中，所以请准备好跳跃。
- en: '`discount.py`'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`discount.py`'
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You see we start by importing the `date` and `timedelta` objects, then we set
    up our products. Those with sku `1` and `3` have an expiration date of `today`,
    which means we want to apply 20% discount on them. We loop over each `product`
    and we inspect the expiration date. If it is not (inequality operator, `!=`) `today`,
    we don't want to execute the rest of the body suite, so we `continue`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们首先导入 `date` 和 `timedelta` 对象，然后设置我们的产品。那些sku为 `1` 和 `3` 的产品有 `today`
    的过期日期，这意味着我们想要对它们应用20%的折扣。我们遍历每个 `product` 并检查过期日期。如果它不是（不等号操作符，`!=`）`today`，我们不想执行其余的代码块，所以使用
    `continue`。
- en: 'Notice that is not important where in the body suite you place the `continue`
    statement (you can even use it more than once). When you reach it, execution stops
    and goes back to the next iteration. If we run the `discount.py` module, this
    is the output:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`continue` 语句在代码块中的位置并不重要（你甚至可以使用它多次）。当你到达它时，执行停止并回到下一次迭代。如果我们运行 `discount.py`
    模块，这是输出结果：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Which shows you that the last two lines of the body haven't been executed for
    sku number 2.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明sku编号2的代码块的最后两行没有被执行。
- en: 'Let''s now see an example of breaking out of a loop. Say we want to tell if
    at least any of the elements in a list evaluates to `True` when fed to the `bool`
    function. Given that we need to know if there is at least one, when we find it
    we don''t need to keep scanning the list any further. In Python code, this translates
    to using the **break** statement. Let''s write this down into code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何从循环中退出的一个例子。假设我们想要判断列表中的至少一个元素在传递给 `bool` 函数时评估为 `True`。鉴于我们需要知道是否至少有一个，当我们找到它时，我们不需要继续扫描列表。在Python代码中，这相当于使用
    **break** 语句。让我们把这个写下来：
- en: '`any.py`'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`any.py`'
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The preceding code is such a common pattern in programming, you will see it
    a lot. When you inspect items this way, basically what you do is to set up a `flag`
    variable, then start the inspection. If you find one element that matches your
    criteria (in this example, that evaluates to `True`), then you update the flag
    and stop iterating. After iteration, you inspect the flag and take action accordingly.
    Execution yields:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是编程中非常常见的模式，你将经常看到它。当你这样检查项目时，基本上你做的是设置一个 `flag` 变量，然后开始检查。如果你找到一个符合你标准（在这个例子中，评估为
    `True`）的元素，那么你更新标志并停止迭代。迭代后，你检查标志并相应地采取行动。执行结果如下：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: See how execution stopped after `True` was found?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，在找到 `True` 后执行停止了吗？
- en: The `break` statement acts exactly like the `continue` one, in that it stops
    executing the body of the loop immediately, but also, prevents any other iteration
    to run, effectively breaking out of the loop.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`break` 语句的行为与 `continue` 语句完全相同，即它立即停止执行循环体，但同时也阻止任何其他迭代运行，有效地退出循环。'
- en: The `continue` and `break` statements can be used together with no limitation
    in their number, both in the `for` and `while` looping constructs.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue` 和 `break` 语句可以与 `for` 和 `while` 循环结构一起使用，数量没有限制。'
- en: Tip
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: By the way, there is no need to write code to detect if there is at least one
    element in a sequence that evaluates to `True`. Just check out the `any` built-in
    function.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，检测一个序列中是否至少有一个元素评估为 `True` 并不需要编写代码。只需查看内置的 `any` 函数即可。
- en: A special else clause
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个特殊的 `else` 子句
- en: One of the features I've seen only in the Python language is the ability to
    have `else` clauses after `while` and `for` loops. It's very rarely used, but
    it's definitely nice to have. In short, you can have an `else` suite after a `for`
    or `while` loop. If the loop ends normally, because of exhaustion of the iterator
    (`for` loop) or because the condition is finally not met (`while` loop), then
    the `else` suite (if present) is executed. In case execution is interrupted by
    a `break` statement, the `else` clause is not executed. Let's take an example
    of a `for` loop that iterates over a group of items, looking for one that would
    match some condition. In case we don't find at least one that satisfies the condition,
    we want to raise an **exception**. This means we want to arrest the regular execution
    of the program and signal that there was an error, or exception, that we cannot
    deal with. Exceptions will be the subject of [Chapter 7](ch07.html "Chapter 7. Testing,
    Profiling, and Dealing with Exceptions"), *Testing, Profiling, and Dealing with
    Exceptions*, so don't worry if you don't fully understand them now. Just bear
    in mind that they will alter the regular flow of the code. Let me now show you
    two examples that do exactly the same thing, but one of them is using the special
    `for` ... `else` syntax. Say that we want to find among a collection of people
    one that could drive a car.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我只在Python语言中看到的一个特性是能够在`while`和`for`循环之后有`else`子句。这很少被使用，但确实很好。简而言之，你可以在`for`或`while`循环之后有一个`else`子句。如果循环正常结束，因为迭代器耗尽（`for`循环）或者因为条件最终不满足（`while`循环），那么（如果存在）`else`子句将被执行。如果执行被`break`语句中断，则`else`子句不会执行。让我们举一个`for`循环的例子，它遍历一组项目，寻找符合某些条件的项目。如果我们找不到至少一个满足条件的项目，我们想要抛出一个**异常**。这意味着我们想要阻止程序的常规执行，并发出信号，表示出现了我们无法处理的错误或异常。异常将是[第7章](ch07.html
    "第7章。测试、分析和处理异常")的主题，*测试、分析和处理异常*，所以如果你现在不完全理解它们，不要担心。只需记住，它们将改变代码的常规流程。现在让我给你展示两个做同样事情的例子，其中一个使用了特殊的`for`
    ... `else`语法。假设我们想在人群中找到一个能开车的人。
- en: '`for.no.else.py`'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`for.no.else.py`'
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Notice the `flag` pattern again. We set driver to be `None`, then if we find
    one we update the `driver` flag, and then, at the end of the loop, we inspect
    it to see if one was found. I kind of have the feeling that those kids would drive
    a very metallic car, but anyway, notice that if a driver is not found, a `DriverException`
    is raised, signaling the program that execution cannot continue (we're lacking
    the driver).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意`flag`模式。我们将`driver`设置为`None`，然后如果我们找到它，我们更新`driver`标志，然后在循环结束时检查它是否被找到。我有一种感觉，那些孩子会开一辆非常金属的车，但无论如何，注意如果找不到司机，将抛出一个`DriverException`，向程序发出信号，表示无法继续执行（我们缺少司机）。
- en: 'The same functionality can be rewritten a bit more elegantly using the following
    code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的功能可以用以下代码以更优雅的方式重写：
- en: '`for.else.py`'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`for.else.py`'
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice that we aren't forced to use the `flag` pattern any more. The exception
    is raised as part of the `for` loop logic, which makes good sense because the
    `for` loop is checking on some condition. All we need is to set up a `driver`
    object in case we find one, because the rest of the code is going to use that
    information somewhere. Notice the code is shorter and more elegant, because the
    logic is now correctly grouped together where it belongs.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不再被迫使用`flag`模式。异常作为`for`循环逻辑的一部分被抛出，这很有意义，因为`for`循环正在检查某个条件。我们只需要设置一个`driver`对象，以防我们找到它，因为代码的其余部分将使用这些信息。注意代码变得更短、更优雅，因为逻辑现在被正确地组合在一起。
- en: Putting this all together
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将这些放在一起
- en: Now that you have seen all there is to see about conditionals and loops, it's
    time to spice things up a little, and see those two examples I anticipated at
    the beginning of this chapter. We'll mix and match here, so you can see how one
    can use all these concepts together. Let's start by writing some code to generate
    a list of prime numbers up to some limit. Please bear in mind that I'm going to
    write a very inefficient and rudimentary algorithm to detect primes. The important
    thing for you is to concentrate on those bits in the code that belong to this
    chapter's subject.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了关于条件和循环的所有内容，是时候让事情变得有趣一些，看看我在本章开头提到的两个例子。我们将混合使用，这样你可以看到如何将这些概念结合起来。让我们先编写一些代码来生成一个到某个限制的质数列表。请记住，我将编写一个非常低效和原始的算法来检测质数。对你来说，重要的是要专注于代码中属于本章主题的部分。
- en: Example 1 – a prime generator
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 1 – 一个素数生成器
- en: 'According to Wikipedia:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 根据维基百科：
- en: '*"A prime number (or a prime) is a natural number greater than 1 that has no
    positive divisors other than 1 and itself. A natural number greater than 1 that
    is not a prime number is called a composite number."*'
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"素数（或素数）是一个大于 1 的自然数，它除了 1 和它本身外没有其他正除数。一个大于 1 但不是素数的自然数称为合数。"*'
- en: Based on this definition, if we consider the first 10 natural numbers, we can
    see that 2, 3, 5, and 7 are primes, while 1, 4, 6, 8, 9, 10 are not. In order
    to have a computer tell you if a number *N* is prime, you can divide that number
    by all natural numbers in the range [2, *N*). If any of those divisions yields
    zero as a remainder, then the number is not a prime. Enough chatter, let's get
    down to business. I'll write two versions of this, the second of which will exploit
    the `for` ... `else` syntax.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个定义，如果我们考虑前 10 个自然数，我们可以看到 2、3、5 和 7 是素数，而 1、4、6、8、9、10 则不是。为了让计算机告诉你一个数
    *N* 是否是素数，你可以将这个数除以 [2, *N*) 范围内的所有自然数。如果这些除法中的任何一个产生了余数为零，那么这个数就不是素数。说够了，让我们开始工作。我会写两个版本，第二个版本将利用
    `for` ... `else` 语法。
- en: '`primes.py`'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`primes.py`'
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Lots of things to notice in the preceding code. First of all we set up an empty
    list `primes`, which will contain the primes at the end. The limit is 100, and
    you can see it's inclusive in the way we call `range()` in the outer loop. If
    we wrote `range(2, upto)` that would be [2, upto), right? Therefore `range(2,
    upto + 1)` gives us *[2, upto + 1) == [2, upto]*.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中有很多需要注意的地方。首先，我们设置了一个空列表 `primes`，它将包含最后的素数。限制是 100，你可以看到我们在外层循环中调用 `range()`
    的方式是包含的。如果我们写成 `range(2, upto)`，那么就是 [2, upto)，对吗？因此 `range(2, upto + 1)` 给我们
    *[2, upto + 1) == [2, upto]*。
- en: So, two `for` loops. In the outer one we loop over the candidate primes, that
    is, all natural numbers from 2 to `upto`. Inside each iteration of this outer
    loop we set up a flag (which is set to `True` at each iteration), and then start
    dividing the current `n` by all numbers from 2 to *n* – 1\. If we find a proper
    divisor for `n`, it means `n` is composite, and therefore we set the flag to `False`
    and break the loop. Notice that when we break the inner one, the outer one keeps
    on going normally. The reason why we break after having found a proper divisor
    for `n` is that we don't need any further information to be able to tell that
    `n` is not a prime.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，两个 `for` 循环。在外层循环中，我们遍历候选素数，即从 2 到 `upto` 的所有自然数。在每个外层循环的迭代中，我们设置一个标志（每个迭代都设置为
    `True`），然后开始将当前的 `n` 除以从 2 到 *n* – 1 的所有数字。如果我们找到了 `n` 的一个合适的除数，这意味着 `n` 是合数，因此我们将标志设置为
    `False` 并跳出循环。注意，当我们跳出内层循环时，外层循环会正常继续。我们找到 `n` 的一个合适的除数后跳出循环的原因是，我们不需要任何更多的信息就能判断
    `n` 不是素数。
- en: When we check on the `is_prime` flag, if it is still `True`, it means we couldn't
    find any number in [2, *n*) that is a proper divisor for `n`, therefore `n` is
    a prime. We append `n` to the `primes` list, and hop! Another iteration, until
    *n* equals 100.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检查 `is_prime` 标志时，如果它仍然是 `True`，这意味着我们在 [2, *n*) 范围内没有找到任何是 `n` 的合适除数的数字，因此
    `n` 是素数。我们将 `n` 添加到 `primes` 列表中，然后！另一个迭代，直到 *n* 等于 100。
- en: 'Running this code yields:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码会产生：
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Before we proceed, one question: of all iterations of the outer loop, one of
    them is different than all the others. Could you tell which one, and why? Think
    about it for a second, go back to the code and try to figure it out for yourself,
    and then keep reading on.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，有一个问题：在外层循环的所有迭代中，有一个与其他所有迭代不同。你能告诉我哪一个，为什么吗？想一下，回到代码中，试着自己找出答案，然后再继续阅读。
- en: 'Did you figure it out? If not, don''t feel bad, it''s perfectly normal. I asked
    you to do it as a small exercise because it''s what coders do all the time. The
    skill to understand what the code does by simply looking at it is something you
    build over time. It''s very important, so try to exercise it whenever you can.
    I''ll tell you the answer now: the iteration that behaves differently from all
    others is the first one. The reason is because in the first iteration, `n` is
    2\. Therefore the innermost `for` loop won''t even run, because it''s a `for`
    loop which iterates over `range(2, 2)`, and what is that if not [2, 2)? Try it
    out for yourself, write a simple `for` loop with that iterable, put a `print`
    in the body suite, and see if anything happens (it won''t...).'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你弄懂了吗？如果没有，别难过，这是完全正常的。我让你做这个小练习是因为这就是程序员一直做的事情。通过仅仅看代码就能理解代码的功能的技能是你在时间中逐渐培养出来的。这非常重要，所以尽量在可能的情况下练习它。我现在告诉你答案：表现与其他迭代不同的迭代是第一个。原因是第一个迭代中
    `n` 是 2。因此最内层的 `for` 循环甚至不会运行，因为它是一个迭代 `range(2, 2)` 的 `for` 循环，而这如果不是 [2, 2)
    又是什么呢？自己试试，写一个简单的 `for` 循环，用那个可迭代对象，在主体中放一个 `print`，看看是否会发生什么（不会...）。
- en: 'Now, from an algorithmic point of view this code is inefficient so let''s at
    least make it more beautiful:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从算法的角度来看，这段代码效率不高，所以至少让我们让它更美观一些：
- en: '`primes.else.py`'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`primes.else.py`'
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Much nicer, right? The `is_prime` flag is completely gone, and we append `n`
    to the `primes` list when we know the inner `for` loop hasn't encountered any
    `break` statements. See how the code looks cleaner and reads better?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 更好了，对吧？`is_prime` 标志已经完全消失，当我们知道内部 `for` 循环没有遇到任何 `break` 语句时，我们会将 `n` 添加到 `primes`
    列表中。看看代码看起来更整洁，读起来更好吗？
- en: Example 2 – applying discounts
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 2 – 应用折扣
- en: 'In this example, I want to show you a technique I like a lot. In many programming
    languages, other than the `if`/`elif`/`else` constructs, in whatever form or syntax
    they may come, you can find another statement, usually called `switch`/`case`,
    that in Python is missing. It is the equivalent of a cascade of `if`/`elif`/.../`elif`/else
    clauses, with a syntax similar to this (warning! JavaScript code!):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我想向你展示我非常喜欢的一种技术。在许多编程语言中，除了 `if`/`elif`/`else` 构造之外，无论它们以何种形式或语法出现，你都可以找到一个称为
    `switch`/`case` 的另一个语句，在 Python 中这是缺失的。它相当于一系列的 `if`/`elif`/.../`elif`/`else`
    子句，其语法类似于这样（警告！JavaScript 代码！）：
- en: '`switch.js`'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch.js`'
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the preceding code, we `switch` on a variable called `day_number`. This
    means we get its value and then we decide what case it fits in (if any). From
    1 to 5 there is a cascade, which means no matter the number, [1, 5] all go down
    to the bit of logic that sets `day` as `"Weekday"`. Then we have single cases
    for 0 and 6 and a `default` case to prevent errors, which alerts the system that
    `day_number` is not a valid day number, that is, not in [0, 6]. Python is perfectly
    capable of realizing such logic using `if`/`elif`/`else` statements:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们根据一个名为 `day_number` 的变量进行 `switch` 操作。这意味着我们得到它的值，然后我们决定它适合哪个情况（如果有的话）。从
    1 到 5 是一个级联，这意味着无论数字是什么，[1, 5] 都会下降到设置 `day` 为 `"Weekday"` 的逻辑部分。然后我们有针对 0 和 6
    的单个情况，以及一个 `default` 情况来防止错误，这会通知系统 `day_number` 不是一个有效的天数，也就是说，不在 [0, 6] 范围内。Python
    完全可以使用 `if`/`elif`/`else` 语句实现这样的逻辑：
- en: '`switch.py`'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch.py`'
- en: '[PRE36]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding code, we reproduce the same logic of the JavaScript snippet,
    in Python, using `if`/`elif`/`else` statements. I raised `ValueError` exception
    just as an example at the end, if `day_number` is not in [0, 6]. This is one possible
    way of translating the `switch`/`case` logic, but there is also another one, sometimes
    called dispatching, which I will show you in the last version of the next example.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 `if`/`elif`/`else` 语句在 Python 中重现了 JavaScript 片段的相同逻辑。我在最后仅仅作为一个例子抛出了
    `ValueError` 异常，如果 `day_number` 不在 [0, 6] 范围内。这是翻译 `switch`/`case` 逻辑的一种可能方式，但还有一种方式，有时被称为分派，我将在下一个示例的最后版本中向你展示。
- en: Tip
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: By the way, did you notice the first line of the previous snippet? Have you
    noticed that Python can make double (actually, even multiple) comparisons? It's
    just wonderful!
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便问一下，你注意到前面片段的第一行了吗？你注意到 Python 可以进行双重（实际上，甚至是多重的）比较吗？这真是太棒了！
- en: Let's start the new example by simply writing some code that assigns a discount
    to customers based on their coupon value. I'll keep the logic down to a minimum
    here, remember that all we really care about is conditionals and loops.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从编写一些代码开始新的示例，这些代码根据客户的优惠券价值给客户分配折扣。我会尽量简化这里的逻辑，记住我们真正关心的是条件和循环。
- en: '`coupons.py`'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`coupons.py`'
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We start by setting up some customers. They have an order total, a coupon code,
    and an id. I made up four different types of coupon, two are fixed and two are
    percentage based. You can see that in the `if`/`elif`/`else` cascade I apply the
    discount accordingly, and I set it as a `'discount'` key in the `customer` dict.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先设置一些客户。他们有一个订单总额、一个优惠券代码和一个ID。我编造了四种不同的优惠券类型，两种是固定的，两种是百分比基础的。您可以看到，在`if`/`elif`/`else`级联中，我相应地应用了折扣，并将其设置为`customer`字典中的`'discount'`键。
- en: At the end I just print out part of the data to see if my code is working properly.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我只是打印出部分数据来查看我的代码是否正常工作。
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This code is simple to understand, but all those clauses are kind of cluttering
    the logic. It''s not easy to see what''s going on at a first glance, and I don''t
    like it. In cases like this, you can exploit a dictionary to your advantage, like
    this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码很容易理解，但所有这些条款都使得逻辑显得有些杂乱。一开始看不太清楚发生了什么，我不喜欢这样。在这种情况下，您可以利用字典的优势，如下所示：
- en: '`coupons.dict.py`'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`coupons.dict.py`'
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Running the preceding code yields exactly the same result we had from the snippet
    before it. We spared two lines, but more importantly, we gained a lot in readability,
    as the body of the `for` loop now is just three lines long, and very easy to understand.
    The concept here is to use a dictionary as **dispatcher**. In other words, we
    try to fetch something from the dictionary based on a code (our `coupon_code`),
    and by using `dict.get(key, default)`, we make sure we also cater for when the
    `code` is not in the dictionary and we need a default value.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码会产生与之前代码片段完全相同的结果。我们节省了两行代码，但更重要的是，我们在可读性上取得了很大的进步，因为`for`循环的主体现在只有三行长，非常容易理解。这里的思路是使用一个字典作为**调度器**。换句话说，我们尝试根据一个代码（我们的`coupon_code`）从字典中获取一些内容，通过使用`dict.get(key,
    default)`，我们确保当`code`不在字典中且需要默认值时也能处理。
- en: Notice that I had to apply some very simple linear algebra in order to calculate
    the discount properly. Each discount has a percentage and fixed part in the dictionary,
    represented by a 2-tuple. By applying `percent * total + fixed`, we get the correct
    discount. When `percent` is `0`, the formula just gives the fixed amount, and
    it gives `percent * total` when fixed is `0`. Simple but effective.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我必须应用一些非常简单的线性代数来正确计算折扣。每个折扣在字典中都有一个百分比和固定部分，由一个二元组表示。通过应用`percent * total
    + fixed`，我们得到正确的折扣。当`percent`为`0`时，公式只给出固定金额，当固定为`0`时，它给出`percent * total`。简单但有效。
- en: This technique is important because it is also used in other contexts, with
    functions, where it actually becomes much more powerful than what we've seen in
    the preceding snippet. If it's not completely clear to you how it works, I suggest
    you to take your time and experiment with it. Change values and add print statements
    to see what's going on while the program is running.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术很重要，因为它还用于其他上下文中，比如函数，在那里它实际上比我们在前面的代码片段中看到的功能要强大得多。如果您对它的工作原理还不完全清楚，我建议您花点时间实验一下。改变值并添加打印语句，以查看程序运行时的状态。
- en: A quick peek at the itertools module
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速浏览`itertools`模块
- en: A chapter about iterables, iterators, conditional logic, and looping wouldn't
    be complete without spending a few words about the `itertools` module. If you
    are into iterating, this is a kind of heaven.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在关于可迭代对象、迭代器、条件逻辑和循环的章节中，如果不花点时间谈谈`itertools`模块，那就不是一个完整的章节。如果您喜欢迭代，这将是一个天堂。
- en: 'According to the Python official documentation, the `itertools` module is:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Python官方文档，`itertools`模块是：
- en: '*"A module which implements a number of iterator building blocks inspired by
    constructs from APL, Haskell, and SML. Each has been recast in a form suitable
    for Python. The module standardizes a core set of fast, memory efficient tools
    that are useful by themselves or in combination. Together, they form an "iterator
    algebra" making it possible to construct specialized tools succinctly and efficiently
    in pure Python."*'
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"一个模块，它实现了一系列由APL、Haskell和SML中的构造灵感的迭代器构建块。每个都已被重新塑造成适合Python的形式。该模块标准化了一组快速、内存高效的工具，这些工具本身或组合使用都很有用。它们共同形成了一个“迭代器代数”，使得在纯Python中简洁且高效地构建专用工具成为可能。"*'
- en: By no means do I have the room here to show you all the goodies you can find
    in this module, so I encourage you to go and check it out for yourself, I promise
    you'll enjoy it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我绝对没有足够的空间向您展示这个模块中您可以找到的所有好东西，所以我鼓励您自己去看看，我保证您会喜欢的。
- en: In a nutshell, it provides you with three broad categories of iterators. I will
    give you a very small example of one iterator taken from each one of them, just
    to make your mouth water a little.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，它为你提供了三种广泛的迭代器类别。我将给出一个例子，从每个类别中取一个迭代器，只是为了让你稍微有点兴趣。
- en: Infinite iterators
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无限迭代器
- en: Infinite iterators allow you to work with a `for` loop in a different fashion,
    like if it was a `while` loop.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 无限迭代器允许你以不同的方式使用`for`循环，就像它是`while`循环一样。
- en: '`infinite.py`'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`infinite.py`'
- en: '[PRE40]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Running the code gives this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码得到以下结果：
- en: '[PRE41]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `count` factory class makes an iterator that just goes on and on counting.
    It starts from 5 and keeps adding 3 to it. We need to manually break it if we
    don't want to get stuck in an infinite loop.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`count`工厂类创建一个不断计数并继续的迭代器。它从5开始，并持续加3。如果我们不希望陷入无限循环，我们需要手动中断它。'
- en: Iterators terminating on the shortest input sequence
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入序列最短时终止的迭代器
- en: 'This category is very interesting. It allows you to create an iterator based
    on multiple iterators, combining their values according to some logic. The key
    point here is that among those iterators, in case any of them are shorter than
    the rest, the resulting iterator won''t break, it will simply stop as soon as
    the shortest iterator is exhausted. This is very theoretical, I know, so let me
    give you an example using `compress`. This iterator gives you back the data according
    to a corresponding item in a selector being `True` or `False`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类别非常有趣。它允许你基于多个迭代器创建一个迭代器，根据某些逻辑组合它们的值。关键点在于，在这些迭代器中，如果其中任何一个比其他的长，结果迭代器不会断裂，它会在最短的迭代器耗尽时简单地停止。这非常理论化，我知道，所以让我给你举一个使用`compress`的例子。这个迭代器根据选择器中相应项的`True`或`False`返回数据：
- en: '`compress(''ABC'', (1, 0, 1))` would give back `''A''` and `''C''`, because
    they correspond to the `1''s`. Let''s see a simple example:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`compress(''ABC'', (1, 0, 1))`会返回`''A''`和`''C''`，因为它们对应于`1''s`。让我们看看一个简单的例子：'
- en: '`compress.py`'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`compress.py`'
- en: '[PRE42]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Notice that `odd_selector` and `even_selector` are 20 elements long, while
    `data` is just 10 elements long. `compress` will stop as soon as `data` has yielded
    its last element. Running this code produces the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`odd_selector`和`even_selector`长度为20个元素，而`data`只有10个元素长。`compress`会在`data`产生最后一个元素时停止。运行此代码会产生以下结果：
- en: '[PRE43]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: It's a very fast and nice way of selecting elements out of an iterable. The
    code is very simple, just notice that instead of using a `for` loop to iterate
    over each value that is given back by the compress calls, we used `list()`, which
    does the same, but instead of executing a body of instructions, puts all the values
    into a list and returns it.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个从可迭代对象中选择元素非常快且很棒的方法。代码非常简单，只需注意，我们不是使用`for`循环遍历由`compress`调用返回的每个值，而是使用了`list()`，它做的是同样的事情，但不同的是，它不是执行一系列指令，而是将所有值放入列表中并返回它。
- en: Combinatoric generators
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合生成器
- en: Last but not least, combinatoric generators. These are really fun, if you are
    into this kind of thing. Let's just see a simple example on permutations.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，组合生成器。如果你对这类东西感兴趣，这真的很有趣。让我们看看排列的一个简单例子。
- en: 'According to Wolfram Mathworld:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Wolfram Mathworld：
- en: '*"A permutation, also called an "arrangement number" or "order", is a rearrangement
    of the elements of an ordered list S into a one-to-one correspondence with S itself."*'
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"排列，也称为“排列数”或“顺序”，是将有序列表S的元素重新排列，使其与S本身形成一一对应关系。"*'
- en: 'For example, the permutations of ABC are 6: ABC, ACB, BAC, BCA, CAB, and CBA.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，ABC的排列有6个：ABC、ACB、BAC、BCA、CAB和CBA。
- en: 'If a set has *N* elements, then the number of permutations of them is *N!*
    (*N* factorial). For the string ABC the permutations are *3! = 3 * 2 * 1 = 6*.
    Let''s do it in Python:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个集合有*N*个元素，那么它们的排列数是*N!*（*N*的阶乘）。对于字符串ABC，排列是*3! = 3 * 2 * 1 = 6*。让我们用Python来做：
- en: '`permutations.py`'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`permutations.py`'
- en: '[PRE44]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This very short snippet of code produces the following result:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这段非常短的代码片段产生了以下结果：
- en: '[PRE45]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Be very careful when you play with permutation. Their number grows at a rate
    that is proportional to the factorial of the number of the elements you're permuting,
    and that number can get really big, really fast.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当你玩排列时，一定要非常小心。它们的数量以与你要排列的元素数量的阶乘成比例的速度增长，而这个数字可以变得非常大，非常快。
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've taken another step forward to expand our coding vocabulary.
    We've seen how to drive the execution of the code by evaluating conditions, and
    we've seen how to loop and iterate over sequences and collections of objects.
    This gives us the power to control what happens when our code is run, which means
    we are getting an idea on how to shape it so that it does what we want and it
    reacts to data that changes dynamically.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们进一步扩展了我们的编码词汇。我们看到了如何通过评估条件来驱动代码的执行，我们也看到了如何循环遍历对象序列和集合。这给了我们控制代码运行时发生什么的能力，这意味着我们正在获得如何塑造它以实现我们想要的功能，并对其动态变化的数据做出反应的想法。
- en: We've also seen how to combine everything together in a couple of simple examples,
    and in the end we have taken a brief look at the `itertools` module, which is
    full of interesting iterators which can enrich our abilities with Python even
    more.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也看到了如何在几个简单的例子中将所有东西结合起来，最后我们还简要地浏览了`itertools`模块，它充满了有趣的迭代器，可以进一步丰富我们在Python中的能力。
- en: 'Now it''s time to switch gears, to take another step forward and talk about
    functions. The next chapter is all about them because they are extremely important.
    Make sure you''re comfortable with what has been done up to now: I want to provide
    you with interesting examples, so I''ll have to go a little faster. Ready? Turn
    the page.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候转换方向，迈出另一步，来谈谈函数了。下一章全部都是关于它们的，因为它们极其重要。确保你对到目前为止所做的一切感到舒适：我想给你提供一些有趣的例子，所以我需要稍微加快一点速度。准备好了吗？翻到下一页。
