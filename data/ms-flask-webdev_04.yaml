- en: Creating Controllers with Blueprints
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用蓝图创建控制器
- en: The final piece of the **Model View Controller** (**MVC**) equation is controllers.
    We have already seen the basic usage of the view functions in our `main.py` file.
    Now, the more complex and powerful versions will be introduced, and we will turn
    our disparate view functions into cohesive wholes. We will also discuss the internals
    of how Flask handles the lifetime of an HTTP request and advanced ways to define
    Flask views.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型-视图-控制器**（**MVC**）方程式的最后一部分是控制器。我们已经在 `main.py` 文件中看到了视图函数的基本用法。现在，我们将介绍更复杂和强大的版本，并将我们的不同视图函数转变为统一的整体。我们还将讨论
    Flask 处理 HTTP 请求生命周期的内部机制以及定义 Flask 视图的先进方法。'
- en: Sessions and globals
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话和全局变量
- en: '**Sessions** are the way Flask will store information across requests; to do
    this, Flask will use signed cookies using the previously set `SECRET_KEY` config
    to apply the HMAC-SHA1 default cryptographic method. So, a user can read their
    session cookie but can''t modify it. Flask also sets a default session lifetime
    that defaults to 31 days to prevent relay attacks; this can be changed by using
    the configuration key''s `PERMANENT_SESSION_LIFETIME` config key.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**会话**是 Flask 在请求之间存储信息的方式；为此，Flask 将使用之前设置的 `SECRET_KEY` 配置来应用 HMAC-SHA1 默认加密方法。因此，用户可以读取他们的会话cookie，但不能修改它。Flask
    还设置了一个默认的会话生命周期，默认为 31 天，以防止中继攻击；这可以通过使用配置键的 `PERMANENT_SESSION_LIFETIME` 配置键来更改。'
- en: Security is paramount in today's modern web applications; read Flask's documentation carefully, where
    various attacks methods are covered: [http://flask.pocoo.org/docs/security/](http://flask.pocoo.org/docs/security/).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今的现代化网络应用程序中，安全性至关重要；请仔细阅读 Flask 的文档，其中涵盖了各种攻击方法：[http://flask.pocoo.org/docs/security/](http://flask.pocoo.org/docs/security/).
- en: 'A Flask session object is a special kind of Python dictionary, but you can
    use it much like a plain Python dictionary, as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 会话对象是一种特殊的 Python 字典，但您可以使用它就像使用普通的 Python 字典一样，如下所示：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Global** is a thread-safe namespace store to keep data during a request''s
    context. At the beginning of each request, a new global object is created, and
    at the end of the request the object is destroyed. It''s the right place to keep
    a User object or any data that needs to be shared across views, templates, or
    Python functions that are called within the request context. This is done without
    the need to pass around any data.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**全局**是一个线程安全的命名空间存储，用于在请求上下文中保持数据。在每个请求的开始时，创建一个新的全局对象，并在请求结束时销毁该对象。这是放置用户对象或任何需要在视图、模板或请求上下文中调用的
    Python 函数之间共享的数据的正确位置。这是无需传递任何数据即可完成的。'
- en: 'The use of `g` (global)is very simple, to set a key on a request context:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `g`（全局）非常简单，为了在请求上下文中设置一个键：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Request setup and teardown
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求设置和清理
- en: When your **WSGI** (**Web Server Gateway Interface**) handles a request, Flask
    creates a request context object that contains all the information about the request
    itself. This object is pushed into a stack that contains other important information,
    such as the Flask `app` , `g`, `session`, and flash messages.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的 **WSGI**（**Web 服务器网关接口**）处理请求时，Flask 会创建一个包含请求本身所有信息的请求上下文对象。此对象被推入一个包含其他重要信息的堆栈中，例如
    Flask 的 `app`、`g`、`session` 和闪存消息。
- en: The request object is available to any function, view, or template that is currently
    processing the request; this happens without the need to pass around the request
    object itself. `request` contains information such as HTTP headers, URI arguments,
    URL path, WSGI environment, and whatnot.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 请求对象对任何正在处理请求的功能、视图或模板都是可用的；这无需传递请求对象本身。`request` 包含诸如 HTTP 头部、URI 参数、URL 路径、WSGI
    环境等信息。
- en: For more detailed information on the Flask request object, see: [http://flask.pocoo.org/docs/api/#incoming-request-data](http://flask.pocoo.org/docs/api/#incoming-request-data).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Flask 请求对象的更详细信息，请参阅：[http://flask.pocoo.org/docs/api/#incoming-request-data](http://flask.pocoo.org/docs/api/#incoming-request-data).
- en: 'We can easily add more information to the request context by implementing our
    own hooks on request creation. To achieve this, we can use Flask''s decorator
    function, `@app.before_request`, and the `g` object. The `@app.before_request` function is
    executed every time, before a new request is made. For example, the following
    code keeps a global counter for the number of page loads:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在请求创建时实现自己的钩子来轻松地向请求上下文添加更多信息。为此，我们可以使用 Flask 的装饰器函数 `@app.before_request`
    和 `g` 对象。`@app.before_request` 函数在每次创建新请求之前执行。例如，以下代码为页面加载次数保持一个全局计数器：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Multiple functions can be decorated with `@app.before_request`, and they all
    will be executed before the requested view function is executed. There also exists
    a decorator, `@app.teardown_request`, which is called after the end of every request.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用 `@app.before_request` 装饰器装饰多个函数，它们都会在请求视图函数执行之前执行。还有一个装饰器，`@app.teardown_request`，它在每个请求结束后被调用。
- en: Initialize the example code provided for this chapter and watch how the data
    for `g`, `session`, and `request` changes. Also, note the `csrf_token` set by
    WTForm to secure our forms.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化本章提供的示例代码，并观察 `g`、`session` 和 `request` 的数据如何变化。还要注意由 WTForm 设置的 `csrf_token`，以保护我们的表单。
- en: Error pages
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误页面
- en: 'Displaying a browser''s default error pages to the end user is jarring as the
    user loses all context of your app, and they must hit the back button to return
    to your site. To display your own templates when an error is returned with the
    Flask `abort()` function, use the `errorhandler` decorator function:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 将浏览器的默认错误页面显示给最终用户会让人感到震惊，因为用户会失去你应用的所有上下文，他们必须点击后退按钮才能返回你的网站。当使用 Flask 的 `abort()`
    函数返回错误时，要显示你自己的模板，请使用 `errorhandler` 装饰器函数：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`errorhandler` is also useful to translate internal server errors and HTTP
    500 codes into user-friendly error pages. The `app.errorhandler()` function may
    take either one or many HTTP status codes to define which code it will act on.
    The returning of a tuple instead of just an HTML string allows you to define the
    HTTP status code of the `Response` object. By default, this is set to `200`. The
    `recommend` method is covered in [Chapter 6](433b4f3b-4e05-4a63-ae8b-ec2e392877b4.xhtml),
    *Securing Your App*.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`errorhandler` 也可以用来将内部服务器错误和 HTTP 500 状态码转换为用户友好的错误页面。`app.errorhandler()`
    函数可以接受一个或多个 HTTP 状态码来定义它将操作哪个代码。通过返回一个元组而不是仅仅一个 HTML 字符串，你可以定义 `Response` 对象的
    HTTP 状态码。默认情况下，这设置为 `200`。`recommend` 方法在 [第 6 章](433b4f3b-4e05-4a63-ae8b-ec2e392877b4.xhtml)，*保护你的应用*
    中有介绍。'
- en: Class-based views
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于类的视图
- en: In most Flask apps, views are handled by functions. However, when many views
    share common functionality or there are pieces of your code that could be broken
    out into separate functions, it would be useful to implement our views as classes
    to take advantage of inheritance.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数 Flask 应用中，视图是通过函数处理的。然而，当许多视图共享共同的功能或者你的代码中有可以拆分成单独函数的部分时，将视图实现为类以利用继承会很有用。
- en: 'For example, if we have views that render a template, we could create a generic
    view class that keeps our code *DRY*:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有渲染模板的视图，我们可以创建一个通用的视图类，以使我们的代码保持 *DRY*：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first thing to note about this code is the `dispatch_request()` function
    in our view class. This is the function in our view that acts as the normal view
    function and returns an HTML string. The `app.add_url_rule()` function mimics
    the `app.route()` function as it ties a route to a function call. The first argument
    defines the route of the function, and the `view_func` parameter defines the function
    that handles the route. The `View.as_view()` method is passed to the `view_func`
    parameter because it transforms the `View` class into a view function. The first
    argument defines the name of the view function, so functions such as `url_for()`
    can route to it. The remaining parameters are passed to the `__init__` function
    of the `View` class.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这段代码，首先要注意的是我们视图类中的 `dispatch_request()` 函数。这是我们的视图中充当正常视图函数并返回 HTML 字符串的函数。`app.add_url_rule()`
    函数模仿了 `app.route()` 函数，因为它将路由绑定到函数调用。第一个参数定义了函数的路由，`view_func` 参数定义了处理路由的函数。`View.as_view()`
    方法传递给 `view_func` 参数，因为它将 `View` 类转换成视图函数。第一个参数定义了视图函数的名称，这样 `url_for()` 等函数就可以路由到它。其余参数传递给
    `View` 类的 `__init__` 函数。
- en: 'Like the normal view functions, HTTP methods other than `GET` must be explicitly
    allowed for the `View` class. To allow other methods, a class variable containing
    the list of named methods must be added:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与正常的视图函数一样，除了 `GET` 方法之外的其他 HTTP 方法必须明确允许 `View` 类。要允许其他方法，必须添加一个包含命名方法列表的类变量：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This can be a very powerful approach. Take for example web pages that render
    tabular lists from database tables; they are almost identical, so are nice candidates
    for generic approaches. Although not a trivial task to carry out, the time you
    take to implement it can save you time in the future. An initial skeleton using
    class-based views could be this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以是一个非常强大的方法。以渲染来自数据库表的表格列表的网页为例；它们几乎相同，因此是通用方法的良好候选者。尽管执行起来不是一件简单的事情，但实现它所花费的时间可以在未来为你节省时间。使用基于类的视图的初始骨架可能是这样的：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There are some interesting things to notice. First, in the class constructor
    we initialize the `columns` class property with the SQLAlchemy model columns;
    we are leveraging the model introspection ability of SQLAlchemy to be able to
    implement our generic template. So, column names are going to be passed to our
    generic template so that we can properly render a well formatted tabular list
    for any model we throw at it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些有趣的事情需要注意。首先，在类构造函数中，我们使用SQLAlchemy模型列初始化`columns`类属性；我们正在利用SQLAlchemy的模型自省能力来实现我们的通用模板。因此，列名将被传递到我们的通用模板中，这样我们就可以为任何我们抛给它的模型正确渲染一个格式良好的表格列表。
- en: This is a simple example of how, with a single class view, we handle all list
    views from all our models.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用单个类视图处理所有模型列表视图的简单示例。
- en: 'This is how the template looks like:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是模板的样式：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can access these views by running the example code provided for this chapter,
    then directly accessing the declared URLs:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行本章提供的示例代码，然后直接访问声明的URL来访问这些视图：
- en: '`http://localhost:5000/generic_users`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:5000/generic_users`'
- en: '`http://localhost:5000/generic_posts`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:5000/generic_posts`'
- en: '`http://localhost:5000/generic_comments`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:5000/generic_comments`'
- en: You may have noticed that our tabular view is missing the table column headers.
    As an exercise, I challenge you to implement it; you can simply render the provided `columns` class
    property, or even better, use a label/column mapping to display more user-friendly
    column names.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们的表格视图缺少表列标题。作为一个练习，我挑战你来实现它；你可以简单地渲染提供的`columns`类属性，或者更好的方法是使用标签/列映射来显示更友好的列名。
- en: Method class views
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法类视图
- en: 'Often, when functions handle multiple HTTP methods, the code can become difficult
    to read due to large sections of code nested within `if` statements, as demonstrated
    in the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当函数处理多个HTTP方法时，由于代码中嵌套在`if`语句中的大段代码，代码可能会变得难以阅读，如下所示：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This can be solved with the `MethodView` class. `MethodView` allows each method
    to be handled by a different class method to separate concerns:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过`MethodView`类来解决。`MethodView`允许每个方法由不同的类方法处理，以分离关注点：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Blueprints
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝图
- en: In Flask, a **blueprint** is a method of extending an existing Flask app. They
    provide a way of combining groups of views with common functionality and allow
    developers to break their app down into different components. In our architecture,
    the blueprints will act as our *controllers*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flask中，**蓝图**是扩展现有Flask应用的一种方法。它们提供了一种将具有共同功能的一组视图组合起来的方式，并允许开发者将应用分解为不同的组件。在我们的架构中，蓝图将充当我们的*控制器*。
- en: 'Views are registered to a blueprint; a separate template and static folder
    can be defined for it, and when it has all the desired content in it, it can be
    registered on the main Flask app to add the blueprint''s content. A blueprint
    acts much like a Flask app object, but is not actually a self-contained app. This
    is how Flask extensions provide view functions. To get an idea of what blueprints
    are, here is a very simple example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 视图被注册到蓝图上；可以为它定义一个单独的模板和静态文件夹，当它包含所有所需的内容时，它可以在主Flask应用上注册以添加蓝图的内容。蓝图在功能上类似于Flask应用对象，但实际上不是一个自包含的应用。这就是Flask扩展提供视图函数的方式。为了了解蓝图是什么，这里有一个非常简单的例子：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The blueprint takes two required parameters, the name of the blueprint and the
    name of the package, which are used internally in Flask, and passing `__name__`
    to it will suffice.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝图需要两个必需的参数，蓝图名称和包名称，这些名称在Flask内部使用，传递`__name__`给它就足够了。
- en: The other parameters are optional and define where the blueprint will look for
    files. Because `templates_folder` was specified, the blueprint will not look in
    the default template folder, and the route will render `templates/example/home.html`
    and not `templates/home.html`. The `url_prefix` option automatically adds the
    provided URI to the start of every route in the blueprint. So, the URL for the
    home view is actually `/example/`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 其他参数是可选的，定义了蓝图将查找文件的位置。因为指定了`templates_folder`，蓝图将不会在默认模板文件夹中查找，并且路由将渲染`templates/example/home.html`而不是`templates/home.html`。`url_prefix`选项自动将提供的URI添加到蓝图中的每个路由的开头。所以，主页视图的URL实际上是`/example/`。
- en: 'The `url_for()` function will now have to be told which blueprint the requested
    route is in:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`url_for()`函数现在必须告诉请求的路由在哪个蓝图：'
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Also, the `url_for()` function will now have to be told whether the view is
    being rendered from within the same blueprint:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`url_for()`函数现在必须告诉视图是否是从同一蓝图内部渲染的：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `url_for()` function will also look for static files in the specified `static`
    folder as well.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`url_for()`函数还会在指定的`static`文件夹中查找静态文件。'
- en: 'Use this to add the blueprint to our app:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下方法将蓝图添加到我们的应用中：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s transform our current app to one that uses blueprints. We will first
    need to define our blueprint before all of our routes:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将当前的应用转换为使用蓝图的应用。我们首先需要定义我们的蓝图，然后再定义所有路由：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, because the `templates` folder was defined, we need to move all of our
    templates into a subfolder of the `templates` folder named `blog`. Next, all of
    our routes need to have `@app.route` changed to `@blog_blueprint.route`, and any
    class view assignments now need to be registered to `blog_blueprint`. Remember
    that the `url_for()` function calls in the templates will also have to be changed
    to have a period prepended to then to indicate that the route is in the same blueprint.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，因为已经定义了`templates`文件夹，我们需要将所有的模板移动到`templates`文件夹下的一个名为`blog`的子文件夹中。接下来，所有我们的路由都需要将`@app.route`更改为`@blog_blueprint.route`，并且任何类视图的分配现在都需要注册到`blog_blueprint`。记住，模板中的`url_for()`函数调用也将需要更改，前面要加上一个点来表示该路由位于同一个蓝图下。
- en: 'At the end of the file, right before the `if__name__ == ''__main__'':` statement,
    add the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件末尾，在`if __name__ == '__main__':`语句之前，添加以下内容：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, all of our content is back in the app, which is registered under the blueprint.
    Because our base app no longer has any views, let''s add a redirect on the base
    URL:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有内容都回到了我们的应用中，这些内容注册在蓝图下。因为我们的基础应用不再有任何视图，让我们在基础URL上添加一个重定向：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Why blog and not `blog_blueprint`? Because blog is the name of the blueprint
    and the name is what Flask uses internally for routing. `blog_blueprint` is the
    name of the variable in the Python file.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么是`blog`而不是`blog_blueprint`？因为`blog`是蓝图的名字，而名字是Flask在内部用于路由的。`blog_blueprint`是Python文件中变量的名字。
- en: Summary
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have introduced you to some powerful features of Flask;
    we have seen how to use sessions to store user data across requests and globals
    for keeping data during the request context. We have introduced you to the concept
    of request context and started showing you some new features that will enable
    us to scale our applications easily to any size, using Blueprints and Method Class
    views.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向您介绍了一些Flask的强大功能；我们看到了如何使用会话在请求之间存储用户数据，以及如何使用全局变量在请求上下文中保持数据。我们向您介绍了请求上下文的概念，并开始向您展示一些新功能，这些功能将使我们能够轻松地将我们的应用程序扩展到任何规模，使用蓝图和方法类视图。
- en: We now have our app working inside a blueprint, but what does this give us?
    Let's say that we wanted to add a photo sharing function to our site, we would
    be able to group all the view functions into one blueprint with its own templates,
    static folder, and URL prefix without any fear of disrupting the functionality
    of the rest of the site.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在让我们的应用在蓝图内部运行，但这给我们带来了什么？假设我们想要在我们的网站上添加一个照片分享功能，我们能够将所有的视图函数组合到一个包含自己的模板、静态文件夹和URL前缀的蓝图里，而无需担心会破坏网站其他部分的功能。
- en: In the next chapter, blueprints will be made even more powerful by separating
    them into different files after upgrading our file and code structure.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，通过升级我们的文件和代码结构，蓝图将被进一步强化，将它们分离到不同的文件中。
