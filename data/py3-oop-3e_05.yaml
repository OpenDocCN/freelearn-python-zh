- en: When to Use Object-Oriented Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用面向对象编程
- en: In previous chapters, we've covered many of the defining features of object-oriented
    programming. We now know the principles and paradigms of object-oriented design,
    and we've covered the syntax of object-oriented programming in Python.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们介绍了面向对象编程的许多定义特征。我们现在知道了面向对象设计的原理和范式，并且我们已经介绍了Python中面向对象编程的语法。
- en: 'Yet, we don''t know exactly how and, especially, when to utilize these principles
    and syntax in practice. In this chapter, we''ll discuss some useful applications
    of the knowledge we''ve gained, looking at some new topics along the way:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们并不知道确切如何以及特别是在实践中何时利用这些原则和语法。在本章中，我们将讨论一些有用知识的应用，沿途探讨一些新主题：
- en: How to recognize objects
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何识别对象
- en: Data and behaviors, once again
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据和行为，再次强调
- en: Wrapping data behaviors using properties
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性包装数据行为
- en: Restricting data using behaviors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用行为限制数据
- en: The Don't Repeat Yourself principle
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要重复原则
- en: Recognizing repeated code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别重复的代码
- en: Treat objects as objects
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将对象视为对象
- en: 'This may seem obvious; you should generally give separate objects in your problem
    domain a special class in your code. We''ve seen examples of this in the case
    studies in previous chapters: first, we identify objects in the problem, and then
    model their data and behaviors.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很明显；你应该通常给你的问题域中的单独对象在代码中一个特殊的类。我们在前几章的案例研究中看到了这样的例子：首先，我们识别问题中的对象，然后建模它们的数据和行为。
- en: Identifying objects is a very important task in object-oriented analysis and
    programming. But it isn't always as easy as counting the nouns in short paragraphs
    that, frankly, I have constructed explicitly for that purpose. Remember, objects
    are things that have both data and behavior. If we are working only with data,
    we are often better off storing it in a list, set, dictionary, or other Python
    data structure (which we'll be covering thoroughly in [Chapter 6](6a121a79-7716-4a8f-94ab-f96781e82d25.xhtml),
    *Python Data Structures*). On the other hand, if we are working only with behavior,
    but no stored data, a simple function is more suitable.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 识别对象是面向对象分析和编程中一个非常重要的任务。但这并不总是像在简短的段落中数名词那么简单，坦白说，我为此目的明确地构建了这些段落。记住，对象是既有数据又有行为的事物。如果我们只处理数据，我们通常最好将其存储在列表、集合、字典或其他Python数据结构中（我们将在[第6章](6a121a79-7716-4a8f-94ab-f96781e82d25.xhtml)，*Python数据结构*中彻底介绍）。另一方面，如果我们只处理行为，但没有存储的数据，一个简单的函数就更为合适。
- en: An object, however, has both data and behavior. Proficient Python programmers
    use built-in data structures unless (or until) there is an obvious need to define
    a class. There is no reason to add an extra level of abstraction if it doesn't
    help organize our code. On the other hand, the *obvious* need is not always self-evident.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个对象既有数据也有行为。熟练的Python程序员会使用内置的数据结构，除非（或直到）有明显的需要定义一个类。如果没有帮助组织我们的代码，就没有理由添加额外的抽象层次。另一方面，*明显*的需要并不总是显而易见的。
- en: 'We can often start our Python programs by storing data in a few variables.
    As the program expands, we will later find that we are passing the same set of
    related variables to a set of functions. This is the time to think about grouping
    both variables and functions into a class. If we are designing a program to model
    polygons in two-dimensional space, we might start with each polygon represented
    as a list of points. The points would be modeled as two tuples (*x*, *y*) describing
    where that point is located. This is all data, stored in a set of nested data
    structures (specifically, a list of tuples):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常可以通过在几个变量中存储数据来开始我们的Python程序。随着程序的扩展，我们稍后会发现我们将同一组相关的变量传递给一组函数。这时，我们应该考虑将变量和函数分组到一个类中。如果我们正在设计一个用于模拟二维空间中多边形的程序，我们可能从每个多边形表示为点的列表开始。这些点将被建模为描述该点位置的(*x*,
    *y*)两个元组。这全是数据，存储在一系列嵌套的数据结构中（具体来说，是一个元组的列表）：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, if we want to calculate the distance around the perimeter of the polygon,
    we need to sum the distances between each point. To do this, we need a function
    to calculate the distance between two points. Here are two such functions:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想要计算多边形周长的距离，我们需要求出每个点之间的距离之和。为此，我们需要一个函数来计算两点之间的距离。这里有两个这样的函数：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, as object-oriented programmers, we clearly recognize that a `polygon`
    class could encapsulate the list of points (data) and the `perimeter` function
    (behavior). Further, a `point` class, such as we defined in [Chapter 2](0786c893-abb9-4f35-9320-3f2f54de95eb.xhtml),
    *Objects in Python*, might encapsulate the `x` and `y` coordinates and the `distance`
    method. The question is: is it valuable to do this?'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，作为面向对象的程序员，我们明显认识到`polygon`类可以封装点列表（数据）和`perimeter`函数（行为）。此外，一个`point`类，例如我们在[第2章](0786c893-abb9-4f35-9320-3f2f54de95eb.xhtml)“Python中的对象”中定义的，可以封装`x`和`y`坐标以及`distance`方法。问题是：这样做有价值吗？
- en: 'For the previous code, maybe yes, maybe no. With our recent experience in object-oriented
    principles, we can write an object-oriented version in record time. Let''s compare
    them as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于之前的代码，也许是的，也许不是。凭借我们最近在面向对象原则方面的经验，我们可以快速编写面向对象的版本。让我们如下进行比较：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we can see from the highlighted sections, there is twice as much code here
    as there was in our earlier version, although we could argue that the `add_point`
    method is not strictly necessary.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从突出显示的部分中可以看到，这里的代码量是我们早期版本的两倍，尽管我们可以争论`add_point`方法并不是严格必要的。
- en: 'Now, to understand the differences a little better, let''s compare the two
    APIs in use. Here''s how to calculate the perimeter of a square using the object-oriented
    code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了更好地理解两者之间的差异，让我们比较一下两个API的使用情况。以下是使用面向对象代码计算正方形周长的方法：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'That''s fairly succinct and easy to read, you might think, but let''s compare
    it to the function-based code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来相当简洁且易于阅读，你可能会这样认为，但让我们将其与基于函数的代码进行比较：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Hmm, maybe the object-oriented API isn't so compact! That said, I'd argue that
    it was easier to *read* than the functional example. How do we know what the list
    of tuples is supposed to represent in the second version? How do we remember what
    kind of object we're supposed to pass into the `perimeter` function? (a list of
    two tuples? That's not intuitive!) We would need a lot of documentation to explain
    how these functions should be used.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，也许面向对象的API并不那么紧凑！话虽如此，我认为它比函数示例更容易*阅读*。我们如何知道在第二个版本中元组的列表应该代表什么？我们如何记住我们应该传递给`perimeter`函数的对象类型？（一个包含两个元组的列表？这并不直观！）我们需要大量的文档来解释这些函数应该如何使用。
- en: In contrast, the object-oriented code is relatively self-documenting. We just
    have to look at the list of methods and their parameters to know what the object
    does and how to use it. By the time we wrote all the documentation for the functional
    version, it would probably be longer than the object-oriented code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，面向对象的代码相对自文档化。我们只需查看方法列表及其参数，就可以知道对象的功能以及如何使用它。等到我们为函数版本编写完所有文档，它可能比面向对象的代码还要长。
- en: Finally, code length is not a good indicator of code complexity. Some programmers
    get hung up on complicated *one liners* that do an incredible amount of work in
    one line of code. This can be a fun exercise, but the result is often unreadable,
    even to the original author the following day. Minimizing the amount of code can
    often make a program easier to read, but do not blindly assume this is the case.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码长度并不是代码复杂性的良好指标。一些程序员会陷入复杂的*一行代码*中，一行代码就能完成大量的工作。这可能是一项有趣的练习，但结果往往是难以阅读的，即使是原作者第二天再看也会如此。尽量减少代码量通常可以使程序更容易阅读，但不要盲目地假设这是正确的。
- en: 'Luckily, this trade-off isn''t necessary. We can make the object-oriented `Polygon`
    API as easy to use as the functional implementation. All we have to do is alter
    our `Polygon` class so that it can be constructed with multiple points. Let''s
    give it an initializer that accepts a list of `Point` objects. In fact, let''s
    allow it to accept tuples too, and we can construct the `Point` objects ourselves,
    if needed:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这种权衡是不必要的。我们可以使面向对象的`Polygon` API与函数实现一样易于使用。我们只需要修改我们的`Polygon`类，使其可以用多个点来构造。让我们给它一个接受`Point`对象列表的初始化器。实际上，让我们允许它接受元组，如果需要，我们还可以自己构造`Point`对象：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This initializer goes through the list and ensures that any tuples are converted
    to points. If the object is not a tuple, we leave it as is, assuming that it is
    either a `Point` object already, or an unknown duck-typed object that can act
    like a `Point` object.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个初始化器会遍历列表，并确保将任何元组转换为点。如果对象不是元组，我们就保持原样，假设它要么是一个已经存在的`Point`对象，要么是一个可以像`Point`对象一样操作的未知鸭子类型对象。
- en: If you are experimenting with the above code, you could subclass `Polygon` and
    override the `__init__` function instead of replacing the initializer or copying
    the `add_point` and `perimeter` methods.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在尝试上述代码，你可以通过子类化`Polygon`并覆盖`__init__`函数来代替替换初始化器或复制`add_point`和`perimeter`方法。
- en: Still, there's no clear winner between the object-oriented and more data-oriented
    versions of this code. They both do the same thing. If we have new functions that
    accept a polygon argument, such as `area(polygon)` or `point_in_polygon(polygon,
    x, y)`, the benefits of the object-oriented code become increasingly obvious.
    Likewise, if we add other attributes to the polygon, such as `color` or `texture`,
    it makes more and more sense to encapsulate that data into a single class.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在面向对象和更多数据导向的代码版本之间，并没有明显的胜者。它们都做了同样的事情。如果我们有接受多边形参数的新函数，如`area(polygon)`或`point_in_polygon(polygon,
    x, y)`，面向对象代码的好处将越来越明显。同样，如果我们给多边形添加其他属性，如`color`或`texture`，将数据封装到单个类中会更有意义。
- en: The distinction is a design decision, but in general, the more important a set
    of data is, the more likely it is to have multiple functions specific to that
    data, and the more useful it is to use a class with attributes and methods instead.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种区别是一个设计决策，但一般来说，一组数据越重要，就越有可能有针对该数据的多个特定函数，使用具有属性和方法类的用途就越大。
- en: When making this decision, it also pays to consider how the class will be used.
    If we're only trying to calculate the perimeter of one polygon in the context
    of a much greater problem, using a function will probably be quickest to code
    and easier to use *one time only*. On the other hand, if our program needs to
    manipulate numerous polygons in a wide variety of ways (calculating the perimeter,
    area, and intersection with other polygons, moving or scaling them, and so on),
    we have almost certainly identified an object; one that needs to be extremely
    versatile.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在做出这个决定时，考虑类将如何被使用也是有帮助的。如果我们只是在更大的问题背景下尝试计算一个多边形的周长，使用一个函数可能编写起来最快，也更容易一次性使用。另一方面，如果我们的程序需要以多种方式操纵大量多边形（计算周长、面积、与其他多边形的交集、移动或缩放等），我们几乎肯定已经识别出一个对象；一个需要极其灵活的对象。
- en: Additionally, pay attention to the interaction between objects. Look for inheritance
    relationships; inheritance is impossible to model elegantly without classes, so
    make sure to use them. Look for the other types of relationships we discussed
    in [Chapter 1](f3a06c74-ab7f-450f-9663-bfe014b359bf.xhtml), *Object-Oriented Design*,
    association and composition. Composition can, technically, be modeled using only
    data structures; for example, we can have a list of dictionaries holding tuple
    values, but it is sometimes less complicated to create a few classes of objects,
    especially if there is behavior associated with the data.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意对象之间的交互。寻找继承关系；没有类，继承是无法优雅建模的，所以请确保使用它们。寻找我们在[第1章](f3a06c74-ab7f-450f-9663-bfe014b359bf.xhtml)“面向对象设计”中讨论的其他类型的关系，如关联和组合。在技术上，组合可以使用仅数据结构来建模；例如，我们可以有一个包含元组值的字典列表，但有时创建几个具有与数据相关行为的对象类会更简单。
- en: Don't rush to use an object just because you can use an object, but don't neglect
    to create a class when you need to use a class.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 不要因为可以使用对象就急于使用对象，但当你需要使用类时，也不要忽视创建一个类。
- en: Adding behaviors to class data with properties
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将行为添加到具有属性的类数据中
- en: Throughout this book, we've focused on the separation of behavior and data.
    This is very important in object-oriented programming, but we're about to see
    that, in Python, the distinction is uncannily blurry. Python is very good at blurring
    distinctions; it doesn't exactly help us to *think outside the box*. Rather, it
    teaches us to stop thinking about the box.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们一直关注行为和数据分离。这在面向对象编程中非常重要，但我们将看到，在Python中，这种区别非常模糊。Python非常擅长模糊化区别；它并不真正帮助我们跳出思维定式。相反，它教会我们停止考虑思维定式。
- en: 'Before we get into the details, let''s discuss some bad object-oriented theory.
    Many object-oriented languages teach us to never access attributes directly (Java
    is the most notorious). They insist that we write attribute access like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入细节之前，让我们讨论一些不好的面向对象理论。许多面向对象的语言教导我们永远不要直接访问属性（Java是最臭名昭著的）。他们坚持认为我们应该这样编写属性访问：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The variables are prefixed with an underscore to suggest that they are private
    (other languages would actually force them to be private). Then, the `get` and
    `set` methods provide access to each variable. This class would be used in practice
    as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 变量以下划线为前缀，以表明它们是私有的（其他语言实际上会强制它们成为私有）。然后，`get`和`set`方法提供了对每个变量的访问。这个类在实际应用中的使用如下：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is not nearly as readable as the direct access version that Python favors:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这在可读性上远不如Python所青睐的直接访问版本：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So, why would anyone insist upon the method-based syntax? Their reasoning is
    that, someday, we may want to add extra code when a value is set or retrieved.
    For example, we could decide to cache a value to avoid complex computations, or
    we might want to validate that a given value is a suitable input.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么有人会坚持使用基于方法的语法呢？他们的理由是，总有一天，我们可能想在设置或检索值时添加额外的代码。例如，我们可以决定缓存一个值以避免复杂的计算，或者我们可能想验证给定的值是否是一个合适的输入。
- en: 'In code, for example, we could decide to change the `set_name()` method as
    follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在代码中，我们可以决定将`set_name()`方法更改为以下内容：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, in Java and similar languages, if we had written our original code for
    direct attribute access, and then later changed it to a method like the preceding
    one, we''d have a problem: anyone who had written code that accessed the attribute
    directly would now have to access a method. If they didn''t then change the access
    style from attribute access to a function call, their code will be broken.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在Java和类似的语言中，如果我们最初为直接属性访问编写了原始代码，然后后来将其更改为前面提到的方法，我们会遇到问题：任何编写了直接访问属性代码的人现在都必须访问一个方法。如果他们没有将访问样式从属性访问更改为函数调用，他们的代码就会出错。
- en: The mantra in these languages is that we should never make public members private.
    This doesn't make much sense in Python since there isn't any real concept of private
    members!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语言中的格言是，我们永远不应该将公共成员设置为私有。在Python中这并没有太多意义，因为Python中并没有真正的私有成员概念！
- en: 'Python gives us the `property` keyword to make methods that *look* like attributes.
    We can therefore write our code to use direct member access, and if we ever unexpectedly
    need to alter the implementation to do some calculation when getting or setting
    that attribute''s value, we can do so without changing the interface. Let''s see
    how it looks:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Python为我们提供了`property`关键字来创建看起来像属性的函数。因此，我们可以编写代码以使用直接成员访问，如果我们需要意外地更改实现以在获取或设置该属性的值时进行一些计算，我们可以这样做而不必更改接口。让我们看看它看起来如何：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Compared to the earlier class, we first change the `name` attribute into a (semi-)private
    `_name` attribute. Then, we add two more (semi-)private methods to get and set
    that variable, performing our validation when we set it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与早期版本相比，我们首先将`name`属性更改为（半）私有属性`_name`。然后，我们添加了两个更多（半）私有方法来获取和设置该变量，在我们设置它时执行验证。
- en: 'Finally, we have the `property` declaration at the bottom. This is the Python
    magic. It creates a new attribute on the `Color` class called `name`, to replace
    the direct `name` attribute. It sets this attribute to be a **property**. Under
    the hood, `property` calls the two methods we just created whenever the value
    is accessed or changed. This new version of the `Color` class can be used exactly
    the same way as the earlier version, yet it now performs validation when we set
    the `name` attribute:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在底部有`property`声明。这是Python的魔法。它为`Color`类创建了一个名为`name`的新属性，以替换直接的`name`属性。它将此属性设置为**属性**。在底层，`property`在访问或更改值时调用我们刚刚创建的两个方法。这个`Color`类的新版本可以像早期版本一样使用，但现在在设置`name`属性时它将执行验证：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: So, if we'd previously written code to access the `name` attribute, and then
    changed it to use our `property`-based object, the previous code would still work,
    unless it was sending an empty `property` value, which is the behavior we wanted
    to forbid in the first place. Success!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们之前编写了访问`name`属性的代码，然后将其更改为使用我们的基于`property`的对象，之前的代码仍然会工作，除非它发送了一个空的`property`值，这正是我们最初想要禁止的行为。成功了！
- en: Bear in mind that, even with the `name` property, the previous code is not 100%
    safe. People can still access the `_name` attribute directly and set it to an
    empty string if they want to. But if they access a variable we've explicitly marked
    with an underscore to suggest it is private, they're the ones that have to deal
    with the consequences, not us.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，即使有了`name`属性，之前的代码也不是100%安全的。人们仍然可以直接访问`_name`属性并将其设置为空字符串，如果他们想这么做的话。但如果他们访问了我们明确标记为下划线以表明它是私有的变量，那么他们必须承担后果，而不是我们。
- en: Properties in detail
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性的详细说明
- en: Think of the `property` function as returning an object that proxies any requests
    to set or access the attribute value through the methods we have specified. The
    `property` built-in is like a constructor for such an object, and that object
    is set as the public-facing member for the given attribute.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `property` 函数想象成返回一个对象，该对象通过我们指定的方法代理对属性值的设置或访问请求。`property` 内置函数就像这样一个对象的构造函数，并且该对象被设置为给定属性的公共成员。
- en: 'This `property` constructor can actually accept two additional arguments, a
    `delete` function and a docstring for the property. The `delete` function is rarely
    supplied in practice, but it can be useful for logging the fact that a value has
    been deleted, or possibly to veto deleting if we have reason to do so. The docstring
    is just a string describing what the property does, no different from the docstrings
    we discussed in [Chapter 2](0786c893-abb9-4f35-9320-3f2f54de95eb.xhtml), *Objects
    in Python*. If we do not supply this parameter, the docstring will instead be
    copied from the docstring for the first argument: the `getter` method. Here is
    a silly example that states whenever any of the methods are called:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个 `property` 构造函数可以接受两个额外的参数，一个 `delete` 函数和属性的文档字符串。在实践中，很少提供 `delete`
    函数，但它可以用于记录值已被删除的事实，或者如果我们有理由这样做，可以拒绝删除。文档字符串只是一个描述属性做什么的字符串，与我们在[第 2 章](0786c893-abb9-4f35-9320-3f2f54de95eb.xhtml)，《Python
    中的对象》中讨论的文档字符串没有区别。如果我们不提供此参数，则文档字符串将复制自第一个参数的文档字符串：`getter` 方法。以下是一个愚蠢的例子，它声明了每次调用任何方法时：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we actually use this class, it does indeed print out the correct strings
    when we ask it to:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们实际使用这个类，当我们要求它打印正确的字符串时，它确实会这样做：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Further, if we look at the help file for the `Silly` class (by issuing `help(Silly)`
    at the interpreter prompt), it shows us the custom docstring for our `silly` attribute:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们查看 `Silly` 类的帮助文件（通过在解释器提示符中输入 `help(Silly)`），它将显示我们 `silly` 属性的自定义文档字符串：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once again, everything is working as we planned. In practice, properties are
    normally only defined with the first two parameters: the `getter` and `setter`
    functions. If we want to supply a docstring for a property, we can define it on
    the `getter` function; the property proxy will copy it into its own docstring.
    The `delete` function is often left empty because object attributes are so rarely
    deleted. If a coder does try to delete a property that doesn''t have a `delete`
    function specified, it will raise an exception. Therefore, if there is a legitimate
    reason to delete our property, we should supply that function.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，一切都在我们的计划之中。在实践中，属性通常只使用前两个参数定义：`getter` 和 `setter` 函数。如果我们想为属性提供一个文档字符串，我们可以在
    `getter` 函数上定义它；属性代理将把它复制到自己的文档字符串中。`delete` 函数通常留空，因为对象属性很少被删除。如果一个编码者尝试删除没有指定
    `delete` 函数的属性，它将引发异常。因此，如果有合法的理由删除我们的属性，我们应该提供该函数。
- en: Decorators – another way to create properties
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器 – 创建属性的另一种方式
- en: If you've never used Python decorators before, you might want to skip this section
    and come back to it after we've discussed the decorator pattern in [Chapter 10](345fe617-9a90-4c59-9355-e7076759f9a4.xhtml),
    *Python Design Patterns I*. However, you don't need to understand what's going
    on to use the decorator syntax in order to make property methods more readable.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前从未使用过 Python 装饰器，你可能想要跳过这一节，在我们讨论了[第 10 章](345fe617-9a90-4c59-9355-e7076759f9a4.xhtml)，《Python
    设计模式 I》中的装饰器模式后再回来。然而，你不需要理解正在发生的事情，就可以使用装饰器语法来使属性方法更易读。
- en: 'The `property` function can be used with the decorator syntax to turn a `get`
    function into a `property` function, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`property` 函数可以用装饰器语法使用，将 `get` 函数转换为 `property` 函数，如下所示：'
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This applies the `property` function as a decorator, and is equivalent to the
    previous `foo = property(foo)` syntax. The main difference, from a readability
    perspective, is that we get to mark the `foo` function as a property at the top
    of the method, instead of after it is defined, where it can be easily overlooked.
    It also means we don't have to create private methods with underscore prefixes
    just to define a property.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 `property` 函数用作装饰器，与之前的 `foo = property(foo)` 语法等效。从可读性的角度来看，主要区别在于我们可以在方法顶部标记
    `foo` 函数为属性，而不是在定义之后，这样它就不容易被忽视了。这也意味着我们不需要创建带有下划线前缀的私有方法来定义属性。
- en: 'Going one step further, we can specify a `setter` function for the new property
    as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 再进一步，我们可以为新的属性指定一个 `setter` 函数，如下所示：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This syntax looks pretty odd, although the intent is obvious. First, we decorate
    the `foo` method as a getter. Then, we decorate a second method with exactly the
    same name by applying the `setter` attribute of the originally decorated `foo`
    method! The `property` function returns an object; this object always comes with
    its own `setter` attribute, which can then be applied as a decorator to other
    functions. Using the same name for the get and set methods is not required, but
    it does help to group together the multiple methods that access one property.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语法看起来相当奇怪，尽管意图是明显的。首先，我们将`foo`方法装饰为一个getter。然后，我们通过应用原始装饰的`foo`方法的`setter`属性来装饰一个具有完全相同名称的第二个方法！`property`函数返回一个对象；这个对象总是带有自己的`setter`属性，然后可以将它作为装饰器应用于其他函数。get和set方法使用相同的名称不是必需的，但它有助于将访问同一属性的多个方法分组在一起。
- en: 'We can also specify a `delete` function with `@foo.deleter`. We cannot specify
    a docstring using `property` decorators, so we need to rely on the property copying
    the docstring from the initial getter method. Here''s our previous `Silly` class
    rewritten to use `property` as a decorator:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`@foo.deleter`指定一个`delete`函数。我们不能使用`property`装饰器来指定文档字符串，因此我们需要依赖于属性从初始的getter方法复制文档字符串。以下是我们之前重写的`Silly`类，使用`property`作为装饰器：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This class operates *exactly* the same as our earlier version, including the
    help text. You can use whichever syntax you feel is more readable and elegant.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类与我们的早期版本操作**完全相同**，包括帮助文本。你可以使用你认为更易读和优雅的语法。
- en: Deciding when to use properties
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 决定何时使用属性
- en: With the built-in property clouding the division between behavior and data,
    it can be confusing to know when to choose an attribute, or a method, or a property.
    The use case example we saw earlier is one of the most common uses of properties;
    we have some data on a class that we later want to add behavior to. There are
    also other factors to take into account when deciding to use a property.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于内置的`property`模糊了行为和数据之间的界限，知道何时选择属性、方法或属性可能会令人困惑。我们之前看到的用例示例是属性最常见的使用之一；我们有一个类上的数据，我们稍后想添加行为。在决定使用属性时，还需要考虑其他因素。
- en: Technically, in Python, data, properties, and methods are all attributes on
    a class. The fact that a method is callable does not distinguish it from other
    types of attributes; indeed, we'll see in [Chapter 7](b70c8ea0-4778-4005-af13-bdae3d90d2c6.xhtml),
    *Python Object-Oriented Shortcuts*, that it is possible to create normal objects
    that can be called like functions. We'll also discover that functions and methods
    are themselves normal objects.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，在Python中，数据、属性和方法都是类上的属性。一个方法是可调用的这一事实并不能将其与其他类型的属性区分开来；实际上，我们将在[第7章](b70c8ea0-4778-4005-af13-bdae3d90d2c6.xhtml)，《Python面向对象快捷方式》中看到，可以创建出可以像函数一样调用的普通对象。我们还将发现函数和方法本身也是普通对象。
- en: The fact that methods are just callable attributes, and properties are just
    customizable attributes, can help us make this decision. Methods should typically
    represent actions; things that can be done to, or performed by, the object. When
    you call a method, even with only one argument, it should *do* something. Method
    names are generally verbs.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 方法只是可调用的属性，属性只是可定制的属性这一事实可以帮助我们做出这个决定。方法通常表示动作；可以对对象执行或由对象执行的事情。当你调用一个方法时，即使只有一个参数，它也应该**做**些事情。方法名通常是动词。
- en: Once confirming that an attribute is not an action, we need to decide between
    standard data attributes and properties. In general, always use a standard attribute
    until you need to control access to that property in some way. In either case,
    your attribute is usually a noun. The only difference between an attribute and
    a property is that we can invoke custom actions automatically when a property
    is retrieved, set, or deleted.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确认一个属性不是动作，我们需要在标准数据属性和属性之间做出选择。一般来说，直到你需要以某种方式控制对该属性的访问时，才使用标准属性。在两种情况下，你的属性通常是名词。属性和属性之间的唯一区别是我们可以在属性被检索、设置或删除时自动调用自定义操作。
- en: Let's look at a more realistic example. A common need for custom behavior is
    caching a value that is difficult to calculate or expensive to look up (requiring,
    for example, a network request or database query). The goal is to store the value
    locally to avoid repeated calls to the expensive calculation.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个更实际的例子。自定义行为的常见需求是缓存一个难以计算或查找代价高昂的值（例如，需要网络请求或数据库查询）。目标是存储该值以避免重复调用昂贵的计算。
- en: 'We can do this with a custom getter on the property. The first time the value
    is retrieved, we perform the lookup or calculation. Then, we can locally cache
    the value as a private attribute on our object (or in dedicated caching software),
    and the next time the value is requested, we return the stored data. Here''s how
    we might cache a web page:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在属性上使用自定义获取器来实现这一点。第一次检索值时，我们执行查找或计算。然后，我们可以在我们的对象（或专门的缓存软件）上本地缓存该值作为私有属性，下次请求该值时，我们返回存储的数据。以下是我们可能缓存网页的方式：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can test this code to see that the page is only retrieved once:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以测试这段代码，看看页面是否只检索一次：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'I was on an awful satellite connection when I originally tested this code for
    the first version of this book back in 2010 and it took 20 seconds the first time
    I loaded the content. The second time, I got the result in 2 seconds (which is
    really just the amount of time it took to type the lines into the interpreter).
    On my more modern connection it looks as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在2010年测试这本书的第一版时，我原本在一个糟糕的卫星连接上，第一次加载内容时花费了20秒。第二次，我用了2秒（这实际上只是将行输入解释器所需的时间）。在我的更现代的连接上，它看起来如下所示：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It takes about 620 milliseconds to retrieve a page from my web host. From my
    laptop's RAM, it takes 0.018 milliseconds!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从我的网络主机检索一个页面大约需要620毫秒。从我的笔记本电脑的RAM中，它只需要0.018毫秒！
- en: 'Custom getters are also useful for attributes that need to be calculated on
    the fly, based on other object attributes. For example, we might want to calculate
    the average for a list of integers:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义获取器对于需要根据其他对象属性动态计算属性的情况也非常有用。例如，我们可能想要计算一系列整数的平均值：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This very simple class inherits from `list`, so we get list-like behavior for
    free. We just add a property to the class, and hey presto, our list can have an
    average as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个非常简单的类从`list`继承，因此我们免费获得了类似列表的行为。我们只需向类中添加一个属性，嘿，我们的列表就可以有平均值了，如下所示：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Of course, we could have made this a method instead, but then we ought to call
    it `calculate_average()`, since methods represent actions. But a property called
    `average` is more suitable, and is both easier to type and easier to read.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们本可以将这做成一个方法，但那时我们应该将其命名为`calculate_average()`，因为方法代表动作。但名为`average`的属性更合适，它既容易输入也容易阅读。
- en: Custom setters are useful for validation, as we've already seen, but they can
    also be used to proxy a value to another location. For example, we could add a
    content setter to the `WebPage` class that automatically logs into our web server
    and uploads a new page whenever the value is set.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义设置器在验证方面很有用，正如我们之前所看到的，但它们也可以用来代理一个值到另一个位置。例如，我们可以在`WebPage`类中添加一个内容设置器，每当值被设置时，它会自动登录我们的网络服务器并上传一个新页面。
- en: Manager objects
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理对象
- en: We've been focused on objects and their attributes and methods. Now, we'll take
    a look at designing higher-level objects; the kind of objects that manage other
    objects – the objects that tie everything together.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直关注对象及其属性和方法。现在，我们将探讨设计更高级的对象；那些管理其他对象的对象——那些将一切联系在一起的对象。
- en: The difference between these objects and most of the previous examples is that
    the latter usually represent concrete ideas. Management objects are more like
    office managers; they don't do the actual *visible* work out on the floor, but
    without them, there would be no communication between departments and nobody would
    know what they are supposed to do (although, this can be true anyway if the organization
    is badly managed!). Analogously, the attributes on a management class tend to
    refer to other objects that do the *visible* work; the behaviors on such a class
    delegate to those other classes at the right time, and pass messages between them.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象与之前的大多数示例之间的区别在于，后者通常代表具体的概念。管理对象更像是办公室经理；他们不在现场做实际的*可见*工作，但没有他们，部门之间就没有沟通，没有人知道他们应该做什么（尽管，如果组织管理不善，这也可能是真的！）。类似地，管理类上的属性往往指的是做*可见*工作的其他对象；此类上的行为在适当的时候委托给其他类，并在它们之间传递消息。
- en: 'As an example, we''ll write a program that does a find-and-replace action for
    text files stored in a compressed ZIP file. We''ll need objects to represent the
    ZIP file and each individual text file (luckily, we don''t have to write these
    classes, as they''re available in the Python standard library). The manager object
    will be responsible for ensuring the following three steps occur in order:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将编写一个程序，对存储在压缩ZIP文件中的文本文件执行查找和替换操作。我们需要对象来表示ZIP文件和每个单独的文本文件（幸运的是，我们不需要编写这些类，因为它们在Python标准库中可用）。管理对象将负责确保以下三个步骤按顺序发生：
- en: Unzipping the compressed file
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压压缩文件
- en: Performing the find-and-replace action
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行查找和替换操作
- en: Zipping up the new files
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 压缩新文件
- en: 'The class is initialized with the `.zip` filename, and search and replace strings.
    We create a temporary directory to store the unzipped files in, so that the folder
    stays clean. The `pathlib` library helps out with file and directory manipulation.
    We''ll learn more about it in [Chapter 8](9a6335a2-1c69-4fa8-a685-02bbeeba23be.xhtml),
    *Strings and Serialization*, but the interface should be pretty clear in the following
    example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 类使用`.zip`文件名、搜索和替换字符串进行初始化。我们创建一个临时目录来存储解压的文件，这样文件夹就可以保持干净。`pathlib`库帮助处理文件和目录操作。我们将在[第8章](9a6335a2-1c69-4fa8-a685-02bbeeba23be.xhtml)中了解更多关于它的信息，*字符串和序列化*，但以下示例中的接口应该相当清晰：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we create an overall *manager* method for each of the three steps. This
    method delegates responsibility to other objects:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为每个步骤创建一个总的*管理*方法。这个方法将责任委托给其他对象：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Obviously, we could do all three steps in one method, or indeed in one script,
    without ever creating an object. There are several advantages to separating the
    three steps:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们可以在一个方法中完成这三个步骤，或者在一个脚本中完成，而不需要创建对象。分离这三个步骤有几个优点：
- en: '**Readability**: The code for each step is in a self-contained unit that is
    easy to read and understand. The method name describes what the method does, and
    less additional documentation is required to understand what is going on.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可读性**：每个步骤的代码都是一个自包含的单元，易于阅读和理解。方法名描述了方法的作用，不需要额外的文档就可以理解正在发生的事情。'
- en: '**Extensibility**: If a subclass wanted to use compressed TAR files instead
    of ZIP files, it could override the `zip` and `unzip` methods without having to
    duplicate the `find_replace` method.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：如果子类想使用压缩TAR文件而不是ZIP文件，它可以覆盖`zip`和`unzip`方法，而无需重复`find_replace`方法。'
- en: '**Partitioning**: An external class could create an instance of this class
    and call the `find_replace` method directly on some folder without having to `zip`
    the content.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分区**：外部类可以创建这个类的实例，并直接在某个文件夹上调用`find_replace`方法，而无需压缩内容。'
- en: 'The delegation method is the first in the following code; the rest of the methods
    are included for completeness:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 委派方法是以下代码中的第一个；其余的方法包括为了完整性：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: For brevity, the code for zipping and unzipping files is sparsely documented.
    Our current focus is on object-oriented design; if you are interested in the inner
    details of the `zipfile` module, refer to the documentation in the standard library,
    either online or by typing `import zipfile ; help(zipfile)` into your interactive
    interpreter. Note that this toy example only searches the top-level files in a
    ZIP file; if there are any folders in the unzipped content, they will not be scanned,
    nor will any files inside those folders.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁，对文件压缩和解压缩的代码只有很少的文档说明。我们目前的重点是面向对象设计；如果你对`zipfile`模块的内部细节感兴趣，可以参考标准库中的文档，无论是在线还是通过在你的交互式解释器中输入`import
    zipfile ; help(zipfile)`来查看。请注意，这个玩具示例只搜索ZIP文件中的顶级文件；如果解压内容中包含任何文件夹，它们将不会被扫描，文件夹内的任何文件也不会被扫描。
- en: If you are using a Python version older than 3.6, you will need to convert the
    path objects to strings before calling `extractall`, `rmtree`, and `file.write`
    on the `ZipFile` object.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是低于3.6版本的Python，在调用`extractall`、`rmtree`和`file.write`在`ZipFile`对象上之前，你需要将路径对象转换为字符串。
- en: 'The last two lines in the example allow us to run the program from the command
    line by passing the `zip` filename, the search string, and the replace string
    as arguments, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中的最后两行允许我们通过传递`zip`文件名、搜索字符串和替换字符串作为参数，从命令行运行程序，如下所示：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Of course, this object does not have to be created from the command line; it
    could be imported from another module (to perform batch ZIP file processing),
    or accessed as part of a GUI interface or even a higher-level management object
    that knows where to get ZIP files (for example, to retrieve them from an FTP server
    or back them up to an external disk).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个对象不必从命令行创建；它可以从另一个模块导入（以执行批量ZIP文件处理），或作为GUI界面的一部分访问，甚至是一个更高级的管理对象，该对象知道在哪里获取ZIP文件（例如，从FTP服务器检索或将其备份到外部磁盘）。
- en: As programs become more and more complex, the objects being modeled become less
    and less like physical objects. Properties are other abstract objects, and methods
    are actions that change the state of those abstract objects. But at the heart
    of every object, no matter how complex, is a set of concrete data and well-defined
    behaviors.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 随着程序变得越来越复杂，被建模的对象越来越不像物理对象。属性是其他抽象对象，方法则是改变这些抽象对象状态的动作。但无论对象多么复杂，其核心总是一组具体数据和定义良好的行为。
- en: Removing duplicate code
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除重复代码
- en: Often, the code in management style classes such as `ZipReplace` is quite generic
    and can be applied in a variety of ways. It is possible to use either composition
    or inheritance to help keep this code in one place, thus eliminating duplicate
    code. Before we look at any examples of this, let's discuss a tiny bit of theory.
    Specifically, why is duplicate code a bad thing?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 经常，管理风格课程中的代码，如`ZipReplace`，相当通用，可以以多种方式应用。可以使用组合或继承来帮助将此代码保留在一个地方，从而消除重复代码。在我们查看任何此类示例之前，让我们先讨论一点理论。具体来说，为什么重复代码是件坏事？
- en: There are several reasons, but they all boil down to readability and maintainability.
    When we're writing a new piece of code that is similar to an earlier piece, the
    easiest thing to do is copy the old code and change whatever needs to be changed
    (variable names, logic, comments) to make it work in the new location. Alternatively,
    if we're writing new code that seems similar, but not identical, to code elsewhere
    in the project, it is often easier to write fresh code with similar behavior,
    rather than figuring out how to extract the overlapping functionality.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个原因，但它们都归结为可读性和可维护性。当我们编写一个与早期代码相似的新代码时，最简单的事情就是复制旧代码，并根据需要更改（变量名、逻辑、注释）以使其在新位置工作。或者，如果我们编写的新代码似乎与项目中的其他代码相似，但又不完全相同，那么编写具有相似行为的全新代码通常比找出如何提取重叠功能要容易得多。
- en: But as soon as someone has to read and understand the code and they come across
    duplicate blocks, they are faced with a dilemma. Code that might have appeared
    to make sense suddenly has to be understood. How is one section different from
    the other? How are they the same? Under what conditions is one section called?
    When do we call the other? You might argue that you're the only one reading your
    code, but if you don't touch that code for eight months, it will be as incomprehensible
    to you as it is to a fresh coder. When we're trying to read two similar pieces
    of code, we have to understand why they're different, as well as how they're different.
    This wastes the reader's time; code should always be written to be readable first.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 但一旦有人需要阅读和理解代码，并遇到重复的代码块，他们就会面临一个困境。原本可能看起来有意义的代码突然需要被理解。这一部分与另一部分有何不同？它们有何相同之处？在什么条件下调用一个部分？何时调用另一个？你可能认为只有你一个人会阅读你的代码，但如果你八个月不接触那段代码，它对你来说将像对一个新手程序员一样难以理解。当我们试图阅读两段相似的代码时，我们必须理解它们为什么不同，以及它们是如何不同的。这浪费了读者的时间；代码应该首先易于阅读。
- en: I once had to try to understand someone's code that had three identical copies
    of the same 300 lines of very poorly written code. I had been working with the
    code for a month before I finally comprehended that the three *identical* versions
    were actually performing slightly different tax calculations. Some of the subtle
    differences were intentional, but there were also obvious areas where someone
    had updated a calculation in one function without updating the other two. The
    number of subtle, incomprehensible bugs in the code could not be counted. I eventually
    replaced all 900 lines with an easy-to-read function of 20 lines or so.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经不得不尝试理解某人的代码，这段代码中有三份完全相同的300行糟糕的代码。我在这个代码上工作了整整一个月，才最终明白这三份**相同**的版本实际上执行的是略微不同的税务计算。其中一些细微的差异是有意为之，但也有明显的地方，有人在更新了一个函数中的计算时，没有更新其他两个函数。代码中细微、难以理解的错误数量无法计数。我最终用大约20行的易读函数替换了所有900行。
- en: Reading such duplicate code can be tiresome, but code maintenance is even more
    tormenting. As the preceding story suggests, keeping two similar pieces of code
    up to date can be a nightmare. We have to remember to update both sections whenever
    we update one of them, and we have to remember how multiple sections differ so
    we can modify our changes when we are editing each of them. If we forget to update
    all sections, we will end up with extremely annoying bugs that usually manifest
    themselves as, But I fixed that already, why is it still happening*?*
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读这样的重复代码可能会感到疲倦，但代码维护更是折磨。正如前面的故事所暗示的，保持两段相似代码的更新状态可能是一场噩梦。我们必须记住在更新其中一个时更新两个部分，并且我们必须记住多个部分之间的差异，以便在编辑每个部分时修改我们的更改。如果我们忘记更新所有部分，我们最终会得到极其烦人的错误，这些错误通常表现为，“我已经修复了那个，为什么它还在发生”？
- en: The result is that people who are reading or maintaining our code have to spend
    astronomical amounts of time understanding and testing it compared to the time
    required to write it in a non-repetitive manner in the first place. It's even
    more frustrating when we are the ones doing the maintenance; we find ourselves
    saying, Why didn't I do this right the first time? The time we save by copying
    and pasting existing code is lost the very first time we have to maintain it.
    Code is both read and modified many more times and much more often than it is
    written. Comprehensible code should always be a priority.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，阅读或维护我们代码的人必须花费天文数字般的时间来理解和测试它，与最初以非重复方式编写它所需的时间相比。当我们自己进行维护时，这甚至更加令人沮丧；我们会发现自己说，为什么我没有一开始就做得正确？通过复制和粘贴现有代码节省的时间，在第一次维护它时就已经丢失了。代码被阅读和修改的次数比它被编写的次数多得多，也更为频繁。可理解的代码始终应该是优先考虑的。
- en: This is why programmers, especially Python programmers (who tend to value elegant
    code more than average developers), follow what is known as the **Don't Repeat
    Yourself** (**DRY**) principle. DRY code is maintainable code. My advice for beginning
    programmers is to never use the copy-and-paste feature of their editor. To intermediate
    programmers, I suggest they think thrice before they hit *Ctrl* + *C*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么程序员，尤其是Python程序员（他们往往比普通开发者更重视优雅的代码），遵循所谓的**不要重复自己**（**DRY**）原则。DRY代码是可维护的代码。我对初学者的建议是永远不要使用编辑器的复制粘贴功能。对于中级程序员，我建议他们在按下*Ctrl*
    + *C*之前三思。
- en: But what should we do instead of code duplication? The simplest solution is
    often to move the code into a function that accepts parameters to account for
    whatever parts are different. This isn't a terribly object-oriented solution,
    but it is frequently optimal.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们除了代码重复之外还能做什么呢？最简单的解决方案通常是将其移动到函数中，该函数接受参数以处理任何不同的部分。这不是一个特别面向对象的解决方案，但它通常是最佳选择。
- en: For example, if we have two pieces of code that unzip a ZIP file into two different
    directories, we can easily replace it with a function that accepts a parameter
    for the directory to which it should be unzipped. This may make the function itself
    slightly more difficult to read, but a good function name and docstring can easily
    make up for that, and any code that invokes the function will be easier to read.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有两个将ZIP文件解压到两个不同目录的代码片段，我们可以轻松地用一个接受参数的函数来替换它，该参数指定了它应该解压到的目录。这可能会使函数本身稍微难以阅读，但一个好的函数名和文档字符串可以轻松弥补这一点，并且任何调用该函数的代码都将更容易阅读。
- en: 'That''s certainly enough theory! The moral of the story is: always make the
    effort to refactor your code to be easier to read instead of writing bad code
    that may seem easier to write.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 理论已经足够多了！这个故事的意义是：总是努力重构你的代码，使其更易于阅读，而不是编写可能看起来更容易编写但质量较差的代码。
- en: In practice
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在实践中
- en: Let's explore two ways we can reuse existing code. After writing our code to
    replace strings in a ZIP file full of text files, we are later contracted to scale
    all the images in a ZIP file to 640 x 480\. It looks like we could use a very
    similar paradigm to what we used in `ZipReplace`. Our first impulse might be to
    save a copy of that file and change the `find_replace` method to `scale_image`
    or something similar.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索两种我们可以重用现有代码的方法。在编写了替换文本文件ZIP文件中的字符串的代码之后，我们后来被委托去将ZIP文件中的所有图片缩放到640 x
    480。看起来我们可以使用与`ZipReplace`中使用的非常相似的模式。我们的第一个冲动可能是保存该文件的副本，并将`find_replace`方法更改为`scale_image`或类似的方法。
- en: But, that's suboptimal. What if someday we want to change the `unzip` and `zip`
    methods to also open TAR files? Or maybe we'll want to use a guaranteed unique
    directory name for temporary files. In either case, we'd have to change it in
    two different places!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这并不理想。如果我们有一天想将`unzip`和`zip`方法也改为打开TAR文件怎么办？或者我们可能希望为临时文件使用一个保证唯一的目录名称。在任何情况下，我们都必须在不同地方进行更改！
- en: 'We''ll start by demonstrating an inheritance-based solution to this problem.
    First, we''ll modify our original `ZipReplace` class into a superclass for processing
    generic ZIP files:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先演示一个基于继承的解决方案。首先，我们将修改原始的`ZipReplace`类，使其成为处理通用ZIP文件的超类：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We changed the `filename` property to `zipname` to avoid confusion with the
    `filename` local variables inside the various methods. This helps make the code
    more readable, even though it isn't actually a change in design.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`filename`属性更改为`zipname`，以避免与各种方法内部的`filename`局部变量混淆。这有助于使代码更易于阅读，尽管这实际上并不是设计上的改变。
- en: We also dropped the two parameters to `__init__` (`search_string` and `replace_string`)
    that were specific to `ZipReplace`. Then, we renamed the `zip_find_replace` method
    to `process_zip` and made it call an (as yet undefined) `process_files` method
    instead of `find_replace`; these name changes help demonstrate the more generalized
    nature of our new class. Notice that we have removed the `find_replace` method
    altogether; that code is specific to `ZipReplace` and has no business here.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还删除了`__init__`方法中的两个特定于`ZipReplace`的参数（`search_string`和`replace_string`）。然后，我们将`zip_find_replace`方法重命名为`process_zip`，并让它调用一个尚未定义的`process_files`方法而不是`find_replace`；这些名称更改有助于展示我们新类更通用的特性。请注意，我们已经完全删除了`find_replace`方法；这段代码是特定于`ZipReplace`的，并且在这里没有存在的必要。
- en: This new `ZipProcessor` class doesn't actually define a `process_files` method.
    If we ran it directly, it would raise an exception. Because it isn't meant to
    run directly, we removed the main call at the bottom of the original script. We
    could make this an abstract base class in order to communicate that this method
    needs to be defined in a subclass, but I've left it out for brevity.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的`ZipProcessor`类实际上并没有定义`process_files`方法。如果我们直接运行它，它会引发异常。因为它不是用来直接运行的，所以我们删除了原始脚本底部的main调用。我们可以将其制作成一个抽象基类，以表明这个方法需要在子类中定义，但我为了简洁起见省略了它。
- en: 'Now, before we move on to our image processing application, let''s fix up our
    original `zipsearch` class to make use of this parent class, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们继续到图像处理应用程序之前，让我们修复原始的`zipsearch`类，使其能够使用这个父类，如下所示：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This code is shorter than the original version, since it inherits its ZIP processing
    abilities from the parent class. We first import the base class we just wrote
    and make `ZipReplace` extend that class. Then, we use `super()` to initialize
    the parent class. The `find_replace` method is still here, but we renamed it `process_files`
    so the parent class can call it from its management interface. Because this name
    isn't as descriptive as the old one, we added a docstring to describe what it
    is doing.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码比原始版本更短，因为它从父类继承了ZIP处理能力。我们首先导入我们刚刚编写的基类，并让`ZipReplace`扩展这个类。然后，我们使用`super()`来初始化父类。`find_replace`方法仍然存在，但我们将其重命名为`process_files`，这样父类就可以从其管理界面调用它。因为这个名称不如原来的名称描述性强，所以我们添加了一个文档字符串来描述它的功能。
- en: Now, that was quite a bit of work, considering that all we have now is a program
    that is functionally not different from the one we started with! But having done
    that work, it is now much easier for us to write other classes that operate on
    files in a ZIP archive, such as the (hypothetically requested) photo scaler. Further,
    if we ever want to improve or bug fix the zip functionality, we can do it for
    all subclasses at once by changing only the one `ZipProcessor` base class. Therefore
    maintenance will be much more effective.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的工作量相当大，考虑到我们现在拥有的程序在功能上与我们开始时使用的程序没有区别！但是，完成了这项工作后，我们现在写其他操作 ZIP 存档中文件的类（例如，假设请求的）照片缩放器就变得容易多了。此外，如果我们想改进或修复
    zip 功能的 bug，我们只需更改一个 `ZipProcessor` 基类，就可以一次性为所有子类进行操作。因此，维护将更加有效。
- en: 'See how simple it is now to create a photo scaling class that takes advantage
    of the `ZipProcessor` functionality:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 看看现在创建一个利用 `ZipProcessor` 功能的照片缩放类是多么简单：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Look how simple this class is! All that work we did earlier paid off. All we
    do is open each file (assuming that it is an image; it will unceremoniously crash
    if a file cannot be opened or isn't an image), scale it, and save it back. The
    `ZipProcessor` class takes care of the zipping and unzipping without any extra
    work on our part.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个类是多么简单！我们之前所做的所有工作都得到了回报。我们只是打开每个文件（假设它是图像；如果文件无法打开或不是图像，它将无礼地崩溃），将其缩放，并保存回去。`ZipProcessor`
    类负责压缩和解压缩，而无需我们做任何额外的工作。
- en: Case study
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: For this case study, we'll try to delve further into the question, When should
    I choose an object versus a built-in type? We'll be modeling a `Document` class
    that might be used in a text editor or word processor. What objects, functions,
    or properties should it have?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个案例研究，我们将尝试进一步探讨这个问题：我应该何时选择对象而不是内置类型？我们将模拟一个可能在文本编辑器或文字处理器中使用的 `Document`
    类。它应该有什么对象、函数或属性？
- en: We might start with a `str` for the `Document` contents, but in Python, strings
    aren't mutable (able to be changed). Once a `str` is defined, it is forever. We
    can't insert a character into it or remove one without creating a brand new string
    object. That would be leaving a lot of `str` objects taking up memory until Python's
    garbage collector sees fit to clean up behind us.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能从 `Document` 内容的 `str` 开始，但在 Python 中，字符串是不可变的（不能被更改）。一旦定义了一个 `str`，它就永远不变。我们无法在不创建一个新的字符串对象的情况下向其中插入字符或删除一个字符。这样就会留下很多占用内存的
    `str` 对象，直到 Python 的垃圾回收器决定清理。
- en: So, instead of a string, we'll use a list of characters, which we can modify
    at will. In addition, we'll need to know the current cursor position within the
    list, and should probably also store a filename for the document.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不会使用字符串，而会使用字符列表，我们可以随意修改它。此外，我们还需要知道列表中的当前光标位置，并且可能还需要存储文档的文件名。
- en: Real text editors use a binary tree-based data structure called a `rope` to
    model their document contents. This book's title isn't *Advanced Data Structures*,
    so if you're interested in learning more about this fascinating topic, you may
    want to search the web for *rope data structure*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 真实的文本编辑器使用基于二叉树的数据结构，称为 `rope` 来模拟它们的文档内容。这本书的标题不是《高级数据结构》，所以如果你对了解更多关于这个有趣的主题感兴趣，你可能想在网上搜索
    `rope 数据结构`。
- en: There are a lot of things we might want to do to a text document, including
    inserting, deleting, and selecting characters; cutting, copying, and, pasting
    the selection; and saving or closing the document. It looks like there are copious
    amounts of both data and behavior, so it makes sense to put all this stuff into
    its own `Document` class.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想要对文本文档做很多事情，包括插入、删除和选择字符；剪切、复制和粘贴选择；以及保存或关闭文档。看起来有大量的数据和操作，所以将这些所有东西放入一个单独的
    `Document` 类中是有意义的。
- en: 'A pertinent question is: should this class be composed of a bunch of basic
    Python objects such as `str` filenames, `int` cursor positions, and a `list` of
    characters? Or should some or all of those things be specially defined objects
    in their own right? What about individual lines and characters? Do they need to
    have classes of their own?'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相关的问题是：这个类应该由一些基本的 Python 对象组成，如 `str` 文件名、`int` 光标位置和一个字符的 `list`？或者，这些中的某些或所有东西应该被特别定义的对象？关于单独的行和字符呢？它们需要有自己的类吗？
- en: 'We''ll answer these questions as we go, but let''s start with the simplest
    possible class first- `Document`  and see what it can do:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在进行过程中回答这些问题，但让我们首先从最简单的类开始——`Document`，看看它能做什么：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This basic class allows us full control over editing a basic document. Have
    a look at it in action:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基本类允许我们完全控制编辑一个基本文档。看看它在实际操作中的表现：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It looks like it's working. We could connect a keyboard's letter and arrow keys
    to these methods and the document would track everything just fine.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来是正常工作的。我们可以将这些方法连接到键盘的字母键和箭头键上，这样文档就可以跟踪一切了。
- en: 'But what if we want to connect more than just arrow keys. What if we want to
    connect the *Home* and *End* keys as well? We could add more methods to the `Document`
    class that search forward or backward for newline characters (a newline character,
    escaped as `\n`, represents the end of one line and the beginning of a new one)
    in the string and jump to them, but if we did that for every possible movement
    action (move by words, move by sentences, *Page Up*, *P**age Down*, end of line,
    beginning of white space, and others), the class would be huge. Maybe it would
    be better to put those methods on a separate object. So, let''s turn the `Cursor`
    attribute into an object that is aware of its position and can manipulate that
    position. We can move the forward and back methods to that class, and add a couple
    more for the `Home` and `End` keys, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们想连接的不仅仅是箭头键呢？如果我们还想连接 `Home` 和 `End` 键呢？我们可以在 `Document` 类中添加更多方法，这些方法在字符串中向前或向后搜索换行字符（换行字符，转义为
    `\n`，代表一行结束和下一行的开始），并跳转到它们，但如果为每个可能的移动动作（按单词移动、按句子移动、*Page Up*、*Page Down*、行尾、空白开始等）都这样做，类将会变得非常大。也许将这些方法放在一个单独的对象上会更好。所以，让我们将
    `Cursor` 属性转换成一个知道其位置并能操作该位置的对象。我们可以将向前和向后方法移动到那个类中，并为 `Home` 和 `End` 键添加几个更多的方法，如下所示：
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This class takes the document as an initialization parameter so the methods
    have access to the content of the document's character list. It then provides
    simple methods for moving backward and forward, as before, and for moving to the `home`
    and `end` positions.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将文档作为初始化参数，因此方法可以访问文档字符列表的内容。然后它提供了简单的向前和向后移动方法，就像之前一样，以及移动到 `home` 和 `end`
    位置的方法。
- en: This code is not very safe. You can very easily move past the ending position,
    and if you try to go home on an empty file, it will crash. These examples are
    kept short to make them readable, but that doesn't mean they are defensive! You
    can improve the error checking of this code as an exercise; it might be a great
    opportunity to expand your exception-handling skills.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码并不十分安全。你很容易就会移动到结束位置，如果你尝试在一个空文件上回到起始位置，它将会崩溃。这些示例被保持得比较短，以便于阅读，但这并不意味着它们是防御性的！你可以作为一个练习来改进这段代码的错误检查；这可能是一个扩展你的异常处理技能的绝佳机会。
- en: 'The `Document` class itself is hardly changed, except for removing the two
    methods that were moved to the `Cursor` class:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`Document` 类本身几乎没有变化，除了移除了移动到 `Cursor` 类的两个方法：'
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We just updated anything that accessed the old cursor integer to use the new
    object instead. We can now test that the `home` method is really moving to the
    newline character, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚更新了所有访问旧光标整数的代码，以使用新对象。现在我们可以测试 `home` 方法是否真的移动到了换行字符，如下所示：
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, since we''ve been using that string `join` function a lot (to concatenate
    the characters so we can see the actual document contents), we can add a property
    to the `Document` class to give us the complete string as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，因为我们已经大量使用了那个字符串 `join` 函数（用于连接字符，以便我们可以看到实际的文档内容），我们可以在 `Document` 类中添加一个属性，以提供完整的字符串，如下所示：
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This makes our testing a little simpler:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们的测试变得稍微简单一些：
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This framework is simple to extend, create and edit a complete plain text document
    (though it might be a bit time consuming!) Now, let's extend it to work for rich
    text; text that can have **bold**, underlined, or *italic* characters.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个框架简单易扩展，可以创建和编辑一个完整的纯文本文档（尽管可能需要一点时间！）现在，让我们扩展它以支持富文本；可以包含**粗体**、下划线或*斜体*字符的文本。
- en: There are two ways we could process this. The first is to insert *fake* characters
    into our character list that act like instructions, such as *bold characters until
    you find a stop bold character*. The second is to add information to each character,
    indicating what formatting it should have. While the former method is more common
    in real editors, we'll implement the latter solution. To do that, we're obviously
    going to need a class for characters. This class will have an attribute representing
    the character, as well as three Boolean attributes representing whether it is
    *bold, italic, or underlined*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有两种处理方式。第一种是在我们的字符列表中插入*假的*字符，它们像指令一样工作，例如*直到找到停止粗体的字符为止，粗体字符*。第二种是在每个字符上添加信息，指示它应该有什么格式。虽然前一种方法在实际编辑器中更为常见，但我们将实现后一种解决方案。为了做到这一点，显然我们需要一个字符类。这个类将有一个表示字符的属性，以及三个布尔属性，表示它是否是*粗体、斜体或下划线*。
- en: Hmm, wait! Is this `Character` class going to have any methods? If not, maybe
    we should use one of the many Python data structures instead; a tuple or named
    tuple would probably be sufficient. Are there any actions that we would want to
    execute or invoke on a character?
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，等等！这个`Character`类会有任何方法吗？如果没有，也许我们应该使用许多Python数据结构中的任何一个；一个元组或命名元组可能就足够了。我们会对字符执行或调用哪些操作？
- en: Well, clearly, we might want to do things with characters, such as delete or
    copy them, but those are things that need to be handled at the `Document` level,
    since they are really modifying the list of characters. Are there things that
    need to be done to individual characters?
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，我们可能想要对字符做一些事情，比如删除或复制它们，但这些事情需要在`Document`级别处理，因为它们实际上是在修改字符列表。对单个字符需要做些什么？
- en: Actually, now that we're thinking about what a `Character` class actually **is**...
    what is it? Would it be safe to say that a `Character` class is a string? Maybe
    we should use an inheritance relationship here? Then we can take advantage of
    the numerous methods that `str` instances come with.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，现在我们正在思考一个`Character`类实际上**是什么**...它是什么？我们是否可以说`Character`类就是一个字符串？也许我们应该在这里使用继承关系？这样我们就可以利用`str`实例所带的众多方法。
- en: What sorts of methods are we talking about? There's `startswith`, `strip`, `find`,
    `lower`, and many more. Most of these methods expect to be working on strings
    that contain more than one character. In contrast, if `Character` were to subclass
    `str`, we'd probably be wise to override `__init__` to raise an exception if a
    multi-character string were supplied. Since all those methods we'd get for free
    wouldn't really apply to our `Character` class, it seems we shouldn't use inheritance,
    after all.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在谈论哪些方法呢？有`startswith`、`strip`、`find`、`lower`等等。大多数这些方法都期望在包含多个字符的字符串上工作。相比之下，如果`Character`类继承自`str`，我们可能明智地重写`__init__`方法，在提供多字符字符串时抛出异常。由于那些我们免费获得的方法实际上并不适用于我们的`Character`类，所以最终看来我们不应该使用继承。
- en: 'This brings us back to our original question; should `Character` even be a
    class? There is a very important special method on the `object` class that we
    can take advantage of to represent our characters. This method, called `__str__`
    (two underscores at each end, like `__init__`), is used in string-manipulation
    functions such as `print` and the `str` constructor to convert any class to a
    string. The default implementation does some boring stuff, such as printing the
    name of the module and class, and its address in memory. But if we override it,
    we can make it print whatever we like. For our implementation, we could make it
    prefix characters with special characters to represent whether they are bold,
    italic, or underlined. So, we will create a class to represent a character, and
    here it is:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这又带我们回到了最初的问题；`Character`甚至应该是一个类吗？`object`类中有一个非常重要的特殊方法，我们可以利用它来表示我们的字符。这个方法叫做`__str__`（两端各两个下划线，就像`__init__`一样），在字符串操作函数如`print`和`str`构造函数中使用，用于将任何类转换为字符串。默认实现做了一些无聊的事情，比如打印模块和类的名称，以及它在内存中的地址。但如果我们重写它，我们可以让它打印我们想要的任何内容。对于我们的实现，我们可以让它在字符前加上特殊字符来表示它们是粗体、斜体还是下划线。因此，我们将创建一个表示字符的类，这就是它：
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This class allows us to create characters and prefix them with a special character
    when the `str()` function is applied to them. Nothing too exciting there. We only
    have to make a few minor modifications to the `Document` and `Cursor` classes
    to work with this class. In the `Document` class, we add these two lines at the
    beginning of the `insert` method, as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类允许我们在应用`str()`函数时为字符创建前缀特殊字符。这并没有什么激动人心的地方。我们只需要对`Document`和`Cursor`类进行一些小的修改，以便与这个类一起工作。在`Document`类中，我们在`insert`方法的开始处添加这两行，如下所示：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is a rather strange bit of code. Its basic purpose is to check whether
    the character being passed in is a `Character` or a `str`. If it is a string,
    it is wrapped in a `Character` class so all objects in the list are `Character`
    objects. However, it is entirely possible that someone using our code would want
    to use a class that is neither a `Character` nor a string, using duck typing.
    If the object has a character attribute, we assume it is a `Character`-like object.
    But if it does not, we assume it is a `str`-like object and wrap it in `Character`.
    This helps the program take advantage of duck typing as well as polymorphism;
    as long as an object has a character attribute, it can be used in the `Document`
    class.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码相当奇怪。它的基本目的是检查传入的字符是否是`Character`或`str`。如果是字符串，它会被包裹在`Character`类中，这样列表中的所有对象都是`Character`对象。然而，完全有可能有人使用我们的代码，想要使用既不是`Character`也不是字符串的类，使用鸭子类型。如果对象有一个字符属性，我们假设它是一个类似`Character`的对象。但如果它没有，我们假设它是一个类似`str`的对象，并将其包裹在`Character`中。这有助于程序利用鸭子类型和多态；只要一个对象有一个字符属性，它就可以在`Document`类中使用。
- en: This generic check could be very useful. For example, if we wanted to make a
    programmer's editor with syntax highlighting, we'd need extra data on the character,
    such as what type of syntax token the character belongs to. Note that, if we are
    doing a lot of this kind of comparison, it's probably better to implement `Character`
    as an abstract base class with an appropriate `__subclasshook__`, as discussed
    in [Chapter 3](ba7b3eb7-17cc-4f1c-bb74-fb7d5ee7d517.xhtml), *When Objects Are
    Alike*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这种通用的检查可能非常有用。例如，如果我们想制作一个具有语法高亮的程序员编辑器，我们需要关于字符的额外数据，例如字符属于哪种语法标记类型。请注意，如果我们进行很多这种类型的比较，可能最好将`Character`实现为一个具有适当`__subclasshook__`的抽象基类，正如在第3章中讨论的，*当对象相似时*。
- en: 'In addition, we need to modify the string property on `Document` to accept
    the new `Character` values. All we need to do is call `str()` on each character
    before we join it, as demonstrated in the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要修改`Document`上的字符串属性，以便接受新的`Character`值。我们只需要在连接之前对每个字符调用`str()`，如下所示：
- en: '[PRE39]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This code uses a generator expression, which we'll discuss in [Chapter 9](0abbcae0-eb3f-4237-adda-32765e1cce32.xhtml),
    *The Iterator Pattern*. It's a shortcut to perform a specific action on all the
    objects in a sequence.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用生成器表达式，我们将在第9章中讨论，*迭代器模式*。这是在序列中的所有对象上执行特定操作的快捷方式。
- en: 'Finally, we also need to check `Character.character`, instead of just the string
    character we were storing before, in the `home` and `end` functions when we''re
    looking to see whether it matches a newline character, as demonstrated in the
    following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还需要检查`Character.character`，而不仅仅是之前存储的字符串字符，在`home`和`end`函数中查看它是否匹配换行符时，如下所示：
- en: '[PRE40]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This completes the formatting of characters. We can test it to see that it
    works as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了字符的格式化。我们可以按照以下方式测试它是否正常工作：
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As expected, whenever we print the string, each bold character is preceded by
    a `*` character, each italicized character by a `/` character, and each underlined
    character by a `_` character. All our functions seem to work, and we can modify
    characters in the list after the fact. We have a working rich text document object
    that could be plugged into a proper graphical user interface and hooked up with
    a keyboard for input and a screen for output. Naturally, we'd want to display
    real *bold, italic, and underlined* fonts in a UI, instead of using our `__str__`
    method, but it was sufficient for the basic testing we demanded of it.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，每次我们打印字符串时，每个粗体字符前面都有一个`*`字符，每个斜体字符前面都有一个`/`字符，每个下划线字符前面都有一个`_`字符。我们的所有函数似乎都正常工作，我们可以在事后修改列表中的字符。我们有一个可以连接到适当的图形用户界面并与键盘输入和屏幕输出连接的富文本文档对象。当然，我们希望在UI中显示真正的*粗体、斜体和下划线*字体，而不是使用我们的`__str__`方法，但对于我们要求的基本测试来说，这是足够的。
- en: Exercises
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: We've looked at various ways that objects, data, and methods can interact with
    each other in an object-oriented Python program. As usual, your first thoughts
    should be how you can apply these principles to your own work. Do you have any
    messy scripts lying around that could be rewritten using an object-oriented manager?
    Look through some of your old code and look for methods that are not actions.
    If the name isn't a verb, try rewriting it as a property.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了在面向对象的Python程序中对象、数据和方法如何相互交互的各种方式。像往常一样，你的第一个想法应该是如何将这些原则应用到自己的工作中。你是否有任何混乱的脚本可以使用面向对象的经理重写？查看一些你的旧代码，寻找不是动作的方法。如果名称不是一个动词，尝试将其重写为一个属性。
- en: Think about code you've written in any language. Does it break the DRY principle?
    Is there any duplicate code? Did you copy and paste code? Did you write two versions
    of similar pieces of code because you didn't feel like understanding the original
    code? Go back over some of your recent code now and see whether you can refactor
    the duplicate code using inheritance or composition. Try to pick a project you're
    still interested in maintaining; not code so old that you never want to touch
    it again. That will help to keep you interested when you do the improvements!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 思考一下你在任何语言中编写的代码。它是否违反了DRY原则？是否有任何重复的代码？你是否复制和粘贴了代码？你是否因为不想理解原始代码而编写了两个类似代码的版本？现在回顾一下你最近的一些代码，看看你是否可以使用继承或组合重构重复的代码。尽量选择一个你仍然感兴趣维护的项目；不是那种你永远不会再次触碰的旧代码。这将有助于你在进行改进时保持兴趣！
- en: Now, look back over some of the examples we looked at in this chapter. Start
    with the cached web page example that uses a property to cache the retrieved data.
    An obvious problem with this example is that the cache is never refreshed. Add
    a timeout to the property's getter, and only return the cached page if the page
    has been requested before the timeout has expired. You can use the `time` module
    (`time.time() - an_old_time` returns the number of seconds that have elapsed since
    `an_old_time`) to determine whether the cache has expired.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回顾一下我们在本章中查看的一些示例。从一个使用属性来缓存检索数据的缓存网页示例开始。这个示例的一个明显问题是缓存永远不会刷新。给属性的getter添加一个超时，并且只有当页面在超时之前被请求时才返回缓存的页面。你可以使用`time`模块（`time.time()
    - an_old_time`返回自`an_old_time`以来经过的秒数）来确定缓存是否已过期。
- en: Also look at the inheritance-based `ZipProcessor`. It might be reasonable to
    use composition instead of inheritance here. Instead of extending the class in
    the `ZipReplace` and `ScaleZip` classes, you could pass instances of those classes
    into the `ZipProcessor` constructor and call them to do the processing part. Implement
    this.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 还要看看基于继承的`ZipProcessor`。在这里使用组合而不是继承可能是合理的。你可以在`ZipReplace`和`ScaleZip`类中扩展类，而不是将这些类的实例传递给`ZipProcessor`构造函数并调用它们来执行处理部分。实现这一点。
- en: Which version do you find easier to use? Which is more elegant? What is easier
    to read? These are subjective questions; the answer varies for each of us. Knowing
    the answer, however, is important. If you find you prefer inheritance over composition,
    you need to pay attention that you don't overuse inheritance in your daily coding.
    If you prefer composition, make sure you don't miss opportunities to create an
    elegant inheritance-based solution.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你觉得哪个版本更容易使用？哪个更优雅？哪个更容易阅读？这些问题都是主观的；每个人的答案都不尽相同。然而，知道答案是很重要的。如果你发现你更喜欢继承而不是组合，你需要注意在日常编码中不要过度使用继承。如果你更喜欢组合，确保不要错过创建基于继承的优雅解决方案的机会。
- en: Finally, add some error handlers to the various classes we created in the case
    study. They should ensure single characters are entered, that you don't try to
    move the cursor past the end or beginning of the file, that you don't delete a
    character that doesn't exist, and that you don't save a file without a filename.
    Try to think of as many edge cases as you can, and account for them (thinking
    about edge cases is about 90% of a professional programmer's job!). Consider different
    ways to handle them; should you raise an exception when the user tries to move
    past the end of the file, or just stay on the last character?
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为我们在案例研究中创建的各种类添加一些错误处理器。它们应该确保只输入单个字符，不要尝试将光标移动到文件的末尾或开头，不要删除不存在的字符，并且不要在没有文件名的情况下保存文件。尽量思考尽可能多的边缘情况，并考虑如何处理它们（考虑边缘情况大约是专业程序员工作的90%）！考虑不同的处理方式；当用户尝试移动到文件末尾时，你应该抛出一个异常，还是仅仅停留在最后一个字符上？
- en: In your daily coding, pay attention to the copy and paste commands. Every time
    you use them in your editor, consider whether it would be a good idea to improve
    your program's organization so that you only have one version of the code you
    are about to copy.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的日常编码中，请注意复制和粘贴命令。每次你在编辑器中使用它们时，考虑一下是否是一个改进程序组织的好主意，这样你就可以只保留你即将复制的代码的一个版本。
- en: Summary
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we focused on identifying objects, especially objects that
    are not immediately apparent; objects that manage and control. Objects should
    have both data and behaviors, but properties can be used to blur the distinction
    between the two. The DRY principle is an important indicator of code quality,
    and inheritance and composition can be applied to reduce code duplication.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们专注于识别对象，特别是那些不是立即显而易见的对象；那些管理和控制的对象。对象应该既有数据也有行为，但属性可以被用来模糊两者之间的区别。DRY原则是代码质量的重要指标，继承和组合可以用来减少代码重复。
- en: In the next chapter, we'll cover several of the built-in Python data structures
    and objects, focusing on their object-oriented properties and how they can be
    extended or adapted.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍几个内置的Python数据结构和对象，重点关注它们的面向对象属性以及它们如何被扩展或适应。
