- en: Chapter 1. Creating Your First Flask Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。创建您的第一个Flask应用程序
- en: '*Flask is fun*. This bold declaration is one of the first things you see when
    you view the official Flask documentation and, over the course of this book, you
    will come to understand why so many Python developers agree.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*Flask很有趣*。这是您在查看官方Flask文档时看到的第一件事情之一，而在本书的过程中，您将了解为什么这么多Python开发人员同意这一观点。'
- en: 'In this chapter we shall:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Briefly discuss the features of the Flask framework
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简要讨论Flask框架的特点
- en: Set up a development environment and install Flask
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置开发环境并安装Flask
- en: Implement a minimal Flask app and analyze how it works
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个最小的Flask应用程序并分析其工作原理
- en: Experiment with commonly used APIs and the interactive debugger
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试常用API和交互式调试器
- en: Start working on the blog project that will be progressively enhanced over the
    course of the book
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始着手博客项目，该项目将在本书的过程中逐步增强
- en: What is Flask?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Flask？
- en: 'Flask is a lightweight Web framework written in Python. Flask started out as
    an April fool''s joke that became a highly popular underdog in the Python web
    framework world. It is now one of the most widely used Python web frameworks for
    start-ups, and is becoming commonly accepted as the perfect tool for quick and
    simple solutions in most businesses. At its core, it provides a set of powerful
    libraries for handling the most common web development tasks, such as:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Flask是一个用Python编写的轻量级Web框架。Flask最初是一个愚人节玩笑，后来成为Python Web框架世界中备受欢迎的黑马。它现在是创业公司中最广泛使用的Python
    Web框架之一，并且正在成为大多数企业快速简单解决方案的完美工具。在其核心，它提供了一组强大的库，用于处理最常见的Web开发任务，例如：
- en: URL routing that makes it easy to map URLs to your code
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL路由，使URL映射到您的代码变得容易
- en: Template rendering with Jinja2, one of the most powerful Python template engines
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jinja2进行模板渲染，这是最强大的Python模板引擎之一。
- en: Session management and securing cookies
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话管理和保护Cookie
- en: HTTP request parsing and flexible response handling
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP请求解析和灵活的响应处理
- en: Interactive web-based debugger
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交互式基于Web的调试器
- en: Easy-to-use, flexible application configuration management
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于使用的灵活应用程序配置管理
- en: This book will teach you how to use these tools through practical, real-world
    examples. We will also discuss commonly used third-party libraries for things
    that are not included in Flask, such as database access and form validation. By
    the end of this book you will be ready to tackle your next big project with Flask.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将通过实际的实例教您如何使用这些工具。我们还将讨论Flask中未包含的常用第三方库，例如数据库访问和表单验证。通过本书的学习，您将准备好使用Flask处理下一个大型项目。
- en: With great freedom comes great responsibility
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自由伴随着责任
- en: As the documentation states, *Flask is fun*, but it can also be challenging,
    especially when you are building a large application. Unlike other popular Python
    web frameworks, such as Django, Flask does not enforce ways of structuring your
    modules or your code. If you have experience with other web frameworks, you may
    be surprised how writing applications in Flask feels like writing Python as opposed
    to the framework boilerplate.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如文档所述，*Flask很有趣*，但在构建大型应用程序时可能会具有挑战性。与Django等其他流行的Python Web框架不同，Flask不强制规定模块或代码的结构方式。如果您有其他Web框架的经验，您可能会惊讶于在Flask中编写应用程序感觉像编写Python而不是框架样板。
- en: This book will teach you to use Flask to write clean, expressive applications.
    As you progress through this book, you will not only become a proficient Flask
    developer but you will also become a stronger Python developer.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将教您使用Flask编写清晰、表达力强的应用程序。随着本书的学习，您不仅将成为熟练的Flask开发人员，还将成为更强大的Python开发人员。
- en: Setting up a development environment
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置开发环境
- en: Flask is written in Python, so before we can start writing Flask apps we must
    ensure that Python is installed. Most Linux distributions and recent versions
    of OSX come with Python pre-installed. The examples in this book will require
    Python 2.6 or 2.7\. Instructions for installing Python can be found at [http://www.python.org](http://www.python.org).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Flask是用Python编写的，因此在我们开始编写Flask应用程序之前，我们必须确保已安装Python。大多数Linux发行版和最新版本的OSX都预装了Python。本书中的示例将需要Python
    2.6或2.7。有关安装Python的说明，请访问[http://www.python.org](http://www.python.org)。
- en: If this is your first time using Python, there are a number of excellent resources
    available for free on the web. I would recommend *Learn Python The Hard Way*,
    by *Zed Shaw*, available for free online at [http://learnpythonthehardway.org](http://learnpythonthehardway.org).
    Looking for more? You can find a large list of free Python resources at [http://resrc.io/list/10/list-of-free-programming-books/#python](http://resrc.io/list/10/list-of-free-programming-books/#python).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是您第一次使用Python，网上有许多优秀的免费资源可供使用。我建议阅读*Learn Python The Hard Way*，作者是*Zed Shaw*，可在[http://learnpythonthehardway.org](http://learnpythonthehardway.org)免费在线阅读。还想了解更多？您可以在[http://resrc.io/list/10/list-of-free-programming-books/#python](http://resrc.io/list/10/list-of-free-programming-books/#python)找到大量免费的Python资源。
- en: 'You can verify that Python is installed and that you have the correct version
    by running the Python interactive interpreter from a command prompt:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过从命令提示符运行Python交互解释器来验证Python是否已安装并且您拥有正确的版本：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: At the prompt (`>>>`) type `exit()` and hit *Enter* to leave the interpreter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在提示符（`>>>`）中键入`exit()`并按*Enter*离开解释器。
- en: Supporting Python 3
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持Python 3
- en: This book will include code that is compatible with both Python 2 and Python
    3 where possible. Unfortunately, since Python 3 is still relatively new as compared
    to Python 2, not all third-party packages used in this book are guaranteed to
    work seamlessly with Python 3\. There is a lot of effort being put into making
    popular open-source libraries compatible with both versions but, at the time of
    writing, some libraries have still not been ported. For best results, ensure that
    the version of Python that you have installed on your system is 2.6 or above.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将包含兼容Python 2和Python 3的代码。不幸的是，由于Python 3相对于Python 2仍然相对较新，本书中使用的并非所有第三方包都保证与Python
    3无缝工作。许多人正在努力使流行的开源库与两个版本兼容，但在撰写本文时，仍有一些库尚未移植。为了获得最佳结果，请确保您在系统上安装的Python版本为2.6或更高。
- en: Installing Python packages
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Python包
- en: Now that you have ensured that Python is installed correctly, we will install
    some popular Python packages that will be used over the course of this book.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经确保Python正确安装，我们将安装一些流行的Python包，这些包将在本书的过程中使用。
- en: We will be installing these packages system-wide but, once they are installed,
    we will be working exclusively in virtual environments.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将系统范围内安装这些包，但一旦它们安装完成，我们将专门在虚拟环境中工作。
- en: Installing pip
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装pip
- en: The de-facto Python package installer is `pip` . We will use it throughout the
    book to install Flask and other third-party libraries.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Python包安装程序是`pip`。我们将在整本书中使用它来安装Flask和其他第三方库。
- en: 'If you already have `setuptools` installed, you can install `pip` by simply
    running the following command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经安装了`setuptools`，您可以通过运行以下命令来安装`pip`：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After completing the installation, verify that `pip` is installed correctly:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，请验证`pip`是否正确安装：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The version numbers are likely to change, so for a definitive guide please consult
    the official instructions, which can be found at [http://www.pip-installer.org/en/latest/installing.html](http://www.pip-installer.org/en/latest/installing.html).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 版本号可能会发生变化，因此请参考官方说明，网址为[http://www.pip-installer.org/en/latest/installing.html](http://www.pip-installer.org/en/latest/installing.html)。
- en: Installing virtualenv
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装virtualenv
- en: 'Once pip is installed, we can proceed to install the most important tool in
    any Python developer''s toolkit: `virtualenv`. Virtualenv makes it easy to produce
    isolated Python environments, complete with their own copies of system and third-party
    packages.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了pip之后，我们可以继续安装任何Python开发人员工具包中最重要的工具：`virtualenv`。Virtualenv可以轻松创建隔离的Python环境，其中包括它们自己的系统和第三方包的副本。
- en: Why use virtualenv?
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么使用virtualenv？
- en: Virtualenv solves a number of problems related to package management. Imagine
    you have an old application that was built using a very early version of Flask,
    and you would like to build a new project using the most-recent version of Flask.
    If Flask was installed system-wide, you was be forced to either upgrade your old
    project or write your new project against the old Flask. If both projects were
    using virtualenv, then each could run its own version of Flask, with no conflicts
    or issues.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Virtualenv解决了与包管理相关的许多问题。想象一下，您有一个使用非常早期版本的Flask构建的旧应用程序，您想使用最新版本的Flask构建一个新项目。如果Flask是系统范围内安装的，您将被迫要么升级旧项目，要么针对旧的Flask编写新项目。如果两个项目都使用virtualenv，那么每个项目都可以运行自己的Flask版本，而不会有冲突或问题。
- en: Virtualenv makes it easy to control which versions of the third-party package
    is used by your project.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Virtualenv可以轻松控制项目使用的第三方包的版本。
- en: Another consideration is that installing packages system-wide generally requires
    elevated privileges (`sudo pip install foo`). By using virtualenvs, you can create
    Python environments and install packages as a regular user. This is especially
    useful if you are deploying to a shared hosting environment or are in a situation
    where you do not have administrator privileges.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个考虑因素是，通常需要提升权限（`sudo pip install foo`）才能在系统范围内安装包。通过使用virtualenv，您可以创建Python环境并像普通用户一样安装包。如果您正在部署到共享托管环境或者在没有管理员权限的情况下，这将非常有用。
- en: Installing virtualenv with pip
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用pip安装virtualenv
- en: 'We will use pip to install `virtualenv`; since it is a standard Python package,
    it can be installed just like any other Python package. To ensure that `virtualenv`
    is installed system-wide, run the following command (it requires elevated privileges):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用pip来安装`virtualenv`；因为它是一个标准的Python包，所以可以像安装其他Python包一样安装。为了确保`virtualenv`被系统范围内安装，运行以下命令（需要提升的权限）：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The version numbers are likely to change, so for a definitive guide please consult
    the official instructions at [http://virtualenv.org](http://virtualenv.org).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 版本号可能会发生变化，因此请参考[http://virtualenv.org](http://virtualenv.org)上的官方说明。
- en: Creating your first Flask app
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的第一个Flask应用程序
- en: Now that we have the proper tools installed, we're ready to create our first
    Flask app. To begin, create a directory somewhere convenient that will hold all
    of your Python projects. At the command prompt or terminal, navigate to your projects
    directory; mine is `/home/charles/projects`, or `~/projects` for short on Unix-based
    systems.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了适当的工具，我们准备创建我们的第一个Flask应用程序。首先，在一个方便的地方创建一个目录，用于保存所有的Python项目。在命令提示符或终端中，导航到您的项目目录；我的是`/home/charles/projects`，或者在基于Unix的系统中简写为`~/projects`。
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now we will create a `virtualenv`. The commands below will create a new directory
    named `hello_flask` inside your projects folder that contains a complete, isolated
    Python environment.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一个`virtualenv`。下面的命令将在您的项目文件夹中创建一个名为`hello_flask`的新目录，其中包含一个完整的、隔离的Python环境。
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you list the contents of the `hello_flask` directory, you will see that
    it has created several sub-directories, including a `bin` folder (`Scripts` on
    Windows) that contains copies of both Python and pip. The next step is to activate
    your new virtualenv. The instructions differ depending on whether you are using
    Windows or Mac OS/Linux. To activate your virtualenv refer to the following screenshot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列出`hello_flask`目录的内容，您将看到它创建了几个子目录，包括一个包含Python和pip副本的`bin`文件夹（在Windows上是`Scripts`）。下一步是激活您的新virtualenv。具体的说明因使用Windows还是Mac
    OS/Linux而有所不同。要激活您的virtualenv，请参考以下截图：
- en: '![Creating your first Flask app](img/1709_01_01.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![创建您的第一个Flask应用](img/1709_01_01.jpg)'
- en: Creating the hello_flask virtualenv
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 创建hello_flask virtualenv
- en: When you `activate` a `virtualenv`, your PATH environment variable is temporarily
    modified to ensure that any packages you install or use are restricted to your
    `virtualenv`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当您`激活`一个`virtualenv`时，您的PATH环境变量会被临时修改，以确保您安装或使用的任何软件包都受限于您的`virtualenv`。
- en: Installing Flask in your virtualenv
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在您的virtualenv中安装Flask
- en: Now that we've verified that our `virtualenv` is set up correctly, we can install
    Flask.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经验证了我们的`virtualenv`设置正确，我们可以安装Flask了。
- en: When you are inside a virtualenv, you should never install packages with administrator
    privileges. If you receive a permission error when attempting to install Flask,
    double-check that you have activated your `virtualenv` correctly (you should see
    (`hello_flask`) in your command prompt).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在虚拟环境中时，永远不应该使用管理员权限安装软件包。如果在尝试安装Flask时收到权限错误，请仔细检查您是否正确激活了您的`virtualenv`（您的命令提示符中应该看到(`hello_flask`)）。
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You will see some text scroll by as pip downloads the Flask package and the
    related dependencies before installing it into your virtualenv. Flask depends
    on a couple of additional third-party libraries, which pip will automatically
    download and install for you. Let''s verify that everything is installed properly:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当pip下载Flask包及其相关依赖项并将其安装到您的virtualenv时，您将看到一些文本滚动。Flask依赖于一些额外的第三方库，pip将自动为您下载和安装这些库。让我们验证一下是否一切都安装正确：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Congratulations! You've installed Flask and now we are ready to start coding.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已经安装了Flask，现在我们准备开始编码。
- en: Hello, Flask!
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hello, Flask!
- en: 'Create a new file in the `hello_flask` virtualenv named `app.py`. Using your
    favorite text editor or IDE, enter the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在`hello_flask` virtualenv中创建一个名为`app.py`的新文件。使用您喜欢的文本编辑器或IDE，输入以下代码：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Save the file and then execute `app.py` by running it from the command line.
    You will need to ensure that you have activated the `hello_flask` virtualenv:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件，然后通过命令行运行`app.py`来执行它。您需要确保已激活`hello_flask` virtualenv：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Open your favorite web-browser and navigate to the URL displayed (`http://127.0.0.1:5000`).
    You should see the message **Hello, Flask!** displayed on a blank white page.
    By default, the Flask development server runs locally on `127.0.0.1`, bound to
    port `5000`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您喜欢的Web浏览器，导航到显示的URL（`http://127.0.0.1:5000`）。您应该在一个空白的白色页面上看到消息**Hello, Flask!**。默认情况下，Flask开发服务器在本地运行在`127.0.0.1`，绑定到端口`5000`。
- en: '![Hello, Flask!](img/1709_01_02.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![Hello, Flask!](img/1709_01_02.jpg)'
- en: Your first Flask app.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您的第一个Flask应用程序。
- en: Understanding the code
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解代码
- en: We just created a very basic Flask app. To understand what's happening let's
    take this code apart line-by-line.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个非常基本的Flask应用程序。要理解发生了什么，让我们逐行分解这段代码。
- en: '`from flask import Flask`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`from flask import Flask`'
- en: Our app begins by importing the `Flask` class. This class represents a single
    WSGI application and is the central object in any Flask project.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序通过导入`Flask`类开始。这个类代表一个单独的WSGI应用程序，是任何Flask项目中的核心对象。
- en: WSGI is the Python standard web server interface, defined in PEP 333\. You can
    think of WSGI as a set of behaviors and methods that, when implemented, allow
    your web app to just work with a large number of webservers. Flask handles all
    the implementation details for you, so you can focus on writing you web app.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: WSGI是Python标准的Web服务器接口，在PEP 333中定义。您可以将WSGI视为一组行为和方法，当实现时，允许您的Web应用程序与大量的Web服务器一起工作。Flask为您处理所有实现细节，因此您可以专注于编写Web应用程序。
- en: '`app = Flask(__name__)`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`app = Flask(__name__)`'
- en: In this line, we create an application instance in the variable `app` and pass
    it the name of our module. The variable `app` can of course be anything, however
    `app` is a common convention for most Flask applications. The application instance
    is the central registry for things such as views, URL routes, template configuration,
    and much more. We provide the name of the current module so that the application
    is able to find resources by looking inside the current folder. This will be important
    later when we want to render templates or serve static files.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行中，我们在变量`app`中创建了一个应用程序实例，并将其传递给我们模块的名称。变量`app`当然可以是任何东西，但是对于大多数Flask应用程序来说，`app`是一个常见的约定。应用程序实例是诸如视图、URL路由、模板配置等的中央注册表。我们提供当前模块的名称，以便应用程序能够通过查看当前文件夹内部找到资源。这在以后当我们想要渲染模板或提供静态文件时将会很重要。
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding lines, we are instructing our Flask app to route all requests
    for `/` (the root URL) to this view function (`index`). A view is simply a function
    or a method that returns a response of some kind. Whenever you open a browser
    and navigate to the root URL of our app, Flask will call this view function and
    send the return value to the browser.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的几行中，我们指示我们的Flask应用程序将所有对`/`（根URL）的请求路由到这个视图函数（`index`）。视图只是一个返回某种响应的函数或方法。每当您打开浏览器并导航到我们应用程序的根URL时，Flask将调用这个视图函数并将返回值发送到浏览器。
- en: 'There are a few things to note about these lines of code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些代码行有一些需要注意的事项：
- en: '`@app.route` is a Python decorator from the `app` variable defined above. This
    decorator (`app.route`) wraps the following function, in this case,`index`, in
    order to route requests for a particular URL to a particular view. Index is chosen
    as the name for the function here, as it''s the common name for the first page
    that a web server uses. Other examples could be homepage or main. Decorators are
    a rich and interesting subject for Python developers, so if you are not familiar
    with them, I recommend using your favorite search engine to find a good tutorial.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@app.route`是上面定义的`app`变量的Python装饰器。这个装饰器(`app.route`)包装了下面的函数，这种情况下是`index`，以便将特定URL的请求路由到特定视图。这里选择`index`作为函数的名称，因为它是Web服务器使用的第一个页面的通用名称。其他示例可能是主页或主要。装饰器是Python开发人员丰富且有趣的主题，所以如果您对它们不熟悉，我建议使用您喜欢的搜索引擎找到一个好的教程。'
- en: The `index` function takes no arguments. This might seem odd if you are coming
    from other web-frameworks and were expecting a request object or something similar.
    We will see in the following examples how to access values from the request.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index`函数不带任何参数。如果您来自其他Web框架，并且期望有一个请求对象或类似的东西，这可能看起来有点奇怪。在接下来的示例中，我们将看到如何从请求中访问值。'
- en: The `index` function returns a plain string object. In later examples, we will
    see how to render templates to return HTML.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index`函数返回一个普通的字符串对象。在后面的示例中，我们将看到如何渲染模板以返回HTML。'
- en: The following lines execute our app using the built-in development server in
    debug mode. The 'if' statement is a common Python convention that ensures that
    the app will only be run when we run our script via python `app.py`, and will
    not run if we try to import this app from another Python file.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下行使用调试模式下内置的开发服务器执行我们的应用程序。`if`语句是一个常见的Python约定，确保只有在通过python `app.py`运行脚本时才会运行应用程序，如果我们尝试从另一个Python文件导入此应用程序，则不会运行。
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Routes and requests
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由和请求
- en: 'Right now our Flask app isn''t much fun, so let''s look at the different ways
    in which we can add more interesting behavior to our web app. One common way is
    to add responsive behavior so that our app will look at values in the URL and
    handle them. Let''s add a new route to our Hello Flask app called `hello`. This
    new route will display a greeting to the person whose name appears in the URL:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的Flask应用程序并不那么有趣，所以让我们看看我们可以以不同方式为我们的Web应用程序添加更有趣的行为。一种常见的方法是添加响应式行为，以便我们的应用程序将查看URL中的值并处理它们。让我们为我们的Hello
    Flask应用程序添加一个名为`hello`的新路由。这个新路由将向出现在URL中的人显示问候语：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Again, let''s run our app and open it up in a web browser. We can now navigate
    to a URL such as `http://127.0.0.1/hello/Charlie` and see our custom message:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行我们的应用程序并在Web浏览器中打开它。现在我们可以导航到URL，比如`http://127.0.0.1/hello/Charlie`，并看到我们的自定义消息：
- en: '![Routes and requests](img/1709_01_03.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![路由和请求](img/1709_01_03.jpg)'
- en: Our Flask app displaying a custom message
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Flask应用程序显示自定义消息
- en: 'In the preceding example, the route we added specifies a single parameter:
    `name`. This parameter also appears in the function declaration as the sole argument.
    Flask is automatically matching the URL `/hello/Charlie` to the `hello` view;
    this is known as mapping. It then passes the string `Charlie` into our view function
    as an argument.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们添加的路由指定了一个参数：`name`。这个参数也出现在函数声明中作为唯一的参数。Flask自动将URL`/hello/Charlie`与`hello`视图进行匹配；这被称为映射。然后将字符串`Charlie`作为参数传递给我们的视图函数。
- en: What happens if we navigate to `http://127.0.0.1:5000/hello/` without specifying
    a name? As you can see, the Flask development server will return a `404` response,
    indicating that the URL did not match any known routes.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们导航到`http://127.0.0.1:5000/hello/`而没有指定名称会发生什么？正如您所看到的，Flask开发服务器将返回`404`响应，表示URL与任何已知路由不匹配。
- en: '![Routes and requests](img/1709_01_04.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![路由和请求](img/1709_01_04.jpg)'
- en: Flask 404 page
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 404页面
- en: Reading values from the request
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从请求中读取值
- en: 'In addition to the URL, values can be passed to your app in the query string.
    The query string is made up of arbitrary keys and values that are tacked onto
    the URL, using a question-mark:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 除了URL之外，值可以通过查询字符串传递给您的应用程序。查询字符串由任意键和值组成，这些键和值被附加到URL上，使用问号：
- en: '| URL | Argument Values |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| URL | 参数值 |'
- en: '| --- | --- |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `/hello/?name=Charlie` | name: Charlie |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `/hello/?name=Charlie` | name: Charlie |'
- en: '| `/hello/?name=Charlie&favorite_color=green` | name: Charliefavorite_color:
    green |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `/hello/?name=Charlie&favorite_color=green` | name: Charliefavorite_color:
    green |'
- en: In order to access these values inside your view functions, Flask provides a
    request object that encapsulates all sorts of information about the current HTTP
    request. In the following example, we will modify our `hello` view to also respond
    to names passed in via the query string. If no name is specified either on the
    query-string or in the URL, we will return a 404.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在视图函数中访问这些值，Flask提供了一个请求对象，该对象封装了关于当前HTTP请求的各种信息。在下面的示例中，我们将修改我们的`hello`视图，以便通过查询字符串传递的名称也能得到响应。如果在查询字符串或URL中未指定名称，我们将返回404。
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As you can see, we have added another route decorator to our `hello` view:
    Flask allows you to map multiple URL routes to the same view. Because our new
    route does not contain a name parameter, we need to modify the argument signature
    of our view function to make `name` an optional parameter, which we accomplish
    by providing a default value of `None`.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们已经为我们的`hello`视图添加了另一个路由装饰器：Flask允许您将多个URL路由映射到同一个视图。因为我们的新路由不包含名称参数，我们需要修改视图函数的参数签名，使`name`成为可选参数，我们通过提供默认值`None`来实现这一点。
- en: The function body of our view has also been modified to check for the presence
    of a name in the URL. If no name is specified, we will abort with a `404` page
    not found status code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们视图的函数体也已经修改为检查URL中是否存在名称。如果未指定名称，我们将中止并返回`404`页面未找到状态码。
- en: '![Reading values from the request](img/1709_01_05.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![从请求中读取值](img/1709_01_05.jpg)'
- en: Greet someone using the query string
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用查询字符串问候某人
- en: Debugging Flask applications
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试Flask应用程序
- en: It is inevitable that, sooner or later, we will introduce a bug into our code.
    Since bugs are inevitable, the best thing we can hope for as developers is good
    tools that help us diagnose and fix bugs quickly. Luckily, Flask comes bundled
    with an extremely powerful web-based debugger. The Flask debugger makes it possible
    to introspect the state of your application the moment an error occurs, removing
    the need to sprinkle in print statements or breakpoints.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 不可避免的是，迟早我们会在我们的代码中引入一个bug。由于bug是不可避免的，作为开发人员，我们所能希望的最好的事情就是有助于我们快速诊断和修复bug的好工具。幸运的是，Flask自带了一个非常强大的基于Web的调试器。Flask调试器使得在错误发生的瞬间内省应用程序的状态成为可能，消除了需要添加打印语句或断点的必要。
- en: 'This can be enabled by telling the Flask app to run in `debug` mode at run
    time. We can do this in a few ways but we have actually already done this through
    the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过在运行时告诉Flask应用程序以`debug`模式运行来启用。我们可以通过几种方式来做到这一点，但实际上我们已经通过以下代码做到了这一点：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In order to try it out, let''s introduce a bug to the `hello_flask` app by
    creating a typo. Here I have simply deleted the trailing e from the variable `name`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试它，让我们通过制造一个拼写错误来引入`hello_flask`应用程序中的一个bug。在这里，我只是从变量`name`中简单地删除了末尾的e：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When we fire up the development server and attempt to access our view, we are
    now presented with the debugging page:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动开发服务器并尝试访问我们的视图时，现在会出现调试页面：
- en: '![Debugging Flask applications](img/1709_01_06.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![调试Flask应用程序](img/1709_01_06.jpg)'
- en: The Flask interactive debugger running in a web browser
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web浏览器中运行的Flask交互式调试器
- en: This list of code is called a **Traceback** and it is made up of the call stack,
    the nested list of function calls that preceded the actual error. The traceback
    usually provides a very good clue as to what may have happened. At the very bottom
    we see the line of code we intentionally mistyped along with the actual Python
    error, which is a **NameError** exception telling us that **nam** is not defined.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码列表被称为**Traceback**，它由调用堆栈组成，即在实际错误之前的嵌套函数调用列表。Traceback通常提供了一个很好的线索，可以解释发生了什么。在底部我们看到了我们有意打错的代码行，以及实际的Python错误，这是一个**NameError**异常，告诉我们**nam**未定义。
- en: '![Debugging Flask applications](img/1709_01_07.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![调试Flask应用程序](img/1709_01_07.jpg)'
- en: Traceback detail showing our typo and a description of the error
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Traceback详细显示了我们的拼写错误和错误的描述。
- en: The real magic happens when you place your mouse on the highlighted line with
    the mouse. On the right-hand side you will see two small icons representing a
    terminal and a source code file. Clicking the **Source Code** icon will expand
    the source code surrounding the line that contained the error. This is very useful
    for establishing some context when interpreting an error.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的魔力发生在你把鼠标放在高亮的行上时。在右侧，你会看到两个小图标，代表终端和源代码文件。点击**Source Code**图标将展开包含错误行的源代码。这对于解释错误时建立一些上下文非常有用。
- en: 'The terminal icon is the most interesting. When you click the **Terminal**
    icon, a small console appears with the standard Python prompt. This prompt allows
    you to inspect, in real-time, the values of the local variables at the time of
    the exception. Try typing in `name` and hitting *Enter*—it should display the
    value, if any, that was specified in the URL. We can also introspect the current
    request arguments as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 终端图标最有趣。当你点击**Terminal**图标时，一个小控制台会出现，带有标准的Python提示符。这个提示符允许你实时检查异常发生时本地变量的值。尝试输入`name`并按*Enter*——它应该显示在URL中指定的值（如果有的话）。我们还可以通过以下方式检查当前请求参数：
- en: '![Debugging Flask applications](img/1709_01_08.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![调试Flask应用程序](img/1709_01_08.jpg)'
- en: Introspecting variables using the debugging console
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用调试控制台内省变量
- en: As you work through the chapters and experiment on your own, being able to quickly
    diagnose and correct any bugs will be an extremely valuable skill. We will return
    to the interactive debugger in [Chapter 8](ch08.html "Chapter 8. Testing Flask
    Apps"), *Testing Flask Apps* but, for now, be aware that it exists and can be
    used to introspect your code when and where it breaks.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在章节中工作并进行实验时，能够快速诊断和纠正任何bug将是一项非常有价值的技能。我们将在[第8章](ch08.html "第8章。测试Flask应用程序")中回到交互式调试器，*测试Flask应用程序*，但现在要知道它的存在，并且可以在代码中断时和地方使用它进行内省。
- en: Introducing the blog project
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍博客项目
- en: 'Over the rest of this book, we will be building, enhancing, and deploying a
    programmer-friendly blogging site. This project will introduce you to the most
    common web development tasks, such as working with relational databases, processing
    and validating form data, and (everyone''s favorite), testing. In each chapter,
    you will learn a new skill through practical, hands-on coding projects. In the
    following table, I''ve listed a brief description of the core skills paired with
    the corresponding features of the blog:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们将构建、增强和部署一个对程序员友好的博客站点。这个项目将介绍你最常见的Web开发任务，比如使用关系数据库、处理和验证表单数据，以及（每个人都喜欢的）测试。在每一章中，你将通过实际的、动手编码的项目学习一个新的技能。在下表中，我列出了核心技能的简要描述，以及博客相应的功能：
- en: '| Skill | Blog site feature(s) |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 技能 | 博客站点功能 |'
- en: '| --- | --- |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Relational databases with SQLAlchemyFlask-SQLAlchemy | Store entries and
    tags in a relational database. Perform a wide variety of queries, including pagination,
    date-ranges, full-text search, inner and outer joins, and more. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 使用SQLAlchemy的关系数据库Flask-SQLAlchemy | 在关系数据库中存储条目和标签。执行各种查询，包括分页、日期范围、全文搜索、内连接和外连接等。'
- en: '| Form processing and validationFlask-WTF | Create and edit blog entries using
    forms. In later chapters, we will also use forms for logging users into the site
    and allowing visitors to post comments. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 表单处理和验证Flask-WTF | 使用表单创建和编辑博客条目。在后面的章节中，我们还将使用表单来让用户登录站点并允许访问者发表评论。'
- en: '| Template rendering with Jinja2Jinja2 | Create a clean, extensible set of
    templates, making use of inheritance and includes, where appropriate. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 使用Jinja2模板渲染Jinja2 | 创建一个干净、可扩展的模板集，适当时使用继承和包含。'
- en: '| User authentication and administrative dashboardsFlask-Login | Store user
    accounts in the database and restrict the post management page to registered users.
    Build an administrative panel for managing posts, user accounts, and for displaying
    stats such as page-views, IP geolocation, and more. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 用户认证和管理仪表板Flask-Login | 将用户帐户存储在数据库中，并将帖子管理页面限制为注册用户。构建一个管理面板，用于管理帖子、用户帐户，并显示页面浏览量、IP地理位置等统计信息。'
- en: '| Ajax and RESTful APIsFlask-API | Build an Ajax-powered commenting system
    that will be displayed on each entry. Expose blog entries using a RESTful API,
    and build a simple command-line client for posting entries using the API. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| Ajax和RESTful APIsFlask-API | 构建一个Ajax驱动的评论系统，该系统将显示在每个条目上。使用RESTful API公开博客条目，并构建一个简单的命令行客户端，用于使用API发布条目。'
- en: '| Unit testingunittest | We will build a full suite of tests for the blog,
    and learn how to simulate real requests and use mocks to simplify complex interactions.
    |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 单元测试unittest | 我们将为博客构建一个完整的测试套件，并学习如何模拟真实请求并使用模拟简化复杂的交互。|'
- en: '| Everything else | **Cross-Site Request Forgery** (**CSRF**) protection, Atom
    feeds, spam detection, asynchronous task execution, deploying, **Secure Socket
    Layer** (**SSL**), hosting providers, and more. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 其他 | **跨站点请求伪造**（**CSRF**）保护，Atom feeds，垃圾邮件检测，异步任务执行，部署，**安全套接字层**（**SSL**），托管提供商等等。'
- en: The spec
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 规范
- en: 'It''s always a good idea when starting a large project to have a functional
    specification in mind. For the blogging site, our spec will simply be the list
    of features that we want our blog to have. These features are based on my experience
    in building my personal blog:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当开始一个大型项目时，拥有一个功能规范是个好主意。对于博客网站，我们的规范将简单地是我们希望博客具有的功能列表。这些功能是基于我在构建个人博客时的经验：
- en: Entries should be entered using web-based interfaces. For formatting, the author
    can use **Markdown**, a lightweight, visually appealing markup language.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条目应该使用基于web的界面输入。对于格式，作者可以使用**Markdown**，这是一种轻量级、外观吸引人的标记语言。
- en: Images can be uploaded to the site and easily embedded in blog entries.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图片可以上传到网站，并轻松地嵌入到博客条目中。
- en: Entries can be organized using any number of tags.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条目可以使用任意数量的标签进行组织。
- en: The site should support multiple authors.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该网站应支持多个作者。
- en: Entries can be displayed in order of publication, but also listed by month,
    by tag, or by author. Long lists of entries will be paginated.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条目可以按发布顺序显示，也可以按月份、标签或作者列出。条目的长列表将被分页。
- en: Entries can be saved as *drafts* and viewed by their author but nobody else
    until they are *published*.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条目可以保存为*草稿*，并由其作者查看，但在*发布*之前其他人无法查看。
- en: Visitors to the site can post comments on entries, which will be checked for
    spam and then left to the author's discretion as to whether they should remain
    visible.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问者可以在条目上发表评论，评论将被检查是否为垃圾邮件，然后由作者自行决定是否应该保持可见。
- en: Atom feeds will be made available for all posts, including separate feeds for
    each author and tag.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有帖子都将提供Atom feeds，包括每个作者和标签的单独feeds。
- en: Entries can be accessed using a RESTful API. Authors will be given an API token
    that will allow them to modify entries using the API.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用RESTful API访问条目。作者将获得一个API令牌，允许他们使用API修改条目。
- en: While this list is not exhaustive, it covers the core functionality of our blogging
    site and you will hopefully find it both fun and challenging to build. At the
    end of the book, I will present some ideas for additional features that you might
    add, but first you need to become comfortable working with Flask. I'm sure you're
    eager to get started, so let's set up our blogging project.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个列表并不详尽，但它涵盖了我们博客网站的核心功能，你将有希望发现它既有趣又具有挑战性。在本书的最后，我将提出一些你可能添加的其他功能的想法，但首先你需要熟悉使用Flask。我相信你迫不及待地想要开始，所以让我们设置我们的博客项目。
- en: Creating the blog project
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建博客项目
- en: 'Let''s start by creating a new project within our working directory; on my
    laptop this is `/home/charles/projects`, or on a Unix system `~/projects,` for
    short. This is exactly what we did when we created the `hello_flask` app:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在我们的工作目录中创建一个新项目开始；在我的笔记本电脑上是`/home/charles/projects`，或者在Unix系统中是`~/projects`，简称为。这正是我们创建`hello_flask`应用程序时所做的事情：
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We will then need to set up our `virtualenv` environment. This differs from
    what we did earlier as this is a more structured way of using virtualenv:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要设置我们的`virtualenv`环境。这与我们之前所做的不同，因为这是一种更有结构的使用虚拟环境的方式：
- en: '[PRE17]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The next step will be to install Flask into our virtualenv. To do this, we
    will `activate` the `virtualenv` and use `pip` to install Flask:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是将Flask安装到我们的虚拟环境中。为此，我们将`激活`虚拟环境，并使用`pip`安装Flask：
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Up until now, all of this should be somewhat familiar to you. However, instead
    of creating a single file for our app, which we are definitely allowed to do and
    that makes sense for very small apps, we can also create a new folder named `app`
    that will allow us to make our app modular and more logical. Inside that folder,
    we will create five empty files named `__init__.py`, `app.py`, `config.py`, `main.py,`
    and `views.py` as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有这些对你来说应该都有些熟悉。但是，我们可以创建一个名为`app`的新文件夹，而不是为我们的应用程序创建单个文件，这是完全可以的，对于非常小的应用程序来说是有意义的，这样可以使我们的应用程序模块化和更加合乎逻辑。在该文件夹内，我们将创建五个空文件，分别命名为`__init__.py`、`app.py`、`config.py`、`main.py`和`views.py`，如下所示：
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This last command uses a little trick of your shell to create multiple files
    with the names within the brackets. If you use version control, you will want
    to treat the `app` directory as the root of your repository. The app directory
    will contain the source code, templates, and static assets for the blog app. If
    you haven't used version control, now would be a great time to give it a try.
    *Pro Git* is a great resource and is available for free at [http://git-scm.com/book](http://git-scm.com/book).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的命令使用了你的shell的一个小技巧，来创建括号内的多个文件名。如果你使用版本控制，你会希望将`app`目录视为你的代码库的根目录。app目录将包含博客应用的源代码、模板和静态资源。如果你还没有使用版本控制，现在是一个很好的时机来尝试一下。*Pro
    Git*是一个很好的资源，可以免费在[http://git-scm.com/book](http://git-scm.com/book)上获取。
- en: 'What are these files that we just created? As you will see, each file serves
    an important purpose. Hopefully their names provide a clue as to their purpose,
    but here is a brief overview of each module''s responsibility:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的这些文件是什么？正如你将看到的，每个文件都有重要的作用。希望它们的名称能够提供关于它们作用的线索，但这里是每个模块责任的简要概述：
- en: '| `__init__.py` | Tells Python to use the app/ directory as a python package
    |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `__init__.py` | 告诉Python将app/目录作为Python包使用 |'
- en: '| `app.py` | The Flask app |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `app.py` | Flask应用 |'
- en: '| `config.py` | Configuration variables for our Flask app |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `config.py` | 我们的Flask应用的配置变量 |'
- en: '| `main.py` | Entry-point for executing our application |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `main.py` | 执行我们应用的入口点 |'
- en: '| `views.py` | URL routes and views for the app |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `views.py` | 应用的URL路由和视图 |'
- en: A barebones Flask app
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个简单的Flask应用
- en: Let's fill in these files with the minimum amount of code needed to create a
    runnable Flask app. This will get our project in good shape for the second chapter,
    in which we'll start working on the code to store and retrieve blog entries from
    the database.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用最少量的代码填充这些文件，以创建一个可运行的Flask应用程序。这将使我们的项目在第二章中处于良好的状态，我们将开始编写代码来存储和检索数据库中的博客条目。
- en: 'We will start with the `config.py` module. This module will contain a `Configuration`
    class that instructs Flask that we want to run our app in the `DEBUG` mode. Add
    the following two lines of code to the `config.py` module as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`config.py`模块开始。这个模块将包含一个`Configuration`类，指示Flask我们想要在`DEBUG`模式下运行我们的应用。将以下两行代码添加到`config.py`模块中：
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next we will create our Flask app and instruct it to use the configuration
    values specified in the `config` module. Add the following code to the `app.py`
    module:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将创建我们的Flask应用，并指示它使用`config`模块中指定的配置值。将以下代码添加到`app.py`模块中：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The views module will contain a single view mapped to the root URL of the site.
    Add the following code to `views.py`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 视图模块将包含一个映射到站点根URL的单个视图。将以下代码添加到`views.py`中：
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As you probably noticed, we are still missing our call to `app.run()`. We will
    put that code in `main.py`, which we will use as the entry-point into our app.
    Add the following code to the `main.py` module:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，我们仍然缺少对`app.run()`的调用。我们将把这段代码放在`main.py`中，这将作为我们应用的入口点。将以下代码添加到`main.py`模块中：
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We do not call `app.run(debug=True)` because we have already instructed Flask
    to run our app in the debug mode in the `Configuration` object.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不调用`app.run(debug=True)`，因为我们已经指示Flask在`Configuration`对象中以调试模式运行我们的应用。
- en: 'You can run the app from the command-line by executing the `main` module as
    follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过执行以下命令行来运行应用程序：
- en: '[PRE24]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![A barebones Flask app](img/1709_01_09.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![一个简单的Flask应用](img/1709_01_09.jpg)'
- en: From humble beginnings...
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 从小小的开始...
- en: Zooming out
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 放大
- en: Other than the `Configuration` class, most of this code should look familiar
    to you. We have basically taken the code from the `hello_flask` example and separated
    it into several modules. It may seem silly to write only two or three lines of
    code per file, but as our project grows you will see how this early commitment
    to organization pays off.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Configuration`类之外，大部分代码对你来说应该很熟悉。我们基本上是将`hello_flask`示例中的代码分离成了几个模块。可能每个文件只写两三行代码看起来有些愚蠢，但随着我们项目的增长，你会看到这种早期组织的承诺是如何得到回报的。
- en: You may have noticed that there is an internal prioritization to these files,
    based on the order in which they are imported—this is to mitigate the possibility
    of a circular import. A circular import occurs when two modules mutually import
    each other and, hence, cannot be imported at all. When using the Flask framework,
    it is very easy to create circular imports because so many different things depend
    on the central app object. To avoid problems, some people just put everything
    into a single module. This works fine for smaller apps, but is not maintainable
    beyond a certain size or complexity. That is why we have broken our app into several
    modules and created a single entry-point that controls the ordering of imports.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，这些文件有一个内部的优先级，根据它们被导入的顺序—这是为了减轻循环导入的可能性。循环导入发生在两个模块相互导入并且因此根本无法被导入时。在使用Flask框架时，很容易创建循环导入，因为很多不同的东西依赖于中心应用对象。为了避免问题，有些人只是把所有东西放到一个单一的模块中。这对于较小的应用程序来说是可以的，但在一定规模或复杂性之后就无法维护了。这就是为什么我们将我们的应用程序分成几个模块，并创建一个单一的入口点来控制导入的顺序。
- en: The import flow
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入流程
- en: Execution starts when you run python `main.py` from the command line. The first
    line of code that the Python interpreter runs into imports the `app` object from
    the `app` module. Now we're inside `app.py`, which imports Flask and our `Configuration`
    object. The rest of the `app.py` module is read and interpreted, and we're back
    into `main.py` again. The second line of `main.py` imports the `views` module.
    Now we're in `views.py`, which depends on `app.py` for `@app.route` and is, in
    fact, already available from `main.py`. The URL route and view are registered
    as the `views` module is interpreted, and we're back into `main.py` again. Since
    we are running `main.py` directly, the 'if' check will evaluate to `True` and
    our app will run.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从命令行运行python `main.py`时，执行就开始了。Python解释器运行的第一行代码是从`app`模块导入`app`对象。现在我们在`app.py`内部，它导入了Flask和我们的`Configuration`对象。`app.py`模块的其余部分被读取和解释，然后我们又回到了`main.py`。`main.py`的第二行导入了`views`模块。现在我们在`views.py`内部，它依赖于`app.py`的`@app.route`，实际上已经从`main.py`中可用。随着`views`模块的解释，URL路由和视图被注册，然后我们又回到了`main.py`。由于我们直接运行`main.py`，'if'检查将评估为`True`，我们的应用程序将运行。
- en: '![The import flow](img/1709_01_10.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![导入流程](img/1709_01_10.jpg)'
- en: Import flow when executing main.py
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 执行main.py时的导入流程
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: By now you should be familiar with the process of setting up a new virtualenv
    for your Python project, be able to install Flask, and have created a simple app.
    In this chapter,we discussed how to create virtualenvs for your projects and install
    third-party packages using `pip`. We also learnt how to write a basic Flask app,
    route requests to views, and to read request arguments. We familiarized ourselves
    with the interactive debugger and with how the Python interpreter processes the
    import statements.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经熟悉了为Python项目设置新的虚拟环境的过程，能够安装Flask，并创建了一个简单的应用程序。在本章中，我们讨论了如何为项目创建虚拟环境，并使用`pip`安装第三方包。我们还学习了如何编写基本的Flask应用程序，将请求路由到视图，并读取请求参数。我们熟悉了交互式调试器以及Python解释器如何处理导入语句。
- en: If you were already familiar with most of the subject-matter in this chapter,
    do not worry; things will soon get more challenging.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经熟悉本章大部分内容，不用担心；很快事情会变得更具挑战性。
- en: 'In the next chapter, you will discover how to work with a relational database
    to store and retrieve blog entries. We''ll add a new module to our project for
    storing our database-specific code and create some models to represent blog entries
    and tags. Once we are able to store the entries, we will learn how to read them
    back in a variety of ways through filtering, sorting, and aggregation. For more
    information, you can refer to the following links:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将了解如何使用关系数据库来存储和检索博客条目。我们将为项目添加一个新模块来存储我们的数据库特定代码，并创建一些模型来表示博客条目和标签。一旦我们能够存储这些条目，我们将学习如何以各种方式通过过滤、排序和聚合来读取它们。更多信息，请参考以下链接：
- en: '[https://www.python.org/dev/peps/pep-0333/](https://www.python.org/dev/peps/pep-0333/)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.python.org/dev/peps/pep-0333/](https://www.python.org/dev/peps/pep-0333/)'
- en: '[https://wiki.python.org/moin/PythonDecorators](https://wiki.python.org/moin/PythonDecorators)'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://wiki.python.org/moin/PythonDecorators](https://wiki.python.org/moin/PythonDecorators)'
- en: '[http://charlesleifer.com](http://charlesleifer.com)'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://charlesleifer.com](http://charlesleifer.com)'
