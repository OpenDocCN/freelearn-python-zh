- en: Threads and Networking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程和网络
- en: In this chapter, we will extend the functionality of our Python GUI using threads,
    queues, and network connections.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过使用线程、队列和网络连接来扩展我们Python GUI的功能。
- en: A `tkinter` GUI is a single-threaded application. Every function that involves
    sleep or wait time has to be called in a separate thread; otherwise, the `tkinter`
    GUI freezes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '`tkinter` GUI是一个单线程应用程序。涉及睡眠或等待时间的每个函数都必须在单独的线程中调用；否则，`tkinter` GUI会冻结。'
- en: When we run our Python GUI, in Windows Task Manager, we can see that a new `python.exe`
    process has been launched. When we give our Python GUI a `.pyw` extension, then
    the process created will be `python.pyw`, which can be seen in Task Manager as
    well.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行我们的Python GUI时，在Windows任务管理器中，我们可以看到已启动一个新的`python.exe`进程。当我们给我们的Python
    GUI添加`.pyw`扩展名时，创建的进程将是`python.pyw`，这也可以在任务管理器中看到。
- en: When a process is created, the process automatically creates a main thread to
    run our application. This is called a *single-threaded application*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建进程时，进程会自动创建一个主线程来运行我们的应用程序。这被称为**单线程应用程序**。
- en: Single-threaded processes contain the execution of instructions in a single
    sequence. In other words, one command is processed at a time.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 单线程进程包含指令的单个序列执行。换句话说，一次只处理一个命令。
- en: For our Python GUI, a single-threaded application will lead to our GUI becoming
    frozen as soon as we call a longer-running task, such as clicking a button that
    has a sleep time of a few seconds. In order to keep our GUI responsive, we have
    to use *multithreading*, and this is what we will study in this chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的Python GUI，单线程应用程序会导致我们在调用长时间运行的任务（如点击具有几秒睡眠时间的按钮）时，GUI立即冻结。为了保持我们的GUI响应，我们必须使用**多线程**，这正是本章我们将要学习的内容。
- en: Our GUI runs in a single thread. Knowing how to use multiple threads is an important
    concept for GUI development.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的GUI在单个线程中运行。了解如何使用多个线程是GUI开发中的一个重要概念。
- en: We can also create multiple processes by creating multiple instances of our
    Python GUI, as can be seen in Task Manager, where we can see several `python.exe`
    processes running at the same time.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过创建多个Python GUI实例来创建多个进程，如任务管理器所示，我们可以看到同时运行着几个`python.exe`进程。
- en: Processes are isolated from each other by design and do not share common data.
    In order to communicate between separate processes, we have to use **Inter-Process
    Communication** (**IPC**), which is an advanced technique. Threads, on the other
    hand, do share common data, code, and files, which makes communication between
    threads within the same process much easier than when using IPC. A great explanation
    of threads can be found at [https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSyste](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/4_Threads.html)[ms/4_Threads.html](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/4_Threads.html).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 设计上，进程之间是隔离的，并且不共享公共数据。为了在独立进程之间进行通信，我们必须使用**进程间通信**（**IPC**），这是一种高级技术。另一方面，线程之间确实共享公共数据、代码和文件，这使得在同一进程内使用线程进行通信比使用IPC要容易得多。关于线程的精彩解释可以在[https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSyste](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/4_Threads.html)[ms/4_Threads.html](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/4_Threads.html)找到。
- en: In this chapter, we will learn how to keep our Python GUI responsive and keep
    it from freezing. Having this knowledge is essential when creating working GUIs,
    and knowing how to create threads and use queues increases your programming skills.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何保持我们的Python GUI响应，并防止它冻结。在创建工作GUI时，拥有这种知识是必不可少的，并且知道如何创建线程和使用队列可以提高您的编程技能。
- en: We will also use TCP/IP to connect our GUI to a network. In addition to that,
    we will read a URL web page, which is also a networking component on the internet.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用TCP/IP将我们的GUI连接到网络。除此之外，我们还将读取URL网页，这也是互联网上的一个网络组件。
- en: 'Here is the overview of Python modules for this chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章Python模块的概述：
- en: '![](img/4b53775b-8917-4182-a184-de7f64017f2d.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4b53775b-8917-4182-a184-de7f64017f2d.png)'
- en: We will create threads, queues, and TCP/IP sockets using Python 3.7 or later.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Python 3.7或更高版本创建线程、队列和TCP/IP套接字。
- en: 'To sum it up, we will cover the following recipes:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们将涵盖以下内容：
- en: How to create multiple threads
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建多个线程
- en: Starting a thread
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动线程
- en: Stopping a thread
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止线程
- en: How to use queues
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用队列
- en: Passing queues among different modules
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同模块之间传递队列
- en: Using dialog widgets to copy files to your network
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对话框小部件将文件复制到您的网络中
- en: Using TCP/IP to communicate via networks
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用TCP/IP通过网络进行通信
- en: Using `urlopen` to read data from websites
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`urlopen`从网站读取数据
- en: How to create multiple threads
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何创建多个线程
- en: Multiple threads are necessary in order to keep our GUI responsive. Without
    running of our GUI program using multiple threads, our application will freeze
    and possibly crash.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 多个线程是必要的，以便保持我们的GUI响应。如果没有使用多个线程运行我们的GUI程序，我们的应用程序可能会冻结并可能崩溃。
- en: Getting ready
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Multiple threads run within the same computer process memory space. There is
    no need for IPC, which would complicate our code. In this recipe, we will avoid
    IPC by using threads.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 多个线程在同一个计算机进程的内存空间中运行。不需要IPC，这会复杂化我们的代码。在这个菜谱中，我们将通过使用线程来避免IPC。
- en: How to do it…
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到…
- en: First, we will increase the size of our `ScrolledText` widget, making it larger.
    Let's increase `scrol_w` to `40` and `scrol_h` to `10`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将增加我们的`ScrolledText`小部件的大小，使其更大。让我们将`scrol_w`增加到`40`，将`scrol_h`增加到`10`。
- en: 'We will start by using the latest code from [Chapter 5](42e25c40-ea12-4805-aa6c-2303e6ea36d0.xhtml),
    *Matplotlib Charts*:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用[第5章](42e25c40-ea12-4805-aa6c-2303e6ea36d0.xhtml)的最新代码，*Matplotlib图表*：
- en: Open `Ch04_Code.GUI_OOP_class_imported_tooltip.py` and save it as `GUI_multiple_threads.py`.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Ch04_Code.GUI_OOP_class_imported_tooltip.py`并将其保存为`GUI_multiple_threads.py`。
- en: 'Make the changes shown in the following code:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行以下代码所示更改：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Modify `self.spin.grid` to use `sticky`:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`self.spin.grid`修改为使用`sticky`：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Increase the `width` size of `Entry`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加小部件`Entry`的`width`大小：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Increase the `width` size of `Combobox` to `14`:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Combobox`小部件的`width`大小增加到`14`：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run the code and observe the output:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并观察输出：
- en: '![](img/e5924910-7719-43f2-9db4-e1a0de6b3c1a.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e5924910-7719-43f2-9db4-e1a0de6b3c1a.png)'
- en: 'Import `Thread` from Python''s built-in `threading` module:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Python的内置`threading`模块导入`Thread`：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add the `method_in_a_thread` method:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`method_in_a_thread`方法：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a thread as follows:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建线程如下：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Set a breakpoint or use a `print` statement for the `run_thread` variable:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`run_thread`变量设置断点或使用`print`语句：
- en: '![](img/1cbec86d-a956-41d1-a024-04d66060b70f.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1cbec86d-a956-41d1-a024-04d66060b70f.png)'
- en: Let's go behind the scenes to understand the code better.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解代码，以更好地理解它。
- en: How it works…
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: After our first changes in *step 2* to `GUI_multiple_threads.py`, when we run
    the resulting GUI, the `Spinbox` widget is center-aligned in relation to the `Entry`
    widget above it, which does not look good. We'll change this by left-aligning
    the widget. We add `sticky='W'` to the `grid` control to left-align the `Spinbox`
    widget.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对`GUI_multiple_threads.py`的*第2步*所做的第一次更改之后，当我们运行生成的GUI时，位于其上方的`Spinbox`小部件相对于`Entry`小部件是居中对齐的，这看起来不太好。我们将通过左对齐小部件来改变这一点。我们向`grid`控件添加`sticky='W'`以左对齐`Spinbox`小部件。
- en: The GUI could still look better, so next, we increase the size of the `Entry`
    widget to get a more balanced GUI layout. After that, we also increase the `Combobox`
    widget. Running the modified and improved code results in a larger GUI, which
    we will use for this recipe and for the following recipes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: GUI仍然可以更好，所以接下来，我们将`Entry`小部件的大小增加到获得更平衡的GUI布局。之后，我们也增加了`Combobox`小部件。运行修改和改进后的代码将产生一个更大的GUI，我们将使用这个GUI来完成这个菜谱以及接下来的菜谱。
- en: In order to create and use threads in Python, we have to import the `Thread`
    class from the `threading` module. After adding the `method_in_a_thread` method,
    we can now call our threaded method in the code, saving the instance in a variable
    called `run_thread`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Python中创建和使用线程，我们必须从`threading`模块导入`Thread`类。在添加`method_in_a_thread`方法后，我们现在可以在代码中调用我们的线程方法，并将实例保存在名为`run_thread`的变量中。
- en: Now we have a method that is threaded, but when we run the code, nothing gets
    printed to the console!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个线程化的方法，但当我们运行代码时，控制台没有任何打印输出！
- en: We have to start the thread first before it can run, and the next recipe will
    show us how to do this.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须首先启动线程，然后它才能运行，下一个菜谱将展示如何做到这一点。
- en: However, setting a breakpoint after the GUI main event loop proves that we did
    indeed create a thread object, as can be seen in the Eclipse IDE debugger.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在GUI主事件循环之后设置断点证明我们确实创建了一个线程对象，如Eclipse IDE调试器中所示。
- en: In this recipe, we prepared our GUI to use threads by first increasing the GUI
    size so we can see the results printed to the `ScrolledText` widget in a better
    way. We then imported the `Thread` class from the Python `threading` module. Next,
    we created a method that we call in a thread from within our GUI.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们首先通过增加GUI大小来准备我们的GUI使用线程，这样我们就可以更好地看到打印到`ScrolledText`小部件的结果。然后，我们从Python的`threading`模块导入了`Thread`类。接下来，我们创建了一个在GUI内部调用的方法。
- en: Let's move on to the next recipe.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续下一个菜谱。
- en: Starting a thread
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动线程
- en: This recipe will show us how to start a thread. It will also demonstrate why
    threads are necessary to keep our GUI responsive during long-running tasks.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将向我们展示如何启动一个线程。它还将演示为什么在长时间运行的任务期间，线程对于保持我们的GUI响应是必要的。
- en: Getting ready
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's first see what happens when we call a function or a method of our GUI
    that has `sleep` associated with it without using threads.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看当我们调用与 `sleep` 相关的函数或GUI方法而没有使用线程时会发生什么。
- en: We are using `sleep` here to simulate a real-world application that might have
    to wait for a web server or database to respond, a large file transfer, or complex
    computations to complete its task. `sleep` is a very realistic placeholder and
    shows the principle involved.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用 `sleep` 来模拟可能需要等待网络服务器或数据库响应、大文件传输或复杂计算完成任务的现实世界应用程序。`sleep` 是一个非常现实的占位符，展示了涉及的原则。
- en: How to do it…
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Adding a loop into our button callback method with some `sleep` time results
    in our GUI becoming unresponsive and, when we try to close the GUI, things get
    even worse.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的按钮回调方法中添加一个循环和一些 `sleep` 时间会导致我们的GUI变得无响应，当我们尝试关闭GUI时，情况变得更糟。
- en: Open `GUI_multiple_threads.py` and save it as `GUI_multiple_threads_sleep_freeze.py`.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GUI_multiple_threads.py` 并将其保存为 `GUI_multiple_threads_sleep_freeze.py`。
- en: 'Make the following changes to the code:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对代码进行以下更改：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Running the preceding code results in the following screenshot:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行前面的代码会产生以下截图：
- en: '![](img/ecfd95d7-7a1a-47a7-92cf-9c6a281ae72e.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ecfd95d7-7a1a-47a7-92cf-9c6a281ae72e.png)'
- en: 'Let''s move the creation of the thread into its own method and then call this
    method from the button callback method:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将线程的创建移动到它自己的方法中，然后从按钮回调方法中调用此方法：
- en: Open `GUI_multiple_threads_sleep_freeze.py` and save it as `GUI_multiple_threads_starting_a_thread.py`.
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GUI_multiple_threads_sleep_freeze.py` 并将其保存为 `GUI_multiple_threads_starting_a_thread.py`。
- en: 'Add the following code:'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Run the code and observe the output. Running the code now no longer freezes
    our GUI:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并观察输出。现在运行代码不再使我们的GUI冻结：
- en: '![](img/6fd3862f-eef9-49e0-b897-e56fc308af42.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6fd3862f-eef9-49e0-b897-e56fc308af42.png)'
- en: 'We can print the instance of the thread by following these steps:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下步骤打印线程的实例：
- en: Open `GUI_multiple_threads_starting_a_thread.py`.
  id: totrans-79
  prefs:
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GUI_multiple_threads_starting_a_thread.py`。
- en: 'Add a `print` statement to the code:'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码中添加一个 `print` 语句：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Clicking the button now creates the following printout:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击按钮现在会创建以下输出：
- en: '![](img/7c5a3578-bcb5-4797-8672-31e2550089fe.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7c5a3578-bcb5-4797-8672-31e2550089fe.png)'
- en: 'On clicking the button several times, you get the following output:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在多次点击按钮后，你会得到以下输出：
- en: '![](img/4b267cee-2239-4678-9b00-28ccabc349b2.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4b267cee-2239-4678-9b00-28ccabc349b2.png)'
- en: 'Move the code with `sleep` into a loop in the `method_in_a_thread` method:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将带有 `sleep` 的代码移动到 `method_in_a_thread` 方法中的循环：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Click the button, change tabs, and then click on other widgets:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击按钮，切换标签页，然后点击其他小部件：
- en: '![](img/ce438601-2e1f-4ab8-b21f-2b5b49d6aaa4.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ce438601-2e1f-4ab8-b21f-2b5b49d6aaa4.png)'
- en: Let's go behind the scenes to understand the code better.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解代码，更好地理解它。
- en: How it works…
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In `GUI_multiple_threads_sleep_freeze.py`, we added a `sleep` statement and
    noticed how our GUI became unresponsive.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `GUI_multiple_threads_sleep_freeze.py` 中，我们添加了一个 `sleep` 语句，并注意到我们的GUI变得无响应。
- en: If we wait long enough, the method will eventually complete, but during this
    time, none of our GUI widgets respond to click events. We solve this problem by
    using threads.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果等待足够长的时间，方法最终会完成，但在这段时间内，我们的任何GUI小部件都不会对点击事件做出响应。我们通过使用线程来解决这个问题。
- en: Unlike regular Python functions and methods, we have to `start` a method that
    will be run in its own thread! This is what we did next in `GUI_multiple_threads_starting_a_thread.py`.
    Clicking the button now results in the `create_thread` method being called, which,
    in turn, calls the `method_in_a_thread` method.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规Python函数和方法不同，我们必须 `start` 一个将在其自己的线程中运行的方法！这就是我们在 `GUI_multiple_threads_starting_a_thread.py`
    中接下来所做的事情。点击按钮现在会导致调用 `create_thread` 方法，然后它反过来调用 `method_in_a_thread` 方法。
- en: First, we create a thread and target it at a method. Next, we start the thread
    that runs the targeted method in a new thread. Running the code now no longer
    freezes our GUI.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个线程并将其指向一个方法。然后，我们启动一个新线程来运行目标方法。现在运行代码不再使我们的GUI冻结。
- en: The GUI itself runs in its own thread, which is the main thread of the application.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: GUI本身在其自己的线程中运行，这是应用程序的主线程。
- en: When we click the button several times, we can see that each thread gets assigned
    a unique name and ID. After moving the code with `sleep` into a loop in the `method_in_a_thread`
    method, we are able to verify that threads really do solve our problem.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们多次点击按钮时，我们可以看到每个线程都会被分配一个唯一的名称和ID。在将带有`sleep`的代码移动到`method_in_a_thread`方法的循环中之后，我们能够验证线程确实解决了我们的问题。
- en: When clicking the button, while the numbers are being printed into the `ScrolledText`
    widget with a five-second delay, we can click around anywhere in our GUI, switch
    tabs, and so on. Our GUI has become responsive again because we are using threads!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击按钮，同时数字以五秒的延迟打印到`ScrolledText`小部件时，我们可以在我们的GUI的任何地方点击，切换标签页等等。由于我们使用了线程，我们的GUI再次变得响应。
- en: In this recipe, we called the methods of our GUI class in their own threads
    and learned that we have to start the threads. Otherwise, the thread gets created
    but just sits there waiting for us to run its target method. Also, we noticed
    that each thread gets assigned a unique name and ID. And finally, we simulated
    long-running tasks by inserting a `sleep` statement into our code, which showed
    us that threads can indeed solve our problem.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们在自己的线程中调用了我们的GUI类的函数，并了解到我们必须启动线程。否则，线程会被创建，但只是在那里等待我们运行它的目标方法。我们还注意到每个线程都会被分配一个唯一的名称和ID。最后，我们通过在代码中插入`sleep`语句来模拟长时间运行的任务，这表明线程确实可以解决问题。
- en: Let's move on to the next recipe.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续下一个菜谱。
- en: Stopping a thread
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 停止一个线程
- en: We have to start a thread to actually make it do something by calling the `start()`
    method so, intuitively, we expect there to be a matching `stop()` method, but
    there is no such thing. In this recipe, we will learn how to run a thread as a
    background task, which is called a *daemon*. When closing the main thread, which
    is our GUI, all daemons will automatically be stopped as well.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须通过调用`start()`方法来启动线程，以便真正让它做些事情，直观上，我们期望有一个匹配的`stop()`方法，但并没有这样的方法。在这个菜谱中，我们将学习如何将线程作为一个后台任务运行，这被称为*守护进程*。当关闭主线程，即我们的GUI时，所有守护进程也会自动停止。
- en: Getting ready
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: When we call methods in a thread, we can also pass arguments and keyword arguments
    to the method. We start this recipe by doing exactly that. We will start with
    the code from the previous recipe.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在线程中调用方法时，我们也可以向方法传递参数和关键字参数。我们通过这样做来开始这个菜谱。我们将从上一个菜谱中的代码开始。
- en: How to do it…
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'By adding `args=[8]` to the thread constructor and modifying the targeted method
    to expect arguments, we can pass arguments to the threaded methods. The parameter
    to `args` has to be a sequence, so we will wrap our number in a Python list. Let''s
    go through the process:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在线程构造函数中添加`args=[8]`并将目标方法修改为期望参数，我们可以向线程方法传递参数。`args`参数必须是一个序列，因此我们将我们的数字包裹在一个Python列表中。让我们通过这个过程来了解一下：
- en: Open `GUI_multiple_threads_starting_a_thread.py` and save it as `GUI_multiple_threads_stopping_a_thread.py`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GUI_multiple_threads_starting_a_thread.py`并将其保存为`GUI_multiple_threads_stopping_a_thread.py`。
- en: 'Change `run_thread` to `self.run_thread` and `arg=[8]`:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`run_thread`改为`self.run_thread`并将`arg=[8]`改为`arg=[8]`：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add `num_of_loops` as a new argument to `method_in_a_thread`:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`num_of_loops`作为新参数添加到`method_in_a_thread`中：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Run the code, click the button, and then close the GUI:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，点击按钮，然后关闭GUI：
- en: '![](img/21acf656-06a6-4577-b10f-51817b202b84.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/21acf656-06a6-4577-b10f-51817b202b84.png)'
- en: 'Add `self.run_thread.setDaemon(True)` to the code:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码中添加`self.run_thread.setDaemon(True)`：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run the modified code, click the button, and then close the GUI:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行修改后的代码，点击按钮，然后关闭GUI：
- en: '![](img/3b911aad-f77e-43d9-9f06-1c182121ef82.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3b911aad-f77e-43d9-9f06-1c182121ef82.png)'
- en: Let's now see how the recipe works!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看这个菜谱是如何工作的！
- en: How it works…
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the following code, `run_thread` is a local variable, which we only access
    within the scope of the method inside which we created `run_thread`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，`run_thread`是一个局部变量，我们只在我们创建`run_thread`的方法的作用域内访问它：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: By turning the local variable into a class instance attribute, we can then check
    if the thread is still running by calling `isAlive` on it from another method.
    In `GUI_multiple_threads_stopping_a_thread.py`, we have elevated our local `run_thread`
    variable to an instance attribute of our class. This enables us to access the
    `self.run_thread` variable from any method in our class.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将局部变量转换为类实例属性，我们可以通过在另一个方法中调用它的`isAlive`来检查线程是否仍在运行。在`GUI_multiple_threads_stopping_a_thread.py`中，我们将我们的局部`run_thread`变量提升为类的实例属性。这使得我们可以从我们类中的任何方法访问`self.run_thread`变量。
- en: When we click the button and then exit the GUI before the thread has finished,
    we get a runtime error.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击按钮然后在线程完成之前退出GUI时，我们会得到一个运行时错误。
- en: Threads are expected to finish their assigned task, so when we close the GUI
    before the thread has completed, according to the error, Python tells us that
    the thread we started is not in the main event loop. We can solve this by turning
    the thread into a *daemon*, which will then execute as a background task. What
    this gives us is that as soon as we close our GUI, which is our main thread that
    starts other threads, the daemon threads will cleanly exit. We do this by calling
    the `setDaemon(True)` method on the thread before we start the thread.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 预期线程完成其分配的任务，因此当我们在线程完成之前关闭GUI时，根据错误信息，Python告诉我们我们启动的线程不在主事件循环中。我们可以通过将线程转换为*守护线程*来解决这个问题，这样它就会作为一个后台任务执行。这给我们带来的好处是，当我们关闭我们的GUI，即我们的主要线程，它启动其他线程时，守护线程会干净地退出。我们通过在启动线程之前调用线程的`setDaemon(True)`方法来实现这一点。
- en: When we now click the button and exit our GUI before the thread has completed
    its assigned task, we no longer get any errors. While there is a `start` method
    to make threads run, surprisingly there isn't really an equivalent stop method.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们现在点击按钮并在线程完成其分配的任务之前退出我们的GUI时，我们不再收到任何错误。虽然有一个`start`方法可以让线程运行，但令人惊讶的是，并没有一个等效的停止方法。
- en: In this recipe, we are running a method in a thread, which prints numbers to
    our `ScrolledText` widget. When we exit our GUI, we are no longer interested in
    the thread that used to print to our widget, so by turning the thread into a *daemon*,
    we can exit our GUI cleanly.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们在一个线程中运行一个方法，该方法将数字打印到我们的`ScrolledText`小部件中。当我们退出GUI时，我们不再对曾经打印到我们小部件的线程感兴趣，因此通过将线程转换为*守护线程*，我们可以干净地退出GUI。
- en: Let's move on to the next recipe.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续下一个菜谱。
- en: How to use queues
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用队列
- en: A Python queue is a data structure that implements the **First In, First Out**
    (**FIFO**) paradigm, basically working like a pipe. You shovel something into
    the pipe on one side and it falls out on the other side of the pipe.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Python队列是一个实现**先进先出**（**FIFO**）范式的数据结构，基本上就像一个管道。你在一侧把东西铲进管道，它就会从管道的另一侧掉出来。
- en: The main difference between this queue shoveling and shoveling mud into physical
    pipes is that, in Python queues, things do not get mixed up. You put one unit
    in, and that unit comes back out on the other side. Next, you place another unit
    in (say, for example, an instance of a class), and this entire unit will come
    back out on the other end as one piece. It comes back out at the other end in
    the exact order we inserted code into the queue.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与将泥铲入物理管道相比，这个队列铲泥的主要区别在于，在Python队列中，事物不会混淆。你放一个单位进去，那个单位就会从另一侧出来。接下来，你放另一个单位进去（例如，一个类的实例），这个整个单位就会作为一个整体从另一端出来。它以我们插入队列代码的确切顺序从另一端出来。
- en: A queue is not a stack in which we push and pop data. A stack is a **Last In,
    First Out** (**LIFO**) data structure.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 队列不是一个我们推和弹出数据的栈。栈是一个**后进先出**（**LIFO**）的数据结构。
- en: Queues are containers that hold data being fed into the queue from potentially
    different data sources. We can have different clients providing data to the queue
    whenever those clients have data available. Whichever client is ready to send
    data to our queue sends it, and we can then display this data in a widget or send
    it forward to other modules.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 队列是容器，用于存储从可能不同的数据源输入队列中的数据。当这些客户端有数据可用时，我们可以让不同的客户端向队列提供数据。哪个客户端准备好向我们的队列发送数据就发送，然后我们可以在小部件中显示这些数据或将它们发送到其他模块。
- en: Using multiple threads to complete assigned tasks in a queue is very useful
    when receiving the final results of processing and displaying them. The data is
    inserted at one end of the queue and then comes out of the other end in an ordered
    fashion, FIFO.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个线程在队列中完成分配的任务，在接收处理结果的最终结果并显示它们时非常有用。数据被插入到队列的一端，然后以有序的方式从另一端出来，FIFO。
- en: Our GUI might have five different button widgets such that each kicks off a
    different task that we want to display in our GUI in a widget (for example, a
    `ScrolledText` widget). These five different tasks take a different amount of
    time to complete.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的GUI可能有五个不同的按钮小部件，这样每个都可以启动一个不同的任务，我们希望在GUI中的小部件中显示这些任务（例如，一个`ScrolledText`小部件）。这五个不同的任务完成所需的时间各不相同。
- en: Whenever a task has completed, we immediately need to know this and display
    this information in our GUI. By creating a shared Python queue and having the
    five tasks write their results to this queue, we can display the result of whichever
    task has been completed immediately using the FIFO approach.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 每当一项任务完成时，我们立即需要知道这一点，并在GUI中显示此信息。通过创建共享的Python队列并让五个任务将它们的结果写入此队列，我们可以使用FIFO方法立即显示已完成任务的任何任务的结果。
- en: Getting ready
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: As our GUI is ever-increasing in its functionality and usefulness, it starts
    to talk to networks, processes, and websites, and will eventually have to wait
    for data to be made available for the GUI to display.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的GUI在功能性和实用性上的不断增长，它开始与网络、进程和网站进行通信，最终将不得不等待数据可用以便GUI显示。
- en: Creating queues in Python solves the problem of waiting for data to be displayed
    inside our GUI.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中创建队列解决了在GUI内部等待数据显示的问题。
- en: How to do it…
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In order to create queues in Python, we have to import the `Queue` class from
    the `queue` module. Add the following statement toward the top of the GUI module:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Python中创建队列，我们必须从`queue`模块导入`Queue`类。在GUI模块的顶部添加以下语句：
- en: Open `GUI_multiple_threads_starting_a_thread.py` and save it as `GUI_queues.py`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GUI_multiple_threads_starting_a_thread.py`并将其保存为`GUI_queues.py`。
- en: 'Make the following changes to the code:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对代码进行以下更改：
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the following method:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Modify the `click_me` method:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`click_me`方法：
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Run the preceding code and observe the output as illustrated in the following
    screenshot:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行前面的代码并观察输出，如图所示：
- en: '![](img/e872e17c-7ae7-4d25-b4f1-2daef454f306.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e872e17c-7ae7-4d25-b4f1-2daef454f306.png)'
- en: 'Modify `use_queues` to use `put` and `get`:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`use_queues`以使用`put`和`get`：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run the preceding code and observe the output, as illustrated in the following
    screenshot:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行前面的代码并观察输出，如图所示：
- en: '![](img/eec7e109-b773-429b-b631-d15519251f45.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eec7e109-b773-429b-b631-d15519251f45.png)'
- en: 'Write a loop to place many messages into `Queue`:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个循环，将许多消息放入`Queue`：
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the preceding code:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行前面的代码：
- en: '![](img/03a2a616-a142-4804-be58-29d29dcffc44.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/03a2a616-a142-4804-be58-29d29dcffc44.png)'
- en: 'Add a `while` loop:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`while`循环：
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Run the preceding code to see the following result:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行前面的代码以查看以下结果：
- en: '![](img/dc9c5e41-1042-480e-ac21-ba99b95023c4.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dc9c5e41-1042-480e-ac21-ba99b95023c4.png)'
- en: 'Now, let''s consider the scenario of the endless loop:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑无限循环的场景：
- en: Open `GUI_queues.py` and save it as `GUI_queues_put_get_loop_endless_threaded.py`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GUI_queues.py`并将其保存为`GUI_queues_put_get_loop_endless_threaded.py`。
- en: 'Make the following changes to start `self.run_thread` as a background daemon
    thread:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行以下更改以将`self.run_thread`作为后台守护线程启动：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the `click_me` method, we comment out `self.use_queues()` and now call `self.create_thread()`
    instead:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`click_me`方法中，我们注释掉`self.use_queues()`并现在调用`self.create_thread()`：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Run the code to see the following result:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码以查看以下结果：
- en: '![](img/bcc41345-1ff2-4803-9cbb-7f79f277af56.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bcc41345-1ff2-4803-9cbb-7f79f277af56.png)'
- en: Let's go behind the scenes to understand the code better.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解代码以更好地理解它。
- en: How it works…
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In `GUI_queues.py`, we first add `import` statements and then create a new method
    to create `Queue`. We call the method within our button click event.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GUI_queues.py`中，我们首先添加`import`语句，然后创建一个新的方法来创建`Queue`。我们在按钮点击事件中调用该方法。
- en: In the code, we create a local `Queue` instance that is only accessible within
    this method. If we wish to access this queue from other places, we have to turn
    it into an instance attribute of our class by using the `self` keyword, which
    binds the local variable to the entire class, making it available from any other
    method within our class. In Python, we often create class instance variables in
    the `__init__(self)` method, but Python is very pragmatic and enables us to create
    those attributes anywhere in the code.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们创建了一个局部`Queue`实例，该实例仅在此方法内部可访问。如果我们希望从其他地方访问此队列，我们必须使用`self`关键字将其转换为类的实例属性，这会将局部变量绑定到整个类，使其可在类中的任何其他方法中访问。在Python中，我们通常在`__init__(self)`方法中创建类实例变量，但Python非常实用，允许我们在代码的任何位置创建这些属性。
- en: Now we have an instance of a queue. We can see that this works by printing it
    out.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个队列的实例。我们可以通过打印它来看到这是如何工作的。
- en: In order to put the data into the queue, we use the `put` command. In order
    to get the data out of the queue, we use the `get` command.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将数据放入队列，我们使用`put`命令。为了从队列中获取数据，我们使用`get`命令。
- en: Running the code results in the message first being placed in `Queue`, then
    being taken out of `Queue`, and then being printed to the console. We have placed
    10 messages into `Queue`, but we are only getting the first one out. The other
    messages are still inside `Queue`, waiting to be taken out in a FIFO fashion.
    In order to get all the messages that have been placed into `Queue` out, we can
    create an endless loop.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码的结果是消息首先被放入`Queue`，然后从`Queue`中取出，然后被打印到控制台。我们已将10条消息放入`Queue`，但我们只取出第一条。其他消息仍然在`Queue`中，等待以FIFO的方式取出。为了取出所有已放入`Queue`的消息，我们可以创建一个无限循环。
- en: While this code works, unfortunately, it freezes our GUI. In order to fix this,
    we have to call the method in its own thread, as we did in the previous recipes.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这段代码可以工作，但不幸的是，它使我们的GUI冻结。为了解决这个问题，我们必须在它的自己的线程中调用该方法，就像我们在前面的食谱中所做的那样。
- en: We do this in `GUI_queues_put_get_loop_endless_threaded.py`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`GUI_queues_put_get_loop_endless_threaded.py`中这样做。
- en: When we now click the button, the GUI no longer freezes and the code works.
    We created `Queue` and placed messages into one side of `Queue` in a FIFO fashion.
    We got the messages out of `Queue` and then printed them to the console (`stdout`).
    We realized that we have to call the method in its own thread because, otherwise,
    our GUI might freeze.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们现在点击按钮时，GUI不再冻结，代码可以正常工作。我们创建了`Queue`，并以FIFO的方式将消息放入`Queue`的一侧。我们从`Queue`中取出消息，然后将其打印到控制台（`stdout`）。我们意识到我们必须在它的自己的线程中调用该方法，否则我们的GUI可能会冻结。
- en: Let's move on to the next recipe.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续下一个食谱。
- en: Passing queues among different modules
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在不同模块之间传递队列
- en: In this recipe, we will pass queues around different modules. As our GUI code
    increases in complexity, we want to separate the GUI components from the business
    logic, separating them out into different modules. Modularization allows us to
    reuse code and also makes the code more readable.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将传递不同模块之间的队列。随着我们的GUI代码复杂性的增加，我们希望将GUI组件从业务逻辑中分离出来，将它们分离到不同的模块中。模块化使我们能够重用代码，并使代码更具可读性。
- en: Once the data to be displayed in our GUI comes from different data sources,
    we will face latency issues, which is what queues solve. By passing instances
    of `Queue` among different Python modules, we are separating the different concerns
    of the modules' functionalities.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在我们的GUI中显示的数据来自不同的数据源时，我们将面临延迟问题，这正是队列解决的问题。通过在不同Python模块之间传递`Queue`的实例，我们正在分离模块功能的不同关注点。
- en: The GUI code ideally would only be concerned with creating and displaying widgets
    and data.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 理想的GUI代码只应关注创建和显示小部件以及数据。
- en: The business logic modules' job is only to do the business logic and supply
    the resulting data to the GUI.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 业务逻辑模块的工作只是执行业务逻辑并向GUI提供结果数据。
- en: We have to combine the two elements, ideally using as few relationships among
    the different modules as possible, reducing code interdependence.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须结合这两个元素，理想情况下使用尽可能少的模块间关系，减少代码依赖性。
- en: The coding principle of avoiding unnecessary dependencies is usually called
    *loose coupling*. This is a very important principle and I strongly encourage
    you to look into it, understand it, and apply it to your own coding projects.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 避免不必要的依赖的编码原则通常被称为*松散耦合*。这是一个非常重要的原则，我强烈建议你深入研究它，理解它，并将其应用到自己的编码项目中。
- en: In order to understand the significance of *loose coupling*, we can draw some
    boxes on a whiteboard or a piece of paper. One box represents our GUI class and
    code, while the other boxes represent business logic, databases, and so on.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解*松散耦合*的重要性，我们可以在白板或一张纸上画一些盒子。一个盒子代表我们的GUI类和代码，而其他盒子代表业务逻辑、数据库等。
- en: 'Next, we draw lines between the boxes, graphing out the interdependencies between
    those boxes, which are our Python modules, as shown here:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在盒子之间画线，绘制出这些盒子（即我们的Python模块）之间的相互依赖关系，如图所示：
- en: '![](img/61dc851a-e4f2-423e-89aa-42e8016a91bf.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61dc851a-e4f2-423e-89aa-42e8016a91bf.png)'
- en: While these three boxes connected via three lines might look a little simple,
    this is what you really would draw on a whiteboard in a software team meeting.
    I have left out any labels, but one box could be labeled **UI**, another **database**,
    and a third **business processing logic**.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这三个通过三条线连接的盒子看起来可能有点简单，但这正是你会在软件团队会议的白板上画出的内容。我已经省略了任何标签，但一个盒子可以标记为**UI**，另一个**数据库**，第三个**业务处理逻辑**。
- en: The fewer lines we have between our Python boxes, the more *loosely coupled*
    our design is.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们Python盒子之间的线条越少，我们的设计就越是*松散耦合*。
- en: Getting ready
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the previous recipe, *How to use queues*, we started to use queues. In this
    recipe, we will pass instances of `Queue` from our main GUI thread to other Python
    modules, which will enable us to write to the `ScrolledText` widget from another
    module while keeping our GUI responsive.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配方中，*如何使用队列*，我们开始使用队列。在这个配方中，我们将从我们的主GUI线程传递`Queue`实例到其他Python模块，这将使我们能够从另一个模块写入`ScrolledText`小部件，同时保持我们的GUI响应。
- en: How to do it…
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'First, we create a new Python module in our project. Let''s call it `Queues.py`.
    We''ll place a function into it (no OOP necessary yet). Sequentially, we can state
    it as follows:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们在项目中创建一个新的Python模块。让我们称它为`Queues.py`。我们将一个函数放入其中（目前不需要面向对象）。依次，我们可以这样表述：
- en: Create a new Python module and name it `Queues.py`.
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Python模块，并命名为`Queues.py`。
- en: 'Write the following code into this module to place messages into the instance
    queue:'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码写入此模块以将消息放入实例队列：
- en: '[PRE23]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The next steps show how we shall import this newly created module:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步将展示我们如何导入这个新创建的模块：
- en: Open `GUI_queues_put_get_loop_endless_threaded.py` and save it as `GUI_passing_queues_member.py`.
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GUI_queues_put_get_loop_endless_threaded.py`并将其保存为`GUI_passing_queues_member.py`。
- en: 'Make the following changes to invoke the function from the module we are importing:'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对导入的模块进行以下更改以调用该函数：
- en: '[PRE24]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In `GUI_passing_queues_member.py`, create an instance of `Queue`:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GUI_passing_queues_member.py`中创建一个`Queue`的实例：
- en: '[PRE25]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Modify the `use_queues` method:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`use_queues`方法：
- en: '[PRE26]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Running the code yields the following result:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码会产生以下结果：
- en: '![](img/437cc42c-7d33-46aa-9255-d96eaa75cf9d.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/437cc42c-7d33-46aa-9255-d96eaa75cf9d.png)'
- en: Let's go behind the scenes to understand the code better.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解代码以更好地理解它。
- en: How it works…
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: First, we create a new Python module, `Queues.py`. The `write_to_scrol` function
    within it accepts an instance of a class. We use this instance to access the methods
    and attributes of the class.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个新的Python模块，名为`Queues.py`。其中`write_to_scrol`函数接受一个类的实例。我们使用这个实例来访问类的方法和属性。
- en: Here, we are relying on the knowledge that our class instance has the two methods
    we are accessing within the function.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们依赖于我们的类实例具有我们函数中访问的两个方法。
- en: In `GUI_passing_queues_member.py`, we first import the `Queues` module, alias
    it to `bq`, and then we use it to call the function residing in the `Queues` module.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GUI_passing_queues_member.py`中，我们首先导入`Queues`模块，将其别名设置为`bq`，然后我们使用它来调用位于`Queues`模块中的函数。
- en: Aliasing the module to `bq` is probably not the best name. I meant it to mean
    *background queue* because it runs threads as daemons in the background. I am
    not changing the alias in this third edition as I have used it in the first two
    editions of this book, for reasons of consistency.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 将模块别名设置为`bq`可能不是最好的名字。我的意思是想表示*后台队列*，因为它在后台以守护线程的形式运行。由于我在本书的前两版中已经使用了它，出于一致性的原因，我在这一版中不更改别名。
- en: In the `click_me` button callback method, we are passing `self` into this function.
    This enables us to use all of the GUI methods from another Python module.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在`click_me`按钮回调方法中，我们将`self`传递给这个函数。这使得我们能够从另一个Python模块中使用所有的GUI方法。
- en: 'The imported module contains the `write_to_scrol` function we are calling:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 导入的模块包含我们正在调用的`write_to_scrol`函数：
- en: '[PRE27]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: By passing in a self-reference from the class instance to the function that
    the class is calling in another module, we now have access to all our GUI elements
    from other Python modules.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 通过传递类实例的自我引用到另一个模块中类调用的函数，我们现在可以从其他Python模块访问所有我们的GUI元素。
- en: '`gui_queue` is an instance attribute and `create_thread` is a method, and both
    are defined in `GUI_passing_queues_member.py`, and we are accessing them via the
    passed-in self-reference inside the `Queues` module.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`gui_queue`是一个实例属性，`create_thread`是一个方法，两者都在`GUI_passing_queues_member.py`中定义，我们通过`Queues`模块中传递的self引用来访问它们。'
- en: We create `Queue` as an instance attribute of our class, placing a reference
    to it in the `__init__` method of the `GUI_passing_queues_member.py` class.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`Queue`创建为类的实例属性，将其引用放置在`GUI_passing_queues_member.py`类的`__init__`方法中。
- en: 'Now we can put messages into the queue from our new module by simply using
    the passed-in class reference to our GUI. Notice `inst.gui_queue.put` in the `Queues.py`
    code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过简单地使用传递给我们的GUI的类引用，从我们的新模块中向队列中放入消息。注意`Queues.py`代码中的`inst.gui_queue.put`：
- en: '[PRE28]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: After we modified the `use_queues` method, the `create_thread` method in our
    GUI code only reads from the `Queue`, which got filled in by the business logic
    residing in our new module, which has separated the logic from our GUI module.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们修改了 `use_queues` 方法之后，我们的图形用户界面（GUI）代码中的 `create_thread` 方法只从 `Queue` 中读取，这个
    `Queue` 被我们新模块中的业务逻辑填充，这个新模块将逻辑从我们的图形用户界面（GUI）模块中分离出来。
- en: In order to separate the GUI widgets from the functionality that expresses the
    business logic, we created a class, made a queue an instance attribute of this
    class, and, by passing an instance of the class into a function residing in a
    different Python module, we now have access to all the GUI widgets, as well as
    the queue.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将图形用户界面（GUI）小部件与表达业务逻辑的功能分离，我们创建了一个类，将队列作为该类的实例属性，并通过将类的实例传递到不同 Python 模块中的函数，我们现在可以访问所有图形用户界面（GUI）小部件以及队列。
- en: This is the magic of OOP. In the middle of a class, we pass ourselves into a
    function we are calling from within the class using the `self` keyword.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是面向对象编程（OOP）的魔力。在一个类的中间，我们使用 `self` 关键字将自身传递给类内部调用的函数。
- en: This recipe is an example of when it makes sense to program in OOP.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱是一个例子，说明了在面向对象编程（OOP）中编程是有意义的。
- en: Let's move on to the next recipe.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续下一个菜谱。
- en: Using dialog widgets to copy files to your network
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用对话框小部件将文件复制到您的网络
- en: This recipe shows us how to copy files from your local hard drive to a network
    location. We will do this by using one of Python's `tkinter` built-in dialogs,
    which enables us to browse our hard drive. We can then select a file to be copied.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱展示了如何从您的本地硬盘复制文件到网络位置。我们将通过使用 Python 的 `tkinter` 内置对话框来完成此操作，它使我们能够浏览硬盘。然后我们可以选择要复制的文件。
- en: This recipe also shows us how to make `Entry` widgets read-only and to default
    `Entry` to a specified location, which speeds up the browsing of our hard drive.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱还展示了如何使 `Entry` 小部件只读，并将 `Entry` 默认设置为指定位置，这可以加快浏览硬盘的速度。
- en: Getting ready
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will extend Tab 2 of the GUI we were building in the previous recipe, *Passing
    queues among different modules*.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展前一个菜谱中构建的图形用户界面（GUI）的第二个标签页，*在不同模块间传递队列*。
- en: How to do it…
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Add the following code to the GUI in the `create_widgets()` method toward the
    bottom, where we created Tab Control 2\. The parent of the new widget frame is
    `tab2`, which we created at the very beginning of the `create_widgets()` method.
    As long as you place the following code physically under the creation of `tab2`,
    it will work:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `create_widgets()` 方法中接近底部的地方，我们将添加以下代码到图形用户界面（GUI）中，在那里我们创建了标签控制 2。新的小部件框架的父元素是
    `tab2`，我们在 `create_widgets()` 方法的开头创建了它。只要您将以下代码物理地放置在 `tab2` 创建的下方，它就会工作：
- en: Open `GUI_passing_queues_member.py` and save it as `GUI_copy_files.py`.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GUI_passing_queues_member.py` 并将其保存为 `GUI_copy_files.py`。
- en: 'Make the following changes:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行以下更改：
- en: '[PRE29]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Running the code creates the following GUI:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码会创建以下图形用户界面（GUI）：
- en: '![](img/8347b6be-7b48-44df-a0c4-c0849731a102.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8347b6be-7b48-44df-a0c4-c0849731a102.png)'
- en: 'Click the Browse to File... button:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击浏览到文件…按钮：
- en: '![](img/5ce731b5-969c-4d48-ab42-0378efd326e5.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ce731b5-969c-4d48-ab42-0378efd326e5.png)'
- en: Open `GUI_copy_files.py`.
  id: totrans-243
  prefs:
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GUI_copy_files.py`。
- en: 'Add the following two `import` statements:'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下两个 `import` 语句：
- en: '[PRE30]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create the following function:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下函数：
- en: '[PRE31]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run the code and click the Browse To button:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并点击浏览到按钮：
- en: '![](img/82704756-3891-4b5f-85b4-742074b272b2.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82704756-3891-4b5f-85b4-742074b272b2.png)'
- en: 'Add the following two lines of code to the creation of the `Entry` widget:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建 `Entry` 小部件时添加以下两行代码：
- en: '[PRE32]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Run the code and see the following result:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看以下结果：
- en: '![](img/5ca24e3f-24e2-487a-a5fd-6d5a726d191b.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ca24e3f-24e2-487a-a5fd-6d5a726d191b.png)'
- en: 'Now, open `GUI_copy_files.py` and add the following code:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开 `GUI_copy_files.py` 并添加以下代码：
- en: '[PRE33]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Running `GUI_copy_files.py` results in the following screenshot:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `GUI_copy_files.py` 会导致以下截图：
- en: '![](img/2756175f-0bf5-4ea8-a098-aee15a687d4b.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2756175f-0bf5-4ea8-a098-aee15a687d4b.png)'
- en: 'Open `GUI_copy_files.py` and add the following code:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GUI_copy_files.py` 并添加以下代码：
- en: '[PRE34]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Once we click the button that invokes the `copyFile()` function, we import the
    required module.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们点击调用 `copyFile()` 函数的按钮，我们就导入所需的模块。
- en: 'Open `GUI_copy_files.py` and add the following code:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GUI_copy_files.py` 并添加以下代码：
- en: '[PRE35]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Run the code, browse to a file, and click the Copy button:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，浏览到文件，并点击复制按钮：
- en: '![](img/a7baa723-878c-4235-b7c3-57b70c3ff9d4.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7baa723-878c-4235-b7c3-57b70c3ff9d4.png)'
- en: 'Run the code, but don''t browse and click the Copy button:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，但不要浏览并点击复制按钮：
- en: '![](img/f30c5437-aac1-4a63-962c-29eaac6b9960.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f30c5437-aac1-4a63-962c-29eaac6b9960.png)'
- en: Open `GUI_copy_files.py` and save it as `GUI_copy_files_limit.py`.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GUI_copy_files.py`并将其保存为`GUI_copy_files_limit.py`。
- en: 'Add the following code:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '![](img/58658b51-0c57-414c-a60a-f9a6e7079baa.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/58658b51-0c57-414c-a60a-f9a6e7079baa.png)'
- en: 'Run the preceding code to observe the output, as illustrated in the following
    screenshot:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行前面的代码以观察输出，如下面的截图所示：
- en: '![](img/d9997425-532d-4e48-acdb-f41a70221cf4.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9997425-532d-4e48-acdb-f41a70221cf4.png)'
- en: Let's go behind the scenes to understand the code better.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解代码以更好地理解它。
- en: How it works…
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In `GUI_copy_files.py`, we add two buttons and two entries to Tab 2 of our GUI.
    We are not yet implementing the functionality of our button callback function.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GUI_copy_files.py`中，我们在GUI的标签2中添加了两个按钮和两个输入框。我们还没有实现按钮回调函数的功能。
- en: Clicking the Browse to File... button currently prints `hello from getFileName`
    to the console. We can use the `tkinter` built-in file dialogs after adding the
    `import` statements.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“浏览文件...”按钮当前会在控制台打印`hello from getFileName`。在添加`import`语句后，我们可以使用`tkinter`内置的文件对话框。
- en: We can now use the dialogs in our code. Instead of hardcoding a path, we can
    use Python's `os` module to find the full path to where our GUI module resides.
    Clicking the Browse to File... button now opens up the `askopenfilename` dialog.
    We can now open a file in this directory or browse to a different directory. After
    selecting a file and clicking the Open button in the dialog, we will save the
    full path to the file in the `fName` local variable.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在代码中使用对话框。而不是硬编码路径，我们可以使用Python的`os`模块来找到我们的GUI模块所在的全路径。点击“浏览文件...”按钮现在会打开`askopenfilename`对话框。我们现在可以在这个目录中打开文件或浏览到不同的目录。在对话框中选择文件并点击“打开”按钮后，我们将文件的全路径保存到`fName`局部变量中。
- en: It would be nice if, when we opened our Python `askopenfilename` dialog widget,
    we would automatically default to a directory so that we would not have to browse
    all the way to where we were looking for a particular file to be opened. It is
    best to demonstrate how to do this by going back to our GUI Tab 1, which is what
    we will do next.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在打开Python的`askopenfilename`对话框小部件时，它自动默认到一个目录，这样我们就不必浏览到我们要打开特定文件的地方。最好的做法是通过回到我们的GUI标签1来演示如何做这件事，这就是我们接下来要做的。
- en: We can default the values into `Entry` widgets. Back on our Tab 1, this is very
    easy. When we now run the GUI, the `name_entered` entry has a default value. We
    can get the full path to the module we are using, and then we can create a new
    subfolder just below it. We can do this as a module-level global variable, or
    we can create the subfolder within a method.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将值默认到`Entry`小部件中。回到我们的标签1，这非常简单。当我们现在运行GUI时，`name_entered`输入框有一个默认值。我们可以获取我们正在使用的模块的全路径，然后我们可以在它下面创建一个新的子文件夹。我们可以将这作为一个模块级别的全局变量，或者我们可以在一个方法中创建子文件夹。
- en: We set the defaults for both the `Entry` widgets and, after setting them, we
    make the local file `Entry` widget read-only.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为两个`Entry`小部件设置了默认值，并在设置后，使本地文件`Entry`小部件为只读。
- en: This order is important. We have to first populate the entry before we make
    it read-only.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这个顺序很重要。我们必须首先填充输入框，然后再将其设置为只读。
- en: 'We are also selecting Tab 2 before calling the main event loop and no longer
    set the focus into the `Entry` of Tab 1\. Calling `select` on our `notebook` of
    `tkinter` is zero-based, so by passing in the value of `1`, we select Tab 2:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用主事件循环之前，我们也在选择标签2，并且不再将焦点设置到标签1的`Entry`中。在`tkinter`的`notebook`上调用`select`是零基索引的，所以通过传入值`1`，我们选择了标签2：
- en: '[PRE36]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As we are not all on the same network, this recipe uses the local hard drive
    in place of a network.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不在同一个网络上，这个菜谱使用本地硬盘代替网络。
- en: A **UNC** path is a **Universal Naming Convention**, and what this means is
    that by using double backslashes instead of the typical `C:\`, we can access a
    server on a network.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**UNC**路径是**通用命名约定**，这意味着通过使用双反斜杠而不是典型的`C:\`，我们可以访问网络上的服务器。'
- en: You just have to use the UNC and replace `C:\` with `\\<servername>\<folder>`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需使用UNC路径，并将`C:\`替换为`\\<servername>\<folder>`。
- en: This example can be used to back up our code to a backup directory, which we
    can create if it does not exist by using `os.makedirs`. After selecting a file
    to copy to somewhere else, we import the Python `shutil` module. We need the full
    path to the source of the file to be copied and a network or local directory path,
    and then we append the filename to the path where we will copy it using `shutil.copy`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以用来将我们的代码备份到备份目录，如果它不存在，我们可以使用`os.makedirs`来创建它。在选择了要复制到其他地方的文件后，我们导入Python的`shutil`模块。我们需要复制文件的源完整路径以及网络或本地目录路径，然后使用`shutil.copy`将文件名追加到我们将要复制的路径中。
- en: '`shutil` is shorthand notation for shell utility.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`shutil` 是shell工具的缩写表示。'
- en: We also give feedback to the user via a message box to indicate whether the
    copying succeeded or failed. In order to do this, we import `messagebox` and alias
    it to `msg`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过消息框向用户反馈，以指示复制是否成功。为了做到这一点，我们导入`messagebox`并将其别名设置为`msg`。
- en: In the next code, we mix two different approaches of where to place our `import`
    statements. In Python, we have some flexibility that other languages do not provide.
    We typically place all of the `import` statements toward the very top of each
    of our Python modules so that it is clear which modules we are importing. At the
    same time, a modern coding approach is to place the creation of variables close
    to the function or method where they are first being used.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的代码中，我们混合了两种不同的放置`import`语句的方法。在Python中，我们有其他语言所不具备的灵活性。我们通常将所有的`import`语句放置在每个Python模块的顶部，以便清楚地知道我们正在导入哪些模块。同时，现代编码方法是将变量的创建放置在它们首次被使用的函数或方法附近。
- en: In the code, we import the message box at the top of our Python module, but
    then we also import the `shutil` Python module in a function. Why would we wish
    to do this? Does this even work? The answer is yes, it does work, and we are placing
    this `import` statement into a function because this is the only place in our
    code where we actually do need this module.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们在Python模块的顶部导入消息框，但随后也在一个函数中导入了`shutil` Python模块。我们为什么希望这样做？这样做甚至可行吗？答案是肯定的，它是可行的，我们将这个`import`语句放入函数中，因为这是我们代码中唯一真正需要此模块的地方。
- en: If we never call this method, then we will never import the module this method
    requires. In a sense, you can view this technique as the **lazy initialization
    design pattern**. If we don't need it, we don't import it until we really do require
    it in our Python code. The idea here is that our entire code might require, let's
    say, 20 different modules. At runtime, which modules are really needed depends
    upon the user interaction. If we never call the `copyFile()` function, then there
    is no need to import `shutil`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从未调用这个方法，那么我们永远不会导入这个方法所需的模块。从某种意义上说，你可以将这种技术视为**懒加载初始化设计模式**。如果我们不需要它，我们不会在Python代码中真正需要它时才导入它。这里的想法是，我们的整个代码可能需要，比如说，20个不同的模块。在运行时，哪些模块真正需要取决于用户交互。如果我们从未调用`copyFile()`函数，那么就没有必要导入`shutil`。
- en: When we now run our GUI, browse to a file, and click Copy, the file is copied
    to the location we specified in our Entry widget.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们现在运行GUI，浏览到文件，并点击复制时，文件将被复制到我们在Entry小部件中指定的位置。
- en: If the file does not exist or we forgot to browse to a file and are trying to
    copy the entire parent folder, the code will let us know this as well because
    we are using Python's built-in exception handling capabilities.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件不存在或者我们忘记浏览到文件而试图复制整个父文件夹，代码也会告诉我们这一点，因为我们正在使用Python内置的异常处理功能。
- en: Our new `Entry` widgets did expand the width of the GUI. While it is sometimes
    nice to be able to see the entire path, at the same time, it pushes other widgets,
    making our GUI look not so good. We can solve this by restricting the width parameter
    of our `Entry` widgets. We do this in `GUI_copy_files_limit.py`. This results
    in a limited GUI size. We can right-arrow in the enabled `Entry` widget to get
    to the end of this widget.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新的`Entry`小部件确实扩展了GUI的宽度。虽然有时候看到整个路径是件好事，但同时它也会推其他小部件，使我们的GUI看起来不那么好。我们可以通过限制`Entry`小部件的宽度参数来解决这个问题。我们在`GUI_copy_files_limit.py`中这样做。这导致GUI大小有限。我们可以按右箭头键在启用的`Entry`小部件中到达该小部件的末尾。
- en: We are copying files from our local hard drive to a network by using the Python
    shell utility. As most of us are not connected to the same local area network,
    we simulate the copying by backing up our code to a different local folder.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用Python shell工具将文件从本地硬盘复制到网络上。由于我们大多数人没有连接到同一个局域网，我们通过将代码备份到不同的本地文件夹来模拟复制。
- en: We are using one of `tkinter` dialog controls, and by defaulting the directory
    paths, we can increase our efficiency in copying files.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用`tkinter`对话框控件之一，并通过默认目录路径，我们可以提高复制文件的效率。
- en: Let's move on to the next recipe.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续下一个菜谱。
- en: Using TCP/IP to communicate via networks
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TCP/IP通过网络进行通信
- en: This recipe shows you how to use `sockets` to communicate via *TCP/IP*. In order
    to achieve this, we need both an *IP address* and a *port number*.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱展示了如何使用`sockets`通过*TCP/IP*进行通信。为了实现这一点，我们需要一个*IP地址*和一个*端口号*。
- en: In order to keep things simple and independent of changing internet IP addresses,
    we will create our own local TCP/IP server and client, and we will learn how to
    connect the client to the server and read data via a TCP/IP connection.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情简单，并且独立于不断变化的互联网IP地址，我们将创建自己的本地TCP/IP服务器和客户端，我们将学习如何通过TCP/IP连接将客户端连接到服务器并读取数据。
- en: We will integrate this networking capability into our GUI by using the queues
    we created in the previous recipes.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用之前菜谱中创建的队列将这种网络功能集成到我们的GUI中。
- en: '**TCP/IP** short for **Transmission Control Protocol/Internet Protocol**, which
    is a set of networking protocols that allows two or more computers to communicate.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**TCP/IP**代表**传输控制协议/互联网协议**，是一组网络协议，允许两台或多台计算机进行通信。'
- en: Getting ready
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will create a new Python module, which will be the TCP server.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的Python模块，它将成为TCP服务器。
- en: How to do it…
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'One way to implement a TCP server in Python is to inherit from the `socketserver`
    module. We subclass `BaseRequestHandler` and then override the inherited `handle`
    method. In very few lines of Python code, we can implement a TCP server:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中实现TCP服务器的一种方法是从`socketserver`模块继承。我们子类化`BaseRequestHandler`然后覆盖继承的`handle`方法。在非常少的Python代码中，我们可以实现一个TCP服务器：
- en: Create a new Python module and save it as `TCP_Server.py`.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Python模块并将其保存为`TCP_Server.py`。
- en: 'Add the following code to create the TCP server and a `start` function:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码以创建TCP服务器和`start`函数：
- en: '[PRE37]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Open `Queues.py` and add the following code to create a socket and use it:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Queues.py`并添加以下代码以创建套接字并使用它：
- en: '[PRE38]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Open `GUI_copy_files_limit.py` and save it as `GUI_TCP_IP.py`.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GUI_copy_files_limit.py`并将其保存为`GUI_TCP_IP.py`。
- en: 'Add the following code to start the TCP server in its own thread:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码以在单独的线程中启动TCP服务器：
- en: '[PRE39]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Run the code and click the Click Me! button on Tab 1:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并点击Tab 1上的“点击我！”按钮：
- en: '![](img/2a300a1c-026c-4aa3-aa69-a5e7e4abaaa3.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2a300a1c-026c-4aa3-aa69-a5e7e4abaaa3.png)'
- en: Let's go behind the scenes to understand the code better.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入幕后更好地理解代码。
- en: How it works…
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In `TCP_Server.py`, we are passing our `RequestHandler` class into a `TCPServer`
    initializer. The empty single quotes are a shortcut for localhost, which is our
    own PC. This is the IP address of `127.0.0.1`. The second item in the tuple is
    the *port number*. We can choose any port number that is not in use on our local
    PC.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TCP_Server.py`中，我们将`RequestHandler`类传递给`TCPServer`初始化器。空的单引号是localhost的快捷方式，即我们的个人电脑。这是`127.0.0.1`的IP地址。元组中的第二个项目是*端口号*。我们可以选择任何在我们本地电脑上未使用的端口号。
- en: We have to make sure that we are using the same port on the client side of the
    TCP connection; otherwise, we would not be able to connect to the server.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保我们在TCP连接的客户端使用相同的端口；否则，我们就无法连接到服务器。
- en: Of course, we have to start the server first before clients can connect to it.
    We will modify our `Queues.py` module to become the TCP client. When we now click
    the Click Me! button, we are calling `bq.write_to_scrol_TCP(self)`, which then
    creates the socket and connection.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在客户端能够连接之前，我们必须首先启动服务器。我们将修改`Queues.py`模块以成为TCP客户端。当我们现在点击“点击我！”按钮时，我们正在调用`bq.write_to_scrol_TCP(self)`，然后创建套接字和连接。
- en: This is all the code we need to talk to the TCP server. In this example, we
    are simply sending some bytes to the server and the server sends them back, prepending
    some strings before returning the response.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们与TCP服务器通信所需的所有代码。在这个例子中，我们只是向服务器发送一些字节，服务器将它们发送回来，并在返回响应之前添加一些字符串。
- en: This shows the principle of how TCP communications via networks work.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了TCP通过网络通信的工作原理。
- en: Once we know how to connect to a remote server via TCP/IP, we will use whatever
    commands are designed by the protocol of the program we are interested in communicating
    with. The first step is to connect before we can send commands to specific applications
    residing on a server.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道了如何通过TCP/IP连接到远程服务器，我们将使用我们感兴趣与之通信的程序协议设计的任何命令。在我们可以向服务器上驻留的特定应用程序发送命令之前，第一步是连接。
- en: 'In the `write_to_scrol_TCP` function, we use the same loop as before, but now
    we will send the messages to the TCP server. The server modifies the received
    message and then sends it back to us. Next, we place it into the GUI class instance
    queue, which, as in the previous recipes, runs in its own thread:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在`write_to_scrol_TCP`函数中，我们使用与之前相同的循环，但现在我们将消息发送到TCP服务器。服务器修改接收到的消息，然后将其发送回我们。接下来，我们将它放入GUI类实例队列中，正如之前的菜谱中所述，它在自己的线程中运行：
- en: '[PRE40]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note the `b` character before the string and then the rest of the required casting.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 注意字符串前面的`b`字符，然后进行所需的其余转换。
- en: We start the TCP server in its own thread in the initializer of the OOP class.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在OOP类的初始化器中在自己的线程中启动TCP服务器。
- en: In Python 3, we send strings over sockets in binary format. Adding the integer
    index now becomes a little bit convoluted as we have to cast it to a string, encode
    it, and then cast the encoded string into bytes!
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3中，我们以二进制格式通过套接字发送字符串。现在添加整数索引变得有点复杂，因为我们不得不将其转换为字符串，对其进行编码，然后将编码后的字符串转换为字节！
- en: Clicking the Click Me! button on Tab 1 now creates the output in our `ScrolledText`
    widget as well as on the console, and the response because of the use of threads
    is very fast. We created a TCP server to simulate connecting to a server in our
    local area network or on the internet. We turned our queues module into a TCP
    client. We are running both the queue and the server in their own background thread,
    which keeps our GUI very responsive.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在Tab 1上点击“点击我！”按钮现在会在我们的`ScrolledText`小部件以及控制台上创建输出，由于使用了线程，响应速度非常快。我们创建了一个TCP服务器来模拟连接到我们局域网或互联网上的服务器。我们将我们的队列模块变成了TCP客户端。我们在各自的背景线程中运行队列和服务器，这使得我们的GUI非常响应。
- en: Let's move on to the next recipe.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续下一个菜谱。
- en: Using urlopen to read data from websites
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`urlopen`从网站读取数据
- en: This recipe shows how we can easily read entire web pages by using some of Python's
    built-in modules. We will display the web page data first in its raw format and
    then decode it, and then we will display it in our GUI.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱展示了我们如何通过使用Python的一些内置模块轻松地读取整个网页。我们首先以原始格式显示网页数据，然后对其进行解码，然后我们在我们的GUI中显示它。
- en: Getting ready
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will read the data from a web page and then display it in the `ScrolledText`
    widget of our GUI.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从网页中读取数据，然后在我们的GUI的`ScrolledText`小部件中显示它。
- en: How to do it…
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First, we create a new Python module and name it `URL.py`. We then import the
    required functionality to read web pages using Python. We can do this in very
    few lines of code:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个新的Python模块，并将其命名为`URL.py`。然后我们导入使用Python读取网页所需的功能。我们可以在非常少的代码行中做到这一点：
- en: Create a new module and name it `URL.py`.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的模块并命名为`URL.py`。
- en: 'Add the following code to open and read the URL:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码以打开和读取URL：
- en: '[PRE41]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Run the preceding code and observe the following output:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行前面的代码并观察以下输出：
- en: '![](img/300c4819-faeb-4a64-9f03-b8687d639cbe.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![](img/300c4819-faeb-4a64-9f03-b8687d639cbe.png)'
- en: 'Compare the result to the official Python web page we just read:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将结果与刚刚读取的官方Python网页进行比较：
- en: '![](img/9c82a0c1-eabe-40f5-af94-b4f73ac47a10.png)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c82a0c1-eabe-40f5-af94-b4f73ac47a10.png)'
- en: 'Let''s consider the next scenario:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑下一个场景：
- en: Open `URL.py`.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`URL.py`。
- en: 'Place the code into a function:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代码放入一个函数中：
- en: '[PRE42]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Open `GUI_TCP_IP.py` from the previous recipe and save it as `GUI_URL.py`.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上一个菜谱中的`GUI_TCP_IP.py`打开并保存为`GUI_URL.py`。
- en: 'Import the `URL` module and modify the `click_me` method:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`URL`模块并修改`click_me`方法：
- en: '[PRE43]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Run the code, the output of which is as follows:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，输出如下：
- en: '![](img/3ea25447-fbef-40de-a100-8e46dcf4881d.png)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3ea25447-fbef-40de-a100-8e46dcf4881d.png)'
- en: The next section talks about the process in detail.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将详细讨论这个过程。
- en: How it works…
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We wrap the `URL.py` code in a `try...except` block similar to Java and C#.
    This is a modern approach to coding, which Python supports. Whenever we have code
    that might not complete, we can experiment with this code and, if it works, all
    is fine. If the block of code in the `try...except` block does not work, the Python
    interpreter will throw one of several possible exceptions, which we can then catch.
    Once we have caught the exception, we can decide what to do next.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`URL.py`代码包裹在一个类似于Java和C#的`try...except`块中。这是一种现代的编程方法，Python支持。每当我们的代码可能无法完成时，我们可以尝试这段代码，如果它有效，那就没问题。如果`try...except`块中的代码无法工作，Python解释器将抛出几种可能的异常之一，然后我们可以捕获它。一旦我们捕获了异常，我们就可以决定下一步做什么。
- en: There is a hierarchy of exceptions in Python, and we can also create our own
    classes that inherit from and extend the Python exception classes. In the following
    code, we are mainly concerned that the URL we are trying to open might not be
    available, so we wrap our code within a `try...except` code block. If the code
    succeeds in opening the requested URL, all is fine. If it fails, maybe because
    our internet connection is down, we fall into the exception part of the code and
    print out that an exception has occurred.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: Python中存在异常的层次结构，我们也可以创建自己的类，这些类从Python异常类继承并扩展。在下面的代码中，我们主要关注的是我们试图打开的URL可能不可用，因此我们将代码包裹在一个`try...except`代码块中。如果代码成功打开请求的URL，那就没问题。如果失败了，可能是因为我们的互联网连接断开，我们将进入代码的异常部分并打印出异常已发生。
- en: You can read more about Python exception handling at [https://docs.python.org/3.7/library/exceptions.html](https://docs.python.org/3.7/library/exceptions.html).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://docs.python.org/3.7/library/exceptions.html](https://docs.python.org/3.7/library/exceptions.html)了解更多关于Python异常处理的信息。
- en: By calling `urlopen` on the official Python website, we get the entire data
    as one long string. The first `print` statement prints this long string out to
    the console. We then call `decode` on the result, and this time we get a little
    over 1,000 lines of web data, including some white space. We also print out `type`
    for calling `urlopen`, which is an `http.client.HTTPResponse` object. Actually,
    we print it out first.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在官方Python网站上调用`urlopen`，我们得到整个数据作为一个长字符串。第一个`print`语句将这个长字符串打印到控制台。然后我们对结果调用`decode`，这次我们得到了超过1,000行的网页数据，包括一些空白。我们还打印出`type`，调用`urlopen`的是`http.client.HTTPResponse`对象。实际上，我们首先打印它。
- en: Next, we display this data in our GUI inside the `ScrolledText` widget. In order
    to do so, we have to connect our new module, which reads the data from the web
    page to our GUI. In order to do this, we need a reference to our GUI, and one
    way to do this is by tying our new module to the Tab 1 button callback. We can
    return the decoded HTML data from the Python web page to the `Button` widget,
    which we can then place into the `ScrolledText` control.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在GUI中的`ScrolledText`小部件中显示这些数据。为了做到这一点，我们必须将我们的新模块（从网页读取数据）连接到我们的GUI。为了实现这一点，我们需要一个对我们GUI的引用，一种方法是将我们的新模块绑定到Tab
    1按钮回调。我们可以从Python网页返回解码后的HTML数据到`Button`小部件，然后将其放置到`ScrolledText`控制中。
- en: We turn our `URL.py` code into a function and return the data to the calling
    code. We can now write the data from our button callback method to the `ScrolledText`
    control by first importing the new module and then inserting the data into the
    widget. We also give it some sleep after the call to `write_to_scrol.`
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`URL.py`代码转换为一个函数，并将数据返回给调用代码。现在，我们可以通过首先导入新模块，然后将数据插入到小部件中，将我们的按钮回调方法中的数据写入`ScrolledText`控制。我们还在调用`write_to_scrol`后给它一些休眠时间。
- en: In `GUI_URL.py`, the HTML data is now displayed in our GUI widget.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GUI_URL.py`中，HTML数据现在显示在我们的GUI小部件中。
