- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Understanding Database Management in PyCharm
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在PyCharm中理解数据库管理
- en: What do horseshoe crabs, coelacanths, crocodiles, and relational databases have
    in common? I’ll wait while you go look up *coelacanth*. All four of these have
    been around for millions of years and yet have evolved very little. OK, databases
    haven’t been around for millions of years, but they have been around for millions
    of internet years. Everybody knows that internet years are very short. JavaScript
    developers often joke that before lunchtime, anywhere in the world, dozens of
    new frameworks have been invented, risen to prominence, fallen out of favor, and
    then been abandoned all before you finish your noodles.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 马蹄蟹、肺鱼、鳄鱼和关系数据库有什么共同之处？我等你查一下*肺鱼*。这四种生物都存在了数百万年，但进化很小。好吧，数据库没有存在数百万年，但它们已经存在了数百万个互联网年。众所周知，互联网年是短暂的。JavaScript开发者经常开玩笑说，在午餐时间之前，世界上任何地方都会发明数十个新的框架，它们会崭露头角，失去青睐，然后在你吃完面条之前就被遗弃。
- en: In the early 1970s, a researcher named E. F. Codd was working at IBM’s San Jose
    Research Laboratory in California. He developed a revolutionary concept called
    **the relational model of data**. In his seminal paper titled *A Relational Model
    of Data for Large Shared Data Banks*, published in 1970, Codd outlined the principles
    and foundations of this new approach to organizing and retrieving data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪70年代初，一位名叫E. F. Codd的研究员在加利福尼亚州IBM的圣何塞研究实验室工作。他开发了一种革命性的概念，称为**数据关系模型**。在他的开创性论文《大型共享数据银行的关系数据模型》中，发表于1970年，Codd概述了这种新方法组织数据的原则和基础。
- en: Codd’s relational model proposed a way to represent data as a collection of
    tables, known as relations, with each table consisting of rows and columns. He
    introduced the concept of **relational algebra**, a mathematical framework for
    manipulating and querying data in these tables. The model emphasized the use of
    mathematical **set theory** and logic to define relationships and perform operations
    on the data.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Codd的关系模型提出了一种将数据表示为关系集合的方法，即关系，每个表由行和列组成。他引入了**关系代数**的概念，这是一种用于在这些表中操作和查询数据的数学框架。该模型强调了使用数学**集合论**和逻辑来定义关系和执行数据操作。
- en: Codd’s ideas challenged the prevailing hierarchical and network database models
    of the time, which were more complex and less flexible. The relational model offered
    a simpler and more intuitive way to manage data, providing a foundation for **Structured
    Query Language** (**SQL**) and other tools used in relational databases.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Codd的思想挑战了当时盛行的层次结构和网络数据库模型，这些模型更复杂且灵活性较差。关系模型提供了一种更简单、更直观的方式来管理数据，为**结构化查询语言**（**SQL**）和其他在关系数据库中使用的工具奠定了基础。
- en: 'In 1974, IBM released the first commercially available **relational database
    management system** (**RDBMS**), called *System R*, based on Codd’s work. System
    R implemented many of the concepts outlined in Codd’s research and became an influential
    precursor to subsequent relational database systems. In 1974, IBM released System
    R based on Codd’s work, but the product wasn’t aggressively marketed or sold because
    IBM executives were worried about cannibalizing sales on other database systems
    sold by the company. During that time, another start-up database company was born:
    **Oracle**. The initial release of Oracle was developed by Larry Ellison, Bob
    Miner, and Ed Oates. Released in 1983, Oracle is generally considered to be the
    first commercial success even though IBM had a serious head start.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 1974年，IBM发布了第一个商业可用的**关系数据库管理系统**（**RDBMS**），名为*System R*，基于Codd的工作。System R实现了Codd研究中概述的许多概念，并成为后续关系数据库系统的一个有影响力的先驱。1974年，IBM基于Codd的工作发布了System
    R，但由于IBM高管担心会损害公司其他数据库系统的销售，该产品并没有积极地进行市场推广或销售。在那个时期，另一家初创数据库公司诞生了：**Oracle**。Oracle的最初版本是由拉里·埃利森、鲍勃·米纳和埃德·奥茨开发的。1983年发布的Oracle通常被认为是第一个商业上的成功，尽管IBM有明显的先发优势。
- en: Relational database technology evolved throughout the 80s and 90s, and along
    the way, it became a staple of corporate IT in every industry in every corner
    of the globe. In 1986, the SQL language became standardized. The standard evolved
    over time, but to be honest, 49 years after the invention of SQL, most development
    is done with the simplest and oldest set of language statements.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 关系数据库技术在20世纪80年代和90年代不断发展，在这个过程中，它成为了全球每个角落每个行业中企业IT的必备技术。1986年，SQL语言实现了标准化。随着时间的推移，标准也在不断发展，但说实话，在SQL发明49年后，大多数开发工作都是使用最简单、最古老的语句集完成的。
- en: A moment ago, I stated that Codd’s ideas challenged the prevailing hierarchical
    and network database models of the time, which were more complex and less flexible.
    It is interesting to note that in the early 2000s, there was a shift away from
    relational database technology toward what we call **NoSQL databases**. The world
    of IT often acts like a pendulum, forever swinging back and forth. We used to
    have relatively low-powered PCs capable of playing video files at 12 frames per
    second in a postage stamp-sized window. Technology improved to the point where
    we could watch a 4K high-definition video at full speed on a PC, but then we invented
    small hand-held devices, such as the iPod, and we were back to low-end processing
    and choppy, grainy video. Eventually, those improved into the iPhone, which can
    play video at high definition and high frame rates. Some iPhones are bigger than
    the TV I had in college.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 刚才，我说过Codd的想法挑战了当时盛行的层次化和网络数据库模型，这些模型更加复杂且灵活性较低。值得注意的是，在2000年代初，人们开始从关系型数据库技术转向我们所说的**NoSQL数据库**。IT界常常像摆钟一样，永远在来回摇摆。我们曾经有过相对低功耗的PC，能够在邮票大小的窗口中以每秒12帧的速度播放视频文件。技术得到了改进，我们可以全速在PC上观看4K高清视频，但随后我们发明了小型手持设备，如iPod，我们又回到了低端处理和粗糙的视频。最终，这些改进成了iPhone，它能够以高清和高帧率播放视频。有些iPhone比我在大学时拥有的电视还要大。
- en: Likewise, with databases, one day the world was using hierarchical and network-oriented
    databases. The next day everything swung to a new thing called *relational*. Today,
    we see a swing back in the other direction. More and more projects today favor
    non-relational databases, many of which support hierarchical data. Regardless
    of which technology you might favor, it is safe to say that just about any project
    you build, especially in the corporate IT world, will interact with some database
    in some big way.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在数据库领域，有一天世界正在使用层次化和面向网络的数据库。第二天，一切又转向了一个新事物，称为*关系型*。如今，我们看到又回到了另一个方向。越来越多的项目今天倾向于非关系型数据库，其中许多支持层次化数据。无论你偏爱哪种技术，可以说，你几乎构建的任何项目，尤其是在企业IT领域，都将以某种方式与数据库交互。
- en: In 2015, JetBrains created a new product aimed at becoming a popular IDE for
    database developers. **DataGrip** was created to provide a unified interface and
    robust toolset for working with various databases. It offers features such as
    intelligent code completion, advanced SQL editing capabilities, schema navigation,
    data analysis, and integration with version control systems. Like the web development
    product by JetBrains, WebStorm, the DataGrip product is integrated into the Professional
    edition of PyCharm through its plugin system. Consider that your 99 USD investment
    in PyCharm Professional gets you a Python IDE, a JavaScript IDE, an IDE for web
    frontend work in HTML and CSS, and now a fully fledged IDE for database work and
    you’ll see you’ve gotten a solid deal!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年，JetBrains推出了一款新产品，旨在成为数据库开发人员流行的IDE。**DataGrip**的创建是为了提供用于处理各种数据库的统一界面和强大的工具集。它提供智能代码补全、高级SQL编辑功能、模式导航、数据分析以及与版本控制系统的集成。与JetBrains的Web开发产品WebStorm一样，DataGrip产品通过其插件系统集成到PyCharm的专业版中。考虑到你在PyCharm专业版上的99美元投资，你得到了一个Python
    IDE、一个JavaScript IDE、一个用于HTML和CSS前端工作的IDE，现在还有一个用于数据库工作的完整IDE，你会发现这是一个非常划算的交易！
- en: 'In this chapter, we will cover the features of PyCharm related to databases.
    By the end of the chapter, you will have learned the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍PyCharm与数据库相关的功能。到本章结束时，你将学习以下内容：
- en: Some database history and some basics just to make sure we’re all on the same
    page in terms of terminology. If you’ve been developing software for a while,
    this might be a review. If you’re new, I will endeavor to provide you with the
    best possible introduction to database technology.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些数据库历史和一些基础知识，以确保我们在术语方面处于同一页。如果你已经开发软件一段时间了，这可能是一次复习。如果你是新手，我将努力为你提供数据库技术的最佳可能介绍。
- en: How to navigate to the database tools in PyCharm, which are hidden away in a
    tab on the right side of the interface. I have met many developers who have used
    PyCharm for years yet don’t know these tools are even present.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何导航到PyCharm中的数据库工具，这些工具隐藏在界面右侧的一个标签页中。我遇到过许多使用PyCharm多年的开发者，但他们甚至不知道这些工具的存在。
- en: How to connect to different databases, including how to add the necessary connection
    drivers to PyCharm. JetBrains has made this very easy!
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何连接到不同的数据库，包括如何在PyCharm中添加必要的连接驱动程序。JetBrains使这一过程变得非常简单！
- en: How to configure SQL dialects for individual projects as well as globally.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为单个项目和全局配置SQL方言。
- en: How to use SQL generation templates to help you write SQL queries more quickly.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用SQL生成模板来帮助你更快地编写SQL查询。
- en: How to generate an **entity relationship** **diagram** (**ERD**).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何生成**实体关系图**（**ERD**）。
- en: How to use the graphical designers to build tables easily.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用图形设计器轻松构建表格。
- en: How to use consoles to create and run ad hoc queries against any database.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用控制台创建和运行针对任何数据库的即席查询。
- en: On a personal note, besides learning to code in BASIC when I was 12, relational
    technology was the first skill I mastered when I got into the IT field over 30
    years ago. This is a skill set that has always been in demand, and will probably
    continue to be in demand for many years to come. It is a subject I have extensive
    experience in, and I am excited to share that experience with you in this chapter.
    So, let’s get to it!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，除了12岁时学习BASIC编程之外，关系技术是我30多年前进入IT领域时掌握的第一项技能。这是一个一直有需求，并且可能在未来许多年里仍将有需求的技能集。这是我有着丰富经验的一个主题，我很高兴能在本章与你分享这些经验。那么，让我们开始吧！
- en: Technical requirements
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In order to proceed with this chapter, and indeed the rest of the book, you
    will need the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续本章，以及本书的其余部分，你需要以下内容：
- en: An installed and working Python interpreter. I’ll be using the latest from [https://python.org](https://python.org).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 安装并运行Python解释器。我将使用来自[https://python.org](https://python.org)的最新版本。
- en: An installed and working copy of PyCharm. Installation was covered in [*Chapter
    2*](B19644_02.xhtml#_idTextAnchor028), *Installation and Configuration*, in case
    you are jumping into the middle of the book.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 安装并运行PyCharm的副本。安装已在[*第2章*](B19644_02.xhtml#_idTextAnchor028)，*安装和配置*中介绍，以防你是在书的中途开始阅读。
- en: A database server is a nice-to-have in this chapter so you can practice on a
    real database. There are dozens of popular relational databases to choose from,
    so it is not practical for me to cover all of them. I will be running **MySQL**
    using **Docker Desktop**. If you plan on following along, you’ll need to have
    Docker Desktop installed on your computer. You can find instructions for installation
    at [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，数据库服务器是一个不错的选择，这样你就可以在实际数据库上练习。有数十种流行的关系型数据库可供选择，因此对我来说涵盖所有这些并不实际。我将使用**MySQL**和**Docker
    Desktop**运行。如果你打算跟随，你需要在你的计算机上安装Docker Desktop。你可以在[https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/)找到安装说明。
- en: This book’s sample source code is from GitHub. We covered cloning the code in
    [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028), *Installation and Configuration*.
    You’ll find this chapter’s relevant code at [https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-11](https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-11).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供的示例源代码来自GitHub。我们已在[*第2章*](B19644_02.xhtml#_idTextAnchor028)，*安装和配置*中介绍了代码克隆。你可以在[https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-11](https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-11)找到本章的相关代码。
- en: Relational databases in a nutshell
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简要介绍关系数据库
- en: 'The idea of relational data conceived by E. F. Codd is based on a few simple
    principles. Firstly, data can be represented in sets called *tables*. A `books`.
    The `books` table will contain columns that define the data within those columns
    – maybe something like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: E. F. Codd提出的关于关系数据的概念基于几个简单的原则。首先，数据可以用称为*表*的集合来表示。一个`books`。`books`表将包含定义这些列内数据的列——可能像这样：
- en: '| **Title** | **ISBN** | **Page Count** | **Author** | **Price** |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| **标题** | **ISBN** | **页数** | **作者** | **价格** |'
- en: '| The Art of War | 1599869772 | 68 | Sun Tzu | 4.99 |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 资治通鉴 | 1599869772 | 68 | 孙子 | 4.99 |'
- en: '| Book of Five Rings | 8387743849 | 43 | Miyamoto Musashi | 4.50 |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 五轮书 | 8387743849 | 43 | 宫本武藏 | 4.50 |'
- en: This table has five columns designed to structure data about books. We have
    two books, which are stored as rows in the table.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此表有五个列，用于结构化关于书籍的数据。我们有两本书，它们作为行存储在表中。
- en: Structured Query Language
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构化查询语言
- en: E. F. Codd’s paper that defined relational algebra served as the basis for SQL.
    SQL is unlike any other coding language you will ever use because it is one of
    only a handful of languages that use a declarative paradigm. Most languages you
    use, including Python, use an imperative paradigm. In short, the language serves
    as a syntactical framework to give a computer instructions on what you want it
    to do. You are basically a micro-manager. You specify every input, every output
    and every step the program will take during the processing that happens to get
    the input to the output. You must be meticulous, as the computer will take you
    literally. If you leave out even a single detail, you are setting things up to
    malfunction.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: E. F. Codd的关于关系代数的论文是SQL的基础。SQL与您将使用的任何其他编程语言都不同，因为它仅是少数几种使用声明性范式的语言之一。您使用的多数语言，包括Python，都使用命令式范式。简而言之，这种语言作为一个句法框架，向计算机提供指令，告诉它您希望它做什么。您基本上是一个微观管理者。您必须指定每个输入、每个输出以及程序在处理过程中将采取的每个步骤，以将输入转换为输出。您必须非常细致，因为计算机将严格地执行您的指令。如果您遗漏了任何细节，您就是在设置系统出现故障。
- en: '**Declarative programming**, on the other hand, entails merely specifying the
    output you want from an implicit input. You have little to no control over the
    operations performed to derive the output from the input. Consider this SQL statement
    designed to get some rows from your bookstore database:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**声明性编程**仅仅涉及指定您希望从隐含输入中获得的输出。您对从输入中推导出输出的操作几乎没有控制权。考虑以下设计用于从您的书店数据库中获取一些行的SQL语句：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This query will produce some output consisting of a table that has a few of
    the columns from your original database, which serves as the implicit input. You’ll
    get the following columns:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询将产生一些输出，包括一个表格，其中包含您原始数据库中的一些列，这些列作为隐含输入。您将得到以下列：
- en: '`Title`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`标题`'
- en: '`ISBN`'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`ISBN`'
- en: '`Author`'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`作者`'
- en: '`Price`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`价格`'
- en: But you won’t get the page count because you didn’t ask for it in the query.
    The input data source is implied in the `FROM books` section of the query. At
    the end, we have a request to order the results by price in descending order (`DESC`),
    which will make our resulting tabular list of books appear from the most expensive
    to the cheapest.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 但您不会得到页数，因为您在查询中没有要求。输入数据源隐含在查询的`FROM books`部分中。最后，我们有一个按价格降序排序结果的要求（`DESC`），这将使我们的结果表格从最贵到最便宜排列。
- en: The two halves of SQL
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL的两个部分
- en: 'SQL itself is split into two separate sets of syntax: `SELECT` statement presented
    earlier is an example of a read operation. SQL has keywords for `INSERT`, `UPDATE`,
    and `DELETE` operations for records which are straightforward, so I want to focus
    on DDL since this is going to be a big part of your work in PyCharm.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: SQL本身分为两个独立的语法集合：前面提到的`SELECT`语句是一个读操作的例子。SQL有`INSERT`、`UPDATE`和`DELETE`操作的关键字，这些操作对于记录来说是直接的，所以我想专注于DDL，因为这将是你PyCharm工作中的一大部分。
- en: 'Our earlier example of a table to be used in a bookstore application had one
    table in it called `books`. That table contained a set of columns, which we would
    define using DDL like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在书店应用程序中使用的表格示例中有一个名为`books`的表。这个表包含了一组列，我们将使用DDL（数据定义语言）如下定义这些列：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you are new to SQL, you might have noticed the keywords are capitalized.
    In fact, I’ll bet you correctly assumed that the capitalized words were keywords.
    While it isn’t a requirement to capitalize keywords, it is good practice – particularly
    if your project’s database lead is a large man retired from the United States
    Marine Corps who is particular about the details of syntax in *his* database!
    In this case, good practice might become a matter of survival.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是SQL的新手，您可能已经注意到关键字都是大写的。实际上，我敢打赌您正确地假设那些大写的单词是关键字。虽然关键字大写不是强制性的，但这是一个好的实践——尤其是如果您的项目数据库负责人是一位从美国海军陆战队退休的大个子，他对*他*的数据库中的句法细节非常讲究的话！在这种情况下，好的实践可能成为生存的关键。
- en: Most of what you read in the table’s DDL is easy to figure out. We’re creating
    a table called `books`. We already knew about the column names. SQL uses a strong
    type system, meaning you have to define the type of data that will go into a column,
    and violating that constraint might come with consequences. I’ve said many times
    before that a developer’s job is to protect a program from entering an invalid
    state. Likewise, it is a database developer’s job, as well as that of a `VARCHAR`
    refers to a variable-length set of characters. Programmers call this a *string*.
    The number (`255`) after the type refers to the maximum length of `VARCHAR`. All
    of the `VARCHAR` (string) fields in the database are limited to 255 characters
    in length. The number 255 is very common because many of us old-timers grew up
    in the world of 8-bit computing. The number 255, being the maximum value of an
    8-bit unsigned integer, was a common maximum for the length of the field. We’d
    set it to that when we weren’t sure how long the data might be.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在表的DDL中，你读到的内容大部分都很容易理解。我们正在创建一个名为`books`的表。我们已经知道了列名。SQL使用强类型系统，这意味着你必须定义将要放入列中的数据类型，违反这个约束可能会带来后果。我以前说过很多次，开发者的工作就是保护程序不进入无效状态。同样，数据库开发者的工作也是如此，以及`VARCHAR`指的是一组可变长度的字符。程序员称之为*字符串*。类型后面的数字（`255`）指的是`VARCHAR`的最大长度。数据库中所有的`VARCHAR`（字符串）字段长度都被限制在255个字符以内。数字255非常常见，因为我们这些老一辈的人都是在8位计算的世界中长大的。数字255是8位无符号整数的最大值，因此是字段长度的常见最大值。当我们不确定数据可能有多长时，我们会将其设置为这个值。
- en: Naturally, today, we normally work in 32- and even 64-bit architectures, so
    the maximum can be much higher. It is normal to constrain ourselves to the old
    maximum because 255 characters are generally enough for most things. Specifying
    sane maximums helps keep your database storage and memory requirements reasonable.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，今天，我们通常在32位甚至64位架构上工作，所以最大值可以更高。将我们限制在旧的最大值是正常的，因为255个字符通常足够用于大多数事情。指定合理的最大值有助于保持你的数据库存储和内存需求合理。
- en: Look at the `price` field. It is specified as the `DECIMAL` type, which is obviously
    like a float. Database systems have different names for their types, so you should
    always consult your database system’s documentation to get the exact naming. `DECIMAL`
    is indeed a floating-point number, but we also specified the level of precision
    with `(10,2)`. This means we can have a 10-digit number with 2 decimal places.
    This is commonly used to specify prices. Some database systems have specialized
    types specifically for currency. SQL Server is an example of this with their `MONEY`
    and `SMALLMONEY` types. Again, check your database system’s documentation for
    appropriate types since these specialized types aren’t part of standard SQL.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下`price`字段。它被指定为`DECIMAL`类型，这显然类似于浮点数。数据库系统对它们的类型有不同的命名，所以你应该始终查阅你的数据库系统文档以获取确切的命名。`DECIMAL`确实是一个浮点数，但我们还指定了精度级别为`(10,2)`。这意味着我们可以有一个10位数字，有2位小数。这通常用于指定价格。一些数据库系统有专门针对货币的类型。SQL
    Server就是这样一个例子，它们有`MONEY`和`SMALLMONEY`类型。再次提醒，检查你的数据库系统文档以获取适当类型，因为这些专用类型不是标准SQL的一部分。
- en: Relationships
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系
- en: 'Consider our bookstore will naturally grow in size and complexity. Let’s say
    we’ve added some different fields and removed some we weren’t using. Our new table
    structure looks like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们的书店自然会增长规模和复杂性。假设我们添加了一些不同的字段，并删除了一些我们没有使用的字段。我们新的表结构看起来像这样：
- en: '| **Title** | **Author_name** | **Author_email** | **Pages** | **Price** |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **标题** | **作者姓名** | **作者邮箱** | **页数** | **价格** |'
- en: '| C Programming Language, 2nd Edition | Brian Kernighan and Dennis Ritchie
    | bkernigan@notrealaddress.com | 272 | 53.60 |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| C程序设计语言（第2版） | 布莱恩·肯尼根和丹尼斯·里奇 | bkernigan@notrealaddress.com | 272 | 53.60
    |'
- en: '| Real-World Implementation of C# Design Patterns | Bruce Van Horn | bvanhorn@notrealaddress.com
    | 442 | 44.99 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| C#设计模式实战应用 | 布鲁斯·范·霍恩 | bvanhorn@notrealaddress.com | 442 | 44.99 |'
- en: '| Hands-On Application Development with PyCharm | Quan Nguyen | qnguyen@notrealaddress.com
    | 785 | 35.45 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 使用PyCharm进行实战应用开发 | 阮文 | qnguyen@notrealaddress.com | 785 | 35.45 |'
- en: '| Hands-On Application Development with PyCharm, 2nd Edition | Bruce Van Horn
    | bvanhorn@notrealaddress.com | 840 | 44.99 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 使用PyCharm进行实战应用开发（第2版） | 布鲁斯·范·霍恩 | bvanhorn@notrealaddress.com | 840 | 44.99
    |'
- en: Besides the complexity coming from more records, we’ve introduced some complexity
    in terms of design. At some point, it became important for us to track more information
    about the authors of any given book. We added fields for the name and email address,
    which seemed to solve our problems at first, but ultimately led to more issues.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 除了来自更多记录的复杂性之外，我们在设计方面也引入了一些复杂性。在某个时候，对我们来说，跟踪任何给定书籍作者的更多信息变得很重要。我们添加了姓名和电子邮件地址字段，起初这似乎解决了我们的问题，但最终导致了更多问题。
- en: The C book has two authors, but we only have one field. While it might be fine
    to store both authors as we did, there is also a field for the email address and
    this can only accommodate one address. This is not ideal since our objective might
    be to send royalty statements or sales reports to the authors. One address is
    a problem.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: C语言书籍有两个作者，但我们只有一个字段。虽然将两位作者都存储起来可能没问题，但我们还有一个电子邮件地址字段，而这个字段只能容纳一个地址。这并不理想，因为我们的目标可能是向作者发送版税声明或销售报告。一个地址就是一个问题。
- en: The email addresses will be duplicated in the event we store two books with
    the same author. If the author changes email addresses, all of the records have
    to be updated. This is the equivalent of hardcoded values kept in multiple places
    in a program. You have to remember to change it in lots of places. The problem
    is compounded if this email address data is duplicated in several different tables.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们存储了两本同一作者的书籍，电子邮件地址将会重复。如果作者更改了电子邮件地址，所有记录都必须更新。这相当于在程序中多个地方硬编码的值。你必须记住在许多地方更改它。如果这个电子邮件地址数据在几个不同的表中重复，问题会更加复杂。
- en: 'The solution to this is prescribed by SQL and the ideas behind relational algebra.
    You need a single source of truth for the author’s data instead of mixing it in
    with other tables. So, we create a new table for authors:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的解决方案由SQL和关系代数背后的思想规定。你需要一个作者数据的单一来源，而不是将其与其他表混合。因此，我们为作者创建了一个新表：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This table has fields for the first and last names as well as the email address.
    It also has a field called `id`, which is going to the server as a primary key.
    A primary key is a field that can uniquely identify the information in that row.
    The idea here is that every author gets only one row to store their information.
    We need some piece of data to uniquely identify that row. Consider my own records.
    My first and last names make poor choices to uniquely define my record in the
    database. I know of at least three other people named Bruce Van Horn. One was
    my father, who published in the medical field. One is a motivational speaker who
    publishes books in that literary field. I found another Bruce Van Horn on LinkedIn,
    and believe it or not, he too is a software developer! So the name is a poor choice
    as a unique identifier.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表格有姓名、姓氏以及电子邮件地址字段。还有一个名为`id`的字段，它作为主键发送到服务器。主键是一个可以唯一标识该行信息的字段。这里的想法是每个作者只得到一个行来存储他们的信息。我们需要一些数据来唯一标识该行。以我自己的记录为例。我的姓名和姓氏在数据库中作为唯一定义我的记录的选择很糟糕。我知道至少有其他三个人叫布鲁斯·范·霍恩。一个是我的父亲，他在医学领域发表作品。一个是励志演讲者，在那个文学领域出版书籍。我在领英上找到了另一个布鲁斯·范·霍恩，信不信由你，他也是一个软件开发者！所以，名字作为唯一标识符是一个糟糕的选择。
- en: Email addresses might work, except that we’ve already figured out that email
    addresses can change. I have no fewer than five email addresses and at least one
    of these is so overtaken with spam that I no longer even check it. Email isn’t
    going to work.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件地址可能可行，但我们已经发现电子邮件地址可能会更改。我至少有五个电子邮件地址，其中至少有一个被垃圾邮件淹没得如此严重，以至于我甚至不再检查它。电子邮件是不可行的。
- en: The best practice is to use some piece of data that is unique but arbitrary,
    with no bearing at all on the rest of the data in the record. There are two ways
    to do this. The most common is to use a database sequence. A **sequence** is an
    automatically incrementing source of integers. Each time a record is inserted
    into a table, the sequencer generates a sequential number, which is guaranteed
    to be unique.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是使用一些独特但随机的数据，它与记录中的其他数据没有任何关联。有两种方法可以做到这一点。最常见的是使用数据库序列。序列是一个自动递增的整数源。每次将记录插入到表中时，序列生成器都会生成一个顺序号，该顺序号保证是唯一的。
- en: The other approach is to use `6f35e0e7-d99a-4437-b894-f73ff35bd3ad` versus a
    record with the `id` value of `16`. Which would you rather type into your queries?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用`6f35e0e7-d99a-4437-b894-f73ff35bd3ad`这样的记录与具有`id`值为`16`的记录相比。你更愿意在查询中输入哪一个？
- en: 'Now that we have a field that uniquely identifies an author’s record, we can
    adjust our book table structure like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个字段可以唯一标识作者的记录，我们可以调整我们的书籍表结构如下：
- en: '| **Title** | **pages** | **price** | **author_id** |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| **Title** | **pages** | **price** | **author_id** |'
- en: '| Real-World Implementation of C# Design Patterns | 442 | 44.99 | 2 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| Real-World Implementation of C# Design Patterns | 442 | 44.99 | 2 |'
- en: '| Hands-On Application Development with PyCharm | 785 | 35.45 | 1 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| Hands-On Application Development with PyCharm | 785 | 35.45 | 1 |'
- en: '| Hands-On Application Development with PyCharm, 2nd Edition | 840 | 44.99
    | 2 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| Hands-On Application Development with PyCharm, 2nd Edition | 840 | 44.99
    | 2 |'
- en: 'Our `authors` table looks like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `authors` 表看起来是这样的：
- en: '| **author_id** | **first_name** | **last_name** | **email** |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| **author_id** | **first_name** | **last_name** | **email** |'
- en: '| 1 | Quan | Nguyen | qnugyen@notrealaddress.com |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 1 | Quan | Nguyen | qnugyen@notrealaddress.com |'
- en: '| 2 | Bruce | Van Horn | bvanhorn@notrealaddress.com |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Bruce | Van Horn | bvanhorn@notrealaddress.com |'
- en: The author ID in the `authors` table is used as a related column in the `books`
    table using a one-to-many relationship. Each author will have one record, which
    is related to many records in the `books` table.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`authors` 表中的作者ID在 `books` 表中用作相关列，通过一对一关系。每个作者将有一个记录，该记录与 `books` 表中的多个记录相关联。'
- en: More relational structures
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多关系结构
- en: We’ve solved a big problem using our one-to-many table structure. We no longer
    have duplicate data in multiple records for our authors. We didn’t, however, solve
    all of our problems. For example, the C book has multiple authors. How can we
    store authors in a way that allows each book to support multiple authors?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一对一的表结构解决了一个大问题。我们不再在多个记录中为作者重复数据。然而，我们并没有解决所有问题。例如，C语言书籍有多个作者。我们如何以允许每本书支持多个作者的方式存储作者？
- en: I’m afraid we’ve reached the point where I tell you that this isn’t a book on
    SQL, nor is it a book on relational theory. If I’ve hooked you on this, I can
    recommend some excellent books that I used when I learned these things. We’ve
    presented enough relational database vocabulary to help you relate to what you
    will see in PyCharm’s tooling and that was my real objective.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我恐怕我们已经到了这样一个地步，我告诉你这既不是一本关于SQL的书，也不是一本关于关系理论的书籍。如果我让你对这本书产生了兴趣，我可以推荐一些我学习这些知识时用过的优秀书籍。我们已经提供了足够的数据库关系词汇，以帮助你理解PyCharm工具中看到的内容，那才是我的真正目标。
- en: Since I am not a total degenerate, regardless of what you may read about me
    on Stack Overflow, I will give you the solution quickly and without many pages
    of explanation.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我并不是一个彻底的堕落者，无论你在Stack Overflow上读到关于我的什么，我都会快速地给你解决方案，而不会用很多页的解释。
- en: 'You’d solve it using what we call a mapping table. Your structure would require
    the addition of a table called `books_authors_map`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你会使用我们所说的映射表来解决这个问题。你的结构需要添加一个名为 `books_authors_map` 的表：
- en: '| **Id** | **Book_id** | **Author_id** |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| **Id** | **Book_id** | **Author_id** |'
- en: '| 1 | 1 | 1 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 |'
- en: '| 2 | 1 | 2 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1 | 2 |'
- en: 'Your `books` table would look like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 `books` 表将如下所示：
- en: '| **Book_id** | **Title** | **Pages** | **Price** |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| **Book_id** | **Title** | **Pages** | **Price** |'
- en: '| 1 | The C Programming Language | 442 | 44.99 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 1 | The C Programming Language | 442 | 44.99 |'
- en: 'We took out the `author_id` field and added a `book_id` field, which really
    should have been there all along. The `authors` table would look the same:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们移除了 `author_id` 字段，并添加了一个 `book_id` 字段，这个字段本来就应该在那里。`authors` 表看起来会相同：
- en: '| **Author_id** | **First_name** | **Last_name** | **Email** |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| **Author_id** | **First_name** | **Last_name** | **Email** |'
- en: '| 1 | Brian | Kernighan | bkernigan@notrealaddress.com |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 1 | Brian | Kernighan | bkernigan@notrealaddress.com |'
- en: '| 2 | Dennis | Ritchie | dritche@noterealaddress.com |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Dennis | Ritchie | dritche@noterealaddress.com |'
- en: The mapping table can map a `books` and `authors`! If either author goes solo
    and publishes a book without their co-author, that will work! The `books` table’s
    record will have one related record in the map, which has one related record in
    the `authors` table.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 映射表可以将 `books` 和 `authors` 进行映射！如果任何作者独立出版书籍而没有合作者，那也是可以的！`books` 表的记录将在映射中有一个相关记录，该记录在
    `authors` 表中有一个相关记录。
- en: If a book has 10 authors, it will have 1 book record, 10 author records, and
    10 mapping entries. Relational algebra is pretty cool! It is an underrated skill
    in today’s world of **object relational mappers** (**ORMs**), which abstract all
    of this into normal object structures. Developers today tend to lose this skill.
    If you do, you give up a lot. You can make fine-grained modifications in your
    DDL that lead to huge performance gains for your application.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一本书有 10 位作者，它将有一个书记录，10 个作者记录和 10 个映射条目。关系代数非常酷！它是当今**对象关系映射器**（**ORMs**）世界中被低估的技能，ORMs
    将所有这些抽象成常规对象结构。今天的开发者往往失去了这种技能。如果你失去了它，你将失去很多。你可以在 DDL 中进行精细的修改，这将为你的应用程序带来巨大的性能提升。
- en: Speaking of that, let’s learn about PyCharm’s tooling for database development.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这个，让我们来了解一下 PyCharm 的数据库开发工具。
- en: Database terminology uses simple English plurals
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库术语使用简单的英语复数形式
- en: As we go through some of the terminology used when talking about databases,
    I feel compelled to point out something that bothered me for a very long time.
    Many terms used when talking about databases come from Latin root words. For example,
    an **index** is an addition to a table that can speed up data retrieval at the
    cost of the speed of inserting new data. It is also a Latin word that refers to
    *a pointer, indicator, or signpost*. A **schema** refers to a way of partitioning
    off tables and other structures in a database. The word *schema* originated with
    the Greek word σχῆμα (*skema*) and in both languages means *shape, form,* *or
    plan*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们讨论数据库讨论中使用的术语，我感到有必要指出困扰我很久的一件事。在讨论数据库时使用的许多术语都源自拉丁语根词。例如，**索引**是表格的一个附加项，可以加快数据检索速度，但会牺牲插入新数据的速度。它也是一个指代**指针、指示器或路标**的拉丁语单词。**模式**指的是在数据库中将表和其他结构划分开来的方式。单词**模式**起源于希腊语单词σχῆμα
    (*skema*)，在两种语言中均意为**形状、形式**或**计划**。
- en: When talking about the plural forms, the words might not be as you expect if
    you received a classical education as I did. If you come from a country where
    your language is based on Latin, you might notice this issue as well.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到复数形式时，如果你像我一样接受了传统教育，你可能会发现单词的复数形式并不像你预期的那么简单。如果你来自一个以拉丁语为基础的语言国家，你也可能会注意到这个问题。
- en: I would expect the plural form of *schema* to be *schemata*, and the plural
    of *index* to be *indices*. If you expect this, you will always be disappointed.
    The industry has standardized simple plural forms such as *schemas* and *indexes*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我原本预期 *schema* 的复数形式应该是 *schemata*，而 *index* 的复数形式应该是 *indices*。如果你预期这样，你总会感到失望。该行业已经标准化了简单的复数形式，如
    *schemas* 和 *indexes*。
- en: Database tooling in PyCharm
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PyCharm 中的数据库工具
- en: 'The database tooling in PyCharm is complete but generic. By this, I mean that
    PyCharm attempts to support every database out there, and as such, it generally
    supports features common to all. You may find yourself sometimes leaning on more
    specific tools, such as **SQL Server Management Studio** (**SSMS**) for SQL Server.
    However, for general development work, the tooling in PyCharm is more than sufficient.
    The starting point for working with databases in PyCharm is opening the database
    tools and creating a connection. For this, you also need a database. PyCharm supports
    dozens of the most popular database servers. Since this is true, it would be impossible
    for me to predict which one you prefer, so I’m going to fall back on one that
    I know well: MySQL. Regardless of your favorite, the tooling in PyCharm is generic,
    so as long as you pick a relational database that is standards-compliant, the
    processes are the same.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm 中的数据库工具功能全面但通用。我的意思是，PyCharm 试图支持所有数据库，因此它通常支持所有数据库共有的功能。你可能会发现自己有时会依赖更具体的工具，例如用于
    SQL Server 的 **SQL Server Management Studio**（**SSMS**）。然而，对于一般开发工作，PyCharm 中的工具已经足够。在
    PyCharm 中处理数据库的起点是打开数据库工具并创建一个连接。为此，你还需要一个数据库。PyCharm 支持数十种最受欢迎的数据库服务器。由于这个原因，我无法预测你更喜欢哪一个，所以我将退而求其次，选择我熟悉的：MySQL。无论你更喜欢哪一个，PyCharm
    中的工具都是通用的，只要你选择一个符合标准的关联数据库，过程都是相同的。
- en: Setting up a MySQL database server with Docker
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 设置 MySQL 数据库服务器
- en: The easiest way to try out any database system, or pretty much any server technology
    at all, is to use Docker. I have more plans for Docker later in the book, and
    I will be using Docker Desktop, along with the command line. I like the desktop’s
    GUI for seeing what is running graphically, but you should master Docker command-line
    skills in order to remain competitive. If you don’t have Docker Desktop installed,
    you can find the installation instructions at [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/).
    Naturally, there are other options, such as installing a database server on your
    computer. I personally rail against this because database servers are very complicated.
    Installing something such as SQL Server or Oracle will make modifications to your
    OS at a level that makes these software packages hard to uninstall. It used to
    be a rule of thumb that if you made any mistakes installing the database server,
    the smartest option was the wipe the OS and start over. I’m relatively sure that’s
    no longer the case, but I still treat database servers with respect because of
    all the moving parts in your solution, this one is easily the most complicated.
    The last thing you want is a broken database server on your laptop while in the
    middle of developing an epic project. So, I recommend Docker. If something goes
    wrong, you delete the container and make a new one.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试任何数据库系统，或者几乎所有服务器技术的最简单方法就是使用 Docker。我在本书的后面部分还有更多关于 Docker 的计划，我将使用 Docker
    Desktop 和命令行。我喜欢桌面版的图形用户界面来查看正在运行的内容，但你应该掌握 Docker 命令行技能，以便保持竞争力。如果你没有安装 Docker
    Desktop，你可以在 [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/)
    找到安装说明。当然，还有其他选项，比如在你的电脑上安装数据库服务器。我个人反对这样做，因为数据库服务器非常复杂。安装像 SQL Server 或 Oracle
    这样的东西会在操作系统级别进行修改，使得这些软件包难以卸载。过去有一个规则，如果你在安装数据库服务器时犯了错误，最明智的选择是擦除操作系统并重新开始。我相对确信这不再是规则，但我仍然因为你的解决方案中所有移动部件，这个是最复杂的。你最不希望的事情就是在开发史诗级项目的过程中，你的笔记本电脑上的数据库服务器出了问题。所以，我推荐使用
    Docker。如果出了问题，你可以删除容器并创建一个新的。
- en: Likewise, you can create a VM using products such as **VMware Workstation**
    or **Oracle VirtualBox**. This is another fine way to work, though it takes up
    more space and resources than Docker will, and you must remember to keep your
    VMs up to date.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以使用 **VMware Workstation** 或 **Oracle VirtualBox** 等产品创建虚拟机。这是另一种很好的工作方式，尽管它比
    Docker 占用更多的空间和资源，你必须记住保持你的虚拟机更新。
- en: Another fine option is to spin up your database server of choice in your favorite
    cloud. I recommend **DigitalOcean** for this since their pricing and setup are
    both extremely easy to understand. I use this service to host the companion website
    for this book. If your computer isn’t up for running a database server, VMware,
    or Docker, using a cloud provider is your best option.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很好的选择是在你最喜欢的云中启动你选择的数据库服务器。我推荐 **DigitalOcean**，因为他们的定价和设置都极其容易理解。我用这个服务来托管这本书的配套网站。如果你的电脑无法运行数据库服务器、VMware
    或 Docker，使用云服务提供商是你的最佳选择。
- en: All these options are great, but I need to pick one, so I’m going to be working
    with Docker. Remember, this isn’t a book on Docker. My coverage is going to be
    tacit. Your objective is to get a database server up and running so you can practice.
    If you can do that with something besides Docker, go ahead and skip to the next
    section.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些选项都很好，但我需要选择一个，所以我将使用 Docker。记住，这不是一本关于 Docker 的书。我的介绍将是隐晦的。你的目标是让数据库服务器运行起来，以便你可以进行实践。如果你可以用除了
    Docker 之外的东西做到这一点，请直接跳到下一节。
- en: Installing and running the MySQL container
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和运行 MySQL 容器
- en: 'I’m assuming you have Docker running on your computer and that your Docker
    commands are available in your `PATH`. We can confirm this by opening our terminal
    and typing this command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设你在你的电脑上运行了 Docker，并且你的 Docker 命令在你的 `PATH` 中可用。我们可以通过打开我们的终端并输入以下命令来确认：
- en: '[PRE3]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This command will list all the containers currently running, or stopped. If
    you just installed Docker, you should see an empty list, which is to say, nothing
    at all. The test is really to make sure the command runs and doesn’t throw any
    errors. If it doesn’t, you’re ready to grab MySQL using this command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将列出当前正在运行或已停止的所有容器。如果你刚刚安装了 Docker，你应该看到一个空列表，也就是说，什么都没有。这个测试实际上是为了确保命令可以运行并且不会抛出任何错误。如果它没有，你就可以使用以下命令来获取
    MySQL：
- en: '[PRE4]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You’ll see a nicely animated display of the installation, as shown in *Figure
    11**.1*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到安装的动画显示，如图 *图 11.1* 所示。
- en: '![Figure 11.1: The Docker command used to pull the images needed for MySQL](img/B19644_11_001.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1：用于拉取 MySQL 所需镜像的 Docker 命令](img/B19644_11_001.jpg)'
- en: 'Figure 11.1: The Docker command used to pull the images needed for MySQL'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1：用于拉取 MySQL 所需镜像的 Docker 命令
- en: 'This command pulled all the requirements needed to run one or more containers
    for MySQL. Next, we need to create and run a container with this command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令拉取了运行一个或多个 MySQL 容器所需的所有要求。接下来，我们需要使用以下命令创建并运行一个容器：
- en: '[PRE5]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This command will create and run a container named `pycharm-mysql`. It sets
    the root password for the MySQL database to `P@ssw0rd`. The `–p` flag maps port
    `3306`, which is the standard port for MySQL, to the same value between your container
    and the host. This will make it seem as though you are running the MySQL server
    directly on your computer. The `-d` flag tells Docker to run MySQL as a background
    process rather than waiting for it to exit. This is common with server software.
    I hope I don’t need to remind you that *this is not production ready*. If you
    are in a small group where the developers are responsible for standing up a production
    environment, don’t simply duplicate your development environment on a server open
    to the internet. You should at least map your database to more robust permanent
    storage, as well as harden MySQL, use non-privileged accounts for your app, and
    use a non-obvious root password.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将创建并运行一个名为 `pycharm-mysql` 的容器。它将 MySQL 数据库的根密码设置为 `P@ssw0rd`。`-p` 标志将端口
    `3306`（MySQL 的标准端口）映射到容器和主机之间的相同值。这将使您感觉就像是在计算机上直接运行 MySQL 服务器一样。`-d` 标志告诉 Docker
    以后台进程的方式运行 MySQL，而不是等待其退出。这对于服务器软件来说是常见的。我希望我不需要提醒您，*这并不是生产就绪的*。如果您在一个小团队中，开发者负责建立生产环境，不要简单地将您的开发环境复制到对互联网开放的服务器上。您至少应该将数据库映射到更健壮的永久存储，以及加固
    MySQL，为您的应用程序使用非特权账户，并使用一个不明显的主机密码。
- en: We are now running the MySQL server. When you run the Docker command, your output
    is somewhat cryptic and unsatisfying. You can see mine in *Figure 11**.2*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在正在运行 MySQL 服务器。当您运行 Docker 命令时，您的输出有些晦涩且令人不满意。您可以在 *图 11.2* 中看到我的输出。
- en: '![Figure 11.2: A long string of seemingly random letters and numbers is Docker’s
    way of saying “I love you,” or at least that your container is running](img/B19644_11_002.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2：一串看似随机的字母和数字是 Docker 表示“我爱你”的方式，或者至少表明您的容器正在运行](img/B19644_11_002.jpg)'
- en: 'Figure 11.2: A long string of seemingly random letters and numbers is Docker’s
    way of saying “I love you,” or at least that your container is running'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2：一串看似随机的字母和数字是 Docker 表示“我爱你”的方式，或者至少表明您的容器正在运行
- en: 'There is an old saying that goes, *Tell a man there are a trillion stars in
    the galaxy, and he’ll believe you. Tell him his container is successfully running
    in Docker and he’ll run* `docker ps -a` *to be sure.* In truth, I might have just
    made that up. Nevertheless, let’s make sure:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有句老话说，*告诉一个人银河系中有万亿颗星星，他会相信你。告诉他他的容器在 Docker 中成功运行，他会运行* `docker ps -a` *来确认。实际上，我可能只是编造了这个。无论如何，让我们确保：
- en: '[PRE6]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You should see proof like mine in *Figure 11**.3*. The `CONTAINER ID` value
    will be different for every run, so don’t expect yours to match mine.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到像我一样的证据，在 *图 11.3* 中。`CONTAINER ID` 的值对于每次运行都会不同，所以不要期望您的与我的匹配。
- en: '![Figure 11.3: I can see my container named pycharm-mysql is running and has
    exposed port 3306](img/B19644_11_003.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3：我可以看到名为 pycharm-mysql 的容器正在运行，并已暴露端口 3306](img/B19644_11_003.jpg)'
- en: 'Figure 11.3: I can see my container named pycharm-mysql is running and has
    exposed port 3306'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3：我可以看到名为 pycharm-mysql 的容器正在运行，并已暴露端口 3306
- en: Stopping and starting the container
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 停止和启动容器
- en: 'When you’re ready to retire for the day, you might want to stop the container:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当您准备好退休时，您可能想停止容器：
- en: '[PRE7]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This stops the container. You can check with the same `docker ps -a` command
    we’ve been using to confirm the status changed from *Up* to *Stopped*. Tomorrow
    morning, when you come back, type the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这将停止容器。您可以使用我们一直在使用的相同的 `docker ps -a` 命令来确认状态已从 *Up* 更改为 *Stopped*。明天早上，当您回来时，键入以下内容：
- en: '[PRE8]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This starts things up so you can pick up where you left off.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一切，以便您可以从上次离开的地方继续。
- en: Connecting to data sources using PyCharm
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PyCharm 连接到数据源
- en: Open PyCharm Professional and create a new Python project called `database_fun`.
    Now, locate the database tools. You can find them on the right side toolbar via
    the database icon that looks like a three-layer cake (yum!). Alternatively, you
    can find it via the hamburger (yum!) menu by clicking **View** | **Tool Windows**
    | **Database**. Both options are shown in *Figure 11**.4*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 PyCharm 专业版并创建一个名为 `database_fun` 的新 Python 项目。现在，定位数据库工具。您可以在右侧工具栏中通过看起来像三层蛋糕（美味！）的数据库图标找到它们。或者，您可以通过点击**视图**
    | **工具窗口** | **数据库**的汉堡菜单（美味！）来找到它。两种选项都在*图 11.4*中显示。
- en: '![Figure 11.4: Two options for opening database tools – one from the menu,
    and the second by clicking the database tools icon](img/B19644_11_004.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4：打开数据库工具的两种选项 – 一种来自菜单，另一种通过点击数据库工具图标](img/B19644_11_004.jpg)'
- en: 'Figure 11.4: Two options for opening database tools – one from the menu, and
    the second by clicking the database tools icon'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4：打开数据库工具的两种选项 – 一种来自菜单，另一种通过点击数据库工具图标
- en: With the database tools open, you need to create a new **data source**. Note
    the generic terminology. PyCharm supports relational as well as non-relational
    databases, so the term *data source* is just a generic way of pointing that out.
    Click the **+** icon shown in *Figure 11**.5*, then hover over **Data Source**.
    You’ll see a long list of supported data sources. Find **MySQL** and click it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开数据库工具后，您需要创建一个新的**数据源**。注意这个术语的通用性。PyCharm 支持关系型数据库以及非关系型数据库，所以“数据源”这个术语只是一个通用的方式来指出这一点。点击*图
    11.5*中显示的**+**图标，然后悬停在**数据源**上。您将看到一个支持的数据源的长列表。找到**MySQL**并点击它。
- en: '![Figure 11.5: Supported data sources in PyCharm](img/B19644_11_005.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5：PyCharm 支持的数据源](img/B19644_11_005.jpg)'
- en: 'Figure 11.5: Supported data sources in PyCharm'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5：PyCharm 支持的数据源
- en: You’ll see a configuration window like mine in *Figure 11**.6*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到*图 11.6*中像我一样的配置窗口。
- en: '![Figure 11.6: Configuration window for a MySQL database](img/B19644_11_006.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.6：MySQL 数据库的配置窗口](img/B19644_11_006.jpg)'
- en: 'Figure 11.6: Configuration window for a MySQL database'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6：MySQL 数据库的配置窗口
- en: Each database server may have slightly different settings, but essentially they
    boil down to the IP address (or DNS name), port, security credentials, and, very
    often, the default database, which may not yet exist. We defined the root password
    for our MySQL server as `P@ssw0rd`, and we know since we’re running in Docker
    our IP is just going to be `localhost`. You might also remember the port that
    was displayed in the output of the `docker ps -a` command we ran earlier is `3306`.
    The arrow in the preceding figure points to an important aspect of database tooling
    in PyCharm.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据库服务器可能有略微不同的设置，但本质上它们归结为 IP 地址（或 DNS 名称）、端口、安全凭证，以及非常常见的是默认数据库，这可能还不存在。我们为我们的
    MySQL 服务器定义了根密码为 `P@ssw0rd`，并且我们知道由于我们在 Docker 中运行，我们的 IP 地址将是 `localhost`。您可能也记得我们之前运行的
    `docker ps -a` 命令中显示的端口是 `3306`。前一个图中的箭头指向 PyCharm 数据库工具的一个重要方面。
- en: PyCharm, like most JetBrains IDEs, is written in Java. As such, PyCharm relies
    on **Java Database Connectivity** (**JDBC**) drivers in order to work. Most JDBC
    drivers are written by the same company or group that publishes the database,
    which means it’s generally not legal for JetBrains to bundle those drivers with
    PyCharm without getting lawyers involved. Nobody wants that! JetBrains did the
    next best thing. The IDE can download and install the driver automatically, but
    you have to initiate this by clicking the **Download missing driver files** link
    on this screen. This only needs to be done the first time you use the database
    driver. Once the drivers are installed, the option shown by the arrow in *Figure
    11**.6* no longer appears. You can test your connection by clicking the **Test
    Connection** link. If everything works, you’ll get a confirmation message stating
    your database connection was successful. Click **OK** to close the connection
    dialog.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm，就像大多数 JetBrains IDE 一样，是用 Java 编写的。因此，PyCharm 需要依赖**Java 数据库连接**（**JDBC**）驱动程序才能工作。大多数
    JDBC 驱动程序是由发布数据库的同一公司或团队编写的，这意味着如果没有律师介入，JetBrains 通常不能将那些驱动程序捆绑到 PyCharm 中。没有人想那样做！JetBrains
    做了下一件最好的事情。IDE 可以自动下载和安装驱动程序，但您必须通过点击此屏幕上的**下载缺失的驱动文件**链接来启动此操作。这只需要在您第一次使用数据库驱动程序时完成。一旦安装了驱动程序，*图
    11.6*中箭头所示的选项就不再出现。您可以通过点击**测试连接**链接来测试您的连接。如果一切正常，您将收到一条确认消息，表明您的数据库连接成功。点击**确定**以关闭连接对话框。
- en: Once the connection dialog is closed, you’ll see a list of data source connections
    for your project in the **Database** panel. There is a small toolbar visible at
    the top of the database panel, as shown in *Figure 11**.7*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭连接对话框后，您将在**数据库**面板中看到您项目的数据源连接列表。数据库面板顶部有一个可见的小工具栏，如图11.7所示。
- en: '![Figure 11.7: The database panel has a small menu bar at the top](img/B19644_11_007.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图11.7：数据库面板顶部有一个小菜单栏](img/B19644_11_007.jpg)'
- en: 'Figure 11.7: The database panel has a small menu bar at the top'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7：数据库面板顶部有一个小菜单栏
- en: 'As usual, I’ve numbered the options in the figure. Let’s review them:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，我在图中对选项进行了编号。让我们回顾一下：
- en: The **Add Data Source** button, which we’ve already seen, allows you to add
    new data sources to your project.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经看到的**添加数据源**按钮允许您将新的数据源添加到您的项目中。
- en: The **Duplicate** button allows you to make a quick copy, presumably with some
    minor adjustments. Many of my projects entail multiple databases on one server.
    All I have to do is set up the first one, then duplicate the connection and change
    the name of the database. This option makes this a quick and easy process.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**复制**按钮允许您快速复制，可能进行一些小的调整。我的许多项目涉及一个服务器上的多个数据库。我只需设置第一个数据库，然后复制连接并更改数据库名称。此选项使这个过程变得快速且简单。'
- en: The **Refresh** button reloads the metadata for your connections. Remember this
    one. PyCharm doesn’t automatically keep track of all your database changes, especially
    if they are made outside of PyCharm. You’ll need to click the **Refresh** button
    periodically to make sure you’re viewing the latest information on your data sources.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**刷新**按钮用于重新加载您连接的元数据。请记住这一点。PyCharm不会自动跟踪您所有的数据库更改，尤其是如果您在PyCharm之外进行更改。您需要定期点击**刷新**按钮，以确保您查看的是数据源的最新信息。'
- en: The **Data source properties** button will display a dialog that allows you
    to change the settings of the data source configuration.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数据源属性**按钮将显示一个对话框，允许您更改数据源配置的设置。'
- en: The **Disconnect** button will disconnect you from a database server.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**断开连接**按钮将使您从数据库服务器断开连接。'
- en: The **Edit data** button allows you to directly edit data in tables in your
    database using a graphical, spreadsheet-like UI. This is nice for quickly adding
    or changing test data.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编辑数据**按钮允许您使用图形化、类似电子表格的用户界面直接在数据库中的表中编辑数据。这对于快速添加或更改测试数据来说很方便。'
- en: The **Go To DDL** button will take you to the SQL definition of whatever you
    have currently selected. You need to have a DDL mapping for this to work properly.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**转到DDL**按钮将带您到当前所选内容的SQL定义。您需要有一个DDL映射才能正确工作。'
- en: '**Compare Structure** lets us compare two database structures. This is usually
    used to help migrate one database structure to another after changes were made
    during the normal development process. Migration technology in PyCharm 2023 is
    only partially complete, so this feature might have changed at the time you are
    reading this book.'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**比较结构**允许我们比较两个数据库结构。这通常用于在正常开发过程中进行更改后，帮助将一个数据库结构迁移到另一个数据库。PyCharm 2023的迁移技术仅部分完成，因此这个功能在你阅读这本书的时候可能已经有所变化。'
- en: '**Jump to Query Console** is pretty much your go-to tool for interacting with
    the database at the command line. A query console was opened automatically when
    you first connected to the database, but if you closed it, this button opens it
    and brings it into focus.'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**跳转到查询控制台**基本上是您在命令行与数据库交互的常用工具。当您第一次连接到数据库时，会自动打开查询控制台，但如果您已关闭它，此按钮将打开它并将其置于焦点。'
- en: The filter button allows you to filter what you see in the data sources you
    have defined. By default, everything is turned on, which might be a bit much for
    most developers who are not usually accustomed to seeing all the guts of the database
    so explicitly displayed.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**过滤器**按钮允许您过滤您在已定义的数据源中看到的内容。默认情况下，所有选项都处于开启状态，这可能对大多数不习惯如此明确地看到数据库所有细节的开发者来说有点多。'
- en: Besides these tools, there are others that pertain to setting up how you view
    and work with your data sources. These will be a little easier to explain once
    we have a database to play with. Let’s take a moment to create one.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些工具之外，还有一些与设置您如何查看和使用数据源相关的其他工具。一旦我们有一个数据库可以操作，这些工具的解释将会更容易。让我们花点时间创建一个数据库。
- en: Creating a new database
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新的数据库
- en: Before we do anything else, we need a new database. Most database servers just
    call this “a new database.” MySQL is a little different. They call a new database
    a new `@localhost`) and click **New** | **Schema**, as shown in *Figure 11**.8*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们做任何事情之前，我们需要一个新的数据库。大多数数据库服务器只是将这个称为“一个新的数据库”。MySQL 稍有不同。他们将一个新的数据库称为新的 `@localhost`)
    并点击 **新** | **模式**，如图 *图 11.8* 所示。
- en: '![Figure 11.8: Create a new database by right-clicking the server (indicated
    by the arrow), then New | Schema](img/B19644_11_008.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.8：通过右键单击服务器（箭头所示），然后选择“新”|“模式”来创建一个新的数据库](img/B19644_11_008.jpg)'
- en: 'Figure 11.8: Create a new database by right-clicking the server (indicated
    by the arrow), then New | Schema'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8：通过右键单击服务器（箭头所示），然后选择“新”|“模式”来创建一个新的数据库
- en: When you do this, you are prompted to name the schema, as shown in *Figure 11**.9*.
    I’ll name my schema to match my project in PyCharm. I’ll call it `database_fun`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当您这样做时，系统会提示您命名模式，如图 *图 11.9* 所示。我将我的模式命名为与 PyCharm 中的项目匹配。我将它命名为 `database_fun`。
- en: '![Figure 11.9: Name your schema using this dialog](img/B19644_11_009.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.9：使用此对话框命名您的模式](img/B19644_11_009.jpg)'
- en: 'Figure 11.9: Name your schema using this dialog'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9：使用此对话框命名您的模式
- en: Beneath the covers, PyCharm is just generating and executing DDL statements.
    This is how it is able to be so agnostic with respect to so many database options.
    You can see the preview of the command it will run in *Figure 11**.9*. Click **OK**
    to execute the command, and the database window will update to show the new schema.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，PyCharm 正在生成和执行 DDL 语句。这就是它能够对许多数据库选项保持如此无差别的理由。您可以在 *图 11.9* 中看到它将运行的命令预览。点击
    **确定** 执行命令，数据库窗口将更新以显示新的模式。
- en: You’ve just created a new database! It is just as easy using any other database
    server software supported by PyCharm.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚创建了一个新的数据库！使用 PyCharm 支持的任何其他数据库服务器软件同样简单。
- en: Before we get into working on the structure of our database, there are a few
    more setup options to consider.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始处理数据库结构之前，还有一些其他设置选项需要考虑。
- en: Setting the SQL dialect (this is crucial)
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 SQL 方言（这是至关重要的）
- en: Since PyCharm supports dozens of different databases, each with its own dialect
    of SQL, it stands to reason that you might need to tell PyCharm which SQL dialect
    you intend to use. You won’t have any trouble remembering to do this because PyCharm
    nags you until you fill in the setting.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 PyCharm 支持数十种不同的数据库，每种数据库都有自己的 SQL 方言，因此可以理解您可能需要告诉 PyCharm 您打算使用哪种 SQL 方言。您不会忘记这样做，因为
    PyCharm 会一直催促您，直到您填写设置。
- en: In your project window, right-click the project and create a new file called
    `test.sql`. It’s the same process we’ve been using for Python files, except there
    isn’t a template in the list. Right-click the project, then click **New File**,
    as shown in *Figure 11**.10*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的项目窗口中，右键单击项目并创建一个名为 `test.sql` 的新文件。这与我们一直在使用的 Python 文件的过程相同，只是列表中没有模板。右键单击项目，然后点击
    **新建文件**，如图 *图 11.10* 所示。
- en: '![Figure 11.10: There isn’t a specific listing for SQL files, so just right-click
    and pick New | File](img/B19644_11_010.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.10：没有特定的 SQL 文件列表，所以只需右键单击并选择“新”|“文件”](img/B19644_11_010.jpg)'
- en: 'Figure 11.10: There isn’t a specific listing for SQL files, so just right-click
    and pick New | File'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.10：没有特定的 SQL 文件列表，所以只需右键单击并选择“新”|“文件”
- en: A small dialog will appear. Type the name of the file as `test.sql`. The moment
    you do this, the nagging begins. You’ll see a message stating the SQL dialect
    is not configured, as shown in *Figure 11**.11*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 将会弹出一个小的对话框。将文件的名称键入为 `test.sql`。您这样做的时候，就会开始催促。您会看到一个消息指出 SQL 方言尚未配置，如图 *图
    11.11* 所示。
- en: '![Figure 11.11: PyCharm will hound you until you configure the SQL dialect](img/B19644_11_11.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.11：PyCharm 会一直催促您，直到您配置 SQL 方言](img/B19644_11_11.jpg)'
- en: 'Figure 11.11: PyCharm will hound you until you configure the SQL dialect'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.11：PyCharm 会一直催促您，直到您配置 SQL 方言
- en: If PyCharm were me and the user of PyCharm were my 13-year-old daughter, there
    would be a lot of eye-rolling, an exasperated grunt, followed by, “Fine! I’ll
    set the SQL dialog! But none of my friends do!” Then I’d say, “If you’re friends
    all installed Windows 7 on their computers, would you follow their example?” Then
    she’d sag her head and say, “No, of course not.”
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 PyCharm 是我，而 PyCharm 的用户是我的 13 岁女儿，那么会有很多翻白眼，一个沮丧的哼声，然后说，“好吧！我会设置 SQL 对话框！但我的朋友们都没有这么做！”然后我会说，“如果你的朋友们都在他们的电脑上安装了
    Windows 7，你会跟随他们的例子吗？”然后她会垂下头来说，“不，当然不会。”
- en: Nobody wants this dialogue playing out, so we’d better make our IDE overlord
    happy. Click the link in *Figure 11**.11* to set the dialect. You’ll need to set
    it locally and globally. The configuration is shown in *Figure 11**.12*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人想看到这个对话框播放出来，所以我们最好让我们的 IDE 君主开心。点击 *图 11.11* 中的链接来设置方言。你需要本地和全局地设置它。配置如
    *图 11.12* 所示。
- en: '![Figure 11.12: Set the SQL dialects globally and locally](img/B19644_11_012.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.12：全局和本地设置 SQL 方言](img/B19644_11_012.jpg)'
- en: 'Figure 11.12: Set the SQL dialects globally and locally'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12：全局和本地设置 SQL 方言
- en: The global setting carries across all projects, so if you’re like me and you
    only ever use one database server type, you can set it globally here, and it will
    be set for all your projects. The project dialect is a little more nuanced. If
    you value your sanity, you really need to create a folder for your SQL files,
    then set the dialect for the folder. Here, I’m just showing you where the settings
    are. Go ahead and pick **MySQL** for your global and local dialect and we’ll worry
    about the whole folder idea a little later.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 全局设置适用于所有项目，所以如果你像我一样，你只使用一种数据库服务器类型，你可以在全局这里设置它，它将为所有你的项目设置。项目方言稍微复杂一些。如果你重视你的理智，你真的需要为你的
    SQL 文件创建一个文件夹，然后为文件夹设置方言。在这里，我只是向你展示设置在哪里。请先选择 **MySQL** 作为你的全局和本地方言，我们稍后再讨论整个文件夹的想法。
- en: Grouping and color coding data sources
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对数据源进行分组和颜色编码
- en: My own work consists of creating the SaaS product sold by my employer. This
    means that for the first seven years of the project, I only had one database to
    deal with. As the product grew in capability, we added two more SQL databases,
    a MongoDB database, and several Redis data caches to the project. My project is
    still pretty tame compared to some I’ve worked on. If you have many databases
    to deal with, PyCharm allows you to organize them in several different ways.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我的工作是创建我雇主销售的服务软件产品。这意味着在项目的头七年里，我只处理一个数据库。随着产品功能的增长，我们向项目中添加了两个额外的 SQL 数据库、一个
    MongoDB 数据库和几个 Redis 数据缓存。与我所参与的一些项目相比，我的项目仍然相当温和。如果你要处理很多数据库，PyCharm 允许你以几种不同的方式组织它们。
- en: Organizing by folders
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过文件夹组织
- en: You can organize your data sources by grouping them into folders. We only have
    one, but we’ll go through the process anyway. Click the data source indicated
    by the arrow in *Figure 11**.8*. Last time, we right-clicked; this time, just
    click the data source and press *F6* on your keyboard. This brings up a dialog,
    as shown in *Figure 11**.13*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将数据源分组到文件夹中来组织你的数据源。我们只有一个，但我们仍然会通过这个过程。点击 *图 11.8* 中箭头所示的数据源。上次我们是右键点击；这次，只需点击数据源并在键盘上按
    *F6* 键。这将弹出一个对话框，如 *图 11.13* 所示。
- en: '![Figure 11.13: Create a new folder for your data source](img/B19644_11_013.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.13：为你的数据源创建一个新文件夹](img/B19644_11_013.jpg)'
- en: 'Figure 11.13: Create a new folder for your data source'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.13：为你的数据源创建一个新文件夹
- en: Organizing by folder can be useful if you have lots of databases in your project,
    or maybe you have separate sets of connections for development, **user acceptance
    testing** (**UAT**), and production.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通过文件夹组织可以很有用，如果你在项目中有很多数据库，或者你可能为开发、**用户验收测试**（**UAT**）和生产有单独的连接集。
- en: Color coding databases
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用颜色编码数据库
- en: 'I’m fond of this feature since I have four environments:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我很喜欢这个功能，因为我有四个环境：
- en: A local database, just like we have now
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个本地数据库，就像我们现在这样
- en: A central development testing database where the development validates their
    designs before the product team is allowed to see our changes
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个中央开发测试数据库，在产品团队被允许看到我们的更改之前，开发人员会验证他们的设计
- en: A staging database that is connected to a staged version of our application
    for UAT
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于 UAT 的与我们的应用程序预发布版本连接的预发布数据库
- en: A production database
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个生产数据库
- en: I always color code everything! You can set a color for the data source by opening
    up the **Data Source Properties** window. To do this, click the **Data Source
    Properties** button on the toolbar. I showed you this earlier in *Figure 11**.7
    (4)*. Clicking this button reveals a dialog box similar to the one you used to
    create the data source earlier. Look at mine in *Figure 11**.14*.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我总是对一切进行颜色编码！你可以通过打开 **数据源属性** 窗口来为数据源设置颜色。为此，请点击工具栏上的 **数据源属性** 按钮。我之前在 *图
    11.7*（4）中展示了这个。点击此按钮将弹出一个与之前创建数据源时使用的对话框相似的对话框。看看我的 *图 11.14*。
- en: '![Figure 11.14: Click the innocuous dot next to the data source name in the
    properties window to set a color for your data source](img/B19644_11_014.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.14：在属性窗口中点击数据源名称旁边的无害点，为您的数据源设置颜色](img/B19644_11_014.jpg)'
- en: 'Figure 11.14: Click the innocuous dot next to the data source name in the properties
    window to set a color for your data source'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.14：在属性窗口中点击数据源名称旁边的无害点，为您的数据源设置颜色
- en: You can probably figure it out from here. Once you dismiss the dialog, your
    database elements in the IDE become awash with lovely pastel hues. Personally,
    I set my local development environment to violet, the dev environment to green,
    staging to yellow, and production to red. Not rose from the selection, but a bright,
    obnoxious, over-the-top, fire engine red picked from the custom dialog at the
    bottom of the list. As the project’s development lead, there are times when I
    need to go look at the project in production. I want to make sure I remember where
    I am! Color coding helps!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能从这里就能理解。一旦关闭对话框，您在 IDE 中的数据库元素就会变得五彩斑斓。我个人将我的本地开发环境设置为紫色，开发环境设置为绿色，预发布设置为黄色，生产设置为红色。不是从选择中选出的玫瑰色，而是一种鲜艳、刺眼、过分、像消防车一样的红色，我从列表底部的自定义对话框中挑选出来的。作为项目开发负责人，有时我需要查看生产环境中的项目。我想确保我能记住我在哪里！颜色编码有助于！
- en: Sharing a data source between projects
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在项目之间共享数据源
- en: If you have many projects that use the same data source, it would be tedious
    to have to set the same thing over and over for each project. Thankfully, you
    don’t have to. PyCharm allows you to make a data source global, meaning it is
    available to all your projects in PyCharm. In the data source properties window
    shown in *Figure 11**.15*, find the button indicated by the arrow.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有多个使用相同数据源的项目，每次都要为每个项目重复设置相同的内容将会很繁琐。幸运的是，您不必这样做。PyCharm 允许您将数据源设置为全局，这意味着它可以在
    PyCharm 的所有项目中使用。在 *图 11.15* 展示的数据源属性窗口中，找到箭头指示的按钮。
- en: '![Figure 11.15: You can make your data source configuration global so it is
    available to all your projects](img/B19644_11_015.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.15：您可以将数据源配置设置为全局，这样它就可以在所有项目中使用](img/B19644_11_015.jpg)'
- en: 'Figure 11.15: You can make your data source configuration global so it is available
    to all your projects'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.15：您可以将数据源配置设置为全局，这样它就可以在所有项目中使用
- en: If you click it, the dialog changes very subtly to indicate the data source
    is now global. If you want to check, just make a new project like we did earlier.
    Open the database tools and you’ll find the data source is already there. I made
    a project called `more_database_fun`, and as you can see in *Figure 11**.16*,
    the data source indeed carried over.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击它，对话框会非常微妙地改变，以表明数据源现在是全局的。如果您想检查，只需创建一个新项目，就像我们之前做的那样。打开数据库工具，您会发现数据源已经在那里了。我创建了一个名为
    `more_database_fun` 的项目，如图 11.16 所示，数据源确实被继承了下来。
- en: '![Figure 11.16: I made a new project and opened the database tools. The global
    data source is there](img/B19644_11_016.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.16：我创建了一个新项目并打开了数据库工具。全局数据源就在那里](img/B19644_11_016.jpg)'
- en: 'Figure 11.16: I made a new project and opened the database tools. The global
    data source is there'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.16：我创建了一个新项目并打开了数据库工具。全局数据源就在那里
- en: Since there is no code in this second project, I did not include it in the chapter
    source code.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个第二个项目中没有代码，我没有将其包含在章节源代码中。
- en: Another fun feature is the global data sources are exported when you export
    your IDE settings. Refer back to [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028),
    *Installation and Configuration*, if you need a refresher on importing and exporting
    settings, but I’ll go ahead and point out the export settings I’m talking about
    here in *Figure 11**.17*.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的功能是，当您导出 IDE 设置时，全局数据源也会被导出。如果您需要复习导入和导出设置，请参考 [*第 2 章*](B19644_02.xhtml#_idTextAnchor028)，*安装和配置*，但我将在这里指出
    *图 11.17* 中提到的导出设置。
- en: '![Figure 11.17: You can export your global data sources to the settings export
    ZIP file, allowing others to simply import the relevant settings](img/B19644_11_017.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.17：您可以将全局数据源导出到设置导出 ZIP 文件中，允许其他人简单地导入相关设置](img/B19644_11_017.jpg)'
- en: 'Figure 11.17: You can export your global data sources to the settings export
    ZIP file, allowing others to simply import the relevant settings'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.17：您可以将全局数据源导出到设置导出 ZIP 文件中，允许其他人简单地导入相关设置
- en: If you are a development lead, you might consider creating an export of your
    IDE settings that does not include things such as color and font size. Those are
    likely more personal preferences and make sense when you want to copy your settings
    between a laptop and a workstation. But it does make sense to export more work-specific
    settings such as your data sources so your team can easily import them. If you
    do this, remember you are also potentially copying credentials! You should only
    make development data sources available as global exports lest your `settings.zip`
    file falls into the wrong hands. This is especially important in an age where
    more and more of us are using cloud database servers rather than locally installed
    servers.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一名开发主管，你可能考虑创建一个不包含颜色和字体大小等个人偏好的IDE设置导出。这些可能更适合在笔记本电脑和工作站之间复制设置时使用。但是，导出更多与工作相关的设置，如数据源，以便你的团队能够轻松导入它们是有意义的。如果你这样做，请记住你也在复制凭证！你应该只将开发数据源作为全局导出，以免你的`settings.zip`文件落入错误的手中。在越来越多的人使用云数据库服务器而不是本地安装的服务器的时代，这一点尤为重要。
- en: If you need tight control over credentials, PyCharm can integrate with a product
    called *KeePass*. Since that is fairly niche, I’ll not cover it here, but I will
    leave a link with more details in the *Further reading* section of this chapter.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要严格控制凭证，PyCharm可以与名为*KeePass*的产品集成。由于这相当专业，我这里不会介绍，但我会在这个章节的*进一步阅读*部分留下一个包含更多详细信息的链接。
- en: Connecting with SSL and SSH options
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用SSL和SSH选项进行连接
- en: For even more security, especially with respect to cloud data sources, PyCharm
    supports SSL and SSH configuration options. See *Figure 11**.18* for your security
    setup options for your data sources.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得更高的安全性，特别是针对云数据源，PyCharm支持SSL和SSH配置选项。请参阅*图11.18*以获取你的数据源安全设置选项。
- en: '![Figure 11.18: SSH and SSL security options can be found in the data source
    settings on the SSH/SSL tab](img/B19644_11_018.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图11.18：SSH和SSL安全选项可以在SSH/SSL选项卡的数据源设置中找到](img/B19644_11_018.jpg)'
- en: 'Figure 11.18: SSH and SSL security options can be found in the data source
    settings on the SSH/SSL tab'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.18：SSH和SSL安全选项可以在SSH/SSL选项卡的数据源设置中找到
- en: I won’t go deep into this here, but you need to know where these settings lie
    in the IDE since you will need them for cloud providers such as Microsoft Azure.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里不会深入探讨，但你需要知道这些设置在IDE中的位置，因为你在使用像Microsoft Azure这样的云服务提供商时需要它们。
- en: Database design and manipulation
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库设计和操作
- en: 'Let’s move on to the part you’ve probably been waiting for: the part where
    we get to build a database! We already created the schema, but at the moment,
    we don’t have any tables. Let’s fix that first!'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到你可能一直在等待的部分：构建数据库的部分！我们已经创建了架构，但到目前为止，我们还没有任何表。让我们先解决这个问题！
- en: Creating a table
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个表
- en: Right-click the schema, **database_fun**, which we created earlier, and click
    **New** | **Table**, as shown in *Figure 11**.19*.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击我们之前创建的**database_fun**架构，然后点击**新建** | **表**，如图*图11.19*所示。
- en: '![Figure 11.19: Right-click on the schema indicated by the arrow, then click
    New | Table](img/B19644_11_019.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图11.19：右键单击箭头指示的架构，然后点击新建 | 表](img/B19644_11_019.jpg)'
- en: 'Figure 11.19: Right-click on the schema indicated by the arrow, then click
    New | Table'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.19：右键单击箭头指示的架构，然后点击新建 | 表
- en: You’ll get a new window, as shown in *Figure 11**.20*.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到一个新窗口，如图*图11.20*所示。
- en: '![Figure 11.20: New window](img/B19644_11_020.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图11.20：新窗口](img/B19644_11_020.jpg)'
- en: 'Figure 11.20: New window'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.20：新窗口
- en: I had to stretch mine out a little to see it all, as shown in the figure. The
    next few steps will build our table. I went ahead and typed the table name in
    the **Name** field at the top. You can see what’s going on here. As before, with
    the schema creation DDL, PyCharm is building a DDL script in the preview at the
    bottom of the window. Right now, we have a red squiggly line under the semicolon
    because we have yet to add any fields, so this DDL is invalid.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我不得不稍微拉伸一下才能看到全部内容，如图所示。接下来的几个步骤将构建我们的表。我在顶部的**名称**字段中输入了表名。你可以看到这里发生了什么。和之前一样，在架构创建DDL中，PyCharm正在窗口底部的预览中构建DDL脚本。目前，我们在分号下有一个红色的波浪线，因为我们还没有添加任何字段，所以这个DDL是无效的。
- en: At the top left of the window is a button with a **+** icon. Click that to see
    a list of elements you can add to the table, as shown in *Figure 11**.21*.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口的左上角有一个带有**+**图标的按钮。点击它以查看可以添加到表中的元素列表，如图*图11.21*所示。
- en: '![Figure 11.21: You can add to the table by clicking the + button](img/B19644_11_021.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图11.21：你可以通过点击+按钮向表中添加内容](img/B19644_11_021.jpg)'
- en: 'Figure 11.21: You can add to the table by clicking the + button'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.21：你可以通过点击+按钮向表中添加内容
- en: From here, you can pick whatever it is you need to add. We’re going to add our
    primary key field first. If you’re new to relational database design and you need
    a good primer, *Database Design for Mere Mortals* by Michael Hernandez is a must-read.
    I’ve used it as a textbook in my classes for over 20 years! Hernandez has an equally
    impactful book on SQL queries, as does another author, named Ben Forta. I’ll leave
    the details in the *Further reading* section of this chapter.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，你可以选择你需要添加的任何内容。我们将首先添加我们的主键字段。如果你是关系数据库设计的新手，并且需要一个好的入门书籍，Michael Hernandez的《Database
    Design for Mere Mortals》是必读之作。我已经在我的课堂上使用了20多年！Hernandez还有一本关于SQL查询同样有影响力的书，另一位作者Ben
    Forta也是如此。我将细节留在本章的“进一步阅读”部分。
- en: In short, every table we create should have a field that can uniquely identify
    individual records. It should not consist of data that is related to the domain
    of data contained in the table. By this I mean we are making a table to hold information
    about book authors. We should not use any field related to the author as the primary
    key, the record’s unique identifier. Instead, we should use something unrelated.
    With MySQL, the norm is to use an auto-incrementing integer field.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们创建的每个表都应该有一个字段可以唯一标识单个记录。它不应由与表中包含的数据域相关的数据组成。我的意思是，我们正在创建一个表来存储关于图书作者的信息。我们不应使用与作者相关的任何字段作为主键，即记录的唯一标识符。相反，我们应该使用一些无关的东西。在MySQL中，通常使用自动增长的整数字段。
- en: An auto-incrementing integer field refers to a field that will automatically
    populate a number from a sequence starting with the number 1 and increasing automatically
    with each record insertion. The increment is not something you should do in code.
    This is a feature of the database itself. This is important. Relational databases
    are designed to be atomic, meaning all transactions are isolated. This is important
    because it means the database will never generate the same value for the auto-incrementing
    key even if two record insertions happen within microseconds of one another. This
    is something you cannot guarantee with your own code. You need to rely on the
    server for this.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 自动增长的整数字段指的是一个字段，它将自动填充一个从1开始的序列号，并在每次记录插入时自动增加。这个增加不是你应该在代码中做的事情。这是数据库本身的一个特性。这很重要。关系数据库被设计成原子的，这意味着所有事务都是隔离的。这很重要，因为它意味着即使两个记录插入在彼此微秒之内发生，数据库也不会为自动增长的键生成相同的值。这是你不能通过自己的代码保证的事情。你需要依赖服务器来做这件事。
- en: Using the menu shown in *Figure 11**.21*, add a column and set it as shown in
    *Figure 11**.22*.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用图11.21中所示的菜单，添加一个列并设置如图11.22所示。
- en: '![Figure 11.22: Add the first column with the settings shown here](img/B19644_11_022.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图11.22：添加具有此处所示设置的第一个列](img/B19644_11_022.jpg)'
- en: 'Figure 11.22: Add the first column with the settings shown here'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.22：添加具有此处所示设置的第一个列
- en: Here, we’ve created an auto-incrementing integer field called `author_id`. I’m
    using snake case here, but this is not required. Use whatever naming conventions
    your project requires. Note I haven’t yet officially made it the primary key.
    That’s coming. First, let’s finish out the rest of our columns.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为`author_id`的自动增长的整数字段。我在这里使用的是蛇形命名法，但这不是必需的。使用你项目需要的任何命名约定。注意，我还没有正式将其设为主键。那即将到来。首先，让我们完成其余的列。
- en: This can be done quickly if you leave the `author_id` field selected, then click
    the plus button three times. When you have a column selected, or even when you
    have the `columns` folder selected in the window, PyCharm assumes that when you
    click the **+** button, you want a column. Likewise, you can select any of the
    other folders for things such as primary keys, foreign keys, and indexes. PyCharm
    will simply create it without making you use the menu we saw earlier.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选中`author_id`字段，然后点击加号按钮三次，这可以快速完成。当你选中一个列，或者甚至当你在窗口中选中`columns`文件夹时，PyCharm会假设当你点击**+**按钮时，你想要一个列。同样，你也可以选择其他文件夹，比如主键、外键和索引。PyCharm会简单地创建它，而不会让你使用我们之前看到的菜单。
- en: 'Configure the three fields like so:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式配置三个字段：
- en: '`first_name`: `varchar(30)`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`first_name`: `varchar(30)`'
- en: '`last_name`: `varchar(30)`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`last_name`: `varchar(30)`'
- en: '`email`: `varchar(255)` `not null`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`email`: `varchar(255)` `not null`'
- en: '*Figure 11**.23* shows the last field configuration. I gave this one the `not
    null` constraint, which will prevent a record insertion from completing if the
    `email` field is left empty. This is done by clicking the checkbox titled **Not
    null**, as seen in *Figure 11**.22*.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11**.23*显示了最后一个字段配置。我给这个字段添加了`not null`约束，这将防止在`email`字段留空时记录插入完成。这是通过点击标题为**非空**的复选框来完成的，如图*图11**.22*所示。'
- en: '![Figure 11.23: Configure the email field as shown](img/B19644_11_023.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图11.23：按图所示配置电子邮件字段](img/B19644_11_023.jpg)'
- en: 'Figure 11.23: Configure the email field as shown'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.23：按图所示配置电子邮件字段
- en: It’s starting to look like a table, isn’t it? There are just a couple more things
    we need. Let’s go ahead and configure the `author_id` field to be a proper primary
    key.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 它开始看起来像一张表，不是吗？我们还需要几样东西。让我们继续配置`author_id`字段，使其成为一个合适的主键。
- en: Setting the primary key
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置主键
- en: Click on the `keys` folder, then click the **+** button. You’re asked whether
    you want to create a primary or unique key, as shown in *Figure 11**.24*.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 点击`keys`文件夹，然后点击**+**按钮。你会被问是否要创建主键或唯一键，如图*图11**.24*所示。
- en: '![Figure 11.24: Make sure the keys folder is selected, as shown in this figure,
    then click the + icon and pick Primary Key](img/B19644_11_024.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图11.24：确保已选择keys文件夹，如图所示，然后点击+图标并选择主键](img/B19644_11_024.jpg)'
- en: 'Figure 11.24: Make sure the keys folder is selected, as shown in this figure,
    then click the + icon and pick Primary Key'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.24：确保已选择keys文件夹，如图所示，然后点击+图标并选择主键
- en: This will bring up a different window, as seen in *Figure 11**.25*.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这将弹出一个不同的窗口，如图*图11**.25*所示。
- en: '![Figure 11.25: Adding a primary key entails clicking the + icon and then selecting
    the field name from the dropdown](img/B19644_11_025.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图11.25：添加主键需要点击+图标，然后从下拉菜单中选择字段名](img/B19644_11_025.jpg)'
- en: 'Figure 11.25: Adding a primary key entails clicking the + icon and then selecting
    the field name from the dropdown'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.25：添加主键需要点击+图标，然后从下拉菜单中选择字段名
- en: To add the key, click the `author_id` field to add it as the primary key. The
    relational theory allows for the creation of compound keys, which is why you could
    potentially add more than one field. It isn’t used in general practice since if
    you stick to an auto-incrementing integer for your key, creating a compound primary
    key isn’t needed. In fact, I consider a compound key to be a code smell.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加键，点击`author_id`字段将其添加为主键。关系理论允许创建复合键，这就是为什么你可以添加多个字段。在一般实践中并不常用，因为如果你为键使用自增整数，创建复合主键就不必要了。实际上，我认为复合键是一个代码异味。
- en: Adding a unique key constraint
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加唯一键约束
- en: Next, let’s constrain the `email` field so that the value of any inserted record
    must be unique. This prevents data toxicity problems arising from promiscuous
    inserts. There should really only be one record for each email address. Let’s
    enforce it formally with a unique key.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们约束`email`字段，以确保任何插入的记录的值必须是唯一的。这可以防止由随意插入引起的数据毒性问题。每个电子邮件地址应该只有一个记录。让我们通过唯一键正式实施它。
- en: The process is the same as with the primary key, except this time we’ll pick
    a unique key instead of the primary key and we’ll specify the `email` field. There’s
    a trick though. This time, you’ll need to right-click the `keys` folder to pick
    the **Unique Key**. If you just click the **+** icon, it will add another primary
    key field, which isn’t what we want. *Figure 11**.26* shows you what to do.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程与设置主键相同，只是这次我们将选择唯一键而不是主键，并指定`email`字段。但是有一个技巧。这次，你需要右键点击`keys`文件夹来选择**唯一键**。如果你只点击**+**图标，它将添加另一个主键字段，这不是我们想要的。*图11**.26*显示了你要做什么。
- en: '![Figure 11.26: Right-click keys, then click New | Unique Key to avoid creating
    a second primary key](img/B19644_11_026.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图11.26：右键点击keys，然后点击新建 | 唯一键以避免创建第二个主键](img/B19644_11_026.jpg)'
- en: 'Figure 11.26: Right-click keys, then click New | Unique Key to avoid creating
    a second primary key'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.26：右键点击keys，然后点击新建 | 唯一键以避免创建第二个主键
- en: Right-click the `keys` folder, indicated by the arrow in the preceding figure,
    then click `email` field. I would also change the name from the generated `authors_pk2`
    value to `authors_uq`. This will tell you at a glance in the DDL that it is a
    unique field constraint.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击前一个图中的箭头所指的`keys`文件夹，然后点击`email`字段。我还会将名称从生成的`authors_pk2`值更改为`authors_uq`。这将让你一眼就能在DDL中知道它是一个唯一字段约束。
- en: Adding an index
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加索引
- en: Adding an index to a table will make filtered read operations more performant.
    It would be a reasonable requirement to expect an application to allow users to
    search for an author by their email address. Adding an index to the `email` field
    will make this search faster at the expense of making new record inserts slightly
    slower. The insert performance hit is small, but if you were to add an index to
    every single field, it would become noticeable, so pick the fields you want to
    index carefully.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 向表中添加索引将使过滤读取操作更高效。预期应用程序允许用户通过电子邮件地址搜索作者是一个合理的要求。将索引添加到 `email` 字段将使此搜索更快，但会稍微减慢新记录的插入速度。插入性能的损失很小，但如果您要将索引添加到每个字段，这将变得明显，所以请仔细选择要索引的字段。
- en: The process is the same for creating the keys. Refer to *Figure 11**.27*.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 创建键的过程与此相同。请参阅 *图11.27*。
- en: '![Figure 11.27: Right-click the indexes folder and add the index as shown](img/B19644_11_027.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图11.27：右键点击索引文件夹并添加如图所示的索引](img/B19644_11_027.jpg)'
- en: 'Figure 11.27: Right-click the indexes folder and add the index as shown'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.27：右键点击索引文件夹并添加如图所示的索引
- en: This time, we right-click the `indexes` folder and click **New** | **Index**.
    From here, the dialog is familiar, as shown in *Figure 11**.28*.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们右键点击 `indexes` 文件夹，然后点击 **新建** | **索引**。从这里，对话框看起来很熟悉，如图 *图11.28* 所示。
- en: '![Figure 11.28: We’ve added an index to the email field](img/B19644_11_028.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图11.28：我们已经为电子邮件字段添加了一个索引](img/B19644_11_028.jpg)'
- en: 'Figure 11.28: We’ve added an index to the email field'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.28：我们已经为电子邮件字段添加了一个索引
- en: 'At this point, our table code won’t fit in a screenshot, so here’s what we
    have:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的表代码无法放入屏幕截图，所以这里是我们的内容：
- en: '[PRE9]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When you’re happy with your table structure, click **OK** and PyCharm will apply
    the DDL code generated to the database. You can see the results in the data source.
    Check mine out in *Figure 11**.29*.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当您对表结构满意时，点击 **确定**，PyCharm 将将生成的 DDL 代码应用到数据库中。您可以在数据源中查看结果。我的结果如图 *图11.29*
    所示。
- en: '![Figure 11.29: The results of our hard work are shown in the data source panel](img/B19644_11_029.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![图11.29：我们的辛勤工作成果显示在数据源面板中](img/B19644_11_029.jpg)'
- en: 'Figure 11.29: The results of our hard work are shown in the data source panel'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.29：我们的辛勤工作成果显示在数据源面板中
- en: Altering existing structures
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改现有结构
- en: I’ve seen a lot of tools over the years that are good at allowing you to graphically
    create a database structure, but when it comes to altering existing structures,
    they fall flat. Microsoft SSMS springs to mind! It will let you merrily design
    away only to tell you when you try to commit your changes that it can’t do it.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这些年来，我见过很多工具擅长让您图形化地创建数据库结构，但当涉及到更改现有结构时，它们却无能为力。微软 SSMS 就是一个例子！它让您愉快地设计，但当您尝试提交更改时，它会告诉您无法执行。
- en: PyCharm’s not like that. PyCharm handles changes the way your company’s DBA
    wants you to do it. If you’re new to the field, a DBA is in charge of the database.
    They’re the boss. If you are lucky enough to be granted the *privilege* of creating
    anything in their database, you will follow their rules. And they want you to
    alter structures using SQL `alter` statements.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm 并非如此。PyCharm 处理变更的方式与您公司数据库管理员（DBA）希望您执行的方式一致。如果您是新手，DBA 负责数据库管理。他们是老板。如果您有幸获得在他们的数据库中创建任何内容的**特权**，您将遵循他们的规则。他们希望您使用
    SQL 的 `alter` 语句来更改结构。
- en: Right-click the `authors` table and click **Modify Table…**, as shown in *Figure
    11**.30*.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击 `authors` 表，然后点击 **修改表…**，如图 *图11.30* 所示。
- en: '![Figure 11.30: You can alter existing tables by right-clicking the table](img/B19644_11_30.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![图11.30：您可以通过右键点击表来更改现有表](img/B19644_11_30.jpg)'
- en: 'Figure 11.30: You can alter existing tables by right-clicking the table'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.30：您可以通过右键点击表来更改现有表
- en: When you do this, you get a window like the one shown in *Figure 11**.31*.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当您这样做时，您会看到一个如图 *图11.31* 所示的窗口。
- en: '![Figure 11.31: Changes you make here are generated as an alter statement,
    which is a best practice in database development](img/B19644_11_31.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![图11.31：您在这里所做的更改将生成一个 alter 语句，这是数据库开发中的最佳实践](img/B19644_11_31.jpg)'
- en: 'Figure 11.31: Changes you make here are generated as an alter statement, which
    is a best practice in database development'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.31：您在这里所做的更改将生成一个 alter 语句，这是数据库开发中的最佳实践
- en: In *Figure 11**.31*, I’ve added a column called `date_of_birthd` with the type
    of date. As you can see in the preview window, PyCharm is generating an `alter`
    statement rather than trying to drop and recreate the table as many database editors
    do. If you wanted to drop the table, there was an option for that in the menu
    displayed in *Figure 11**.30*.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在**图11.31**中，我添加了一个名为`date_of_birthd`的列，其类型为日期。正如你在预览窗口中可以看到的，PyCharm正在生成一个`alter`语句，而不是像许多数据库编辑器那样尝试删除并重新创建表。如果你想要删除表，菜单中有一个选项，如**图11.30**所示。
- en: Generating scripts
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成脚本
- en: PyCharm has a very powerful utility for generating all kinds of SQL scripts.
    Since we’re talking about DDL here, it makes sense to learn how to generate the
    full SQL script that will create the table we’ve been working on.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm有一个非常强大的工具，可以生成各种SQL脚本。由于我们在这里讨论的是DDL，因此学习如何生成创建我们一直在工作的表的完整SQL脚本是有意义的。
- en: Right-click the database, as shown in *Figure 11**.32*, and click the **SQL
    Scripts** | **SQL Generator…** menu item.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击数据库，如**图11.32**所示，然后点击**SQL脚本** | **SQL生成器…**菜单项。
- en: '![Figure 11.32: SQL Generator generates the create script for our database](img/B19644_11_32.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图11.32：SQL生成器生成数据库的创建脚本](img/B19644_11_32.jpg)'
- en: 'Figure 11.32: SQL Generator generates the create script for our database'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.32：SQL生成器生成数据库的创建脚本
- en: The panel on the left allows you to set a few interesting options. As you click
    them, the generated SQL will change if applicable. I say *if applicable* because
    not every database platform supports every syntax option in the list. We’re using
    MySQL, which supports the `Use CREATE IF NOT EXISTS` syntax but doesn’t support
    the `CREATE OR REPLACE` syntax, which you would find in Postgres or Oracle. Clicking
    a syntax that isn’t supported simply doesn’t change the syntax in the preview
    window.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的面板允许你设置一些有趣选项。当你点击它们时，如果适用，生成的SQL将会改变。我说“如果适用”，因为并非每个数据库平台都支持列表中的每个语法选项。我们使用的是MySQL，它支持`Use
    CREATE IF NOT EXISTS`语法，但不支持在Postgres或Oracle中找到的`CREATE OR REPLACE`语法。点击不支持的语言不会改变预览窗口中的语法。
- en: When the DDL script meets your needs, you can use the buttons on the far right
    (circled in *Figure 11**.32*) to copy, save, or run the script in a query window.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当DDL脚本满足你的需求时，你可以使用最右侧的按钮（如**图11.32**中圆圈所示）来复制、保存或在查询窗口中运行脚本。
- en: Generating a database diagram
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成数据库图表
- en: Very traditional database practices typically entail a design document such
    as a database schema diagram. In the good old days, we’d use dedicated tools for
    diagramming. PyCharm has a diagramming tool built in, and the best part is the
    diagram is generated based on the structure of the database, rather than being
    drawn from scratch.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 非常传统的数据库实践通常包括一个设计文档，如数据库模式图。在那些美好的日子里，我们会使用专门的工具来绘制图表。PyCharm内置了一个图表工具，最好的部分是图表是根据数据库的结构生成的，而不是从头开始绘制。
- en: To generate a diagram, just right-click your database, find the **Diagrams**
    menu item, and pick either option shown in *Figure 11**.33*.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成一个图表，只需右键单击你的数据库，找到**图表**菜单项，然后选择**图11.33**中显示的任一选项。
- en: '![Figure 11.33: The Diagrams menu items are shown along with a generated diagram](img/B19644_11_33.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![图11.33：显示生成的图表的菜单项](img/B19644_11_33.jpg)'
- en: 'Figure 11.33: The Diagrams menu items are shown along with a generated diagram'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.33：显示生成的图表的菜单项
- en: The only difference between the two options is one draws the diagram directly
    in the content area of the IDE while the other generates it in a pop-up window.
    The pop-up window is useful for viewing the diagram on another monitor. You can
    navigate the diagram with zooming tools, as well as panning around by right-clicking
    within the diagram while dragging.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个选项之间的唯一区别是一个直接在IDE的内容区域绘制图表，而另一个在弹出窗口中生成它。弹出窗口对于在另一个显示器上查看图表很有用。你可以使用缩放工具导航图表，以及通过在图表内右键单击并拖动来平移。
- en: You’ll also find export options on the top toolbar for exporting your diagram
    to image files, as well as data files that can be imported into dedicated diagramming
    tools.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 你也会在顶部工具栏上找到导出选项，可以将你的图表导出为图像文件，以及可以导入到专用图表工具中的数据文件。
- en: Querying the data source using SQL
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SQL查询数据源
- en: Querying the database is probably the second most useful feature of having database
    tooling built right into the IDE. As with many of the features in PyCharm, this
    one ensures you never need to leave PyCharm to get your work done.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 查询数据库可能是将数据库工具直接构建到IDE中的第二大有用功能。与PyCharm中的许多功能一样，这个功能确保你永远不需要离开PyCharm来完成工作。
- en: There are several places that allow you to run queries. You can run ad hoc queries
    in a query console, or you can run queries directly from `.``sql` files.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个地方允许你运行查询。你可以在查询控制台中运行临时查询，或者你可以直接从`.sql`文件中运行查询。
- en: Ad hoc queries
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 临时查询
- en: 'Ad hoc queries are simply queries for an immediate purpose. An ad hoc query
    has a number of characteristics:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 临时查询只是针对即时目的的查询。临时查询有几个特点：
- en: '**Unplanned**: Ad hoc queries are not part of a predefined set of queries.
    They are written on the spot to address a particular need.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非计划性**：临时查询不是预定义查询集的一部分。它们是即兴编写的，以解决特定的需求。'
- en: '**Temporary**: They are used to retrieve data for a specific task or situation
    and are not saved for future use. They aren’t part of your application, though
    after some experimentation and tweaking, you might formalize them in your code.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**临时性**：它们用于检索特定任务或情况的数据，并且不会保存供将来使用。尽管经过一些实验和调整后，你可能会在代码中将它们正式化，但它们不是你应用程序的一部分。'
- en: '**No optimization**: Ad hoc queries might not be optimized for efficiency,
    as they are quickly put together without the time for fine-tuning.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无优化**：临时查询可能没有针对效率进行优化，因为它们是迅速组合而成的，没有时间进行细致调整。'
- en: '**Variability**: The syntax and structure of ad hoc queries can vary depending
    on the user’s knowledge and experience.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可变性**：临时查询的语法和结构可能因用户的知识和经验而异。'
- en: '**Not stored**: Unlike stored procedures or views, ad hoc queries are not stored
    in the database as with, say, a view or a stored procedure. This means they cannot
    be called or executed again later unless you save them to a file later.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不存储**：与存储过程或视图不同，临时查询不会像视图或存储过程一样存储在数据库中。这意味着除非你稍后将其保存到文件中，否则它们不能被再次调用或执行。'
- en: Ad hoc queries are executed in a database console. A console window appears
    automatically when you complete your connection to the data source, but there
    are many places in the interface where you can create a new console view. Look
    at *Figure 11**.34* and you’ll see the data source window. A button labeled **QL**,
    for **Query Language**, is circled. It doesn’t say *SQL* because, remember, PyCharm
    also supports NoSQL databases, such as MongoDB, Apache Cassandra, and Redis.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 临时查询是在数据库控制台中执行的。当你完成与数据源的连接时，会自动出现控制台窗口，但在界面的许多地方你都可以创建一个新的控制台视图。看看*图11.34*，你会看到数据源窗口。一个标记为**QL**（查询语言）的按钮被圈出。它没有说*SQL*，因为，记住，PyCharm也支持NoSQL数据库，如MongoDB、Apache
    Cassandra和Redis。
- en: '![Figure 11.34: Any place you see a QL icon like this you can launch a console
    window and query your data source using an ad hoc query](img/B19644_11_034.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![图11.34：在任何地方看到这样的QL图标，你都可以启动控制台窗口并使用临时查询查询数据源](img/B19644_11_034.jpg)'
- en: 'Figure 11.34: Any place you see a QL icon like this you can launch a console
    window and query your data source using an ad hoc query'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.34：在任何地方看到这样的QL图标，你都可以启动控制台窗口并使用临时查询查询数据源
- en: The **QL** button is sensitive to the database selected in the data source window,
    so if you have more than one data source, you can open a query source to any of
    them by selecting them in the data source window and then hitting the **QL** button.
    I actually closed the console that was automatically launched when I created the
    data source. To create a new console, I’ll hit the **QL** button and select **New
    Console**.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**QL**按钮对数据源窗口中选择的数据库敏感，所以如果你有多个数据源，你可以通过在数据源窗口中选择它们并点击**QL**按钮来为任何一个打开查询源。实际上，我在创建数据源时自动启动的控制台已经关闭了。要创建一个新的控制台，我会点击**QL**按钮并选择**新控制台**。'
- en: The first console you open becomes the **default console**. PyCharm keeps track
    of your consoles in the **Scratches and Consoles** folder, as shown in *Figure
    11**.35*.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先打开的控制台将成为**默认控制台**。PyCharm在**Scratches and Consoles**文件夹中跟踪你的控制台，如图*图11.35*所示。
- en: '![Figure 11.35: PyCharm tracks consoles along with scratch files in a dedicated
    folder in the IDE](img/B19644_11_35.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图11.35：PyCharm在IDE中一个专门的文件夹中跟踪控制台和临时文件](img/B19644_11_35.jpg)'
- en: 'Figure 11.35: PyCharm tracks consoles along with scratch files in a dedicated
    folder in the IDE'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.35：PyCharm在IDE中一个专门的文件夹中跟踪控制台和临时文件
- en: If you’ve typed any SQL in the console, PyCharm will keep the contents even
    between sessions. Empty consoles will disappear when you exit PyCharm. This is
    handy for keeping track of your ad hoc work.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在控制台中输入了任何 SQL，PyCharm 将在会话之间保持内容不变。当你退出 PyCharm 时，空的控制台将消失。这对于跟踪你的临时工作非常有用。
- en: Generating SQL statements
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成 SQL 语句
- en: We need to create some seed records, which will ultimately be saved as a seed
    script. A seed script is a script that can be used for testing an application
    by seeding the database with some initial test data. We’re moving away from the
    strictly DDL statements we’ve used so far. We’re going to be using more DML, which
    are the statements used to work with data rather than database structure. Seed
    scripts are also useful for filling in data tables with static data that rarely
    changes.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一些种子记录，这些记录最终将被保存为一个种子脚本。种子脚本是一个可以用来通过在数据库中填充一些初始测试数据来测试应用程序的脚本。我们正在远离我们迄今为止使用的严格
    DDL 语句。我们将使用更多的 DML，这些是用于处理数据而不是数据库结构的语句。种子脚本对于填充很少改变的数据表中的静态数据也非常有用。
- en: We’re going to seed our `authors` table with a few records, but we’re going
    to have PyCharm generate a lot of the SQL for us. Begin by creating a console
    if you don’t have one open already. Right-click the `authors` table, hover over
    **SQL Scripts**, then find **Insert rows into a table**. Check out *Figure 11**.36*
    to see it in action.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 PyCharm 为我们的 `authors` 表生成一些记录，但我们将让 PyCharm 为我们生成大量的 SQL。如果你还没有打开控制台，请先创建一个。右键单击
    `authors` 表，将鼠标悬停在 **SQL 脚本** 上，然后找到 **向表中插入行**。查看 *图 11.36* 以了解其操作。
- en: s
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: s
- en: '![Figure 11.36: PyCharm will generate DML queries for you automatically!](img/B19644_11_36.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.36：PyCharm 将会自动为您生成 DML 查询！](img/B19644_11_36.jpg)'
- en: 'Figure 11.36: PyCharm will generate DML queries for you automatically!'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.36：PyCharm 将会自动为您生成 DML 查询！
- en: Once you click the option, you’ll find an `insert` statement has been inserted
    (oh yes!) directly into the console. You can see mine in *Figure 11**.37*.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你点击了选项，你就会发现一个 `insert` 语句已经被直接插入到控制台（哦，是的！）中。你可以在 *图 11.37* 中看到我的示例。
- en: '![Figure 11.37: PyCharm generated an insert statement for the table we selected](img/B19644_11_037.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.37：PyCharm 为我们选定的表生成了一个 insert 语句](img/B19644_11_037.jpg)'
- en: 'Figure 11.37: PyCharm generated an insert statement for the table we selected'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.37：PyCharm 为我们选定的表生成了一个 insert 语句
- en: Note the bounding box around the text. We’ve seen this before. You’re looking
    at a template! This means we can tab from place to place in the templated text,
    which is why you shouldn’t mess with the text as I did.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 注意文本周围的边界框。我们之前见过这个。你正在看一个模板！这意味着我们可以从模板文本的一个地方跳到另一个地方，这就是为什么你不应该像我一样乱动文本。
- en: Copy-paste warning!
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 复制粘贴警告！
- en: If you have an electronic copy of this book that allows you to copy and paste
    from the e-book itself, be careful with any code that relies on single quotation
    marks as the upcoming SQL statement does. The process of editing the book often
    turns them into special characters that won’t work when you paste them into a
    console. Make sure the single quotation marks are really single quotation marks!
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有这本书的电子版，允许你从电子书本身复制粘贴，请注意任何依赖于单引号的代码。编辑书籍的过程常常将它们转换为特殊字符，这些字符在粘贴到控制台时将无法正常工作。请确保单引号确实是单引号！
- en: '`insert` statements can be divided into two halves:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert` 语句可以分为两部分：'
- en: '[PRE10]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The halves I’m talking about are the parts of the statement that aren’t boilerplate
    – the parts in the two sets of parentheses. The first set specifies which fields
    you’ll be filling, and the second set is the values. You have to match the order
    and type of the fields in the first half when you type values for each field.
    If you hit the *Tab* key, you’ll move between the two halves of the `insert` statement,
    allowing you to modify it as you see fit.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我所说的两部分是指语句中不是模板的部分——两对括号中的部分。第一部分指定了你将填充哪些字段，第二部分是值。当你为每个字段输入值时，你必须匹配第一部分中字段的数量和类型。如果你按下
    *Tab* 键，你将在 `insert` 语句的两部分之间移动，允许你根据需要修改它。
- en: Unconventional generated SQL
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 非常规生成的 SQL
- en: PyCharm doesn’t generate SQL keywords in all caps by default, which is the normal
    convention. You might notice that statements that I type are all caps, but generated
    ones aren’t. I had to resist the temptation to fix that for the sake of the book,
    but I also need to explain why there are inconsistencies at play.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm 默认不会将 SQL 关键字全部大写，这是常规做法。你可能注意到我输入的语句都是大写的，但生成的语句不是。我不得不抵制修改它的诱惑，为了这本书，但我也需要解释为什么存在不一致性。
- en: PyCharm generated a placeholder for the primary key, which is a field you wouldn’t
    normally populate since the database fills that in automatically. Go ahead and
    take that first field out of the field set in the first parentheses as I did in
    the preceding code.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm 为主键生成了一个占位符，这是一个你通常不会填充的字段，因为数据库会自动填充它。按照我在前面代码中所做的那样，将第一个字段从第一个括号中的字段集中移除。
- en: Next, tab over to the `values` section, and begin to fill in values. Remember,
    in SQL, `varchar (string)` values must be enclosed in single quotes. Python allows
    you to use either single or double quotes but SQL does not. As you type values,
    PyCharm will give you hints about the field you are matching for the value. It
    does this with a tooltip over the text in the editor, but it also color codes
    the current field in the top half of the statement. See *Figure 11**.38* to see
    what I mean.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，切换到 `values` 部分，并开始填写值。记住，在 SQL 中，`varchar (字符串)` 值必须用单引号括起来。Python 允许你使用单引号或双引号，但
    SQL 不允许。当你输入值时，PyCharm 会给你关于你正在匹配的字段的提示。它是通过在编辑器中的文本上显示工具提示来做的，但它也在语句的上半部分对当前字段进行着色。参见
    *图 11*.*38* 了解我的意思。
- en: '![Figure 11.38: PyCharm gives tooltips for the field and type you are currently
    filling in the second half of the query](img/B19644_11_038.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.38：PyCharm 为你在查询的第二部分中正在填写的字段和类型提供工具提示](img/B19644_11_038.jpg)'
- en: 'Figure 11.38: PyCharm gives tooltips for the field and type you are currently
    filling in the second half of the query'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.38：PyCharm 为你在查询的第二部分中正在填写的字段和类型提供工具提示
- en: This is huge! How many times have you written a long `insert` statement only
    to find that you have more values than fields? Or worse, you discover you’ve transposed
    a few fields and you enter a bunch of garbage data by mistake? PyCharm gives you
    a visual indicator to make sure you know exactly which field you’re entering by
    showing you a tooltip with the field and type you are filling in. It also shades
    the field in the top half of the SQL statement.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这太棒了！你有多少次写了一个长的 `insert` 语句，结果发现你有的值比字段多？或者更糟糕的是，你发现你颠倒了几个字段，你错误地输入了一堆垃圾数据？PyCharm
    通过显示包含字段和类型的工具提示来给你一个视觉指示，确保你知道你正在输入哪个字段。它还在 SQL 语句的上半部分对字段进行着色。
- en: Running the query
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行查询
- en: You probably don’t need me to tell you this because, at this point, you’re probably
    used to seeing green run arrows where it is appropriate to run something. You
    can run the contents of the console by clicking the green arrow at the top of
    the console’s tab in the IDE. You can also highlight a section of the console’s
    contents and run a portion of the query.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不需要我告诉你这一点，因为在这个时候，你可能已经习惯了在适当运行的地方看到绿色的运行箭头。你可以通过点击 IDE 中控制台标签页顶部的绿色箭头来运行控制台的内容。你也可以突出显示控制台内容的一部分，并运行查询的一部分。
- en: 'Change the contents of your console to match this code:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的控制台内容更改为与此代码匹配：
- en: '[PRE11]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: All I did was copy the same SQL four times, then I changed the names for a little
    variety, and to give a shout-out to my Packt crew (holla!). Next, highlight the
    first statement and run the query. The **Services** panel will open to show the
    results of the query. As you can see in *Figure 11**.39*, only one record was
    inserted.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我所做的只是将相同的 SQL 重复四次，然后我更改了名称以增加一些变化，并向我的 Packt 团队致敬（嗨！）。接下来，突出显示第一个语句并运行查询。**服务**面板将打开以显示查询结果。如图
    *11*.*39* 所示，只插入了一条记录。
- en: '![Figure 11.39: You can execute single statements by selecting them and clicking
    the Run button](img/B19644_11_039.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.39：你可以通过选择语句并点击运行按钮来执行单个语句](img/B19644_11_039.jpg)'
- en: 'Figure 11.39: You can execute single statements by selecting them and clicking
    the Run button'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.39：你可以通过选择语句并点击运行按钮来执行单个语句
- en: If you select the remainder and run again, you’ll find three insertions.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择剩余部分并再次运行，你会找到三个插入点。
- en: 'Now that we have some data, let’s query with a `SELECT` statement. Add this
    code to your console:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一些数据了，让我们用 `SELECT` 语句进行查询。将以下代码添加到你的控制台：
- en: '[PRE12]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: I could have generated `select`, but this query is short. I wanted to show you
    how PyCharm displays the results. Take a look at *Figure 11**.40*.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我本可以生成 `select` 语句，但这个查询很短。我想向您展示 PyCharm 如何显示结果。请看 *图 11.40*。
- en: '![Figure 11.40: By default, select statements produce a nice, tabular output](img/B19644_11_040.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.40：默认情况下，选择语句产生一个很好的表格输出](img/B19644_11_040.jpg)'
- en: 'Figure 11.40: By default, select statements produce a nice, tabular output'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.40：默认情况下，选择语句产生一个很好的表格输出
- en: This is a dense panel! You can do a lot here. By default, you see a tabular
    view of the data (**1**). You can double-click the cells and edit the data in
    place. You can also add and delete rows using this UI (**2**). After you’ve edited
    the data to your liking, you can submit your changes using the small green up
    arrow on the toolbar (**2**) in *Figure 11**.40*.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个密集的面板！您在这里可以做很多事情。默认情况下，您会看到数据的表格视图（**1**）。您可以双击单元格并就地编辑数据。您还可以使用此 UI 添加和删除行（**2**）。在您编辑完数据后，您可以使用工具栏（**2**）中的小绿色向上箭头提交您的更改
    *图 11.40*。
- en: If you’d rather change the output view from tabular to either raw text or a
    tree view (which makes more sense for querying hierarchical data), you can click
    the eyeball icon in the toolbar (**2**) in *Figure 11**.41*.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想将输出视图从表格视图更改为纯文本或树视图（这对于查询层次数据更有意义），您可以在 *图 11.41* 中的工具栏（**2**）中点击眼睛图标。
- en: Exporting query results
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导出查询结果
- en: You can export the results of your `select` statements using the export button
    *Figure 11**.41*. *Figure 11**.41* shows what this looks like.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用导出按钮导出 `select` 语句的结果 *图 11.41*。*图 11.41* 展示了其外观。
- en: '![Figure 11.41: Exporting data is easy in PyCharm](img/B19644_11_041.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.41：在 PyCharm 中导出数据非常简单](img/B19644_11_041.jpg)'
- en: 'Figure 11.41: Exporting data is easy in PyCharm'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.41：在 PyCharm 中导出数据非常简单
- en: The export format defaults to **comma-separated values** (**CSV**), which is
    a common format for tabular data exchange. PyCharm supports dozens of other useful
    formats, which you’ll find in the **Extractor** drop-down list. Change the output
    file to something you like, then click the **Export to** **file** button.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的导出格式是 **逗号分隔值**（**CSV**），这是一种常见的表格数据交换格式。PyCharm 支持数十种其他有用的格式，您将在 **提取器**
    下拉列表中找到。将输出文件更改为您喜欢的名称，然后点击 **导出到** **文件** 按钮。
- en: Working with SQL files
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 SQL 文件一起工作
- en: PyCharm supports files with a `.sql` or `.ddl` file extension. Like other recognized
    file types, you’ll get auto-completion, syntax highlighting, and so on. You can
    also run statements directly in the SQL file just like we can in the console.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm 支持具有 `.sql` 或 `.ddl` 文件扩展名的文件。与其他已识别的文件类型一样，您将获得自动完成、语法高亮等功能。您还可以直接在
    SQL 文件中运行语句，就像我们在控制台中一样。
- en: 'Let’s immortalize our console work so far as a proper script. Create a new
    file in PyCharm called `seed.sql`. Next, add this line to the top of the script
    file:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将到目前为止的控制台工作保存为一个合适的脚本。在 PyCharm 中创建一个名为 `seed.sql` 的新文件。接下来，将此行添加到脚本文件顶部：
- en: '[PRE13]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `USE` statement is MySQL-specific and ensures you have the `database_fun`
    database selected prior to executing the SQL statements. The `TRUNCATE` statement
    will delete all the records in the `authors` table and reset the auto-incrementor
    sequence on the table back to its initial value. This is useful for development
    testing since now the seed script can reset to a clean set of testing values.
    Just be careful to never run the seed script in production!
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`USE` 语句是 MySQL 特有的，确保在执行 SQL 语句之前已经选择了 `database_fun` 数据库。`TRUNCATE` 语句将删除
    `authors` 表中的所有记录，并将表上的自增序列重置为其初始值。这对于开发测试很有用，因为现在种子脚本可以重置到一组干净的测试值。只是要小心，永远不要在生产环境中运行种子脚本！'
- en: 'Next, cut and paste the contents of your console beneath the `TRUNCATE` statement.
    Note that I said cut. You want the console empty. The script should look like
    this:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将控制台的内容剪切并粘贴到 `TRUNCATE` 语句下方。注意，我说的是剪切。您想要控制台为空。脚本应该看起来像这样：
- en: '[PRE14]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Save your seed script and run it. It should execute successfully.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 保存您的种子脚本并运行它。它应该会成功执行。
- en: Summary
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: I have this terrible feeling that I haven’t covered everything. That’s because
    I didn’t. I could write a whole book just on the database features of PyCharm,
    but if I did, I might as well title it something like *Hands-On Database Programming
    with DataGrip*. Don’t forget, we’re seeing a whole other IDE crammed into the
    crevices of PyCharm much as we did with WebStorm in [*Chapter 7*](B19644_07.xhtml#_idTextAnchor172),
    *Web Development with JavaScript, HTML, and CSS*. The feature set is truly staggering
    and I didn’t cover some of the really interesting features owing to either lack
    of space in this book or because some of the really cool features are still works
    in progress.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一种可怕的感觉，觉得自己没有涵盖到所有内容。这是因为我没有。我可以写一本关于 PyCharm 数据库特性的整本书，但如果我这样做，我可能不如给它起个类似
    *使用 DataGrip 进行数据库编程实践* 的标题。别忘了，我们看到了 PyCharm 中挤满了另一个 IDE，就像我们在 [*第 7 章*](B19644_07.xhtml#_idTextAnchor172)，*使用
    JavaScript、HTML 和 CSS 进行 Web 开发* 中所做的那样。功能集真正令人印象深刻，我没有涵盖一些真正有趣的功能，要么是因为这本书的空间有限，要么是因为一些真正酷的功能仍在开发中。
- en: For example, you can set code as a data source and synchronize the code to the
    structure of the database. At present, it isn’t 100% complete, which is why I
    left it out. As a database developer, I would expect to be able to have a round-trip
    experience where changes to the code are reflected in the database and changes
    to the database are copied back to the code. I think we’re well on our way.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以将代码设置为数据源，并将代码同步到数据库的结构中。目前，它还不是 100% 完成，这就是为什么我将其排除在外。作为一名数据库开发者，我期望能够有一个往返体验，即代码的更改反映在数据库中，数据库的更改复制回代码。我认为我们已经走上了正轨。
- en: What we did cover, though, was pretty complete coverage for either full stack
    web development or a data science practitioner needing to tap multiple database
    platforms and data storage paradigms.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们所涵盖的内容对于全栈 Web 开发或需要访问多个数据库平台和数据存储范式的数据科学从业者来说是非常全面的。
- en: We started out with a little history. I like covering the history in this and
    previous chapters because I have the advantage of a long career behind me. I was
    around for most of what I’m describing, and I had a front-row seat. I was in the
    first grade when E. F. Codd formalized relational algebra. Part of me wishes I
    could brag about using his early work, but in truth, I was a bigger fan of watching
    the Saturday morning TV show *Lassie and the Rescue Rangers* in my footy pajamas
    than I was of `SELECT` statements. When I was older, I got to work on IBM mainframes,
    so I did eventually catch up.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一点历史开始。我喜欢在本章和前几章中介绍历史，因为我有丰富的职业生涯作为后盾。我见证了所描述的大部分内容，并且是第一排的观众。当我上一年级时，E.
    F. Codd 正式化了关系代数。我的一部分希望我能吹嘘使用他的早期工作，但事实上，我更热衷于穿着睡衣在周六早上观看电视节目 *拉西和救援小队*，而不是 `SELECT`
    语句。当我长大后，我开始在 IBM 主机上工作，所以我最终赶上了。
- en: Moving into more practical matters, we learned that PyCharm, using separately
    installed JDBC drivers, can connect to dozens of different database platforms.
    We learned it supports not only relational databases but NoSQL as well. After
    we learned how to open the database tools and connect our data source, we learned
    how to design a database using a host of tools that generate DDL for us.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 进入更实际的问题，我们了解到 PyCharm 可以通过单独安装的 JDBC 驱动程序连接到数十种不同的数据库平台。我们了解到它不仅支持关系数据库，还支持
    NoSQL。在我们学会了如何打开数据库工具并连接我们的数据源之后，我们学会了如何使用一系列为我们生成 DDL 的工具来设计数据库。
- en: Then we moved on to using PyCharm to generate the DML that would power our work
    once we got some data in our tables. Finally, after working in a console to create
    our initial work, we saved our SQL into a `.``sql` file.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们转向使用 PyCharm 生成 DML，一旦我们在表中获取了一些数据，它就能为我们的工作提供动力。最后，在控制台中创建我们的初步工作后，我们将
    SQL 保存到了一个 `.sql` 文件中。
- en: The positioning of this chapter in the book is very intentional. I’ve restrained
    myself from doing a lot of coding in the full stack frameworks we covered in the
    last few chapters. In real life, you would most assuredly have databases attached
    to such projects. While many developers rely on ORMs to handle the database work
    for them, it never hurts to at least be able to examine the database and its contents
    directly using a console.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书中这一章节的位置是非常有意的。我克制自己没有在上一章中涵盖的完整栈框架中进行大量编码。在现实生活中，你肯定会将这些数据库附加到这样的项目上。虽然许多开发者依赖
    ORM 来处理他们的数据库工作，但至少能够直接使用控制台检查数据库及其内容是有益的。
- en: If you’re like me, and you forgo ORMs entirely, you now have the missing piece
    to the puzzle. You can create your database code using a marvelous set of tools
    without leaving PyCharm.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像我一样，完全放弃了ORM，你现在有了拼图缺失的一块。你可以在不离开PyCharm的情况下，使用一套出色的工具来创建你的数据库代码。
- en: This chapter also offered a logical split as the next few chapters start coverage
    of PyCharm Professional’s power data science feature set. It only makes sense
    to preface that set of chapters with coverage of these most ubiquitous engines
    for data storage and retrieval.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 本章也进行了逻辑划分，因为接下来的几章开始介绍PyCharm Professional的强大数据科学功能集。在介绍这些最普遍的数据存储和检索引擎之前进行概述是有意义的。
- en: In the next chapter, we’ll be turning on *science mode*! Go pick up your lab
    coat from the dry cleaners, grab yourself a big cup of C8H10N4O2, and I’ll see
    you in the next chapter!
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开启*科学模式*！去干洗店取回你的白大褂，给自己倒一大杯C8H10N4O2（可能是指某种化学物质），我们下一章见！
- en: Further reading
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Be sure to check out the companion website for the book at [https://www.pycharm-book.com](https://www.pycharm-book.com).
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 请务必查看本书的配套网站：[https://www.pycharm-book.com](https://www.pycharm-book.com)。
- en: 'Docker Desktop installation instructions: [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/).'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Desktop安装说明：[https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/)。
- en: 'Using KeePass in PyCharm: [https://www.jetbrains.com/help/pycharm/reference-ide-settings-password-safe.html](https://www.jetbrains.com/help/pycharm/reference-ide-settings-password-safe.html).'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在PyCharm中使用KeePass：[https://www.jetbrains.com/help/pycharm/reference-ide-settings-password-safe.html](https://www.jetbrains.com/help/pycharm/reference-ide-settings-password-safe.html)。
- en: Codd, E. F. (1983). A relational model of data for large shared data banks.
    *Communications of the ACM*, *26*(1), 64-69.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Codd, E. F. (1983). 大型共享数据库的关系数据模型。*ACM通讯*, *26*(1), 64-69。
- en: Forta, B. (2013). *Sams teach yourself SQL in 10 minutes*. Pearson Education.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Forta, B. (2013). *10分钟学会SQL*. Pearson Education。
- en: 'Hernandez, M. J. (2013). *Database Design for Mere Mortals: A Hands-On Guide
    to Relational Database Design*. Pearson Education.'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hernandez, M. J. (2013). *数据库设计入门：关系型数据库设计实战指南*. Pearson Education.
- en: Pettit, T. and Cossetino, S. (2022). *The MySQL Workshop*. Packt Publishing.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pettit, T. 和 Cossetino, S. (2022). *MySQL实战*. Packt Publishing.
- en: Poulton, N. (2023). *Docker Deep Dive – 2nd Edition.* Packt Publishing.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Poulton, N. (2023). *Docker深度探索 – 第二版*. Packt Publishing。
- en: 'Viescas, J. L. and Hernandez, M. J. (2014). *SQL Queries for Mere Mortals:
    A Hands-On Guide to Data Manipulation in SQL*. Pearson Education.'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Viescas, J. L. 和 Hernandez, M. J. (2014). *SQL入门：SQL数据操作实战指南*. Pearson Education.
- en: 'Part 4: Data Science with PyCharm'
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四部分：使用PyCharm进行数据科学
- en: Similar to the previous part, this part of the book focuses on a specific application
    of Python programming, this time data analysis and data science. Readers will
    be able to use PyCharm and its features to efficiently work on their data science
    and scientific computing projects.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一部分类似，本书的这一部分专注于Python编程的特定应用，这次是数据分析与数据科学。读者将能够使用PyCharm及其功能高效地处理他们的数据科学和科学计算项目。
- en: 'This part has the following chapters:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 12*](B19644_12.xhtml#_idTextAnchor298), *Turning on Scientific Mode*'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B19644_12.xhtml#_idTextAnchor298), *开启科学模式*'
- en: '[*Chapter 13*](B19644_13.xhtml#_idTextAnchor318), *Dynamic Data Viewing with
    SciView and Jupyter*'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B19644_13.xhtml#_idTextAnchor318), *使用SciView和Jupyter动态数据查看*'
- en: '[*Chapter 14*](B19644_14.xhtml#_idTextAnchor340), *Building a Data Pipeline
    in PyCharm*'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B19644_14.xhtml#_idTextAnchor340), *在PyCharm中构建数据管道*'
