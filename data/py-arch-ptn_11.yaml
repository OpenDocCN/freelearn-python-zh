- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Microservices vs Monolith
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务与单体
- en: In this chapter, we will present and comment on two of the most common architectures
    for complex systems. Monolithic architecture creates a single block where the
    whole system is contained, and is simple to operate. Microservices architecture,
    on the other hand, divides the system into smaller microservices that talk to
    each other, aiming to allow different teams to take ownership of different elements,
    and helping big teams to work in parallel.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍并讨论复杂系统中最常见的两种架构。单体架构创建了一个单一块，其中包含整个系统，并且操作简单。另一方面，微服务架构将系统划分为相互通信的较小微服务，旨在让不同的团队能够拥有不同的元素，并帮助大型团队能够并行工作。
- en: We will discuss when to choose each one, based on its different characteristics.
    We will also go through the teamwork aspect of them, as they have different requirements
    in terms of how the work needs to be structured.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论何时选择每一种架构，基于它们不同的特性。我们还将讨论它们的团队合作方面，因为它们在如何结构化工作方面有不同的要求。
- en: Remember that the architecture is not only related to tech, but to a significant
    degree to how communication is structured! Refer to *Chapter 1*, *Introduction
    to Software Architecture*, for a further discussion of Conway's Law.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，架构不仅与技术相关，而且在很大程度上与沟通的结构有关！请参阅*第一章*，*软件架构简介*，以进一步讨论康威定律。
- en: A common pattern is to migrate from an old monolithic architecture to a microservices
    one. We will talk about the stages involved in such a change.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的模式是从旧的单体架构迁移到微服务架构。我们将讨论这种变化所涉及的阶段。
- en: We will also introduce Docker as a way of containerizing services, something
    very useful when it comes to creating microservices, but that can also be applied
    to monoliths. We will containerize the web application presented in *Chapter 5*,
    *The Twelve-Factor App Methodology*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将介绍Docker作为服务容器化的方式，这在创建微服务时非常有用，但也可以应用于单体。我们将对*第五章*，*十二要素应用方法*中展示的Web应用进行容器化。
- en: Finally, we will briefly describe how to deploy and operate multiple containers
    using an orchestration tool, and describe the most popular one these days – Kubernetes.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将简要描述如何使用编排工具部署和操作多个容器，并介绍目前最流行的一个——Kubernetes。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Monolithic architecture
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单体架构
- en: The microservices architecture
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构
- en: Which architecture to choose
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择哪种架构
- en: Moving from a monolith to microservices
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从单体架构迁移到微服务
- en: Containerizing services
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务容器化
- en: Orchestration and Kubernetes
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编排和Kubernetes
- en: Let's start by talking in more depth about monolithic architecture.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先深入谈谈单体架构。
- en: Monolithic architecture
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单体架构
- en: When a system is designed organically, the tendency is to generate a single
    unitary block of software that contains the whole functionality of the system.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个系统自然设计时，倾向于生成一个包含整个系统功能的单一单元软件块。
- en: This is a logical progression. When a software system is designed, it starts
    small, typically with a simple functionality. But, as the software is used, it
    grows in terms of its usage and starts getting requests for new functionality
    to complement the existing ones. Unless there are sufficient resources and planning
    to structure the growth, the path of least resistance will be to keep adding everything
    into the same code structure, with little modularity.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个逻辑上的发展过程。当设计一个软件系统时，它通常从简单开始，通常具有简单的功能。但是，随着软件的使用，它在使用方面开始增长，并开始收到对新功能的需求，以补充现有功能。除非有足够的资源和规划来结构化增长，否则最简单的路径就是将所有内容都添加到相同的代码结构中，几乎没有模块化。
- en: '![Diagram'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图](img/B17580_09_01.png)'
- en: Description automatically generated with low confidence](img/B17580_09_01.png)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 描述自动生成，置信度低](img/B17580_09_01.png)
- en: 'Figure 9.1: A monolithic application'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：单体应用
- en: This process ensures that all the code and functionality are tied together in
    a single block, hence the name *monolithic architecture*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程确保所有代码和功能都绑定在一个单一块中，因此得名*单体架构*。
- en: And, by extension, software that follows this pattern is called a monolith.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，通过扩展，遵循这种模式的软件被称为单体。
- en: Although this kind of structure is quite common, in general, monolithic structures
    have a better modularity and internal structure. Even if the software is composed
    of a single block, it can be divided logically into different parts, assigning
    different responsibilities to different modules.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种结构相当常见，但一般来说，单体结构具有更好的模块化和内部结构。即使软件由单个块组成，也可以逻辑上将其划分为不同的部分，将不同的责任分配给不同的模块。
- en: For example, in previous chapters we discussed the MVC architecture. This is
    a monolithic architecture. The Models, Views, and Controllers are all under the
    same process, but there is a definitive structure in place that differentiates
    the responsibilities and functions.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在之前的章节中，我们讨论了MVC架构。这是一个单体架构。模型、视图和控制器都在同一个进程中，但有一个明确的结构来区分责任和功能。
- en: Monolithic architecture is not synonymous with a lack of structure.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 单体架构不等于缺乏结构。
- en: The defining characteristic of a monolith is that all the calls between modules
    are through *internal* APIs, within the same process. This affords the advantage
    of being very flexible. The strategy for deploying a new version of the monolith
    is also easy. Restarting the process will ensure full deployment.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 单体的定义特征是模块之间的所有调用都是通过*内部*API进行的，在同一个进程中。这提供了非常灵活的优势。部署单体新版本的策略也很简单。重启进程将确保完全部署。
- en: Keep in mind that a monolithic application can have multiple copies running.
    For example, a monolithic web application can have multiple copies of the same
    software running in parallel, with a load balancer sending requests to all of
    them. A restart, in this case, will be in multiple stages.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，一个单体应用可以运行多个副本。例如，一个单体Web应用可以在并行运行多个相同的软件副本，负载均衡器将请求发送给所有这些副本。在这种情况下，重启将分为多个阶段。
- en: The version of the monolith is easy to know, as all the code is part of the
    same structure. The code, if it's under source control, will all be under the
    same repo.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 单体的版本容易识别，因为所有代码都是同一结构的一部分。如果代码在源代码控制下，所有代码都将位于同一仓库中。
- en: The microservices architecture
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务架构
- en: The microservices architecture was developed as an alternative to having a single
    block containing all the code.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构是作为拥有包含所有代码的单个块的替代方案而开发的。
- en: 'A system following a microservices architecture is *a collection of loosely
    coupled specialized services that work in unison to provide a comprehensive service*.
    Let''s divide the definition up in order to be clearer:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 采用微服务架构的系统是*一组松散耦合的专业服务，它们协同工作以提供全面的服务*。让我们将定义分解以使其更清晰：
- en: A **collection of specialized services**, meaning that there are different and
    well-defined modules
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**一组专业服务**，意味着存在不同且定义明确的模块'
- en: '**Loosely coupled**, so each microservice can be independently deployed and
    developed'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**松散耦合**，因此每个微服务都可以独立部署和开发'
- en: That **work in unison**. Each microservice needs to communicate with others
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**协同工作**。每个微服务都需要与其他服务进行通信'
- en: To **provide a comprehensive service**, meaning that the whole system creates
    a full system that has a clear motive and functionality
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**提供全面服务**，意味着整个系统创建了一个具有明确动机和功能的全系统'
- en: Compared with a monolith, instead of grouping the whole software under the same
    process, it uses multiple, separate functional parts (each microservice) that
    communicate through well-defined APIs. These elements can be in different processes
    and typically are moved out from different servers to allow proper scaling of
    the system.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 与单体相比，它不是将整个软件放在同一个进程中，而是使用多个独立的、功能性的部分（每个微服务），这些部分通过定义良好的API进行通信。这些元素可以位于不同的进程中，通常被移动到不同的服务器上，以允许系统的适当扩展。
- en: '![Diagram'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图解'
- en: Description automatically generated](img/B17580_09_02.png)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_09_02.png)
- en: 'Figure 9.2: Note that not all microservices will be connected to the storage.
    Each microservice may have its own individual storage'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：请注意，并非所有微服务都将连接到存储。每个微服务可能都有自己的独立存储
- en: The defining characteristic is that the calls between different services are
    all through *external* APIs. These APIs act as a clear, defined barrier between
    functionalities. Because of this, microservices architecture requires advanced
    planning and needs to define clearly the differences between components.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 定义特征是不同服务之间的调用都是通过*外部*API进行的。这些API充当功能之间的清晰、定义明确的障碍。正因为如此，微服务架构需要高级规划，并需要明确定义组件之间的差异。
- en: In particular, microservices architecture requires a good upfront design to
    be sure that the different elements connect together correctly, as any problem
    that is cross-service will be costly to work with.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是微服务架构需要良好的前期设计，以确保不同的元素能够正确连接，因为任何跨服务的都会在处理上非常昂贵。
- en: A system that follows the microservices architecture doesn't happen organically,
    but it's the result of a plan created beforehand and executed carefully. This
    architecture is not typically started for systems from scratch, but instead, they
    are migrated from a previously existing, successful, monolithic architecture.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循微服务架构的系统不是自然形成的，而是事先制定并精心执行的计划的结果。这种架构通常不是从零开始构建系统，而是从先前存在的、成功的单体架构迁移而来。
- en: Which architecture to choose
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择哪种架构
- en: There's a tendency to think that a more evolved architecture, like the microservices
    architecture, is better, but that's an oversimplification. Each one has its own
    set of strengths and weaknesses.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种趋势认为，更先进的架构，如微服务架构，更好，但这是一种过度简化。每个架构都有自己的优点和缺点。
- en: The first one is the fact that almost every small application will start as
    a monolithic application. This is because it is the most natural way to start
    a system. Everything is at hand, the number of modules is reduced, and it's an
    easy starting point.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，几乎每个小型应用程序都会从一个单体应用程序开始。这是因为这是启动系统的最自然方式。所有东西都在手边，模块数量减少，并且是一个容易的起点。
- en: Microservices, on the other hand, require the creation of a plan to divide the
    functionality carefully into different modules. This task may be complicated,
    as some designs may prove inadequate later on.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，微服务架构需要制定一个计划，将功能仔细地划分为不同的模块。这项任务可能很复杂，因为某些设计可能在以后可能证明是不充分的。
- en: Keep in mind that no design can be totally future-proof. Any perfectly valid
    architectural decision may prove incorrect a year or two later when changes in
    the system require adjustments. While it is a good question to think about the
    future, trying to cover every possibility is futile. The proper balance between
    designing for the current feature and designing for the future vision of the system
    is a constant challenge in software architecture.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，没有任何设计可以完全适应未来。任何完美的架构决策可能在一年或两年后，当系统变化需要调整时，可能证明是错误的。虽然考虑未来是一个好问题，但试图涵盖每一个可能性是徒劳的。在为当前功能设计和为系统的未来愿景设计之间找到适当的平衡，是软件架构中一个持续的挑战。
- en: This requires quite a lot of work to be done beforehand, which requires an investment
    in the microservices architecture.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要事先做大量的工作，这需要对微服务架构进行投资。
- en: That said, as monoliths grow, they can start presenting problems just through
    the sheer size of the code. The main characteristic of a monolithic architecture
    is that all the code is found together, and it can start presenting a lot of connections
    that can cause developers to be confused. Complexity can be reduced by good practices
    and constant vigilance to ensure good internal structure, but that requires a
    lot of work in place by existing developers to enforce it. When dealing with a
    big and complex system, it may be easier to present clear and strict boundaries
    just by dividing different areas into different processes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，随着单体应用程序的增长，它们可能会仅仅因为代码的规模而开始出现问题。单体架构的主要特征是所有代码都集中在一起，它可能会开始展示出许多可能导致开发者困惑的连接。通过良好的实践和持续的警惕来确保良好的内部结构可以减少复杂性，但这需要现有开发者投入大量工作来执行。当处理一个大而复杂的系统时，通过将不同的区域划分为不同的进程，可能更容易呈现清晰和严格的边界。
- en: The modules can also require different specific knowledge, making it natural
    to assign different team members to different areas. To create a proper sense
    of ownership of the modules, they can have different opinions in terms of code
    standards, an adequate programming language for the job, ways of performing tasks,
    and so on; for example, a photosystem that has an interface for uploading photos
    and an AI system for categorizing them. While the first module will work as a
    web service, the abilities required for training and handling an AI model to categorize
    the data will be very different, making the module separation natural and productive.
    Both of them in the same code base may generate problems by trying to work at
    the same time.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 模块也可能需要不同的特定知识，这使得将不同的团队成员分配到不同的领域变得自然。为了在模块中建立适当的所有权感，它们可以在代码标准、适合工作的适当编程语言、执行任务的方式等方面有不同的观点；例如，一个具有上传照片界面的光合作用系统和用于分类的AI系统。虽然第一个模块将作为一个网络服务运行，但训练和处理用于分类数据的AI模型所需的能力将非常不同，这使得模块分离既自然又高效。如果它们在同一个代码库中同时工作，可能会产生问题。
- en: Another problem of monolithic applications is the inefficient utilization of
    resources, as each deployment of the monolith carries over every copy of every
    module. For example, the RAM required will be determined for the worst-case scenario
    across multiple modules. When there are multiple copies of the monolith, that
    will waste a lot of RAM preparing for worst-case scenarios that will likely be
    rare. Another example is the fact that, if any module requires a connection to
    the database, a new connection will be created, whether that's used or not.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用的另一个问题是资源利用效率低下，因为单体应用的每次部署都会携带每个模块的每个副本。例如，所需的RAM将根据多个模块的最坏情况场景来确定。当存在多个单体副本时，这将浪费大量RAM来准备可能很少发生的最坏情况。另一个例子是，如果任何模块需要与数据库建立连接，无论是否使用，都会创建一个新的连接。
- en: In comparison, using microservices can adjust each service according to its
    own worst-case use case, and independently control the number of replicas for
    each. When viewed as a whole, that can lead to big resource saves in big deployments.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，使用微服务可以根据每个服务的最坏情况使用情况进行调整，并独立控制每个服务的副本数量。从整体来看，这在大规模部署中可能导致巨大的资源节省。
- en: '![Shape'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![形状'
- en: Description automatically generated](img/B17580_09_03.png)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_09_03.png)
- en: 'Figure 9.3: Notice that using different microservices allows us to reduce RAM
    usage by dividing requests into different microservices, while in a monolithic
    application, the worst-case scenario drives RAM utilization'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：请注意，使用不同的微服务可以将请求分割到不同的微服务中，从而减少RAM的使用，而在单体应用中，最坏情况场景驱动了RAM的利用率
- en: Deployments also work very differently between monoliths and microservices.
    As the monolithic application needs to be deployed in a single go, every deployment
    is, effectively, a task for the whole team. If the team is small, creating a new
    deployment and ensuring that the new features are properly coordinated between
    modules and not interfering incorrectly is not very complicated. However, as the
    teams grow bigger, this can present a serious challenge if the code is not strictly
    structured. In particular, a bug in a small part of the system may bring down
    the whole system completely, as any critical error in the monolith affects the
    whole of the code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 单体和微服务的部署方式也非常不同。由于单体应用需要一次性部署，因此每次部署实际上都是整个团队的任务。如果团队规模较小，创建新的部署并确保新功能在模块之间得到适当协调且不会产生错误，并不复杂。然而，随着团队规模的扩大，如果代码没有严格的结构，这可能会带来严重的挑战。特别是，系统小部分的一个错误可能会完全使整个系统崩溃，因为单体中的任何关键错误都会影响整个代码。
- en: Monolith deployments require coordination between modules, meaning that they
    need to work with each other, which normally leads to teams working closely together
    until the feature is ready to be released, and require some sort of supervision
    until the deployment is ready. This is noticeable when several teams are working
    on the same code base, with competing goals, and this blurs the ownership and
    responsibility of deployments.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用的部署需要在模块之间进行协调，这意味着它们需要相互协作，这通常导致团队在功能准备发布之前紧密合作，并在部署准备就绪之前需要某种形式的监督。当几个团队在同一个代码库上工作，有竞争目标时，这会模糊部署的所有权和责任。
- en: By comparison, different microservices are deployed independently. The API should
    be stable and backward compatible with older releases, and that's one of the strong
    requisites that need to be enforced. However, the boundaries are very clear, and
    in the event of a critical bug, the worst that can happen is that the particular
    microservice goes down, while other unrelated microservices continue unaffected.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，不同的微服务是独立部署的。API应该是稳定的，并且与旧版本向后兼容，这是需要强制执行的一个强烈要求。然而，边界非常清晰，在发生关键错误的情况下，最坏的情况是特定的微服务会崩溃，而其他无关的微服务则继续不受影响。
- en: This makes the system work in a "degraded state," as compared to the "all-or-none"
    approach of the monolith. It limits the scope of a catastrophic failure.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得系统工作在“降级状态”，与单体的“全有或全无”方法相比。它限制了灾难性故障的范围。
- en: Of course, certain microservices may be more critical than others, making them
    worthy of extra attention and care regarding their stability. But, in that case,
    they can be defined as critical in advance, with stricter stability rules enforced.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，某些微服务可能比其他微服务更为关键，因此它们值得额外的关注和照顾以确保其稳定性。但是，在这种情况下，它们可以预先定义为关键，并实施更严格的稳定性规则。
- en: Of course, in both cases, solid testing techniques can be used to increase the
    quality of the software released.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在这两种情况下，都可以使用坚实的测试技术来提高发布软件的质量。
- en: In comparison with the monolith, microservices can be deployed independently,
    without coordinating closely with other services. This brings independence to
    the teams working on them and allows for faster, continuous deployments that require
    less central coordination.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与单体相比，微服务可以独立部署，无需与其他服务紧密协调。这为从事这些工作的团队带来了独立性，并允许进行更快、更连续的部署，需要较少的中心协调。
- en: The keyword here is *less* coordination. Coordination is still required, but
    the objective of a microservices architecture is necessarily that each microservice
    can be independently deployed and owned by a team, so the majority of changes
    can be dictated exclusively by the owner without requiring a process of warning
    other teams.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键词是*减少*协调。协调仍然是必要的，但微服务架构的目标必然是每个微服务可以独立部署并由一个团队拥有，因此大多数变更可以完全由所有者决定，而不需要通知其他团队的过程。
- en: Monolithic applications, because they communicate with other modules through
    internal operations, mean that they typically can perform these operations much
    faster than through the external APIs. This allows a very high level of interaction
    between modules without paying a significant performance price.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用，因为它们通过内部操作与其他模块通信，通常可以比通过外部API更快地执行这些操作。这允许模块之间有非常高的交互水平，而不需要付出显著的性能代价。
- en: There is an overhead related to the usage of external APIs and communication
    through a network that can produce a noticeable delay, especially if there are
    too many internal requests made to different microservices. Careful consideration
    is required to try to avoid repeating external calls and to limit the number of
    services that can be contacted in a single task.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用外部API和通过网络进行通信会产生一些开销，这可能导致明显的延迟，尤其是在向不同的微服务发出过多内部请求时。需要仔细考虑以尝试避免重复外部调用并限制在单个任务中可以联系的服务数量。
- en: In some cases, the usage of tools to abstract the contact with other microservices
    may produce extra calls that will be absolutely necessary. For example, a task
    to process a document needs to obtain some user information, which requires calling
    a different microservice. The name is required at the start of the document, and
    the email at the end of it. A naïve implementation may produce two requests to
    obtain the information instead of requesting it all in a single go.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，使用工具来抽象与其他微服务的接触可能会产生额外的调用，这些调用将是绝对必要的。例如，处理文档的任务需要获取一些用户信息，这需要调用不同的微服务。文档的开始需要名字，而结束需要电子邮件。一个简单的实现可能会产生两个请求来获取信息，而不是一次性请求所有信息。
- en: Another interesting advantage of microservices is the independence of technical
    requirements. In a monolithic application, problems may arise as a result of requiring
    different versions of libraries for different modules. For example, updating the
    version of Python requires the whole code base to be prepared for that. These
    library updates can be complicated as different modules may have different requirements,
    and one module can effectively mingle with another by requiring an upgrade of
    the version of a certain library that's used by both.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的另一个有趣的优势是技术要求的独立性。在单体应用程序中，由于需要不同模块的不同版本库，可能会出现问题。例如，更新Python版本需要整个代码库都为此做好准备。这些库更新可能很复杂，因为不同的模块可能有不同的要求，一个模块可以通过要求升级两个模块都使用的某个库的版本，实际上与另一个模块混合。
- en: Microservices, on the other hand, contain their own set of technical requirements,
    so there's not this limitation. Because of the external APIs used, different microservices
    can even be programmed in different programming languages. This allows the use
    of specialized tools for different microservices, tailoring each one for each
    purpose and thereby avoiding conflicts.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，微服务有其自身的技术要求，因此不存在这种限制。由于使用了外部API，不同的微服务甚至可以用不同的编程语言编写。这允许为不同的微服务使用专门的工具，针对每个目的进行定制，从而避免冲突。
- en: Just because different microservices can be programmed in different languages
    doesn't mean that they should. Avoid the temptation of using too many programming
    languages in a microservices architecture as this will complicate maintenance
    and make it difficult for a member of a different team to be able to help, thereby
    creating more isolated teams.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不同的微服务可以用不同的语言编程，但这并不意味着它们应该这样做。避免在微服务架构中使用过多的编程语言，因为这会使维护复杂化，并使得不同团队的一员难以提供帮助，从而形成更多孤立的团队。
- en: Having one or two default languages and frameworks available and then allowing
    special justified cases is a sensible way to proceed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 提供一到两种默认的语言和框架，然后允许特殊合理的案例是一个合理的做法。
- en: As we see, most of the characteristics of microservices make it more suited
    for a bigger operation, when the number of developers is high enough that they
    need to be split into different teams and coordination needs to be more explicit.
    The high change of pace in a big application also requires better ways to deploy
    and work independently, in general.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，微服务的大多数特性使其更适合大型操作，当开发者的数量足够高，以至于需要分成不同的团队，并且需要更明确的协调时。大型应用程序的高变化速度也要求有更好的部署和工作独立性的方法，通常来说。
- en: A small team can self-coordinate very well and will be able to work quickly
    and efficiently in a monolith.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小团队能够很好地自我协调，并且能够在单体中快速高效地工作。
- en: This is not to say that a monolith can be very big. Some are. But, in a general
    sense, microservices architecture only makes sense if there are enough developers
    such that different teams are working in the same system and are required to achieve
    a good level of independence between them.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说单体可以非常大。有些确实很大。但在一般意义上，只有当有足够的开发者，使得不同的团队在同一个系统中工作，并且需要在他们之间达到良好的独立性时，微服务架构才有意义。
- en: A side note about similar designs
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于类似设计的旁白
- en: While the decision of monolith versus microservices is normally discussed in
    the context of web services, it's not exactly a new idea and it's not the only
    environment where there are similar ideas and structures.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单体与微服务的决策通常是在讨论网络服务时提出的，但这并不是一个新想法，也不是唯一存在类似想法和结构的环境。
- en: The kernel of an OS can also be monolithic. In this case, a kernel structure
    is called monolithic if it all operates within kernel space. A program running
    in kernel space in a computer can access the whole memory and hardware directly,
    something that is critical for the usage of an OS, while at the same time, this
    is dangerous as it has big security and safety implications. Because the code
    in kernel space works so closely with the hardware, any failure here can result
    in the total failure of the system (a kernel panic). The alternative is to run
    in user space, which is the area where a program only has access to its own data,
    and has to interact explicitly with the OS to retrieve information.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统的内核也可以是单体的。在这种情况下，如果一个内核结构在其所有操作都在内核空间内进行，那么它被称为单体结构。在计算机中运行的程序如果在内核空间运行，可以直接访问整个内存和硬件，这对于操作系统的使用至关重要，同时这也非常危险，因为它具有很大的安全和安全影响。由于内核空间中的代码与硬件紧密工作，任何故障都可能导致系统完全崩溃（内核恐慌）。另一种选择是在用户空间运行，这是程序只能访问其自己的数据，并且必须明确与操作系统交互以检索信息的区域。
- en: For example, a program in user space that wants to read from a file needs to
    make a call to the OS, and the OS, in kernel space, will access the file, retrieve
    the information, and return it to the requested program, copying to a part of
    the memory where the program can access.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个想要从文件中读取的用户空间程序需要调用操作系统，操作系统在内核空间中会访问文件，检索信息，并将其返回给请求的程序，将其复制到程序可以访问的内存部分。
- en: The idea of the monolithic kernel is that it can minimize this movement and
    context switch between different kernel elements, such as libraries or hardware
    drivers.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 单体内核的想法是它可以最小化不同内核元素（如库或硬件驱动程序）之间的移动和上下文切换。
- en: The alternative to a monolithic kernel is called a microkernel. In a microkernel
    structure, the kernel part is greatly reduced and elements such as filesystems,
    hardware drivers, and network stacks are executed in user space instead of in
    kernel space. This requires these elements to communicate by passing messages
    through the microkernel, which is less efficient.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 单体内核的替代品被称为微内核。在微内核结构中，内核部分大大减少，文件系统、硬件驱动程序和网络堆栈等元素在用户空间而不是内核空间中执行。这要求这些元素通过通过微内核传递消息来进行通信，这效率较低。
- en: At the same time, it can improve the modularity and security of the elements,
    as any crash in user space can be restarted easily.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，它还可以提高元素的模块化和安全性，因为任何用户空间中的崩溃都可以轻松重启。
- en: There was a famous argument between Andrew S. Tanenbaum and Linus Torvalds about
    what architecture is better, given that Linux was created as a monolithic kernel.
    In the long run, kernels have evolved toward hybrid models, where they take aspects
    of both elements, incorporating microkernel ideas into existing monolithic kernels
    for flexibility.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 安德鲁·S·坦能鲍姆和林纳斯·托瓦兹之间就Linux被创建为单体内核时哪种架构更好进行了著名的争论。从长远来看，内核已经演变为混合模型，其中它们结合了两个元素的特点，将微内核思想融入现有的单体内核中以提高灵活性。
- en: Discovering and analyzing related architectural ideas can help to improve the
    tools at the disposal of a good architect and improve architectural understanding
    and knowledge.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 发现和分析相关的架构思想可以帮助提高优秀架构师可用的工具，并提高对架构的理解和知识。
- en: The key factor – team communication
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关键因素——团队沟通
- en: A key element of the difference between microservices and monolithic architecture
    is the difference in the communication structure that they support.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务和单体架构之间的一个关键区别是它们支持的通信结构的不同。
- en: If the monolithic application has grown organically from a small project, as
    usually happens, the internal structure can become messy, and requires developers
    with experience in the system who can change and adapt it for any change. In bad
    cases, the code can become very chaotic and be more and more complicated to work
    with.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果单体应用是从一个小型项目有机地成长起来的，这通常会发生，其内部结构可能会变得混乱，需要具有系统经验的开发者来对其进行更改和适应以应对任何变化。在糟糕的情况下，代码可能会变得非常混乱，并且越来越难以工作。
- en: Increasing the size of the development team becomes complicated, as each engineer
    requires a lot of contextual information, and learning how to navigate the code
    is difficult. The older teammates who have been around can help to train new team
    members, but they'll act as bottlenecks, and mentoring is a slow process that
    has limits. Each new member of the team will require a significant amount of training
    time until they can be productive in fixing bugs and adding new features.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 随着开发团队规模的增加变得复杂，因为每个工程师都需要大量的上下文信息，学习如何导航代码是困难的。那些经验丰富的老队员可以帮助培训新队员，但他们将成为瓶颈，而指导是一个缓慢的过程，有其局限性。每个新队员都需要大量的培训时间，直到他们能够有效地修复错误和添加新功能。
- en: Teams also have a maximum natural size limit. Managing a team with too many
    members, without dividing it into smaller groups, is difficult.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 团队也有一个最大自然规模限制。管理一个成员过多的团队，而不将其划分为更小的组，是困难的。
- en: The ideal size of a team depends on a lot of different factors, but between
    5 and 9 is generally considered the ideal size to work efficiently.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 团队的理想规模取决于许多不同的因素，但通常认为5到9人是在有效工作时的理想规模。
- en: Teams that are bigger than that tend to self-organize into their own smaller
    groups, losing focus as a unit and creating small information silos where parts
    of the team are not aware of what's going on.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 大于这个规模的团队往往会自发组织成自己的小团队，作为一个整体失去焦点，并形成小的信息孤岛，其中团队的一部分人并不知道正在发生什么。
- en: Teams with fewer members create too much overhead in terms of management and
    communication with other teams. They will be able to work faster with a slightly
    bigger size.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 成员较少的团队在管理和与其他团队沟通方面会产生过多的开销。它们在稍微大一点规模的情况下将能够更快地工作。
- en: If the growing size of the code requires it, this is the time to employ all
    the techniques that we are describing in this book to generate more structure,
    architecting the system. This will involve defining modules with clear responsibilities
    and clear boundaries. This division allows the team to be divided into groups
    and allows them to work at creating ownership and explicit goals for each team.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码的增长规模需要，这就是应用我们在本书中描述的所有技术来生成更多结构、构建系统架构的时候。这将涉及定义具有明确责任和边界的模块。这种划分允许团队划分为小组，并允许他们为每个团队创建所有权和明确的目标。
- en: This allows the teams to work in parallel without too much interference, so
    the extra members can increase the throughput in terms of features. As we commented
    before, clear boundaries will help in defining the work for each team.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得团队可以在没有太多干扰的情况下并行工作，因此额外的成员可以增加在功能方面的吞吐量。正如我们之前所评论的，清晰的边界有助于为每个团队定义工作内容。
- en: In a monolith, however, these limitations are *soft*, as the whole system is
    accessible. Sure, there is a certain discipline in terms of focusing on certain
    areas, and the tendency will be that one team will be able to access everything,
    and will tweak and bend internal APIs.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在单体架构中，这些限制是“软”的，因为整个系统都是可访问的。当然，在专注于某些领域方面有一定的纪律性，趋势是某个团队将能够访问一切，并调整和弯曲内部API。
- en: This characteristic is not necessarily a bad thing, especially on a smaller
    scale. This way of working with a small, focused team can produce fantastic results,
    as they'll be able to adjust quickly all the related parts of the software. The
    drawback is that the members of the team need to be highly experienced and know
    their way around the software, which normally becomes more and more difficult
    over time.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这种特性并不一定是坏事，尤其是在较小规模的情况下。这种与小型、专注的团队一起工作的方式可以产生惊人的结果，因为它们将能够快速调整所有相关的软件部分。缺点是团队成员需要经验丰富，并且熟悉软件，这通常随着时间的推移变得越来越困难。
- en: 'When moving to a microservices architecture, the division of work becomes way
    more explicit. The APIs between teams become hard limitations and there is a need
    for more work upfront to communicate between teams. The trade-off is that teams
    are way more independent, as they can:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当迁移到微服务架构时，工作的划分变得更加明确。团队之间的API成为硬性限制，并且需要更多前期工作来在团队之间进行沟通。权衡的是，团队将更加独立，因为它们可以：
- en: Own the microservice completely without other teams coding in the same code
    base
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全拥有微服务，而其他团队不在同一代码库中编码
- en: Deploy independently from other teams
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立于其他团队进行部署
- en: As the code base will be smaller, new members of the team will be able to learn
    it quickly and be productive earlier. Because the external APIs to interact with
    other microservices will be explicitly defined, a higher level of abstraction
    will be applied, making it easier to interact.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代码库将更小，新加入团队的成员将能够快速学习并尽早变得高效。由于与其他微服务交互的外部API将明确定义，将应用更高层次的抽象，这使得交互更容易。
- en: Note this also means that different teams will know less about the internals
    of other microservices compared with monolithic applications when there's at least
    a superficial knowledge of it. This can create some friction when moving people
    from one team to another.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这也意味着，当至少对它有表面了解时，不同团队对其他微服务的内部了解将比单体应用少。这可能在人员从一个团队调动到另一个团队时产生一些摩擦。
- en: As we saw in the first chapter, Conway's law is something to keep in mind when
    making architectural decisions that affect communication within the organization.
    Let's remember that this software law states that the structure of the software
    will replicate the communication structure of the organization.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第一章中看到的，康威定律是在做出影响组织内部沟通的架构决策时需要牢记的东西。让我们记住，这条软件定律指出，软件的结构将复制组织的沟通结构。
- en: A good example of Conway's law is the creation of DevOps practices. The older
    way of dividing work was to have different teams, one related to developing new
    features, and another in charge of deploying and operating the software. The abilities
    required for each task are different, after all.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 康威定律的一个好例子是DevOps实践的产生。过去的工作划分方式是拥有不同的团队，一个与开发新功能相关，另一个负责部署和运营软件。毕竟，每个任务都需要不同的能力。
- en: The risk of this structure is the "I don't know what it is / I don't know where
    it runs" division, which can cause the team responsible for developing new features
    to be unaware of bugs and problems associated with operating the software, while
    the operations team finds changes with little reaction time, and identifies bugs
    without understanding the inside operation of the software.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构的风险在于“我不知道它是啥/我不知道它在哪运行”的划分，这可能导致负责开发新功能的团队对软件操作相关的错误和问题一无所知，而运维团队在反应时间很短的情况下发现变化，并识别出软件内部的错误，却未能理解软件的内部运作。
- en: This division is still in place in many organizations, but the idea behind DevOps
    is that the same team that develops the software is responsible for deploying
    it, thereby creating a virtuous feedback loop where developers are aware of the
    complexities of the deployment and can react and fix bugs in production and improve
    the operation of the software.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这种划分在许多组织中仍然存在，但DevOps背后的理念是，负责开发软件的同一团队也负责部署它，从而创建一个良性的反馈循环，其中开发者了解部署的复杂性，可以在生产中反应并修复错误，并改进软件的运行。
- en: Note that this normally involves creating a multi-functional team with people
    who both understand operations and development, though they don't necessarily
    need to be the same. Sometimes, an external team is responsible for creating a
    set of common tools for other teams to use in their operations.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这通常涉及创建一个多功能团队，其中既有理解运维也有理解开发的人，尽管他们不一定需要是同一人。有时，一个外部团队负责为其他团队创建一套通用的工具，用于他们的运维。
- en: This is a big change, and changing from the older structure to the DevOps one
    involves mixing teams in a way that can be very disruptive for the corporate culture.
    As we've tried to highlight here, this involves people changes, which are slow
    and have a significant amount of pain associated with them. For example, there
    may be a good operations culture where they share their knowledge and have fun
    together, and now they'll need to break up those teams and integrate them with
    new people.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个巨大的变化，从旧结构转变为DevOps结构涉及以可能对企业文化造成极大破坏的方式混合团队。正如我们在这里试图强调的，这涉及到人员变化，这些变化缓慢，并伴随着大量的痛苦。例如，可能有一个很好的运维文化，他们分享知识并一起享受乐趣，但现在他们需要解散这些团队并与新人整合。
- en: This kind of process is difficult and should be planned carefully, understanding
    both its human and social scale.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这种过程很困难，应该仔细规划，理解其人类和社会规模。
- en: 'Communication within the same team is different from the communication between
    different teams. Communicating with other teams is always more difficult and costlier.
    This is probably easy to say, but the implications of it for teamwork are big.
    Examples include the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 同一团队内部的沟通与不同团队之间的沟通不同。与其他团队沟通总是更困难且成本更高。这可能很容易说，但其对团队合作的含义很大。以下是一些例子：
- en: Because APIs to be used externally from the team are going to be used by other
    engineers without the same level of expertise in the internals, it makes sense
    to make them generic and easy to use, as well as creating proper documentation.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于要从团队外部使用的API将由其他工程师使用，而这些工程师对内部知识的掌握程度不同，因此使它们通用且易于使用，以及创建适当的文档是有意义的。
- en: If a new design follows the structure of already existing teams, it will be
    easier to implement than the other way around. Architectural changes that lie
    between teams require organizational changes. Changing the structure of an organization
    is a long and painful process. Anyone who has been involved in a company reorganization
    can attest to that. These organizational changes will be reflected in the software
    naturally, so ideally a plan will be generated to allow for it.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果新的设计遵循现有团队的架构，那么实施起来会比反过来更容易。存在于团队之间的架构变化需要组织上的变化。改变组织的结构是一个漫长而痛苦的过程。任何参与过公司重组的人都可以证明这一点。这些组织变化会在软件中自然反映出来，因此理想情况下，将生成一个计划以允许这种变化。
- en: Two teams working in the same service will create problems because each team
    will try to pull it to their own goals. This is a situation that can happen with
    some common libraries or with "core" microservices that are used by multiple teams.
    Try to enforce clear owners for them to be sure that a single team is in charge
    of any changes.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在同一服务中工作的两个团队将产生问题，因为每个团队都会试图将其拉向自己的目标。这种情况可能发生在一些常见的库或被多个团队使用的“核心”微服务中。尝试为它们设定清晰的负责人，以确保只有一个团队负责任何变更。
- en: Explicit owners establish clarity about who is responsible for changes and new
    features. Even if something is implemented by someone else, the owner should be
    responsible for approving it and giving direction and feedback. They should also
    be prepared to have a long-term vision and handle any technical debt.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 明确的负责人可以明确谁负责变更和新功能。即使某些东西是由其他人实施的，负责人也应负责批准它并提供方向和反馈。他们还应准备好有一个长期愿景并处理任何技术债务。
- en: Given that different physical locations and time zones naturally impose their
    own communication barrier, they normally are used to set up different teams, describing
    their own structured communication, like the API definition, between time zones.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于不同的地理位置和时区自然地设置了各自的沟通障碍，他们通常会被用来建立不同的团队，描述他们自己跨时区的结构化沟通，例如API定义。
- en: Working remotely has increased significantly as a result of the COVID-19 crisis.
    This has also created the need to structure communication differently compared
    with a team working together in the same room. This has developed and improved
    communication skills, which can lead to better ways of organizing work. In any
    case, team division is not only a matter of being physically located in the same
    place but creating the bonds and structure to work as a team.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于COVID-19危机，远程工作显著增加。这也产生了与同一房间内一起工作的团队不同的不同沟通结构的需求。这已经发展和提高了沟通技巧，这可能导致更好的工作组织方式。无论如何，团队划分不仅仅是物理上位于同一地点，而是创造团队工作的纽带和结构。
- en: Communication aspects of development are an important part of the work and should
    not be underestimated. Keep in mind that changes to them are "people changes,"
    which are more difficult to implement than tech changes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 开发中的沟通方面是工作的重要部分，不应被低估。记住，对这些方面的改变是“人员变化”，这比技术变化更难实施。
- en: Moving from a monolith to microservices
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从单体架构迁移到微服务架构
- en: A usual case is the need to migrate from an existing monolithic architecture
    to a new microservices one.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的案例是需要从现有的单体架构迁移到新的微服务架构。
- en: The main reason for wanting to implement this change is the size of the system.
    As we've discussed before, the main advantage of a microservice system is the
    creation of multiple independent parts that can be developed in parallel, enabling
    the development to be scaled and the pace increased by allowing more engineers
    to work at the same time.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 想要实施这一变化的主要原因是系统的规模。正如我们之前讨论的，微服务系统的主要优势是创建多个独立的部分，这些部分可以并行开发，通过允许更多工程师同时工作，使开发可扩展并加快速度。
- en: This is a move that makes sense if the monolith has grown to exceed a manageable
    size and there are enough problems with releases, interfering features, and stepping
    on each other's toes. But, at the same time, it's a very huge and painful transition
    to perform.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果单体已经增长到超出可管理的大小，并且存在足够的问题，如发布问题、功能冲突和相互干扰，这是一个有意义的举措。但与此同时，这也是一个非常巨大且痛苦的过渡。
- en: Challenges for the migration
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迁移的挑战
- en: 'While the final result may be much better than a monolithic application that
    shows its age, migrating to a new architecture is a big undertaking. We''ll now
    look at some of the challenges and problems that we can expect in the process:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管最终结果可能比显示其年龄的单一架构应用要好得多，但迁移到新架构是一项重大任务。现在我们将探讨在迁移过程中我们可以预期的某些挑战和问题：
- en: Migrating to microservices will require a huge amount of effort, actively changing
    the way the organization operates, and will require a big upfront investment until
    it starts to pay off. The transition time will be painful and will require compromises
    between the speed of migration and the regular operation of the service, as stopping
    the operation completely won't be an option. It will require a good deal of meetings
    and documentation to plan and communicate the migration to everyone. It needs
    to have active support at the executive level to ensure full commitment to get
    it done, with a clear understanding of why it is being done.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迁移到微服务将需要大量的努力，积极改变组织的运营方式，并且直到开始产生回报之前，需要大量的前期投资。过渡时间将会痛苦，需要在迁移速度和服务的常规运营之间做出妥协，因为完全停止运营不是一种选择。这需要大量的会议和文档来规划和传达迁移给每个人。它需要在管理层有积极的支持，以确保对完成任务的充分承诺，并清楚地了解为什么要这样做。
- en: It also requires a profound cultural change. As we've seen above, the key element
    of microservices is the interaction between teams, which will change significantly
    compared with the way of operating in a monolithic architecture. This will likely
    involve changing teams and changing tools. Teams will have to be stricter in their
    usage and documentation of external APIs.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这还要求进行深刻的文化变革。正如我们上面所看到的，微服务的关键要素是团队之间的互动，与单一架构的运营方式相比，这将发生显著变化。这可能会涉及改变团队和改变工具。团队在对外部API的使用和文档方面将更加严格。
- en: They'll need to be more formal in their interaction with other teams and probably
    take attributions they didn't have before. In general, people don't like change,
    and that could be responded to in the form of resistance by members of some teams.
    Be sure that these elements are taken into account.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 他们需要在与其他团队的互动中更加正式，并且可能需要承担之前没有的职责。一般来说，人们不喜欢改变，这可能会以某些团队成员的抵抗形式出现。确保这些因素被考虑在内。
- en: Another challenge is the training aspect. New tools will surely be used (we
    will cover Docker and Kubernetes later in this chapter), so some teams will likely
    need to adapt to use them. Managing a cluster of services can be complicated to
    wrap one's head around, and it will likely involve different tools than the ones
    used previously. For example, local developers will likely be very different.
    Learning how to operate and work with containers, if going down that route, will
    take some time. This requires planning and the need to support team members until
    they are comfortable with the new system.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个挑战是培训方面。新工具肯定会得到应用（我们将在本章后面介绍Docker和Kubernetes），因此一些团队可能需要适应使用它们。管理服务集群可能很复杂，难以理解，并且可能涉及与之前使用的不同工具。例如，本地开发者可能会有很大不同。如果选择走这条路，学习如何操作和使用容器将需要一些时间。这需要规划和支持团队成员，直到他们对新系统感到舒适。
- en: A very clear example of this is the extra complexity for debugging a request
    coming into the system, as it can be jumping around different microservices. Previously,
    this request was probably easier to track in the monolith. Understanding how a
    request moves and finding subtle bugs produced by that can be difficult. To be
    certain of fixing this, they will likely need to be replicated and fixed in local
    development, which, as we've seen, will entail the use of different tools and
    systems.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种复杂性的一个非常清晰的例子是调试进入系统的请求时增加的复杂性，因为请求可能会在不同的微服务之间跳跃。以前，这个请求在单体架构中可能更容易追踪。理解请求的移动和寻找由此产生的细微错误可能很困难。为了确保修复这个问题，他们可能需要在本地开发中复制并修复，正如我们所看到的，这将涉及使用不同的工具和系统。
- en: Dividing the existing monolith into different services requires careful planning.
    A bad division between services can make two services tightly coupled, thereby
    not allowing independent deployment. This can result in a situation where practically
    any change to one service will require a change in the other, even if, theoretically,
    this could be done independently. This creates duplication of work, as routinely
    working on a single feature requires multiple microservices to be changed and
    deployed. Microservices can be mutated later and boundaries redefined, but there's
    a high cost associated with that. The same care should be taken later when adding
    new services.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将现有的单体架构划分为不同的服务需要周密的规划。服务之间的不良划分可能会使两个服务紧密耦合，从而不允许独立部署。这可能导致一种情况，即实际上对任何一个服务的任何更改都可能导致另一个服务的更改，即使理论上可以独立完成。这会导致工作重复，因为通常需要更改和部署多个微服务才能完成单个功能的开发。微服务可以在以后进行变异和边界重新定义，但这会带来很高的成本。在添加新服务时，也应采取同样的谨慎态度。
- en: There's an overhead in creating microservices, as there is some work that gets
    replicated on each service. That overhead gets compensated for by allowing independent
    and parallel development. But, to take full advantage of that, you need numbers.
    A small development team of up to 10 people can coordinate and handle a monolith
    very efficiently. It's only when the size grows and independent teams are formed
    that migrating to microservices starts to make sense. The bigger the company,
    the more it makes sense.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建微服务会有一些开销，因为每个服务都需要重复一些工作。这种开销通过允许独立和并行开发来补偿。但是，为了充分利用这一点，你需要有足够的人数。一个由多达10人组成的小型开发团队能够非常高效地协调和处理单体架构。只有当团队规模扩大并形成独立团队时，迁移到微服务才开始有意义。公司规模越大，这样做就越有意义。
- en: A balance between allowing each team to make their own decisions and standardize
    some common elements and decisions is necessary. If teams have too little direction,
    they'll keep reinventing the wheel over and over. They'll also end up creating
    knowledge silos where the knowledge in a section of the company is wholly non-transferable
    to another team, making it difficult to learn lessons collectively. Solid communication
    between teams is required to allow consensus and the reuse of common solutions.
    Allow controlled experimentation, label it as such, and get the lessons learned
    across the board so that the other teams benefit. There will be tension between
    shared and reusable ideas and independent, multiple-implementation ideas.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在允许每个团队做出自己的决定和标准化一些共同元素和决策之间取得平衡是必要的。如果团队的方向过于模糊，他们就会不断地重复造轮子。他们还可能最终形成知识孤岛，其中公司的某个部分的知识完全无法转移到另一个团队，这使得集体学习变得困难。团队之间需要良好的沟通，以便达成共识和重用共同解决方案。允许进行受控的实验，将其标记为实验，并将所学到的经验传达给所有团队，以便其他团队也能从中受益。共享和可重用想法与独立、多实现想法之间将存在紧张关系。
- en: Be careful when introducing shared code across services. If the code grows,
    it will make services dependent on each other. This can reduce the independence
    of the microservices.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在服务之间引入共享代码时要小心。如果代码增长，它将使服务相互依赖。这可能会降低微服务的独立性。
- en: Following the Agile principles, we know that working software is more important
    than extensive documentation. However, in microservices, it's important to maximize
    the usability of each individual microservice to reduce the amount of support
    between teams. That involves some degree of documentation. The best approach is
    to create self-documenting services.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循敏捷原则，我们知道，工作软件比广泛的文档更重要。然而，在微服务中，最大化每个单独微服务的可用性以减少团队之间的支持量是很重要的。这涉及到一定程度的文档。最佳的方法是创建自文档化的服务。
- en: As we've discussed earlier, each call to a different microservice can increase
    the delay of responses, as multiple layers will have to be involved. This can
    produce latency problems, with external responses taking longer. They will also
    be affected by the performance and capacity of the internal network connecting
    the microservices.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，对每个不同微服务的调用都可能增加响应延迟，因为需要涉及多个层次。这可能导致延迟问题，外部响应时间更长。它们还会受到连接微服务的内部网络性能和容量的影响。
- en: A move to microservices should be taken with care and by carefully analyzing
    its pros and cons. It is possible that it will take years to complete the migration
    in a mature system. But for a big system, the resulting system will be much more
    agile and easy to change, allowing you to tackle technical debt effectively and
    to empower developers to take full ownership and innovate, structuring communication
    and delivering a high-quality, reliable service.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在采取微服务迁移时应该谨慎行事，并仔细分析其利弊。在成熟系统中完成迁移可能需要数年时间。但对于大型系统，结果系统将更加敏捷，易于更改，使您能够有效地解决技术债务，并赋予开发者完全的拥有权和创新能力，构建沟通并交付高质量、可靠的服务。
- en: A move in four acts
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这是一个分为四个部分的动作。
- en: 'The migration from one architecture to another should be considered in four
    steps:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个架构迁移到另一个架构应考虑分为四个步骤：
- en: '**Analyze** the existing system carefully.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**分析**现有的系统。'
- en: '**Design** to determine what the desired destination is.'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设计**以确定期望的目标是什么。'
- en: '**Plan**. Create a route to move, step by step, from the current system to
    the vision designed in the first stage.'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**计划**。创建一个路线图，逐步从当前系统移动到第一阶段设计的愿景。'
- en: '**Execute** the plan. This stage will need to be done slowly and deliberately,
    and at each step, the design and plan will need to be re-evaluated.'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**执行**计划。这一阶段需要缓慢而谨慎地进行，并且每一步都需要重新评估设计和计划。'
- en: Let's look at each of the steps in greater detail.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看每个步骤。
- en: 1\. Analyze
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1. 分析
- en: The very first step is to have a good understanding of our starting point with
    the existing monolith. This may appear trivial, but the fact is that it is quite
    conceivable that no particular person has a good understanding of all the details
    of the system. It may require information gathering, compilation, and digging
    deep to understand the intricacies of the system.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是充分理解我们现有的单体架构的起点。这看起来可能微不足道，但事实是，可能没有特定的人对系统的所有细节有很好的理解。可能需要收集信息、汇编和深入挖掘以理解系统的复杂性。
- en: The existing code can be described as *legacy code*. While a debate is currently
    taking place on exactly what code can be categorized as legacy, the main property
    of it is code that is already in place and doesn't follow the best and new practices
    that new code has.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的代码可以描述为*遗留代码*。虽然目前正在进行关于哪些代码可以归类为遗留代码的辩论，但其主要特性是已经存在的代码，它不遵循新代码的最佳和最新实践。
- en: In other words, legacy code is old code from some time ago and that is very
    likely not up to date with current practices. However, legacy code is critical,
    as it is in use and probably key for the day-to-day operations of the organization.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，遗留代码是来自很久以前的旧代码，很可能不符合当前的最佳实践。然而，遗留代码是至关重要的，因为它正在使用中，并且可能是组织日常运营的关键。
- en: The main objective of this phase should be to determine whether a change will
    actually be beneficial and get a preliminary idea of what microservices will result
    from the migration. Performing this migration is a big commitment, and it's always
    a good idea to double-check that tangible benefits will result. Even if, at this
    stage, it won't be possible to estimate the effort required, it will start shaping
    the size of the task.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 本阶段的主要目标应该是确定变更是否真正有益，并对迁移后可能产生的微服务有一个初步的了解。执行这次迁移是一项重大承诺，始终检查是否会带来实际效益是一个好主意。即使在这个阶段，可能无法估计所需的工作量，但它将开始塑造任务的规模。
- en: This analysis will benefit greatly from good metrics and actual data showing
    the number of requests and interactions that are actually being produced in the
    system. This can be achieved through good monitoring, and adding metrics and logs
    to the system to allow the current behavior to be measured. This can lead to insights
    about what parts are commonly used, and, even better, parts that are almost never
    used and can perhaps be deprecated and removed. Monitoring can continue to be
    used to ensure that the process is going according to plan.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分析将极大地受益于良好的指标和实际数据，这些数据显示了系统中实际产生的请求数量和交互。这可以通过良好的监控，以及向系统添加指标和日志来实现，以便测量当前行为。这可以揭示哪些部分被常用，甚至更好的是，几乎从未使用且可能被弃用和删除的部分。监控可以继续使用以确保过程按计划进行。
- en: We will discuss monitoring in more detail in *Chapter 11*, *Package Mangement*,
    and *Chapter 12*, *Logging*.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第11章“包管理”和第12章“日志”中更详细地讨论监控。
- en: This analysis can be almost instant if the system is already well-architected
    and properly maintained, but may extend to months of meetings and digging into
    code if the monolith is a mess of chaotic code. However, this stage will allow
    us to build on solid foundations, knowing what the current system is.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统已经很好地架构并得到妥善维护，这种分析几乎可以立即完成，但如果单体是混乱代码的集合，可能需要数月的会议和代码挖掘。然而，这一阶段将使我们能够在了解当前系统的基础上建立坚实的基础。
- en: 2\. Design
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2. 设计
- en: The next stage of the process is to generate a vision in terms of what the system
    will look like after breaking the monolith up into multiple microservices.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个阶段是生成一个愿景，即系统在将单体拆分为多个微服务后的样子。
- en: 'Each microservice needs to be considered in isolation, and as part of the rest.
    Think in terms of what makes sense to separate. Some questions that may help you
    to structure the design are as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务都需要单独考虑，并作为整体的一部分。从分离什么有意义的角度思考。以下是一些可能有助于您构建设计的疑问：
- en: What microservices should be created? Can you describe each microservice with
    a clear objective and area to control?
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该创建哪些微服务？能否用清晰的目标和控制区域描述每个微服务？
- en: Is there any critical or core microservice that requires more attention or special
    requirements? For example, higher security or performance requirements.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否有任何关键或核心微服务需要更多关注或特殊要求？例如，更高的安全或性能要求。
- en: How will the teams be structured to cover the microservices? Are there too many
    for the team to support? If that's the case, can multiple requests or areas be
    joined as part of the same microservice?
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队将如何构建以覆盖微服务？团队是否支持过多？如果是这样，是否可以将多个请求或区域作为同一微服务的一部分？
- en: What are the prerequisites of each microservice?
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个微服务的先决条件是什么？
- en: What new technologies will be introduced? Is any training required?
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将引入哪些新技术？是否需要培训？
- en: Are microservices independent? What are the dependencies between microservices?
    Is there any microservice that is accessed more than others?
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务是否独立？微服务之间的依赖关系是什么？是否有任何微服务被访问的频率高于其他微服务？
- en: Can microservices be deployed independently from each other? What's the process
    if a new change is introduced that requires a change in a dependent dependency?
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务能否相互独立部署？如果引入了需要更改依赖项的新变更，过程是怎样的？
- en: What microservices are going to be exposed externally? What microservices are
    only exposed internally?
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将要对外暴露哪些微服务？哪些微服务仅内部暴露？
- en: Is there any prerequisite in terms of required API limitations? For example,
    is there any service that requires specific APIs, such as a SOAP connection?
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在API限制方面是否有任何先决条件？例如，是否有任何服务需要特定的API，如SOAP连接？
- en: Other things that can be useful in informing the design can be to draw expected
    flow diagrams of requests that need to interact with multiple microservice, so
    as to analyze the expected movement between services.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 其他有助于告知设计的事情可以是绘制需要与多个微服务交互的预期流程图，以便分析服务之间的预期移动。
- en: Special care should be taken regarding whatever storage is decided for each
    microservice. In general, storage for one microservice should not be shared with
    another, to isolate the data.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 应对每个微服务选择的存储方式应特别小心。一般来说，一个微服务的存储不应与其他微服务共享，以隔离数据。
- en: This has a very concrete application, that is, to not access a database or other
    kind of raw storage directly by two or more microservices. Instead, one microservice
    should control the format and expose the data, and allow changes to the data by
    an accessible API.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个非常具体的应用，即不要让两个或更多微服务直接访问数据库或其他类型的原始存储。相反，一个微服务应该控制格式并公开数据，并通过可访问的API允许对数据进行更改。
- en: For example, let's imagine that there are two microservices, one that controls
    reports and another that controls users. For certain reports, we may need to access
    the user information to pull, for example, the name and email of a user who generated
    a report. We can break the microservice's responsibility by allowing the report
    service to access directly a database that contains user information.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们想象有两个微服务，一个控制报告，另一个控制用户。对于某些报告，我们可能需要访问用户信息，例如获取生成报告的用户的姓名和电子邮件。我们可以通过允许报告服务直接访问包含用户信息的数据库来分解微服务的职责。
- en: '![Diagram'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![图'
- en: Description automatically generated](img/B17580_09_04.png)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_09_04.png)
- en: 'Figure 9.4: An example of incorrect usage, accessing the information directly
    from storage'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4：不正确使用示例，直接从存储中访问信息
- en: Instead, the report service needs to access the user microservice through an
    API and pull the data. That way, each microservice is responsible for its own
    storage and format.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，报告服务需要通过API访问用户微服务并拉取数据。这样，每个微服务都负责其自己的存储和格式。
- en: '![Diagram'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '![图'
- en: Description automatically generated](img/B17580_09_05.png)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_09_05.png)
- en: 'Figure 9.5: This is the correct structure. Each microservice keeps its own
    independent storage. This way, any information is only shared through well-defined
    APIs'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5：这是正确的结构。每个微服务都保持其独立的存储。这样，任何信息都只通过定义良好的API进行共享
- en: As we commented before, creating a flow diagram of some requests will help enforce
    this separation and find possible points of improvement; for example, returning
    data from an API that is not required until later in the process.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所评论的，创建一些请求的流程图将有助于加强这种分离并找到可能的改进点；例如，返回在处理过程中稍后不需要的数据。
- en: While a prerequisite is not to mix storage, and to retain separation, you can
    use the same backend service to provide support for different microservices. The
    same database server can handle two or more logical databases that can store different
    information.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一个先决条件是不混合存储，并保持分离，但你可以使用相同的后端服务为不同的微服务提供支持。同一个数据库服务器可以处理两个或更多逻辑数据库，可以存储不同的信息。
- en: Generally, though, most microservices won't require their own data to be stored
    and can work in a completely stateless way, relying instead on other microservices
    to store the data.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一般来说，大多数微服务不需要存储自己的数据，并且可以以完全无状态的方式工作，而是依赖其他微服务来存储数据。
- en: At this stage, there's no need to design detailed APIs between microservices,
    but some general ideas on what services handle what data and what the required
    flows between microservices are would be beneficial.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，没有必要在微服务之间设计详细的API，但了解哪些服务处理哪些数据以及微服务之间所需的数据流的一般想法将是有益的。
- en: 3\. Plan
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3. 计划
- en: Once the general areas are clear, it's time to get into more detail and start
    planning how the system is going to be changed from the starting point to the
    end line.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦明确了大致区域，就到了更详细地规划如何从起点到终点改变系统的时候了。
- en: The challenge here is to iteratively move into the new system while the system
    simultaneously remains functional at all times. New features are likely being
    introduced, but let's park that for the moment and talk only about the migration
    itself.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的挑战是在系统始终保持功能的同时，迭代地迁移到新系统。新功能可能正在被引入，但让我们暂时放下这一点，只谈论迁移本身。
- en: To be able to do so, we need to use what is known as the **strangler pattern**.
    This pattern aims to gradually replace parts of the system with new ones until
    the entire previous system is "strangled" and can be removed safely. This pattern
    gets applied iteratively, slowly, migrating the functionality from the old system
    to the new one in small increments.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够做到这一点，我们需要使用所谓的**断头蛇模式**。这种模式旨在逐步用新部分替换系统的旧部分，直到整个旧系统被“勒死”并可以安全地移除。这种模式是迭代地、缓慢地、以小步骤将功能从旧系统迁移到新系统。
- en: '![Diagram'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![图'
- en: Description automatically generated](img/B17580_09_06.png)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_09_06.png)
- en: 'Figure 9.6: The strangler pattern'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6：断头蛇模式
- en: 'To create new microservices, there are three possible strategies:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新的微服务，有三种可能的方法：
- en: Replace the functionality with new code that substitutes the old code, functionally
    producing the same result. Externally, the code reacts exactly the same to external
    requests, but internally, the implementation is new. This strategy allows you
    to start from scratch and fix some of the oddities of the old code. It can even
    be done in newer tools such as frameworks or even programming languages.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用新的代码替换功能，以替代旧代码，功能上产生相同的结果。从外部来看，代码对外部请求的反应完全相同，但内部实现是新的。这种策略允许你从头开始，修复一些旧代码的奇怪之处。甚至可以在新的工具中进行，如框架或编程语言。
- en: At the same time, this approach can be very time-consuming. If the legacy system
    is undocumented and/or untested, it can be difficult to guarantee the same functionality.
    Also, if the functionality covered by this microservice is changing quickly, it
    may enter a game of catch-up between the new system and the old one, where there's
    no time to replicate any new functionality.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同时，这种方法可能非常耗时。如果遗留系统没有文档记录和/或未经测试，可能很难保证相同的功能。此外，如果此微服务覆盖的功能变化很快，它可能会进入新旧系统之间的追赶游戏，没有时间复制任何新的功能。
- en: This approach makes the most sense where the legacy parts to be replicated are
    small and obsolete, like using a tech stack that is considered to be deprecated.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种方法在需要复制的旧部分很小且过时的情况下最有意义，例如使用被认为已过时的技术栈。
- en: Divide the functionality, copying and pasting code that exists in the monolith
    into a new microservice structure. If the existing code is in good shape and structured,
    this approach is relatively fast, only requiring some internal calls to be replaced
    with external API calls.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将功能分割，将单体中存在的代码复制粘贴到新的微服务结构中。如果现有代码状况良好且结构良好，这种方法相对较快，只需将一些内部调用替换为外部API调用即可。
- en: It may be necessary to include in the monolith new access points to ensure that
    a new microservice can call back to obtain some information.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 可能需要在单体中包含新的访问点，以确保新的微服务可以回调以获取一些信息。
- en: It's also possible that the monolith needs to be refactored to clarify elements
    and divide them into a structure that's more in line with the new system.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能需要重构单体，以明确元素并将它们划分为与新技术更一致的结构。
- en: This process can also be made iterative by first starting with a single functionality
    migrated to the new microservice, and then, one by one, moving the code until
    the functionality is completely migrated. At that point, it is safe to delete
    the code from the old system.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程也可以通过首先将单个功能迁移到新的微服务中，然后逐个移动代码，直到功能完全迁移来进行迭代。到那时，可以安全地从旧系统中删除代码。
- en: A **combination** of both divide and replace. Some parts of the same functionality
    can likely be copied directly, but for others, a new approach is preferred.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是分割和替换的**组合**。同一功能的某些部分可能可以直接复制，但对于其他部分，则更倾向于采用新的方法。
- en: This will inform each microservice plan, although we will need to create a global
    view to determine which microservices to create in what order.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为每个微服务计划提供信息，尽管我们需要创建一个全局视图来确定按什么顺序创建哪些微服务。
- en: 'Here are some useful points to think about to determine what the best course
    of action is:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些有用的观点需要考虑，以确定最佳的行动方案：
- en: What microservices need to be available first, taking into account dependencies
    that will be produced.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要首先提供哪些微服务，考虑到将产生的依赖关系。
- en: An idea of what the biggest pain points are, and whether working on them is
    a priority. Pain points are the code or other elements that are changed frequently
    and the current way of dealing with them in a monolith makes them difficult. This
    can produce great benefits following migration.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解最大的痛点是什么，以及是否优先处理它们。痛点是经常更改的代码或其他元素，在单体架构中处理它们的方式使得它们变得困难。迁移后可以产生巨大的好处。
- en: What are the difficult points and the cans of worms? There will likely be some.
    Acknowledge that they exist and minimize their impact on other services. Note
    that they may be the same as the pain points, or they may differ. For example,
    old systems that are very stable are difficult points, but not painful as per
    our definition, as they don't change.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有哪些难点和潜在问题？很可能会有些。承认它们的存在并尽量减少它们对其他服务的影响。请注意，它们可能与痛点相同，也可能不同。例如，非常稳定的旧系统是难点，但根据我们的定义，它们并不痛苦，因为它们没有变化。
- en: Now for a couple of quick wins that will keep the momentum of the project going.
    Show the advantages to your teams and stakeholders quickly! This will also allow
    everyone to understand the new mode of operation you want to move to and start
    working that way.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在让我们来谈谈几个快速胜利，这将保持项目的势头。快速向你的团队和利益相关者展示优势！这也会让每个人理解你想要迁移到的新操作模式，并开始这样工作。
- en: An idea of the training that teams will require and what the new elements are
    that you want to introduce. Also, whether any skills are lacking in your team
    – you may be planning to hire.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要考虑团队所需的培训以及你想要引入的新元素。还要考虑团队中是否缺少某些技能——你可能正在计划招聘。
- en: Any team changes and ownership of the new services. It's important to consider
    feedback from the teams so that they can express their concerns regarding any
    oversights during the creation of the plan. Involve the team and value their feedback.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何团队变化和新服务的所有权。考虑团队的反馈很重要，这样他们就可以表达在制定计划过程中对任何疏忽的担忧。让团队参与并重视他们的反馈。
- en: Once we have a plan on how we are going to proceed, it's time to do it.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了如何进行的计划，就是时候付诸实施了。
- en: 4\. Execute
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4. 执行
- en: Finally, we need to act on our plan to start the move from the outdated monolith
    to the new wonderful land of microservices!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要采取行动，开始从过时的单体架构迁移到新的美好微服务领域！
- en: This will actually be the longest stage of the four, and arguably the most difficult.
    As we said before, the objective is to keep the service running all throughout
    the process.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上将是四个阶段中最长的，可以说是最困难的。正如我们之前所说，目标是让服务在整个过程中保持运行。
- en: The key element for a successful transition is to maintain **backward compatibility**.
    This means that the system keeps behaving like the monolithic system from an external
    point of view. That way, we can change the internals in terms of how the system
    works without affecting customers.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 成功过渡的关键要素是保持**向后兼容性**。这意味着从外部角度来看，系统保持像单体系统一样的行为。这样，我们可以在不影响客户的情况下，改变系统的内部工作方式。
- en: Ideally, the new architecture will allow us to be faster, meaning the only perceived
    change will be that the system is more responsive!
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，新的架构将使我们变得更快，这意味着唯一能感知到的变化就是系统更加响应迅速！
- en: This is obviously easier said than done. Software development in a production
    environment has been referred to as starting an automobile race driving a Ford
    T and crossing the finishing line in a Ferrari, changing every single piece of
    it without stopping. Fortunately, software is so flexible that this is something
    we can even discuss.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是说得容易做起来难。在生产环境中进行软件开发被比作驾驶福特T型车开始汽车比赛，然后在法拉利上冲过终点线，同时不断更换每一个部件而不停车。幸运的是，软件的灵活性如此之高，以至于我们甚至可以讨论这一点。
- en: To be able to make the change, from the monolith to the new microservice or
    microservices that handle the same functionality, the key tool is to use a load
    balancer at the top level, right on the ingress of requests. This is especially
    useful if the new microservice is directly replacing the requests. The load balancer
    can take the intake of requests and redirect them to the proper service, in a
    controlled manner.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够实现这种变化，从单体架构到新的微服务或处理相同功能的微服务，关键工具是在请求入口处使用负载均衡器。如果新的微服务直接替换请求，这尤其有用。负载均衡器可以接管请求的输入并将它们以受控的方式重定向到适当的服务。
- en: We will assume that all incoming requests are HTTP requests. A load balancer
    can handle other kinds of requests, but HTTP is by far the most common.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将假设所有传入的请求都是HTTP请求。负载均衡器可以处理其他类型的请求，但HTTP无疑是最常见的。
- en: This can be used to migrate the requests from the monolith slowly to the new
    microservice that should receive this request. Keep in mind that the load balancer
    can be configured by a different URL to direct the request to a different service,
    so it can use that small granularity to distribute the load properly across the
    different services.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用来将单体架构的请求缓慢迁移到应该接收此请求的新微服务。记住，负载均衡器可以通过不同的URL配置来将请求定向到不同的服务，因此它可以利用这种小的粒度来在不同服务之间正确分配负载。
- en: The process will look a little like this. First, the load balancer is directing
    all the requests to the legacy monolith. Once the new microservice is deployed,
    the requests can be load-balanced by introducing the new microservice. Initially,
    the balance should only be forwarding a few requests to the new system, to be
    sure that the behavior is the same.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程看起来可能像这样。首先，负载均衡器将所有请求都导向遗留单体。一旦新微服务部署，请求可以通过引入新微服务进行负载均衡。最初，平衡应该只将少量请求转发到新系统，以确保行为相同。
- en: Slowly, over time, it can grow until all requests are migrated. For example,
    the first week can only move 10% of the requests, the second week 30%, the third
    week 50%, and then 100% of all requests the week after.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 慢慢地，随着时间的推移，它可以增长，直到所有请求都迁移。例如，第一周只能移动10%的请求，第二周30%，第三周50%，然后在接下来的那一周移动所有请求的100%。
- en: The migration period is 4 weeks. During that time, no new features and changes
    should be introduced as the interface needs to be stable between the legacy monolith
    and the new microservice. Be sure that all the parties involved are aware of the
    plan and each of the steps.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移周期为4周。在这段时间内，不应引入任何新功能或更改，因为接口需要在遗留单体和新微服务之间保持稳定。确保所有相关人员都知道计划以及每个步骤。
- en: At that point, the handling of the requests in the legacy monolith is unused
    and can be removed to cleanup if this makes sense.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 到那时，在遗留单体中处理请求的操作将不再使用，如果这样做有意义，可以将其移除以进行清理。
- en: This process is similar to the strangler pattern that we discussed before, but
    in this case applied to individual requests. The load balancer will be an invaluable
    ally for implementing the pattern in full form, extending this procedure in a
    greater mode, as we are adding more functionality and slowly migrating it to be
    certain that any problem can be detected early and without affecting a large number
    of requests.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程与我们之前讨论的“杀手模式”类似，但在这个情况下是应用于单个请求。负载均衡器将是实施完整模式的宝贵盟友，以更大的规模扩展这个程序，因为我们正在添加更多功能，并缓慢地将它们迁移，以确保任何问题都能及早发现，并且不会影响大量请求。
- en: Execution phases
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 执行阶段
- en: 'The whole execution plan should consist of three phases:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 整个执行计划应包括三个阶段：
- en: '**The pilot phase.** Any plan will need to be tested with care. The pilot phase
    will be when the plan is checked in terms of its feasibility and the tools tested.
    A single team should lead this effort, to be sure that they are focused on it,
    and can learn and share quickly. Try to start on a couple of small services and
    low-hanging fruit, so that the improvement is obvious for the team. Good candidates
    are non-critical services, so if there''s a problem, it doesn''t present a big
    impact. This phase will allow you to prepare for the migration and to make adjustments
    and learn from inevitable mistakes.'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**试点阶段**。任何计划都需要经过仔细的测试。试点阶段将是检查计划的可行性以及测试工具的时候。应该由一个团队来领导这项工作，以确保他们专注于它，并且可以快速学习和分享。尽量从几个小型服务和低垂的果实开始，这样团队就能明显看到改进。合适的候选是非关键服务，如果出现问题，不会造成重大影响。这个阶段将使你为迁移做准备，并从不可避免的错误中调整和吸取教训。'
- en: '**Consolidation phase.** At this point, the basics of the migration are understood,
    but there''s still a lot of code to migrate. The pilot team can then start training
    other teams and spread the knowledge, so everyone understands how it should proceed.
    By this time, the basic infrastructure will be in place, and hopefully the most
    obvious issues have been corrected or at least there''s a good understanding of
    how to deal with them.'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**整合阶段**。在这个阶段，迁移的基本原理已经理解，但仍有许多代码需要迁移。此时，试点团队可以开始培训其他团队并传播知识，这样每个人都能理解应该如何进行。到那时，基本基础设施将到位，希望最明显的问题已经得到纠正，或者至少对如何处理它们有良好的理解。'
- en: To help with the spreading of knowledge, documenting standards will help teams
    to coordinate and depend less on asking the same questions over and over. Enforcing
    a list of prerequisites for a new microservice to be deployed and running in production
    will give clarity on what is required. Be sure also to keep a feedback channel,
    so new teams can share their findings and improve the process.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了帮助知识的传播，制定文档标准将帮助团队进行协调，并减少反复询问相同问题的情况。为新微服务部署和在生产中运行制定一系列先决条件将阐明所需内容。还务必保持反馈渠道，以便新团队可以分享他们的发现并改进流程。
- en: This phase will probably see some plan changes, as reality will overcome whatever
    plan has been laid out in advance. Be sure to adapt and keep an eye on the objective
    while navigating through the problems.
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个阶段可能会看到一些计划的变化，因为现实将克服之前制定的任何计划。确保在解决问题的过程中适应变化，并密切关注目标。
- en: At this phase, the pace will be increased, as the uncertainty is being reduced
    as more and more code is migrated. At some point, creating and migrating a new
    microservice will be routine for the team.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个阶段，速度将会加快，因为随着越来越多的代码迁移，不确定性正在减少。在某个时候，为团队创建和迁移新的微服务将变得司空见惯。
- en: '**Final phase**. In this phase, the monolithic architecture has been split,
    and any new development is done in the microservices. There may still be some
    remains of the monolith that are regarded as unimportant or low priority. If that''s
    the case, the boundaries should be clear to contain the old way of doing things.'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最终阶段**。在这个阶段，单体架构已经被拆分，所有新的开发都是在微服务中进行的。可能仍然有一些被视为不重要或低优先级的单体残留。如果是这样，边界应该清晰，以包含旧的方式做事。'
- en: Now, teams can take full ownership of their microservices and start taking more
    ambitious tasks, such as replacing a microservice completely by creating an equivalent
    one in another programming language or changing the architecture by merging or
    splitting microservices. This is the end stage where, from now on, you live in
    a microservices architecture. Be sure to celebrate it with the team accordingly.
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，团队可以完全掌控他们的微服务，并开始承担更宏伟的任务，例如通过在另一种编程语言中创建一个等效的微服务来完全替换一个微服务，或者通过合并或拆分微服务来改变架构。这是最终阶段，从现在开始，你将生活在微服务架构中。务必与团队一起庆祝这一时刻。
- en: That's roughly the process. Of course, this may be a long and arduous process
    that can span many months or even years. Be sure to keep a sustainable pace and
    a long-term view on the objective to be able to continue until the goal is reached.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这大致就是过程。当然，这可能是一个漫长而艰巨的过程，可能需要数月甚至数年。确保保持可持续的步伐，并从长远的角度看待目标，以便能够继续直到达到目标。
- en: Containerizing services
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器化服务
- en: The traditional way of operating services is to use a server using a full OS,
    such as Linux, and then install on it all the required packages (for example,
    Python or PHP) and services (for example, nginx, uWSGI). The server acts as the
    unit, so each physical machine needs to be independently maintained and managed.
    It also may not be optimal from the point of view of hardware utilization.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的服务操作方式是使用一个运行完整操作系统的服务器，例如Linux，然后在上面安装所有必需的包（例如Python或PHP）和服务（例如nginx，uWSGI）。服务器作为单元，因此每个物理机器都需要独立维护和管理。从硬件利用率的观点来看，这也许并不最优。
- en: This can be improved by replacing the physical server with virtual machines,
    so a single physical server can handle multiple VMs. This helps with hardware
    utilization and flexibility, but still requires each server to be managed as an
    independent physical machine.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 通过用虚拟机替换物理服务器，可以提高这一点，这样单个物理服务器就可以处理多个虚拟机。这有助于提高硬件利用率和灵活性，但仍然需要将每个服务器作为独立的物理机器进行管理。
- en: Multiple tools help with this management, for example, configuration management
    tools such as Chef or Puppet. They can manage multiple servers and guarantee that
    they have installed the proper versions and are running the proper services.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 多种工具有助于这项管理，例如配置管理工具，如Chef或Puppet。它们可以管理多个服务器，并确保它们安装了正确的版本，并运行了正确的服务。
- en: Containers bring a different approach to this area. Instead of using a full-fledged
    computer (a server), with an installed OS, packages, and dependencies, and then
    installing your software on top of that, which mutates more often than the underlying
    system, it creates a package (the container image) that brings it all.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 容器为这个领域带来了不同的方法。不是使用一个完整的计算机（服务器），安装一个操作系统，包和依赖项，然后在上面安装你的软件，这比底层系统变化更频繁，而是创建一个包含所有内容的包（容器镜像）。
- en: The container has its own filesystem, including the OS, dependencies, packages,
    and code, and is deployed as a whole. Instead of having a stable platform and
    running services on top of them, containers run as a whole, self-containing everything
    required. The platform (host machine) is a thin layer that only needs to be able
    to run the containers. Containers share the same kernel with the host, making
    them very efficient to run, compared with VMs, which may require simulating the
    whole server.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 容器拥有自己的文件系统，包括操作系统、依赖项、软件包和代码，并且作为一个整体部署。容器不是在稳定的平台上运行服务，而是作为一个整体运行，包含所需的所有内容。平台（主机机器）是一个薄层，只需要能够运行容器。容器与主机共享相同的内核，这使得它们在运行效率上非常高效，与可能需要模拟整个服务器的虚拟机相比。
- en: This allows, for example, different containers to be run in the same physical
    machine and have each container run a different OS, with different packages, and
    different versions of the code.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许，例如，在相同的物理机器上运行不同的容器，并且每个容器运行不同的操作系统、不同的软件包和不同的代码版本。
- en: Sometimes, containers are thought of as "lightweight virtual machines." This
    is not correct. Instead, think of them as *a process wrapped in its own filesystem*.
    This process is the main process of the container, and when it finishes, the container
    stops running.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，人们将容器视为“轻量级虚拟机”。这并不正确。相反，将它们视为*被其自身文件系统包裹的进程*。这个进程是容器的主要进程，当它完成时，容器停止运行。
- en: The most popular tool for building and running containers is Docker ([https://www.docker.com/](https://www.docker.com/)).
    We will now examine how to operate with it.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和运行容器的最流行工具是 Docker ([https://www.docker.com/](https://www.docker.com/))。我们现在将检查如何操作它。
- en: To install Docker, you can go to the documentation at [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)
    and follow the instructions. Use version 20.10.7 or later.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Docker，您可以访问[https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)上的文档并遵循说明。使用
    20.10.7 或更高版本。
- en: 'Once installed, you should be able to check the version running and get something
    similar to the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您应该能够检查正在运行的版本，并获得以下类似的内容：
- en: '[PRE0]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now we need to build a container image that we can run.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要构建一个可以运行的容器镜像。
- en: Building and running an image
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建和运行镜像
- en: The container image is the whole filesystem and instructions to run when it's
    started. To start using containers we need to build the proper images that form
    the basis of the system.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像包括整个文件系统和启动时的指令。为了开始使用容器，我们需要构建构成系统基础的适当镜像。
- en: Remember the description presented previously, that a container is a process
    surrounded by its own filesystem. Building the image creates this filesystem.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 记住之前提供的描述，即容器是一个被其自身文件系统包围的进程。构建镜像创建了该文件系统。
- en: An image is created by applying a `Dockerfile`, a recipe that creates the image
    by executing different layers, one by one.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用 `Dockerfile`，一个创建镜像的配方，通过逐层执行不同的层来创建镜像。
- en: 'Let''s see a very simple `Dockerfile`. Create a file called `sometext.txt`
    containing some small example text, and another file called `Dockerfile.simple`
    containing the following text:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个非常简单的 `Dockerfile`。创建一个名为 `sometext.txt` 的文件，包含一些小的示例文本，另一个名为 `Dockerfile.simple`
    的文件，包含以下文本：
- en: '[PRE1]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first line, `FROM`, will start the image by using the Ubuntu image.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行，`FROM`，将通过使用 Ubuntu 镜像来启动镜像。
- en: There are many images that you can use as a starting point. You have all the
    usual Linux distributions, such as Ubuntu, Debian, and Fedora, but also images
    for full-fledged systems such as storage systems (MySQL, PostgreSQL, and Redis)
    or images to work with specific tools, such as Python, Node.js, or Ruby. Check
    Docker Hub ([https://hub.docker.com](https://hub.docker.com)) for all the available
    images.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多可以作为起点使用的镜像。您有所有常见的 Linux 发行版，如 Ubuntu、Debian 和 Fedora，还有用于完整系统的镜像，如存储系统（MySQL、PostgreSQL
    和 Redis）或用于特定工具的镜像，如 Python、Node.js 或 Ruby。查看 Docker Hub ([https://hub.docker.com](https://hub.docker.com))
    以获取所有可用的镜像。
- en: An interesting starting point is to use the Alpine Linux distribution, which
    is designed to be small and focused on security. Check out [https://www.alpinelinux.org](https://www.alpinelinux.org)
    for further information.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的起点是使用 Alpine Linux 发行版，它被设计成小巧且专注于安全。更多信息请查看[https://www.alpinelinux.org](https://www.alpinelinux.org)。
- en: One of the main advantages of containers is the ability to use and share already
    created containers, either directly or as a starting point to enhance them. Nowadays,
    it is very common to create and push a container to Docker Hub to allow others
    to use it directly. That's one of the great things about containers! They are
    very easy to share and use.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的主要优势之一是能够使用和共享已经创建的容器，无论是直接使用还是作为增强它们的起点。如今，创建并推送到Docker Hub以允许他人直接使用它是非常常见的。这就是容器的一大优点！它们非常容易分享和使用。
- en: 'The second line runs a command inside the container. In this case, it creates
    a new subdirectory in `/opt`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行在容器内运行一个命令。在这种情况下，它会在`/opt`中创建一个新的子目录：
- en: '[PRE2]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we copy the current `sometext.txt` file inside, in the new subdirectory:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将当前`sometext.txt`文件复制到容器内部的新子目录中：
- en: '[PRE3]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, we define the command to execute when the image is run:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义当镜像运行时要执行的命令：
- en: '[PRE4]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To build the image, we run the following command:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建镜像，我们运行以下命令：
- en: '[PRE5]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In our case, we use the defined Dockerfile and `example` as a tag. The context
    is `.` (current directory), which defines the root point in terms of where to
    refer to all the `COPY` commands:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们使用定义好的Dockerfile和`example`作为标签。上下文是`.`（当前目录），它定义了所有`COPY`命令的根点：
- en: '[PRE6]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we list the available images, you will be able to see the `example` one:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们列出可用的镜像，你将能够看到`example`这个镜像：
- en: '[PRE7]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can now run the container, which will execute the `cat` command inside:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以运行容器，它将在容器内执行`cat`命令：
- en: '[PRE8]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The container will stop the execution as the command finishes. You can see the
    stopped containers using the `docker ps -a` command, but a stopped container is
    generally not very interesting.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 容器将在命令完成后停止执行。你可以使用`docker ps -a`命令查看已停止的容器，但通常停止的容器并不很有趣。
- en: A common exception to this is that the resulting filesystem is stored onto disk,
    so the stopped container may have interesting files generated as part of the command.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的例外是，生成的文件系统被存储到磁盘上，因此停止的容器可能产生了作为命令一部分的有趣文件。
- en: While this way of running containers can be useful sometimes to compile binaries
    or other kinds of operations of a similar kind, normally, it's more common to
    create `RUN` commands that are always running. In that case, it will run until
    stopped externally, as the command will run forever.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方式在某些时候运行容器可能很有用，比如编译二进制文件或其他类似操作，但通常情况下，更常见的是创建始终运行的`RUN`命令。在这种情况下，它将一直运行，直到外部停止，因为命令将永远运行。
- en: Building and running a web service
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建和运行一个网络服务
- en: 'A web service container is the most common type of microservice, as we have
    seen. To be able to build and run one, we need to have the following parts:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务容器是我们已经看到的最常见的微服务类型。为了能够构建和运行一个，我们需要以下部分：
- en: Proper infrastructure that runs the web service to a port in the container
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确的基础设施将网络服务运行到容器中的端口
- en: Our code, which will run
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将运行的我们的代码
- en: 'Following the usual architecture presented in previous chapters, we will use
    the following tech stack:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 按照前几章中介绍的常规架构，我们将使用以下技术栈：
- en: Our code will be written in Python and use Django as the web framework
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的代码将使用Python编写，并使用Django作为网络框架
- en: The Python code will be executed through uWSGI
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python代码将通过uWSGI执行
- en: The service will be exposed in port 8000 through an nginx web server
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该服务将通过nginx网络服务器在端口8000上公开
- en: Let's take a look at the different elements.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看不同的元素。
- en: The code is available at [https://github.com/PacktPublishing/Python-Architecture-Patterns/tree/main/chapter_09_monolith_microservices/web_service](https://github.com/PacktPublishing/Python-Architecture-Patterns/tree/main/chapter_09_monolith_microservices/web_service).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可在[https://github.com/PacktPublishing/Python-Architecture-Patterns/tree/main/chapter_09_monolith_microservices/web_service](https://github.com/PacktPublishing/Python-Architecture-Patterns/tree/main/chapter_09_monolith_microservices/web_service)找到。
- en: 'The code is structured in two main directories and one file:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 代码结构在两个主要目录和一个文件中：
- en: '`docker`: This subdirectory contains the files related to the operation of
    Docker and other infrastructure.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker`：此子目录包含与Docker和其他基础设施操作相关的文件。'
- en: '`src`: The source code of the web service itself. The source code is the same
    as we saw in *Chapter 5*, *The Twelve-Factor App Methodology*.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`：网络服务的源代码本身。源代码与我们在*第五章*，“十二要素应用方法论”中看到的是相同的。'
- en: '`requirements.txt`: The file with the Python requirements for running the source
    code.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requirements.txt`：包含运行源代码所需的Python依赖的文件。'
- en: 'The Dockerfile image is located in the `./docker` subdirectory. We will follow
    it to explain how the different parts connect:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile镜像位于`./docker`子目录中。我们将按照它来解释不同部分是如何连接的：
- en: '[PRE9]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The first part of the file starts the container from the standard Ubuntu Docker
    image and install the basic requirements: Python interpreter, nginx, uWSGI, and
    a couple of complementary packages – the uWSGI plugin to run `python3` code and
    `pip` to be able to install Python packages:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的第一部分从标准的Ubuntu Docker镜像启动容器，并安装基本需求：Python解释器、nginx、uWSGI以及一些补充包——运行`python3`代码的uWSGI插件和能够安装Python包的`pip`：
- en: '[PRE10]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The next stage is to add all the required scripts and config files to start
    the server and configure uWSGI and nginx. All these files are in the `./docker`
    subdirectory and are stored inside the container in `/opt/server` (except for
    the nginx configuration that is stored in the default `/etc/nginx` subdirectory).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个阶段是将所有必需的脚本和配置文件添加到启动服务器并配置uWSGI和nginx。所有这些文件都在`./docker`子目录中，并存储在容器中的`/opt/server`目录内（除了nginx配置，它存储在默认的`/etc/nginx`子目录中）。
- en: 'We ensure that the start script is executable:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确保启动脚本可执行：
- en: '[PRE11]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The Python requirements are installed next. The `requirements.txt` file is
    added and then installed through the `pip3` command:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来安装Python需求。添加`requirements.txt`文件，然后通过`pip3`命令安装：
- en: '[PRE12]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Some Python packages may need certain packages to be installed in the container
    in the first stage to be sure that some tools are available; for example, installing
    certain database connection modules will require the proper client libraries to
    be installed.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Python包可能需要在容器第一阶段安装某些包以确保某些工具可用；例如，安装某些数据库连接模块将需要安装适当的客户端库。
- en: 'We add the source code to `/opt/code` next. With the `WORKDIR` command, we
    execute any `RUN` command in that subdirectory and then run `collectstatic` with
    the Django `manage.py` command to generate the static files in the proper subdirectory:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将源代码添加到`/opt/code`。使用`WORKDIR`命令，在该子目录中执行任何`RUN`命令，然后使用Django的`manage.py`命令运行`collectstatic`以在正确的子目录中生成静态文件：
- en: '[PRE13]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we describe the exposed port (8000) and the `CMD` to run to start
    the container, the `start_server.sh` script copied previously:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们描述暴露的端口（8000）和要运行的`CMD`以启动容器，即之前复制的`start_server.sh`脚本：
- en: '[PRE14]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: uWSGI configuration
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: uWSGI配置
- en: 'The uWSGI configuration is very similar to the one presented in *Chapter 5*,*The
    Twelve-Factor App Methodology*:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: uWSGI配置与*第五章*中介绍的配置非常相似，*十二要素应用方法*：
- en: '[PRE15]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The only difference is the need to include the `plugins` parameter to indicate
    that it runs the `python3` plugin (this is because the Ubuntu-installed `uwsgi`
    package doesn't have it activated by default). Also, we will run the process with
    the same user as nginx, to allow them to communicate through the `/tmp/uwsgi.sock`
    socket. This is added with `uid=www-data`, with `www-data` being the default nginx
    user.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是需要包含`plugins`参数来指示它运行`python3`插件（这是因为Ubuntu安装的`uwsgi`包默认没有激活它）。此外，我们将使用与nginx相同的用户运行进程，以便它们可以通过`/tmp/uwsgi.sock`套接字进行通信。这是通过`uid=www-data`添加的，其中`www-data`是默认的nginx用户。
- en: nginx configuration
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: nginx配置
- en: 'The nginx configuration is also very similar to the one presented in *Chapter
    5*,*The Twelve-Factor App Methodology*:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: nginx配置也与*第五章*中介绍的配置非常相似，*十二要素应用方法*：
- en: '[PRE16]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The only difference is the exposed port, which is `8000`. Note that the root
    directory is `/opt/code`, making the static file directory `/opt/code/static`.
    This needs to be in sync with the configuration from Django.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是暴露的端口，它是`8000`。请注意，根目录是`/opt/code`，这使得静态文件目录是`/opt/code/static`。这需要与Django的配置保持同步。
- en: Start script
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动脚本
- en: 'Let''s take a look at the script that starts the service, `start_script.sh`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看启动服务的脚本，`start_script.sh`：
- en: '[PRE17]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The core of the start is at the center, in these lines, nginx:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 启动脚本的核心位于中心，在这些nginx行中：
- en: '[PRE18]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This starts both `nginx` and `uwsgi`, and waits until the `uwsgi` process is
    not running. In Bash, `$!` is the PID of the last process (the `uwsgi` process).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动`nginx`和`uwsgi`，并等待`uwsgi`进程停止。在Bash中，`$!`是最后一个进程（`uwsgi`进程）的PID。
- en: 'When Docker attempts to stop a container, it will first send a `SIGTERM` signal
    to the container. That''s why we create a `trap` command that captures this signal
    and executes the `_term()` function. This function sends a graceful stop command
    to the `uwsgi` queue, as we described in *Chapter 5*,*The Twelve-Factor App Methodology*,
    which ends the process in a graceful manner:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Docker 尝试停止容器时，它将首先向容器发送 `SIGTERM` 信号。这就是为什么我们创建了一个 `trap` 命令来捕获这个信号并执行 `_term()`
    函数。这个函数会发送一个优雅的停止命令到 `uwsgi` 队列，正如我们在 *第 5 章*，*十二要素应用方法* 中所描述的，以优雅的方式结束进程：
- en: '[PRE19]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If the initial `SIGTERM` signal is not successful, Docker will stop the container
    killing it following a grace period, but that will risk having a non-graceful
    end for the process.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果初始的 `SIGTERM` 信号不成功，Docker 将在一段宽限期后停止容器并杀死它，但这可能会使进程的结束变得不优雅。
- en: Building and running
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建 和 运行
- en: 'We can now build the image and run it. To build the image, we perform a similar
    command as before:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以构建镜像并运行它。要构建镜像，我们执行与之前类似的命令：
- en: '[PRE20]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To run the service, start the container, mapping its port `8000` to a local
    port, for example, `local 8000`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行服务，启动容器，将其端口 `8000` 映射到本地端口，例如，`local 8000`：
- en: '[PRE21]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After doing this, you can access your local address, `http://localhost:8000`,
    and access the service; for example, accessing the URL `http://localhost:8000/api/users/jaime/collection`:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，您可以通过本地地址 `http://localhost:8000` 访问服务；例如，访问 URL `http://localhost:8000/api/users/jaime/collection`：
- en: '![Graphical user interface, application'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '![图形用户界面，应用程序'
- en: Description automatically generated](img/B17580_09_07.png)
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 描述自动生成](img/B17580_09_07.png)
- en: 'Figure 9.7: Microposts list'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7：微帖子列表
- en: 'You''ll see the access log in the screen where you started the container:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在启动容器的屏幕上看到访问日志：
- en: '[PRE22]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The container can be stopped gracefully using the `docker stop` command. To
    do so, you''ll need to first discover the container ID using `docker ps`:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `docker stop` 命令优雅地停止容器。为此，您需要首先使用 `docker ps` 命令发现容器 ID：
- en: '[PRE23]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The container log will show the details when capturing the `SIGTERM` signal
    sent by Docker and will then exit:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 容器日志将在捕获 Docker 发送的 `SIGTERM` 信号时显示详细信息，然后退出：
- en: '[PRE24]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To be able to set this example, we made some conscious decisions to simplify
    the operation compared with a typical service.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够设置此示例，我们做出了一些有意识的决策，简化了与典型服务相比的操作。
- en: Caveats
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: Remember to check *Chapter 5*,*The Twelve-Factor App Methodology*, to see the
    defined API and understand it better.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住查看 *第 5 章*，*十二要素应用方法*，以了解定义的 API 并更好地理解它。
- en: The `DEBUG` mode in the Django `settings.py` file is set to `True`, which allows
    us to see more information when, for example, 404 or 500 errors are triggered.
    This parameter should be disabled in production as it can give away critical information.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: Django `settings.py` 文件中的 `DEBUG` 模式设置为 `True`，这使得在触发例如 404 或 500 错误时，我们可以看到更多信息。在生产环境中，应禁用此参数，因为它可能会泄露关键信息。
- en: The `STATIC_ROOT` and `STATIC_URL` parameters need to be coordinated between
    Django and nginx to point to the same place. That way, the `collectstatic` command
    will store the data in the same place where nginx will pick it up.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`STATIC_ROOT` 和 `STATIC_URL` 参数需要在 Django 和 nginx 之间协调，以便指向同一位置。这样，`collectstatic`
    命令将数据存储在 nginx 将从中获取数据的地方。'
- en: The most important detail is the use of a SQLite database instead of an internal
    one. This database is stored in the `src/db.sqlite3` file, in the filesystem of
    the container. This means that if the container is stopped and restarted, any
    changes will be destroyed.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的细节是使用 SQLite 数据库而不是内部数据库。此数据库存储在容器的文件系统中的 `src/db.sqlite3` 文件中。这意味着如果容器停止并重新启动，任何更改都将被销毁。
- en: The `db.sqlite3` file in the GitHub repo contains some information that has
    been stored for convenience, two users, `jaime` and `dana`, each with a couple
    of microposts. The API so far hasn't been defined in such a way to create new
    users, so it needs to relay into creating them using Django tools or manipulating
    the SQL directly. These users are added for demonstration purposes.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 仓库中的 `db.sqlite3` 文件包含一些为了方便存储的信息，两个用户 `jaime` 和 `dana`，每人都有几条微帖子。API
    目前还没有定义创建新用户的方式，因此需要通过 Django 工具或直接操作 SQL 来创建它们。这些用户是为了演示目的添加的。
- en: As an exercise, create a script that seeds the database with information as
    part of the build process.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，创建一个脚本，在构建过程中将信息作为种子添加到数据库中。
- en: In general, this database usage is not well suited for production usage, requiring
    connection to a database external to the container. This obviously requires an
    available external database, which complicates the setup.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这种数据库使用不适合生产使用，需要连接到容器外部的数据库。这显然需要一个可用的外部数据库，这会复杂化设置。
- en: Now that we know how to use containers, we can perhaps start another Docker
    container with a database, such as MySQL, for a better configuration.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何使用容器，我们或许可以启动另一个带有数据库的 Docker 容器，例如 MySQL，以获得更好的配置。
- en: A containerized database is not a great idea for production. In general, containers
    are great for stateless services that change often, as they can be started and
    stopped easily. Databases tend to be very stable and there are a lot of services
    that make provisions for managed databases. The advantages that containers bring
    are simply not relevant for a typical database.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化数据库对于生产来说不是一个好主意。一般来说，容器非常适合经常变化的无状态服务，因为它们可以轻松启动和停止。数据库通常非常稳定，有很多服务为托管数据库做出安排。容器带来的优势对于典型的数据库来说并不相关。
- en: That doesn't mean that there are usages out of production. It is a great option
    for local development, for example, as it allows the creation of a replicable
    local environment easily.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着它没有在生产环境中的用途。例如，它是一个很好的本地开发选项，因为它允许轻松创建可复制的本地环境。
- en: If we want to create more than one container and connect them, like a web server
    and a database that acts as a backend for storing the data, instead of starting
    all the containers individually, we can use orchestration tools.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要创建多个容器并将它们连接起来，比如一个作为数据存储后端的 Web 服务器和数据库，而不是单独启动所有容器，我们可以使用编排工具。
- en: Orchestration and Kubernetes
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 或许是编排和 Kubernetes
- en: Managing multiple containers and connecting them is known as orchestrating them.
    Microservices that are deployed in containers will have to orchestrate them to
    be sure that the multiple microservices are interconnecting.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 管理多个容器并将它们连接起来被称为编排它们。部署在容器中的微服务必须进行编排，以确保多个微服务能够相互连接。
- en: This concept includes details such as discovering where the other containers
    are, dependencies between services, and generating multiple copies of the same
    container.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念包括诸如发现其他容器所在位置、服务之间的依赖关系以及生成相同容器的多个副本等细节。
- en: Orchestration tools are very powerful, as well as complex, and require that
    you become familiar with a lot of terms. To explain them fully is beyond the scope
    of this book, but we will point to some and give a short introduction. Please
    refer to the linked documentation in the sections below for more information.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 编排工具非常强大，但也非常复杂，需要你熟悉许多术语。要完全解释它们超出了本书的范围，但我们将指出一些并给出简要介绍。请参阅下文中的链接文档以获取更多信息。
- en: There are several tools that can perform orchestration, the two most common
    ones being `docker-compose` and Kubernetes.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种工具可以执行编排，其中最常见的是 `docker-compose` 和 Kubernetes。
- en: '`docker-compose` is part of the general offering by Docker. It works very well
    for small deployments or local development. It defines a single YAML file that
    contains the definition of the different services, and the name that they can
    use. It can be used to replace a lot of `docker build` and `docker run` commands,
    as it can define all the parameters in the YAML file.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose` 是 Docker 通用服务的一部分。它在小型部署或本地开发中工作得非常好。它定义了一个包含不同服务定义及其可用名称的单个
    YAML 文件。它可以用来替代许多 `docker build` 和 `docker run` 命令，因为它可以在 YAML 文件中定义所有参数。'
- en: 'You can check the documentation for Docker Compose here: [https://docs.docker.com/compose/](https://docs.docker.com/compose/).'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处查看 Docker Compose 的文档：[https://docs.docker.com/compose/](https://docs.docker.com/compose/)。
- en: Kubernetes is aimed at bigger deployments and clusters and allows the generation
    of a full logical structure for containers to define how they connect to one another,
    thereby allowing abstraction to the underlying infrastructure.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 针对更大规模的部署和集群，允许生成一个完整的逻辑结构来定义容器如何相互连接，从而允许对底层基础设施进行抽象。
- en: Any physical (or virtual) server configured in Kubernetes is called a **node**.
    All nodes define the cluster. Each node is handled by Kubernetes, and Kubernetes
    will create a network between the nodes and assign the different containers to
    each of them, attending to the available space on them. This means that the number,
    location, or kind of node doesn't need to be handled by the services.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中配置的任何物理（或虚拟）服务器都称为 **节点**。所有节点定义了集群。每个节点都由 Kubernetes 处理，Kubernetes
    将在节点之间创建网络，并将不同的容器分配给每个节点，同时考虑到它们上的可用空间。这意味着节点的数量、位置或类型不需要由服务来处理。
- en: 'Instead, the applications in the cluster are distributed in the logical layer.
    Several elements can be defined:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，集群中的应用程序在逻辑层中分布。可以定义几个元素：
- en: '**Pod**. A Pod is the minimal unit defined in Kubernetes, and it is defined
    as a group of containers that runs as a unit. Normally, Pods will consist of just
    one container, but in some cases, they may comprise several. Everything in Kubernetes
    runs in Pods.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pod**。Pod 是 Kubernetes 中定义的最小单元，它被定义为作为一个单元运行的容器组。通常，Pod 将仅包含一个容器，但在某些情况下，它们可能包含多个。Kubernetes
    中的所有内容都在 Pod 中运行。'
- en: '**Deployment**. A collection of Pods. The Deployment will define the number
    of replicas that are needed, and create the proper number of Pods. Each Pod for
    the same deployment can live in different nodes, but that''s under the control
    of Kubernetes.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署**。Pod 的集合。部署将定义所需的副本数量，并创建适当数量的 Pod。同一部署的每个 Pod 可以位于不同的节点上，但这由 Kubernetes
    控制。'
- en: Because the Deployment controls the number of Pods, if a Pod crashes, the Deployment
    will restart it. Also, the Deployment can be manipulated to change the number,
    for example, by creating autoscalers. If the image to be deployed in the Pods
    is changed, the Deployment will create new Pods with the right image and remove
    the old ones accordingly, based on rolling updates or other strategies.
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于部署控制 Pod 的数量，如果一个 Pod 崩溃，部署将重新启动它。此外，可以通过创建自动扩展器等来操纵部署以更改数量。如果要在 Pod 中部署的镜像更改，部署将创建具有正确镜像的新
    Pod，并相应地根据滚动更新或其他策略删除旧 Pod。
- en: '**Service**. A label that can be used to route requests to certain Pods, acting
    as a DNS name. Normally, this will point to the Pods created for deployment. This
    allows other Pods in the system to send requests to a known place. The requests
    will be load-balanced between the different Pods.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务**。一个可以用来将请求路由到特定 Pod 的标签，充当 DNS 名称。通常，这将指向为部署创建的 Pod。这允许系统中的其他 Pod 向已知位置发送请求。请求将在不同的
    Pod 之间进行负载均衡。'
- en: '**Ingress**. External access to a service. This will map an incoming DNS to
    a service. Ingresses allow applications to be exposed externally. An external
    request will go through the process of entering through an Ingress, being directed
    to a Service, and then handled by a specific pod.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**入口**。对服务的外部访问。这将映射一个传入的 DNS 到一个服务。入口允许应用程序对外暴露。外部请求将通过通过入口进入、被引导到服务、然后由特定的
    Pod 处理的过程。'
- en: Some components can be described in a Kubernetes cluster, such as `ConfigMaps`,
    defining key-value pairs that can be used for configuration purposes; `Volumes`
    to share storage across Pods; and `Secrets` to define secret values that can be
    injected into Pods.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 一些组件可以在 Kubernetes 集群中描述，例如 `ConfigMaps`，定义可用于配置目的的键值对；`Volumes` 用于在 Pod 之间共享存储；以及
    `Secrets` 用于定义可以注入到 Pod 中的秘密值。
- en: 'Kubernetes is a fantastic tool that can handle pretty big clusters with hundreds
    of nodes and thousands of Pods. It''s also a complex tool that requires you to
    learn how it can be used and has a significant learning curve. It''s pretty popular
    these days, and there''s plenty of documentation about it. The official documentation
    can be found here: [https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/).'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是一个出色的工具，可以处理相当大的集群，拥有数百个节点和数千个 Pod。它也是一个复杂的工具，需要你学习如何使用它，并且有一个显著的学习曲线。它现在非常受欢迎，关于它的文档也很多。官方文档可以在以下位置找到：[https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)。
- en: Summary
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we described both the monolithic and microservices architectures.
    We started by presenting the monolithic architecture and how it tends to be a
    "default architecture," generated organically as an application is designed. Monoliths
    are created as unitary blocks that contain all the code within a single block.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们描述了单体和微服务架构。我们首先介绍了单体架构以及它通常是如何成为一个“默认架构”的，作为一个应用程序被设计时自然产生的。单体被创建为包含单个块内所有代码的单元块。
- en: In comparison, the microservices architecture divides the functionality of the
    whole application into smaller parts so that they can be worked in parallel. For
    this strategy to work, it needs to define clear boundaries and document how to
    interconnect the different services. Compared with the monolithic architecture,
    microservices aim to generate more structured code and control big code bases
    by dividing them into smaller, more manageable systems.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相比，微服务架构将整个应用程序的功能划分为更小的部分，以便它们可以并行工作。为了使这种策略有效，它需要定义清晰的边界并记录如何连接不同的服务。与单体架构相比，微服务旨在生成更结构化的代码，并通过将它们划分为更小、更易于管理的系统来控制大型代码库。
- en: We discussed what the best architecture is and how to choose whether to design
    a system as a monolith or as microservices. Each approach has its pros and cons,
    but in general, systems start as monolithic and the move to divide the code base
    into smaller microservices comes after the code base and the number of developers
    working on it reaches a certain size.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了最佳架构是什么，以及如何选择是否将系统设计为单体或微服务。每种方法都有其优缺点，但一般来说，系统最初是单体的，当代码库和开发人员数量达到一定规模后，才会将代码库划分为更小的微服务。
- en: The difference between the two architectures is not just technical. It largely
    involves how developers working on the system need to communicate and divide the
    teams. We discussed the different aspects to take into account, including the
    structure and size of the teams.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 两种架构之间的区别不仅仅是技术上的。它主要涉及在系统上工作的开发者需要如何沟通和划分团队。我们讨论了需要考虑的不同方面，包括团队的结构和规模。
- en: 'Since migrating from an old monolithic architecture to a new microservices
    one is such a common case, we talked about how to approach the work, analyze it,
    and perform it, using a four-stage roadmap: Analyze, Design, Plan, and Execute.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 由于从旧的单体架构迁移到新的微服务架构是一个非常常见的案例，我们讨论了如何着手这项工作，分析它，并执行它，使用一个四阶段路线图：分析、设计、计划和执行。
- en: We then discussed how containerizing services (and, in particular, microservices)
    can be helpful. We explored how to use Docker as a tool to containerize services
    and its multiple advantages and uses. We included an example of containerizing
    our example web service, as described in *Chapter 5*, *The Twelve-Factor App Methodology*.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了如何将服务容器化（特别是微服务）可能带来的帮助。我们探讨了如何使用Docker作为工具来容器化服务，以及它的多种优点和用途。我们还提供了一个将示例Web服务容器化的例子，如第5章中所述的*十二要素应用方法*。
- en: Finally, we described briefly the usage of an orchestration tool to coordinate
    and intercommunicate between multiple containers, and the most popular, Kubernetes.
    We then covered a brief introduction to Kubernetes.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们简要描述了使用编排工具来协调和多个容器之间相互通信的用法，以及最受欢迎的Kubernetes。然后我们简要介绍了Kubernetes。
- en: You can get more information about microservices and how to perform a migration
    from a monolithic architecture to a microservices one in the book *Hands-On Docker
    for Microservices with Python*, from the author of this book, which expands on
    these concepts and goes into greater depth.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书作者所著的《Hands-On Docker for Microservices with Python》一书中了解更多关于微服务以及如何从单体架构迁移到微服务架构的信息，该书对这些概念进行了扩展，并深入探讨了这些内容。
