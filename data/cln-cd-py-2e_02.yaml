- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Pythonic Code
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pythonic代码
- en: In this chapter, we will explore the way ideas are expressed in Python, with
    its own peculiarities. If you are familiar with the standard ways of accomplishing
    some tasks in programming (such as getting the last element of a list, iterating,
    and searching), or if you come from other programming languages (such as C, C++,
    and Java), then you will find that, in general, Python provides its own mechanism
    for most common tasks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Python中思想表达的方式，以及其独特的特性。如果你熟悉编程中完成某些任务的标准方式（例如获取列表的最后一个元素、迭代和搜索），或者如果你来自其他编程语言（如C、C++和Java），那么你会发现，总的来说，Python为大多数常见任务提供了自己的机制。
- en: In programming, an idiom is a particular way of writing code in order to perform
    a specific task. It is something common that repeats and follows the same structure
    every time. Some could even argue and call them a pattern, but be careful because
    they are not designed patterns (which we will explore later on). The main difference
    is that design patterns are high-level ideas, independent from the language (sort
    of), but they do not translate into code immediately. On the other hand, idioms
    are actually coded. It is the way things should be written when we want to perform
    a particular task.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，习语是执行特定任务的一种特定的代码编写方式。它是某种常见且每次都遵循相同结构的东西。有些人甚至可以争论并称它们为模式，但请注意，它们不是设计模式（我们将在稍后探讨）。主要区别在于设计模式是高级思想，独立于语言（某种程度上），但它们不能立即转化为代码。另一方面，习语实际上是编码的。这是我们想要执行特定任务时应该编写的方式。
- en: As idioms are code, they are language dependent. Every language will have its
    idioms, which means the way things are done in that particular language (for example,
    how you would open and write a file in C, or C++). When the code follows these
    idioms, it is known as being idiomatic, which in Python is often referred to as
    Pythonic.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 习语是代码，它们是语言相关的。每种语言都会有自己的习语，这意味着在该特定语言中做事的方式（例如，如何在C或C++中打开和写入文件）。当代码遵循这些习语时，它被称为是idiomatic的，在Python中通常被称为Pythonic。
- en: There are multiple reasons to follow these recommendations and write Pythonic
    code first (as we will see and analyze), since writing code in an idiomatic way
    usually performs better. It is also more compact and easier to understand. These
    are traits that we always want in our code so that it works effectively.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个原因需要遵循这些建议并首先编写Pythonic代码（正如我们将看到和分析的那样），因为以习惯的方式编写代码通常性能更好。它也更紧凑，更容易理解。这些是我们总希望在代码中实现的特性，以便它能够有效工作。
- en: Secondly, as introduced in the previous chapter, it is important that the entire
    development team can get used to the same patterns and structure of the code because
    this will help them focus on the true essence of the problem, and will help them
    avoid making mistakes.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，正如前一章所介绍的，整个开发团队能够习惯相同的代码模式和结构是很重要的，因为这将帮助他们专注于问题的真正本质，并帮助他们避免犯错误。
- en: 'The goals of this chapter are as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标如下：
- en: To understand indices and slices, and correctly implement objects that can be indexed
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解索引和切片，并正确实现可索引的对象
- en: To implement sequences and other iterables
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现序列和其他可迭代对象
- en: To learn about good use cases for context managers, and how to write effective
    ones.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解上下文管理器的良好用例以及如何编写有效的上下文管理器。
- en: To implement more idiomatic code through magic methods
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过魔术方法实现更符合习惯的代码
- en: To avoid common mistakes in Python that lead to undesired side effects
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免导致不期望副作用在Python中的常见错误
- en: We start by exploring the first item on the list (indexes and slices) in the
    next section.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中探索列表上的第一个项目（索引和切片）。
- en: Indexes and slices
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引和切片
- en: In Python, as in other languages, some data structures or types support accessing
    its elements by index. Another thing it has in common with most programming languages
    is that the first element is placed in the index number `0`. However, unlike those
    languages, when we want to access the elements in a different order than usual,
    Python provides extra features.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，和其他语言一样，一些数据结构或类型支持通过索引访问其元素。它与其他大多数编程语言的另一个共同点是，第一个元素被放置在索引号`0`。然而，与这些语言不同，当我们想以不同于常规的顺序访问元素时，Python提供了额外的功能。
- en: 'For example, how would you access the last element of an array in C? This is
    something I did the first time I tried Python. Thinking the same way as in C,
    I would get the element in the position of the length of the array minus one.
    In Python, this would work too, but we could also use a negative index number,
    which will start counting from the last element, as shown in the following commands:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您如何在 C 中访问数组的最后一个元素？这是我第一次尝试 Python 时做的事情。像在 C 中一样思考，我会获取数组长度减一的元素位置。在 Python
    中，这也会起作用，但我们也可以使用负索引号，它将从最后一个元素开始计数，如下面的命令所示：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is an example of the preferred (Pythonic) way of doing things.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种首选的（Pythonic）做事方式。
- en: 'In addition to getting just one element, we can obtain many by using `slice`,
    as shown in the following commands:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 除了获取单个元素之外，我们还可以通过使用 `slice` 来获取多个元素，如下面的命令所示：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this case, the syntax on the square brackets means that we get all of the
    elements on the tuple, starting from the index of the first number (inclusive),
    up to the index on the second one (not including it). Slices work this way in
    Python by excluding the end of the selected interval.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，方括号上的语法意味着我们从第一个数字（包含）的索引开始获取元组上的所有元素，直到第二个数字的索引（不包含）。Python 中的切片就是这样工作的，通过排除所选区间的结束。
- en: 'You can exclude either one of the intervals, start or stop, and in that case,
    it will act from the beginning or end of the sequence, respectively, as shown
    in the following commands:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以排除任一区间，即起始或结束，在这种情况下，它将分别从序列的开始或结束处开始，如下面的命令所示：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the first example, it will get everything up to the index in the position
    number `3`. In the second example, it will get all the numbers from the position
    `3` (inclusive), up to the end. In the second to last example, where both ends
    are excluded, it is actually creating a copy of the original tuple.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，它将获取到位置编号 `3` 的所有内容。在第二个例子中，它将获取从位置 `3`（包含）开始的所有数字，直到末尾。在倒数第二个例子中，当两端都排除时，实际上是在创建原始元组的副本。
- en: The last example includes a third parameter, which is the step. This indicates
    how many elements to jump when iterating over the interval. In this case, it would
    mean getting the elements between the positions one and seven, jumping by two.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个例子包括一个第三个参数，即步长。这表示在迭代区间时跳过的元素数量。在这种情况下，这意味着获取位置一和七之间的元素，每次跳过两个。
- en: 'In all of these cases, when we pass intervals to a sequence, what is actually
    happening is that we are passing `slice`. Note that `slice` is a built-in object
    in Python that you can build yourself and pass directly:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些情况下，当我们向一个序列传递区间时，实际上我们传递的是 `slice`。请注意，`slice` 是 Python 中的一个内置对象，您可以自己构建并直接传递：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that when one of the elements is missing (start, stop, or step), it is
    considered to be `None`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当一个元素缺失（起始、结束或步长）时，它被视为 `None`。
- en: You should always prefer to use this built-in syntax for slices, as opposed
    to manually trying to iterate the tuple, string, or list inside a `for` loop,
    excluding the elements by hand.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该始终优先使用这种内置的切片语法，而不是手动在 `for` 循环中迭代元组、字符串或列表，并手动排除元素。
- en: Creating your own sequences
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自己的序列
- en: The functionality we just discussed works, thanks to a magic method (magic methods
    are those surrounded by double underscores that Python uses to reserve special
    behavior) called `__getitem__`. This is the method that is called when something
    like `myobject[key]` is called, passing the `key` (value inside the square brackets)
    as a parameter. A sequence, in particular, is an object that implements both `__getitem__`
    and `__len__`, and for this reason, it can be iterated over. Lists, tuples, and
    strings are examples of sequence objects in the standard library.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才讨论的功能之所以有效，是因为一个名为 `__getitem__` 的魔法方法（魔法方法是 Python 用来保留特殊行为的双下划线包围的方法）。这是当调用类似
    `myobject[key]` 的内容时调用的方法，将 `key`（方括号内的值）作为参数传递。特别是，序列是一个实现了 `__getitem__` 和 `__len__`
    的对象，因此它可以被迭代。列表、元组和字符串是标准库中的序列对象示例。
- en: In this section, we care more about getting particular elements from an object
    by a key than building sequences or iterable objects, which is a topic explored
    in *Chapter 7*, *Generators, Iterators, and Asynchronous Programming*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们更关注通过键从一个对象中获取特定元素，而不是构建序列或可迭代对象，这是在 *第 7 章*，*生成器、迭代器和异步编程* 中探讨的主题。
- en: If you are going to implement `__getitem__` in a custom class in your domain,
    you will have to take into account some considerations in order to follow a Pythonic
    approach.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算在你的领域中的自定义类中实现 `__getitem__`，你必须考虑到一些因素，以便遵循 Pythonic 方法。
- en: 'In the case that your class is a wrapper around a standard library object,
    you might as well delegate the behavior as much as possible to the underlying
    object. This means that if your class is actually a wrapper on the list, call
    all of the same methods on that list to make sure that it remains compatible.
    In the following listing, we can see an example of how an object wraps a list,
    and for the methods we are interested in, we just delegate to its corresponding
    version on the `list` object:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的类是标准库对象包装器的情况下，你可以尽可能地将行为委托给底层对象。这意味着如果你的类实际上是列表的包装器，那么在列表上调用所有相同的方法，以确保它保持兼容。在下面的列表中，我们可以看到一个对象如何包装列表的例子，并且对于我们感兴趣的方法，我们只是委托给
    `list` 对象的相应版本：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To declare that our class is a sequence, it implements the `Sequence` interface
    from the `collections.abc` module ([https://docs.python.org/3/library/collections.abc.html](https://docs.python.org/3/library/collections.abc.html)).
    For the classes you write that are intended to behave as standard types of objects
    (containers, mappings, and so on), it's a good idea to implement the interfaces
    from this module, because that reveals the intention of what that class is meant
    to be, and also because using the interfaces will force you to implement the required
    methods.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了声明我们的类是一个序列，它实现了 `collections.abc` 模块中的 `Sequence` 接口（[https://docs.python.org/3/library/collections.abc.html](https://docs.python.org/3/library/collections.abc.html)）。对于你编写的旨在作为标准类型对象（容器、映射等）行为的类，实现此模块中的接口是一个好主意，因为这揭示了该类意图成为什么，并且因为使用接口将迫使你实现所需的方法。
- en: This example uses composition (because it contains an internal collaborator
    that is a list, rather than inheriting from the list class). Another way of doing
    it is through class inheritance, in which case we will have to extend the `collections.UserList`
    base class, with the considerations and caveats mentioned in the last part of
    this chapter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子使用了组合（因为它包含一个内部协作者，即列表，而不是从列表类继承）。另一种方法是通过类继承来实现，在这种情况下，我们将不得不扩展 `collections.UserList`
    基类，考虑到本章最后部分提到的考虑事项和警告。
- en: 'If, however, you are implementing your own sequence that is not a wrapper or
    does not rely on any built-in object underneath, then keep in mind the following
    points:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你正在实现自己的序列，它不是一个包装器或者不依赖于任何内置对象，那么请记住以下要点：
- en: When indexing by a range, the result should be an instance of the same type
    of the class
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当通过范围索引时，结果应该是与类相同类型的实例
- en: In the range provided by `slice`, respect the semantics that Python uses, excluding
    the element at the end
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `slice` 提供的范围内，尊重 Python 使用的语义，不包括末尾的元素
- en: 'The first point is a subtle error. Think about it—when you get a slice of a
    list, the result is a list; when you ask for a range in a tuple, the result is
    a tuple; and when you ask for a substring, the result is a string. It makes sense
    in each case that the result is of the same type as the original object. If you
    are creating, let''s say, an object that represents an interval of dates, and
    you ask for a range on that interval, it would be a mistake to return a list or
    tuple, or something else. Instead, it should return a new instance of the same
    class with the new interval set. The best example of this is in the standard library,
    with the `range` function. If you call `range` with an interval, it will construct
    an iterable object that knows how to produce the values in the selected range.
    When you specify an interval for `range`, you get a new range (which makes sense),
    not a list:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个要点是一个微妙的错误。想想看——当你从列表中获取一个切片时，结果是列表；当你在一个元组中请求一个范围时，结果是元组；当你请求一个子字符串时，结果是字符串。在每种情况下，结果与原始对象相同类型是有意义的。如果你创建的是代表日期区间的对象，比如说，并且你请求该区间的范围，返回列表或元组或其他东西将是一个错误。相反，它应该返回一个新的具有新区间设置的相同类的实例。标准库中的最佳例子是
    `range` 函数。如果你用区间调用 `range`，它将构造一个知道如何产生选定范围内值的可迭代对象。当你为 `range` 指定区间时，你得到一个新的范围（这是有意义的），而不是列表：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The second rule is also about consistency—users of your code will find it more
    familiar and easier to use if it is consistent with Python itself. As Python developers,
    we are already used to the idea of how the slices work, how the `range` function
    works, and so on. Making an exception on a custom class will create confusion,
    which means that it will be harder to remember, and it might lead to bugs.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条规则也是关于一致性——如果你的代码与Python本身保持一致，那么用户会发现它更加熟悉且易于使用。作为Python开发者，我们已经习惯了切片的工作方式，`range`函数的工作方式等等。在自定义类上创建异常将会造成混淆，这意味着它将更难记住，并可能导致错误。
- en: Now that we know about indices and slices, and how to create our own, in the
    next section, we'll take the same approach but for context managers. First, we'll
    see how context managers from the standard library work, and then we'll go to
    the next level and create our own.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了索引和切片，以及如何创建自己的，在下一节中，我们将采取相同的方法，但针对上下文管理器。首先，我们将看到标准库中的上下文管理器是如何工作的，然后我们将进一步深入，创建自己的上下文管理器。
- en: Context managers
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上下文管理器
- en: Context managers are a distinctively useful feature that Python provides. The
    reason why they are so useful is that they correctly respond to a pattern. There
    are recurrent situations in which we want to run some code that has preconditions
    and postconditions, meaning that we want to run things before and after a certain
    main action, respectively. Context managers are great tools to use in those situations.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文管理器是Python提供的一个独特且非常有用的特性。它们之所以如此有用，是因为它们正确地响应了一个模式。在许多情况下，我们想要运行一些具有前置条件和后置条件的代码，这意味着我们希望在某个主要操作之前和之后运行某些事情。上下文管理器是处理这些情况时的优秀工具。
- en: Most of the time, we see context managers around resource management. For example,
    in situations when we open files, we want to make sure that they are closed after
    processing (so we do not leak file descriptors). Or, if we open a connection to
    a service (or even a socket), we also want to be sure to close it accordingly,
    or when dealing with temporary files, and so on.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，我们看到上下文管理器都与资源管理相关。例如，在打开文件的情况下，我们想要确保在处理完毕后关闭它们（这样我们就不泄漏文件描述符）。或者，如果我们打开到服务的连接（甚至是一个套接字），我们也想要确保相应地关闭它，或者处理临时文件等情况。
- en: 'In all of these cases, you would normally have to remember to free all of the
    resources that were allocated and that is just thinking about the best case—but
    what about exceptions and error handling? Given the fact that handling all possible
    combinations and execution paths of our program makes it harder to debug, the
    most common way of addressing this issue is to put the cleanup code on a `finally`
    block so that we are sure we do not miss it. For example, a very simple case would
    look like the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些情况下，你通常都需要记住释放所有已分配的资源，这只是在考虑最佳情况——但是关于异常和错误处理呢？考虑到处理我们程序的所有可能的组合和执行路径会使调试变得更加困难，解决这个问题的最常见方式是将清理代码放在`finally`块中，这样我们就可以确保不会遗漏它。例如，一个非常简单的例子可能如下所示：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Nonetheless, there is a much more elegant and Pythonic way of achieving the
    same thing:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，有一种更加优雅且Python风格的实现相同功能的方法：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `with` statement (PEP-343) enters the context manager. In this case, the
    `open` function implements the context manager protocol, which means that the
    file will be automatically closed when the block is finished, even if an exception
    occurred.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`with`语句（PEP-343）进入上下文管理器。在这种情况下，`open`函数实现了上下文管理器协议，这意味着当块执行完毕时，文件将被自动关闭，即使发生了异常。'
- en: 'Context managers consist of two magic methods: `__enter__` and `__exit`__.
    On the first line of the context manager, the `with` statement will call the first
    method, `__enter__`, and whatever this method returns will be assigned to the
    variable labeled after `as`. This is optional—we don''t really need to return
    anything specific on the `__enter__` method, and even if we do, there is still
    no strict reason to assign it to a variable if it is not required.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文管理器由两个魔法方法组成：`__enter__`和`__exit__`。在上下文管理器的第一行，`with`语句将调用第一个方法`__enter__`，并且这个方法返回的任何内容都将被分配给`as`后面的变量。这是可选的——我们实际上并不需要在`__enter__`方法上返回任何特定内容，即使我们返回了，如果没有必要，也没有严格理由将其分配给变量。
- en: After this line is executed, the code enters a new context, where any other
    Python code can be run. After the last statement on that block is finished, the
    context will be exited, meaning that Python will call the `__exit__` method of
    the original context manager object we first invoked.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这一行后，代码进入一个新的上下文，其中可以运行任何其他Python代码。在该块的最后一个语句完成后，上下文将退出，这意味着Python将调用最初调用的原始上下文管理器对象的`__exit__`方法。
- en: If there is an exception or error inside the context manager block, the `__exit__`
    method will still be called, which makes it convenient for safely managing the
    cleaning up of conditions. In fact, this method receives the exception that was
    triggered on the block in case we want to handle it in a custom fashion.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上下文管理器块内部有异常或错误，`__exit__`方法仍然会被调用，这使得安全地管理清理条件变得方便。实际上，该方法接收在块上触发的异常，以防我们想要以自定义方式处理它。
- en: Despite the fact that context managers are very often found when dealing with
    resources (like the example we mentioned with files, connections, and so on),
    this is not the sole application they have. We can implement our own context managers
    in order to handle the particular logic we need.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管上下文管理器在处理资源（如我们提到的文件、连接等）时非常常见，但这并不是它们唯一的用途。我们可以实现自己的上下文管理器来处理我们需要的特定逻辑。
- en: Context managers are a good way of separating concerns and isolating parts of
    the code that should be kept independent, because if we mix them, then the logic
    will become harder to maintain.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文管理器是一种很好的分离关注点和隔离应该保持独立的代码部分的方法，因为如果我们混合它们，逻辑将变得难以维护。
- en: As an example, consider a situation where we want to run a backup of our database
    with a script. The caveat is that the backup is offline, which means that we can
    only do it while the database is not running, and for this we have to stop it.
    After running the backup, we want to make sure that we start the process again,
    regardless of how the process of the backup itself went.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一种情况，我们想要使用脚本运行数据库的备份。需要注意的是，备份是离线的，这意味着我们只能在数据库不运行时进行备份，为此我们必须停止它。在运行备份后，我们想要确保无论备份本身的过程如何，我们都重新启动这个过程。
- en: 'Now, the first approach would be to create a huge monolithic function that
    tries to do everything in the same place, stop the service, perform the backup
    task, handle exceptions and all possible edge cases, and then try to restart the
    service again. You can imagine such a function, and for that reason, I will spare
    you the details, and instead come up directly with a possible way of tackling
    this issue with context managers:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，第一种方法可能是创建一个巨大的单体函数，试图在同一个地方做所有的事情，停止服务，执行备份任务，处理异常和所有可能的边缘情况，然后再次尝试重新启动服务。你可以想象这样的函数，因此，我将省略细节，直接提出一个使用上下文管理器处理这个问题的可能方法：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, we don't need the result of the context manager inside the
    block, and that's why we can consider that, at least for this particular case,
    the return value of `__enter__` is irrelevant. This is something to take into
    consideration when designing context managers—what do we need once the block is
    started? As a general rule, it should be good practice (although not mandatory)
    to always return something on `__enter__`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们不需要在块内部上下文管理器的结果，这就是为什么我们可以认为，至少在这个特定情况下，`__enter__`的返回值是不相关的。在设计上下文管理器时，这是需要考虑的——一旦块开始，我们需要什么？作为一个一般规则，始终在`__enter__`上返回某些内容应该是一个好的实践（尽管不是强制性的）。
- en: In this block, we only run the task for the backup, independently from the maintenance
    tasks, as we saw previously. We also mentioned that even if the backup task has
    an error, `__exit__` will still be called.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个块中，我们只运行备份任务，独立于之前看到的维护任务。我们还提到，即使备份任务有错误，`__exit__`仍然会被调用。
- en: Notice the signature of the `__exit__` method. It receives the values for the
    exception that was raised on the block. If there was no exception on the block,
    they are all none.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`__exit__`方法的签名。它接收在块上引发的异常的值。如果没有在块上引发异常，它们都是none。
- en: 'The return value of `__exit__` is something to consider. Normally, we would
    want to leave the method as it is, without returning anything in particular. If
    this method returns `True`, it means that the exception that was potentially raised
    will not propagate to the caller and will stop there. Sometimes, this is the desired
    effect, maybe even depending on the type of exception that was raised, but in
    general, it is not a good idea to swallow the exception. Remember: errors should
    never pass silently.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`__exit__` 的返回值是值得考虑的。通常情况下，我们希望方法保持原样，不返回任何特定内容。如果这个方法返回 `True`，这意味着可能抛出的异常将不会传播到调用者，并在这里停止。有时，这可能是一个期望的效果，甚至可能取决于抛出的异常类型，但总的来说，吞下异常并不是一个好主意。记住：错误永远不应该无声无息地通过。'
- en: Keep in mind not to accidentally return `True` on `__exit__`. If you do, make
    sure that this is exactly what you want, and that there is a good reason for it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，不要意外地在 `__exit__` 上返回 `True`。如果你这样做，请确保这正是你想要的，并且有充分的理由。
- en: Implementing context managers
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现上下文管理器
- en: In general, we can implement context managers like the one in the previous example.
    All we need is just a class that implements the `__enter__` and `__exit__` magic
    methods, and then that object will be able to support the context manager protocol.
    While this is the most common way for context managers to be implemented, it is
    not the only one.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们可以像上一个示例那样实现上下文管理器。我们需要的只是一个实现了 `__enter__` 和 `__exit__` 魔法方法的类，然后那个对象将能够支持上下文管理器协议。虽然这是上下文管理器实现的最常见方式，但并非唯一方式。
- en: In this section, we will see not only different (sometimes more compact) ways
    of implementing context managers, but also how to take full advantage of them
    by using the standard library, in particular with the `contextlib` module.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到不同的（有时更紧凑的）实现上下文管理器的方法，以及如何通过使用标准库充分利用它们，特别是使用 `contextlib` 模块。
- en: The `contextlib` module contains a lot of helper functions and objects to either
    implement context managers or use ones already provided that can help us write
    more compact code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`contextlib` 模块包含许多辅助函数和对象，用于实现上下文管理器或使用已提供的上下文管理器，这可以帮助我们编写更紧凑的代码。'
- en: Let's start by looking at the `contextmanager` decorator.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看 `contextmanager` 装饰器。
- en: When the `contextlib.contextmanager` decorator is applied to a function, it
    converts the code on that function into a context manager. The function in question
    has to be a particular kind of function called a `generator` function, which will
    separate the statements into what is going to be on the `__enter__` and `__exit__`
    magic methods, respectively.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `contextlib.contextmanager` 装饰器应用于一个函数时，它将那个函数上的代码转换为一个上下文管理器。所涉及的函数必须是一种特定的函数，称为
    `generator` 函数，它将语句分别分离到 `__enter__` 和 `__exit__` 魔法方法上。
- en: If, at this point, you are not familiar with decorators and generators, this
    is not a problem because the examples we will be looking at will be self-contained,
    and the recipe or idiom can be applied and understood regardless. These topics
    are discussed in detail in *Chapter 7*, *Generators, Iterators, and Asynchronous
    Programming*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果到目前为止你对装饰器和生成器还不熟悉，这不是问题，因为我们将要查看的示例将是自包含的，无论这些主题是否被讨论，都可以应用和理解的。这些主题在 *第7章*，*生成器、迭代器和异步编程*
    中有详细讨论。
- en: 'The equivalent code of the previous example can be rewritten with the `contextmanager`
    decorator like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个示例的等效代码可以用 `contextmanager` 装饰器重写，如下所示：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we define the `generator` function and apply the `@contextlib.contextmanager`
    decorator to it. The function contains a `yield` statement, which makes it a `generator`
    function. Again, details on generators are not relevant in this case. All we need
    to know is that when this decorator is applied, everything before the `yield`
    statement will be run as if it were part of the `__enter__` method. Then, the
    yielded value is going to be the result of the context manager evaluation (what
    `__enter__` would return), and what would be assigned to the variable if we chose
    to assign it like `as x`:—in this case, nothing is yielded (which means the yielded
    value will be none, implicitly), but if we wanted to, we could yield a statement
    that will become something we might want to use inside the context manager block.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了 `generator` 函数，并将其应用于 `@contextlib.contextmanager` 装饰器。该函数包含一个 `yield`
    语句，这使得它成为一个生成器函数。再次强调，在这种情况下，生成器的细节并不相关。我们只需要知道，当这个装饰器被应用时，`yield` 语句之前的所有内容都将像它是
    `__enter__` 方法的一部分一样运行。然后，产生的值将是上下文管理器评估的结果（`__enter__` 会返回什么），以及如果我们选择像 `as x`
    一样赋值，将会被分配给变量的值：在这种情况下，没有产生任何内容（这意味着产生的值将是隐式的 none），但如果我们想的话，我们可以产生一个语句，该语句将成为我们可能在上下文管理器块内部使用的某个东西。
- en: At that point, the `generator` function is suspended, and the context manager
    is entered, where, again, we run the backup code for our database. After this
    completes, the execution resumes, so we can consider that every line that comes
    after the `yield` statement will be part of the `__exit__` logic.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，`generator` 函数被挂起，上下文管理器被进入，在那里，我们再次运行数据库的备份代码。完成此操作后，执行将继续，因此我们可以认为在
    `yield` 语句之后的每一行都将作为 `__exit__` 逻辑的一部分。
- en: Writing context managers like this has the advantage that it is easier to refactor
    existing functions, reuse code, and in general is a good idea when we need a context
    manager that doesn't belong to any particular object (otherwise, you'd be creating
    a "fake" class for no real purpose, in the object-oriented sense).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式编写上下文管理器的好处是，它更容易重构现有函数，重用代码，并且在需要不属于任何特定对象的上下文管理器时，通常是一个好主意（否则，你会在面向对象的意义上创建一个“虚假”类，没有任何实际目的）。
- en: Adding the extra magic methods would make another object of our domain more
    coupled, with more responsibilities, and supporting something that it probably
    shouldn't. When we just need a context manager function, without preserving many
    states, and completely isolated and independent from the rest of our classes,
    this is probably a good way to go.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 添加额外的魔法方法会使我们领域的另一个对象更加耦合，承担更多的责任，并支持它可能不应该支持的东西。当我们只需要一个不保留许多状态的上下文管理器函数，并且完全独立于其他类时，这可能是一个不错的选择。
- en: There are, however, more ways in which we can implement context manager, and
    once again, the answer is in the `contextlib` package from the standard library.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还有更多实现上下文管理器的方法，而且答案再次在标准库的 `contextlib` 包中。
- en: Another helper we could use is `contextlib.ContextDecorator`. This is a base
    class that provides the logic for applying a decorator to a function that will
    make it run inside the context manager. The logic for the context manager itself
    has to be provided by implementing the aforementioned magic methods. The result
    is a class that works as a decorator for functions, or that can be mixed into
    the class hierarchy of other classes to make them behave as context managers.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用另一个辅助工具 `contextlib.ContextDecorator`。这是一个基类，它提供了将装饰器应用于函数的逻辑，使得该函数可以在上下文管理器中运行。上下文管理器本身的逻辑必须通过实现上述魔法方法来提供。结果是，一个既可以作为函数装饰器使用，也可以混合到其他类的类层次结构中，使它们表现得像上下文管理器的类。
- en: 'In order to use it, we have to extend this class and implement the logic on
    the required methods:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用它，我们必须扩展这个类并在所需的方法上实现逻辑：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Do you notice something different from the previous examples? There is no `with`
    statement. We just have to call the function, and `offline_backup()` will automatically
    run inside a context manager. This is the logic that the base class provides to
    use it as a decorator that wraps the original function so that it runs inside
    a context manager.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到与前面的例子有什么不同？没有 `with` 语句。我们只需要调用函数，`offline_backup()` 将会自动在上下文管理器中运行。这正是基类提供的逻辑，以便将其用作装饰器，将原始函数包装起来，使其在上下文管理器中运行。
- en: The only downside of this approach is that by the way the objects work, they
    are completely independent (which is a good trait)—the decorator doesn't know
    anything about the function that is decorating, and vice versa. This, however
    good, means that the `offline_backup` function cannot access the decorator object,
    should this be needed. However, nothing is stopping us from still calling this
    decorator inside the function to access the object.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的唯一缺点是，由于对象的工作方式，它们是完全独立的（这是一个好的特性）——装饰器不知道被装饰的函数，反之亦然。然而，这虽然好，意味着`offline_backup`函数无法访问装饰器对象，如果需要的话。然而，这并没有阻止我们在函数内部调用这个装饰器来访问对象。
- en: 'This can be done in the following form:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过以下形式完成：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Being a decorator, this also has the advantage that the logic is defined only
    once, and we can reuse it as many times as we want by simply applying the decorators
    to other functions that require the same invariant logic.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 作为装饰器，这也具有优势，即逻辑只定义一次，我们可以通过简单地将装饰器应用于需要相同不变逻辑的其他函数来重复使用它任意多次。
- en: Let's explore one last feature of `contextlib`, to see what we can expect from
    context managers and get an idea of the sort of thing we could use them for.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索`contextlib`的一个最后特性，看看我们可以期待从上下文管理器中得到什么，以及我们可以用它们做什么。
- en: In this library, we can find `contextlib.suppress`, which is a utility to avoid
    certain exceptions in situations where we know it is safe to ignore them. It's
    similar to running that same code on a `try/except` block and passing an exception
    or just logging it, but the difference is that calling the `suppress` method makes
    it more explicit that those exceptions are controlled as part of our logic.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个库中，我们可以找到`contextlib.suppress`，这是一个在已知可以安全忽略异常的情况下避免某些异常的实用工具。它与在`try/except`块中运行相同代码并传递异常或只是记录日志类似，但不同之处在于调用`suppress`方法使得那些异常作为我们逻辑的一部分被控制得更加明确。
- en: 'For example, consider the following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下代码：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, the presence of the exception means that the input data is already in
    the expected format, so there is no need for conversion, hence making it safe
    to ignore it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，异常的存在意味着输入数据已经处于预期的格式，因此不需要转换，因此可以安全地忽略它。
- en: Context managers are quite a peculiar feature that differentiates Python. Therefore,
    using context managers can be considered idiomatic. In the next section, we explore
    another interesting trait of Python that will help us write more concise code;
    comprehensions and assignment expressions.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文管理器是Python的一个相当独特的特性，它区分了Python。因此，使用上下文管理器可以被认为是惯用的。在下一节中，我们将探讨Python的另一个有趣特性，这将帮助我们编写更简洁的代码；理解表达式和赋值表达式。
- en: Comprehensions and assignment expressions
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解和赋值表达式
- en: We will see comprehension expressions many times throughout the book. This is
    because they're usually a more concise way of writing code, and in general, code
    written this way tends to be easier to read. I say in general, because sometimes
    if we need to do some transformations on the data we're collecting, using a comprehension
    might lead to some more complicated code. In these cases, writing a simple `for`
    loop should be preferred instead.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们会多次看到理解表达式。这是因为它们通常是一种更简洁的编写代码的方式，而且一般来说，以这种方式编写的代码更容易阅读。我这么说是因为有时如果我们需要对收集到的数据进行一些转换，使用理解可能会导致一些更复杂的代码。在这些情况下，编写一个简单的`for`循环应该更受欢迎。
- en: 'There is, however, one last resort we could apply to try to salvage the situation:
    assignment expressions. In this section, we discuss these alternatives.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还有一个最后的手段可以尝试来挽救情况：赋值表达式。在本节中，我们将讨论这些替代方案。
- en: 'The use of comprehensions is recommended to create data structures in a single
    instruction, instead of multiple operations. For example, if we wanted to create
    a list with calculations over some numbers in it, instead of writing it like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐使用理解来在单个指令中创建数据结构，而不是多个操作。例如，如果我们想创建一个包含某些数字计算的列表，而不是像这样编写：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We would create the list directly:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将直接创建列表：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Code written in this form usually performs better because it uses a single Python
    operation, instead of calling `list.append` repeatedly. If you are curious about
    the internals or differences between different versions of the code, you can check
    out the `dis` module, and call it with these examples.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种形式编写的代码通常性能更好，因为它使用单个Python操作，而不是反复调用`list.append`。如果你对代码的内部结构或不同版本之间的差异感兴趣，可以查看`dis`模块，并用这些示例调用它。
- en: 'Let''s see the example of a function that will take some strings that represent
    resources on a cloud computing environment (for example ARNs), and returns the set
    with the account IDs found on them. Something like this would be the most naïve
    way of writing such a function:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个函数的例子，该函数将接受一些表示云计算环境中资源（例如 ARN）的字符串，并返回包含在其中的账户 ID 的集合。这样的函数可能会写成最简单的方式：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Clearly the code has many lines, and it''s doing something relatively simple.
    A reader of this code might get confused by these multiple statements, and perhaps
    inadvertently make a mistake when working with that code. If we could simplify
    it, that would be better. We can achieve the same functionality in fewer lines
    by using a few comprehension expressions in a way that resembles functional programming:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，代码有很多行，并且执行的是相对简单的事情。阅读此代码的读者可能会被这些多个语句搞糊涂，并且在处理该代码时可能会无意中犯错。如果我们能简化它，那就更好了。我们可以通过使用几个类似于函数式编程的推导式来在更少的行中实现相同的功能：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The first line of the function seems similar to applying `map` and `filter`:
    first, we apply the result of trying to match the regular expression to all the
    strings provided, and then we filter those that aren''t `None`. The result is
    an iterator that we will later use to extract the account ID in a set comprehension
    expression.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的第一行看起来类似于应用 `map` 和 `filter`：首先，我们将尝试匹配正则表达式的结果应用于提供的所有字符串，然后过滤掉那些不是 `None`
    的字符串。结果是我们将后来用于在集合推导式中提取账户 ID 的一个迭代器。
- en: 'The previous function should be more maintainable than our first example, but
    still requires two statements. Before Python 3.8, it wasn''t possible to achieve
    a more compact version. But with the introduction of assignment expressions in
    PEP-572 ([https://www.python.org/dev/peps/pep-0572/](https://www.python.org/dev/peps/pep-0572/)),
    we can rewrite this in a single statement:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的功能应该比我们的第一个例子更容易维护，但仍然需要两个语句。在 Python 3.8 之前，无法实现更紧凑的版本。但是，随着 PEP-572（[https://www.python.org/dev/peps/pep-0572/](https://www.python.org/dev/peps/pep-0572/））中引入赋值表达式，我们可以用单个语句重写它：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note the syntax on the third line inside the comprehension. This sets a temporary
    identifier inside the scope, which is the result of applying the regular expression
    to the string, and it can be reused in more parts within the same scope.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在列表推导式中的第三行语法。这在该作用域内设置了一个临时标识符，它是将正则表达式应用于字符串的结果，并且可以在同一作用域内的更多部分重复使用。
- en: In this particular example, it's arguable if the third example is better than
    the second one (but there should be no doubts that both of them are better than
    the first one!). I believe this last example to be more expressive because it
    has fewer indirections in the code, and everything that the reader needs to know
    on how the values are being collected belongs to the same scope.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的例子中，关于第三个例子是否比第二个例子更好（但应该没有疑问，这两个例子都比第一个例子好！）是有争议的。我相信这个最后的例子更具有表达性，因为它在代码中具有更少的间接引用，而且读者需要了解的关于值是如何被收集的信息都属于同一个作用域。
- en: Keep in mind that a more compact code does not always mean better code. If to
    write a one-liner, we have to create a convoluted expression, then it's not worth
    it, and we would be better off with the naïve approach. This is related to the
    *keep it simple* principle that we'll discuss in the next chapter.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，代码更加紧凑并不总是意味着代码更好。如果我们为了写一行代码而不得不创建一个复杂的表达式，那么这就不值得了，我们还不如采用简单的方法。这与我们在下一章将要讨论的“保持简单”原则有关。
- en: Take into consideration the readability of the comprehension expressions, and
    don't force your code to be a one-liner, if this one won't be actually easier
    to understand.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑推导式的可读性，如果这样一行代码实际上不会更容易理解，就不要强迫你的代码成为一行。
- en: Another good reason for using assignment expressions in general (not just in
    comprehensions) is the performance considerations. If we have to use a function
    as part of our transformation logic, we don't want to call that more than is necessary.
    Assigning the result of the function to a temporary identifier (as it's done by
    assignment expressions in new scopes) would be a good optimization technique that,
    at the same time, keeps the code more readable.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用赋值表达式的一般好处（而不仅仅是推导式）还包括性能考虑。如果我们必须将函数作为我们的转换逻辑的一部分，我们不希望调用它比必要的次数更多。将函数的结果分配给一个临时标识符（正如新作用域中的赋值表达式所做的那样）将是一种很好的优化技术，同时也能使代码更具可读性。
- en: Evaluate the performance improvements that can be made by using assignment expressions.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 评估使用赋值表达式所能带来的性能提升。
- en: 'In the next section, we''ll review another idiomatic feature of Python: `properties`.
    Moreover, we''ll discuss the different ways of exposing or hiding data in Python
    objects.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将回顾Python的另一个惯用特性：`属性`。此外，我们还将讨论在Python对象中暴露或隐藏数据的不同方式。
- en: Properties, attributes, and different types of methods for objects
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象的属性、属性和不同类型的方法
- en: All of the properties and functions of an object are `public` in Python, which
    is different from other languages where properties can be `public`, `private`,
    or `protected`. That is, there is no point in preventing caller objects from invoking
    any attributes an object has. This is another difference compared to other programming
    languages in which you can mark some attributes as `private` or `protected`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，一个对象的所有属性和函数都是`公开`的，这与其他语言不同，在其他语言中属性可以是`公开`的、`私有`的或`受保护`的。也就是说，阻止调用者对象调用对象的任何属性是没有意义的。这是与其他编程语言相比的另一个区别，在其他编程语言中，你可以将一些属性标记为`私有`或`受保护`。
- en: There is no strict enforcement, but there are some conventions. An attribute
    that starts with an underscore is meant to be `private` to that object, and we
    expect that no external agent calls it (but again, nothing is preventing this).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有严格的强制执行，但也有一些约定。以下划线开头的属性意味着它是该对象的`私有`属性，我们期望没有外部代理调用它（但同样，没有任何东西阻止这样做）。
- en: Before jumping into the details of `properties`, it's worth mentioning some
    traits of underscores in Python, understanding the convention, and the scope of
    attributes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入`属性`的细节之前，值得提一下Python中下划线的某些特性，理解约定和属性的范畴。
- en: Underscores in Python
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python中的下划线
- en: There are some conventions and implementation details that make use of underscores
    in Python, which is an interesting topic that's worthy of analysis.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，有一些约定和实现细节涉及到下划线的使用，这是一个值得分析的有趣话题。
- en: 'Like we mentioned previously, by default, all attributes of an object are `public`.
    Consider the following example to illustrate this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，默认情况下，一个对象的所有属性都是`公开`的。考虑以下示例来阐述这一点：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, a `Connector` object is created with `source`, and it starts with two
    attributes—the aforementioned `source` and `timeout`. The former is `public` and
    the latter `private`. However, as we can see from the following lines when we
    create an object like this, we can actually access both of them.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个带有`source`的`Connector`对象，它开始时有两个属性——前面提到的`source`和`timeout`。前者是`公开`的，后者是`私有`的。然而，正如我们从以下行中可以看到的，当我们创建这样的对象时，我们实际上可以访问它们。
- en: The interpretation of this code is that `_timeout` should be accessed only within
    `connector` itself and never from a caller. This means that you should organize
    the code in a way so that you can safely refactor the timeout at all of the times
    it's needed, relying on the fact that it's not being called from outside the object
    (only internally), hence preserving the same interface as before. Complying with
    these rules makes the code easier to maintain and more robust because we don't
    have to worry about ripple effects when refactoring the code if we maintain the
    interface of the object. The same principle applies to methods as well.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的解释是，`_timeout`应该只在该`connector`内部访问，永远不要从调用者那里访问。这意味着你应该以这种方式组织代码，以便在需要时安全地重构超时，依赖于它不会被从对象外部调用（只内部调用），从而保持与之前相同的接口。遵守这些规则使得代码更容易维护和更健壮，因为我们不必担心重构代码时的连锁反应，如果我们保持对象的接口。同样的原则也适用于方法。
- en: Classes should only expose those attributes and methods that are relevant to
    an external caller object, namely, entailing its interface. Everything that is
    not strictly part of an object's interface should be kept prefixed with a single
    underscore.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 类应该只暴露与外部调用者对象相关的属性和方法，即其接口。不属于对象接口的任何内容都应该以单个下划线为前缀。
- en: 'Attributes that start with an underscore must be respected as `private` and
    not be called externally. On the other hand, as an exception to this rule, we
    could say that in unit tests, it might be allowed to access internal attributes
    if this makes things easier to test (but note that adhering to this pragmatic
    approach still suffers from the maintainability cost when you decide to refactor
    the main class). However, keep in mind the following recommendation:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下划线开头的属性必须被视为`私有`的，并且不能从外部调用。另一方面，作为这个规则的例外，我们可以说在单元测试中，如果这样做可以使测试更容易进行，那么允许访问内部属性可能是允许的（但请注意，即使遵循这种实用方法，在决定重构主类时，维护成本仍然存在）。然而，请记住以下建议：
- en: Using too many internal methods and attributes could be a sign that the class
    has too many tasks and doesn't comply with the single responsibility principle.
    This could indicate that you need to extract some of its responsibilities into
    more collaborating classes.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用过多的内部方法和属性可能是类承担太多任务且不符合单一职责原则的标志。这可能表明你需要将其部分职责提取到更多协作的类中。
- en: 'Using a single underscore as prefix is the Pythonic way of clearly delimiting
    the interface of an object. There is, however, a common misconception that some
    attributes and methods can be actually made `private`. This is, again, a misconception.
    Let''s imagine that now the `timeout` attribute is defined with a leading double
    underscore instead:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单个下划线作为前缀是Pythonic的方式，可以清楚地界定一个对象接口。然而，有一个常见的误解，即某些属性和方法实际上可以被设置为`私有`。这同样是一个误解。让我们假设现在`timeout`属性是以双下划线开头的：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Some developers use this method to hide some attributes, thinking, like in this
    example, that `timeout` is now `private` and that no other object can modify it.
    Now, take a look at the exception that is raised when trying to access `__timeout`.
    It's `AttributeError`, saying that it doesn't exist. It doesn't say something
    like "this is private" or "this can't be accessed", and so on. It says it does
    not exist. This should give us a clue that, in fact, something different is happening
    and that this behavior is instead just a side effect, but not the real effect
    we want.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者使用这种方法来隐藏一些属性，认为，就像这个例子一样，`timeout`现在是`私有`的，并且没有其他对象可以修改它。现在，看看尝试访问`__timeout`时引发的异常。它是`AttributeError`，表示它不存在。它不会说“这是私有的”或“不能访问”等。它只是说它不存在。这应该给我们一个提示，实际上正在发生的是，实际上发生了不同的事情，这种行为只是副作用，而不是我们真正想要的效果。
- en: 'What''s actually happening is that with the double underscores, Python creates
    a different name for the attribute (this is called name mangling). What it does
    is create the attribute with the following name instead: `"_<class-name>__<attribute-name>"`.
    In this case, an attribute named `''_Connector__timeout''` will be created, and
    this attribute can be accessed (and modified) as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上发生的情况是，使用双下划线，Python为属性创建了一个不同的名字（这被称为名称混淆）。它所做的就是用以下名字创建属性：`"_<类名>__<属性名>"`。在这种情况下，将创建一个名为`'_Connector__timeout'`的属性，并且这个属性可以被访问（并修改）如下：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice the side effect that we mentioned earlier—the attribute still exists,
    only with a different name, and for that reason, the `AttributeError` was raised
    on our first attempt to access it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们之前提到的副作用——属性仍然存在，只是名字不同，因此在我们第一次尝试访问它时引发了`AttributeError`。
- en: The idea of the double underscore in Python is completely different. It was
    created as a means to override different methods of a class that is going to be
    extended several times, without the risk of having collisions with the method
    names. Even that is a too far-fetched use case as to justify the use of this mechanism.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Python中双下划线的概念完全不同。它是作为一种手段被创建的，用于覆盖将要多次扩展的类的不同方法，而不会与方法名发生冲突。即使这个用例也过于牵强，不足以证明使用这种机制是合理的。
- en: Double underscores are a non-Pythonic approach. If you need to define attributes
    as `private`, use a single underscore, and respect the Pythonic convention that
    it is a `private` attribute.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 双下划线不是Pythonic的方法。如果你需要将属性定义为`私有`，请使用单个下划线，并遵守Pythonic约定，即它是一个`私有`属性。
- en: Do not define attributes with leading double underscores.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 不要定义以双下划线开头属性的属性。
- en: By the same token, do not define your own "dunder" methods (methods whose names
    are surrounded by double underscores)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，不要定义自己的“双下划线”方法（方法名被双下划线包围）
- en: Let's now explore the opposite case, that is, when we do want to access some
    attributes of an object that are intended to be `public`. Typically, we'd use
    `properties` for this, which we will explore in the next section.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来探讨相反的情况，即当我们确实想要访问对象的一些旨在为`public`的属性时。通常，我们会使用`properties`来做这件事，我们将在下一节中探讨。
- en: Properties
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性
- en: Typically, in object-oriented design, we create objects to represent an abstraction
    over an entity of the domain problem. In this sense, objects can encapsulate behavior
    or data. And more often than not, the accuracy of the data determines if an object
    can be created or not. That is to say, some entities can only exist for certain
    values of the data, whereas incorrect values shouldn't be allowed.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在面向对象设计中，我们创建对象来表示领域问题实体上的抽象。从这个意义上说，对象可以封装行为或数据。而且，很多时候，数据的准确性决定了对象是否可以创建。也就是说，某些实体只能存在于数据的一定值中，而不正确的值不应被允许。
- en: This is why we create validation methods, typically to be used in the `setter`
    operations. However, in Python, sometimes we can encapsulate these `setter` and
    `getter` methods more compactly by using `properties`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为这个原因，我们创建了验证方法，通常用于`setter`操作。然而，在Python中，有时我们可以通过使用`properties`来更紧凑地封装这些`setter`和`getter`方法。
- en: 'Consider the example of a geographical system that needs to deal with coordinates.
    There is only a certain range of values for which latitude and longitude make
    sense. Outside of those values, a coordinate cannot exist. We can create an object
    to represent a coordinate, but in doing so we must ensure that the values for
    latitude are at all times within the acceptable ranges. And for this we can use
    `properties`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个需要处理坐标的地理系统示例。纬度和经度只有一定范围内的值是有意义的。超出这些值，坐标将无法存在。我们可以创建一个对象来表示坐标，但在这样做的时候，我们必须确保纬度的值始终在可接受的范围内。为此，我们可以使用`properties`：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here, we''re using a property to define the latitude and longitude. In doing
    so, we establish that retrieving any of these attributes will return the internal
    value held in the `private` variables. More importantly, when any user wants to
    modify values for any of these `properties` in the following form:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用一个属性来定义纬度和经度。这样做，我们确立了一个原则，即检索这些属性中的任何一个都将返回内部`private`变量中持有的值。更重要的是，当任何用户想要以下形式修改这些`properties`的值时：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The validation method that's declared with the `@latitude.setter` decorator
    will be automatically (and transparently) invoked, and it will pass the value
    on the right-hand-side of the statement `(<new-latitude-value>`) as the parameter
    (named `lat_value` in the preceding code).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@latitude.setter`装饰器声明的验证方法将被自动（且透明地）调用，并将语句右侧的值（在前面代码中命名为`lat_value`）作为参数传递。
- en: Don't write custom `get_*` and `set_*` methods for all attributes on your objects.
    Most of the time, leaving them as regular attributes is just enough. If you need
    to modify the logic for when an attribute is retrieved or modified, then use `properties`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 不要为你的对象上的所有属性都编写自定义的`get_*`和`set_*`方法。大多数时候，将它们作为常规属性就足够了。如果你需要修改属性检索或修改的逻辑，那么请使用`properties`。
- en: We have seen the case for when an object needs to hold values, and how `properties`
    help us to manage their internal data in a consistent and transparent way, but
    sometimes, we might also need to do some computations based on the state of the
    object and its internal data. Most of the time, properties are a good choice for
    this.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了当对象需要持有值时的情况，以及`properties`如何帮助我们以一致和透明的方式管理它们的内部数据，但有时，我们也可能需要根据对象的状态及其内部数据进行一些计算。大多数时候，属性是这一选择的好选择。
- en: For example, if you have an object that needs to return a value in a particular
    format, or data type, a property can be used to do this computation. In the previous
    example, if we decided that we wanted to return the coordinates with a precision
    of up to four decimal places (regardless of how many decimal places the original
    number was provided with), we can make the computation for rounding this in the
    `@property` method that reads the value.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你有一个需要以特定格式或数据类型返回值的对象，可以使用属性来完成这个计算。在先前的例子中，如果我们决定想要以最多四位小数的精度返回坐标（无论原始数字提供了多少位小数），我们可以在读取值的`@property`方法中进行四舍五入的计算。
- en: You might find that properties are a good way to achieve command and query separation
    (`CC08`). The command and query separation principle states that a method of an
    object should either answer to something or do something, but not both. If a method
    is doing something, and at the same time it returns a status answering a question
    of how that operation went, then it's doing more than one thing, clearly violating
    the principle that says that functions should do one thing, and one thing only.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现属性是实现命令和查询分离（`CC08`）的好方法。命令和查询分离原则指出，一个对象的方法应该要么回答某个问题，要么执行某个操作，但不能两者兼而有之。如果一个方法在执行某个操作的同时返回一个状态，回答该操作如何进行，那么它就做了多于一件事情，明显违反了函数应该只做一件事情的原则。
- en: 'Depending on the name of the method, this can create even more confusion, making
    it harder for readers to understand what the actual intention of the code is.
    For example, if a method is called `set_email`, and we use it as `if self.set_email("a@j.com"):
    ...`, what is that code doing? Is it setting the email to `a@j.com?` Is it checking
    if the email is already set to that value? Both (setting and then checking if
    the status is correct)?'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '根据方法名称，这可能会造成更多的混淆，使读者更难理解代码的实际意图。例如，如果方法名为`set_email`，并且我们将其用作`if self.set_email("a@j.com"):
    ...`，那么这段代码在做什么？它是将电子邮件设置为`a@j.com`吗？它是检查电子邮件是否已经设置为该值吗？两者都是（设置并检查状态是否正确）？'
- en: With `properties`, we can avoid this kind of confusion. The `@property` decorator
    is the query that will answer to something, and `@<property_name>.setter` is the
    command that will do something.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`properties`，我们可以避免这种混淆。`@property`装饰器是查询，将回答某个问题，而`@<property_name>.setter`是执行某个操作的命令。
- en: Another piece of good advice derived from this example is as follows—don't do
    more than one thing in a method. If you want to assign something and then check
    the value, break that down into two or more statements.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中得到的另一条有益的建议如下——不要在一个方法中做超过一件事情。如果你想分配某个值然后检查其值，请将其分解为两个或更多个语句。
- en: 'To illustrate what this means, using the previous example, we would have one
    `setter` or getter method, to set the email of the user, and then another property
    to simply ask for the email. This is because, in general, any time we ask an object
    about its current state, it should return it without side effects (without changing
    its internal representation). Perhaps the only exception I can think of to this
    rule would be in the case of a lazy property: something we want to precompute
    only once, and then use the computed value. For the rest of the cases, try to
    make properties idempotent, and then methods that are allowed to change the internal
    representation of the object, but don''t mix both.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这意味着什么，使用之前的例子，我们可能需要一个`setter`或`getter`方法来设置用户的电子邮件，然后另一个属性来简单地请求电子邮件。这是因为，一般来说，任何时间我们询问一个对象关于其当前状态，它都应该返回它而不产生副作用（不改变其内部表示）。或许我能想到的唯一例外是在懒属性的情况下：我们只想预先计算一次，然后使用计算出的值。对于其他情况，尽量使属性幂等，然后是允许改变对象内部表示的方法，但不要混合两者。
- en: Methods should do one thing only. If you have to run an action and then check
    for the status, do that in separate methods that are called by different statements.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 方法应该只做一件事情。如果你必须执行一个动作然后检查状态，请在由不同语句调用的不同方法中执行。
- en: Creating classes with a more compact syntax
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用更紧凑的语法创建类
- en: 'Continuing with the idea that sometimes, we need objects to hold values, there''s
    a common boilerplate in Python when it comes to the initialization of objects,
    which is to declare in the `__init__` method all attributes that the object will
    have, and then set that to internal variables, typically in the following form:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 继续探讨有时我们需要对象来存储值的思想，在Python中初始化对象时有一个常见的模板，即在`__init__`方法中声明对象将拥有的所有属性，然后将其设置为内部变量，通常如下所示：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Since Python 3.7, we can simplify this by using the `dataclasses` module. This
    has been introduced by PEP-557\. We have seen this module in the previous chapter,
    in the context of using annotations on the code, and here we'll review it briefly
    in terms of how it helps us write more compact code.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 自Python 3.7以来，我们可以通过使用`dataclasses`模块来简化这一点。这个模块是在PEP-557中引入的。我们在上一章中已经看到了这个模块，在代码使用注解的上下文中，在这里我们将简要回顾它，从它如何帮助我们编写更紧凑的代码的角度来看。
- en: This module provides a `@dataclass` decorator, which, when applied to a class,
    it'll take all the class attributes with annotations, and treat them as instance
    attributes, as if they were declared in the initialization method. When using
    this decorator, it will automatically generate the `__init__` method on the class,
    so we don't have to.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块提供了一个`@dataclass`装饰器，当应用于一个类时，它会获取所有带有注释的类属性，并将它们视为实例属性，就像它们在初始化方法中声明一样。当使用此装饰器时，它将自动在类上生成`__init__`方法，因此我们不需要手动编写。
- en: Additionally, this module provides a `field` object that will help us define
    particular traits for some of the attributes. For example, if one of the attributes
    we need needs to be mutable (such as a `list`), we'll see later in the chapter
    (in the section for avoiding caveats in Python) that we cannot pass this default
    empty list in the `__init__` method, and that instead we should pass `None`, and
    set it to a default list inside `__init__`, if `None` was provided.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，此模块提供了一个`field`对象，它将帮助我们定义一些属性的特定特征。例如，如果我们需要的某个属性需要是可变的（例如一个`list`），我们将在本章后面的部分（在避免Python中陷阱的部分）看到，我们不能在`__init__`方法中传递这个默认空列表，而应该传递`None`，并在`__init__`内部将其设置为默认列表，如果提供了`None`。
- en: When using the `field` object, what we would do instead is to use the `default_factory`
    argument, and provide the `list` class to it. This argument is meant to be used
    with a callable that takes no arguments, and will be called to construct the object,
    when nothing is provided for the value of that attribute.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`field`对象时，我们通常会使用`default_factory`参数，并将`list`类传递给它。这个参数是用来与不接受任何参数的可调用对象一起使用的，当该属性的值没有提供时，它将被调用以构造对象。
- en: Because there's no `__init__` method to be implemented, what happens if we need
    to run validations? Or if we want to have some attributes computed or derived
    from previous ones? To answer the latter, we can rely on `properties`, as we have
    just explored in the previous section. As per the former, the data classes allow
    us to have a `__post_init__` method that will be called automatically by `__init__`,
    so this would be a good place to write our logic for post-initialization.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 因为没有需要实现的`__init__`方法，如果我们需要运行验证或者想要有一些属性是从之前的属性计算或派生出来的，会发生什么？为了回答后者，我们可以依赖`properties`，正如我们在上一节中所探讨的。至于前者，数据类允许我们有一个`__post_init__`方法，它将在`__init__`自动调用，所以这是一个编写初始化后逻辑的好地方。
- en: To put all of this into practice, let's consider the example of modeling a node
    for an R-Trie data structure (where R stands for *radix*, which means it is an
    indexed tree over some base R). The details of this data structure, and the algorithms
    associated with it, are beyond the scope of this book, but for the purposes of
    the example, I'll mention that is a data structure designed to answer queries
    over text or strings (such as prefixes, and finding similar or related words).
    In a very basic form, this data structure contains a value (that holds a character,
    and it can be its integer representation, for instance), and then an array or
    length R with references to the next nodes (it's a recursive data structure, in
    the same sense as a `linked list` or a `tree` for example). The idea is that each
    position of the array defines implicitly a reference to the next node. For example,
    imagine the value `0` is mapped to the character `'a'`, then if the next node
    contains a value different than `None` in its `0` position, then this means there's
    a reference for `'a'`, and that points to another R-Trie node.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这些内容付诸实践，让我们考虑一个例子，即建模R-Trie数据结构（其中R代表*基数*，这意味着它是在某个基数R上的索引树）的节点。这个数据结构及其相关算法超出了本书的范围，但为了本例的目的，我将提到这是一个设计用来回答关于文本或字符串的查询（如前缀和查找相似或相关单词）的数据结构。在非常基本的形式中，这个数据结构包含一个值（它保存一个字符，例如它的整数表示），然后是一个长度为R的数组或引用下一个节点（它是一个递归数据结构，与`linked
    list`或`tree`等类似）。其想法是数组的每个位置隐式地定义了对下一个节点的引用。例如，假设值`0`映射到字符`'a'`，那么如果下一个节点在其`0`位置包含一个不同于`None`的值，那么这意味着有一个对`'a'`的引用，并且它指向另一个R-Trie节点。
- en: 'Graphically, the data structure might look something like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 从图形上看，数据结构可能看起来像这样：
- en: '![](img/B16567_02_01.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B16567_02_01.png)'
- en: 'Figure 2.1: Generic structure for an R-Trie node'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：R-Trie节点的通用结构
- en: 'And we could write a code block like the following one to represent it. In
    the following code, the attribute named `next_` contains a trailing underscore,
    just as a way to differentiate it from the built-in `next` function. We can argue
    that in this case, there''s no collision, but if we needed to use the `next()`
    function within the `RTrieNode` class, that could be problematic (and those are
    usually hard-to-catch subtle errors):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写如下代码块来表示它。在下面的代码中，名为`next_`的属性包含一个尾随下划线，这仅仅是为了将其与内置的`next`函数区分开来。我们可以争论说在这种情况下没有冲突，但如果我们需要在`RTrieNode`类中使用`next()`函数，那可能会出现问题（这些通常是难以捕捉的微妙错误）：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding example contains several different combinations. First, we define
    an R-Trie with `R=26` to represent the characters in the English alphabet (this
    is not important to understand the code itself, but it gives more context). The
    idea is that if we want to store a word, we create a node for each letter, starting
    with the first one. When there's a link to the next character, we store it in
    the position of the `next_` array corresponding to that character, another node
    for that one, and so on.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子包含了几种不同的组合。首先，我们定义了一个`R=26`的R-Trie来表示英语字母表中的字符（这本身对于理解代码并不重要，但它提供了更多的上下文）。其想法是，如果我们想存储一个单词，我们为每个字母创建一个节点，从第一个字母开始。当有指向下一个字符的链接时，我们将它存储在对应字符的`next_`数组位置，为该字符创建另一个节点，依此类推。
- en: 'Note the first attribute in the class: `size`. This one doesn''t have an annotation,
    so it''s a regular class attribute (shared for all node objects), and not something
    that belongs exclusively to the object. Alternatively, we could have defined this
    by setting `field(init=False)`, but this form is more compact. However, if we
    wanted to annotate the variable, but not consider it as part of `__init__`, then
    this syntax is the only viable alternative.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意类中的第一个属性：`size`。这个属性没有注释，所以它是一个常规类属性（为所有节点对象共享），而不是仅属于对象的某些东西。或者，我们也可以通过设置`field(init=False)`来定义它，但这个形式更紧凑。然而，如果我们想注释变量，但不将其视为`__init__`的一部分，那么这种语法是唯一可行的替代方案。
- en: 'Then follow two other attributes, both of which have annotations, but with
    different considerations. The first one, `value`, is an integer, but it doesn''t
    have a default argument, so when we create a new node, we must always provide
    a value as a first parameter. The second one is a mutable argument (a `list` of
    itself), and it does have a default factory: in this case a `lambda` function
    that will create a new list of size R, initialized with `None` on all slots. Note
    that if we had used `field(default_factory=list)` for this, we would still have
    constructed a new list for each object on creation, but this loses control over
    the length of that list. And finally, we wanted to validate that we don''t create
    nodes that have a list of next nodes with the wrong length, so this is validated
    in the `__post_init__` method. Any attempt to create such a list will be prevented
    with a `ValueError` at initialization time.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是另外两个属性，它们都有注释，但考虑不同。第一个属性`value`是一个整数，但它没有默认参数，因此当我们创建一个新的节点时，我们必须始终提供一个值作为第一个参数。第二个属性是一个可变参数（它自己的`list`），它确实有一个默认工厂：在这种情况下是一个`lambda`函数，它将创建一个大小为R的新列表，所有槽位都初始化为`None`。注意，如果我们使用`field(default_factory=list)`来处理这个问题，我们仍然会在创建每个对象时构造一个新的列表，但这会失去对该列表长度的控制。最后，我们希望验证我们不会创建具有错误长度的下一个节点列表的节点，因此在`__post_init__`方法中进行了验证。任何尝试创建此类列表的尝试都会在初始化时通过`ValueError`被阻止。
- en: Data classes provide a more compact way of writing classes, without the boilerplate
    of having to set all variables with the same name in the `__init__` method.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类提供了一种更紧凑的方式来编写类，无需在`__init__`方法中设置所有具有相同名称的变量，从而避免了样板代码。
- en: When you have objects that don't do many complex validations or transformations
    on the data, consider this alternative. Keep in mind this last point. Annotations
    are great, but they don't enforce data conversion. This means that for example,
    if you declare an attribute that needs to be a `float`, or an `integer`, then
    you must do this conversion in the `__init__` method. Writing this as a data class
    won't do it, and it might hide subtle errors. This is for cases when validations
    aren't strictly required and type casts are possible. For example, it's perfectly
    fine to define an object that can be created from multiple other types, like converting
    a `float` from a numeric `string` (after all, this leverages Python's dynamic
    typing nature), provided this is correctly converted to the required data type
    within the `__init__` method.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当你拥有不进行许多复杂验证或数据转换的对象时，考虑这个替代方案。记住这个最后一点。注解很棒，但它们不强制数据转换。这意味着例如，如果你声明了一个需要是`float`或`integer`的属性，那么你必须在这个`__init__`方法中执行这个转换。将这个作为数据类是不会做到的，这可能会隐藏微妙的错误。这是在验证不是严格必需且可以进行类型转换的情况下。例如，定义一个可以从多个其他类型创建的对象是完全可以的，比如将一个数字字符串转换为`float`（毕竟，这利用了Python的动态类型特性），只要在`__init__`方法中正确转换为所需的数据类型即可。
- en: Probably a good use case for data classes would be all those places when we
    need to use objects as data containers or wrappers, namely situations on which
    we used named tuples or simple namespaces. Consider data classes as another alternative
    to named tuples or namespaces when you're evaluating options in your code.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类可能是一个很好的用例，所有那些我们需要使用对象作为数据容器或包装器的地方，即我们使用命名元组或简单命名空间的情况。当你评估代码中的选项时，将数据类视为命名元组或命名空间的另一种替代方案。
- en: Iterable objects
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可迭代对象
- en: In Python, we have objects that can be iterated by default. For example, lists,
    tuples, sets, and dictionaries can not only hold data in the structure we want,
    but also be iterated over a `for` loop to get those values repeatedly.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们有默认可迭代的对象。例如，列表、元组、集合和字典不仅可以以我们想要的结构存储数据，还可以通过`for`循环迭代以重复获取这些值。
- en: However, the built-in `iterable` objects are not the only kind that we can have
    in a `for` loop. We could also create our own `iterable`, with the logic we define
    for iteration.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，内置的可迭代对象并不是我们在`for`循环中唯一可以拥有的类型。我们也可以创建自己的可迭代对象，使用我们定义的迭代逻辑。
- en: In order to achieve this, we rely, once again, on magic methods.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们再次依赖于魔法方法。
- en: 'Iteration works in Python by its own protocol (namely the `iterator` protocol).
    When you try to iterate an object in the form `for e in myobject:...`, what Python
    checks at a very high level are the following two things, in order:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，迭代是通过其自身的协议（即迭代器协议）来工作的。当你尝试以`for e in myobject:`的形式迭代一个对象时，Python在非常高的层面上检查以下两个事情，按顺序：
- en: If the object contains one of the iterator methods— `__next__` or `__iter__`
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对象包含迭代器方法之一——`__next__`或`__iter__`
- en: If the object is a sequence and has `__len__` and `__getitem__`
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对象是一个序列并且具有`__len__`和`__getitem__`
- en: Therefore, as a fallback mechanism, sequences can be iterated, and so there
    are two ways of customizing our objects to be able to work on `for` loops.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，作为一个后备机制，序列可以被迭代，因此有两种方式可以自定义我们的对象，使其能够工作在`for`循环中。
- en: Creating iterable objects
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建可迭代对象
- en: When we try to iterate an object, Python will call the `iter()` function over
    it. One of the first things this function checks for is the presence of the `__iter__`
    method on that object, which, if present, will be executed.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试迭代一个对象时，Python会调用该对象的`iter()`函数。这个函数首先检查该对象上是否存在`__iter__`方法，如果存在，则会被执行。
- en: 'The following code creates an object that allows iterating over a range of
    dates, producing one day at a time on every round of the loop:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了一个对象，允许迭代一系列日期，在每次循环迭代中产生一天：
- en: '[PRE25]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This object is designed to be created with a pair of dates, and when iterated,
    it will produce each day in the interval of specified dates, which is shown in
    the following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象被设计成用一对日期创建，当迭代时，它将产生指定日期间隔中的每一天，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, the `for` loop is starting a new iteration over our object. At this point,
    Python will call the `iter()` function on it, which, in turn, will call the `__iter__`
    magic method. On this method, it is defined to return `self`, indicating that
    the object is an `iterable` itself, so at that point every step of the loop will
    call the `next()` function on that object, which delegates to the `__next__` method.
    In this method, we decide how to produce the elements and return one at a time.
    When there is nothing else to produce, we have to signal this to Python by raising
    the `StopIteration` exception.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`for`循环开始在我们的对象上启动新的迭代。在这个点上，Python将调用`iter()`函数，然后它反过来调用`__iter__`魔法方法。在这个方法中，它被定义为返回`self`，这表明对象本身就是一个`iterable`，所以在这个点上，循环的每一步都会调用该对象的`next()`函数，它委托给`__next__`方法。在这个方法中，我们决定如何产生元素，并逐个返回。当没有其他东西可以产生时，我们必须通过引发`StopIteration`异常来向Python发出信号。
- en: 'This means that what is actually happening is similar to Python calling `next()`
    every time on our object until there is a `StopIteration` exception, on which
    it knows it has to stop the `for` loop:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着实际上发生的情况类似于Python每次在我们的对象上调用`next()`，直到出现`StopIteration`异常，这时它知道它必须停止`for`循环：
- en: '[PRE27]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This example works, but it has a small problem—once exhausted, the `iterable`
    will continue to be empty, hence raising `StopIteration`. This means that if we
    use this on two or more consecutive `for` loops, only the first one will work,
    while the second one will be empty:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是可行的，但它有一个小问题——一旦耗尽，`iterable`将继续为空，因此引发`StopIteration`。这意味着如果我们连续使用两个或更多的`for`循环，只有第一个会工作，而第二个将是空的：
- en: '[PRE28]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is because of the way the iteration protocol works—an `iterable` constructs
    an iterator, and this one is the one being iterated over. In our example, `__iter__`
    just returned `self`, but we can make it create a new iterator every time it is
    called. One way of fixing this would be to create new instances of `DateRangeIterable`,
    which is not a terrible issue, but we can make `__iter__` use a generator (which
    are iterator objects), which is being created every time:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为迭代协议的工作方式——一个`iterable`构建一个迭代器，这个迭代器就是正在迭代的。在我们的例子中，`__iter__`只是返回了`self`，但我们可以让它每次被调用时都创建一个新的迭代器。一种修复方法就是创建`DateRangeIterable`的新实例，这并不是一个严重的问题，但我们可以让`__iter__`使用生成器（它们是迭代器对象），每次调用时都会创建：
- en: '[PRE29]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And this time it works:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 而这次它工作了：
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The difference is that each `for` loop is calling `__iter__` again, and each
    one of those is creating the generator again.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 差别在于每个`for`循环都会再次调用`__iter__`，而每一个都会再次创建生成器。
- en: This is called a container `iterable`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为容器`iterable`。
- en: In general, it is a good idea to work with container iterables when dealing
    with generators.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在处理生成器时，与容器`iterable`一起工作是一个好主意。
- en: Details on generators will be explained in more detail in *Chapter 7*, *Generators,
    Iterators, and Asynchronous Programming*.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 关于生成器的详细信息将在*第7章*，*生成器、迭代器和异步编程*中更详细地解释。
- en: Creating sequences
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建序列
- en: Maybe our object does not define the `__iter__()` method, but we still want
    to be able to iterate over it. If `__iter__` is not defined on the object, the
    `iter()` function will look for the presence of `__getitem__`, and if this is
    not found, it will raise `TypeError`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们的对象没有定义`__iter__()`方法，但我们仍然希望能够迭代它。如果`__iter__`在对象上没有定义，`iter()`函数将寻找`__getitem__`的存在，如果没有找到，它将引发`TypeError`。
- en: A sequence is an object that implements `__len__` and `__getitem__` and expects
    to be able to get the elements it contains, one at a time, in order, starting
    at zero as the first index. This means that you should be careful in the logic
    so that you correctly implement `__getitem__` to expect this type of index, or
    the iteration will not work.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 序列是一个实现了`__len__`和`__getitem__`的对象，并期望能够按顺序逐个获取它包含的元素，从零开始作为第一个索引。这意味着你需要在逻辑上小心，以确保正确实现`__getitem__`以期望这种类型的索引，否则迭代将不会工作。
- en: The example from the previous section had the advantage that it uses less memory.
    This means that it is only holding one date at a time and knows how to produce
    the days one by one. However, it has the drawback that if we want to get the n^(th)
    element, we have no way to do so but iterate n-times until we reach it. This is
    a typical trade-off in computer science between memory and CPU usage.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个章节的例子有一个优点，那就是它使用的内存更少。这意味着它一次只保留一个日期，并且知道如何逐个产生日期。然而，它有一个缺点，那就是如果我们想获取第n个元素，我们无法直接获取，只能迭代n次直到达到它。这是计算机科学中内存和CPU使用之间的典型权衡。
- en: The implementation with an `iterable` will use less memory, but it takes up
    to *O(n)* to get an element, whereas implementing a sequence will use more memory
    (because we have to hold everything at once), but supports indexing in constant
    time, *O(1)*.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`iterable`的实现将占用更少的内存，但获取一个元素可能需要到*O(n)*的时间，而实现一个序列将占用更多的内存（因为我们必须一次性保存所有内容），但支持常数时间的索引，*O(1)*。
- en: The preceding notation (for example, *O(n)*) is called asymptotic notation (or
    "big-O" notation) and it describes the order of complexity of the algorithm. At
    a very high level, this means how many operations the algorithm needs to perform
    as a function of the size of the input *(n)*. For more information on this, you
    can check out (ALGO01) listed at the end of the chapter, which contains a detailed
    study of asymptotic notation.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的符号（例如，*O(n)*）被称为渐近符号（或“大O”符号），它描述了算法的复杂度阶数。在非常高的层面上，这意味着算法作为输入大小（*n*）的函数需要执行多少操作。关于这方面的更多信息，你可以查看章节末尾列出的（ALGO01），其中包含对渐近符号的详细研究。
- en: 'This is what the new implementation might look like:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 新的实现可能看起来是这样的：
- en: '[PRE31]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here is how the object behaves:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个对象的行为：
- en: '[PRE32]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding code, we can see that negative indices also work. This is because
    the `DateRangeSequence` object delegates all of the operations to its wrapped
    object (a `list`), which is the best way to maintain compatibility and a consistent
    behavior.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到负索引也有效。这是因为`DateRangeSequence`对象将所有操作委托给其包装对象（一个`list`），这是保持兼容性和一致行为的最优方式。
- en: Evaluate the trade-off between memory and CPU usage when deciding which one
    of the two possible implementations to use. In general, the iteration is preferable
    (and generators even more), but keep in mind the requirements of every case.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 评估在决定使用两种可能实现中的哪一个时，内存和CPU使用之间的权衡。一般来说，迭代是首选的（生成器甚至更好），但要注意每个案例的具体要求。
- en: Container objects
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器对象
- en: Containers are objects that implement a `__contains__` method (that usually
    returns a `Boolean` value). This method is called in the presence of the `in`
    keyword of Python.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是实现了`__contains__`方法的对象（通常返回一个`Boolean`值）。这个方法在Python的`in`关键字存在时被调用。
- en: 'Something like the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 犹如以下内容：
- en: '[PRE33]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When used in Python, becomes this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Python中使用时，变为如下：
- en: '[PRE34]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can imagine how much more readable (and Pythonic!) the code can be when
    this method is properly implemented.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象，当这个方法得到适当实现时，代码将多么易于阅读（并且更符合Python风格）！
- en: 'Let''s say we have to mark some points on a map of a game that has two-dimensional
    coordinates. We might expect to find a function like the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们必须在具有二维坐标的游戏地图上标记一些点。我们可能会期望找到一个如下所示的功能：
- en: '[PRE35]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, the part that checks the condition of the first `if` statement seems convoluted;
    it doesn't reveal the intention of the code, it's not expressive, and worst of
    all it calls for code duplication (every part of the code where we need to check
    the boundaries before proceeding will have to repeat that `if` statement).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，检查第一个`if`语句条件的部分似乎很复杂；它没有揭示代码的意图，它不够表达，最糟糕的是它需要代码重复（在需要检查边界条件再继续的代码的每个部分都将重复那个`if`语句）。
- en: What if the map itself (called `grid` on the code) could answer this question?
    Even better, what if the map could delegate this action to an even smaller (and
    hence more cohesive) object?
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果地图本身（在代码中称为`grid`）能回答这个问题呢？甚至更好，如果地图能将这个动作委托给一个更小（因此更内聚）的对象呢？
- en: 'We could solve this problem in a more elegant way with object-oriented design
    and with the help of a magic method. In this case, we can create a new abstraction
    to represent the limits of the grid, which can be made an object in itself. *Figure
    2.2* helps illustrate the point:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用面向对象设计和魔法方法来更优雅地解决这个问题。在这种情况下，我们可以创建一个新的抽象来表示网格的界限，这可以成为一个对象本身。*图2.2*有助于说明这一点：
- en: '![](img/B16567_02_02.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16567_02_02.png)'
- en: 'Figure 2.2: An example using composition, distributing responsibilities in
    different classes, and using the container magic method'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：使用组合、在不同类中分配责任以及使用容器魔法方法的示例
- en: Parenthetically, I'll mention that it's true that in general, class names refer
    to nouns, and they're usually singular. So, it might sound strange to have a class
    named `Boundaries`, but if we think about it, perhaps for this particular case,
    it makes sense to say that we have an object representing all the boundaries of
    a grid, especially because of the way it's being used (in this case, we're using
    it to validate if a particular coordinate is within those boundaries).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，确实，在一般情况下，类名指的是名词，并且通常是单数。所以，有一个名为`Boundaries`的类可能听起来有些奇怪，但如果我们仔细想想，也许对于这个特定的情况，说我们有一个表示网格所有边界的对象是有意义的，尤其是在它被使用的方式（在这种情况下，我们使用它来验证特定坐标是否在这些边界内）。
- en: 'With this design, we can ask the `map` if it contains a coordinate, and the
    `map` itself can have information about its limit and pass the query down to its
    internal collaborator:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种设计，我们可以询问`map`是否包含一个坐标，并且`map`本身可以有关其限制的信息，并将查询传递给其内部合作者：
- en: '[PRE36]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This code alone is a much better implementation. First, it is doing a simple
    composition and it's using delegation to solve the problem. Both objects are really
    cohesive, having the minimal possible logic; the methods are short, and the logic
    speaks for itself—`coord in self.limits` is pretty much a declaration of the problem
    to solve, expressing the intention of the code.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码本身是一个更好的实现。首先，它正在进行简单的组合，并且使用代理来解决该问题。两个对象都非常内聚，具有尽可能少的逻辑；方法简短，逻辑不言自明——`coord
    in self.limits`几乎就是解决问题的声明，表达了代码的意图。
- en: 'From the outside, we can also see the benefits. It''s almost as if Python is
    solving the problem for us:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 从外部看，我们也能看到好处。几乎就像是Python在为我们解决问题：
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Dynamic attributes for objects
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象的动态属性
- en: It is possible to control the way attributes are obtained from objects by means
    of the `__getattr__` magic method. When we call something like `<myobject>.<myattribute>`,
    Python will look for `<myattribute>` in the dictionary of the object, calling
    `__getattribute__` on it. If this is not found (namely, the object does not have
    the attribute we are looking for), then the extra method, `__getattr__`, is called,
    passing the name of the attribute (myattribute) as a parameter.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`__getattr__`魔法方法来控制从对象中获取属性的方式。当我们调用类似`<myobject>.<myattribute>`的东西时，Python会在对象的字典中查找`<myattribute>`，并对其调用`__getattribute__`。如果找不到（即，对象没有我们正在寻找的属性），那么额外的`__getattr__`方法会被调用，传递属性名（myattribute）作为参数。
- en: By receiving this value, we can control the way things should be returned to
    our objects. We can even create new attributes, and so on.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 通过接收这个值，我们可以控制事物返回给我们的对象的方式。我们甚至可以创建新的属性，等等。
- en: 'In the following listing, the `__getattr__` method is demonstrated:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的列表中，演示了`__getattr__`方法：
- en: '[PRE38]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here are some calls to an object of this class:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些对这个类对象的调用：
- en: '[PRE39]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The first call is straightforward—we just request an attribute that the object
    has and get its value as a result. The second is where this method takes action
    because the object does not have anything called `fallback_test`, so `__getattr__`
    will run with that value. Inside that method, we placed the code that returns
    a string, and what we get is the result of that transformation.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用很简单——我们只是请求对象具有的属性，并得到其值作为结果。第二次调用是这个方法发挥作用的地方，因为对象没有名为`fallback_test`的东西，所以`__getattr__`会运行并带有那个值。在那个方法内部，我们放置了返回字符串的代码，我们得到的是那个转换的结果。
- en: The third example is interesting because a new attribute named `fallback_new`
    is created (actually, this call would be the same as running `dyn.``fallback_new
    = "new value"``)`, so when we request that attribute, notice that the logic we
    put in `__getattr__` does not apply, simply because that code is never called.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个例子很有趣，因为它创建了一个名为`fallback_new`的新属性（实际上，这个调用将与运行`dyn.fallback_new = "new value"`相同）,所以当我们请求这个属性时，请注意，我们在`__getattr__`中放入的逻辑不适用，仅仅是因为那段代码从未被调用。
- en: Now, the last example is the most interesting one. There is a subtle detail
    here that makes a huge difference. Take another look at the code in the `__getattr__`
    method. Notice the exception it raises when the value is not retrievable, `AttributeError`.
    This is not only for consistency (as well as the message in the exception), but
    also required by the built-in `getattr()` function. Had this exception been any
    other, it would raise, and the default value would not be returned.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最后一个例子是最有趣的。这里有一个细微的细节，它产生了巨大的差异。再次看看`__getattr__`方法中的代码。注意当值不可检索时它抛出的异常`AttributeError`。这不仅是为了一致性（以及异常中的消息），也是由内置的`getattr()`函数要求的。如果这个异常是任何其他类型，它都会引发异常，并且不会返回默认值。
- en: Be careful when implementing a method so dynamic as `__getattr__`, and use it
    with caution. When implementing `__getattr__`, raise `AttributeError`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现像`__getattr__`这样动态的方法时要小心，并且要谨慎使用。在实现`__getattr__`时，抛出`AttributeError`。
- en: The `__getattr__` magic method is useful in many situations. It can be used
    to create a proxy to another object. For example, if you're creating a wrapper
    object on top of another one by means of composition, and you want to delegate
    most of the methods to the wrapped object, instead of copying and defining all
    of those methods, you can implement `__getattr__` that will internally call the
    same method on the wrapped object.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`__getattr__`魔法方法在许多情况下都很有用。它可以用来创建另一个对象的代理。例如，如果你通过组合在另一个对象之上创建一个包装对象，并且想要将大多数方法委托给包装对象，而不是复制并定义所有这些方法，你可以实现`__getattr__`，它将内部调用包装对象上的相同方法。'
- en: Another example is when you know you need attributes that are dynamically computed.
    I've used it on a past project working with `GraphQL` ([https://graphql.org/](https://graphql.org/))
    with `Graphene` ([https://graphene-python.org/](https://graphene-python.org/)).
    The way the library worked was by using resolver methods. Basically, every method
    named `resolve_X` was used when property `X` was requested. Since there were already
    domain objects that could resolve each property `X` in the class of the `Graphene`
    object, `__getattr__` was implemented to know where to get each property from,
    without having to write a massive boilerplate code.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是当你知道你需要动态计算属性时。我在一个过去的项目中使用了`GraphQL` ([https://graphql.org/](https://graphql.org/))
    和 `Graphene` ([https://graphene-python.org/](https://graphene-python.org/))，在这个项目中。该库的工作方式是通过使用解析器方法。基本上，每当请求属性`X`时，都会使用名为`resolve_X`的方法。由于已经存在可以解析`Graphene`对象类中每个属性`X`的域对象，因此实现了`__getattr__`来知道从哪里获取每个属性，而不必编写大量的样板代码。
- en: Use the `__getattr__` magic method when you see an opportunity to avoid lots
    of duplicated code and boilerplate, but don't abuse this method, as it'll render
    the code harder to understand and reason about. Keep in mind that having attributes
    that aren't explicitly declared and just appear dynamically will make the code
    harder to understand. When using this method, you're always weighing code compactness
    versus maintainability.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看到避免大量重复代码和样板代码的机会时，使用`__getattr__`魔法方法，但不要滥用这个方法，因为它会使代码更难以理解和推理。记住，具有未显式声明且仅动态出现的属性会使代码更难以理解。使用此方法时，你总是在代码紧凑性和可维护性之间权衡。
- en: Callable objects
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可调用对象
- en: It is possible (and often convenient) to define objects that can act as functions.
    One of the most common applications for this is to create better decorators, but
    it's not limited to that.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 定义可以充当函数的对象是可能的（并且通常很方便）。这种用法最常见的一个应用是创建更好的装饰器，但这并不局限于这一点。
- en: The magic method `__call__` will be called when we try to execute our object
    as if it were a regular function. Every argument passed to it will be passed along
    to the `__call__` method.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试将对象作为普通函数执行时，将调用魔法方法`__call__`。传递给它的每个参数都将传递给`__call__`方法。
- en: The main advantage of implementing functions this way, through objects, is that
    objects have states, so we can save and maintain information across calls. This
    means that using a `callable` object might be a more convenient way of implementing
    functions if we need to maintain an internal state across different calls. Examples
    of this can be functions we would like to implement with memoization, or internal
    caches.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式通过对象实现函数的主要优势是对象具有状态，因此我们可以在调用之间保存和维护信息。这意味着，如果我们需要在不同的调用之间维护内部状态，使用可调用对象可能是一种更方便的实现函数的方法。这种用法的例子包括我们希望实现记忆化的函数或内部缓存。
- en: When we have an object, a statement like this, `object(*args, **kwargs)`, is
    translated in Python to `object.__call__(*args, **kwargs)`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个对象时，像这样的语句`object(*args, **kwargs)`在Python中会被翻译为`object.__call__(*args,
    **kwargs)`。
- en: This method is useful when we want to create callable objects that will work
    as parametrized functions, or in some cases, functions with memory.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要创建作为参数化函数工作的可调用对象，或者在某些情况下具有记忆功能的函数时，这个方法非常有用。
- en: 'The following listing uses this method to construct an object that, when called
    with a parameter, returns the number of times it has been called with the very
    same value:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表使用这种方法构建一个对象，当用参数调用时，返回它被用相同的值调用的次数：
- en: '[PRE40]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Some examples of this class in action are as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个类在实际应用中的几个例子：
- en: '[PRE41]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Later in this book, we will find out that this method comes in handy when creating
    decorators.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后面部分，我们将发现这个方法在创建装饰器时非常有用。
- en: Summary of magic methods
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 魔法方法总结
- en: 'We can summarize the concepts we described in the previous sections in the
    form of a cheat sheet like the one presented as follows. For each action in Python,
    the magic method involved is presented, along with the concept that it represents:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将前几节中描述的概念总结成如下形式的速查表。对于Python中的每个操作，都展示了相关的魔法方法以及它所代表的概念：
- en: '| Statement | Magic method | Behavior |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| 语句 | 魔法方法 | 行为 |'
- en: '| `obj[key]``obj[i:j]``obj[i:j:k]` | `__getitem__(key)` | Subscriptable object
    |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `obj[key]` `obj[i:j]` `obj[i:j:k]` | `__getitem__(key)` | 可索引对象 |'
- en: '| `with obj: ...` | `__enter__ / __exit__` | Context manager |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `with obj: ...` | `__enter__ / __exit__` | 上下文管理器 |'
- en: '| `for i in obj: ...` | `__iter__ / __next__``__len__ / __getitem__` | Iterable
    objectSequence |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `for i in obj: ...` | `__iter__ / __next__ / __len__ / __getitem__` | 可迭代对象序列
    |'
- en: '| `obj.<attribute>` | `__getattr__` | Dynamic attribute retrieval |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `obj.<属性>` | `__getattr__` | 动态属性检索 |'
- en: '| `obj(*args, **kwargs)` | `__call__(*args, **kwargs)` | Callable object |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `obj(*args, **kwargs)` | `__call__(*args, **kwargs)` | 可调用对象 |'
- en: 'Table 2.1: Magic methods and their behavior in Python'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1：魔法方法和它们在Python中的行为
- en: The best way to implement these methods correctly (and to know the set of methods
    that need to be implemented together) is to declare our class to implement the
    corresponding class following the abstract base classes defined in the `collections.abc`
    module ([https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes](https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes)).
    These interfaces provide the methods that need to be implemented, so it'll make
    it easier for you to define the class correctly, and it'll also take care of creating
    the type correctly (something that works well when the `isinstance()` function
    is called on your object).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 正确实现这些方法（以及知道需要一起实现的方法集）的最佳方式是，将我们的类声明为实现`collections.abc`模块中定义的相应抽象基类。这些接口提供了需要实现的方法，这将使你更容易正确地定义类，并且它还会负责正确创建类型（当在对象上调用`isinstance()`函数时，这会工作得很好）。（[https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes](https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes)）
- en: We have seen the main features of Python with respect to its peculiar syntax.
    With the features we have learned (context managers, callable objects, creating
    our own sequences, and suchlike), we are now able to write code that will blend
    well with Python's reserved words (for example, we can use the `with` statements
    with our own context managers, or the `in` operator with a container of our own.)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了Python在特殊语法方面的主要特点。通过我们学到的特性（上下文管理器、可调用对象、创建自己的序列等），我们现在能够编写与Python保留字很好地融合的代码（例如，我们可以使用自己的上下文管理器与`with`语句一起使用，或者使用`in`运算符与自己的容器一起使用。）
- en: 'With practice and experience, you''ll become more fluent with these features
    of Python, until it becomes second nature for you to wrap the logic you''re writing
    behind abstractions with nice and small interfaces. Give it enough time, and the
    reverse effect will take place: Python will start programming you. That is, you''ll
    naturally think of having small, clean interfaces in your programs, so even when
    you''re creating software in a different language, you''ll try to use these concepts.
    For example, if you find yourself programming in, let''s say, Java or C (or even
    Bash), you might identify a scenario where a context manager might be useful.
    Now the language itself might not support this out of the box, but that might
    not stop you from writing your own abstraction that provides similar guarantees.
    And that''s a good thing. It means you have internalized good concepts beyond
    a specific language, and you can apply them in different situations.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实践和经验，你会更加熟练地掌握 Python 的这些特性，直到它们成为你自然的行为，即用良好且小巧的接口将你正在编写的逻辑封装在抽象中。给它足够的时间，反向效果就会发生：Python
    将开始为你编程。也就是说，你会在程序中自然地想到拥有小巧、干净的接口，即使你用不同的语言创建软件，你也会尝试使用这些概念。例如，如果你发现自己正在用，比如说，Java
    或 C（甚至 Bash）编程，你可能会发现一个上下文管理器可能有用的场景。现在，语言本身可能不支持这一点，但这可能不会阻止你编写自己的抽象，提供类似的保证。这是一件好事。这意味着你已经在特定语言之外内化了良好的概念，并且可以在不同的情境中应用它们。
- en: All programming languages have their caveats, and Python is no exception, so
    in order to have a more complete understanding of Python, we'll review some of
    them in the next section.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 所有编程语言都有它们的注意事项，Python 也不例外，因此为了更全面地理解 Python，我们将在下一节中回顾一些注意事项。
- en: Caveats in Python
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 的注意事项
- en: Besides understanding the main features of the language, being able to write
    idiomatic code is also about being aware of the potential problems of some idioms,
    and how to avoid them. In this section, we will explore common issues that might
    cause you long debugging sessions if they catch you off guard.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 除了理解语言的主要特性之外，能够编写惯用代码还意味着要意识到某些惯用语的潜在问题以及如何避免它们。在本节中，我们将探讨一些可能在你没有防备的情况下导致长时间调试会话的常见问题。
- en: Most of the points discussed in this section are things to avoid entirely, and
    I will dare to say that there is almost no possible scenario that justifies the
    presence of the anti-pattern (or idiom, in this case). Therefore, if you find
    this on the code base you are working on, feel free to refactor it in the way
    that is suggested. If you find these traits while doing a code review, this is
    a clear indication that something needs to change.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论的大部分内容都是应该完全避免的事项，我甚至敢说几乎没有任何可能的情况可以证明这种反模式（或成语，在这种情况下）的存在是合理的。因此，如果你在你正在工作的代码库中发现了这种情况，请随意按照建议的方式进行重构。如果你在代码审查过程中发现了这些特征，这是一个明确的迹象，表明某些东西需要改变。
- en: Mutable default arguments
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可变默认参数
- en: Simply put, don't use mutable objects as the default arguments of functions.
    If you use mutable objects as default arguments, you will get results that are
    not the expected ones.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，不要将可变对象用作函数的默认参数。如果你使用可变对象作为默认参数，你将得到非预期的结果。
- en: 'Consider the following erroneous function definition:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下有误的函数定义：
- en: '[PRE42]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This has two problems, actually. Besides the default mutable argument, the body
    of the function is mutating a mutable object, and hence creating a side effect.
    But the main problem is the default argument for `user_metadata`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这有两个问题。除了默认的可变参数之外，函数体正在修改一个可变对象，从而产生副作用。但主要问题是 `user_metadata` 的默认参数。
- en: 'This will actually only work the first time it is called without arguments.
    For the second time, we call it without explicitly passing something to `user_metadata`.
    It will fail with a `KeyError`, like so:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这只有在第一次调用时不带参数时才会起作用。第二次调用时，我们没有明确传递任何内容给 `user_metadata`。它将失败并抛出 `KeyError`，如下所示：
- en: '[PRE43]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The explanation is simple—by assigning the dictionary with the default data
    to `user_metadata` on the definition of the function, this dictionary is actually
    created once and the `user_metadata` variable points to it. When the Python interpreter
    parses the file, it'll read the function, and find a statement in the signature
    that creates the dictionary and assigns it to the parameter. From that point on,
    the dictionary is created only once, and it's the same for the entire life of
    the program.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 解释很简单——通过在函数定义中将默认数据字典分配给 `user_metadata`，这个字典实际上只创建一次，而 `user_metadata` 变量指向它。当
    Python 解释器解析文件时，它会读取函数，并找到一个创建字典并将其分配给参数的语句。从那时起，字典只创建一次，在整个程序的生命周期中都是相同的。
- en: Then, the body of the function modifies this object, which remains alive in
    memory so long as the program is running. When we pass a value to it, this will
    take the place of the default argument we just created. When we don't want this
    object, it is called again, and it has been modified since the previous run; the
    next time we run it, will not contain the keys since they were removed on the
    previous call.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，函数体修改了这个对象，只要程序在运行，这个对象就会保留在内存中。当我们向它传递一个值时，这个值将取代我们刚刚创建的默认参数。当我们不想要这个对象时，它会再次被调用，并且自从上次运行以来已经被修改；下次我们运行它时，将不会包含键，因为它们在上一次调用中被删除了。
- en: 'The fix is also simple—we need to use `None` as a default sentinel value and
    assign the default on the body of the function. Because each function has its
    own scope and life cycle, `user_metadata` will be assigned to the dictionary every
    time `None` appears:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 修复方法也很简单——我们需要使用 `None` 作为默认哨兵值，并在函数体中分配默认值。因为每个函数都有自己的作用域和生命周期，所以每次 `None`
    出现时，`user_metadata` 都会被分配到字典中：
- en: '[PRE44]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Let's conclude the section by understanding the quirks of extending built-in
    types.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过理解扩展内置类型的怪癖来结束本节。
- en: Extending built-in types
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展内置类型
- en: The correct way of extending built-in types such as lists, strings, and dictionaries
    is by means of the `collections` module.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 正确扩展内置类型（如列表、字符串和字典）的方法是通过 `collections` 模块。
- en: If you create a class that directly extends `dict`, for example, you will obtain
    results that are probably not what you are expecting. The reason for this is that
    in CPython (a C optimization), the methods of the class don't call each other
    (as they should), so if you override one of them, this will not be reflected by
    the rest, resulting in unexpected outcomes. For example, you might want to override
    `__getitem__`, and then when you iterate the object with a `for` loop, you will
    notice that the logic you have put on that method is not applied.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建了一个直接扩展 `dict` 的类，例如，你可能会得到你预期之外的结果。这是因为 CPython（一种 C 优化）中的类方法不会相互调用（正如它们应该的那样），所以如果你覆盖了其中之一，这不会反映在其他方法中，从而导致意外的结果。例如，你可能想覆盖
    `__getitem__` 方法，然后当你使用 `for` 循环迭代对象时，你会注意到你放在那个方法上的逻辑没有被应用。
- en: This is all solved by using `collections.UserDict`, for example, which provides
    a transparent interface to actual dictionaries, and is more robust.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都可以通过使用 `collections.UserDict` 来解决，例如，它提供了一个对实际字典的透明接口，并且更健壮。
- en: 'Let''s say we want a list that was originally created from numbers to convert
    the values to strings, adding a prefix. The first approach might look like it
    solves the problem, but it is erroneous:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要一个列表，它最初是由数字创建的，将值转换为字符串，并添加一个前缀。第一种方法看起来可以解决问题，但实际上是错误的：
- en: '[PRE45]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'At first sight, it looks like the object behaves as we want it to. But then,
    if we try to iterate it (after all, it is a `list`), we find that we don''t get
    what we wanted:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 初看起来，这个对象的行为似乎是我们想要的。但是，如果我们尝试迭代它（毕竟，它是一个 `list`），我们会发现我们没有得到我们想要的结果：
- en: '[PRE46]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `join` function will try to iterate (run a `for` loop over) the `list` but
    expects values of the `string` type. We would expect this to work because we modified
    the `__getitem__` method so that it always returns a `string`. However, based
    on the result, we can conclude that our modified version of `__getitem__` is not
    being called.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`join` 函数会尝试迭代（在 `list` 上运行一个 `for` 循环），但期望值是 `string` 类型。我们可能会期望这会工作，因为我们修改了
    `__getitem__` 方法，使其总是返回一个 `string`。然而，根据结果，我们可以得出结论，我们的 `__getitem__` 修改版本没有被调用。'
- en: This issue is actually an implementation detail of CPython, while in other platforms
    such as PyPy this doesn't happen (see the differences between PyPy and CPython
    in the references at the end of this chapter).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题实际上是CPython的实现细节，而在其他平台如PyPy中则不会发生这种情况（参见本章末尾参考文献中PyPy和CPython之间的差异）。
- en: 'Regardless of this, we should write code that is portable and compatible with
    all implementations, so we will fix it by extending not from `list`, but `UserList`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们应该编写可移植且与所有实现兼容的代码，因此我们将通过扩展`UserList`而不是`list`来修复它：
- en: '[PRE47]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And now things look much better:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在事情看起来要好多了：
- en: '[PRE48]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Don't extend directly from `dict`; use `collections.UserDict` instead. For lists,
    use `collections.UserList`, and for strings, use `collections.UserString`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 不要直接从`dict`扩展；请使用`collections.UserDict`。对于列表，使用`collections.UserList`，对于字符串，使用`collections.UserString`。
- en: At this point, we know all the main concepts of Python. Not only how to write
    idiomatic code that blends well with Python itself, but also to avoid certain
    pitfalls. The next section is complementary.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了Python的所有主要概念。不仅要知道如何编写与Python本身很好地融合的惯用代码，还要避免某些陷阱。下一节是补充。
- en: Before finishing the chapter, I wanted to give a quick introduction to asynchronous
    programming, because while it is not strictly related to clean code *per se*,
    asynchronous code has become more and more popular, following up with the idea
    that, in order to work effectively with code, we must be able to read it and understand
    it, because being able to read asynchronous code is important.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章之前，我想快速介绍一下异步编程，因为虽然它与代码整洁性本身没有严格的关系，但异步代码已经变得越来越流行，这符合这样一个观点：为了有效地与代码工作，我们必须能够阅读它并理解它，因为能够阅读异步代码是很重要的。
- en: A brief introduction to asynchronous code
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步代码简介
- en: Asynchronous programming is not related to clean code. Therefore, the features
    of Python described in this section won't make the code base easier to maintain.
    This section introduces the syntax in Python to work with coroutines, because
    it might be of use for the reader, and examples with coroutines might appear later
    in the book.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程与代码整洁性无关。因此，本节中描述的Python特性不会使代码库更容易维护。本节介绍了Python中与协程一起工作的语法，因为这对读者可能有用，书中可能会出现带有协程的示例。
- en: The idea behind asynchronous programming is to have parts in our code that are
    able to suspend so that other parts of our code can run. Typically, when we are
    running I/O operations, we would very much like to keep that code running, and
    use the CPU on something else during that time.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程背后的思想是让我们的代码中的一部分能够挂起，以便其他部分可以运行。通常，当我们运行I/O操作时，我们非常希望保持代码运行，并在那段时间内使用CPU做其他事情。
- en: This changes the programming model. Instead of us making calls synchronously,
    we would write our code in a way that is being called by an event loop, which
    is in charge of scheduling the coroutines for running all of them in the same
    process and thread.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这改变了编程模型。我们不再以同步方式调用，而是以事件循环调用的方式编写我们的代码，事件循环负责调度协程，以便在同一个进程和线程中运行所有协程。
- en: The idea is that we create a series of coroutines, and they're added to the
    event loop. When the event loop starts, it'll pick among the coroutines it has,
    and schedule them to run. At some point, when one of our coroutines needs to do
    an I/O operation, we can trigger it and signal the event loop back to take control
    again, and then schedule another coroutine whilst this operation was kept running.
    At some point, the event loop will resume our coroutine from the last point it
    got stopped at, and will continue from there. Keep in mind that the advantage
    of asynchronous programming is to not block on I/O operations. This means the
    code can jump to something else while an I/O operation is in place and then come
    back at it, but it doesn't mean that there are multiple processes running simultaneously.
    The execution model is still single-threaded.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 思想是我们创建一系列协程，并将它们添加到事件循环中。当事件循环开始时，它会在其拥有的协程中挑选，并安排它们运行。在某个时刻，当我们的协程需要执行I/O操作时，我们可以触发它，并通知事件循环再次接管控制权，然后安排另一个协程在这次操作保持运行的同时运行。在某个时刻，事件循环将从上次停止的地方恢复我们的协程，并从那里继续。记住，异步编程的优势是不在I/O操作上阻塞。这意味着代码可以在I/O操作进行时跳转到其他地方，然后再回来处理它，但这并不意味着有多个进程同时运行。执行模型仍然是单线程的。
- en: In order to achieve this in Python, there were (and still are) lots of frameworks
    available. But in older versions of Python, there wasn't a specific syntax that
    allowed this, so the way the frameworks worked was a bit complicated, or non-obvious
    at first glance. Starting with Python 3.5, specific syntax for declaring coroutines
    was added to the language, and that changed the way we write asynchronous code
    in Python. Slightly prior to that, a default event loop module, `asyncio`, was
    introduced in the standard library. With these two milestones of Python, making
    asynchronous programming is much better.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Python中实现这一点，曾经（现在仍然有）许多框架可用。但在Python的旧版本中，并没有特定的语法允许这样做，因此框架的工作方式在最初可能有些复杂，或者不太明显。从Python
    3.5开始，语言中添加了用于声明协程的特定语法，这改变了我们在Python中编写异步代码的方式。在这之前，标准库中引入了一个默认的事件循环模块`asyncio`。有了这两个Python的里程碑，异步编程变得更加出色。
- en: While this section uses `asyncio` as the module for asynchronous processing,
    this is not the only one. You can write asynchronous code using any library (there
    are plenty of them available outside the standard library, such as `trio` ([https://github.com/python-trio/trio](https://github.com/python-trio/trio))
    and `curio` ([https://github.com/dabeaz/curio](https://github.com/dabeaz/curio))
    to name just a couple). The syntax that Python provides for writing coroutines
    can be considered an API. As long as the library you choose complies with that
    API, you should be able to use it, without having to change how your coroutines
    were declared.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本节使用`asyncio`作为异步处理的模块，但这并非唯一的选择。您可以使用任何库来编写异步代码（标准库之外有许多可用的库，例如`trio` ([https://github.com/python-trio/trio](https://github.com/python-trio/trio))
    和 `curio` ([https://github.com/dabeaz/curio](https://github.com/dabeaz/curio))，仅举几个例子）。Python提供的用于编写协程的语法可以被视为一个API。只要您选择的库符合该API，您应该能够使用它，而无需更改协程的声明方式。
- en: The syntactic differences compared with asynchronous programming are that coroutines
    are like functions, but they're defined with `async def` before their name. When
    inside a coroutine and we want to call another one (which can be ours, or defined
    in a third-party library), we would typically use the `await` keyword before its
    invocation. When `await` is called, this signals the event loop to take back control.
    At this point, the event loop will resume its execution, and the coroutine will
    be left there waiting for its non-blocking operation to continue, and in the meantime,
    another part of the code will run (another coroutine will be called by the event
    loop). At some point, the event loop will call our original coroutine again, and
    this one will resume from the point where it left off (right after the line with
    the `await` statement).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 与异步编程相比，语法上的差异在于协程就像函数一样，但在其名称之前使用`async def`进行定义。当在协程内部并且我们想要调用另一个协程（这可能是我们自己的，或者定义在第三方库中）时，我们通常会使用`await`关键字在其调用之前。当`await`被调用时，这会向事件循环发出信号以重新获取控制权。此时，事件循环将恢复其执行，协程将留在那里等待其非阻塞操作继续，同时，代码的另一个部分将运行（事件循环将调用另一个协程）。在某个时刻，事件循环将再次调用我们的原始协程，并且它将从离开的地方继续执行（紧随`await`语句之后的行）。
- en: 'A typical coroutine we might define in our code has the following structure:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码中定义的典型协程具有以下结构：
- en: '[PRE49]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'As mentioned before, there''s new syntax for defining coroutines. One difference
    that this syntax introduces is that as opposed to regular functions, when we call
    this definition, it will not run the code within it. Instead, it will create a
    coroutine object. This object will be included in the event loop, and at some
    point, must be awaited (otherwise the code inside the definition will never run):'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，定义协程有新的语法。这种语法引入的一个不同之处在于，与常规函数不同，当我们调用这个定义时，它不会运行其中的代码。相反，它将创建一个协程对象。该对象将被包含在事件循环中，在某个时刻，必须等待它（否则定义内部的代码将永远不会运行）：
- en: '[PRE50]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Don't forget to await your coroutines, or their code will never be run. Pay
    attention to the warnings given by `asyncio`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记等待您的协程，否则它们的代码将永远不会运行。注意`asyncio`给出的警告。
- en: 'As mentioned, there are several libraries for asynchronous programming in Python,
    with event loops that can run coroutines like the preceding one defined. In particular,
    for `asyncio`, there''s a built-in function to run a coroutine until its completion:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Python中有几个用于异步编程的库，具有可以运行前面定义的协程的事件循环。特别是对于`asyncio`，有一个内置函数可以运行一个协程直到其完成：
- en: '[PRE51]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The details of how coroutines work in Python are beyond the scope of this book,
    but this introduction should get the reader more familiar with the syntax. That
    said, coroutines are technically implemented on top of generators, which we will
    explore in detail in *Chapter 7*, *Generators, Iterators, and Asynchronous Programming*.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Python中协程的工作原理超出了本书的范围，但这个介绍应该能让读者更熟悉其语法。话虽如此，协程在技术上是在生成器之上实现的，我们将在第7章“生成器、迭代器和异步编程”中详细探讨。
- en: Summary
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have explored the main features of Python, with the goal
    of understanding its most distinctive features, those that make Python a peculiar
    language compared to the rest. Along this path, we have explored different methods of
    Python, protocols, and their internal mechanics.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Python的主要特性，目标是理解其最独特的特性，这些特性使Python与其它语言相比显得独特。沿着这条路径，我们探讨了Python的不同方法、协议及其内部机制。
- en: As opposed to the previous chapter, this one is more Python-focused. A key takeaway
    of the topics of this book is that clean code goes beyond following the formatting
    rules (which, of course, are essential to a good code base). They are a necessary
    condition, but not sufficient. Over the next few chapters, we will see ideas and
    principles that relate more to the code, with the goal of achieving a better design and
    implementation of our software solution.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章相比，这一章更侧重于Python。本书主题的一个关键收获是，干净的代码不仅仅是遵循格式化规则（当然，这对于良好的代码库是至关重要的）。它们是一个必要条件，但不是充分条件。在接下来的几章中，我们将探讨更多与代码相关的想法和原则，目标是实现我们软件解决方案的更好设计和实现。
- en: 'With the concepts and the ideas of this chapter, we explored the core of Python:
    its protocols and magic methods. It should be clear by now that the best way of
    having Pythonic, idiomatic code is not only by following the formatting conventions,
    but also by taking full advantage of all the features Python has to offer. This
    means that you can write more maintainable code by using a particular magic method,
    a context manager, or writing more concise statements by using comprehensions
    and assignment expressions.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章的概念和想法，我们探索了Python的核心：其协议和魔法方法。现在应该很清楚，编写Pythonic、惯用代码的最佳方式不仅仅是遵循格式化约定，而且要充分利用Python提供的一切功能。这意味着您可以通过使用特定的魔法方法、上下文管理器，或者通过使用列表推导和赋值表达式来编写更简洁的语句，从而编写出更易于维护的代码。
- en: We also got acquainted with asynchronous programming, and now we should feel
    comfortable reading asynchronous code in Python. This is important because asynchronous
    programming is becoming increasingly popular, and it'll be useful for future topics,
    explored later in the book.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还熟悉了异步编程，现在我们应该能够舒适地阅读Python中的异步代码。这很重要，因为异步编程越来越受欢迎，对于书中稍后探讨的主题将非常有用。
- en: In the next chapter, we will put these concepts into action, relating general
    concepts of software engineering with the way they can be written in Python.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把这些概念付诸实践，将软件工程的一般概念与它们在Python中的编写方式联系起来。
- en: References
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考资料
- en: 'The reader will find more information about some of the topics that we have
    covered in this chapter in the following references. The decision of how indices
    work in Python is based on (EWD831), which analyzes several alternatives for ranges
    in math and programming languages:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 读者可以在以下参考资料中找到关于本章所涉及的一些主题的更多信息。Python中索引如何工作的决定基于(EWD831)，它分析了数学和编程语言中范围的一些替代方案：
- en: '*EWD831*: *Why numbering should start at zero* ([https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html](https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html))'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*EWD831*: *为什么编号应该从零开始* ([https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html](https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html))'
- en: '*PEP-343*: *The "with" statement* ([https://www.python.org/dev/peps/pep-0343/](https://www.python.org/dev/peps/pep-0343/))'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP-343*: *with语句* ([https://www.python.org/dev/peps/pep-0343/](https://www.python.org/dev/peps/pep-0343/))'
- en: '*CC08*: The book written by *Robert C. Martin* entitled *Clean Code: A Handbook
    of Agile Software Craftsmanship*'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CC08*: 由*罗伯特·C·马丁*所著的《Clean Code: A Handbook of Agile Software Craftsmanship》一书'
- en: '*The iter() function*: [https://docs.python.org/3/library/functions.html#iter](https://docs.python.org/3/library/functions.html#iter)'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*iter()函数*: [https://docs.python.org/3/library/functions.html#iter](https://docs.python.org/3/library/functions.html#iter)'
- en: '*Differences between PyPy and CPython*: [https://pypy.readthedocs.io/en/latest/cpython_differences.html#subclasses-of-built-in-types](https://pypy.readthedocs.io/en/latest/cpython_differences.html#subclasses-of-built-in-types)'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PyPy 与 CPython 的区别*: [https://pypy.readthedocs.io/en/latest/cpython_differences.html#subclasses-of-built-in-types](https://pypy.readthedocs.io/en/latest/cpython_differences.html#subclasses-of-built-in-types)'
- en: '*The Art of Enbugging*: [http://media.pragprog.com/articles/jan_03_enbug.pdf](http://media.pragprog.com/articles/jan_03_enbug.pdf)'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《调试的艺术》*: [http://media.pragprog.com/articles/jan_03_enbug.pdf](http://media.pragprog.com/articles/jan_03_enbug.pdf)'
- en: '*ALGO01*: The book written by *Thomas H. Cormen*, *Charles E. Leiserson*, *Ronald
    L. Rivest*, and *Clifford Stein* entitled *Introduction to Algorithms*, *3rd Edition
    (The MIT Press)*'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ALGO01*: 由 *托马斯·H·科尔曼*、*查尔斯·E·利瑟森*、*罗纳德·L·里维斯特* 和 *克利福德·斯坦* 撰写的书籍，书名为 *《算法导论》*，第三版（麻省理工学院出版社）'
