- en: Chapter 4. Views and URLs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。视图和URL
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Class-based and function-based views
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于类和基于函数的视图
- en: Mixins
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合
- en: Decorators
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器
- en: Common view patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的视图模式
- en: Designing URLs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计URL
- en: A view from the top
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从顶部看视图
- en: In Django, a view is defined as a callable that accepts a request and returns
    a response. It is usually a function or a class with a special class method such
    as `as_view()`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在Django中，视图被定义为一个可调用的函数，它接受一个请求并返回一个响应。它通常是一个带有特殊类方法（如`as_view()`）的函数或类。
- en: In both cases, we create a normal Python function that takes an `HTTPRequest`
    as the first argument and returns an `HTTPResponse`. A `URLConf` can also pass
    additional arguments to this function. These arguments can be captured from parts
    of the URL or set to default values.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们创建一个普通的Python函数，它以`HTTPRequest`作为第一个参数，并返回一个`HTTPResponse`。`URLConf`也可以向该函数传递其他参数。这些参数可以从URL的部分捕获或设置为默认值。
- en: 'Here is what a simple view looks like:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的视图如下所示：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Our two-line view function is quite simple to understand. We are currently not
    doing anything with the `request` argument. We can examine a request to better
    understand the context in which the view was called, for example by looking at
    the `GET`/`POST` parameters, URI path, or HTTP headers such as `REMOTE_ADDR`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的两行视图函数非常简单易懂。我们目前没有对`request`参数执行任何操作。我们可以检查请求以更好地理解调用视图的上下文，例如通过查看`GET`/`POST`参数、URI路径或HTTP头部（如`REMOTE_ADDR`）。
- en: 'Its corresponding lines in `URLConf` would be as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 它在`URLConf`中对应的行如下：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We are reusing the same view function to support two URL patterns. The first
    pattern takes a name argument. The second pattern doesn't take any argument from
    the URL, and the view function will use the default name of `World` in this case.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在重用相同的视图函数来支持两个URL模式。第一个模式需要一个名称参数。第二个模式不从URL中获取任何参数，视图函数将在这种情况下使用`World`的默认名称。
- en: Views got classier
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图变得更加优雅
- en: 'Class-based views were introduced in Django 1.4\. Here is how the previous
    view looks when rewritten to be a functionally equivalent class-based view:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 基于类的视图是在Django 1.4中引入的。以下是将先前的视图重写为功能等效的基于类的视图的样子：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Again, the corresponding `URLConf` would have two lines, as shown in the following
    commands:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，相应的`URLConf`将有两行，如下命令所示：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There are several interesting differences between this `view` class and our
    earlier view function. The most obvious one being that we need to define a class.
    Next, we explicitly define that we will handle only the `GET` requests. The previous
    view function gives the same response for `GET`, `POST`, or any other HTTP verb,
    as shown in the following commands using the test client in Django shell:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`view`类与我们之前的视图函数之间有一些有趣的区别。最明显的区别是我们需要定义一个类。接下来，我们明确地定义我们只处理`GET`请求。之前的视图函数对于`GET`、`POST`或任何其他HTTP动词都会给出相同的响应，如下所示，使用Django
    shell中的测试客户端的命令：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Being explicit is good from a security and maintainability point of view.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全性和可维护性的角度来看，明确是好的。
- en: 'The advantage of using a class will be clear when you need to customize your
    view. Say you need to change the greeting and the default name. Then, you can
    write a general view class for any kind of greeting and derive your specific greeting
    classes as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类的优势在于需要自定义视图时会变得很明显。比如，您需要更改问候语和默认名称。然后，您可以编写一个通用视图类来适应任何类型的问候，并派生您的特定问候类如下：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, the `URLConf` would refer to the derived class:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`URLConf`将引用派生类：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: While it is not impossible to customize the view function in a similar manner,
    you would need to add several keyword arguments with default values. This can
    quickly get unmanageable. This is exactly why generic views migrated from view
    functions to class-based views.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然以类似的方式自定义视图函数并非不可能，但您需要添加几个带有默认值的关键字参数。这可能很快变得难以管理。这正是通用视图从视图函数迁移到基于类的视图的原因。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Django Unchained**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**Django Unchained**'
- en: After spending 2 weeks hunting for good Django developers, Steve started to
    think out of the box. Noticing the tremendous success of their recent hackathon,
    he and Hart organized a Django Unchained contest at S.H.I.M. The rules were simple—build
    one web application a day. It could be a simple one but you cannot skip a day
    or break the chain. Whoever creates the longest chain, wins.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在寻找优秀的Django开发人员花了2周后，史蒂夫开始打破常规。注意到最近黑客马拉松的巨大成功，他和哈特在S.H.I.M组织了一个Django Unchained比赛。规则很简单——每天构建一个Web应用程序。它可以很简单，但你不能跳过一天或打破链条。谁创建了最长的链条，谁就赢了。
- en: The winner—Brad Zanni was a real surprise. Being a traditional designer with
    hardly any programming background, he had once attended week-long Django training
    just for kicks. He managed to create an unbroken chain of 21 Django sites, mostly
    from scratch.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 获胜者——布拉德·扎尼真是个惊喜。作为一个传统的设计师，几乎没有任何编程背景，他曾经参加了为期一周的Django培训，只是为了好玩。他设法创建了一个由21个Django站点组成的不间断链条，大部分是从零开始。
- en: The very next day, Steve scheduled a 10 o' clock meeting with him at his office.
    Though Brad didn't know it, it was going to be his recruitment interview. At the
    scheduled time, there was a soft knock and a lean bearded guy in his late twenties
    stepped in.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 第二天，史蒂夫在他的办公室安排了一个10点的会议。虽然布拉德不知道，但这将是他的招聘面试。在预定的时间，有轻轻的敲门声，一个二十多岁的瘦削有胡须的男人走了进来。
- en: As they talked, Brad made no pretense of the fact that he was not a programmer.
    In fact, there was no pretense to him at all. Peering through his thick-rimmed
    glasses with calm blue eyes, he explained that his secret was quite simple—get
    inspired and then focus.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当他们交谈时，布拉德毫不掩饰他不是程序员这一事实。事实上，他根本不需要假装。透过他那副厚框眼镜，透过他那宁静的蓝色眼睛，他解释说他的秘诀非常简单——获得灵感，然后专注。
- en: He used to start each day with a simple wireframe. He would then create an empty
    Django project with a Twitter bootstrap template. He found Django's generic class-based
    views a great way to create views with hardly any code. Sometimes, he would use
    a mixin or two from Django-braces. He also loved the admin interface for adding
    data on the go.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 他过去每天都以一个简单的线框开始。然后，他会使用Twitter bootstrap模板创建一个空的Django项目。他发现Django的基于类的通用视图是以几乎没有代码创建视图的绝佳方式。有时，他会从Django-braces中使用一个或两个mixin。他还喜欢通过管理界面在移动中添加数据。
- en: His favorite project was Labyrinth—a Honeypot disguised as a baseball forum.
    He even managed to trap a few surveillance bots hunting for vulnerable sites.
    When Steve explained about the SuperBook project, he was more than happy to accept
    the offer. The idea of creating an interstellar social network truly fascinated
    him.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 他最喜欢的项目是Labyrinth——一个伪装成棒球论坛的蜜罐。他甚至设法诱捕了一些搜寻易受攻击站点的监视机器人。当史蒂夫解释了SuperBook项目时，他非常乐意接受这个提议。创建一个星际社交网络的想法真的让他着迷。
- en: With a little more digging around, Steve was able to find half a dozen more
    interesting profiles like Brad within S.H.I.M. He learnt that rather that looking
    outside he should have searched within the organization in the first place.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更多的挖掘，史蒂夫能够在S.H.I.M中找到半打像布拉德这样有趣的个人资料。他得知，他应该首先在组织内部搜索，而不是寻找外部。
- en: Class-based generic views
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于类的通用视图
- en: Class-based generic views are commonly used views implemented in an object-oriented
    manner (Template method pattern) for better reuse. I hate the term *generic views*.
    I would rather call them *stock views*. Like stock photographs, you can use them
    for many common needs with a bit of tweaking.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 基于类的通用视图通常以面向对象的方式实现（模板方法模式）以实现更好的重用。我讨厌术语*通用视图*。我宁愿称它们为*库存视图*。就像库存照片一样，您可以在稍微调整的情况下用于许多常见需求。
- en: Generic views were created because Django developers felt that they were recreating
    the same kind of views in every project. Nearly every project needed a page showing
    a list of objects (`ListView`), details of an object (`DetailView`), or a form
    to create an object (`CreateView`). In the spirit of DRY, these reusable views
    were bundled with Django.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通用视图是因为Django开发人员觉得他们在每个项目中都在重新创建相同类型的视图。几乎每个项目都需要显示对象列表（`ListView`），对象的详细信息（`DetailView`）或用于创建对象的表单（`CreateView`）的页面。为了遵循DRY原则，这些可重用的视图与Django捆绑在一起。
- en: 'A convenient table of generic views in Django 1.7 is given here:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Django 1.7中通用视图的方便表格如下：
- en: '| Type | Class Name | Description |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 类名 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Base | `View` | This is the parent of all views. It performs dispatch and
    sanity checks. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 基类 | `View` | 这是所有视图的父类。它执行分发和健全性检查。'
- en: '| Base | `TemplateView` | This renders a template. It exposes the `URLConf`
    keywords into context. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 基类 | `TemplateView` | 这呈现模板。它将`URLConf`关键字暴露到上下文中。 |'
- en: '| Base | `RedirectView` | This redirects on any `GET` request. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 基类 | `RedirectView` | 这在任何`GET`请求上重定向。'
- en: '| List | `ListView` | This renders any iterable of items, such as a `queryset`.
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 列表 | `ListView` | 这呈现任何可迭代的项目，例如`queryset`。'
- en: '| Detail | `DetailView` | This renders an item based on `pk` or `slug` from
    `URLConf`. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 详细 | `DetailView` | 这根据`URLConf`中的`pk`或`slug`呈现项目。'
- en: '| Edit | `FormView` | This renders and processes a form. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 编辑 | `FormView` | 这呈现并处理表单。'
- en: '| Edit | `CreateView` | This renders and processes a form for creating new
    objects. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 编辑 | `CreateView` | 这呈现并处理用于创建新对象的表单。'
- en: '| Edit | `UpdateView` | This renders and processes a form for updating an object.
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 编辑 | `UpdateView` | 这呈现并处理用于更新对象的表单。'
- en: '| Edit | `DeleteView` | This renders and processes a form for deleting an object.
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 编辑 | `DeleteView` | 这呈现并处理用于删除对象的表单。'
- en: '| Date | `ArchiveIndexView` | This renders a list of objects with a date field,
    the latest being the first. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 日期 | `ArchiveIndexView` | 这呈现具有日期字段的对象列表，最新的对象排在第一位。'
- en: '| Date | `YearArchiveView` | This renders a list of objects on `year` given
    by `URLConf`. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 日期 | `YearArchiveView` | 这在`URLConf`中给出的`year`上呈现对象列表。'
- en: '| Date | `MonthArchiveView` | This renders a list of objects on a `year` and
    `month`. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 日期 | `MonthArchiveView` | 这在`year`和`month`上呈现对象列表。'
- en: '| Date | `WeekArchiveView` | This renders a list of objects on a `year` and
    `week` number. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 日期 | `WeekArchiveView` | 这在`year`和`week`号上呈现对象列表。'
- en: '| Date | `DayArchiveView` | This renders a list of objects on a `year`, `month`,
    and `day`. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 日期 | `DayArchiveView` | 这在`year`，`month`和`day`上呈现对象列表。'
- en: '| Date | `TodayArchiveView` | This renders a list of objects on today''s date.
    |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 日期 | `TodayArchiveView` | 这在今天的日期上呈现对象列表。'
- en: '| Date | `DateDetailView` | This renders an object on a `year`, `month`, and
    `day` identified by its `pk` or `slug`. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 日期 | `DateDetailView` | 这根据其`pk`或`slug`在`year`，`month`和`day`上呈现对象。'
- en: We have not mentioned base classes such as `BaseDetailView` or mixins such as
    `SingleObjectMixin` here. They are designed to be parent classes. In most cases,
    you would not use them directly.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有提到诸如`BaseDetailView`之类的基类或`SingleObjectMixin`之类的混合类。它们被设计为父类。在大多数情况下，您不会直接使用它们。
- en: 'Most people confuse class-based views and class-based generic views. Their
    names are similar but they are not the same things. This has led to some interesting
    misconceptions as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人混淆了基于类的视图和基于类的通用视图。它们的名称相似，但它们并不是相同的东西。这导致了一些有趣的误解，如下所示：
- en: '**The only generic views are the ones bundled with Django**: Thankfully, this
    is wrong. There is no special magic in the generic class-based views that are
    provided.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Django捆绑的唯一通用视图**：幸运的是，这是错误的。提供的基于类的通用视图中没有特殊的魔法。'
- en: You are free to roll your own set of generic class-based views. You can also
    use a third-party library such as `django-vanilla-views` ([http://django-vanilla-views.org/](http://django-vanilla-views.org/)),
    which has a simpler implementation of the standard generic views. Remember that
    using custom generic views might make your code unfamiliar to others.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以自由地编写自己的通用基于类的视图集。您还可以使用第三方库，比如`django-vanilla-views`（[http://django-vanilla-views.org/](http://django-vanilla-views.org/)），它具有标准通用视图的更简单的实现。请记住，使用自定义通用视图可能会使您的代码对他人来说变得陌生。
- en: '**Class-based views must always derive from a generic view**: Again, there
    is nothing magical about the generic view classes. Though 90 percent of the time,
    you will find a generic class such as `View` to be ideal for use as a base class,
    you are free to implement similar features yourself.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于类的视图必须始终派生自通用视图**：同样，通用视图类并没有什么神奇之处。虽然90%的时间，您会发现像`View`这样的通用类非常适合用作基类，但您可以自由地自己实现类似的功能。'
- en: View mixins
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图混入
- en: Mixins are the essence of DRY code in class-based views. Like model mixins,
    a view mixin takes advantage of Python's multiple inheritance to easily reuse
    chunks of functionality. They are often parent-less classes in Python 3 (or derived
    from `object` in Python 2 since they are new-style classes).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 混入是类基视图中DRY代码的本质。与模型混入一样，视图混入利用Python的多重继承来轻松重用功能块。它们通常是Python 3中没有父类的类（或者在Python
    2中从`object`派生，因为它们是新式类）。
- en: 'Mixins intercept the processing of views at well-defined places. For example,
    most generic views use `get_context_data` to set the context dictionary. It is
    a good place to insert an additional context, such as a `feed` variable that points
    to all posts a user can view, as shown in the following command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 混入在明确定义的位置拦截视图的处理。例如，大多数通用视图使用`get_context_data`来设置上下文字典。这是插入额外上下文的好地方，比如一个`feed`变量，指向用户可以查看的所有帖子，如下命令所示：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `get_context_data` method first populates the context by calling its namesake
    in all the bases classes. Next, it updates the context dictionary with the `feed`
    variable.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_context_data`方法首先通过调用所有基类中的同名方法来填充上下文。接下来，它使用`feed`变量更新上下文字典。'
- en: 'Now, this mixin can be easily used to add the user''s feed by including it
    in the list of base classes. Say, if SuperBook needs a typical social network
    home page with a form to create a new post followed by your feed, then you can
    use this mixin as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可以很容易地使用这个混入来通过将其包含在基类列表中来添加用户的feed。比如，如果SuperBook需要一个典型的社交网络主页，其中包括一个创建新帖子的表单，然后是您的feed，那么可以使用这个混入如下：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A well-written mixin imposes very little requirements. It should be flexible
    to be useful in most situations. In the previous example, `FeedMixin` will overwrite
    the `feed` context variable in a derived class. If a parent class uses `feed`
    as a context variable, then it can be affected by the inclusion of this mixin.
    Hence, it would be more useful to make the context variable customizable (which
    has been left to you as an exercise).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一个写得很好的混入几乎没有要求。它应该灵活，以便在大多数情况下都能派上用场。在前面的例子中，`FeedMixin`将覆盖派生类中的`feed`上下文变量。如果父类使用`feed`作为上下文变量，那么它可能会受到包含此混入的影响。因此，使上下文变量可定制会更有用（这留给您作为练习）。
- en: The ability of mixins to combine with other classes is both their biggest advantage
    and disadvantage. Using the wrong combination can lead to bizarre results. So,
    before using a mixin, you need to check the source code of the mixin and other
    classes to ensure that there are no method or context-variable clashes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 混入能够与其他类结合是它们最大的优势和劣势。使用错误的组合可能导致奇怪的结果。因此，在使用混入之前，您需要检查混入和其他类的源代码，以确保没有方法或上下文变量冲突。
- en: Order of mixins
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混入的顺序
- en: 'You might have come across code with several mixins as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经遇到了包含几个混入的代码，如下所示：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It can get quite tricky to figure out the order to list the base classes. Like
    most things in Django, the normal rules of Python apply. Python's **Method Resolution
    Order** (**MRO**) determines how they should be arranged.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 确定列出基类的顺序可能会变得非常棘手。就像Django中的大多数事情一样，通常适用Python的正常规则。Python的**方法解析顺序**（**MRO**）决定了它们应该如何排列。
- en: In a nutshell, mixins come first and base classes come last. The more specialized
    the parent class is, the more it moves to the left. In practice, this is the only
    rule you will need to remember.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，混入首先出现，基类最后出现。父类越专业，它就越向左移动。在实践中，这是您需要记住的唯一规则。
- en: 'To understand why this works, consider the following simple example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么这样做，请考虑以下简单的例子：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you would expect, if `B` is mentioned before `A` in the list of base classes,
    then `B`'s method gets called and vice versa.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所期望的，如果在基类列表中提到`B`在`A`之前，那么将调用`B`的方法，反之亦然。
- en: Now imagine `A` is a base class such as `CreateView` and `B` is a mixin such
    as `FeedMixin`. The mixin is an enhancement over the basic functionality of the
    base class. Hence, the mixin code should act first and in turn, call the base
    method if needed. So, the correct order is `BA` (mixins first, base last).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象`A`是一个基类，比如`CreateView`，`B`是一个混入，比如`FeedMixin`。混入是对基类基本功能的增强。因此，混入代码应该首先执行，然后根据需要调用基本方法。因此，正确的顺序是`BA`（混入在前，基类在后）。
- en: 'The order in which base classes are called can be determined by checking the
    `__mro__` attribute of the class:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 调用基类的顺序可以通过检查类的`__mro__`属性来确定：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: So, if `AB` calls `super()`, first `A` gets called; then, `A`'s `super()` will
    call `B`, and so on.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果`AB`调用`super()`，首先会调用`A`；然后，`A`的`super()`将调用`B`，依此类推。
- en: Tip
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Python's MRO usually follows a depth-first, left-to-right order to select a
    method in the class hierarchy. More details can be found at [http://www.python.org/download/releases/2.3/mro/](http://www.python.org/download/releases/2.3/mro/).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Python的MRO通常遵循深度优先，从左到右的顺序来选择类层次结构中的方法。更多细节可以在[http://www.python.org/download/releases/2.3/mro/](http://www.python.org/download/releases/2.3/mro/)找到。
- en: Decorators
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器
- en: Before class-based views, decorators were the only way to change the behavior
    of function-based views. Being wrappers around a function, they cannot change
    the inner working of the view, and thus effectively treat them as black boxes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在类视图之前，装饰器是改变基于函数的视图行为的唯一方法。作为函数的包装器，它们不能改变视图的内部工作，因此有效地将它们视为黑匣子。
- en: 'A decorator is function that takes a function and returns the decorated function.
    Confused? There is some syntactic sugar to help you. Use the annotation notation
    `@`, as shown in the following `login_required` decorator example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是一个接受函数并返回装饰函数的函数。感到困惑？有一些语法糖可以帮助你。使用注解符号`@`，如下面的`login_required`装饰器示例所示：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following code is exactly same as above:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码与上面完全相同：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Since `login_required` wraps around the view, a wrapper function gets the control
    first. If the user was not logged in, then it redirects to `settings.LOGIN_URL`.
    Otherwise, it executes `simple_view` as if it did not exist.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`login_required`包装了视图，所以包装函数首先获得控制权。如果用户未登录，则重定向到`settings.LOGIN_URL`。否则，它执行`simple_view`，就好像它不存在一样。
- en: Decorators are less flexible than mixins. However, they are simpler. You can
    use both decorators and mixins in Django. In fact, many mixins are implemented
    with decorators.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器不如mixin灵活。但它们更简单。在Django中，您可以同时使用装饰器和mixin。实际上，许多mixin都是用装饰器实现的。
- en: View patterns
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图模式
- en: Let's take a look at some common design patterns seen in designing views.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些在设计视图中看到的常见设计模式。
- en: Pattern – access controlled views
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式 - 受控访问视图
- en: '**Problem**: Pages need to be conditionally accessible based on whether the
    user was logged in, is a member of staff, or any other condition.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：页面需要根据用户是否已登录、是否为工作人员或任何其他条件有条件地访问。'
- en: '**Solution**: Use mixins or decorators to control access to the view.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：使用mixin或装饰器来控制对视图的访问。'
- en: Problem details
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题详情
- en: Most websites have pages that can be accessed only if you are logged in. Certain
    other pages are accessible to anonymous or public visitors. If an anonymous visitor
    tries to access a page, which needs a logged-in user, they could be routed to
    the login page. Ideally, after logging in, they should be routed back to the page
    they wished to see in the first place.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数网站有一些只有在登录后才能访问的页面。其他一些页面对匿名或公共访问者开放。如果匿名访问者尝试访问需要登录用户的页面，则可能会被路由到登录页面。理想情况下，登录后，他们应该被路由回到他们最初希望看到的页面。
- en: Similarly, there are pages that can only be seen by certain groups of users.
    For example, Django's admin interface is only accessible to the staff. If a non-staff
    user tries to access the admin pages, they would be routed to the login page.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，有些页面只能由某些用户组看到。例如，Django的管理界面只对工作人员可访问。如果非工作人员用户尝试访问管理页面，他们将被路由到登录页面。
- en: Finally, there are pages that grant access only if certain conditions are met.
    For example, the ability to edit a post should be only accessible to the creator
    of the post. Anyone else accessing this page should see a **Permission Denied**
    error.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有些页面只有在满足某些条件时才能访问。例如，只有帖子的创建者才能编辑帖子。其他任何人访问此页面都应该看到**权限被拒绝**的错误。
- en: Solution details
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案详情
- en: 'There are two ways to control access to a view:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以控制对视图的访问：
- en: 'By using a decorator on a function-based view or class-based view:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在基于函数的视图或基于类的视图上使用装饰器：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'By overriding the `dispatch` method of a class-based view through a mixin:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过mixin重写类视图的`dispatch`方法：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We really don''t need the decorator here. The more explicit form recommended
    is as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里真的不需要装饰器。推荐更明确的形式如下：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When the `PermissionDenied` exception is raised, Django shows the `403.html`
    template in your root directory or, in its absence, a standard "403 Forbidden"
    page.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当引发`PermissionDenied`异常时，Django会在您的根目录中显示`403.html`模板，或者在其缺失时显示标准的“403 Forbidden”页面。
- en: Of course, you would need a more robust and customizable set of mixins for real
    projects. The `django-braces` package ([https://github.com/brack3t/django-braces](https://github.com/brack3t/django-braces))
    has an excellent set of mixins, especially for controlling access to views.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对于真实项目，您需要一个更健壮和可定制的mixin集。`django-braces`包（[https://github.com/brack3t/django-braces](https://github.com/brack3t/django-braces)）有一套出色的mixin，特别是用于控制对视图的访问。
- en: 'Here are examples of using them to control access to the logged-in and anonymous
    views:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用它们来控制登录和匿名视图的示例：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Staff members in Django are users with the `is_staff` flag set in the user
    model. Again, you can use a django-braces mixin called `UserPassesTestMixin`,
    as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Django中的工作人员是在用户模型中设置了`is_staff`标志的用户。同样，您可以使用一个名为`UserPassesTestMixin`的django-braces
    mixin，如下所示：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can also create mixins to perform specific checks, such as if the object
    is being edited by its author or not (by comparing it with the logged-in user):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以创建mixin来执行特定的检查，比如对象是否正在被其作者编辑（通过与登录用户进行比较）：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Pattern – context enhancers
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式 - 上下文增强器
- en: '**Problem**: Several views based on generic views need the same context variable.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：基于通用视图的几个视图需要相同的上下文变量。'
- en: '**Solution**: Create a mixin that sets the shared context variable.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：创建一个设置共享上下文变量的mixin。'
- en: Problem details
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题详情
- en: Django templates can only show variables that are present in its context dictionary.
    However, sites need the same information in several pages. For instance, a sidebar
    showing the recent posts in your feed might be needed in several views.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Django模板只能显示存在于其上下文字典中的变量。然而，站点需要在多个页面中具有相同的信息。例如，侧边栏显示您的动态中最近的帖子可能需要在多个视图中使用。
- en: However, if we use a generic class-based view, we would typically have a limited
    set of context variables related to a specific model. Setting the same context
    variable in each view is not DRY.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们使用通用的基于类的视图，通常会有一组与特定模型相关的有限上下文变量。在每个视图中设置相同的上下文变量并不符合DRY原则。
- en: Solution details
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案详情
- en: Most generic class-based views are derived from `ContextMixin`. It provides
    the `get_context_data` method, which most classes override, to add their own context
    variables. While overriding this method, as a best practice, you will need to
    call `get_context_data` of the superclassfirst and then add or override your context
    variables.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数通用的基于类的视图都是从`ContextMixin`派生的。它提供了`get_context_data`方法，大多数类都会重写这个方法，以添加他们自己的上下文变量。在重写这个方法时，作为最佳实践，您需要首先调用超类的`get_context_data`，然后添加或覆盖您的上下文变量。
- en: 'We can abstract this in the form of a mixin, as we have seen before:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个抽象成一个mixin的形式，就像我们之前看到的那样：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can add this mixin to our views and use the added context variables in our
    templates. Notice that we are using the model manager defined in [Chapter 3](ch03.html
    "Chapter 3. Models"), *Models*, to filter the posts.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个mixin添加到我们的视图中，并在我们的模板中使用添加的上下文变量。请注意，我们正在使用[第3章](ch03.html "第3章。模型")中定义的模型管理器，*模型*，来过滤帖子。
- en: 'A more general solution is to use `StaticContextMixin` from `django-braces`
    for static-context variables. For example, we can add an additional context variable
    `latest_profile` that contains the latest user to join the site:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更一般的解决方案是使用`django-braces`中的`StaticContextMixin`来处理静态上下文变量。例如，我们可以添加一个额外的上下文变量`latest_profile`，其中包含最新加入站点的用户：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, static context means anything that is unchanged from a request to request.
    In that sense, you can mention `QuerySets` as well. However, our `feed` context
    variable needs `self.request.user` to retrieve the user's viewable posts. Hence,
    it cannot be included as a static context here.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，静态上下文意味着任何从一个请求到另一个请求都没有改变的东西。在这种意义上，您也可以提到`QuerySets`。然而，我们的`feed`上下文变量需要`self.request.user`来检索用户可查看的帖子。因此，在这里不能将其包括为静态上下文。
- en: Pattern – services
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式 - 服务
- en: '**Problem**: Information from your website is often scraped and processed by
    other applications.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：您网站的信息经常被其他应用程序抓取和处理。'
- en: '**Solution**: Create lightweight services that return data in machine-friendly
    formats, such as JSON or XML.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：创建轻量级服务，以机器友好的格式返回数据，如JSON或XML。'
- en: Problem details
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题细节
- en: We often forget that websites are not just used by humans. A significant percentage
    of web traffic comes from other programs like crawlers, bots, or scrapers. Sometimes,
    you will need to write such programs yourself to extract information from another
    website.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常忘记网站不仅仅是人类使用的。网站流量的很大一部分来自其他程序，如爬虫、机器人或抓取器。有时，您需要自己编写这样的程序来从另一个网站提取信息。
- en: Generally, pages designed for human consumption are cumbersome for mechanical
    extraction. HTML pages have information surrounded by markup, requiring extensive
    cleanup. Sometimes, information will be scattered, needing extensive data collation
    and transformation.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，为人类消费而设计的页面对机械提取来说很麻烦。HTML页面中的信息被标记包围，需要进行大量的清理。有时，信息会分散，需要进行大量的数据整理和转换。
- en: A machine interface would be ideal in such situations. You can not only reduce
    the hassle of extracting information but also enable the creation of mashups.
    The longevity of an application would be greatly increased if its functionality
    is exposed in a machine-friendly manner.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，机器接口将是理想的。您不仅可以减少提取信息的麻烦，还可以实现混搭。如果应用程序的功能以机器友好的方式暴露，其功能的持久性将大大增加。
- en: Solution details
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案细节
- en: '**Service-oriented architecture** (**SOA**) has popularized the concept of
    a service. A service is a distinct piece of functionality exposed to other applications
    as a service. For example, Twitter provides a service that returns the most recent
    public statuses.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向服务的架构**（**SOA**）已经推广了服务的概念。服务是向其他应用程序公开的一个独特的功能块。例如，Twitter提供了一个返回最新公共状态的服务。'
- en: 'A service has to follow certain basic principles:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一个服务必须遵循一定的基本原则：
- en: '**Statelessness**: This avoids the internal state by externalizing state information'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态性**：这避免了通过外部化状态信息来避免内部状态'
- en: '**Loosely coupled**: This has fewer dependencies and a minimum of assumptions'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**松耦合**：这样可以减少依赖和假设的最小数量'
- en: '**Composable**: This should be easy to reuse and combine with other services'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可组合的**：这应该很容易重用并与其他服务组合'
- en: In Django, you can create a basic service without any third-party packages.
    Instead of returning HTML, you can return the serialized data in the JSON format.
    This form of a service is usually called a web **Application Programming Interface**
    (**API**).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在Django中，您可以创建一个基本的服务，而无需任何第三方包。您可以返回JSON格式的序列化数据，而不是返回HTML。这种形式的服务通常被称为Web应用程序编程接口（API）。
- en: 'For example, we can create a simple service that returns five recent public
    posts from SuperBook as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以创建一个简单的服务，返回SuperBook中最近的五篇公共帖子：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For a more reusable implementation, you can use the `JSONResponseMixin` class
    from `django-braces` to return JSON using its `render_json_response` method:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更可重用的实现，您可以使用`django-braces`中的`JSONResponseMixin`类，使用其`render_json_response`方法返回JSON：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If we try to retrieve this view, we will get a JSON string rather than an HTML
    response:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试检索这个视图，我们将得到一个JSON字符串，而不是HTML响应：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that we cannot pass the `QuerySet` method directly to render the JSON response.
    It has to be a list, dictionary, or any other basic Python built-in data type
    recognized by the JSON serializer.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不能直接将`QuerySet`方法传递给JSON响应。它必须是一个列表、字典或任何其他基本的Python内置数据类型，被JSON序列化器识别。
- en: Of course, you will need to use a package such as Django REST framework if you
    need to build anything more complex than this simple API. Django REST framework
    takes care of serializing (and deserializing) `QuerySets`, authentication, generating
    a web-browsable API, and many other features essential to create a robust and
    full-fledged API.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果您需要构建比这个简单API更复杂的东西，您将需要使用诸如Django REST框架之类的包。 Django REST框架负责序列化（和反序列化）`QuerySets`，身份验证，生成可在Web上浏览的API，以及许多其他必要功能，以创建一个强大而完整的API。
- en: Designing URLs
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计URL
- en: Django has one of the most flexible URL schemes among web frameworks. Basically,
    there is no implied URL scheme. You can explicitly define any URL scheme you like
    using appropriate regular expressions.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Django拥有最灵活的Web框架之一。基本上，没有暗示的URL方案。您可以使用适当的正则表达式明确定义任何URL方案。
- en: However, as superheroes love to say—"With great power comes great responsibility."
    You cannot get away with a sloppy URL design any more.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如超级英雄们喜欢说的那样——“伴随着伟大的力量而来的是巨大的责任。”您不能再随意设计URL。
- en: URLs used to be ugly because they were considered to be ignored by users. Back
    in the 90s when portals used to be popular, the common assumption was that your
    users will come through the front door, that is, the home page. They will navigate
    to the other pages of the site by clicking on links.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: URL曾经很丑陋，因为人们认为用户会忽略它们。在90年代，门户网站流行时，普遍的假设是您的用户将通过前门，也就是主页进入。他们将通过点击链接导航到网站的其他页面。
- en: Search engines have changed all that. According to a 2013 research report, nearly
    half (47 percent) of all visits originate from a search engine. This means that
    any page in your website, depending on the search relevance and popularity can
    be the first page your user sees. Any URL can be the front door.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索引擎已经改变了这一切。根据2013年的一份研究报告，近一半（47％）的访问来源于搜索引擎。这意味着您网站中的任何页面，根据搜索相关性和受欢迎程度，都可能成为用户看到的第一个页面。任何URL都可能是前门。
- en: More importantly, Browsing 101 taught us security. Don't click on a blue link
    in the wild, we warn beginners. Read the URL first. Is it really your bank's URL
    or a site trying to phish your login details?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，浏览101教会了我们安全。我们警告初学者不要在网上点击蓝色链接。先读URL。这真的是您银行的URL还是一个试图钓取您登录详细信息的网站？
- en: 'Today, URLs have become part of the user interface. They are seen, copied,
    shared, and even edited. Make them look good and understandable from a glance.
    No more eye sores such as:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，URL已经成为用户界面的一部分。它们被看到，复制，分享，甚至编辑。让它们看起来好看且一目了然。不再有眼睛的疼痛，比如：
- en: '`http://example.com/gallery/default.asp?sid=9DF4BC0280DF12D3ACB60090271E26A8&command=commntform`'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://example.com/gallery/default.asp?sid=9DF4BC0280DF12D3ACB60090271E26A8&command=commntform`'
- en: Short and meaningful URLs are not only appreciated by users but also by search
    engines. URLs that are long and have less relevance to the content adversely affect
    your site's search engine rankings.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 短而有意义的URL不仅受到用户的欣赏，也受到搜索引擎的欢迎。长且与内容相关性较低的URL会对您的网站搜索引擎排名产生不利影响。
- en: Finally, as implied by the maxim "Cool URIs don't change," you should try to
    maintain your URL structure over time. Even if your website is completely redesigned,
    your old links should still work. Django makes it easy to ensure that this is
    so.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，正如“酷炫的URI不会改变”所暗示的，您应该尽量保持URL结构随时间的稳定。即使您的网站完全重新设计，您的旧链接仍应该有效。Django可以轻松确保如此。
- en: Before we delve into the details of designing URLs, we need to understand the
    structure of a URL.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解设计URL的细节之前，我们需要了解URL的结构。
- en: URL anatomy
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: URL解剖
- en: Technically, URLs belong to a more general family of identifiers called **Uniform
    Resource Identifiers (URI**s). Hence, a URL has the same structure as a URI.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，URL属于更一般的标识符家族，称为**统一资源标识符（URI**）。因此，URL的结构与URI相同。
- en: 'A URI is composed of several parts:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: URI由几个部分组成：
- en: '*URI = Scheme + Net Location + Path + Query + Fragment*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*URI = 方案 + 网络位置 + 路径 + 查询 + 片段*'
- en: 'For example, a URI (`http://dev.example.com:80/gallery/videos?id=217#comments`)
    can be deconstructed in Python using the `urlparse` function:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以使用`urlparse`函数在Python中解构URI（`http://dev.example.com:80/gallery/videos?id=217#comments`）：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The URI parts can be depicted graphically as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: URI的各个部分可以以图形方式表示如下：
- en: '![URL anatomy](img/6644OS_04_01.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![URL解剖](img/6644OS_04_01.jpg)'
- en: Even though Django documentation prefers to use the term URLs, it might more
    technically correct to say that you are working with URIs most of the time. We
    will use the terms interchangeably in this book.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Django文档更喜欢使用术语URLs，但更准确地说，您大部分时间都在使用URI。在本书中，我们将这些术语互换使用。
- en: Django URL patterns are mostly concerned about the 'Path' part of the URI. All
    other parts are tucked away.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Django URL模式主要涉及URI的“路径”部分。所有其他部分都被隐藏起来。
- en: What happens in urls.py?
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: urls.py中发生了什么？
- en: It is often helpful to consider `urls.py` as the entry point of your project.
    It is usually the first file I open when I study a Django project. Essentially,
    `urls.py` contains the root URL configuration or `URLConf` of the entire project.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通常有助于将`urls.py`视为项目的入口点。当我研究Django项目时，这通常是我打开的第一个文件。基本上，`urls.py`包含整个项目的根URL配置或`URLConf`。
- en: It would be a Python list returned from `patterns` assigned to a global variable
    called `urlpatterns`. Each incoming URL is matched with each pattern from top
    to bottom in a sequence. In the first match, the search stops, and the request
    is sent to the corresponding view.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 它将是从`patterns`返回的Python列表，分配给名为`urlpatterns`的全局变量。每个传入的URL都会与顺序中的每个模式进行匹配。在第一次匹配时，搜索停止，并且请求被发送到相应的视图。
- en: 'Here, in considerably simplified form, is an excerpt of `urls.py` from [Python.org](http://Python.org),
    which was recently rewritten in Django:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，是从[Python.org](http://Python.org)的`urls.py`中的一个摘录，最近在Django中重新编写：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Some interesting things to note here are as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一些有趣的事情如下：
- en: The first argument of the `patterns` function is the prefix. It is usually blank
    for the root `URLConf`. The remaining arguments are all URL patterns.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`patterns`函数的第一个参数是前缀。对于根`URLConf`，通常为空。其余参数都是URL模式。'
- en: 'Each URL pattern is created using the `url` function, which takes five arguments.
    Most patterns have three arguments: the regular expression pattern, view callable,
    and name of the view.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个URL模式都是使用`url`函数创建的，该函数需要五个参数。大多数模式有三个参数：正则表达式模式，视图可调用和视图的名称。
- en: The `about` pattern defines the view by directly instantiating `TemplateView`.
    Some hate this style since it mentions the implementation, thereby violating separation
    of concerns.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`about`模式通过直接实例化`TemplateView`来定义视图。有些人讨厌这种风格，因为它提到了实现，从而违反了关注点的分离。'
- en: Blog URLs are mentioned elsewhere, specifically in `urls.py` inside the blogs
    app. In general, separating an app's URL pattern into its own file is good practice.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 博客URL在其他地方提到，特别是在blogs应用程序的`urls.py`中。一般来说，将应用程序的URL模式分离成自己的文件是一个很好的做法。
- en: The `jobs` pattern is the only example here of a named regular expression.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jobs`模式是这里唯一的一个命名正则表达式的例子。'
- en: In future versions of Django, `urlpatterns` should be a plain list of URL pattern
    objects rather than arguments to the `patterns` function. This is great for sites
    with lots of patterns, since `urlpatterns` being a function can accept only a
    maximum of 255 arguments.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来的Django版本中，`urlpatterns`应该是一个URL模式对象的普通列表，而不是`patterns`函数的参数。这对于有很多模式的站点来说很棒，因为`urlpatterns`作为一个函数只能接受最多255个参数。
- en: If you are new to Python regular expressions, you might find the pattern syntax
    to be slightly cryptic. Let's try to demystify it.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是Python正则表达式的新手，你可能会觉得模式语法有点神秘。让我们试着揭开它的神秘面纱。
- en: The URL pattern syntax
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: URL模式语法
- en: URL regular expression patterns can sometimes look like a confusing mass of
    punctuation marks. However, like most things in Django, it is just regular Python.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: URL正则表达式模式有时看起来像一团令人困惑的标点符号。然而，像Django中的大多数东西一样，它只是普通的Python。
- en: 'It can be easily understood by knowing that URL patterns serve two functions:
    to match URLs appearing in a certain form, and to extract the interesting bits
    from a URL.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 通过了解URL模式的两个功能，可以很容易地理解它：匹配以某种形式出现的URL，并从URL中提取有趣的部分。
- en: The first part is easy. If you need to match a path such as `/jobs/1234`, then
    just use the "`^jobs/\d+`" pattern (here `\d` stands for a single digit from 0
    to 9). Ignore the leading slash, as it gets eaten up.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分很容易。如果你需要匹配一个路径，比如`/jobs/1234`，那么只需使用"`^jobs/\d+`"模式（这里`\d`代表从0到9的单个数字）。忽略前导斜杠，因为它会被吞掉。
- en: The second part is interesting because, in our example, there are two ways of
    extracting the job ID (that is, `1234`), which is required by the view.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分很有趣，因为在我们的例子中，有两种提取作业ID（即`1234`）的方法，这是视图所需的。
- en: The simplest way is to put a parenthesis around every group of values to be
    captured. Each of the values will be passed as a positional argument to the view.
    For example, the "`^jobs/(\d+)`" pattern will send the value "`1234`" as the second
    argument (the first being the request) to the view.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是在要捕获的每组值周围放括号。每个值将作为位置参数传递给视图。例如，"`^jobs/(\d+)`"模式将把值"`1234`"作为第二个参数（第一个是请求）发送给视图。
- en: The problem with positional arguments is that it is very easy to mix up the
    order. Hence, we have name-based arguments, where each captured value can be named.
    Our example will now look like "`^jobs/(?P<pk>\d+)/`" . This means that the view
    will be called with a keyword argument `pk` being equal to "`1234`".
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 位置参数的问题在于很容易混淆顺序。因此，我们有基于名称的参数，其中每个捕获的值都可以被命名。我们的例子现在看起来像"`^jobs/(?P<pk>\d+)/`"。这意味着视图将被调用，关键字参数`pk`等于"`1234`"。
- en: If you have a class-based view, you can access your positional arguments in
    `self.args` and name-based arguments in `self.kwargs`. Many generic views expect
    their arguments solely as name-based arguments, for example, `self.kwargs["slug"]`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个基于类的视图，你可以在`self.args`中访问你的位置参数，在`self.kwargs`中访问基于名称的参数。许多通用视图期望它们的参数仅作为基于名称的参数，例如`self.kwargs["slug"]`。
- en: Mnemonic – parents question pink action-figures
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 记忆法-父母质疑粉色动作人物
- en: I admit that the syntax for name-based arguments is quite difficult to remember.
    Often, I use a simple mnemonic as a memory aid. The phrase "Parents Question Pink
    Action-figures" stands for the first letters of Parenthesis, Question mark, (the
    letter) P, and Angle brackets.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我承认基于名称的参数的语法很难记住。我经常使用一个简单的记忆法作为记忆助手。短语“Parents Question Pink Action-figures”代表括号、问号、（字母）P和尖括号的首字母。
- en: Put them together and you get `(?P<` . You can enter the name of the pattern
    and figure out the rest yourself.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 把它们放在一起，你会得到`(?P<`。你可以输入模式的名称，然后自己找出剩下的部分。
- en: It is a handy trick and really easy to remember. Just imagine a furious parent
    holding a pink-colored hulk action figure.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很方便的技巧，而且很容易记住。想象一下一个愤怒的父母拿着一个粉色的浩克动作人物。
- en: Another tip is to use an online regular expression generator such as [http://pythex.org/](http://pythex.org/)
    or [https://www.debuggex.com/](https://www.debuggex.com/) to craft and test your
    regular expressions.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个提示是使用在线正则表达式生成器，比如[http://pythex.org/](http://pythex.org/)或[https://www.debuggex.com/](https://www.debuggex.com/)来制作和测试你的正则表达式。
- en: Names and namespaces
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 名称和命名空间
- en: Always name your patterns. It helps in decoupling your code from the exact URL
    paths. For instance, in the previous `URLConf`, if you want to redirect to the
    `about` page, it might be tempting to use `redirect("/about")`. Instead, use `redirect("about")`,
    as it uses the name rather than the path.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 总是给你的模式命名。这有助于将你的代码与确切的URL路径解耦。例如，在以前的`URLConf`中，如果你想重定向到`about`页面，可能会诱人地使用`redirect("/about")`。相反，使用`redirect("about")`，因为它使用名称而不是路径。
- en: 'Here are some more examples of reverse lookups:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些反向查找的更多示例：
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Names must be unique. If two patterns have the same name, they will not work.
    So, some Django packages used to add prefixes to the pattern name. For example,
    an application named blog might have to call its edit view as '`blog-edit`' since
    '`edit`' is a common name and might cause conflict with another application.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 名称必须是唯一的。如果两个模式有相同的名称，它们将无法工作。因此，一些Django包用于向模式名称添加前缀。例如，一个名为blog的应用程序可能必须将其编辑视图称为'`blog-edit`'，因为'`edit`'是一个常见的名称，可能会与另一个应用程序发生冲突。
- en: 'Namespaces were created to solve such problems. Pattern names used in a namespace
    have to be only unique within that namespace and not the entire project. It is
    recommended that you give every app its own namespace. For example, we can create
    a ''blog'' namespace with only the blog''s URLs by including this line in the
    root `URLconf`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间是为了解决这类问题而创建的。在命名空间中使用的模式名称必须在该命名空间内是唯一的，而不是整个项目。建议您为每个应用程序都分配一个命名空间。例如，我们可以通过在根`URLconf`中包含此行来创建一个“blog”命名空间，其中只包括博客的URL：
- en: '[PRE28]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now the blog app can use pattern names, such as '`edit`' or anything else as
    long as they are unique within that app. While referring to a name within a namespace,
    you will need to mention the namespace, followed by a '`:`' before the name. It
    would be `"blog:edit"` in our example.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在博客应用程序可以使用模式名称，比如“`edit`”或其他任何名称，只要它们在该应用程序内是唯一的。在引用命名空间内的名称时，您需要在名称之前提到命名空间，然后是“`:`”。在我们的例子中，它将是“`blog:edit`”。
- en: As Zen of Python says—"Namespaces are one honking great idea—let's do more of
    those." You can create nested namespaces if it makes your pattern names cleaner,
    such as `"blog:comment:edit"`. I highly recommend that you use namespaces in your
    projects.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 正如Python之禅所说 - “命名空间是一个非常棒的想法 - 让我们做更多这样的事情。”如果这样做可以使您的模式名称更清晰，您可以创建嵌套的命名空间，比如“`blog:comment:edit`”。我强烈建议您在项目中使用命名空间。
- en: Pattern order
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模式顺序
- en: Order your patterns to take advantage of how Django processes them, that is,
    top-down. A good rule of thumb is to keep all the special cases at the top. Broader
    patterns can be mentioned further down. The broadest—a catch-all—if present, can
    go at the very end.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 按照Django处理它们的方式，即自上而下，对您的模式进行排序以利用它们。一个很好的经验法则是将所有特殊情况放在顶部。更广泛的模式可以在更下面提到。最广泛的
    - 如果存在的话，可以放在最后。
- en: 'For example, the path to your blog posts might be any valid set of characters,
    but you might want to handle the About page separately. The right sequence of
    patterns should be as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您的博客文章的路径可以是任何有效的字符集，但您可能希望单独处理关于页面。正确的模式顺序应该如下：
- en: '[PRE29]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If we reverse the order, then the special case, the `AboutView`, will never
    get called.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们颠倒顺序，那么特殊情况“AboutView”将永远不会被调用。
- en: URL pattern styles
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: URL模式样式
- en: 'Designing URLs of a site consistently can be easily overlooked. Well-designed
    URLs can not only logically organize your site but also make it easy for users
    to guess paths. Poorly designed ones can even be a security risk: say, using a
    database ID (which occurs in a monotonic increasing sequence of integers) in a
    URL pattern can increase the risk of information theft or site ripping.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一致地设计网站的URL很容易被忽视。设计良好的URL不仅可以合理地组织您的网站，还可以让用户猜测路径变得容易。设计不良的URL甚至可能构成安全风险：比如，在URL模式中使用数据库ID（它以单调递增的整数序列出现）可能会增加信息窃取或网站剥离的风险。
- en: Let's examine some common styles followed in designing URLs.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些在设计URL时遵循的常见样式。
- en: Departmental store URLs
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 百货商店URL
- en: Some sites are laid out like Departmental stores. There is a section for Food,
    inside which there would be an aisle for Fruits, within which a section with different
    varieties of Apples would be arranged together.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 有些网站的布局就像百货商店。有一个食品区，里面有一个水果通道，通道里有不同种类的苹果摆在一起。
- en: 'In the case of URLs, this means that you will find these pages arranged hierarchically
    as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在URL的情况下，这意味着您将按以下层次结构找到这些页面：
- en: '[PRE30]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The beauty of this layout is that it is so easy to climb up to the parent section.
    Once you remove the tail end after the slash, you are one level up.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这种布局的美妙之处在于很容易向上爬到父级部分。一旦删除斜杠后面的部分，您就会上升一个级别。
- en: 'For example, you can create a similar structure for the articles section, as
    shown here:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以为文章部分创建一个类似的结构，如下所示：
- en: '[PRE31]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice the '`index`' pattern that will show an article index in case a user
    climbs up from a particular article.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意“`index`”模式，它将在用户从特定文章上升时显示文章索引。
- en: RESTful URLs
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: RESTful URL
- en: In 2000, Roy Fielding introduced the term **Representational state transfer**
    (**REST**) in his doctoral dissertation. Reading his thesis ([http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm))
    is highly recommended to better understand the architecture of the web itself.
    It can help you write better web applications that do not violate the core constraints
    of the architecture.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 2000年，Roy Fielding在他的博士论文中引入了**表现状态转移**（**REST**）这个术语。强烈建议阅读他的论文（[http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)）以更好地理解Web本身的架构。它可以帮助你编写更好的Web应用程序，不违反架构的核心约束。
- en: One of the key insights is that a URI is an identifier to a resource. A resource
    can be anything, such as an article, a user, or a collection of resources, such
    as events. Generally speaking, resources are nouns.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个关键的见解是URI是资源的标识符。资源可以是任何东西，比如一篇文章，一个用户，或者一组资源，比如事件。一般来说，资源是名词。
- en: 'The web provides you with some fundamental HTTP verbs to manipulate resources:
    `GET`, `POST`, `PUT`, `PATCH`, and `DELETE`. Note that these are not part of the
    URL itself. Hence, if you use a verb in the URL to manipulate a resource, it is
    a bad practice.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Web为您提供了一些基本的HTTP动词来操作资源：`GET`，`POST`，`PUT`，`PATCH`和`DELETE`。请注意，这些不是URL本身的一部分。因此，如果您在URL中使用动词来操作资源，这是一个不好的做法。
- en: 'For example, the following URL is considered bad:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下URL被认为是不好的：
- en: '`http://site.com/articles/submit/`'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://site.com/articles/submit/`'
- en: 'Instead, you should remove the verb and use the POST action to this URL:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你应该删除动词，并使用POST操作到这个URL：
- en: '`http://site.com/articles/`'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://site.com/articles/`'
- en: Tip
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Best Practice**'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**'
- en: Keep verbs out of your URLs if HTTP verbs can be used instead.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果HTTP动词可以使用，就不要在URL中使用动词。
- en: 'Note that it is not wrong to use verbs in a URL. The search URL for your site
    can have the verb ''`search`'' as follows, since it is not associated with one
    resource as per REST:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在URL中使用动词并不是错误的。您网站的搜索URL可以使用动词“`search`”，因为它不符合REST的一个资源：
- en: '`http://site.com/search/?q=needle`'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://site.com/search/?q=needle`'
- en: RESTful URLs are very useful for designing CRUD interfaces. There is almost
    a one-to-one mapping between the Create, Read, Update, and Delete database operations
    and the HTTP verbs.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful URL对于设计CRUD接口非常有用。创建、读取、更新和删除数据库操作与HTTP动词之间几乎是一对一的映射。
- en: Note that the RESTful URL style is complimentary to the departmental store URL
    style. Most sites mix both the styles. They are separated for clarity and better
    understanding.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，RESTful URL风格是部门商店URL风格的补充。大多数网站混合使用这两种风格。它们被分开以便更清晰地理解。
- en: Tip
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code fies for all Packt books you have purchasedfrom
    your account at [http://www.packtpub.com](http://www.packtpub.com). If you purchased
    this bookelsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register tohave the fies e-mailed directly to you. Pull requests and bug reports
    to the SuperBook project can be sent to [https://github.com/DjangoPatternsBook/superbook](https://github.com/DjangoPatternsBook/superbook).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.packtpub.com](http://www.packtpub.com)的帐户中下载您购买的所有Packt图书的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，将文件直接发送到您的电子邮件。拉取请求和错误报告可以发送到[https://github.com/DjangoPatternsBook/superbook](https://github.com/DjangoPatternsBook/superbook)的SuperBook项目。
- en: Summary
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Views are an extremely powerful part of the MVC architecture in Django. Over
    time, class-based views have proven to be more flexible and reusable compared
    to traditional function-based views. Mixins are the best examples of this reusability.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在Django中，视图是MVC架构中非常强大的部分。随着时间的推移，基于类的视图已被证明比传统的基于函数的视图更灵活和可重用。混合是这种可重用性的最好例子。
- en: Django has an extremely flexible URL dispatch system. Crafting good URLs takes
    into account several aspects. Well-designed URLs are appreciated by users too.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Django拥有非常灵活的URL分发系统。设计良好的URL需要考虑几个方面。设计良好的URL也受到用户的赞赏。
- en: In the next chapter, we will take a look at Django's templating language and
    how best to leverage it.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看一下Django的模板语言以及如何最好地利用它。
