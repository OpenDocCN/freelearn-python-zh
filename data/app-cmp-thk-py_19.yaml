- en: '*Chapter 16*: Advanced Applied Computational Thinking Problems'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第16章*：高级应用计算思维问题'
- en: 'In this chapter, we will continue providing examples in multiple areas for
    applications of the Python programming language and computational thinking. We
    will be exploring multiple areas, such as geometric tessellations, creating models
    of housing data, creating electric fields, analyzing genetic data, analyzing stocks,
    creating a **convolutional neural network** (**CNN**), and more. We will use what
    we''ve learned so far in relation to **computational thinking** and the **Python**
    programming language to do the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续提供Python编程语言和计算思维在多个领域的应用示例。我们将探索多个领域，如几何镶嵌、创建房屋数据模型、创建电场、分析基因数据、分析股票、创建卷积神经网络（CNN）等。我们将利用我们迄今为止学到的关于计算思维和Python编程语言的知识来做以下事情：
- en: Create tessellations
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建镶嵌
- en: Analyze biological data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析生物数据
- en: Analyze data for specific populations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析特定人群的数据
- en: Create models of housing data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建房屋数据模型
- en: Create electric field lines
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建电场线
- en: Analyze generic data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析通用数据
- en: Analyze stocks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析股票
- en: Create a convolutional neural network (CNN)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建卷积神经网络（CNN）
- en: After reading this chapter, you'll have learned how to perform various different
    analyses in working with data, creating tables and graphs that help to analyze
    existing data, as well as create training and testing models to help predict outcomes
    based on existing large datasets.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章后，您将学会如何在处理数据、创建表格和图形以帮助分析现有数据的同时，创建训练和测试模型以帮助根据现有大型数据集预测结果。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need the latest version of Python installed to run the code in this
    chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装最新版本的Python来运行本章中的代码。
- en: 'You will need the following libraries and packages installed for Python:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要为Python安装以下库和包：
- en: '**NLTK**'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NLTK**'
- en: '**Cairos**'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cairos**'
- en: '**Pandas**'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pandas**'
- en: '**Matplotlib**'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Matplotlib**'
- en: '**Seaborn**'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Seaborn**'
- en: 'You can find the full source code used in this chapter here: [https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter16](https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter16)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到本章中使用的完整源代码：[https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter16](https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter16)
- en: Problem 1 – Using Python to create tessellations
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题1 - 使用Python创建镶嵌
- en: In this section, we are going to provide an example using the `cairo` library
    for Python. We are going to create a **tessellation**, more specifically, a sample
    of a **Penrose tiling**. Because this is a straightforward problem, we are going
    to define our parameters using the computational thinking process, but not adhere
    to it precisely.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用Python的`cairo`库提供一个示例。我们将创建一个**镶嵌**，更具体地说，是一个**彭罗斯镶嵌**的样本。因为这是一个简单的问题，我们将使用计算思维过程来定义我们的参数，但不会严格遵循它。
- en: 'First, let''s talk about the `cairo` library. Once the `pip install cairo`
    command is successful, you''ll need to perform one more step to include all the
    components needed. Use `pip install pycairo` to add the necessary components.
    The `cairo` and `pycairo` packages are graphics libraries that work with Python.
    For more information, you can visit their web page: [https://cairographics.org/pycairo](https://cairographics.org/pycairo).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们谈谈`cairo`库。一旦`pip install cairo`命令成功，您需要执行一个步骤来包含所有需要的组件。使用`pip install
    pycairo`来添加必要的组件。`cairo`和`pycairo`包是与Python一起使用的图形库。有关更多信息，您可以访问它们的网页：[https://cairographics.org/pycairo](https://cairographics.org/pycairo)。
- en: 'Now let''s define some things. A **tessellation** is a tiling that uses shapes
    that do not overlap to create patterns. Tessellations are often explored in geometry
    courses. For our example, we will create a Penrose tiling pattern using two triangles.
    We will also get to define our space and the number of sub-divisions we want the
    shapes to undergo. The more sub-divisions, the smaller the pattern in the space
    defined. Let''s take a look at the algorithm (the file `ch16_tessellation.py`
    contains the full algorithm discussed here0:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义一些东西。**镶嵌**是使用不重叠的形状进行平铺以创建图案。镶嵌经常在几何课程中探索。在我们的示例中，我们将使用两个三角形创建一个彭罗斯镶嵌图案。我们还将定义我们的空间和我们希望形状经历的子细分数。子细分数越多，空间中的图案就越小。让我们看一下算法（文件`ch16_tessellation.py`包含了这里讨论的完整算法）：
- en: 'The first thing we''ll do is import the necessary packages and libraries:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是导入必要的包和库：
- en: ch16_tessellation.py
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ch16_tessellation.py
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we want to define our canvas and the number of sub-divisions. Note that
    we chose `4` for our example. In *Figure 16.1*, you''ll see the example from this
    snippet as well as two additional examples changing the sub-divisions:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们要定义我们的画布和子细分数。请注意，我们选择了`4`作为我们的示例。在*图16.1*中，您将看到来自此代码片段的示例以及改变子细分的两个额外示例：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For the tessellation, we need to define the **Golden Ratio**.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于镶嵌，我们需要定义**黄金比例**。
- en: 'The golden ratio is also known as the golden mean or divine proportion (among
    other names). The ratio is approximately 1.618\. As an example, if we were talking
    about a line segment divided into two parts, then the length of the larger segment
    divided by the length of the smaller segment would be equal to the sum of the
    segments divided by the larger segment: ![](image/Formula_B15413_16_001.png).
    For the tessellation, we''ll need to define that golden ratio.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 黄金比例也被称为黄金平均或神圣比例（还有其他名称）。该比例约为1.618。例如，如果我们谈论将一条线段分成两部分，那么较大部分的长度除以较小部分的长度将等于两部分之和除以较大部分的长度：![](image/Formula_B15413_16_001.png)。对于镶嵌，我们需要定义这个黄金比例。
- en: 'Take a look at the following code snippet:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码片段：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now we use functions to define what happens when our triangles sub-divide:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们使用函数来定义当我们的三角形进行子细分时会发生什么：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, we defined the function to sub-divide the triangles.
    The function contains a conditional statement to identify the color of the triangles
    prior to finding the ratio.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们定义了将三角形细分的函数。该函数包含一个条件语句，用于在找到比例之前识别三角形的颜色。
- en: 'To create the wheel of the triangles, we need to append the triangles to a
    group. Because Python is an object-oriented programming language, we can easily
    do that by creating an empty list and then appending the shapes using loops:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建三角形的轮廓，我们需要将三角形附加到一个组中。因为Python是一种面向对象的编程语言，所以我们可以通过创建一个空列表，然后使用循环附加形状来轻松地做到这一点：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we have to prepare the canvas we''ll use for our tessellation. Notice that
    we use the `cairo` functions to define the parameters using the variables we defined
    in the beginning of the algorithm. Here, we use `canvas_size`:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们要准备用于我们的镶嵌的画布。请注意，我们使用`cairo`函数来使用我们在算法开头定义的变量来定义参数。在这里，我们使用`canvas_size`：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now we have to define the two triangles we''ll be using. In this case, our
    triangles are teal and purple, but you can change the RGB values in them, that
    is, if you''d like to test different colors:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们要定义我们将使用的两个三角形。在这种情况下，我们的三角形是蓝绿色和紫色的，但是您可以更改它们的RGB值，也就是说，如果您想要测试不同的颜色：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code creates the teal triangles and the purple triangles. Each
    is defined with the RGB values and created with paths and lines.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了蓝绿色的三角形和紫色的三角形。每个都使用RGB值定义，并使用路径和线条创建。
- en: 'The rotated triangles make a tile pattern, that is, our tessellation. The tiles
    are also separated by a border. The color of the border is also defined in the
    loop that follows:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 旋转的三角形形成了一个瓷砖图案，也就是我们的镶嵌图案。瓷砖之间也有边框分隔。边框的颜色也在接下来的循环中定义：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, we want the algorithm to create an image file with our tessellation:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们希望算法创建一个带有我们的镶嵌的图像文件：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following screenshot shows three variations using different numbers of
    sub-divisions for our algorithm:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了使用不同数量的子区划进行的三种变化：
- en: '![Figure 16.1 – Sample tessellations'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.1 – 样本镶嵌'
- en: '](image/Figure_16.01_B15413.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_16.01_B15413.jpg)'
- en: Figure 16.1 – Sample tessellations
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1 – 样本镶嵌
- en: As you can see from the preceding images, the larger the number of sub-divisions,
    the smaller the tile pattern becomes to fit into our defined canvas size.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从前面的图像中所看到的，子区划的数量越多，瓷砖图案就会变得越小，以适应我们定义的画布大小。
- en: As you play with the algorithm, consider changing the canvas size, the sub-divisions,
    and the colors. If you want an additional challenge, try changing the triangle
    pattern to another polygon.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用算法时，考虑更改画布大小、子区划和颜色。如果您想要额外的挑战，尝试将三角形图案更改为其他多边形。
- en: Problem 2 – Using Python in biological data analysis
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题2 – 在生物数据分析中使用Python
- en: For this particular problem, we'll be using the `Breast_cancer_data.csv` file,
    which can be found on **Kaggle** ([https://www.kaggle.com/nsaravana/breast-cancer?select=breast-cancer.csv](https://www.kaggle.com/nsaravana/breast-cancer?select=breast-cancer.csv)).
    The file has also been uploaded to the book's GitHub repository.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定的问题，我们将使用`Breast_cancer_data.csv`文件，该文件可以在**Kaggle**上找到（[https://www.kaggle.com/nsaravana/breast-cancer?select=breast-cancer.csv](https://www.kaggle.com/nsaravana/breast-cancer?select=breast-cancer.csv)）。该文件也已上传到本书的GitHub存储库中。
- en: When looking at data, sometimes we want to make comparisons with the data we
    currently have, or we want to use it for predictions in machine learning. In this
    case, we're going to look at how we can present another type of plot, the **scatterplot**,
    using two specific values of columns in our dataset.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看数据时，有时我们想要与我们当前拥有的数据进行比较，或者我们想要在机器学习中使用它进行预测。在这种情况下，我们将看看如何使用数据集中两个特定列的值来呈现另一种类型的图表，即**散点图**。
- en: Let's imagine you received this data and already determined that your mean perimeter
    and mean textures are better predictors than the other values in the columns.
    Your goal now is to create an algorithm that will analyze the values for those
    two columns by comparing them using a scatterplot. Our goal is only to get that
    scatterplot. For additional analysis and machine learning applications, feel free
    to explore [*Chapter 13*](B15413_13_Final_SK_ePub.xhtml#_idTextAnchor174), *Using
    Classification and Clusters*, and [*Chapter 14*](B15413_14_Final_SK_ePub.xhtml#_idTextAnchor184),
    *Using Computational Thinking and Python in Statistical Analyses*, for additional
    help.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您收到了这些数据，并且已经确定您的平均周长和平均纹理比列中的其他值更好。您现在的目标是创建一个算法，通过比较这两列的值来分析这两列的值，使用散点图。我们的目标只是获得那个散点图。对于额外的分析和机器学习应用，可以自由探索[*第13章*]，*使用分类和聚类*，和[*第14章*]，*在统计分析中使用计算思维和Python*，以获取额外的帮助。
- en: 'The full code for this problem can be found in the file `ch16_BreastCancerSample.py`.
    We can now start to design our algorithm:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的完整代码可以在文件`ch16_BreastCancerSample.py`中找到。我们现在可以开始设计我们的算法：
- en: 'We begin as we normally do with data, importing the libraries we''ll use. Note
    that we are using two display libraries here, the `matplotlib` and `seaborn` libraries.
    This is the first time we''ll use `seaborn`. We are using `seaborn` because the
    additional work, such as finding regression lines, is handled easily with the
    help of this library:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们像往常一样从数据开始，导入我们将使用的库。请注意，我们在这里使用了两个显示库，即`matplotlib`和`seaborn`库。这是我们第一次使用`seaborn`。我们使用`seaborn`是因为使用这个库可以轻松处理额外的工作，比如找到回归线：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we''re going to find the `.csv` file. Remember that you can always establish
    the directory first. Otherwise, make sure you include the full location of the
    file. Since our directories are different, make sure you change that before running
    the file:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们要找到`.csv`文件。请记住，您可以先建立目录。否则，请确保您在运行文件之前包含文件的完整位置。由于我们的目录不同，请确保在运行文件之前更改目录：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Notice the `dataset.head()` command in the algorithm. If we run the code up
    until that point only, then we get the following output:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意算法中的`dataset.head()`命令。如果我们仅运行代码到那一点，那么我们会得到以下输出：
- en: '![Figure 16.2 – Table showing the heading values'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.2 - 显示标题数值的表格'
- en: '](image/Figure_16.02_B15413.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_16.02_B15413.jpg)'
- en: Figure 16.2 – Table showing the heading values
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2 - 显示标题数值的表格
- en: The `dataset.isnull().sum()` command helps us see whether we have empty data
    points or values.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`dataset.isnull().sum()`命令帮助我们查看是否有空数据点或值。'
- en: If we have many null points, we can clean the dataset before we start the analysis.
    This data is clean, as can be seen from the following output if we run the program
    up until `dataset.isnull().sum()`, as can be seen in the following screenshot:![Figure
    16.3 – Output of the null check
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有许多空值，我们可以在开始分析之前清理数据集。这个数据是干净的，可以从以下输出中看到，如果我们运行程序直到`dataset.isnull().sum()`，如下屏幕截图所示：![图16.3
    - 空值检查的输出
- en: '](image/Figure_16.03_B15413.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_16.03_B15413.jpg)'
- en: Figure 16.3 – Output of the null check
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.3 - 空值检查的输出
- en: 'Since there are no missing values, as seen in the preceding screenshot, we''re
    going to continue to our next snippet, where we''ll create the `count` variable
    for diagnosis:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于没有缺失值，如前面的屏幕截图所示，我们将继续到下一个代码片段，我们将为诊断创建`count`变量：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `count` variable is created in the preceding snippet, meaning we can create
    a bar graph using the values of the diagnosis, whether it was malignant or benign.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中创建了`count`变量，这意味着我们可以使用诊断的值来创建条形图，无论是恶性还是良性。
- en: 'The following code snippet creates that bar graph and shows us the resulting
    output:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段创建了该条形图并显示了结果输出：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Take a look at the following screenshot, which shows the bar graph using the
    diagnosis values. As you can see, the bar graph shows the count of **malignant**
    tumors versus **benign** tumors:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的屏幕截图，显示了使用诊断数值的条形图。正如你所看到的，条形图显示了**恶性**肿瘤与**良性**肿瘤的数量：
- en: '![Figure 16.4 – Malignant versus benign diagnosis bar graph'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.4 - 恶性与良性诊断条形图'
- en: '](image/Figure_16.04_B15413.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_16.04_B15413.jpg)'
- en: Figure 16.4 – Malignant versus benign diagnosis bar graph
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.4 - 恶性与良性诊断条形图
- en: Now that we have that information and the bar graph, we can start looking at
    other combinations and comparisons using the values from our dataset.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这些信息和条形图，我们可以开始使用数据集中的数值来查看其他组合和比较。
- en: 'You can run a different analysis to see which are more relevant, but for now,
    we are just going to use the perimeter mean and texture mean to create our scatterplot.
    The following code snippet shows how to create those using the `seaborn` library:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以运行不同的分析来查看哪些更相关，但现在，我们只是要使用周长均值和纹理均值来创建我们的散点图。以下代码片段显示了如何使用`seaborn`库来创建这些：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once we have created our scatterplot, the algorithm will return the following
    output, which shows the mean perimeter scatterplot compared with the mean texture
    scatterplot:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了我们的散点图后，算法将返回以下输出，显示了平均周长散点图与平均纹理散点图的比较：
- en: '![Figure 16.5 – Mean perimeter versus mean texture scatterplot'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.5 - 平均周长与平均纹理散点图'
- en: '](image/Figure_16.05_B15413.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_16.05_B15413.jpg)'
- en: Figure 16.5 – Mean perimeter versus mean texture scatterplot
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.5 - 平均周长与平均纹理散点图
- en: We are going to pause here for this data analysis. However, please note that
    you can take this example much further. In fact, you can find multiple applications
    and analyses done in Kaggle with this particular dataset and how some developers
    and coders incorporated machine learning in order to make predictions. The world
    of bioinformatics is wide and data science applications are continuing to grow.
    The use of Python in these problems is helpful due to its ease of use and applicable
    libraries.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里暂停数据分析。但是，请注意，您可以将此示例推进得更远。事实上，您可以在Kaggle中找到对这个特定数据集进行的多个应用和分析，以及一些开发人员和编码人员如何整合机器学习以进行预测。生物信息学的世界是广阔的，数据科学应用也在不断增长。在这些问题中使用Python是有帮助的，因为它易于使用并且有适用的库。
- en: Problem 3 – Using Python to analyze data for specific populations
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题3 - 使用Python分析特定人群的数据
- en: For this section, we'll state our problem this way—the year is 2020 and the
    world is overwhelmed by a pandemic due to the **SARS-COV-19** virus, also known
    as **coronavirus** or **COVID-19**. The data is available widely and we are trying
    to look at what's happening in a specific location, in particular, how the number
    of deaths are growing for that location. We find the New York Times GitHub repository,
    which contains the COVID-19 data, and download the master data, which is updated
    daily. Let's look at what we need to do and how we find it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，我们将以这种方式陈述我们的问题 - 现在是2020年，世界被一种名为**SARS-COV-19**的病毒，也称为**冠状病毒**或**COVID-19**，的大流行所压倒。数据是广泛可用的，我们试图看看特定位置发生了什么情况，特别是该位置的死亡人数是如何增长的。我们找到了纽约时报的GitHub存储库，其中包含COVID-19数据，并下载了每日更新的主数据。让我们看看我们需要做什么以及我们如何找到它。
- en: Defining the specific problem to analyze and identify the population
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义要分析和识别人群的具体问题
- en: This problem is broad. *Too broad!* So let's first look at 1 location and for
    only 1 month. For example, let's choose Puerto Rico and the month of October.
    From the master `.csv` file, we've pulled only the data specific for Puerto Rico
    and added it to our repository. Again, the master can be found in the New York
    Times, covid-19-data repository, and you can perform multiple analyses using the
    full data, a specific state, or even a specific county.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题很广泛。*太广泛了！*因此，让我们首先看一个地点，仅限一个月。例如，让我们选择波多黎各和十月份。从主`.csv`文件中，我们只提取了波多黎各特定的数据，并将其添加到我们的存储库中。同样，可以在纽约时报的covid-19-data存储库中找到主数据，并且您可以使用完整数据、特定州甚至特定县进行多种分析。
- en: 'For now, we''re going to concentrate on creating a visual for the data for
    deaths specific to Puerto Rico in October 2020\. From just looking at the data,
    we see that the deaths are rising. Take a look at the following screenshot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将集中于创建一个关于2020年10月波多黎各特定死亡数据的可视化。仅仅通过查看数据，我们就可以看到死亡人数正在上升。请看下面的截图：
- en: '![Figure 16.6 – Data for the first 20 days of October 2020 in Puerto Rico'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.6 - 2020年10月波多黎各前20天的数据'
- en: '](image/Figure_16.06_B15413.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_16.06_B15413.jpg)'
- en: Figure 16.6 – Data for the first 20 days of October 2020 in Puerto Rico
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.6 - 2020年10月波多黎各前20天的数据
- en: As you can see from the preceding screenshot, the **deaths** column continues
    to rise, as does the number of cases, which we will take a look at a little later
    in this problem.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图可以看出，**死亡**列继续上升，病例数量也是如此，我们稍后将在本问题中再次查看。
- en: 'While data read in a table format can be helpful, a visual representation is
    critical if we were to present this information, especially if we want to identify
    trends and influence policy changes. So let''s take a look at how we''d create
    a scatterplot for this particular data. The full file can be found in `ch16_CovidPR.py`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然以表格格式读取的数据可能有所帮助，但如果我们要呈现这些信息，特别是如果我们想要识别趋势并影响政策变化，那么可视化表示就至关重要。因此，让我们看看如何为这些特定数据创建散点图。完整文件可以在`ch16_CovidPR.py`中找到：
- en: 'As always when working with data, we need to make sure we import the libraries
    we''ll be using:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与数据一起工作时，我们需要确保导入我们将使用的库：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we''ll need to get our file. Remember, there are multiple ways to do
    this. You can give Python the full location of your file or you can first identify
    the directory and only provide the filename. Please make sure you change the location
    of the `.csv` file you''ll be using before running the program:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要获取我们的文件。请记住，有多种方法可以做到这一点。您可以给Python提供文件的完整位置，或者您可以首先识别目录，然后只提供文件名。在运行程序之前，请确保更改您将使用的`.csv`文件的位置：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After identifying the file, we''ll just create a simple scatterplot using the
    dates as our *x*-axis, and the deaths as our *y*-axis. The next few commands in
    this code snippet are done to make it easier to read the chart, such as the *y*-axis
    label, the rotation of the *x-tick* marks, and the title of the chart. The *x-tick*
    marks are the division marks for the horizontal axis, or *x*-axis. You can see
    the *x-tick* marks and the labels in *Figure 16.6*:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在确定文件后，我们将只需使用日期创建一个简单的散点图作为我们的*x*轴，以及死亡人数作为我们的*y*轴。此代码片段中的下几个命令是为了使图表更易于阅读，例如*y*轴标签，*x-tick*标记的旋转以及图表的标题。*x-tick*标记是水平轴或*x*轴的分割标记。您可以在*图16.6*中看到*x-tick*标记和标签：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you can see from the preceding code snippet, we also created an image file
    for us to use later, if needed. The chart will show on our screen, as can be seen
    in the following screenshot:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码片段可以看出，我们还创建了一个图像文件，以备将来使用。该图表将显示在我们的屏幕上，如下截图所示：
- en: '![Figure 16.7 – Deaths per day during October 2020 due to COVID-19 in Puerto
    Rico'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.7 - 2020年10月波多黎各每日死亡人数由于COVID-19'
- en: '](image/Figure_16.07_B15413.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_16.07_B15413.jpg)'
- en: Figure 16.7 – Deaths per day during October 2020 due to COVID-19 in Puerto Rico
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.7 - 2020年10月波多黎各每日死亡人数由于COVID-19
- en: This is a helpful chart to see that the number of deaths is increasing at a
    steady pace. There are more things we can do, such as try to determine the regression,
    which is another functionality we can do with Python using the `numpy` library,
    which you are welcome to work out!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有用的图表，可以看出死亡人数正在稳步增加。我们还可以做更多的事情，比如尝试确定回归，这是我们可以使用Python的`numpy`库做的另一个功能，欢迎您去尝试！
- en: 'For now, we''re going to take a look at the cases by date. The code is the
    same as previously, except that our *y*-axis and title will be different. The
    full code can be found in the `ch16_CovidPR_2` file. As the code is very similar,
    we are not sharing it here. However, our resulting graph can be seen in the following
    screenshot:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看一下按日期分类的病例。代码与以前相同，只是我们的*y*轴和标题将不同。完整代码可以在`ch16_CovidPR_2`文件中找到。由于代码非常相似，我们在这里不分享它。但是，我们的结果图可以在下面的截图中看到：
- en: '![Figure 16.8 – Cases per day during October 2020 due to COVID-19 in Puerto
    Rico'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.8 - 2020年10月波多黎各COVID-19每日病例'
- en: '](image/Figure_16.08_B15413.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_16.08_B15413.jpg)'
- en: Figure 16.8 – Cases per day during October 2020 due to COVID-19 in Puerto Rico
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.8 - 2020年10月波多黎各COVID-19每日病例
- en: As you can see from the preceding screenshot, the number of cases has continued
    to rise each day in Puerto Rico. There are multiple things we could do with these
    two graphs; analyzing their regressions, verifying additional trends by looking
    at other monthly data, and so on. You've now seen how to create a simple plot
    to display the data based on your `.csv` file; the rest is up to you. We will
    look at a new problem in the next section.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图中可以看出，波多黎各的病例数量每天都在上升。我们可以对这两个图表做很多事情；分析它们的回归，通过查看其他月度数据来验证额外的趋势等等。您已经看到如何根据您的`.csv`文件创建一个简单的图表来显示数据；其余的就取决于您了。我们将在下一节中研究一个新问题。
- en: Problem 4 – Using Python to create models of housing data
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题4 - 使用Python创建房屋数据模型
- en: Let's take a look at a problem where we want to display trends and information
    about the housing market in Brooklyn, New York. The dataset includes information
    from the NYC Housing Sales Data for 2003-2017\. The dataset used has the information
    merged in a usable format and can be found on Kaggle here ([https://www.kaggle.com/tianhwu/brooklynhomes2003to2017](https://www.kaggle.com/tianhwu/brooklynhomes2003to2017)).
    In addition, a copy of the `.csv` file can be found in the GitHub repository under
    the name `brooklyn_sales_map.csv`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个问题，我们想要显示布鲁克林，纽约的房地产市场的趋势和信息。数据集包括2003年至2017年纽约市房屋销售数据的信息。使用的数据集已经以可用格式合并，并且可以在Kaggle上找到（[https://www.kaggle.com/tianhwu/brooklynhomes2003to2017](https://www.kaggle.com/tianhwu/brooklynhomes2003to2017)）。此外，`.csv`文件的副本可以在GitHub存储库中找到，文件名为`brooklyn_sales_map.csv`。
- en: Defining the problem
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义问题
- en: We have a large data file for this particular problem. We can look at information
    by neighborhood, sale prices by year, compare the year built to the neighborhood
    to find trends, history, and so on. We could spend hours, days, and weeks just
    on this one dataset. So let's try to focus our energy into what we are going to
    accomplish with this example. For this, we're going to create two visual models.
    The first is a horizontal bar graph of housing percentages in a sale range according
    to the year of sale. The second is a bar graph that shows the price range by the
    neighborhoods where houses were sold.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定的问题，我们有一个庞大的数据文件。我们可以按社区查看信息，按年份比较销售价格，将建造年份与社区进行比较以找到趋势、历史等等。我们可以花费数小时、数天、数周来处理这个数据集。所以让我们尝试把精力集中在这个例子中要完成的事情上。为此，我们将创建两个可视化模型。第一个是根据销售年份的房屋百分比的水平条形图。第二个是显示房屋销售地点的价格范围的条形图。
- en: The horizontal bar graph can help display the data in a much clearer way so
    that we can see house price ranges and whether there are significant changes.
    The vertical bar graph can show us those same price ranges by neighborhood, so
    we can see whether there are significant changes depending on the neighborhoods
    where the houses were sold.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 水平条形图可以帮助更清晰地显示数据，以便我们可以看到房屋价格范围以及是否有显著变化。垂直条形图可以按社区显示相同的价格范围，因此我们可以看到根据房屋销售地点的不同是否有显著变化。
- en: Algorithm and visual representations of data
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算法和数据的可视化表示
- en: 'Let''s take a look at the code snippet. The full file can be found in the GitHub
    repository under `ch16_housingBrooklyn.py`. As usual, don''t forget to update
    the file location in the file before trying to run the program:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下代码片段。完整的文件可以在GitHub存储库的`ch16_housingBrooklyn.py`下找到。和往常一样，在尝试运行程序之前不要忘记更新文件位置：
- en: 'For this particular program, we''ll need the `pandas` and `matplotlib` libraries,
    so we need to import them:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个特定的程序，我们需要`pandas`和`matplotlib`库，所以我们需要导入它们：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we need to read our file. This is where you''ll need to update this code
    in order to run it from your machine:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要读取我们的文件。这就是你需要更新这段代码以便在你的机器上运行它的地方：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now we''re going to create our `bins`. These are our range of values and we''ll
    call them when we are creating the charts, as you can see under `df[''price_range'']`
    within the following few lines of code:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们要创建我们的“bins”。这些是我们的值范围，当我们创建图表时会用到它们，你可以在以下几行代码中的`df['price_range']`下看到它们：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we''re going to define a function, where we are going to convert some of
    the data. Notice that we run that function on each of the years from the dataset
    to find our percent total, which we''ll use later on for `housing_df`:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们要定义一个函数，我们将在其中转换一些数据。请注意，我们在数据集的每一年上运行该函数，以找到我们稍后将用于`housing_df`的总百分比：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding snippet helps us to create the first of the two models. This
    one is a horizontal bar graph. We labeled all the axes and the graph, and then,
    in the next line shown in the preceding code snippet, we also defined the color
    map we''ll use for this graph, in this case, `''Spectral''`. You can play with
    the color mappings available for easier reading. Take a look at our first graph,
    shown as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的片段帮助我们创建了两个模型中的第一个。这是一个水平条形图。我们标记了所有的轴和图表，然后在前面的代码片段中显示的下一行中，我们还定义了我们将在这个图表中使用的颜色映射，这里是`'Spectral'`。你可以尝试不同的颜色映射以便更容易阅读。看一下我们的第一个图表，如下所示：
- en: '![Figure 16.9 – Housing sales in Brooklyn by year'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.9-布鲁克林每年的房屋销售'
- en: '](image/Figure_16.09_B15413.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_16.09_B15413.jpg)'
- en: Figure 16.9 – Housing sales in Brooklyn by year
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.9-布鲁克林每年的房屋销售
- en: Notice that we use percentages in the preceding screenshot. This allows us to
    show how much of the sales were in each price range, but it does not show us the
    actual number of sales in each price range. Those two things are quite different.
    Here, we are looking for trends. The percentage of sales that were higher than
    $1,000,000 has consistently increased after a slight dip from **2008** to **2009**.
    In **2017**, a much larger percentage of sales was above that price point than
    in **2003**.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们在前面的截图中使用了百分比。这使我们能够显示每个价格范围的销售额占比，但它并没有显示每个价格范围的实际销售数量。这两件事情是完全不同的。在这里，我们正在寻找趋势。销售额高于100万美元的百分比在2008年到2009年略微下降后一直在增加。在2017年，高于这个价格点的销售额比2003年要高得多。
- en: But that's total sales. If we were only looking at this graph without looking
    at the numbers as well, we wouldn't know whether fewer houses were sold in total
    in 2017, for example. Again, the important thing to note here is that this graph
    is extremely helpful for understanding the share of housing selling under each
    price range, but that's all this graph really gives us. Now let's look at the
    remaining code from our file.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 但这是总销售额。如果我们只看这张图而不看数字，我们就不知道例如2017年总共卖出了更少的房子。再次，需要注意的重点是，这张图对于理解每个价格范围内房屋销售份额非常有帮助，但这就是这张图给我们的全部信息。现在让我们看看文件中剩下的代码。
- en: 'In this next snippet, we create our second graph, which uses our information
    to produce a vertical bar graph with the percentages within each price range for
    each neighborhood:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下面的片段中，我们创建了我们的第二张图，它使用我们的信息为每个社区的每个价格范围生成了一个垂直条形图的百分比：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This graph shows us the price range in each neighborhood using a bar graph.
    Let''s take a look at our second graph in the following screenshot:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图用条形图显示了每个社区的价格范围。让我们看一下以下截图中的第二张图：
- en: '![Figure 16.10 – Pricing by neighborhoods in Brooklyn from 2003-2017'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.10-布鲁克林2003-2017年各社区的定价'
- en: '](image/Figure_16.10_B15413.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_16.10_B15413.jpg)'
- en: Figure 16.10 – Pricing by neighborhoods in Brooklyn from 2003-2017
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.10-布鲁克林2003-2017年各社区的定价
- en: As you can see from the preceding screenshot, we get some important information
    that is additional or more detailed than that in *Figure 16.1*. In this case,
    the data is provided by neighborhood and the breakdown is provided by price range
    in those neighborhoods.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从前面的截图中所看到的，我们得到了一些比*图16.1*中提供的更详细或更详细的重要信息。在这种情况下，数据是由邻里提供的，并且该数据是按那些邻里的价格范围进行了分类。
- en: When we look at a large dataset, we can create multiple different models and
    even use them to predict values moving forward. Take a look at the data available
    in the `.csv` file and try to create some different representations using other
    data, such as commercial versus residential sales, tax class breakdowns, and more.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看大型数据集时，我们可以创建多个不同的模型，甚至使用它们来预测未来的值。查看`.csv`文件中可用的数据，并尝试使用其他数据创建一些不同的表示，例如商业与住宅销售、税务分类等。
- en: Problem 5 – Using Python to create electric field lines
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题5 – 使用Python创建电场线图
- en: 'In this section, let''s look at some applications of Python for engineering
    and, in particular, physics. We are going to be creating an **electric field lines
    plot**. *Why would we want to create that kind of plot and what exactly is it?*
    An electric field happens when there is an electric charge. We use vectors to
    show these electric fields for every point in space. In physics, an electric field
    is an electric force per unit charge. Take a look at what that field looks like
    for a positive point charge and a negative point charge, as shown in the following
    diagram:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们看一下Python在工程和特别是物理学中的一些应用。我们将创建一个**电场线图**。*为什么我们要创建这种类型的图，并且它到底是什么？*
    当存在电荷时，就会产生电场。我们使用矢量来显示空间中每一点的电场。在物理学中，电场是单位电荷的电力。看一下正点电荷和负点电荷的电场是什么样子，如下图所示：
- en: '![Figure 16.11 – Electric field sample'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.11 – 电场示例'
- en: '](image/Figure_16.11_B15413.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_16.11_B15413.jpg)'
- en: Figure 16.11 – Electric field sample
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.11 – 电场示例
- en: As you can see, an electric field line will begin at the charge or end at the
    charge. If it begins at the charge, it is positive, while it if ends at the charge,
    it is negative, as can be seen in the preceding screenshot. There are a fewer
    number of lines for a lesser charge and more lines for a larger charge. In addition,
    the lines will be closer for a larger charge than for a smaller charge.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，电场线将从电荷开始或结束于电荷。如果它从电荷开始，它是正的，而如果它结束于电荷，它是负的，正如前面的截图所示。较小的电荷会有较少的线条，而较大的电荷会有更多的线条。此外，对于较大的电荷，线条会比较接近，而对于较小的电荷，线条会比较远。
- en: 'For our problem, we want to create an electric field lines plot for any number
    of charges. So let''s take a look at what that would look like in the following
    code file. Note that we''ve broken the code down to explain various sections,
    but the full file can be found in the GitHub repository:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的问题，我们想要为任意数量的电荷创建一个电场线图。让我们看看下面的代码文件中会是什么样子。请注意，我们已经将代码分解以解释各个部分，但完整的文件可以在GitHub存储库中找到：
- en: 'As usual, first, we''ll begin by importing the necessary libraries:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样，首先，我们将导入必要的库：
- en: ch16_electricFieldLines.py
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ch16_electricFieldLines.py
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, we''ll set up our *x* and *y* axes by defining some variables:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将通过定义一些变量来设置我们的*x*和*y*轴：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding code snippet, we work on defining our grid and setting up the
    coordinates. Then we create the mesh grid. The `meshgrid()` function returns matrices
    of coordinates from vector coordinates.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们致力于定义我们的网格并设置坐标。然后我们创建了网格。`meshgrid()`函数从向量坐标返回坐标矩阵。
- en: 'After we have set our coordinates and set our mesh grid, we can start defining
    what happens with our charges. First, we''ll need to identify how many charges
    will be plotted:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置了我们的坐标并设置了我们的网格之后，我们可以开始定义我们的电荷发生了什么。首先，我们需要确定将绘制多少个电荷：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see from the preceding snippet of code, after we identified the number
    of charges, we created two empty lists. Then we added coordinates to those lists
    based on the number of charges using nested `for` loops.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从前面的代码片段中所看到的，我们确定了电荷的数量后，创建了两个空列表。然后我们使用嵌套的`for`循环根据电荷的数量向这些列表添加坐标。
- en: 'After we do the necessary math to get our coordinates and vectors, we can then
    go ahead and plot our electric field lines graph. We''ll use a `quiver` plot,
    which is a `matplotlib` graphic we can use for creating vector fields:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们进行必要的数学运算以获得我们的坐标和向量之后，我们可以继续绘制我们的电场线图。我们将使用`quiver`图，这是一个我们可以用来创建矢量场的`matplotlib`图形：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It''s important to always add labels to our graphs and plots, as this will
    make the information more readable, especially for those who do not know what
    the code behind this means or what the graphs and plots represent. When we run
    our code snippet, we get the following output:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要始终为我们的图表和绘图添加标签，因为这将使信息更易读，特别是对于那些不知道这背后的代码意味着什么或图表和绘图代表什么的人。当我们运行我们的代码片段时，我们会得到以下输出：
- en: '![Figure 16.12 – Electric field lines for eight charges'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.12 – 八个电荷的电场线'
- en: '](image/Figure_16.12_B15413.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_16.12_B15413.jpg)'
- en: Figure 16.12 – Electric field lines for eight charges
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.12 – 八个电荷的电场线
- en: 'As you can see in our plot, there are positive and negative charges. Take a
    look at the bottom right-hand corner charge in the graph. That charge is negative,
    as the arrows are pointing toward the charge. The *left-most* charge, which has
    been zoomed-in, shown as follows, shows a positive charge, as the arrows are pointing
    away from the charge:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在我们的图中所看到的，有正电荷和负电荷。看一下图中右下角的电荷。该电荷是负的，因为箭头指向电荷。最左边的电荷，已经放大，如下所示，显示为正电荷，因为箭头指向远离电荷的方向：
- en: '![Figure 16.13 – Zoomed positive charge'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.13 – 放大的正电荷'
- en: '](image/Figure_16.13_B15413.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_16.13_B15413.jpg)'
- en: Figure 16.13 – Zoomed positive charge
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.13 – 放大的正电荷
- en: 'Let''s take a look at one final graphic, shown in the following screenshot,
    with an electric field lines plot that has three charges:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们来看最后一个图形，如下截图所示，其中有一个具有三个电荷的电场线图：
- en: '![Figure 16.14 – Electric field lines with three charges'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.14 - 具有三个电荷的电场线'
- en: '](image/Figure_16.14_B15413.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_16.14_B15413.jpg)'
- en: Figure 16.14 – Electric field lines with three charges
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.14 - 具有三个电荷的电场线
- en: As you can see, this particular plot contains two positive charges and one negative
    charge. If we ran this again, we may get three positive charges, for example,
    as each time we run the algorithm, we get a new representation with random values
    for positive and negative charges.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这个特定的图包含两个正电荷和一个负电荷。如果我们再次运行，我们可能会得到三个正电荷，例如，因为每次运行算法时，我们都会得到一个新的表示，其中正电荷和负电荷的值是随机的。
- en: These kinds of fields and learning how to use vectors and quiver plots can help
    us represent a lot of information. In the case of electric field lines, we can
    learn a lot about the charges, direction, and the strength of those charges with
    a simple visual plot.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的领域以及学习如何使用矢量和箭头图可以帮助我们表示大量信息。在电场线的情况下，我们可以通过简单的视觉图了解电荷的方向和强度。
- en: Take a look at the code snippet in the GitHub repository and try changing some
    of the parameters, such as the size of the plot and the number of charges. The
    more practice you get with these plots and altering some of the parameters, the
    easier they become to create.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 看看GitHub存储库中的代码片段，并尝试更改一些参数，例如图的大小和电荷的数量。通过这些图的实践和改变一些参数，您可以更容易地创建它们。
- en: Problem 6 – Using Python to analyze genetic data
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题6 - 使用Python分析基因数据
- en: Let's shift focus to looking at a larger dataset. You're working with laboratory
    mice and get data for **trisomy mice** and protein expressions in these mice.
    We've truncated some of the data from the public domain file in Kaggle for this
    due to its huge size. We're only focusing on six protein expressions for the mice
    and again, only the trisomy (**Down syndrome**) mice in the study. The full file
    can be found in Kaggle at [https://www.kaggle.com/ruslankl/mice-protein-expression](https://www.kaggle.com/ruslankl/mice-protein-expression).
    The truncated file can be found in our GitHub repository.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把注意力转移到查看一个更大的数据集。您正在处理实验室小鼠的数据，并获得了**三体小鼠**和这些小鼠的蛋白质表达的数据。由于数据量巨大，我们从Kaggle的公共领域文件中截取了一些数据。我们只关注这些小鼠的六种蛋白质表达，并且再次只关注研究中的三体（**唐氏综合征**）小鼠。完整的文件可以在Kaggle上找到[https://www.kaggle.com/ruslankl/mice-protein-expression](https://www.kaggle.com/ruslankl/mice-protein-expression)。截断文件可以在我们的GitHub存储库中找到。
- en: Let's say you don't know where to start with this data. *What should you even
    be looking at?* Well, that's often the first thing we encounter in data science.
    We don't always get to be part of the study design or data collection. Many times,
    we receive large data files and need to figure out what to look for, how to tackle
    the problem, whatever we decide the problem is, and how to display the information
    in the best possible way.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您不知道从这些数据的哪里开始。*您甚至应该看什么？*嗯，这通常是数据科学中遇到的第一件事。我们并不总是能参与研究设计或数据收集。很多时候，我们会收到大量的数据文件，并需要找出要查找的内容，如何解决问题，无论我们决定的问题是什么，以及如何以最佳方式显示信息。
- en: 'Also, this is your reminder to change the location of the file before you attempt
    to run this program. This very simple program can be found in the `ch16_pairplots.py`
    file. Let''s begin with the algorithm:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，这是提醒您在尝试运行此程序之前更改文件位置的提示。这个非常简单的程序可以在`ch16_pairplots.py`文件中找到。让我们从算法开始：
- en: 'The `seaborn` library can help us a bit just to get us started. We can create
    `pairplot()`, which will correlate the numerical data in the `.csv` file using
    histograms and scatterplots. It''s kind of like a fantastic magic trick. We can
    use two lines of code to see what we see. Take a look at the two lines that are
    needed to generate *Figure 16.7* (note that there''s actually four lines of code,
    but I''m not counting the two lines I''m using to import my libraries):'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`seaborn`库可以帮助我们一点，让我们开始。我们可以创建`pairplot()`，它将使用直方图和散点图相关联`.csv`文件中的数值数据。这有点像一个神奇的魔术。我们可以用两行代码来看看我们看到了什么。看看生成*图16.7*所需的两行代码（请注意，实际上有四行代码，但我没有计算我用来导入库的两行代码）：'
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Be patient when you run this program. The algorithm may be simple, but what
    it''s doing in the background isn''t so simple. Take a look at the following screenshot
    to see our pairplot:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此程序时，请耐心等待。算法可能很简单，但它在后台所做的事情并不简单。请看以下截图以查看我们的配对图：
- en: '![Figure 16.15 – Pairplot of protein expressions in trisomy mice with the treatment
    variable'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.15 - 三体小鼠中蛋白质表达的配对图与治疗变量'
- en: '](image/Figure_16.15_B15413.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_16.15_B15413.jpg)'
- en: Figure 16.15 – Pairplot of protein expressions in trisomy mice with the treatment
    variable
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.15 - 三体小鼠中蛋白质表达的配对图与治疗变量
- en: Notice that our data has two colors based on the treatment, which is an injection
    of memantine or saline, respectively. From the plots, we can see that some of
    the proteins seem to have a higher correlation than others. Let's pause on that
    for a second.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的数据根据治疗方式分为两种颜色，分别是注射甲胺醇或盐水。从图中我们可以看到，一些蛋白质似乎比其他蛋白质具有更高的相关性。让我们暂停一下。
- en: 'Let''s now say that our goal wasn''t to check on the expression based on the
    treatment, but rather the class. Then we can run the code, but first we change
    the hue to `class` in our algorithm. The result is shown as follows:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在假设我们的目标不是根据治疗来检查表达，而是根据类别。然后我们可以运行代码，但首先我们将在算法中将色调更改为`class`。结果如下所示：
- en: '![Figure 16.16 - Pairplot of protein expressions in trisomy mice with the class
    variable'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.16 - 三体小鼠中蛋白质表达的配对图与类变量'
- en: '](image/Figure_16.16_B15413.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_16.16_B15413.jpg)'
- en: Figure 16.16 - Pairplot of protein expressions in trisomy mice with the class
    variable
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.16 - 三体小鼠中蛋白质表达的配对图与类变量
- en: Notice that the plots are extremely similar. Where the plots do differ, however,
    is in the identification of where each of the points lies based on another characteristic.
    For example, in the `class` variable chart, we have four colors because there
    are four classes of mice in our particular dataset.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些图表非常相似。然而，这些图表之间的区别在于根据另一个特征来确定每个点的位置。例如，在`class`变量图表中，我们有四种颜色，因为在我们的特定数据集中有四类老鼠。
- en: They are, namely, **t-CS-s**, which refers to the mice stimulated to learn (shock)
    and injected with saline; **t-CS-m**, which refers to the mice stimulated to learn
    (shock) and injected with memantine; **t-SC-s**, which refers to mice not stimulated
    to learn and injected with saline; and **t-SC-m**, which refers to mice not stimulated
    to learn and injected with memantine.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 它们分别是**t-CS-s**，指的是被刺激学习（电击）并注射生理盐水的老鼠；**t-CS-m**，指的是被刺激学习（电击）并注射美金刚烷的老鼠；**t-SC-s**，指的是未被刺激学习并注射生理盐水的老鼠；以及**t-SC-m**，指的是未被刺激学习并注射美金刚烷的老鼠。
- en: Looking at our correlations, we can see that there are strong positive correlations
    between many of the proteins, such as **NR2A_N** and **BDNF_N**. Whether or not
    that's relevant, whether it matters in our study, and whether it's not significant
    is something that we'd have to take into consideration if this were our study.
    Once we see the plots, we can then choose to explore the information further.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看我们的相关性，我们可以看到许多蛋白质之间存在强烈的正相关性，比如**NR2A_N**和**BDNF_N**。无论这是否相关，无论在我们的研究中是否重要，无论是否显著，这些都是我们在进行研究时需要考虑的事情。一旦我们看到图表，我们可以选择进一步探索信息。
- en: 'Another type of plot that can be helpful when looking at this dataset is the
    boxplot. We can use the boxplot to see the protein expression level by class for
    a protein we want to look at more closely. Let''s take the `NR2A_N` protein. Using
    the `seaborn` boxplot, we can create a plot for this particular protein using
    the code in the `ch16_boxplot.py` file. As always, check the file location first:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看这个数据集时，另一种有用的图表类型是箱线图。我们可以使用箱线图来查看我们想更仔细观察的蛋白质的类别的蛋白质表达水平。让我们以`NR2A_N`蛋白为例。使用`seaborn`箱线图，我们可以使用`ch16_boxplot.py`文件中的代码为这种特定蛋白创建一个图表。像往常一样，首先检查文件位置：
- en: '[PRE27]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding code, we identify the things we want to compare, which, in
    this case, are the protein and the class. We''ll then create the boxplot using
    our `seaborn` library, which can be seen as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们确定了我们想要比较的事物，即蛋白质和类别。然后我们将使用我们的`seaborn`库创建箱线图，如下所示：
- en: '![Figure 16.17 – Boxplot of the NR2A_N protein expression by class'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.17 - 按类别绘制NR2A_N蛋白表达的箱线图'
- en: '](image/Figure_16.17_B15413.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_16.17_B15413.jpg)'
- en: Figure 16.17 – Boxplot of the NR2A_N protein expression by class
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.17 - 按类别绘制NR2A_N蛋白表达的箱线图
- en: 'As you can see from the graph, the distributions for our trisomy mice vary
    by class, with the mice that were not stimulated to learn and injected with saline
    showing a wider range in the expression of this protein. Let''s try changing that
    protein to one of our others in the dataset, that is, the **ITSN1_N** protein.
    The following screenshot shows the resulting boxplot:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 从图表中可以看出，我们的三体老鼠的分布因类别而异，未被刺激学习并注射生理盐水的老鼠在这种蛋白质的表达上显示出更广泛的范围。让我们尝试将这种蛋白质更改为数据集中的其他蛋白质之一，即**ITSN1_N**蛋白。以下截图显示了生成的箱线图：
- en: '![Figure 16.18 – Boxplot of the ITSN1_N protein expression by class'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.18 - 按类别绘制ITSN1_N蛋白表达的箱线图'
- en: '](image/Figure_16.18_B15413.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_16.18_B15413.jpg)'
- en: Figure 16.18 – Boxplot of the ITSN1_N protein expression by class
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.18 - 按类别绘制ITSN1_N蛋白表达的箱线图
- en: In this particular boxplot, we can identify outliers in the **t-CS-m** and **t-SC-m**
    classes, that is, both mice classes that were injected with memantine. That may
    tell us to seek more information about any relationship between the memantine
    injections and that particular protein. *If we were to look at non-trisomy mice,
    would these spreads of data (range) hold for that protein if the other elements
    were the same?* Those are some of the things we would ask ourselves in looking
    at datasets such as this one.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的箱线图中，我们可以确定**t-CS-m**和**t-SC-m**类别中的异常值，即注射了美金刚烷的两类老鼠。这可能告诉我们需要进一步了解美金刚烷注射与该特定蛋白之间的任何关系。*如果我们要观察非三体老鼠，如果其他因素相同，这些数据（范围）是否适用于该蛋白？*
    这些是我们在观察这类数据集时会问自己的一些问题。
- en: If you remember, the computational thinking process is rarely a straight line.
    If we identify things we want to consider in our algorithm, we don't just leave
    our algorithm alone and decide it was already done, so we won't change it. We
    go back to identify what we need again, make the necessary changes to our design,
    and create our algorithm again. That's more closely what happens when we are dealing
    with larger datasets. We look at some initial visualizations, maybe create a few
    different types of plots, run some statistical analysis, and then decide where
    to go next with the data. This is just a glimpse into what is possible with Python.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得的话，计算思维过程很少是一条直线。如果我们确定了我们想要在算法中考虑的事情，我们不会只是让我们的算法独自运行并决定它已经完成了，所以我们不会对它进行更改。我们会回去重新确定我们需要什么，对我们的设计进行必要的更改，然后再次创建我们的算法。这更接近于当我们处理更大的数据集时会发生的情况。我们会查看一些初始的可视化，也许创建一些不同类型的图表，运行一些统计分析，然后决定下一步该如何处理数据。这只是Python可能实现的一小部分。
- en: Problem 7 – Using Python to analyze stocks
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题7 - 使用Python分析股票
- en: Time to play with some stocks. You can access a lot of data through **Quandl**,
    which allows for the use of a free API for educational uses. There are also premium
    datasets available. We're sticking to educational purposes, so that should be
    enough for our requirements.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候玩一些股票了。您可以通过**Quandl**访问大量数据，该平台允许免费使用API进行教育用途。也有一些高级数据集可用。我们将坚持教育目的，所以这对我们的要求应该足够了。
- en: 'In this problem, we''re going to learn how to pull data from Quandl and look
    at the VZ stock prices. **VZ** is the code for **Verizon** stock prices. We''re
    going to use them to predict the prices using `quandl`, which is a package for
    Python in addition to being a website full of useful information. Let''s take
    a look at how we grab the information we want. The full code, minus the API key,
    can be found in our repository under the `ch16_stockAnalysis.py` file:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们将学习如何从Quandl获取数据并查看VZ股票价格。**VZ**是**Verizon**股票价格的代码。我们将使用它们来使用`quandl`来预测价格，这是Python的一个包，也是一个充满有用信息的网站。让我们来看一下我们如何获取我们想要的信息。完整的代码，除了API密钥，可以在我们的存储库中的`ch16_stockAnalysis.py`文件中找到：
- en: 'Let''s take a look at how we can import the data. You''ll need your own API
    for this. If you want to check another stock, say for `AMZN`, you''d substitute
    `''EOD/VZ''` with `''WIKI/AMZ''`, for example. **AMZN** is the code for **Amazon**
    stock. But let''s take a look at our `VZ` set:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们来看一下如何导入数据。你需要自己的API。如果你想检查另一个股票，比如`AMZN`，你可以用`'WIKI/AMZ'`替换`'EOD/VZ'`。**AMZN**是**Amazon**股票的代码。但让我们来看看我们的`VZ`集：
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When we run the preceding code, we get the table for the first five values
    in our dataset. The following screenshot shows our table of values:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行上述代码时，我们得到了数据集中前五个值的表格。以下截图显示了我们的数值表：
- en: '![Figure 16.19 – EOD/VZ stock table'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.19 - EOD/VZ股票表'
- en: '](image/Figure_16.19_B15413.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_16.19_B15413.jpg)'
- en: Figure 16.19 – EOD/VZ stock table
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.19 - EOD/VZ股票表
- en: 'Now say we only wanted to focus on the adjusted close value in order to later
    make predictions. Then we can use the following code snippet to do so:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在假设我们只想关注调整后的收盘价，以便以后进行预测。那么我们可以使用以下代码片段来实现：
- en: '[PRE29]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After running the preceding code, our adjusted table can be seen as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码后，我们的调整后的表格如下所示：
- en: '![Figure 16.20 – EOD/VZ adjusted close stock value table'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.20 - EOD/VZ调整后的股票收盘价表'
- en: '](image/Figure_16.20_B15413.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_16.20_B15413.jpg)'
- en: Figure 16.20 – EOD/VZ adjusted close stock value table
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.20 - EOD/VZ调整后的股票收盘价表
- en: Now that we've learned to pull current data, we're going to now work with a
    dataset that we've placed in the GitHub repository so that we can ensure that
    you are able to replicate the results. You can then try to do this for current
    data using the Quandl API.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们已经学会了获取当前数据，我们将现在使用我们放在GitHub存储库中的数据集来进行操作，以确保你能够复制结果。然后你可以尝试使用Quandl API来获取当前数据。 '
- en: Let's take a look at the dataset with the filename `VZ.csv`. This contains the
    same data for VZ from 1983 to April 2020\. *What do we want from this dataset?*
    We want to make some predictions. So let's build that model.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下文件名为`VZ.csv`的数据集。这包含了1983年至2020年4月的VZ相同数据。*我们从这个数据集中想要什么？*我们想要做一些预测。所以让我们建立那个模型。
- en: 'Note that the code is fairly large, so the file with everything you need (minus
    the file location on *line 15*, which you''ll need to add), is in `ch16_predictionsModel.py`.
    But let''s take a look at some of the snippets of code from that file:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，代码相当长，所以包含了你需要的所有内容的文件（除了*第15行*的文件位置，你需要添加），在`ch16_predictionsModel.py`中。但让我们来看一下那个文件中的一些代码片段：
- en: 'The following code snippet will create a plot for our existing data in the
    dataset. It selects the `Date` column from the file and sets that as the index
    value. Then it creates a figure and adds the labels for the graph and axes:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段将为数据集创建一个图。它从文件中选择`Date`列并将其设置为索引值。然后它创建一个图并为图和坐标轴添加标签：
- en: '[PRE30]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We''re not looking at a model yet. We haven''t defined our training data. We''re
    just looking at what happened to our stock prices from **1983** to **2020**, shown
    as follows. Note that the first tick mark label states **1984**. Our data can
    be seen to start just slightly before **1984**. The tick marks are every 4 years
    since 1980, as shown:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有看到模型。我们还没有定义我们的训练数据。我们只是看了我们的股票价格从**1983**年到**2020**年的情况，如下所示。请注意，第一个刻度标签显示**1984**。我们的数据似乎是在**1984**年之前开始的。刻度标记是自1980年以来每4年一次，如下所示：
- en: '![Figure 16.21 – Closing price over time for VZ stock'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.21 - VZ股票随时间的收盘价'
- en: '](image/Figure_16.21_B15413.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_16.21_B15413.jpg)'
- en: Figure 16.21 – Closing price over time for VZ stock
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.21 - VZ股票随时间的收盘价
- en: Notice from the preceding chart that stock prices are not linear in any way.
    They rise, fall, and rise again. A predictive model will require a lot of data
    in order for us to prepare the best predictions possible. Our dataset has 9,166
    rows of data. That's going to come in handy in a second.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图表中可以看出，股票价格在任何情况下都不是线性的。它们上升、下降，然后再上升。一个预测模型将需要大量数据，以便我们能够准备出最佳的预测。我们的数据集有9166行数据。这将在下一步中派上用场。
- en: 'Let''s take a look at another snippet of code that we''ll be using:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们来看一下我们将要使用的另一段代码：
- en: '[PRE31]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice the `750` value in the `train_data=VZ3[0:750,:]` line of code. That means
    I'm using just the first 750 rows of 9,166 possible rows of data to train my model.
    This isn't so great.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意代码中`train_data=VZ3[0:750,:]`行中的`750`值。这意味着我只使用了数据的前750行，而不是可能的9166行数据来训练我的模型。这不太好。
- en: 'Let''s take a look at the following screenshot, which shows the results when
    we run this prediction model. Note that we did choose to copy the original information
    into our graphic. Python will point that out as a possible thing we want to fix.
    That''s up to you to do so. For now, having the original data available as overlaid
    for our graph provides us with a great visual for comparison purposes as regards
    our model:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下以下截图，显示了我们运行此预测模型时的结果。请注意，我们选择将原始信息复制到我们的图形中。Python会指出这可能是我们想要修复的问题。这取决于你是否要这样做。目前，将原始数据作为我们图形的叠加提供了一个很好的视觉比较模型的方式：
- en: '![Figure 16.22 – Closing price predictions'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.22 - 收盘价预测'
- en: '](image/Figure_16.22_B15413.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_16.22_B15413.jpg)'
- en: Figure 16.22 – Closing price predictions
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.22 - 收盘价预测
- en: As you can see in the preceding graphic, shown in orange here, we have the original,
    copied values. The green shows the predictions made by our model. They're not
    terrible, but they're not as tight as they could be.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的图表中所看到的，这里显示的橙色部分是原始的、复制的值。绿色显示了我们模型的预测。它们并不糟糕，但也不如它们本应该的那样紧密。
- en: 'Let''s see what happens when we use 7,500 rows of data instead, which is roughly
    82% of the data available. As a note, the file in the GitHub repository uses the
    value of 7,500, but feel free to change and adjust those so you can test the accuracy
    of your model. The following graph shows our results:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看当我们使用7500行数据时会发生什么，这大约是可用数据的82%。需要注意的是，GitHub存储库中的文件使用了7500的值，但您可以随意更改和调整这些值，以便测试模型的准确性。以下图表显示了我们的结果：
- en: '![Figure 16.23 – Prediction model using 7,500 rows of data'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.23 - 使用7500行数据的预测模型'
- en: '](image/Figure_16.23_B15413.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_16.23_B15413.jpg)'
- en: Figure 16.23 – Prediction model using 7,500 rows of data
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.23 - 使用7500行数据的预测模型
- en: Notice how much closer the real lines and the prediction lines are in this model.
    That's because the more data we have to train our model with, the better our predictions
    will become.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个模型中，真实线条和预测线条之间的距离更近了。这是因为我们用来训练模型的数据越多，我们的预测就会变得越好。
- en: Before we move on from this example, note that we did not cover the entirety
    of the code file here. Some of the code has been discussed in other areas of this
    book, so we focused on the parts of the algorithm that were new and critical to
    the algorithm solution due to the complexity of the algorithm. The final piece
    of that code file does use a **Long Short-Term Memory (LSTM)** model. An LSTM
    model is a type of artificial recurrent neural network. We use this model in machine
    learning to create deep learning models.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开这个例子之前，请注意我们并没有在这里涵盖代码文件的全部内容。本书的其他部分已经讨论了一些代码，因此我们专注于算法的新部分和对算法解决方案至关重要的部分。该代码文件的最后一部分确实使用了**长短期记忆（LSTM）**模型。LSTM模型是一种人工循环神经网络。我们在机器学习中使用这个模型来创建深度学习模型。
- en: '*Will our models actually predict the price of the stock?* No. Otherwise, we''d
    all have an easier time with the market. But models can get really good at predicting
    not the price, but whether or not the price will go up or down.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们的模型实际上能预测股票的价格吗？*不行。否则，我们在市场上就会轻松很多。但模型确实可以非常准确地预测价格是否会上涨或下跌。'
- en: Problem 8 – Using Python to create a convolutional neural network (CNN)
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题8 - 使用Python创建卷积神经网络（CNN）
- en: In this section, we're going to take a look at a problem that uses **artificial
    intelligence** (**AI**). More specifically, we're going to work on creating a
    **convolutional neural network**, or **CNN**. *So what is a CNN?* A CNN is a **Deep
    Learning algorithm**. CNNs take images as input. The image is then processed and
    given importance based on predetermined conditions that will help us differentiate
    and classify the images.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将研究一个使用**人工智能**（**AI**）的问题。更具体地说，我们将致力于创建一个**卷积神经网络**，或者**CNN**。*那么CNN是什么？*CNN是一种**深度学习算法**。CNN将图像作为输入。然后根据预定条件对图像进行处理和赋予重要性，这将帮助我们区分和分类图像。
- en: 'The following diagram illustrates the process involved in the convolutional
    neural network:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了卷积神经网络所涉及的过程：
- en: '![Figure 16.24 – Convolutional neural network process'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.24 - 卷积神经网络过程'
- en: '](image/Figure_16.24_B15413.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_16.24_B15413.jpg)'
- en: Figure 16.24 – Convolutional neural network process
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.24 - 卷积神经网络过程
- en: The CNN is created in order to simplify how we categorize the images without
    sacrificing accuracy in terms of the predictions we want to be able to get from
    our image analyses. It's like if we were applying a filter. Once we apply the
    filter, we can see the characteristics. The preceding diagram shows a simplified
    schematic for this process.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 卷积神经网络（CNN）是为了简化我们对图像进行分类的方式而创建的，同时又不牺牲我们希望从图像分析中得到的准确性。这就好像我们在应用滤镜一样。一旦我们应用了滤镜，我们就可以看到特征。前面的图表显示了这个过程的简化示意图。
- en: The problem we're going to be diving into is handwriting training and analysis.
    Thinking about the computational thinking process, what we're really trying to
    do is analyze handwriting as accurately as possible. To do so, we analyze hundreds
    or thousands of images to create and train our model. The more images we use,
    the more accurate our model will be.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要深入研究的问题是手写训练和分析。在考虑计算思维过程时，我们真正想要做的是尽可能准确地分析手写。为此，我们分析数百甚至数千张图像来创建和训练我们的模型。我们使用的图像越多，我们的模型就会越准确。
- en: For our model, we're going to use a dataset that contains 70,000 images. The
    first 60,000 images are used for training, while we'll use the other 10,000 for
    testing. The full code can be found in the `ch16_CNN_mnist.py` file. We'll take
    a look at some of the snippets from that code and also use some adjustments to
    show additional components. You can run the file in the GitHub repository without
    making changes as long as you have all the necessary libraries and packages installed.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的模型，我们将使用一个包含70,000张图像的数据集。前60,000张图像用于训练，而我们将使用其他10,000张进行测试。完整的代码可以在`ch16_CNN_mnist.py`文件中找到。我们将看一些来自该代码的片段，并进行一些调整以展示额外的组件。只要您安装了所有必要的库和软件包，就可以在GitHub存储库中运行文件而不进行更改。
- en: 'Let''s start designing the model:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始设计模型：
- en: 'Let''s first take a look at a snippet of code that will upload the dataset,
    and then show the first item in the dataset:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先看一段代码片段，它将上传数据集，然后显示数据集中的第一项：
- en: '[PRE32]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We used the index `0` in the training set to see that first image. The `cmap`
    property will make the colormap gray. You can adapt that and adjust it, as needed.
    As a side note, for those who have trouble seeing color or have particular color
    needs, changing the colormap can make a significant difference to how the images
    are perceived. Let''s take a look at that first image in the following screenshot:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在训练集中使用索引`0`来查看第一幅图像。`cmap`属性将使色图变为灰色。您可以根据需要进行调整。顺便说一句，对于那些有困难看到颜色或有特殊颜色需求的人来说，改变色图可以显著改变图像的感知方式。让我们看一下以下的第一幅图像：
- en: '![Figure 16.25 – First image in the MNIST training set'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.25 - MNIST训练集中的第一幅图像'
- en: '](image/Figure_16.25_B15413.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_16.25_B15413.jpg)'
- en: Figure 16.25 – First image in the MNIST training set
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.25 - MNIST训练集中的第一幅图像
- en: 'As you can see from the preceding screenshot, this is a handwriting sample,
    most likely of the number **5**. We can run the program a few more times with
    different indexes to see some other samples in our dataset. The following screenshot
    shows some of those samples and their corresponding indexes:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图中可以看出，这是一个手写样本，很可能是数字**5**。我们可以多次运行程序，使用不同的索引来查看数据集中的其他样本。以下截图显示了其中一些样本及其相应的索引：
- en: '![Figure 16.26 – Sample images in the dataset by index'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.26 - 数据集中的样本图像按索引'
- en: '](image/Figure_16.26_B15413.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_16.26_B15413.jpg)'
- en: Figure 16.26 – Sample images in the dataset by index
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.26 - 数据集中的样本图像按索引
- en: The data we are using is not quantitative, it is qualitative. We are looking
    at images, so we are in need of a process that can analyze those images. To do
    so, we use **One-Hot encoding**, which replaces integer encoded variables with
    new binary variables.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的数据不是定量的，而是定性的。我们正在查看图像，因此我们需要一个可以分析这些图像的过程。为此，我们使用**One-Hot编码**，它用新的二进制变量替换整数编码变量。
- en: 'Now that we''ve looked at what we''re working with, let''s reshape and encode
    our model using the following code snippet. As a reminder, the full code can be
    found in the repository, but some of the components will be slightly different
    (such as our file will not be testing the images in the dataset):'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经看了我们正在使用的东西，让我们使用以下代码片段来重塑和编码我们的模型。作为提醒，完整的代码可以在存储库中找到，但是一些组件会略有不同（例如我们的文件不会测试数据集中的图像）：
- en: '[PRE33]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, we are dividing the images into training and test sets. Then
    we encode them.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在将图像分成训练集和测试集。然后对它们进行编码。
- en: 'Once we have performed one-hot encoding, we can create our model:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们进行了一次性编码，我们就可以创建我们的模型：
- en: '[PRE34]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding code snippet, we used a `softmax` function. The `softmax` function
    is sometimes referred to as a normalized exponential function. We use it to normalize
    the output.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用了`softmax`函数。`softmax`函数有时被称为归一化指数函数。我们用它来规范化输出。
- en: 'Now let''s train the model. We''re going to first fit the model and then validate
    the data. Take a look at this code snippet:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们训练模型。我们将首先拟合模型，然后验证数据。看一下这段代码：
- en: '[PRE35]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: So here's one of the great things about training and testing. That is, when
    we understand and practice with them, we realize it takes just a few lines of
    code to do some pretty amazing things. The preceding two lines of code (the third
    is a comment) will make some great things happen and allow our algorithm to test
    other images.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是训练和测试的好处之一。也就是说，当我们理解并练习它们时，我们意识到只需要几行代码就可以做一些非常了不起的事情。前面的两行代码（第三行是注释）将产生一些很棒的事情，并允许我们的算法测试其他图像。
- en: 'Now we can predict the images in the dataset. We''ll start with the last four,
    because everyone starts with the same four numbers, so I want to start backward
    this time. As a note, be patient. There are thousands of images to get through
    in this algorithm. While the epochs are running, you''ll have a clock that will
    tell you how long until the information is processed. For this particular algorithm,
    it takes just a few minutes. Let''s take a look at the snippet of code we''ll
    need in order to run that prediction:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以预测数据集中的图像。我们将从最后四个开始，因为每个人都从相同的四个数字开始，所以这次我想从后面开始。请注意，要有耐心。在这个算法中有成千上万的图像需要处理。当时代运行时，您将看到一个时钟，它会告诉您信息处理需要多长时间。对于这个特定的算法，只需要几分钟。让我们看一下我们需要运行预测的代码片段：
- en: '[PRE36]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When we run this code, we get a pretty intense array of numbers. Take a look
    at the following screenshot. We have highlighted a key piece of the code for discussion:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这段代码时，我们得到了一系列相当复杂的数字。看一下以下的截图。我们已经突出显示了讨论的代码的关键部分：
- en: '![Figure 16.27 – Model predictions for the CNN image'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.27 - CNN图像的模型预测'
- en: '](image/Figure_16.27_B15413.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_16.27_B15413.jpg)'
- en: Figure 16.27 – Model predictions for the CNN image
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.27 - CNN图像的模型预测
- en: So, I can tell you that the first number predicted is 3\. *How would we know
    that the number represents 3?* Because each list represents the digits 0 to 9\.
    So imagine replacing the first list with [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]. So if
    we think of this as indexes, the number with the **01** (which is highlighted
    in the preceding screenshot) at the end of the number is in index 3, which is
    the number 3\. So our numbers are 3, 4, 5, and 6\.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我可以告诉你，第一个预测的数字是3。*我们怎么知道这个数字代表3呢？*因为每个列表代表数字0到9。所以想象一下，用[0, 1, 2, 3, 4,
    5, 6, 7, 8, 9]来替换第一个列表。因此，如果我们把这个看作索引，以**01**结尾的数字（在前面的截图中突出显示）是索引3，也就是数字3。所以我们的数字是3、4、5和6。
- en: '*But do you trust the model?* We can just go ahead and return to that snippet
    of code at the beginning of this discussion and print our results. Remember to
    change the code slightly to print your test images, and not the training images,
    as shown in the following code snippet:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*但你相信这个模型吗？*我们可以直接返回到这次讨论开始时的代码片段，并打印我们的结果。记得稍微修改代码以打印测试图像，而不是训练图像，就像以下的代码片段中所示：'
- en: '[PRE37]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When running the code, remember you will need to run it for each of the indexes
    to see the images. The following screenshot shows the images for each of the relevant
    indexes of the test images:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行代码时，请记住你需要为每个索引运行代码以查看图像。以下截图显示了测试图像的每个相关索引的图像：
- en: '![Figure 16.28 – Testing data verification images'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.28 – 测试数据验证图像'
- en: '](image/Figure_16.28_B15413.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_16.28_B15413.jpg)'
- en: Figure 16.28 – Testing data verification images
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.28 – 测试数据验证图像
- en: As you can see, our model predicted the correct values for each of the handwritten
    number images in those indexes.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们的模型预测了这些索引中每个手写数字图像的正确值。
- en: Before we close this discussion, it would be important to note that these models
    are used fairly extensively right now in websites to verify whether a visitor
    to the site is human or a bot. Some websites will have a **CAPTCHA**, which sometimes
    provides handwritten letters that the user must identify to be allowed to proceed.
    Those CAPTCHAs often use deep learning as well. The applications of CNNs and these
    kinds of models are endless.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束讨论之前，重要的是要注意，这些模型目前在网站上被广泛使用，用于验证访问网站的访客是人类还是机器人。一些网站会有**CAPTCHA**，有时会提供手写字母，用户必须识别才能继续。这些CAPTCHA通常也使用深度学习。CNN和这些模型的应用是无穷无尽的。
- en: Summary
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we were able to explore more topics in computational thinking,
    especially in dealing with data and deep learning, using the Python programming
    language. We learned how to create pairplots in order to determine the relationship
    between variables in a dataset. We also learned how to produce various types of
    plots to visually represent our datasets. We also learned how to create electric
    field lines using Python. In short, we applied what we'd learned throughout the
    previous chapters and extended our knowledge while working in applied problems.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们能够更深入地探讨计算思维的更多主题，特别是在处理数据和深度学习方面，使用Python编程语言。我们学会了如何创建pairplots来确定数据集中变量之间的关系。我们还学会了如何生成各种类型的图表来直观地表示我们的数据集。我们还学会了如何使用Python创建电场线。简而言之，我们应用了我们在之前章节中学到的知识，并在解决实际问题时扩展了我们的知识。
- en: 'And that''s really what this book sought to do: Show a wide variety of Python
    applications while looking at real problems in context. *Did we cover everything
    Python can do?* That''s fairly impossible, as Python capabilities continue to
    grow because of its ease of use, how easy it is to learn, and how many applications
    continue to be added because of its open source nature. Hopefully, you got to
    work with some new scripts, learned about some of the functions and capabilities
    you still hadn''t explored, and enjoyed exploring these scenarios.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的真正目的是：展示Python应用的广泛性，同时关注上下文中的真实问题。*我们是否涵盖了Python的所有功能？*这几乎是不可能的，因为Python的能力不断增长，这是因为它易于使用，易于学习，并且由于其开源性质，不断增加了许多应用程序。希望你能够使用一些新的脚本，了解一些你尚未探索的功能和能力，并享受探索这些场景。
- en: '*Will we ever be able to say that we''ve created the perfect algorithm?* We,
    the authors of this book, don''t think so. And the reason is that we are always
    thinking about ways to improve. We always question additional applications. We
    always want to make them more efficient. And that''s really what computational
    thinking helps us do. We can analyze, design, test, go back, and see whether we
    did what we wanted, and then refine, redesign, perform tests, and repeat.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们是否会有能力说我们已经创造了完美的算法？*我们这本书的作者认为不会。原因是我们总是在思考如何改进。我们总是质疑额外的应用。我们总是想要使它们更加高效。这正是计算思维帮助我们做的。我们可以分析、设计、测试、回顾，看我们是否达到了想要的目标，然后进行改进、重新设计、进行测试，然后重复。'
- en: Hopefully, after this chapter, you've had a chance to practice and learn about
    more of Python's capabilities. And hopefully, having read this book, you've had
    the opportunity to learn about the importance of computational thinking in programming.
    Thank you for joining us on this journey!
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 希望在本章之后，你有机会练习并了解更多关于Python的能力。希望在阅读本书之后，你有机会了解编程中计算思维的重要性。感谢你加入我们的旅程！
