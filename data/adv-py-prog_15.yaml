- en: '*Chapter 13*: Starvation'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第13章*：饥饿'
- en: In this chapter, we will discuss the concept of **starvation** and its potential
    causes in concurrent programming. We will cover a number of variations of the
    **readers-writers problems**, which are prime examples of starvation, and we will
    simulate them in example Python code. This chapter will also cover the relationship
    between *deadlock* and *starvation*, as well as some potential solutions for starvation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论**饥饿**的概念及其在并发编程中的潜在原因。我们将涵盖**读者-写者问题**的多种变体，这些是饥饿的典型例子，并将使用示例Python代码来模拟它们。本章还将涵盖**死锁**和**饥饿**之间的关系，以及一些潜在的饥饿解决方案。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding starvation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解饥饿
- en: Approaching the readers-writers problem
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接近读者-写者问题
- en: Solutions to starvation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 饥饿的解决方案
- en: By the end of the chapter, you will have a deep understanding of starvation,
    what causes it, and what practical solutions can be implemented to address the
    problem.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将深入理解饥饿，了解其成因，以及可以实施哪些实际解决方案来解决这个问题。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code files for this chapter can be accessed through this link: [https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter13](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter13).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以通过以下链接访问：[https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter13](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter13)。
- en: Understanding starvation
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解饥饿
- en: '**Starvation** is a problem in concurrent systems, in which a process (or a
    thread) cannot gain access to the necessary resources in order to proceed with
    its execution and, therefore, cannot make any progress. In this section, we will
    look into the characteristics of a starvation situation, analyze its most common
    causes, and finally, consider a sample program that exemplifies starvation.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**饥饿**是并发系统中的一个问题，其中进程（或线程）无法获取执行所需的必要资源，因此无法继续执行，因此无法取得任何进展。在本节中，我们将探讨饥饿情况的特征，分析其最常见的原因，并最终考虑一个示例程序，该程序展示了饥饿的情况。'
- en: What is starvation?
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是饥饿？
- en: 'It is quite common for a concurrent program to implement some sort of ordering
    between the different processes in its execution. For example, consider a program
    that has three separate processes, as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 并发程序在执行过程中对不同的进程进行某种排序是很常见的。例如，考虑一个有三个独立进程的程序，如下所示：
- en: One is responsible for handling extremely pressing instructions that need to
    be run as soon as the necessary resources become available.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个负责处理极其紧急的指令，这些指令需要在必要的资源可用时立即运行。
- en: Another process is responsible for other important executions, which are not
    as essential as the tasks in the first process.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个进程负责其他重要的执行任务，这些任务不如第一个进程的任务那么关键。
- en: The last one handles miscellaneous, very infrequent tasks.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个处理的是一些非常不常见的事务。
- en: Furthermore, these three processes need to utilize the same resources in order
    to execute their respective instructions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这三个进程需要利用相同的资源来执行它们各自的指令。
- en: Intuitively, we have every reason to implement a specification that allows the
    first process to have the highest priority of execution and access to resources,
    then the second process, and then the last process, with the lowest priority.
    However, imagine situations in which the first two processes (with higher priorities)
    run so often that the third process cannot execute its instructions; anytime the
    third process needs to run, it checks to see whether the resources are available
    to be used and finds out that one of the other higher-priority processes is using
    them.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 直观地，我们有充分的理由实施一个规范，允许第一个进程具有最高的执行优先级和资源访问权，然后是第二个进程，最后是具有最低优先级的最后一个进程。然而，想象一下这样的情况：前两个进程（具有更高的优先级）运行得如此频繁，以至于第三个进程无法执行其指令；每当第三个进程需要运行时，它会检查资源是否可用，并发现其他一个高优先级的进程正在使用它们。
- en: This is a situation of starvation – the third process is given no opportunity
    to execute and, therefore, no progress can be made with that process. In a typical
    concurrent program, it is quite common to have more than three processes at different
    priority levels, yet the situation is fundamentally similar – some processes are
    given more opportunities to run and, therefore, they are constantly executing.
    Others have lower priorities and cannot access the necessary resources to execute.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个饥饿状态的情况——第三个进程没有执行的机会，因此无法在该进程中取得任何进展。在典型的并发程序中，拥有三个以上不同优先级级别的进程是很常见的，但情况本质上相似——一些进程被赋予更多的运行机会，因此它们会持续执行。而其他进程优先级较低，无法访问执行所需的必要资源。
- en: Scheduling
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调度
- en: In the next few subsections, we will be discussing the potential candidates
    that cause starvation situations. Most of the time, a poorly coordinated set of
    *scheduling instructions* is the main cause of starvation. For example, a considerably
    naive algorithm that deals with three separate tasks might implement constant
    communication and interaction between the first two tasks.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个小节中，我们将讨论可能导致饥饿状态的潜在候选者。大多数情况下，一组协调不佳的**调度指令**是饥饿状态的主要原因。例如，一个相当天真的算法处理三个独立任务时，可能会在第一个和第二个任务之间实施恒定的通信和交互。
- en: This setup leads to the fact that the execution flow of the algorithm switches
    solely between the first and second tasks, while the third finds itself idle and
    unable to make any progress with its execution – in this case, because it is starved
    of CPU execution flow. Intuitively, we can identify the root of the problem as
    the fact that the algorithm allows the first two tasks to always dominate the
    CPU and, hence, effectively prevents any other task from also utilizing the CPU.
    A characteristic of a good scheduling algorithm is the ability to distribute the
    execution flow and allocate the resources equally and appropriately.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设置导致算法的执行流程仅在第一个和第二个任务之间切换，而第三个任务发现自己处于空闲状态，无法在其执行上取得任何进展——在这种情况下，因为它缺乏CPU执行流程。直观地，我们可以将问题的根源识别为算法允许前两个任务始终主导CPU，从而有效地阻止任何其他任务也利用CPU。一个好的调度算法的特点是能够分配执行流程并公平、适当地分配资源。
- en: As mentioned previously, many concurrent systems and programs implement a specific
    order of priority, in terms of process and thread execution. This implementation
    of ordered scheduling may very likely lead to the starvation of processes and
    threads of lower priorities and can result in a condition called **priority inversion**.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，许多并发系统和程序在进程和线程执行方面实施特定的优先级顺序。这种有序调度的实现很可能导致低优先级进程和线程的饥饿，并可能导致称为**优先级反转**的状态。
- en: Suppose that, in your concurrent program, you have process A of the highest
    priority, process B of a medium priority, and finally, process C of the lowest
    priority; process C would most likely be put in the situation of starvation. Additionally,
    if the execution of process A, the prioritized process, is dependent on the completion
    of process C, which is already in starvation, then process A might never be able
    to complete its execution either, even though it is given the highest priority
    in the concurrent program.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在你的并发程序中，你有最高优先级的进程A，中等优先级的进程B，最后是最低优先级的进程C；进程C很可能会处于饥饿状态。此外，如果优先级较高的进程A的执行依赖于已经处于饥饿状态的进程C的完成，那么即使进程A在并发程序中拥有最高的优先级，它也可能永远无法完成其执行。
- en: 'The following diagram further illustrates the concept of priority inversion
    – a high-priority task running from the time **t2** to **t3** needs to access
    some resources, which are being utilized by a low-priority task:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表进一步说明了优先级反转的概念——一个高优先级任务从时间**t2**到**t3**需要访问一些资源，而这些资源正被低优先级任务使用：
- en: '![Figure 13.1 – A diagram of priority inversion ](img/B17499Figure_13.1.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图13.1 – 优先级反转的示意图](img/B17499Figure_13.1.jpg)'
- en: Figure 13.1 – A diagram of priority inversion
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 – 优先级反转的示意图
- en: To reiterate, combining starvation and priority inversion can lead to a situation
    where even the high-priority tasks are unable to execute their instructions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，饥饿和优先级反转的结合可能导致即使高优先级任务也无法执行其指令的情况。
- en: Causes of starvation
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 饥饿的原因
- en: 'With the complexity of designing a scheduling algorithm in mind, let''s discuss
    the specific causes of starvation. The situations that we described in the preceding
    section indicate some potential causes of a starvation situation. However, starvation
    can arise from a number of sources, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到设计调度算法的复杂性，让我们讨论导致饥饿的具体原因。我们前面描述的情况表明了一些可能导致饥饿状态的原因。然而，饥饿可能来自多个来源，如下所述：
- en: Processes (or threads) with high priorities dominate the execution flow in the
    CPU and, hence, low-priority processes (or threads) are not given the opportunity
    to execute their own instructions.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有高优先级的进程（或线程）在CPU中的执行流程中占主导地位，因此，低优先级的进程（或线程）没有机会执行它们自己的指令。
- en: Processes (or threads) with high priorities dominate the usage of non-shareable
    resources and, hence, low-priority processes (or threads) are not given the opportunity
    to execute their own instructions. This situation is similar to the first one
    but addresses the priority of accessing resources, instead of the priority of
    the execution itself.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有高优先级的进程（或线程）主导了对不可共享资源的使用，因此，低优先级的进程（或线程）没有机会执行它们自己的指令。这种情况与第一种情况类似，但解决的是访问资源的优先级，而不是执行本身的优先级。
- en: Processes (or threads) with low priorities are waiting for resources to execute
    their instructions, but as soon as the resources become available, other processes
    (or threads) with higher priorities are immediately given access to them, so the
    low-priority processes (or threads) wait indefinitely.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低优先级的进程（或线程）正在等待资源以执行它们的指令，但一旦资源可用，具有更高优先级的其他进程（或线程）立即获得访问权限，因此低优先级的进程（或线程）无限期地等待。
- en: There are other causes of starvation as well, but the preceding are the most
    common root causes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他导致饥饿的原因，但前面提到的是最常见的根本原因。
- en: Starvation's relationship to deadlock
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 饥饿与死锁的关系
- en: Interestingly, deadlock situations can also lead to starvation, as the definition
    of starvation states that if there is a process (or a thread) that is unable to
    make any progress because it cannot gain access to the necessary process, the
    process (or thread) is experiencing starvation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，死锁情况也可能导致饥饿，因为饥饿的定义指出，如果一个进程（或线程）因为无法获得必要的资源而无法取得任何进展，那么该进程（或线程）正在经历饥饿。
- en: 'Recall our example of deadlock, the Dining Philosophers problem, illustrated
    as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 回想我们之前关于死锁的例子，餐桌哲学家问题，如下所示：
- en: '![Figure 13.2 – An illustration of the Dining Philosophers problem ](img/B17499Figure_13.2.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图13.2 – 餐桌哲学家问题的示意图](img/B17499Figure_13.2.jpg)'
- en: Figure 13.2 – An illustration of the Dining Philosophers problem
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 – 餐桌哲学家问题的示意图
- en: When deadlock occurs in this situation, no philosopher can obtain the necessary
    resources to execute their instructions (each philosopher is required to have
    two forks to start eating). Each philosopher that is in deadlock is therefore
    also in a state of starvation.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当发生死锁时，没有哲学家能够获得执行指令所必需的资源（每个哲学家需要两把叉子才能开始吃饭）。因此，处于死锁状态的每个哲学家也处于饥饿状态。
- en: The readers-writers problem describes in detail the various types of starvation,
    which we will consider next.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 读者-写者问题详细描述了各种类型的饥饿，我们将在下一节考虑。
- en: Approaching the readers-writers problem
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决读者-写者问题
- en: The readers-writers problem is one of the classic use cases in concurrent programming,
    illustrating problems that might occur in a concurrent program. Throughout the
    analysis of the different variations of the readers-writers problem, we will reveal
    more about starvation, as well as its common causes. We will also simulate the
    problem in Python so that a deeper understanding of the problem can be gained.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 读者-写者问题是并发编程中的经典用例之一，说明了在并发程序中可能发生的问题。在整个分析读者-写者问题的不同变体过程中，我们将揭示更多关于饥饿以及其常见原因的信息。我们还将使用Python模拟这个问题，以便更深入地理解问题。
- en: Problem statement
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题陈述
- en: In a readers-writers problem, first and foremost, we have a shared resource,
    which, in most cases, is a text file. Different threads interact with that text
    file; each is either a reader or a writer. A **reader** is a thread that simply
    accesses the shared resource (the text file) and reads in the data included in
    that file, while a **writer** is a thread that accesses, and possibly mutates,
    the contents of the text file.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在读者-作家问题中，首先，我们有一个共享资源，在大多数情况下，这是一个文本文件。不同的线程与该文本文件交互；每个线程要么是读者要么是作家。**读者**是一个简单地访问共享资源（文本文件）并读取该文件中包含的数据的线程，而**作家**是一个访问并可能修改文本文件内容的线程。
- en: We know that writers and readers cannot access the shared resources simultaneously
    since if a thread is writing data to the file, no other thread should be accessing
    the file to read any data from it. The goal of the readers-writers problem is
    therefore to find a correct and efficient way to design and coordinate the scheduling
    of these reader and writer threads. Successful implementation of that goal is
    not only that the program as a whole executes in the most optimized way but also
    that all threads are given sufficient opportunity to execute their instructions
    and no starvation can occur. Additionally, the shared resource (the text file)
    needs to be handled appropriately so that no data will be corrupted.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，由于如果一个线程正在向文件写入数据，则没有其他线程应该访问该文件以读取任何数据，因此作家和读者无法同时访问共享资源。因此，读者-作家问题的目标是找到一种正确且高效的方法来设计和协调这些读者和作家线程的调度。实现该目标不仅意味着程序整体以最优化方式执行，而且所有线程都有足够的机会执行它们的指令，并且不会发生饥饿。此外，共享资源（文本文件）需要得到适当的处理，以确保不会损坏数据。
- en: 'The following diagram further illustrates the setup of the readers-writers
    problem:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图进一步说明了读者-作家问题的设置：
- en: '![Figure 13.3 – A diagram of the readers-writers problem ](img/B17499Figure_13.3.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图13.3 – 读者-作家问题的示意图](img/B17499Figure_13.3.jpg)'
- en: Figure 13.3 – A diagram of the readers-writers problem
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 – 读者-作家问题的示意图
- en: In the following subsections, we will be exploring different variations of the
    problem with increasing levels of complexity. From there, we will also implement
    sample solutions to these problems, thus gaining hands-on experience in preventing
    starvation in concurrent applications.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下小节中，我们将探讨问题的不同变体，其复杂性逐渐增加。从那里，我们还将实现这些问题的示例解决方案，从而在防止并发应用程序中的饥饿中获得实践经验。
- en: The first readers-writers problem
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一个读者-作家问题
- en: As we mentioned, the problem asks us to come up with a scheduling algorithm
    so that readers and writers can access the text file appropriately and efficiently,
    without mishandling or corrupting the data that is included. A naive solution
    to this problem is to impose a lock on the text file so that it becomes a non-shareable
    resource; this means that only one thread (either a reader or a writer) can access
    (and potentially manipulate) the text file at any given time.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们提到的，这个问题要求我们提出一个调度算法，以便读者和作家可以适当且高效地访问文本文件，而不会处理或损坏包含的数据。对这个问题的简单解决方案是在文本文件上施加锁，使其成为不可共享的资源；这意味着在任何给定时间，只有一个线程（无论是读者还是作家）可以访问（并可能操作）文本文件。
- en: Yet, this approach simply equates to a sequential program – if the shared resource
    can be utilized by only one thread at a given time, none of the processing time
    between different threads can be overlapped and, effectively, the execution becomes
    sequential. Therefore, this is not an optimal solution, as it is taking advantage
    of concurrent programming.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法简单地等同于顺序程序——如果共享资源在任何给定时间只能由一个线程使用，那么不同线程之间的处理时间无法重叠，并且实际上执行变为顺序。因此，这不是一个最优解，因为它利用了并发编程。
- en: One insight regarding the reader threads can lead to a more optimal solution
    to this problem – since readers simply read in the text file and do not alter
    the data in it, multiple readers can be allowed to access the text file simultaneously.
    Indeed, even if more than one reader is fetching data from the text file at the
    same time, the data is not being changed in any way, and the consistency and accuracy
    of the data are therefore maintained.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 关于读者线程的一个见解可以导致对这个问题的更优解决方案——由于读者只是读取文本文件而不改变其中的数据，因此可以允许多个读者同时访问文本文件。确实，即使有多个读者同时从文本文件中获取数据，数据本身也没有任何改变，因此数据的完整性和准确性得到保持。
- en: Following this approach, we will implement a specification in which no reader
    will be kept waiting if the shared resource is being opened for reading by another
    reader. Specifically, in addition to a lock on the shared resource, we will also
    have a counter for the number of readers currently accessing the resource. If
    at any point in the program that counter goes from zero to one (in other words,
    at least one reader is starting to access the resource), we will lock the resource
    from the writers; similarly, whenever the counter decreases to zero (in other
    words, no reader is asking for access to the resource), we will release the lock
    on the resource so that writers can access it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这种方法，我们将实现一个规范，即当共享资源被另一个读者打开用于读取时，不会让任何读者等待。具体来说，除了对共享资源的锁之外，我们还将有一个当前访问资源的读者数量的计数器。如果在程序的任何时刻，该计数器从零变为一（换句话说，至少有一个读者开始访问资源），我们将锁定资源以防止写者访问；同样，每当计数器减少到零（换句话说，没有读者请求访问资源），我们将释放对资源的锁，以便写者可以访问它。
- en: This specification is efficient for the readers in the sense that once the first
    reader has accessed the resource and placed a lock on it, no writers can access
    it, and the subsequent readers will not have to re-lock it until the last reader
    finishes reading the resource.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规范对读者来说效率很高，因为一旦第一个读者访问了资源并对其加锁，就没有写者可以访问它，后续的读者也不必在最后一个读者完成读取资源之前重新锁定它。
- en: 'Let''s try to implement this solution in Python. If you have already downloaded
    the code for this book from the GitHub page, go ahead and navigate to the `Chapter13`
    folder. Let''s take a look at the `Chapter13/example1.py` file – specifically,
    the `writer()` and `reader()` functions, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试用 Python 实现这个解决方案。如果你已经从 GitHub 页面下载了这本书的代码，请继续导航到 `Chapter13` 文件夹。让我们看一下
    `Chapter13/example1.py` 文件——特别是 `writer()` 和 `reader()` 函数，如下所示：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding script, the `writer()` function, which is to be called by a
    `threading.Thread` instance (in other words, a separate thread), specifies the
    logic of the writer threads that we discussed previously – accessing the shared
    resource (in this case, the global variable, `text`, which is simply a Python
    string) and writing some data to the resource. Note that we are putting all of
    its instructions inside a `while` loop to simulate the constant nature of the
    application (writers and readers constantly trying to access the shared resource).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的脚本中，`writer()` 函数（它将由一个 `threading.Thread` 实例调用，换句话说，一个单独的线程）指定了我们之前讨论的写线程的逻辑——访问共享资源（在这种情况下，全局变量
    `text`，它只是一个 Python 字符串）并向资源写入一些数据。请注意，我们将所有指令都放在一个 `while` 循环中，以模拟应用程序的持续性质（写者和读者不断尝试访问共享资源）。
- en: We can also see the reader logic in the `reader()` function. Before asking for
    access to the shared resource, each reader will increment a counter for the number
    of readers that are currently active and trying to access the resource. Similarly,
    after reading data off the file, each reader needs to decrement the number of
    readers. During this process, if a reader is the first reader to access the file
    (in other words, when the counter is one), it will put a lock on the file so that
    no writers can access it; conversely, when a reader is the last reader to read
    the file, it has to release that lock.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在 `reader()` 函数中看到读者逻辑。在请求访问共享资源之前，每个读者都会增加一个当前活跃并尝试访问资源的读者数量的计数器。同样，在从文件读取数据之后，每个读者需要减少读者数量。在这个过程中，如果读者是第一个访问文件的读者（换句话说，当计数器为一时），它将锁定文件以防止写者访问；相反，当读者是最后一个读取文件的读者时，它必须释放那个锁。
- en: One note about the handling of that counter of readers – you might have noticed
    that we are using a lock object named `rcounter` when incrementing/decrementing
    the counter variable (`rcount`). This is a method that is used to avoid a race
    condition, which is another common concurrency-related problem, for the counter
    variable; specifically, without the lock, multiple threads can be accessing and
    altering the counter variable at the same time, but the only way to ensure the
    integrity of the data is for this counter variable to be handled sequentially.
    We will discuss race conditions (and the practice that is used to avoid them)
    in more detail in the next chapter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 关于处理那个读者计数器的注意事项——你可能已经注意到，我们在增加/减少计数变量（`rcount`）时使用了一个名为`rcounter`的锁对象。这是一种避免竞争条件的方法，竞争条件是另一个常见的并发相关问题；具体来说，如果没有锁，多个线程可以同时访问和修改计数变量，但确保数据完整性的唯一方法是将这个计数变量按顺序处理。我们将在下一章更详细地讨论竞争条件（以及避免它们的实践）。
- en: 'Going back to our current script – in the main program, we will set up the
    `text` variable, the counter for readers, and two lock objects (for the reader
    counter and the shared resource respectively). We are also initializing and starting
    three reader threads and two writer threads, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们当前的脚本——在主程序中，我们将设置`text`变量、读者计数器和两个锁对象（分别用于读者计数器和共享资源）。我们还在初始化和启动三个读者线程和两个写者线程，如下所示：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It is important to note that, since the instructions of the reader and writer
    threads are both wrapped in `while` loops, the script, when started, will run
    infinitely. You should cancel the Python execution after around 3–4 seconds, when
    enough output has been produced so that the general behavior of the program can
    be observed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，由于读者和写者线程的指令都被包裹在`while`循环中，脚本一旦启动，将会无限运行。你应该在产生足够输出，大约3-4秒后取消Python的执行，以便可以观察到程序的一般行为。
- en: 'The following code shows the first few lines of output that I obtained after
    running the script:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了我在运行脚本后获得的前几行输出：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, there is a specific pattern in the preceding output – all of
    the threads that were accessing the shared resource were readers. In fact, throughout
    my entire output, no writer was able to access the file and, therefore, the `text`
    variable only contains the initial string, `This is some text.`, and was not altered
    in any way. The output that you obtain should also have the same pattern (the
    shared resource not being altered).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，前述输出中有一个特定的模式——所有访问共享资源的线程都是读者。实际上，在我的整个输出中，没有写者能够访问文件，因此`text`变量只包含初始字符串`This
    is some text.`，并且没有被任何方式修改。你获得的输出也应该有相同的模式（共享资源没有被修改）。
- en: In this case, the writers are experiencing starvation, as none of them are able
    to access and use the resource. This is a direct result of our scheduling algorithm;
    since multiple readers are allowed to access the text file simultaneously, if
    there are multiple readers accessing the text file frequently enough, it will
    create a continuous stream of readers going through the text file, leaving no
    room for a writer to attempt to access the file.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，写者正在经历饥饿，因为他们都无法访问和使用资源。这是我们的调度算法的直接结果；由于允许多个读者同时访问文本文件，如果存在多个读者频繁地访问文本文件，它将创建一个连续的读者流通过文本文件，没有给写者留下尝试访问文件的空间。
- en: This scheduling algorithm inadvertently gives priority to the readers over the
    writers and is therefore called **reader preference**. So, this design is undesirable.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种调度算法无意中给读者赋予了比写者更高的优先级，因此被称为**读者优先**。所以，这种设计是不理想的。
- en: The second readers-writers problem
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二个读者-写者问题
- en: The problem with the first approach is that when a reader is accessing the text
    file and a writer is waiting for the file to be unlocked, if another reader starts
    its execution and wants to access the file, it will be given priority over the
    writer that has already been waiting. Additionally, if more and more readers keep
    requesting access to the file, the writer will be waiting indefinitely, and that
    was what we observed in our first code example.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法的问题在于，当一个读者正在访问文本文件，而一个写者正在等待文件解锁时，如果另一个读者开始执行并想要访问文件，它将优先于已经等待的写者。此外，如果越来越多的读者持续请求访问文件，写者将无限期地等待，这正是我们在第一个代码示例中观察到的。
- en: To address this problem, we will implement the specification that once a writer
    makes a request to access the file, no reader should be able to jump in line and
    access the file before that writer. To do this, we will have an additional lock
    object in our program to specify whether a writer is waiting for the file and,
    consequently, whether a reader thread can attempt to read the file; we will call
    this lock `read_try`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将实施一个规范：一旦作者请求访问文件，任何读者都不应该能够插队并在该作者之前访问文件。为了做到这一点，我们将在程序中添加一个额外的锁对象，以指定是否有作者正在等待访问文件，以及因此，是否有读者线程可以尝试读取文件；我们将把这个锁称为`read_try`。
- en: Similar to how the first of the readers accessing the text file always locks
    it from the writers, we will now have the first of the multiple writers that are
    waiting to access the `read_try` file lock, so that no reader can, again, jump
    in line before those writers that requested access before it. As we discussed
    in reference to the readers, since we are keeping track of the number of writers
    waiting for the text file, we will need to implement a counter for the number
    of writers, and its corresponding lock, in our program.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 与第一个访问文本文件的读者总是锁定它以防止作者一样，我们现在将锁定等待访问`read_try`文件锁的第一个多个作者之一，这样读者就不能再次在这些先于它请求访问的作者之前插队。正如我们根据读者讨论的那样，由于我们正在跟踪等待文本文件的作者数量，我们将在程序中实现一个用于作者数量的计数器及其相应的锁。
- en: 'The `Chapter13/example2.py` file contains the code for this implementation,
    as follows (note that the `reader()` function is being omitted in the text):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chapter13/example2.py`文件包含这个实现的代码，如下所示（注意，文本中省略了`reader()`函数）：'
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Compared to our first solution to the problem, the main program remains relatively
    the same (except for the initialization of the `read_try` lock, the `wcount` counter,
    and its lock, `wcounter`), but in our `writer()` function, we are locking `read_try`
    as soon as there is at least one writer waiting to access the file; when the last
    writer finishes its execution, it will release the lock so that any reader waiting
    for the file can now access it.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们针对该问题的第一个解决方案相比，主程序相对保持不变（除了`read_try`锁的初始化、`wcount`计数器及其锁`wcounter`），但在我们的`writer()`函数中，一旦至少有一个作者等待访问文件，我们就会锁定`read_try`；当最后一个作者完成其执行后，它将释放锁，这样任何等待访问文件的读者现在都可以访问它。
- en: 'Again, to see the output produced by the program, we will have it run for 3–4
    seconds and then cancel the execution, as the program would otherwise run forever.
    The following is the output that I obtained via this script:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，为了看到程序产生的输出，我们将让它运行3-4秒然后取消执行，否则程序将永远运行。以下是通过此脚本获得的输出：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It can be observed that while some readers were able to access the text file
    (indicated by the first four lines of my output), once a writer gained access
    to the shared resource, no reader was able to access it anymore. The rest of my
    output included messages about writing instructions – `Writing being done by`,
    and so on. As opposed to what we saw in the first solution of the readers-writers
    problem, this solution is giving priority to writers, and, as a consequence, the
    readers are starved. This is therefore called **writer preference**.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 可以观察到，尽管一些读者能够访问文本文件（如我的输出中的前四行所示），但一旦作者获得了对共享资源的访问，任何读者都无法再访问它。我输出的其余部分包括关于写入指令的消息——`Writing
    being done by`等等。与我们在读者-作者问题的第一个解决方案中看到的情况相反，这个解决方案是在优先考虑作者，因此读者被饿死。因此，这被称为**作者优先级**。
- en: The priority that writers were given over readers resulted from the fact that
    while only the first and the last writers have to acquire and release the `read_try`
    lock respectively, each reader wanting to access the text file has to interact
    with that lock object individually. Once `read_try` is locked by a writer, no
    reader can even attempt to execute its instructions, let alone try to access the
    text file.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 作者相对于读者的优先级来源于这样一个事实：虽然只有第一个和最后一个作者分别需要获取和释放`read_try`锁，但每个想要访问文本文件的读者都必须单独与该锁对象交互。一旦`read_try`被作者锁定，任何读者甚至都无法尝试执行其指令，更不用说尝试访问文本文件。
- en: There are cases in which some readers are able to gain access to the text file
    if the readers are initialized and executed before the writers (for example, in
    our program, the readers were the first three elements, and the writers were the
    last two, in our list of threads). However, once a writer is able to access the
    file and acquire the `read_try` lock during its execution, starvation will most
    likely occur for the readers.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些情况下，如果读者在作者之前初始化和执行（例如，在我们的程序中，读者是前三个元素，作者是最后两个，在我们的线程列表中），一些读者能够访问文本文件。然而，一旦一个作者能够访问文件并在其执行过程中获取`read_try`锁，读者很可能会发生饥饿。
- en: This solution is also not desirable, as it gives higher priority to the writer
    threads in our program.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案也不可取，因为它在我们的程序中给作者线程更高的优先级。
- en: The third readers-writers problem
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三个读者-作者问题
- en: You have seen that both of the solutions that we tried to implement can result
    in starvation by not giving equal priorities to the separate threads; one can
    starve the writers, and the other can starve the readers. A balance between these
    two approaches might give us an implementation with equal priorities among the
    readers and writers, and, hence, solve the problem of starvation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到，我们尝试实施的两种解决方案都可能因为不对不同的线程给予相同的优先级而导致饥饿；一种可能会使作者饥饿，另一种可能会使读者饥饿。这两种方法之间的平衡可能会给我们一个在读者和作者之间具有相同优先级的实现，从而解决饥饿问题。
- en: Recall that – in our second approach, we placed a lock on a reader's attempt
    to access the text file, requiring that no writer would be starved once it started
    waiting for the file. In this solution, we will implement a lock that also utilizes
    this logic but is then applied to both readers and writers. All of the threads
    will then be subjected to the constraints of the lock, and equal priority will
    hence be achieved among the separate threads.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下——在我们的第二种方法中，我们对读者尝试访问文本文件的操作加锁，要求一旦开始等待文件，就不会让任何作者饥饿。在这个解决方案中，我们将实现一个利用这种逻辑的锁，但将其应用于读者和作者。然后，所有线程都将受到锁的约束，从而在各个线程之间实现平等优先级。
- en: Specifically, this is a lock that specifies whether a thread will be given access
    to the text file at a given moment; we will call this the **service lock**. Each
    writer or reader has to try to acquire this service lock before executing any
    of its instructions. A writer, having obtained this service lock, will also attempt
    to obtain the resource lock and release the service lock immediately thereafter.
    The writer will then execute its writing logic and finally release the resource
    lock at the end of its execution.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，这是一个指定在某一时刻线程是否能够访问文本文件的锁；我们将称之为**服务锁**。每个作者或读者在执行任何指令之前都必须尝试获取这个服务锁。一旦作者获得了这个服务锁，他也会尝试获取资源锁，并在之后立即释放服务锁。作者将在执行其写入逻辑后，在其执行结束时释放资源锁。
- en: 'Let''s take a look at the `writer()` function in the `Chapter13/example3.py`
    file for our implementation in Python, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Chapter13/example3.py`文件中的`writer()`函数，以了解我们的Python实现，如下所示：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: On the other hand, a reader will also need to acquire the service lock first.
    Since we are still allowing multiple readers to access the resource at the same
    time, we are implementing the reader counter and its corresponding lock.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，读者也需要首先获取服务锁。由于我们仍然允许多个读者同时访问资源，我们正在实现读者计数器和相应的锁。
- en: The reader will acquire the service lock and the counter lock, increment the
    reader counter (and, potentially, lock the resource), and then release the service
    lock and counter lock sequentially. Now, it will actually read data off the text
    file, and finally, it will decrement the reader counter and potentially release
    the resource lock if it is the last reader to access the file at that time.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 读者将获取服务锁和计数器锁，增加读者计数器（并可能锁定资源），然后依次释放服务锁和计数器锁。现在，它将实际上从文本文件中读取数据，最后，它将减少读者计数器，并在那时是最后访问文件的读者的情况下，可能释放资源锁。
- en: 'The `reader()` function contains the following specification:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`reader()`函数包含以下规范：'
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, in our main program, we initialize the text string, the reader counter,
    all of the necessary locks, and the reader and writer threads, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们的主程序中，我们初始化文本字符串、读者计数器、所有必要的锁以及读者和作者线程，如下所示：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note that we are commenting the code that prints out the current content of
    the text file in the `reader()` function for readability for our output later
    on. Run the program for 3–4 seconds and then cancel it. The following output is
    what I obtained on my personal computer:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在对`reader()`函数中打印当前文本文件内容的代码进行注释，以便我们稍后输出的可读性。运行程序3-4秒后取消。以下是我个人电脑上获得的结果：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The pattern that we have with this current output is that the readers and writers
    are able to access the shared resource cooperatively and efficiently; all of the
    readers and writers are executing their instructions, and no thread is being starved
    by this scheduling algorithm.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前这个输出模式的特点是读者和作者能够协作和高效地访问共享资源；所有的读者和作者都在执行他们的指令，没有任何线程因为这个调度算法而饿死。
- en: Note that as you work with a readers-writers problem in your concurrent program,
    you do not have to reinvent the wheel regarding the approaches that we just discussed.
    PyPI actually has an external library called `readerwriterlock` that contains
    the implementation of the three approaches in Python, as well as support for timeouts.
    Go to [https://pypi.org/project/readerwriterlock/](https://pypi.org/project/readerwriterlock/)
    to find out more about the library and its documentation.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你在你并发程序中处理读者-作者问题时，你不必重新发明轮子，关于我们刚才讨论的方法。PyPI实际上有一个名为`readerwriterlock`的外部库，它包含Python中三种方法的实现，以及超时支持。访问[https://pypi.org/project/readerwriterlock/](https://pypi.org/project/readerwriterlock/)了解更多关于该库及其文档的信息。
- en: Solutions to starvation
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 饥死问题的解决方案
- en: Through an analysis of different approaches to the readers-writers problem,
    you have seen the key to solving starvation – since some threads will be starved
    if they are not given a high priority in accessing the shared resources, implementing
    fairness in the execution of all of the threads will prevent starvation from occurring.
    Fairness, in this case, does not require a program to forgo any order or priority
    that it has imposed on the different threads; but to implement fairness, a program
    needs to ensure that all threads are given sufficient opportunities to execute
    their instructions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对不同读者-作者问题方法的比较分析，你已经看到了解决饿死问题的关键——由于某些线程如果没有被赋予高优先级访问共享资源，它们将会饿死，因此在所有线程的执行中实现公平性将防止饿死的发生。在这种情况下，公平性不需要程序放弃它对不同线程强加的任何顺序或优先级；但是为了实现公平性，程序需要确保所有线程都有足够的机会执行它们的指令。
- en: 'Keeping this idea in mind, we can potentially address the problem of starvation
    by implementing one (or a combination) of the following approaches:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个想法，我们可以通过实施以下一种（或多种）方法来潜在地解决饿死问题：
- en: '**Increasing the priority of low-priority threads**: As we did with the writer
    threads in the second approach and the reader threads in the third approach to
    the readers-writers problem, prioritizing the threads that would otherwise not
    have any opportunity to access the shared resource can successfully eliminate
    starvation.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高低优先级线程的优先级**：正如我们在第二方法中对作者线程和第三方法中对读者线程所做的那样，优先考虑那些在其他情况下没有机会访问共享资源的线程，可以成功地消除饿死现象。'
- en: '**First-in-first-out thread queue**: To ensure that a thread that started waiting
    for the shared resource before another thread will be able to acquire the resource
    before the other thread, we can keep track of the threads requesting access in
    a first-in-first-out queue.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**先进先出线程队列**：为了确保一个在另一个线程之前开始等待共享资源的线程能够在其他线程之前获得资源，我们可以通过一个先进先出队列跟踪请求访问的线程。'
- en: '**Other methods**: Several methods can also be implemented to balance the selection
    frequency of different threads – for example, a priority queue that also gives
    gradually increasing priority to threads that have been waiting in the queue for
    a long time, or if a thread has been able to access the shared resource many times,
    it will be given less priority.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**其他方法**：还可以实现几种方法来平衡不同线程的选择频率——例如，一个优先队列，它也会逐渐增加在队列中等待时间较长的线程的优先级，或者如果一个线程多次能够访问共享资源，它将获得较低的优先级。'
- en: Solving starvation in your concurrent program can be a rather complex and involved
    process, and a deep understanding of its scheduling algorithm, combined with an
    understanding of how processes and threads interact with the shared resources,
    is necessary during the process. As you saw in the example of the readers-writers
    problem, it can also take several implementations and revisions of different approaches
    to arrive at a good solution to starvation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的并发程序中解决饥饿可能是一个相当复杂和复杂的过程，在过程中需要深入理解其调度算法，并结合对进程和线程如何与共享资源交互的理解。正如你在读者-写者问题的例子中所看到的，也可能需要多次实现和修改不同的方法，才能找到解决饥饿的良好方案。
- en: Summary
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered starvation and the specific situations in which
    it could occur by analyzing different instances of the readers-writers problem.
    We have gained insight into how starvation can be solved with different scheduling
    algorithms – by making sure that the priority is distributed appropriately among
    different processes and threads, starvation can be eliminated. These discussions
    will serve as a guide to solutions to real-life instances of starvation.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过分析读者-写者问题的不同实例，已经涵盖了饥饿及其可能发生的具体情况。我们深入了解了如何通过不同的调度算法解决饥饿——通过确保在不同进程和线程之间适当地分配优先级，可以消除饥饿。这些讨论将作为解决现实生活实例中饥饿的指南。
- en: In the next chapter, we will discuss the last of the three common problems of
    concurrent programming – **race conditions**. We will cover the basic foundation
    and causes of race conditions, relevant concepts, and the connection of race conditions
    to other concurrency-related problems.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论并发编程的三个常见问题中的最后一个——**竞态条件**。我们将涵盖竞态条件的基本基础和原因，相关概念以及竞态条件与其他并发相关问题的联系。
- en: Questions
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is starvation and why is it undesirable in a concurrent program?
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是饥饿，为什么在并发程序中它是不理想的？
- en: What are the underlying causes of starvation? What are the common high-level
    causes of starvation that can manifest from the underlying causes?
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 饥饿的根本原因是什么？有哪些常见的高级原因可以从根本原因中表现出来，导致饥饿？
- en: What is the connection between deadlock and starvation?
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 死锁和饥饿之间有什么联系？
- en: What is the readers-writers problem?
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是读者-写者问题？
- en: What is the first approach to the readers-writers problem? Why does starvation
    arise in that situation?
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读者-写者问题的第一种方法是什么？为什么在这种情况下会出现饥饿？
- en: What is the second approach to the readers-writers problem? Why does starvation
    arise in that situation?
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读者-写者问题的第二种方法是什么？为什么在这种情况下会出现饥饿？
- en: What is the third approach to the readers-writers problem? Why does it successfully
    address starvation?
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读者-写者问题的第三种方法是什么？为什么它成功地解决了饥饿问题？
- en: What are some common solutions to starvation?
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些常见的解决饥饿的方法有哪些？
- en: Further reading
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Parallel Programming with Python*, *Jan Palach*, *Packt Publishing Ltd*, *2014*'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Python 进行并行编程*，Jan Palach，Packt Publishing Ltd，2014'
- en: '*Python Parallel Programming Cookbook*, *Giancarlo Zaccone*, *Packt Publishing
    Ltd*, *2015*'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python 并行编程食谱*，Giancarlo Zaccone，Packt Publishing Ltd，2015'
- en: '*Starvation and Fairness*, *Jakob Jenkov* ([tutorials.jenkov.com/java-concurrency/starvation-and-fairness](http://tutorials.jenkov.com/java-concurrency/starvation-and-fairness))'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*饥饿与公平性*，Jakob Jenkov ([tutorials.jenkov.com/java-concurrency/starvation-and-fairness](http://tutorials.jenkov.com/java-concurrency/starvation-and-fairness))'
- en: '*Faster Fair Solution for the Reader-Writer Problem*, *V. Popov and O. Mazonka*'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*针对读者-写者问题的更快公平解决方案*，V. Popov 和 O. Mazonka'
