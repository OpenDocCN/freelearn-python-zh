- en: Chapter 5. Advanced Cython
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章。高级 Cython
- en: 'Throughout this book, we have exclusively been mixing C and Python together.
    In this chapter, we will delve into C++ and Cython. With every release of Cython
    C++, the support has improved. This is not to say that it''s not ready for use
    yet. In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们一直是在混合 C 和 Python。在本章中，我们将深入研究 C++ 和 Cython。随着 Cython C++ 的每一次发布，支持都得到了改善。这并不是说它现在还不能使用。在本章中，我们将涵盖以下主题：
- en: Make native C++ classes callable from Python.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使本地的 C++ 类可从 Python 调用。
- en: Wrapping C++ namespaces and templates
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包装 C++ 命名空间和模板
- en: How exceptions can be propagated to and from C++ and Python
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常如何从 C++ 和 Python 中传播
- en: C++ new and del keyword
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++ 的 new 和 del 关键字
- en: Operator overloading
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符重载
- en: Cython gil and nogil keywords
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cython gil 和 nogil 关键字
- en: We will wrap up this chapter by embedding a web server into a toy C++ messaging
    server.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过将一个网络服务器嵌入到一个玩具 C++ 消息服务器中来结束本章。
- en: Cython and C++
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cython 和 C++
- en: Cython, above all binding generators, works with C++ the most seamlessly. C++
    has some complexity when writing bindings for it, such as calling conventions,
    templates, and classes. I find this exception handling to be a shining feature
    of Cython, and we will look at the examples of each.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有绑定生成器中，Cython 与 C++ 的结合最为无缝。C++ 在编写其绑定时有一些复杂性，例如调用约定、模板和类。我发现这种异常处理是 Cython
    的一个亮点，我们将查看每个示例。
- en: Namespaces
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间
- en: 'I am introducing namespaces first because Cython uses namespaces as a way to
    reference C++ code within your module. Consider this C++ header with the following
    namespace:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先介绍命名空间，因为 Cython 使用命名空间作为在模块中引用 C++ 代码的方式。考虑以下具有以下命名空间的 C++ 头文件：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You will wrap this with the `cdef extern` declaration:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用 `cdef extern` 声明将其包装起来：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can now address it in Cython as you normally would do for a module:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以在 Cython 中像通常对模块那样访问它：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It really feels like a Python module simply by using a namespace.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 只需使用命名空间，它就真的感觉像是一个 Python 模块。
- en: Classes
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: 'I would take a guess that most of your C++ code revolves around using classes.
    Being an object-oriented language, Cython handles this seamlessly:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我猜测，你大部分的 C++ 代码都是围绕使用类来编写的。作为一个面向对象的语言，Cython 可以无缝地处理这一点：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can use Cython''s `cppclass` keyword. This special keyword allows you to
    declare C++ classes and work with them directly, so you don''t need to write the
    wrapper code, which can be very tedious and error prone in big projects. Using
    the previous namespace example, we will wrap the namespace and then the class
    within the namespace:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Cython 的 `cppclass` 关键字。这个特殊的关键字允许你声明 C++ 类并直接与之交互，因此你不需要编写包装代码，这在大型项目中可能会非常繁琐且容易出错。使用之前的命名空间示例，我们将包装命名空间，然后是命名空间内的类：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It's pretty simple just as C types were. Though now, you have a native C++ object,
    which can be very powerful.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像 C 类型一样简单。尽管现在，你有一个本地的 C++ 对象，这可以非常强大。
- en: Remember that Cython will only care about the `public` attributes. Since these
    are the only attributes a callee can access due to the encapsulation of private
    and protected methods. It is not possible to extend the C++ class. Now, you can
    work with these as if they were just `cdef` structs. Just use the '`.`' operator
    as before to access all the necessary attributes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Cython 只会关心 `public` 属性。由于封装了私有和受保护的方法，这些是调用者可以访问的唯一属性。不可能扩展 C++ 类。现在，你可以像处理
    `cdef` 结构体一样处理这些。只需像以前一样使用 `.` 运算符来访问所有必要的属性。
- en: C++ new and del keyword
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++ 的 new 和 del 关键字
- en: 'Cython understands the `new` keyword from C++; so, consider that you have a
    C++ class:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Cython 理解 C++ 的 `new` 关键字；所以，考虑你有一个 C++ 类：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It is defined in Cython as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 它在 Cython 中如下定义：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that we do not declare the `~Car` destructor because we never call this
    directly. It''s not an explicitly callable public member; this is why we never
    call it directly but delete will and the compiler will ensure this is called when
    it will go out of scope on the stack. To instantiate the raw C++ class in Cython
    code on the heap, we can simply run the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有声明 `~Car` 析构函数，因为我们从未直接调用它。它不是一个显式可调用的公共成员；这就是为什么我们从未直接调用它，但 `delete`
    会，编译器将确保在它将离开栈作用域时调用它。要在 Cython 代码中在堆上实例化原始 C++ 类，我们可以简单地运行以下代码：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can then go and use `del` to delete the object at any time using Python''s
    `del` keyword:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用 Python 的 `del` 关键字在任何时候使用 `del` 删除对象：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You will see that the destructor is called as you would expect:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现析构函数的调用正如你所预期的那样：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can also declare a stack-allocated object, but it must only have a default
    constructor such as the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以声明一个栈分配的对象，但它必须只有一个默认构造函数，如下所示：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There is no way to pass arguments with this syntax in Cython. But, note that
    you cannot use `del` on this instance, else you will get the following error:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在Cython中，使用此语法无法传递参数。但是，请注意，你不能在这个实例上使用`del`，否则你会得到以下错误：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Exceptions
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: 'With C++ exception handling, you can get a sense of how seamless Cython can
    feel within the C++ code. If any exceptions are thrown, such as memory allocations,
    Cython will handle these and translate them into more useful errors, and you still
    get the valid C++ exceptions objects. Python will also understand if these are
    caught or not and whether they are handled as required. This table gives you an
    idea of what Python exceptions will map to within C++:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C++异常处理，你可以感受到Cython在C++代码中的无缝感。如果抛出了任何异常，例如内存分配，Cython将处理这些异常并将它们转换为更有用的错误，你仍然会得到有效的C++异常对象。Python也会理解这些是否被捕获以及是否按需处理。此表为你提供了Python异常在C++中映射的概览：
- en: '| C++ | Python |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| C++ | Python |'
- en: '| --- | --- |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `bad_alloc` | `MemoryError` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `bad_alloc` | `MemoryError` |'
- en: '| `bad_cast` | `TypeError` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `bad_cast` | `TypeError` |'
- en: '| `domain_error` | `ValueError` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `domain_error` | `ValueError` |'
- en: '| `invalid_argument` | `ValueError` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `invalid_argument` | `ValueError` |'
- en: '| `ios_base::failure` | `IOError` |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `ios_base::failure` | `IOError` |'
- en: '| `out_of_range` | `IndexError` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `out_of_range` | `IndexError` |'
- en: '| `overflow_error` | `OverflowError` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `overflow_error` | `OverflowError` |'
- en: '| `range_error` | `ArithmeticError` |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `range_error` | `ArithmeticError` |'
- en: '| `underflow_error` | `ArithmeticError` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `underflow_error` | `ArithmeticError` |'
- en: '| All other exceptions | `RuntimeError` |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 所有其他异常 | `RuntimeError` |'
- en: 'For instance, take this C++ code. It will simply throw an exception when the
    `myFunc` function is called. First, we define an exception with the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下C++代码。当调用`myFunc`函数时，它将简单地抛出一个异常。首先，我们使用以下内容定义一个异常：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we write the function to throw the exception:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们编写一个抛出异常的函数：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can call this in Cython with the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Cython中使用以下方式调用它：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When we run the function, we get the following output:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行函数时，我们得到以下输出：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you want to catch the C++ exception in your Python code, you can simply
    use it as normal:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在Python代码中捕获C++异常，你可以像平常一样使用它：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Notice that we told Cython to cast any exceptions to `RuntimeError`. This is
    important to make sure you understand where and which interfaces can throw an
    exception. Unhanded exceptions look really ugly and can be harder to debug. Cython
    cannot assume much about the state at this point since compilers won''t throw
    errors on potentially unhandled exceptions in C++ at the code level. If this happens,
    you will get the following as the no exception handler is ready:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们告诉Cython将任何异常转换为`RuntimeError`。这很重要，以确保你理解哪些接口和位置可能会抛出异常。未处理的异常看起来真的很糟糕，并且可能更难调试。在这个阶段，Cython无法对状态做出太多假设，因为编译器在C++代码级别上不会对可能未处理的异常抛出错误。如果发生这种情况，你将得到以下内容，因为没有准备好异常处理程序：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Bool type
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔类型
- en: 'As seen in the previous chapter, to use the native `bool` type from C++, you
    need to firstly import the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所示，要使用C++的本地`bool`类型，你首先需要导入以下内容：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, you can use `bool` as a normal `cdef`. If you want to use the pure PyObject
    `bool` type, you need to import the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用`bool`作为正常的`cdef`。如果你想使用纯PyObject `bool`类型，你需要导入以下内容：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can then assign them with the normal `true` or `false` values.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用正常的`true`或`false`值来分配它们。
- en: Overloading
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重载
- en: 'Since Python supports overloading to wrap C++ overload, just list the members
    as normal:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python支持重载以包装C++重载，只需按正常方式列出成员即可：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Cython understands that we are in C++ mode and can handle all the type conversion
    as normal. It''s interesting that it can also handle an operator overload easily
    since it is just another hook! For example, let''s take the `Car` class again
    and perform some operator overriding such as the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Cython理解我们处于C++模式，并且可以像正常一样处理所有类型转换。有趣的是，它还可以轻松处理运算符重载，因为它只是另一个钩子！例如，让我们再次以`Car`类为例，执行一些如下的运算符重载操作：
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Remember to add these operator-overloading class members to your Cythonized
    class; otherwise, your Cython will throw the following error:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 记得将这些运算符重载类成员添加到你的Cython化类中；否则，你的Cython将抛出以下错误：
- en: '[PRE22]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The Cython declaration of the operator overload looks as you expected:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符重载的Cython声明看起来正如你所期望的那样：
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, you can do the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以执行以下操作：
- en: '[PRE24]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This will then give us the following output on the command line:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在命令行上给我们以下输出：
- en: '[PRE25]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Everything is handled as you would expect. This, for me, demonstrates the principle
    that inspired Guido to design Python classes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的处理方式都如你所预期。对我来说，这证明了 Guido 设计 Python 类所受到的启发原则。
- en: Templates
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板
- en: Templates are supported in Cython. Though, for the sake of completeness, template
    meta-programming patterns don't wrap up correctly or fail to compile. This keeps
    getting better with every release, so take this comment with a pinch of salt.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Cython 支持模板。尽管如此，为了完整性，模板元编程模式可能无法正确包装或无法编译。随着每个版本的发布，这都在不断改进，所以请带着一点点盐来接受这个评论。
- en: 'C++ class templates work very well; we can implement a template called `LinkedList`
    as the following class:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 类模板工作得非常好；我们可以实现一个名为 `LinkedList` 的模板，如下所示：
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, you can access the template type with the declaration called `T`. You can
    follow the rest of this code in `chapter5/cpptemplates`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用名为 `T` 的声明来访问模板类型。你可以继续阅读 `chapter5/cpptemplates` 中的其余代码。
- en: Static class member attribute
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态类成员属性
- en: 'Sometimes, in classes, it''s useful to have a static attribute such as the
    following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在类中，拥有一个静态属性，如以下内容，是有用的：
- en: '[PRE27]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In Cython, there is no support for this via a `static` keyword, but what you
    can do is tie this function to a namespace so that it becomes the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cython 中，没有通过 `static` 关键字支持这一点，但你可以将这个函数绑定到一个命名空间上，使其成为以下内容：
- en: '[PRE28]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, you simply call this method as a global method in Cython.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你只需在 Cython 中将其作为全局方法调用即可。
- en: Calling C++ functions – Caveat
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用 C++ 函数 - 注意事项
- en: 'When you write a code to call in a C++ function from C, you need to wrap the
    prototypes in the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写代码从 C 调用 C++ 函数时，你需要将原型包装在以下内容中：
- en: '[PRE29]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This allows you to call C++ prototypes because C won't understand a C++ class.
    With Cython, if you are telling your C output to call in C++ functions, you need
    to be careful about which compiler you are using or you need to write a new header
    to implement the minimal wrapper functions required to make the C++ calls.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你调用 C++ 原型，因为 C 无法理解 C++ 类。使用 Cython 时，如果你要让你的 C 输出调用 C++ 函数，你需要小心选择编译器，或者你需要编写一个新的头文件来实现所需的包装函数，以便调用
    C++。
- en: Namespaces – Caveat
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间 - 注意事项
- en: Cython seems to generally require a namespace to keep things nested, which you
    are already probably doing in your C++ code. Making PXD on non-namespaced code
    seems to make new declarations, meaning that you will get linking errors due to
    multiple symbols. The C++ support looks really good from these templates, and
    more metaprogramming idioms can be difficult to express in Cython. When polymorphism
    comes into play, it can be difficult to track down compilation errors. I would
    stress that you should keep your interfaces as simple as possible to perform debugging
    and to be more dynamic!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Cython 似乎通常需要一个命名空间来保持嵌套，你可能已经在你的 C++ 代码中这样做。在非命名空间代码上创建 PXD 似乎会创建新的声明，这意味着你将因为多个符号而得到链接错误。从这些模板来看，C++
    的支持看起来非常好，并且更多的元编程习惯用法在 Cython 中可能难以表达。当多态发挥作用时，跟踪编译错误可能很困难。我强调，你应该尽可能保持你的接口简单，以便进行调试和更动态地操作！
- en: Tip
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember, when using Cython to generate C++, you need to specify `–cplus`, so
    it will default the `cythonfile.cpp` output. Pay attention to the extensions;
    I prefer to use `.cc` for my C++ code, so just be careful with your build system.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当使用 Cython 生成 C++ 时，你需要指定 `–cplus`，这样它将默认输出 `cythonfile.cpp`。注意扩展名；我更喜欢使用
    `.cc` 作为我的 C++ 代码，所以请确保你的构建系统正确无误。
- en: Python distutils
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python distutils
- en: 'As usual, we can also use Python `distutils`, but you will need to specify
    the language so that the auxiliary C++ code required will be compiled by the correct
    compiler:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，我们也可以使用 Python `distutils`，但你需要指定语言，这样所需的辅助 C++ 代码才会由正确的编译器编译：
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, you can compile your C++ code to your Python module.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以将你的 C++ 代码编译成 Python 模块。
- en: Python threading and GIL
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 线程和 GIL
- en: '**GIL** stands for **Global Interpreter Lock**. What this means is when you
    link your program against `libpython.so` and use it, you really have the entire
    Python interpreter in your code. The reason this exists is to make concurrent
    applications really easy. In Python you can have two threads reading/writing to
    the same location and Python automatically handles all of this for you; unlike
    say in Java, where you need to specify that everything is under the GIL in Python.
    There are two things to consider when talking about the GIL and what it does—instruction
    atomicity and read/write lock.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**GIL**代表**全局解释器锁**。这意味着当你将程序链接到`libpython.so`并使用它时，你实际上在你的代码中拥有整个Python解释器。这个存在的原因是为了使并发应用程序变得非常容易。在Python中，你可以有两个线程同时读写同一位置，Python会自动为你处理所有这些；与Java不同，在Java中你需要指定Python中的所有内容都在GIL之下。在讨论GIL及其作用时，有两个需要考虑的事情——指令原子性和读写锁。'
- en: Atomic instructions
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原子指令
- en: Remember that Cython necessarily generates the C code to make it look similar
    to any Python module that you can import. So, what's happening under the hood
    is that it will generate all the code to acquire lock on the GIL so that it can
    manipulate Python objects at runtime. Let's consider two types of execution. Firstly,
    you have the C stack where it executes atomically as you would expect; it doesn't
    care about synchronization between threads—this is left up to the programmer.
    The other is Python where it's doing all of this synchronization for us. When
    you embed Python into your application manually using `Py_Initilize`, this is
    under the C execution. When it comes to calling something, such as `import sys`
    and `sys.uname`, in the Cython code that is called from C, the Python GIL schedules,
    and blocks multiple threads from calling this at the same time to be safe. This
    makes writing multithreaded Python code extremely safe. Any errors from writing
    to the same location at the same time can happen and be handled correctly instead
    of having to use **mutex's** on critical sections in C.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Cython必然会生成C代码，使其看起来与任何你可以导入的Python模块相似。所以，在底层发生的事情是，它会生成所有代码来获取GIL的锁，以便在运行时操作Python对象。让我们考虑两种执行类型。首先，你有C栈，它以原子方式执行，正如你所期望的那样；它不关心线程之间的同步——这留给程序员来处理。另一种是Python，它为我们做所有的同步。当你手动使用`Py_Initilize`将Python嵌入到你的应用程序中时，这处于C执行之下。当涉及到调用某些内容，比如`import
    sys`和`sys.uname`，在从C调用的Cython代码中，Python GIL会调度并阻塞多个线程同时调用以保持安全。这使得编写多线程Python代码非常安全。任何同时写入同一位置的错误都可以发生并被正确处理，而不是需要在C中的关键部分使用**互斥锁**。
- en: Read/write lock
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读写锁
- en: The read/write lock is great because it is pretty rare for you in Python to
    need to care about semaphores or mutex's on data unless you want to synchronize
    different thread's access to a resource`.` The worst that can happen is for you
    to get into an inconsistent state in your program, but you won't crash in contrast
    to C/C++. Any read/write operation to the global dictionary is handled the way
    you would expect in Python.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 读写锁很棒，因为在Python中，你很少需要关心数据上的信号量或互斥锁，除非你想要同步不同线程对资源的访问。最糟糕的情况是，你的程序可能会进入不一致的状态，但与C/C++不同，你不会崩溃。任何对全局字典的读写操作都会按照你预期的Python方式处理。
- en: Cython keywords
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cython关键字
- en: 'Okay, so how does this affect you and, more importantly, your code? It is important
    to know what way your code should and/or will execute in a concurrent manner.
    Without an understanding of this, your debugging will be confusing. There are
    times when the GIL gets in the way and can cause issues by blocking the execution
    of your C code from Python or vice versa. Cython allows us to control the GIL
    with the `gil` and `nogil` keywords, which is much simpler by wrapping this state
    for us:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么这如何影响你，更重要的是，你的代码呢？了解你的代码应该如何以及将会以并发方式执行是很重要的。如果没有理解这一点，你的调试将会很困惑。有时候GIL会阻碍执行，导致从Python到C代码或反之的执行出现问题。Cython允许我们通过`gil`和`nogil`关键字来控制GIL，这通过为我们封装这个状态而变得简单得多：
- en: '| Cython | Python |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| Cython | Python |'
- en: '| --- | --- |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| With gil | `PyGILState_Ensure ()` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 使用gil | `PyGILState_Ensure ()` |'
- en: '| With nogil | `PyGILState_Release (state)` |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 使用nogil | `PyGILState_Release (state)` |'
- en: I find that it's easier to think of multithreading in Python in terms of blocking
    and nonblocking the execution. In the next example, we will examine the steps
    needed to embed a web server into a toy messaging server.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现用Python来考虑多线程更容易从阻塞和非阻塞执行的角度来思考。在下一个例子中，我们将检查将Web服务器嵌入到玩具消息服务器中所需的步骤。
- en: Messaging server
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息服务器
- en: The messaging server is an example of something that would be highly concurrent;
    let's say we want to embed a web server into this to show the list of clients
    that are connected to the server. If you look at the flask, you can see how easily
    you can have a full web container in about eight lines of code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 消息服务器是高度并发的示例之一；比如说，我们想在其中嵌入一个Web服务器来显示连接到服务器的客户端列表。如果你查看flask，你可以看到你可以在大约八行代码中轻松地拥有一个完整的Web容器。
- en: The messaging server is asynchronous; therefore, it is callback based in C code.
    These callbacks can then call into Python roster object via Cython. Then, we can
    iterate over the roster dictionary to get online clients and simply return some
    JSON as a web service very easily reusing Python code and no need to write anything
    in C/C++.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 消息服务器是异步的；因此，它在C代码中是基于回调的。然后，这些回调可以通过Cython调用Python的roster对象。然后，我们可以遍历roster字典以获取在线客户端，并简单地作为Web服务返回一些JSON，非常容易地重用Python代码，无需在C/C++中编写任何内容。
- en: 'It''s important to note when embedding web servers is that they start a lot
    of threads. Calling the start web server function will block until it will exit,
    meaning if we start the web server first, we won''t have the messaging server
    running concurrently. Also, due to the web-server function blocking, if we start
    it on a separate thread, it will never exit. Therefore, we are forced to run the
    messaging server on a background thread, and we can do this from the Python threading
    module. Again, this is where the GIL state becomes important. If we were to run
    the messaging server with the GIL and when the callbacks start, they will crash
    or block when they callback into Python. We can wrap the messaging server into
    the toy class called `MessageServer`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入Web服务器时，重要的是要注意它们启动了很多线程。调用启动Web服务器函数将阻塞，直到它退出，这意味着如果我们首先启动Web服务器，消息服务器将不会并发运行。此外，由于Web服务器函数阻塞，如果我们在一个单独的线程上启动它，它将永远不会退出。因此，我们被迫在后台线程上运行消息服务器，我们可以从Python线程模块中这样做。再次强调，这是GIL状态变得重要的地方。如果我们用GIL运行消息服务器，当回调开始时，它们将崩溃或阻塞。我们可以将消息服务器包装在名为`MessageServer`的玩具类中：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, as you would expect, we can start the thread by running this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，正如你所期望的，我们可以通过运行以下代码来启动线程：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Notice that I specified `with nogil`. Our C code doesn''t need the GIL since
    we are only using pure C types and not touching any Python runtime until the callbacks.
    Once the `libevent` socket server is running asynchronously, we can then move
    onto starting our flask web server:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我指定了`with nogil`。我们的C代码不需要GIL，因为我们只使用纯C类型，并且在回调之前不接触任何Python运行时。一旦`libevent`套接字服务器异步运行，我们就可以开始启动我们的flask
    Web服务器：
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Flask is fantastic for writing RESTful Web Services. It''s clean, simple, and
    most importantly, easy to use and read. This service returns the JSON representation
    of the client roster. Since I have encapsulated the roster object, I am using
    a simple global so that all the flask routes can query the correct context:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Flask非常适合编写RESTful Web服务。它干净、简单，最重要的是，易于使用和阅读。此服务返回客户端roster的JSON表示。由于我已经封装了roster对象，我使用一个简单的全局变量，以便所有flask路由都可以查询正确的上下文：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The web server now blocks until the kill signal is given. Then, it will return
    and we can then kill `MessageServer`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务器现在会阻塞，直到收到终止信号。然后，它将返回，然后我们可以终止`MessageServer`：
- en: '[PRE35]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, we listen onto the specified port in `server.cfg`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们监听`server.cfg`中指定的端口：
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This roster object holds a list of clients and handles each callback:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此roster对象包含一个客户端列表并处理每个回调：
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We run the server as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按照以下方式运行服务器：
- en: '[PRE38]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can then connect clients using a simple telnet session:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用简单的telnet会话连接客户端：
- en: '[PRE39]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can type in messages, see it handled in the server log, and press *Q* to
    quit. We can then query the web service for the list of clients:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以输入消息，在服务器日志中看到它被处理，然后按*Q*退出。然后，我们可以查询Web服务以获取客户端列表：
- en: '[PRE40]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Caveat on GIL
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GIL的注意事项
- en: 'There is a caveat to remember when using `gil`. In our callbacks, we need to
    acquire the GIL on each callback before we call any Python code; otherwise, we
    will segfault and get really confused. So, if you look into each of the `libevent`
    callbacks when calling the Cython functions, you have the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`gil`时有一个需要注意的注意事项。在我们的回调中，在调用任何Python代码之前，我们需要在每个回调中获取GIL；否则，我们将发生段错误并感到非常困惑。所以，如果你查看调用Cython函数时的每个`libevent`回调，你会看到以下内容：
- en: '[PRE41]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Notice that this is also called on the other two callbacks—firstly on the `discb`
    callback:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这也在其他两个回调上调用——首先是在`discb`回调上：
- en: '[PRE42]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, on the connect callback, we must be a little safer and call it this
    way:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在连接回调中，我们必须更加小心，并这样调用它：
- en: '[PRE43]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We have to do this since we executed this with `nogil` from Cython. We need
    to acquire `gil` before we go back into the Python land. You really need to look
    at something like this with your creativity cap on and imagine what you could
    do with this. For example, you can use this as a way to capture data and use the
    Twisted Web server to implement an embedded RESTful server. Maybe, you can even
    use Python JSON to wrap data into nice objects. But, it demonstrates how you can
    really extend a fairly complicated piece of C software with something nice and
    of a high-level nature using Python libraries. This keeps everything very simple
    and maintainable instead of trying to do everything from scratch.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须这样做，因为我们使用Cython的`nogil`执行了它。在我们返回Python领域之前，我们需要获取`gil`。你真的需要戴上你的创造力帽子，看看这样一些东西，并想象你能用它做什么。例如，你可以用它作为捕获数据的方式，并使用Twisted
    Web服务器实现嵌入式RESTful服务器。也许，你甚至可以使用Python JSON将数据包装成漂亮的对象。但是，它展示了如何使用Python库真正扩展一个相当复杂的C软件组件，使其既好又具有高级性质。这使一切都非常简单且易于维护，而不是从头开始尝试做所有事情。
- en: Unit testing the native code
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地代码的单元测试
- en: 'Another use of Cython is unit testing the core functionality of shared C libraries.
    If you maintain a `.pxd` file (this is all you need really), you can write your
    own wrapper classes and do scalability testing of data structures with the expressiveness
    of Python. For example, we can write unit tests for something such as `std::map`
    and `std::vector` as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Cython的另一个用途是单元测试共享C库的核心功能。如果你维护一个`.pxd`文件（这实际上是你需要的全部），你可以编写自己的包装类，并使用Python的表达力进行数据结构的可伸缩性测试。例如，我们可以按照以下方式为`std::map`和`std::vector`编写单元测试：
- en: '[PRE44]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, write a test for `map` as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，按照以下方式为`map`编写测试：
- en: '[PRE45]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, if we compile them into separate modules, we can simply write a test
    executor:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们将它们编译成单独的模块，我们可以简单地编写一个测试执行器：
- en: '[PRE46]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This is really trivial code, but it demonstrates the idea. If you put error
    handling with plenty of asserts and cause a fatal error, you can have some really
    nice unit testing against your C/C++ code. We can go further and implement this
    using Python's native unit testing framework.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是非常简单的代码，但它展示了这个想法。如果你添加了大量的断言和致命错误处理，你就可以对你的C/C++代码进行一些非常棒的单元测试。我们可以更进一步，使用Python的本地单元测试框架来实现这一点。
- en: Preventing subclassing
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止子类化
- en: 'If you create an extension type in Cython, something you never want to be subclassed,
    it is a `cpp` class wrapped in a Python class. To prevent this, you can do the
    following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Cython创建了一个扩展类型，一个你永远不会希望被子类化的类型，它是一个被Python类包裹的`cpp`类。为了防止这种情况，你可以这样做：
- en: '[PRE47]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This annotation will give an error when someone tries to subclass:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人尝试子类化时，这个注释将引发错误：
- en: '[PRE48]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note that these annotations only work on the `cdef` or `cpdef` functions and
    not on normal Python `def` functions.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些注释只适用于`cdef`或`cpdef`函数，而不适用于正常的Python `def`函数。
- en: Parsing large amounts of data
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析大量数据
- en: I want to try and prove how powerful and natively compiled C types are to programmers
    by showing the difference in parsing large amounts of XML. We can take the geographic
    data from the government as the test data for this experiment ([http://www.epa.gov/enviro/geospatial-data-download-service](http://www.epa.gov/enviro/geospatial-data-download-service)).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我想通过展示解析大量XML的差异来尝试证明C类型对程序员是多么强大和原生编译的。我们可以将政府的地域数据作为这个实验的测试数据（[http://www.epa.gov/enviro/geospatial-data-download-service](http://www.epa.gov/enviro/geospatial-data-download-service)）。
- en: 'Let''s look at the size of this XML data:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个XML数据的大小：
- en: '[PRE49]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'It''s huge! Before we write programs, we need to understand a little bit about
    the structure of this data to see what we want to do with it. It contains facility
    site locations with addresses. This seems to be the bulk of the data in here,
    so let''s try and parse it all out with a pure Python XML parser using the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 它太大了！在我们编写程序之前，我们需要了解一些关于这些数据结构的信息，看看我们想用它做什么。它包含设施站点地址。这似乎是这里数据的大头，所以让我们尝试使用以下纯Python
    XML解析器解析它：
- en: '[PRE50]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The code uses `etree` to parse the XML file via the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用`etree`通过以下方式解析XML文件：
- en: '[PRE51]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then, we look up the header and facilities via the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过以下方式查找头文件和设施：
- en: '[PRE52]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally, we output them into a file:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将它们输出到文件中：
- en: '[PRE53]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We then time the execution as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后按照以下方式计时执行：
- en: '[PRE54]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This is quite long, but let''s compare it using a different XML implementation—Python
    `lxml`. It''s a different library implemented using Cython, but it implements
    the same library as the previous pure Python XML parser:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这段内容相当长，但让我们使用不同的 XML 实现来比较一下——Python 的 `lxml`。这是一个使用 Cython 实现的库，但它实现了与之前纯
    Python XML 解析器相同的库：
- en: '[PRE55]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can simply drop the replacement import into the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简单地将在下面的替换导入：
- en: '[PRE56]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The code stays the same, but the execution time is dramatically reduced (compile
    the Cython version by running `make` and the `cpyparse` binary is created from
    the same code with just a different import):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 代码保持不变，但执行时间显著减少（通过运行 `make` 编译 Cython 版本，`cpyparse` 二进制文件是由相同的代码创建的，只是导入方式不同）：
- en: '[PRE57]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You can really see the power of using native code when you make just a little
    effort. And to be finally assured that the code is the same, let''s `MD5` sum
    `xmlout.dat` that we created:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当你只付出一点努力时，你真的可以看到使用原生代码的强大之处。为了最终确保代码相同，让我们计算我们创建的 `xmlout.dat` 的 `MD5` 校验和：
- en: '[PRE58]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: So, you can see that the outputs are exactly the same just so we know that no
    funny business is going on. It's scary how much faster this can make your XML
    parsing; and if we calculate the speed increase rate, it is approximately 17.75
    times faster; but don't take my word for it; try running it yourself. My MacBook
    has a solid state disk and has a 4 GB RAM with a 2 GHz Core 2 Duo.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以看到输出完全相同，这样我们就知道没有发生任何奇怪的事情。这让人感到害怕，这可以使你的 XML 解析速度有多快；如果我们计算速度增加率，它大约快了
    17.75 倍；但不要只听我的话；自己试一试。我的 MacBook 配有固态硬盘，有 4 GB 的 RAM，2 GHz 的 Core 2 Duo 处理器。
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Up to now, you will have seen the core of what's possible with Cython. In this
    chapter, we covered calling into C++ classes from Cython. You learned to wrap
    templates and even look at a more complex application demonstrating the usage
    of `gil` and `nogil`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了使用 Cython 可以实现的核心功能。在本章中，我们介绍了从 Cython 调用 C++ 类。你学习了如何封装模板，甚至查看了一个更复杂的应用，展示了
    `gil` 和 `nogil` 的使用。
- en: '[Chapter 6](ch06.html "Chapter 6. Further Reading"), *Further Reading* is the
    final chapter and will review some final caveats and usages with Cython. I will
    show how you can use Cython with Python 3\. Finally, we will look at related projects
    and my opinions on their usages.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 6 章](ch06.html "第 6 章。进一步阅读")，*进一步阅读* 是最后一章，将回顾一些关于 Cython 的最终注意事项和用法。我将展示如何使用
    Cython 与 Python 3 结合。最后，我们将探讨相关项目和我在它们使用方面的观点。'
