- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Social Media Post Management
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 社交媒体帖子管理
- en: In the previous chapter, we introduced models, serializers, viewsets, and routes
    to create our first endpoints. In this chapter, we will be working with the same
    concepts for creating posts for our social media project. This will be done by
    dividing the project into concepts such as database relations, filtering, and
    permissions. By the end of this chapter, you’ll be able to work with database
    relations with Django models, write custom filters and permissions, and delete
    and update objects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了模型、序列化器、视图集和路由来创建我们的第一个端点。在本章中，我们将使用相同的概念为我们的社交媒体项目创建帖子。这将通过将项目划分为数据库关系、过滤和权限等概念来完成。在本章结束时，你将能够使用Django模型处理数据库关系，编写自定义过滤和权限，以及删除和更新对象。
- en: 'We will be covering the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating the Post model
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建帖子模型
- en: Writing the Post model
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写帖子模型
- en: Writing the Post serializer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写帖子序列化器
- en: Writing Post viewsets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写帖子视图集
- en: Adding permissions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加权限
- en: Deleting and updating posts
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除和更新帖子
- en: Adding the Like feature
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加点赞功能
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you need to have Insomnia installed on your machine to make
    HTTP requests.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要在你的机器上安装Insomnia来发送HTTP请求。
- en: 'You can find the code for this chapter here: [https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap3](https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap3).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到本章的代码：[https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap3](https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap3)。
- en: Creating the Post model
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建帖子模型
- en: 'A post in this project is a long or short piece of text that can be viewed
    by anyone, irrespective of whether a user is linked or associated to that post.
    Here are the requirements for the post feature:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，帖子是一篇长或短的文本，任何人都可以查看，无论用户是否与该帖子相关联。以下是帖子功能的要求数据：
- en: Authenticated users should be able to create a post
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证用户应该能够创建帖子
- en: Authenticated users should be able to like the post
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证用户应该能够点赞帖子
- en: All users should be able to read the post, even if they aren’t authenticated
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有用户都应该能够阅读帖子，即使他们未认证
- en: The author of the post should be able to modify the post
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帖子的作者应该能够修改帖子
- en: The author of the post should be able to delete the post
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帖子的作者应该能够删除帖子
- en: Looking at these requirements from a backend perspective, we can understand
    that we’ll be dealing with a database, a model, and permissions. First, let’s
    start by writing the structure of the `Post` model in the database.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从后端的角度来看这些需求，我们可以理解我们将要处理数据库、模型和权限。首先，让我们从编写数据库中`帖子`模型的结构开始。
- en: Designing the Post model
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计帖子模型
- en: A post consists of content made up of characters written by an author (here,
    a user). How does that schematize itself into our database?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 帖子由作者（在这里，是用户）撰写的字符组成的内容。它是如何在我们数据库中结构化的？
- en: 'Before creating the `Post` model, let’s draw a quick figure of the structure
    of the model in the database:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`帖子`模型之前，让我们快速绘制一下数据库中模型结构的图示：
- en: '![Figure 3.1 – Post table](img/Figure_3.1_B18221.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 帖子表](img/Figure_3.1_B18221.jpg)'
- en: Figure 3.1 – Post table
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 帖子表
- en: As you can see in *Figure 3**.1*, there is an `author` field, which is a `User`
    table. Each time a post is created, a foreign key will need to be passed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图3.1*所示，有一个`作者`字段，它是一个`用户`表。每次创建帖子时，都需要传递一个外键。
- en: The foreign key is one of the characteristics of the **one-to-many** (or **many-to-one**)
    relationship. In this relationship, a row in table A can have many matching rows
    in table B (*one-to-many*) but a row in table B can only have one matching row
    in table A.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 外键是**一对一**（或**多对一**）关系的一个特征。在这种关系中，表A中的一行可以在表B中有多个匹配行（*一对多*），但表B中的一行只能有一个匹配表A的行。
- en: 'In our case, a user (from the `User` table) can have many posts (in the `Post`
    table) but a post can only have one user (*Figure 3**.2*):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，一个用户（来自`用户`表）可以有多个帖子（在`帖子`表中），但一个帖子只能有一个用户（*图3.2*）：
- en: '![Figure 3.2 – User and Post relationship](img/Figure_3.2_B18221.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – 用户和帖子关系](img/Figure_3.2_B18221.jpg)'
- en: Figure 3.2 – User and Post relationship
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 用户和帖子关系
- en: 'There are also two other types of database relationships:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两种其他类型的数据库关系：
- en: 'One-to-one: In this type of relationship, a row in table A can only have one
    matching row in table B, and vice versa. An example of this can be worker C having
    one and only one desk D. And this desk D can only be used by this worker C (*Figure
    3**.3*):'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对一：在这种关系类型中，表A中的一行只能对应表B中的一行，反之亦然。例如，工人C只有一个且仅有一个桌子D。而这个桌子D只能由这个工人C使用（**图3.3**.3）：
- en: '![Figure 3.3 – One-to-one relationship between a worker and a desk](img/Figure_3.3_B18221.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – 工人与桌子之间的一对一关系](img/Figure_3.3_B18221.jpg)'
- en: Figure 3.3 – One-to-one relationship between a worker and a desk
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 工人与桌子之间的一对一关系
- en: 'Many-to-many: In this type of database relationship, a row in table A can have
    many matching rows in table B, and vice versa. For example, in an e-commerce application,
    an order can have many items, and an item can also appear in many different orders
    (*Figure 3**.4*):'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多对多：在这种数据库关系类型中，表A中的一行可以对应表B中的多行，反之亦然。例如，在一个电子商务应用中，一个订单可以有多个商品，一个商品也可以出现在多个不同的订单中（**图3.4**.4）：
- en: '![Figure 3.4 – Many-to-many relationship between an order and an item](img/Figure_3.4_B18221.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 – 订单与商品之间的多对多关系](img/Figure_3.4_B18221.jpg)'
- en: Figure 3.4 – Many-to-many relationship between an order and an item
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 订单与商品之间的多对多关系
- en: The *many-to-many* relationship will be used when writing the *like* feature
    for the posts.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写帖子的“点赞”功能时，将使用*多对多*关系。
- en: Great, now that we have a better idea of database relationships, we can begin
    to write the post feature, starting from the `Post` model. But before that, let’s
    quickly refactor the code to make development easier.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，现在我们更好地了解了数据库关系，我们可以开始编写帖子功能，从`Post`模型开始。但在那之前，让我们快速重构代码以使开发更容易。
- en: Abstraction
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象
- en: The next models that we’ll create will also have the `public_id`, `created`,
    and `updated` fields. For the sake of the **don’t repeat yourself** (**DRY**)
    principle, we will use abstract model classes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要创建的下一个模型也将包含`public_id`、`created`和`updated`字段。为了遵循**不要重复自己**（**DRY**）原则，我们将使用抽象模型类。
- en: An **abstract class** can be considered a blueprint for other classes. It usually
    contains a set of methods or attributes that must be created within any child
    classes built from the abstract class.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**抽象类**可以被视为其他类的蓝图。它通常包含一组必须在从抽象类构建的任何子类中创建的方法或属性。
- en: 'Inside the `core` directory, create a new Python package called `abstract`.
    Once it’s done, create a `models.py` file. In this file, we will write two classes:
    `AbstractModel` and `AbstractManager`.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在`core`目录内，创建一个新的Python包，命名为`abstract`。完成后，创建一个`models.py`文件。在这个文件中，我们将编写两个类：`AbstractModel`和`AbstractManager`。
- en: 'The `AbstractModel` class will contain fields such as `public_id`, `created`,
    and `updated`. On the other side, the `AbstractManager` class will contain the
    function used to retrieve an object by its `public_id` field:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbstractModel`类将包含如`public_id`、`created`和`updated`等字段。另一方面，`AbstractManager`类将包含用于通过`public_id`字段检索对象的函数：'
- en: core/abstract/models.py
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: core/abstract/models.py
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see in the `Meta` class for `AbstractModel`, the `abstract` attribute
    is set to `True`. Django will ignore this class model and won’t generate migrations
    for this.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在`AbstractModel`的`Meta`类中看到的，`abstract`属性被设置为`True`。Django将忽略这个类模型，并且不会为这个模型生成迁移。
- en: 'Now that we have this class, let’s make a quick refactor on the `User` model:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个类，让我们对`User`模型进行快速重构：
- en: 'First, let’s remove the `get_object_by_public_id` method to retrieve an object
    via `public_id`, and let’s subclass `UserManager`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们移除用于通过`public_id`检索对象的`get_object_by_public_id`方法，并让`UserManager`成为子类：
- en: core/user/models.py
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: core/user/models.py
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: On the `User` model, remove the `public_id`, `updated`, and `created` fields,
    and also, subclass the `User` model with the `AbstractModel` class. This will
    normally cause no changes to the database, hence, there is no need to run `makemigrations`
    again unless you’ve changed an attribute of a field.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在`User`模型上，移除`public_id`、`updated`和`created`字段，并且，使用`AbstractModel`类子类化`User`模型。这通常不会对数据库造成任何变化，因此，除非你已更改字段的属性，否则无需再次运行`makemigrations`。
- en: Let’s also add `AbstractSerializer`, which will be used by all the serializers
    we’ll be creating on this project.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再添加一个`AbstractSerializer`，它将被我们在本项目中创建的所有序列化器使用。
- en: Writing the AbstractSerializer
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写抽象序列化器
- en: 'All the objects sent back as a response in our API will contain the `id`, `created`,
    and `updated` fields. It’ll be repetitive to write these fields all over again
    on every `ModelSerializer`, so let’s just create an `AbstractSerializer` class.
    In the `abstract` directory, create a file called `serializers.py` and add the
    following content:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们API中返回的所有对象都将包含`id`、`created`和`updated`字段。在每一个`ModelSerializer`上再次编写这些字段将是重复的，所以让我们只创建一个`AbstractSerializer`类。在`abstract`目录中，创建一个名为`serializers.py`的文件，并添加以下内容：
- en: core/abstract/serializers.py
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: core/abstract/serializers.py
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once it’s done, you can go and subclass the `UserSerializer` class with the
    `AbstractSerializer` class:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你可以去子类化`UserSerializer`类，使用`AbstractSerializer`类：
- en: core/user/serializers.py
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: core/user/serializers.py
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once it’s done, remove the field declaration of `id`, `created`, and `updated`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，删除`id`、`created`和`updated`字段的声明。
- en: Let’s perform one last abstraction for `ViewSets`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对`ViewSets`进行最后一次抽象。
- en: Writing the AbstractViewSet
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写AbstractViewSet
- en: But why write an abstract `ViewSet`? Well, there will be repeated declarations
    as to the ordering and the filtering. Let’s create a class that will contain the
    default values.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么要写一个`ViewSet`的摘要呢？嗯，会有关于排序和过滤的重复声明。让我们创建一个包含默认值的类。
- en: 'In the `abstract` directory, create a file called `viewsets.py` and add the
    following content:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在`abstract`目录中，创建一个名为`viewsets.py`的文件，并添加以下内容：
- en: core/abstract/viewsets.py
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: core/abstract/viewsets.py
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see, we have the following attributes:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们有以下属性：
- en: '`filter_backends`: This sets the default filter backend.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter_backends`：这设置了默认的过滤器后端。'
- en: '`ordering_fields`: This list contains the fields that can be used as ordering
    parameters when making a request.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ordering_fields`：这个列表包含在请求时可以作为排序参数使用的字段。'
- en: '`ordering`: This will tell Django REST in which order to send many objects
    as a response. In this case, all the responses will be ordered by the most recently
    updated.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ordering`：这将告诉Django REST以何种顺序发送多个对象作为响应。在这种情况下，所有响应都将按最近更新的顺序排序。'
- en: 'The next step is to add the `AbstractViewSet` class to the code where `ModelViewSets`
    is actually called. Go to `core/user/viewsets.py` and subclass `UserViewSet` with
    the `AbstractViewSet` class:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将`AbstractViewSet`类添加到代码中，实际上是在调用`ModelViewSets`的地方。转到`core/user/viewsets.py`，并使用`AbstractViewSet`类来子类化`UserViewSet`：
- en: core/user/viewsets.py
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: core/user/viewsets.py
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Great, now we have all the things needed to write better and less code; let’s
    write the `Post` model.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，现在我们有了编写更好、更少代码所需的所有东西；让我们编写`Post`模型。
- en: Writing the Post model
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写Post模型
- en: 'We have already established the structure of the `Post` model. Let’s write
    the code and the features:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经建立了`Post`模型的结构。让我们编写代码和功能：
- en: 'Create a new application called `post`:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`post`的新应用：
- en: '[PRE6]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Rewrite `apps.py` of the new create package so it can be called easily in the
    project:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新编写新创建的包的`apps.py`，以便在项目中轻松调用：
- en: core/post/apps.py
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: core/post/apps.py
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once it’s done, we can now write the `Post` model. Open the `models.py` file
    and enter the following content:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，我们现在可以编写`Post`模型。打开`models.py`文件，输入以下内容：
- en: core/post/models.py
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: core/post/models.py
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can see here how we created the `ForeignKey` relationship. Django models
    actually provide tools to handle this kind of relationship, and it’s also symmetrical,
    meaning that not only can we use the `Post.author` syntax to access the user object
    but we can also access posts created by a user using the `User.post_set` syntax.
    The latter syntax will return a `queryset` object containing the posts created
    by the user because we are in a `ForeignKey` relationship, which is also a one-to-many
    relationship. You will also notice the `on_delete` attribute with the `models.CASCADE`
    value. Using `CASCADE`, if a user is deleted from the database, Django will also
    delete all records of posts in relation to this user.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里看到我们是如何创建`ForeignKey`关系的。Django模型实际上提供了处理这种关系的工具，它也是对称的，这意味着我们不仅可以使用`Post.author`语法来访问用户对象，还可以使用`User.post_set`语法来访问用户创建的帖子。后者语法将返回一个包含用户创建的帖子的`queryset`对象，因为我们处于`ForeignKey`关系，这同样是一个一对多关系。你也会注意到`on_delete`属性具有`models.CASCADE`值。使用`CASCADE`，如果从数据库中删除用户，Django也会删除与此用户相关的所有帖子记录。
- en: 'Apart from `CASCADE` as a value for the `on_delete` attribute on a `ForeignKey`
    relationship, you can also have the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`CASCADE`作为`ForeignKey`关系上`on_delete`属性值的选项之外，你还可以有如下选项：
- en: '`SET_NULL`: This will set the child object foreign key to null on delete. For
    example, if a user is deleted from the database, the value of the `author` field
    of the posts in relation to this user is set to **None**.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SET_NULL`：这将在删除时将子对象的外键设置为null。例如，如果从数据库中删除用户，则与该用户相关的帖子的`author`字段值设置为**None**。'
- en: '`SET_DEFAULT`: This will set the child object to the default value given while
    writing the model. It works if you are sure that the default value won’t be deleted.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SET_DEFAULT`：这将在写入模型时将子对象设置为给定的默认值。如果你确定默认值不会被删除，则它将工作。'
- en: '`RESTRICT`: This raises `RestrictedError` under certain conditions.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RESTRICT`：在特定条件下会引发`RestrictedError`。'
- en: '`PROTECT`: This prevents the foreign key object from being deleted as long
    as there are objects linked to the foreign key object.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PROTECT`：这会阻止外键对象被删除，只要还有对象与外键对象相关联。'
- en: 'Let’s test the newly added model by creating an object and saving it in the
    database:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个对象并将其保存到数据库中来测试新添加的模型：
- en: 'Add the newly created application to the `INSTALLED_APPS` list:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新创建的应用程序添加到`INSTALLED_APPS`列表中：
- en: CoreRoot/settings.py
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: CoreRoot/settings.py
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s create the migrations for the newly added application:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为新增的应用程序创建迁移：
- en: '[PRE10]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, let’s play with the `python manage.py` `shell` command:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们使用`python manage.py` `shell`命令进行操作：
- en: '[PRE11]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Important note
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'You can use the **django_shell_plus** package to speed up work with Django
    shell. You won’t need to type all imports yourself as all your models will be
    imported by default. You can find more information on how to install it from the
    following website: [https://django-extensions.readthedocs.io/en/latest/shell_plus.html](https://django-extensions.readthedocs.io/en/latest/shell_plus.html).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用**django_shell_plus**包来加速与Django shell的工作。你不需要自己输入所有导入，因为默认情况下所有模型都会被导入。你可以在以下网站上找到有关如何安装它的更多信息：[https://django-extensions.readthedocs.io/en/latest/shell_plus.html](https://django-extensions.readthedocs.io/en/latest/shell_plus.html)。
- en: 'Let’s import a user. This will be the author of the post we’ll be creating:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入一个用户。这将是我们将要创建的帖子的作者：
- en: '[PRE16]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, let’s create a dictionary that will contain all the fields needed to
    create a post:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个字典，它将包含创建帖子所需的所有字段：
- en: '[PRE20]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And now, let’s create a post:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个帖子：
- en: '[PRE21]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, the author is in fact the user we’ve retrieved from the database.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，作者实际上是我们在数据库中检索到的用户。
- en: 'Let’s also try the inverse relationship:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也尝试反向关系：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, the `post_set` attribute contains all the instructions needed
    to interact with all the posts linked to this user.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`post_set`属性包含了与该用户相关联的所有帖子所需的所有交互指令。
- en: Now that you have a better understanding of how database relationships work
    in Django, we can move on to writing the serializer of the `Post` object.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经更好地理解了Django中数据库关系的工作方式，我们可以继续编写`Post`对象的序列化器。
- en: Writing the Post serializer
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写Post序列化器
- en: The `Post` serializer will contain the fields needed to create a post when making
    a request on the endpoint. Let’s add the feature for the post creation first.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`Post`序列化器将包含在端点请求时创建帖子所需的字段。让我们首先添加帖子创建的功能。'
- en: 'In the `post` directory, create a file called `serializers.py`. Inside this
    file, add the following content:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在`post`目录下，创建一个名为`serializers.py`的文件。在这个文件中，添加以下内容：
- en: core/post/serializers.py
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: core/post/serializers.py
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We’ve added a new serializer field type, `SlugRelatedField`. As we are working
    with the `ModelSerializer` class, Django automatically handles the fields and
    relationship generation for us. Defining the type of relationship field we want
    to use can also be crucial to tell Django exactly what to do.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个新的序列化器字段类型，`SlugRelatedField`。由于我们正在使用`ModelSerializer`类，Django会自动为我们处理字段和关系生成。定义我们想要使用的关联字段类型对于告诉Django确切要做什么也非常关键。
- en: And that’s where `SlugRelatedField` comes in. It is used to represent the target
    of the relationship using a field on the target. Thus, when creating a post, `public_id`
    of the author will be passed in the body of the request so that the user can be
    identified and linked to the post.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正是`SlugRelatedField`在这里发挥作用。它用于使用目标上的字段来表示关系的目标。因此，在创建帖子时，作者的`public_id`将通过请求体传递，以便用户可以被识别并关联到帖子。
- en: The `validate_author` method checks validation for the `author` field. Here,
    we want to make sure that the user creating the post is the same user as in the
    `author` field. A context dictionary is available in every serializer. It usually
    contains the request object that we can use to make some checks.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`validate_author` 方法检查 `author` 字段的验证。在这里，我们想确保创建帖子的用户与 `author` 字段中的用户相同。每个序列化器都有一个上下文字典可用。它通常包含我们可以用来进行一些检查的请求对象。'
- en: 'There is no hard limitation here so we can easily move to the next part of
    this feature: writing the `Post` viewsets.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有硬性限制，因此我们可以轻松地进入这个功能的下一部分：编写 `Post` 视图集。
- en: Writing Post viewsets
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写帖子视图集
- en: For the following endpoint, we’ll only be allowing the `POST` and `GET` methods.
    This will help us have the basic features working first.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下端点，我们只允许 `POST` 和 `GET` 方法。这将帮助我们首先实现基本功能。
- en: 'The code should follow these rules:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 代码应遵循以下规则：
- en: Only authenticated users can create posts
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有经过身份验证的用户才能创建帖子
- en: Only authenticated users can read posts
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有经过身份验证的用户才能读取帖子
- en: Only `GET` and `POST` methods are allowed
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只允许使用 `GET` 和 `POST` 方法
- en: 'Inside the `post` directory, create a file called `viewsets.py`. Into the file,
    add the following content:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `post` 目录中，创建一个名为 `viewsets.py` 的文件。在文件中，添加以下内容：
- en: core/post/viewsets.py
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: core/post/viewsets.py
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the preceding code, we defined three interesting methods:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了三个有趣的方法：
- en: The `get_queryset` method returns all the posts. We don’t actually have particular
    requirements for fetching posts, so we can return all posts in the database.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_queryset` 方法返回所有帖子。我们实际上没有特定的获取帖子要求，因此我们可以返回数据库中的所有帖子。'
- en: The `get_object` method returns a `post` object using `public_id` that will
    be present in the URL. We retrieve this parameter from the `self.kwargs` directory.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_object` 方法使用 `public_id` 返回一个 `post` 对象，该 `public_id` 将出现在 URL 中。我们从 `self.kwargs`
    目录中检索此参数。'
- en: The `create` method, which is the `ViewSet` action executed on `POST` requests
    on the endpoint linked to `ViewSet`. We simply pass the data to the serializer
    declared on `ViewSet`, validate the data, and then call the `perform_create` method
    to create a `post` object. This method will automatically handle the creation
    of a `post` object by calling the `Serializer.create` method, which will trigger
    the creation of a `post` object in the database. Finally, we return a response
    with the newly created post.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create` 方法，这是在 `ViewSet` 的 `POST` 请求端点执行的 `ViewSet` 动作。我们只需将数据传递给在 `ViewSet`
    上声明的序列化器，验证数据，然后调用 `perform_create` 方法来创建 `post` 对象。此方法将自动通过调用 `Serializer.create`
    方法来处理 `post` 对象的创建，这将触发在数据库中创建 `post` 对象。最后，我们返回一个包含新创建帖子的响应。'
- en: And right here, you have the code for `ViewSet`. The next step is to add an
    endpoint and start testing the API.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正在这里，你有 `ViewSet` 的代码。下一步是添加端点并开始测试 API。
- en: Adding the Post route
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加帖子路由
- en: 'In the `routers.py` file, add the following content:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `routers.py` 文件中，添加以下内容：
- en: core/routers.py
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: core/routers.py
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Once it’s done, you’ll have a new endpoint available on `/post/`. Let’s play
    with Insomnia to test the API.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你将在 `/post/` 路径下获得一个新的端点。让我们用 Insomnia 来测试 API。
- en: First of all, try to make a request directly to the `/post/` endpoint. You’ll
    receive a `/auth/login/` endpoint with a registered user and copy the token.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，尝试直接向 `/post/` 端点发送请求。你会收到一个 `/auth/login/` 端点，并使用注册用户复制令牌。
- en: 'In the **Bearer** tab in Insomnia, select **Bearer Token**:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Insomnia 的 **Bearer** 选项卡中，选择 **Bearer Token**：
- en: '![Figure 3.5 – Adding Bearer Token to Insomnia request](img/Figure_3.5_B18221.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – 将 Bearer Token 添加到 Insomnia 请求中](img/Figure_3.5_B18221.jpg)'
- en: Figure 3.5 – Adding Bearer Token to Insomnia request
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 将 Bearer Token 添加到 Insomnia 请求中
- en: Now, fire the endpoint again with a `GET` request. You’ll see no results, great!
    Let’s create the first post in the database.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次使用 `GET` 请求触发端点。你会看到没有结果，太好了！让我们在数据库中创建第一个帖子。
- en: 'Change the type of request to `POST` and the following to the JSON body:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 将请求类型更改为 `POST` 并将以下内容更改为 JSON 主体：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Please note that we will have a different `public_id` so make sure to use `public_id`
    of the user you’ve just logged in as and send the request again:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将有一个不同的 `public_id`，请确保使用你刚刚登录的用户 `public_id` 并重新发送请求：
- en: '![Figure 3.6 – Creating a post](img/Figure_3.6_B18221.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – 创建帖子](img/Figure_3.6_B18221.jpg)'
- en: Figure 3.6 – Creating a post
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 创建帖子
- en: 'Great, the post is created! Let’s see whether it’s available when making a
    `GET` request:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，帖子已创建！让我们看看在发送 `GET` 请求时它是否可用：
- en: '![Figure 3.7 – Getting all posts](img/Figure_3.7_B18221.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7 – 获取所有帖子](img/Figure_3.7_B18221.jpg)'
- en: Figure 3.7 – Getting all posts
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 获取所有帖子
- en: The DRF provides a way to paginate responses and a default pagination limit
    size globally in the `settings.py` file. With time, a lot of objects will be shown
    and the size of the payload will vary.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: DRF 提供了一种分页响应的方式，并在 `settings.py` 文件中设置了一个全局默认分页限制大小。随着时间的推移，将显示很多对象，并且有效负载的大小也会变化。
- en: To prevent this, let’s add a default size and a class to paginate our results.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况，让我们添加一个默认大小和一个类来分页我们的结果。
- en: 'Inside the `settings.py` file of the project, add new settings to the `REST_FRAMEWORK`
    dictionary:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的 `settings.py` 文件中，向 `REST_FRAMEWORK` 字典添加新的设置：
- en: CoreRoot/settings.py
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: CoreRoot/settings.py
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Basically here, all results are limited to 15 per page but we can also increase
    this size with the `limit` parameter when making a request and also use the `offset`
    parameter to precisely where we want the result to start from:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上在这里，所有结果每页限制为 15 个，但我们在请求时也可以通过 `limit` 参数增加这个大小，并使用 `offset` 参数精确到我们想要结果开始的精确位置：
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Great, now make a `GET` request again and you’ll see that the results are better
    structured.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，现在再次进行 `GET` 请求，你会看到结果结构更清晰。
- en: Also, it’ll be more practical to have the name of the author in the response
    as well. Let’s rewrite a serializer method that can help modify the response object.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在响应中包含作者的名字也会更实用。让我们重写一个序列化方法，以帮助修改响应对象。
- en: Rewriting the Post serialized object
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重写帖子序列化对象
- en: Actually, the `author` field accepts `public_id` and returns `public_id`. While
    it does the work, it can be a little bit difficult to identify the user. This
    will cause it to make a request again with `public_id` of the user to get the
    pieces of information about the user.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`author` 字段接受 `public_id` 并返回 `public_id`。虽然它完成了工作，但可能有点难以识别用户。这会导致它再次使用用户的
    `public_id` 发起请求，以获取关于用户的信息片段。
- en: The `to_representation()` method takes the object instance that requires serialization
    and returns a primitive representation. This usually means returning a structure
    of built-in Python data types. The exact types that can be handled depend on the
    render classes you configure for your API.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`to_representation()` 方法接受需要序列化的对象实例，并返回一个原始表示。这通常意味着返回一个内置 Python 数据类型的结构。可以处理的确切类型取决于你为
    API 配置的渲染类。'
- en: 'Inside `post/serializers.py`, add a new method called `to_represenation()`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `post/serializers.py` 内，添加一个名为 `to_represenation()` 的新方法：
- en: core/post/serializers.py
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: core/post/serializers.py
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see, we are using the `public_id` field to retrieve the user and
    then serialize the `User` object with `UserSerializer`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们正在使用 `public_id` 字段来检索用户，然后使用 `UserSerializer` 序列化 `User` 对象。
- en: 'Let’s get all the posts again and you’ll see all the users:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次获取所有帖子，你会看到所有用户：
- en: '![Figure 3.8 – Getting all posts](img/Figure_3.8_B18221.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8 – 获取所有帖子](img/Figure_3.8_B18221.jpg)'
- en: Figure 3.8 – Getting all posts
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 获取所有帖子
- en: We have a working `Post` feature but it also has some issues. Let’s explore
    this further when writing permissions for our feature.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个工作的 `Post` 功能，但它也有一些问题。当为我们的功能编写写入权限时，让我们进一步探讨这个问题。
- en: Adding permissions
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加权限
- en: If authentication is the action of verifying the identity of a user, authorization
    is simply the action of checking whether the user has the rights or privileges
    to perform an action.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果认证是验证用户身份的行为，那么授权就是简单地检查用户是否有执行该行为的权利或特权。
- en: 'In our project, we have three types of users:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，我们有三种类型的用户：
- en: '**The anonymous user**: This user has no account on the API and can’t really
    be identified'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**匿名用户**：此用户在 API 上没有账户，实际上无法被识别'
- en: '**The registered and active user**: This user has an account on the API and
    can easily perform some actions'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注册和活跃用户**：此用户在 API 上有账户，可以轻松执行一些操作'
- en: '**The admin user**: This user has all rights and privileges'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理员用户**：此用户拥有所有权利和特权'
- en: We want anonymous users to be able to read the posts on the API without necessarily
    being authenticated. While it’s true that there is the `AllowAny` permission,
    it’ll surely conflict with the `IsAuthenticated` permission.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望匿名用户能够在不必要认证的情况下读取 API 上的帖子。虽然确实存在 `AllowAny` 权限，但它肯定会与 `IsAuthenticated`
    权限冲突。
- en: Thus, we need to write a custom permission.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要编写一个自定义权限。
- en: 'Inside the `authentication` directory, create a file called `permissions`,
    and add the following content:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `authentication` 目录内，创建一个名为 `permissions` 的文件，并添加以下内容：
- en: core/post/viewsets.py
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: core/post/viewsets.py
- en: '[PRE36]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Django permissions usually work on two levels: on the overall endpoint (`has_permission`)
    and on an object level (`has_object_permission`).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Django权限通常在两个级别上工作：在整体端点（`has_permission`）和对象级别（`has_object_permission`）。
- en: A great way to write permissions is to always deny by default; that is why we
    always return `False` at the end of each permission method. And then you can start
    adding the conditions. Here, in all the methods, we are checking that anonymous
    users can only make the `SAFE_METHODS` requests — `GET`, `OPTIONS`, and `HEAD`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 编写权限的一个好方法是一直默认拒绝；这就是为什么我们总是在每个权限方法结束时返回`False`。然后你可以开始添加条件。在这里，在所有方法中，我们都在检查匿名用户只能进行`SAFE_METHODS`请求——`GET`、`OPTIONS`和`HEAD`。
- en: And for other users, we are making sure that they are always authenticated before
    continuing. Another important feature is to allow users to delete or update posts.
    Let’s see how we can add this with Django.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他用户，我们确保他们在继续之前总是经过认证。另一个重要功能是允许用户删除或更新帖子。让我们看看我们如何使用Django来实现这一点。
- en: Deleting and updating posts
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除和更新帖子
- en: Deleting and updating articles are also part of the features of posts. To add
    these functionalities, we don’t need to write a serializer or a viewset, as the
    methods for deletion (`destroy()`), and updating (`update()`) are already available
    by default in the `ViewSet` class. We will just rewrite the `update` method on
    `PostSerializer` to ensure that the `edited` field is set to `True` when modifying
    a post.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 删除和更新文章也是帖子功能的一部分。为了添加这些功能，我们不需要编写序列化器或视图集，因为删除（`destroy()`）和更新（`update()`）的方法默认已经在`ViewSet`类中可用。我们只需重写`PostSerializer`上的`update`方法，以确保在修改帖子时将`edited`字段设置为`True`。
- en: 'Let’s add the `PUT` and `DELETE` methods to `http_methods` of `PostViewSet`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`PostViewSet`的`http_methods`中添加`PUT`和`DELETE`方法：
- en: core/post/viewsets.py
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: core/post/viewsets.py
- en: '[PRE37]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Before going in, let’s rewrite the `update` method in `PostSerializer`. We
    actually have a field called `edited` in the `Post` model. This field will tell
    us whether the post has been edited:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入之前，让我们重写`PostSerializer`中的`update`方法。实际上，我们在`Post`模型中有一个名为`edited`的字段。这个字段将告诉我们帖子是否被编辑过：
- en: core/post/serializers.py
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: core/post/serializers.py
- en: '[PRE38]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And let’s try the `PUT` and `DELETE` requests in Insomnia. Here’s an example
    of the body for the `PUT` request:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Insomnia中尝试`PUT`和`DELETE`请求。以下是`PUT`请求的示例正文：
- en: '[PRE39]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '![Figure 3.9 – Modifying a post](img/Figure_3.9_B18221.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图3.9 – 修改帖子](img/Figure_3.9_B18221.jpg)'
- en: Figure 3.9 – Modifying a post
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 – 修改帖子
- en: As you can see, the `edited` field in the response is set to `true`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，响应中的`edited`字段被设置为`true`。
- en: 'Let’s try to delete the post and see whether it works:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试删除帖子，看看它是否工作：
- en: '![Figure 3.10 – Deleting a post](img/Figure_3.10_B18221.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图3.10 – 删除帖子](img/Figure_3.10_B18221.jpg)'
- en: Figure 3.10 – Deleting a post
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 – 删除帖子
- en: Important note
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: There is a way to delete records without necessarily deleting them from the
    database. It’s usually called a soft delete. The record just won’t be accessible
    to the user, but it will always be present in the database. You can learn more
    about this at [https://dev.to/bikramjeetsingh/soft-deletes-in-django-a9j](https://dev.to/bikramjeetsingh/soft-deletes-in-django-a9j).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种方法可以在不必要从数据库中删除记录的情况下删除记录。这通常被称为软删除。记录将无法被用户访问，但它将始终存在于数据库中。您可以在[https://dev.to/bikramjeetsingh/soft-deletes-in-django-a9j](https://dev.to/bikramjeetsingh/soft-deletes-in-django-a9j)了解更多相关信息。
- en: Adding the Like feature
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加点赞功能
- en: A nice feature to have in a social media application is favoriting. Like Facebook,
    Instagram, or Twitter, we’ll allow users here to like a post.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在社交媒体应用中拥有一个不错的功能就是点赞。就像Facebook、Instagram或Twitter一样，我们在这里将允许用户点赞帖子。
- en: Plus, we’ll also add data to count the number of likes a post has received and
    check whether a current user making the request has liked a post.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将添加数据来统计帖子的点赞数，并检查当前发起请求的用户是否点赞了帖子。
- en: 'We’ll do this in four steps:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分四个步骤来完成这项工作：
- en: Add a new `posts_liked` field to the `User` model.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`User`模型添加新的`posts_liked`字段。
- en: Write methods on the `User` model to like and remove a like from a post. We’ll
    also add a method to check whether the user has liked a post.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`User`模型上编写点赞和取消点赞帖子的方法。我们还将添加一个方法来检查用户是否点赞了帖子。
- en: Add `likes_count` and `has_liked` to `PostSerializer`.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`likes_count`和`has_liked`添加到`PostSerializer`。
- en: Add endpoints to like and dislike a post.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加点赞和踩帖子的端点。
- en: Great! Let’s start by adding the new fields to the `User` model.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！让我们先向`User`模型添加新的字段。
- en: Adding the posts_liked field to the User model
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向User模型添加posts_liked字段
- en: 'The `posts_liked` field will contain all the posts liked by a user. The relationship
    between the `User` model and the `Post` model concerning the Like feature can
    be described as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`posts_liked` 字段将包含用户喜欢的所有帖子。关于点赞功能的 `User` 模型和 `Post` 模型之间的关系可以描述如下：'
- en: A user can like many posts
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用户可以点赞多个帖子
- en: A post can be liked by many users
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个帖子可以被多个用户点赞
- en: This kind of relationship sounds familiar? It is a *many-to-many* relationship.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关系听起来熟悉吗？这是一个 *多对多* 关系。
- en: 'Following this change, here’s the updated structure of the table – we are also
    anticipating the methods we’ll add to the model:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这个更改，以下是表的更新结构 – 我们也在预测我们将添加到模型中的方法：
- en: '![Figure 3.11 – New User table structure](img/Figure_3.11_B18221.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.11 – 新用户表结构](img/Figure_3.11_B18221.jpg)'
- en: Figure 3.11 – New User table structure
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 – 新用户表结构
- en: 'Great! Let’s add the `posts_liked` field to the `User` model. Open the `/core/user/models.py`
    file and add a new field to the `User` model:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！让我们将 `posts_liked` 字段添加到 `User` 模型中。打开 `/core/user/models.py` 文件，并在 `User`
    模型中添加一个新字段：
- en: '[PRE40]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'After that, run the following commands to create a new migrations file and
    apply this migration to the database:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行以下命令以创建一个新的迁移文件并将此迁移应用到数据库中：
- en: '[PRE41]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The next step is to add the new methods shown in *Figure 3**.11* to the `User`
    model.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将图 3.11 中显示的新方法添加到 `User` 模型中。
- en: Adding the like, remove_like, and has_liked methods
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加点赞、取消点赞和 has_liked 方法
- en: 'Before writing these methods, let’s describe the purpose of each new method:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写这些方法之前，让我们描述一下每个新方法的目的：
- en: 'The `like()` method: This is used for liking a post if it hasn’t been done
    yet. For this, we’ll use the `add()` method from the models. We’ll use `ManyToManyField`
    to link a post to a user.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`like()` 方法：这个方法用于在尚未点赞的情况下点赞帖子。为此，我们将使用模型中的 `add()` 方法。我们将使用 `ManyToManyField`
    来将帖子链接到用户。'
- en: 'The `remove_like()` method: This is used for removing a like from a post. For
    this, we’ll use the `remove` method from the models. We’ll use `ManyToManyField`
    to unlink a post from a user.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove_like()` 方法：这个方法用于从帖子中移除点赞。为此，我们将使用模型中的 `remove` 方法。我们将使用 `ManyToManyField`
    来解除帖子与用户的链接。'
- en: 'The `has_liked()` method: This is used for returning `True` if the user has
    liked a post, else `False`.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`has_liked()` 方法：这个方法用于返回用户是否喜欢了一个帖子，如果是则返回 `True`，否则返回 `False`。'
- en: 'Let’s move on to the coding:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续编写代码：
- en: '[PRE42]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Great! Next, let’s add the `likes_count` and `has_liked` fields to `PostSerializer`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！接下来，让我们将 `likes_count` 和 `has_liked` 字段添加到 `PostSerializer`。
- en: Adding the likes_count and has_liked fields to PostSerializer
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 likes_count 和 has_liked 字段添加到 PostSerializer
- en: Instead of adding fields such as `likes_count` in the `Post` model and generating
    more fields in the database, we can directly manage it on `PostSerializer`. The
    `Serializer` class in Django provides ways to create the `write_only` values that
    will be sent on the response.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在 `Post` 模型中添加如 `likes_count` 这样的字段并在数据库中生成更多字段，我们可以在 `PostSerializer` 上直接管理它。Django
    中的 `Serializer` 类提供了创建将在响应中发送的 `write_only` 值的方法。
- en: 'Inside the `core/post/serializers.py` file, add new fields to `PostSerializer`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `core/post/serializers.py` 文件中，向 `PostSerializer` 添加新字段：
- en: Core/post/serializers.py
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Core/post/serializers.py
- en: '[PRE43]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the preceding code, we are using the `serializers.SerializerMethodField()`
    field, which allows us to write a custom function that will return a value we
    want to attribute to this field. The syntax of the method will be `get_field`,
    where `field` is the name of the field declared on the serializer.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了 `serializers.SerializerMethodField()` 字段，它允许我们编写一个自定义函数，该函数将返回我们想要分配给此字段的价值。方法的语法将是
    `get_field`，其中 `field` 是在序列化器上声明的字段的名称。
- en: That is why for `liked`, we have the `get_liked` method, and for `likes_count`,
    we have the `get_likes_count` method.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于 `liked`，我们有 `get_liked` 方法，对于 `likes_count`，我们有 `get_likes_count` 方法。
- en: With the new fields on `PostSerializer`, we can now add the endpoints needed
    to `PostViewSet` to like or dislike an article.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `PostSerializer` 上的新字段允许我们添加到 `PostViewSet` 的端点，以点赞或踩踏文章。
- en: Adding like and dislike actions to PostViewSet
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将点赞和踩踏操作添加到 PostViewSet
- en: 'DRF provides a decorator called `action`. This decorator helps make methods
    on a `ViewSet` class routable. The `action` decorator takes two arguments:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: DRF 提供了一个名为 `action` 的装饰器。这个装饰器有助于使 `ViewSet` 类上的方法可路由。`action` 装饰器接受两个参数：
- en: '`detail`: If this argument is set to `True`, the route to this action will
    require a resource lookup field; in most cases, this will be the ID of the resource'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`detail`：如果此参数设置为 `True`，则此操作的路径将需要一个资源查找字段；在大多数情况下，这将是指资源的 ID'
- en: '`methods`: This is a list of the methods accepted by the action'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`methods`：这是动作接受的方方法的列表'
- en: 'Let’s write the actions on `PostViewSets`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`PostViewSets`上编写动作：
- en: core/post/viewsets.py
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: core/post/viewsets.py
- en: '[PRE44]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'For each action added, we are writing the logic following these steps:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个添加的动作，我们按照以下步骤编写逻辑：
- en: First, we retrieve the concerned post on which we want to call the like or remove
    the like action. The `self.get_object()` method will automatically return the
    concerned post using the ID passed to the URL request, thanks to the `detail`
    attribute being set to `True`.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们检索我们想要调用点赞或取消点赞动作的相关帖子。`self.get_object()`方法将自动返回相关的帖子，这是通过将`detail`属性设置为`True`，并使用传递给URL请求的ID来实现的。
- en: Second, we also retrieve the user making the request from the `self.request`
    object. This is done so that we can call the `remove_like` or `like` method added
    to the `User` model.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，我们还从`self.request`对象中检索发起请求的用户。这样做是为了我们可以调用添加到`User`模型中的`remove_like`或`like`方法。
- en: And finally, we serialize the post using the `Serializer` class defined on `self.serializer_class`
    and we return a response.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用在`self.serializer_class`上定义的`Serializer`类序列化帖子，并返回一个响应。
- en: 'With this added to `PostViewSets`, the Django Rest Framework routers will automatically
    create new routes for this resource, and then, you can do the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 将此添加到`PostViewSets`后，Django Rest Framework路由器将自动为该资源创建新的路由，然后，你可以做以下操作：
- en: 'Like a post with the following endpoint: `api/post/post_pk/like/`.'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下端点点赞帖子：`api/post/post_pk/like/`。
- en: 'Remove the like from a post with the following endpoint: `api/post/post_pk/remove_like/`.'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下端点移除帖子的点赞：`api/post/post_pk/remove_like/`。
- en: Great, the feature is working like a charm. In the next chapter, we’ll be adding
    the *comments* feature to the project.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，这个功能运行得像魔法一样。在下一章，我们将向项目中添加*注释*功能。
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we’ve learned how to use database relationships and write permissions.
    We also learned how to surcharge updates and create methods on viewsets and serializers.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用数据库关系和编写权限。我们还学习了如何在视集合和序列化器上覆盖更新和创建方法。
- en: We performed quick refactoring on our code by creating an `Abstract` class to
    follow the *DRY* rule. In the next chapter, we’ll be adding the Comments feature
    on the posts. Users will be able to create comments under posts as well as delete
    and update them.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建一个`Abstract`类来遵循*DRY*规则，对代码进行了快速重构。在下一章，我们将添加注释功能到帖子中。用户将能够在帖子下创建评论，以及删除和更新它们。
- en: Questions
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are some database relationships?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些数据库关系有哪些？
- en: What are Django permissions?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Django权限有哪些？
- en: How do you paginate the results of an API response?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何分页API响应的结果？
- en: How do you use Django shell?
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使用Django shell？
