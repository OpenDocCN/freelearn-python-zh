- en: Chapter 6. Hublot – Flask CLI Tools
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。Hublot - Flask CLI工具
- en: Often when administering a web application, there are tasks that we like to
    accomplish without having to create an entire administrative web interface; even
    though this may be accomplished relatively easily with tools such as Flask-Admin.
    Many developers first turn to a shell scripting language. Bash is near universal
    on most modern Linux operating systems, favored by system administrators, and
    is powerful enough to script any administrative task that may be required.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在管理Web应用程序时，通常有一些任务是我们希望完成的，而不必创建整个管理Web界面；即使这可能相对容易地通过诸如Flask-Admin之类的工具来实现。许多开发人员首先转向shell脚本语言。Bash几乎在大多数现代Linux操作系统上都是通用的，受到系统管理员的青睐，并且足够强大，可以脚本化可能需要的任何管理任务。
- en: While the venerable Bash script is most definitely always an option, it would
    be nice to write a Python-based script that could utilize some of the application-specific
    data handling that we have crafted for our web application. In doing so, we can
    avoid duplicating a fair amount of energy and effort that was put in the painstaking
    process of creating, testing, and deploying the data models and domain logic that
    is the core of any web application. This is where Flask-Script comes in.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可敬的Bash脚本绝对是一个选择，但编写一个基于Python的脚本会很好，它可以利用我们为Web应用程序精心制作的一些应用程序特定的数据处理。这样做，我们可以避免重复大量精力和努力，这些精力和努力是在创建、测试和部署数据模型和领域逻辑的痛苦过程中投入的，这是任何Web应用程序的核心。这就是Flask-Script的用武之地。
- en: Note
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing this, Flask has not yet shipped the 1.0 release, which
    includes an integrated CLI script handling via the `Click` library developed by
    the author of Flask. As the API of the Flask/Click integration may change significantly
    between now and the release of Flask 1.0, we've chosen to implement the CLI tools
    discussed in this chapter via the Flask-Script package, which has been the de
    facto solution for Flask for quite some time now. The creation of administrative
    tasks via the Click API can, however, be considered for any new Flask application—the
    fundamental principles are similar enough even though the implementations differ
    greatly.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Flask尚未发布1.0版本，其中包括通过Flask作者开发的`Click`库进行集成的CLI脚本处理。由于Flask/Click集成的API在现在和Flask
    1.0发布之间可能会发生重大变化，因此我们选择通过Flask-Script包来实现本章讨论的CLI工具，这已经是Flask的事实标准解决方案相当长的时间了。但是，通过Click
    API创建管理任务可以考虑用于任何新的Flask应用程序-尽管实现方式有很大不同，但基本原则是足够相似的。
- en: 'In addition to the infrequent tasks that we may require of a shell script,
    such as exporting computed data, sending e-mails to a subset of users, and so
    on, there are certain tasks from our previous applications that may be ported
    over to the Flask-Script CLI commands:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们可能需要一个shell脚本执行的不经常的任务，例如导出计算数据，向一部分用户发送电子邮件等，还有一些来自我们以前应用程序的任务可以移植到Flask-Script
    CLI命令中：
- en: Creating/deleting our current database schema, thus replacing our `database.py`
    from previous projects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建/删除我们当前的数据库模式，从而替换我们以前项目中的`database.py`
- en: Running our Werkzeug development server, replacing `run.py` from previous projects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行我们的Werkzeug开发服务器，替换以前项目中的`run.py`
- en: Additionally, as Flask-Script is the current de facto solution to write reusable
    CLI scripts for Flask applications, many other extensions publish CLI commands
    that can be integrated in your existing application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于Flask-Script是为Flask应用程序编写可重用CLI脚本的当前事实标准解决方案，许多其他扩展发布CLI命令，可以集成到您的现有应用程序中。
- en: In this chapter, we will be creating an application that stores the data pulled
    from the `Github` API in a local database.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个应用程序，将从`Github` API中提取的数据存储在本地数据库中。
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Git is a **distributed version control system** (**DVCS**) that has become incredibly
    popular in the last few years and with good reason. It has quickly become the
    go-to version control system for an incredible amount of open source projects
    written in a variety of languages.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Git是一种**分布式版本控制系统**（**DVCS**），在过去几年中变得非常流行，而且理由充分。它已经迅速成为了大量使用各种语言编写的开源项目的首选版本控制系统。
- en: GitHub, the most well-known hosting platform for Git repositories of open and
    close source code, is also endowed with a wonderfully complete API that allows
    for a programmatic access to the data and metadata (comments, pull requests, issues,
    and so on) that is available, depending on the authenticated credentials provided.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub是Git开源和闭源代码存储库的最知名的托管平台，还配备了一个非常完整的API，允许根据提供的经过身份验证的凭据，以编程方式访问可用的数据和元数据（评论、拉取请求、问题等）。
- en: To fetch this data, we will create a simple Flask extension to encapsulate the
    REST-based API queries in order to fetch the relevant data, and we will then use
    this extension to create a CLI tool (via Flask-Script) that can be manually run
    or hooked up to a event-based or time-based scheduler, such as cron.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取这些数据，我们将创建一个简单的Flask扩展来封装基于REST的API查询，以获取相关数据，然后我们将使用这个扩展来创建一个CLI工具（通过Flask-Script），可以手动运行或连接到基于事件或时间的调度程序，例如cron。
- en: Before we get into any of this, however, let's set up a very simple application
    skeleton so that we can begin the Flask-Script integration.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们进行任何操作之前，让我们建立一个非常简单的应用程序框架，以便我们可以开始Flask-Script集成。
- en: Starting off
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始
- en: 'We once again reach for our basic Blueprint-based application structure and
    create a whole new virtual environment and directory for this new venture:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用基本的基于Blueprint的应用程序结构，并为这个新的冒险创建一个全新的虚拟环境和目录：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The application layout that we''ll start off with is very similar to what we
    used in previous Blueprint-based projects, with the main difference being the
    `manage.py` script, which will be the main entry point for our Flask-Script CLI
    commands. Also note the lack of `run.py` and a `database.py`, which we alluded
    to previously and will explain in more detail shortly:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始使用的应用程序布局与我们在以前基于Blueprint的项目中使用的非常相似，主要区别在于“manage.py”脚本，它将是我们的Flask-Script
    CLI命令的主要入口点。还要注意缺少“run.py”和“database.py”，这是我们之前提到的，并且很快会详细解释的。
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In keeping with our previous work, we continue to use the `Application Factory`
    pattern to allow the instantiation of our application to happen at runtime instead
    of at module import time, as we shall do with the Flask-SQLAlchemy extension that
    we have become quite familiar with.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的工作保持一致，我们继续使用“应用工厂”模式，允许我们在运行时实例化我们的应用，而不是在模块导入时进行，就像我们将要使用的Flask-SQLAlchemy扩展一样。
- en: 'Our `application/__init__.py` file contains the following, which you should
    recognize quite well:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的“application/__init__.py”文件包含以下内容，您应该会非常熟悉：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Our `application/settings.py` file contains the very basics that we require
    for a Flask-SQLAlchemy application:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的“application/settings.py”文件包含了我们对于Flask-SQLAlchemy应用程序所需的基本内容：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will be using SQLite as our database of choice for this particular project;
    adjust the URI accordingly in case you decide to use a different database.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定项目，我们将使用SQLite作为我们的首选数据库；如果您决定使用不同的数据库，请相应调整URI。
- en: 'For the sake of expediency, we''ll introduce simplified `Repository` and `Issue`
    models that will contain the data we want to collect. These models will exist
    in `application/repositories/models.py`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简便起见，我们将引入简化的“Repository”和“Issue”模型，这些模型将包含我们想要收集的数据。这些模型将存在于“application/repositories/models.py”中：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A `Repository` model instance will contain metadata that pertains to a given
    Git repository hosted on GitHub with a one-to-many relationship to the `Issue`
    model, which we will define next. The fields that we have declared in this `Repository`
    class should be self-explanatory for the most part, the one exception being `__table__args__
    dunder`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: “Repository”模型实例将包含与“Issue”模型的一对多关系相关的给定Git存储库的元数据，我们将在下面定义。我们在这个“Repository”类中声明的字段在大部分情况下应该是不言自明的，唯一的例外是“__table__args__
    dunder”。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A **dunder** is a Python-specific neologism that is used to refer to any variable
    or method that begins with two underscores: a *double underscore* or *dunder*,
    for short. There are several built-in dunder methods (for example, `__init__`)
    and attributes (for example, `__name__`), and any attributes / methods / functions
    that you declare and prefix with two underscores will fall under this category
    as well.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**dunder**是一个Python特有的新词，用于指代以两个下划线开头的任何变量或方法：*双下划线*或*dunder*。有几个内置的dunder方法（例如，“__init__”）和属性（例如，“__name__”），任何您声明并以两个下划线前缀的属性/方法/函数也将属于这个类别。'
- en: This class attribute allows us the ability to specify a table-specific configuration
    to the underlying SQLAlchemy table that is created. In our case, we will use it
    to specify a UniqueConstraint key on a compound value, the combination of the
    name and owner, which would otherwise not be possible via the typical attribute-based
    field definitions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类属性允许我们能够为创建的底层SQLAlchemy表指定特定于表的配置。在我们的情况下，我们将用它来指定一个UniqueConstraint键，这个键是由名称和所有者的组合值组成的，否则通过典型的基于属性的字段定义是不可能的。
- en: Additionally, we defined an issues attribute whose value is a relationship to
    the `Issue` model; this is the classic one-to-many relationship, and accessing
    the issues attribute of a repository instance will yield the list of issues that
    are attached to the repository in question.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们定义了一个issues属性，其值是与“Issue”模型的关系；这是经典的一对多关系，访问存储库实例的issues属性将产生与相关存储库关联的问题列表。
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the specified relationship does not include any arguments pertaining
    to the nature of the query or loading behavior of the related data. We are using
    the default behavior for this application, which is not a good idea for the repositories
    that contain a significant amount of issues—a dynamic lazyload approach as was
    used in a previous chapter may be a better choice in such a situation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，指定的关系不包括与查询性质或相关数据加载行为有关的任何参数。我们正在使用此应用程序的默认行为，这对于包含大量问题的存储库来说并不是一个好主意——在这种情况下，可能会更好地选择先前章节中使用的动态延迟加载方法。
- en: 'The `Issue` model, which we alluded to in the `Repository` model that we defined,
    is designed to contain the GitHub issue metadata associated with a Git repository
    hosted here. As issues only make sense in the context of a repository, we ensure
    that the `repository_id` foreign key exists for all the issues:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在“Repository”模型中提到的“Issue”模型旨在包含与此处托管的Git存储库相关联的GitHub问题元数据。由于问题只在存储库的上下文中有意义，我们确保“repository_id”外键存在于所有问题中：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Each instance of an `Issue` model will encapsulate a very limited set of information
    regarding a GitHub issue that was created, including the issue number, state of
    the issue (*closed* or *open*), and title that was given to the issue.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 每个“Issue”模型的实例将封装关于创建的GitHub问题的非常有限的信息，包括问题编号、问题的状态（*关闭*或*打开*）以及问题的标题。
- en: At this point in previous chapters, we would have created a `database.py` script
    to initialize the construction of our SQLAlchemy models in our database. In this
    chapter, however, we will use Flask-Script to write a small CLI command that will
    do the same thing but provide us with a more consistent framework to write these
    little administrative tools and avoid the dozens of independent script files that
    end up plaguing any nontrivial application over time.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的章节中，我们会创建一个`database.py`脚本来初始化在数据库中构建我们的SQLAlchemy模型。然而，在本章中，我们将使用Flask-Script来编写一个小的CLI命令，它将做同样的事情，但为我们提供一个更一致的框架来编写这些小的管理工具，并避免随着时间的推移而困扰任何非平凡应用的独立脚本文件的问题。
- en: The manage.py file
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: manage.py文件
- en: By convention, the main entry point for Flask-Script is a Python file named
    `manage.py` that we place sibling to the `application/` package as we described
    in our project layout in the beginning of this chapter. While Flask-Script contains
    quite a few options—configurations and customizability—we'll use the simplest
    of the available invocations to encapsulate the functionality of the `database.py`
    Python script that we used in previous chapters in order to handle the initialization
    of our database.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，Flask-Script的主要入口点是一个名为`manage.py`的Python文件，我们将其放在`application/`包的同级目录中，就像我们在本章开头描述的项目布局一样。虽然Flask-Script包含了相当多的选项-配置和可定制性-我们将使用最简单的可用调用来封装我们在以前章节中使用的`database.py`
    Python脚本的功能，以处理我们数据库的初始化。
- en: 'We instantiate a `Manager` instance, which will handle the registration of
    our various commands. The `Manager` constructor takes a Flask application instance
    as an argument, but it can also (thankfully!) accept a function or class that
    implements the callable interface that returns an application instance:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实例化了一个`Manager`实例，它将处理我们各种命令的注册。`Manager`构造函数接受一个Flask应用实例作为参数，但它也（幸运地！）可以接受一个实现可调用接口并返回应用实例的函数或类：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that we have a `manager` instance, we use the `command` method of this
    instance to decorate functions that we would like to turn into CLI commands:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个`manager`实例，我们可以使用这个实例的`command`方法来装饰我们想要转换为CLI命令的函数：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that, by default, the function name that we wrap with the `command` method
    will be the identifier used in the CLI invocation.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，默认情况下，我们用`command`方法包装的函数名称将是CLI调用中使用的标识符。
- en: 'To get the whole thing running, we call the `run` method of the manager instance
    when we invoke the `manage.py` file directly:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使整个过程运行起来，当我们直接调用`manage.py`文件时，我们调用管理器实例的`run`方法：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'At this point, we can execute our CLI command via the Python interpreter:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们可以通过Python解释器执行我们的CLI命令：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Assuming everything worked as expected, we should see no results (or errors,
    for that matter) and our database should be initialized with the tables, columns,
    and indexes that we specified in our model definitions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一切都按预期工作，我们应该看不到任何结果（或错误），并且我们的数据库应该被初始化为我们在模型定义中指定的表、列和索引。
- en: 'Let''s create a diametrically opposite command that will allow us to destroy
    our local database; this can sometimes be handy when making a lot of changes to
    our data model during development:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个截然相反的命令，允许我们销毁本地数据库；在开发过程中对数据模型进行大量更改时，这有时会很方便：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We invoke this newly created `drop_db` command in exactly the same manner as
    we invoked the previously defined `init_db` command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以与之前定义的`init_db`命令相同的方式调用这个新创建的`drop_db`命令：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The built-in default commands
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内置默认命令
- en: 'In addition to giving us the ability to quickly define our own CLI commands,
    Flask-Script includes a few defaults so that we don''t have write them ourselves:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 除了让我们能够快速定义自己的CLI命令之外，Flask-Script还包括一些默认值，这样我们就不必自己编写它们：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Flask-Script automatically generates a help text for the registered commands
    based on `docstrings` of the relevant functions. Additionally, running the `manage.py`
    script without a specified command or with the `help` option will display the
    full list of the top-level commands available.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Flask-Script会根据相关函数的`docstrings`自动生成已注册命令的帮助文本。此外，运行`manage.py`脚本而没有指定命令或使用`help`选项将显示可用顶级命令的完整列表。
- en: 'If, for whatever reason, we''d like to customize the defaults, it''s relatively
    easy to accomplish. For example, we need the development server to run on port
    6000 instead of the 5000 default:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出于任何原因，我们想要自定义默认设置，这是相对容易实现的。例如，我们需要开发服务器在6000端口上运行，而不是默认的5000端口：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we've used the alternative method of defining a CLI command using the
    `manager.add_command` method, which takes a name and subclass of `flask.ext.script.command`
    as the second argument.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了定义CLI命令的另一种方法，即使用`manager.add_command`方法，它将一个名称和`flask.ext.script.command`的子类作为第二个参数。
- en: 'Similarly, we can override the default shell command so that our interactive
    Python shell contains a reference to our configured Flask-SQLAlchemy database
    object in addition to the Flask app object:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我们可以覆盖默认的shell命令，以便我们的交互式Python shell包含对我们配置的Flask-SQLAlchemy数据库对象的引用，以及Flask应用对象：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can verify that our `db` object has been included by executing the `manage.py`
    script to invoke the interactive shell:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行`manage.py`脚本来验证我们的`db`对象是否已经被包含，以调用交互式shell。
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Verify that the default Flask application server runs on the port that we specified:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 验证默认的Flask应用服务器是否在我们指定的端口上运行：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Flask-Script provides several configuration options for the default `runserver`
    and `shell` commands, including the ability to disable them completely if you
    want. You can consult the online documentation for additional details.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Flask-Script为默认的`runserver`和`shell`命令提供了几个配置选项，包括禁用它们的能力。您可以查阅在线文档以获取更多详细信息。
- en: The Flask-Script commands across Blueprints
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Blueprints中的Flask-Script命令
- en: 'The ability to create ad hoc CLI commands in our application-level `manage.py`
    is both a blessing and curse: A blessing because it requires very little boilerplate
    to get up and running and a curse because it can very easily spiral into an unmanageable
    mess of code.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们应用程序级别的“manage.py”中创建临时CLI命令的能力既是一种祝福又是一种诅咒：祝福是因为它需要非常少的样板代码就可以运行起来，诅咒是因为它很容易变成一堆难以管理的代码混乱。
- en: To stave off this somewhat inevitable end state for any nontrivial application,
    we will use the underutilized feature of submanagers in Flask-Script in order
    to create a set of CLI commands that will live inside a blueprint but will be
    accessible via the standard `manage.py` invocation. This should allow us to keep
    the domain logic for our command-line interfaces in the same location(s) as the
    domain logic for our web-based components.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免任何非平凡应用程序的不可避免的最终状态，我们将使用Flask-Script中子管理器的未充分利用的功能，以创建一组CLI命令，这些命令将存在于蓝图中，但可以通过标准的“manage.py”调用访问。这应该使我们能够将命令行界面的领域逻辑保存在与我们基于Web的组件的领域逻辑相同的位置。
- en: Submanagers
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子管理器
- en: 'Our first Flask-Script submanager will contain the logic to parse a GitHub
    project URL to the component pieces that we require to create a valid `Repository`
    model record:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个Flask-Script子管理器将包含解析GitHub项目URL的逻辑，以获取我们需要创建有效的“Repository”模型记录的组件部分：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The general idea is that we'd like to be able to create a new `Repository` object
    with the name, owner, and description parsed from the positional and named arguments
    provided to the "add" function of the "repositories" submanager.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 总体思路是，我们希望能够使用从“repositories”子管理器的“add”函数提供的位置和命名参数解析出名称、所有者和描述，从而创建一个新的“Repository”对象。
- en: 'Let''s get started by creating the module that will contain our repository
    CLI commands in `application/repositories/cli.py` with an empty `add` function
    for the moment:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建一个模块，该模块将包含我们的存储库CLI命令，即`application/repositories/cli.py`，目前为空的“add”函数：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Note that our `repository_manager` instance was created without an application
    instance or a callable that will return an application instance. Instead of providing
    the application object here, we will register our newly created submanager instance
    with our main application manager:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的“repository_manager”实例是在没有应用程序实例或可返回应用程序实例的可调用对象的情况下创建的。我们将新创建的子管理器实例注册到我们的主应用程序管理器中，而不是在此处提供应用程序对象。
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This will let us invoke the `repositories` manager and show us the available
    subcommands:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们能够调用“repositories”管理器并显示可用的子命令：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'While this will produce no results (due to the function body being a simple
    pass statement), we can invoke our `add` subcommand:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这将不会产生任何结果（因为函数体是一个简单的pass语句），但我们可以调用我们的“add”子命令：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The required and optional arguments
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 所需和可选参数
- en: Any command registered with a Flask-Script manager may have zero or many required
    arguments in addition to any number of optional arguments with arbitrary defaults.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flask-Script管理器中注册的任何命令都可以有零个或多个必需参数，以及任意默认值的可选参数。
- en: Our `add` command requires one mandatory argument, the URL of the repository
    to be added to our database, and one optional argument, a description of this
    repository. The command decorator takes care of a large number of the most basic
    cases, turning named function arguments to their CLI argument equivalents and
    function arguments with default values to optional CLI arguments.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的“add”命令需要一个强制参数，即要添加到我们数据库中的存储库的URL，以及一个可选参数，即此存储库的描述。命令装饰器处理了许多最基本的情况，将命名函数参数转换为它们的CLI参数等效项，并将具有默认值的函数参数转换为可选的CLI参数。
- en: 'This means that we can specify the following function declaration to match
    what we wrote down previously:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以指定以下函数声明来匹配我们之前写下的内容：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This allows us to capture the arguments provided to our CLI manager and have
    them readily available in our function body:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够捕获提供给我们的CLI管理器的参数，并在我们的函数体中轻松地使用它们：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As we''ve managed to properly encode the desired interface for the CLI tool,
    let''s add some parsing to extract out the relevant bits and pieces that we want
    from the URL:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '由于我们已经成功地编码了CLI工具的所需接口，让我们添加一些解析，以从URL中提取出我们想要的相关部分： '
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We follow the `*nix` convention of returning a non-zero value between 1 and
    127 (the convention is to return 2 for syntax errors and 1 for any other kind
    of error) when a script encounters an error condition. As we expect our script
    to successfully add a repository object to our database, any situation where this
    does not occur could be considered an error condition and should thus return a
    non-zero value.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遵循`*nix`约定，在脚本遇到错误条件时返回一个介于1和127之间的非零值（约定是对语法错误返回2，对其他任何类型的错误返回1）。由于我们期望我们的脚本能够成功地将存储库对象添加到我们的数据库中，任何情况下如果这种情况没有发生，都可以被视为错误条件，因此应返回一个非零值。
- en: 'Now that we capture and process the CLI arguments correctly, let''s use this
    data to create our `Repository` objects and persist them to our database:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正确捕获和处理CLI参数，让我们使用这些数据来创建我们的“Repository”对象，并将它们持久化到我们的数据库中：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we have taken care of the situation where a duplicate repository (that
    is, with the same name and from the same owner) is added to the database. Without
    capturing `IntegrityError`, the CLI command would fail and spit out a stack trace
    indicating the unhandled exception.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经处理了向数据库添加重复存储库（即具有相同名称和所有者的存储库）的情况。如果不捕获“IntegrityError”，CLI命令将失败并输出指示未处理异常的堆栈跟踪。
- en: 'Running our newly implemented CLI command now yields the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行我们新实现的CLI命令将产生以下结果：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The successful creation of our `Repository` object may be verified in our database.
    For SQLite, the following would suffice:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 成功创建我们的“Repository”对象可以在我们的数据库中进行验证。对于SQLite，以下内容就足够了：
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Flask extensions – the basics
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flask扩展 - 基础知识
- en: We spent a great deal of time installing, configuring, and using various Flask
    extensions (Flask-Login, Flask-WTF, Flask-Bcrypt, and others). They provide us
    with a consistent interface to configure third-party libraries and tools and often
    integrate some Flask-specific niceties that make application development just
    a bit more enjoyable. One thing that we have not touched upon, however, is how
    to build your own Flask extension.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们花了大量时间安装、配置和使用各种Flask扩展（Flask-Login、Flask-WTF、Flask-Bcrypt等）。它们为我们提供了一个一致的接口来配置第三方库和工具，并经常集成一些使应用程序开发更加愉快的Flask特定功能。然而，我们还没有涉及如何构建自己的Flask扩展。
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will only be looking at the framework necessary to create a valid Flask extension
    to be used locally in a project. If you desire to package your custom extension
    and publish it on PyPi or GitHub, you will need to implement the proper `setup.py`
    and setuptools machinery to make this possible. You can follow the setuptools
    documentation for further details.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只会查看创建有效的Flask扩展所需的框架，以便在项目中本地使用。如果您希望打包您的自定义扩展并在PyPi或GitHub上发布它，您将需要实现适当的`setup.py`和setuptools机制，以使这成为可能。您可以查看setuptools文档以获取更多详细信息。
- en: When should an extension be used?
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 何时应该使用扩展？
- en: 'A Flask extension usually falls under one of the following two categories:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Flask扩展通常属于以下两类之一：
- en: Encapsulating the functionality provided by a third-party library, ensuring
    that this third-party library will function correctly when multiple Flask applications
    exist in the same process, and possibly adding some convenient functions/objects
    that make the integration with Flask more concrete; for example, Flask-SQLAlchemy
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装第三方库提供的功能，确保当同一进程中存在多个Flask应用程序时，该第三方库将正常运行，并可能添加一些使与Flask集成更具体的便利函数/对象；例如，Flask-SQLAlchemy
- en: The codification of patterns and behaviors that do not require a third-party
    library but ensure a set of consistent functionalities for an application; for
    example, Flask-Login
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要第三方库的模式和行为的编码，但确保应用程序具有一组一致的功能；例如，Flask-Login
- en: The majority of the Flask extensions that you will encounter in the wild or
    develop yourself will fall under the first category. The second category is a
    bit of an outlier and often arises from common patterns observed in multiple applications
    that are then abstracted and refined to the point where they can be put in an
    extension.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在野外遇到或自己开发的大多数Flask扩展都属于第一类。第二类有点异常，并且通常是由在多个应用程序中观察到的常见模式抽象和精炼而来，以至于可以将其放入扩展中。
- en: Our extension – GitHubber
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们的扩展 - GitHubber
- en: The extension that we will build in this chapter will encapsulate a small portion
    of the `Github` API that will allow us to fetch the list of issues for a given
    repository that we previously tracked.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将构建的扩展将封装`Github` API的一个小部分，这将允许我们获取先前跟踪的给定存储库的问题列表。
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `Github` API allows for more functionalities than what we need it for and
    the documentation is excellent. Additionally, there exist several third-party
    Python libraries that encapsulate much of the `Github` API, of which we will be
    using one.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`Github` API允许的功能比我们需要的更多，文档也很好。此外，存在几个第三方Python库，封装了大部分`Github` API，我们将使用其中一个。'
- en: 'To simplify the interaction with GitHub''s v3 API, we''re going to install
    the `github3.py` Python package to our local virtual environment:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化与GitHub的v3 API的交互，我们将在本地虚拟环境中安装`github3.py` Python包：
- en: '[PRE28]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As we're developing the extension in our Hublot application, we're not going
    to introduce the additional complexity of a separate project for the custom Flask
    extension. If you intend, however, to release and/or distribute an extension,
    you'll want to ensure that it is structured in such a way that it can be made
    available via the Python Package Index and installable via setuptools (or distutils,
    if you'd rather only use packaging tools that are included in the standard library).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在在我们的Hublot应用程序中开发扩展，我们不打算引入自定义Flask扩展的单独项目的额外复杂性。然而，如果您打算发布和/或分发扩展，您将希望确保它以这样的方式结构化，以便可以通过Python包索引提供并通过setuptools（或distutils，如果您更愿意只使用标准库中包含的打包工具）进行安装。
- en: 'Let''s create an `extensions.py` module sibling to `application/repositories/
    package` and introduce the basic structure that any Flask extension should contain:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`extensions.py`模块，与`application/repositories/ package`同级，并引入任何Flask扩展都应包含的基本结构：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: For most extensions, this is all that is required. Note that the basic extension
    is a plain old Python object (colloquially referred to as a POPO) definition,
    augmented with an `init_app` instance method. This method is not strictly necessary.
    If you don't plan on having the extension use the Flask application object (for
    example, to load configuration values) or if you have no intention of using the
    application factory pattern, then `init_app` is superfluous and can be omitted.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数扩展，这就是所需的全部。请注意，基本扩展是一个普通的Python对象（俗称为POPO）定义，增加了一个`init_app`实例方法。这个方法并不是绝对必要的。如果您不打算让扩展使用Flask应用程序对象（例如加载配置值）或者不打算使用应用程序工厂模式，那么`init_app`是多余的，可以省略。
- en: 'We flesh out the extension by adding a few configuration-level checks to ensure
    that we have `GITHUB_USERNAME` and `GITHUB_PASSWORD` for API-authenticated API
    access. Additionally, we store the current extension object instance in `app.extensions`,
    which makes the dynamic usage/loading of the extension more straightforward (among
    other things):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过添加一些配置级别的检查来完善扩展，以确保我们具有`GITHUB_USERNAME`和`GITHUB_PASSWORD`以进行API身份验证访问。此外，我们将当前扩展对象实例存储在`app.extensions`中，这使得扩展的动态使用/加载更加简单（等等）：
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Making authenticated requests to the `Github` API requires some form of authentication.
    GitHub supports several of these methods but the simplest is specifying the username
    and password for the account. Generally, this is not something that you want to
    ask your users to give you: it''s better to use the OAuth authorization flow for
    these situations in order to avoid storing user passwords in cleartext. However,
    for our rather simple application and custom extension, we''ll forgo the extended
    OAuth implementation (we''ll look at OAuth more extensively in a later chapter)
    and use the username and password combination.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对`Github` API进行身份验证请求需要某种形式的身份验证。GitHub支持其中几种方法，但最简单的方法是指定帐户的用户名和密码。一般来说，这不是你想要要求用户提供的东西：最好在这些情况下使用OAuth授权流程，以避免以明文形式存储用户密码。然而，对于我们相当简单的应用程序和自定义扩展，我们将放弃扩展的OAuth实现（我们将在后面的章节中更广泛地讨论OAuth），并使用用户名和密码组合。
- en: 'On its own, the extension that we created doesn''t do very much. Let''s fix
    this by adding a property-decorated method that instantiates the `github3.py Github`
    API client library:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 单独使用，我们创建的扩展并没有做太多事情。让我们通过添加一个装饰属性的方法来修复这个问题，该方法实例化`github3.py Github` API客户端库：
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding `client` method, we've implemented the caching property pattern,
    which will ensure that we only ever instantiate a single `github3.py` client per
    created application instance. Additionally, the extension will load the `Github`
    API client lazily on the first access, which is generally a good idea. This lets
    us use the client property of the extension to interface directly with the `github3.py`
    Python library once the application object has been initialized.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`client`方法中，我们实现了缓存属性模式，这将确保我们只实例化一个`github3.py`客户端，每个创建的应用程序实例只实例化一次。此外，扩展将在第一次访问时延迟加载`Github`
    API客户端，这通常是一个好主意。一旦应用程序对象被初始化，这让我们可以使用扩展的客户端属性直接与`github3.py` Python库进行交互。
- en: 'Now that we have the basic setup for our custom Flask extension, let''s initialize
    it and configure the extension itself in our application factory in `application/__init__.py`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的自定义Flask扩展设置了基本的设置，让我们在`application/__init__.py`中的应用工厂中初始化它并配置扩展本身：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note the `hubber = Githubber()` initialization and assignment that happens outside
    of the factory itself, but the actual `init_app(app)` method call and implied
    extension configuration that occurs in the factory after we've initialized a Flask
    application object. You've probably noticed this split pattern (and we've discussed
    it several times in previous chapters as well), but now you've seen the reasoning
    behind it via the development of your own extension.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`hubber = Githubber()`的初始化和赋值发生在工厂本身之外，但实际的`init_app(app)`方法调用和隐含的扩展配置发生在我们初始化Flask应用程序对象之后的工厂中。你可能已经注意到了这种分割模式（我们在之前的章节中也讨论过几次），但现在你已经通过开发自己的扩展看到了它的原因。
- en: 'With this in mind, we add an additional function to our `application/repositories/cli.py`
    module for some additional CLI tooling power:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们在`application/repositories/cli.py`模块中添加了一个额外的函数，以增加一些额外的CLI工具功能：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: After fetching the repository object from the database (based on the ID value
    specified via the CLI argument), we invoke the `client.repository()` method of
    our `Githubber` extension, which we imported as `hubber`, the name it was assigned
    during the instantiation in the factory preamble. As a part of our extension takes
    care of initializing it with the credentials required to make authenticated requests,
    we don't need to handle this in the CLI tool that invokes it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据库中获取存储库对象（基于通过CLI参数指定的ID值），我们调用了我们的`Githubber`扩展的`client.repository()`方法，我们将其导入为`hubber`，这是在工厂序言中分配的名称。由于我们的扩展的一部分负责使用所需的凭据进行初始化，因此我们不需要在调用它的CLI工具中处理这个问题。
- en: Once we've obtained a reference to the remote GitHub repository, we iterate
    over the registered issues via the `iter_issues()` method provided by `github3.py`
    and then create the `Issue` instances that we persist to the SQLAlchemy session.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了对远程GitHub存储库的引用，我们就通过`github3.py`提供的`iter_issues()`方法迭代注册的问题，然后创建`Issue`实例，将其持久化到SQLAlchemy会话中。
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A welcome improvement to the current `Issue` model would be the introduction
    of a compound index on `repository_id` and the number with a unique constraint
    to ensure that imported issues are not duplicated in case we run the preceding
    command more than once on the same repository.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对当前的`Issue`模型的一个受欢迎的改进是在`repository_id`和数字上引入一个复合索引，并使用唯一约束来确保在同一存储库上多次运行前面的命令时不会重复导入问题。
- en: Handling of the raised exception on the insertion of a duplicate would then
    need to happen in the preceding CLI command as well. The implementation is left
    as a (relatively simple) exercise for the reader.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的CLI命令中，对重复插入的异常处理也需要发生。实现留给读者作为一个（相对简单的）练习。
- en: These types of CLI tools are very useful to script actions and behaviors that
    could be considered too costly to occur in-band of a current user request of a
    typical web application. The last thing that you want is for a user of your application
    to wait seconds, if not minutes, for some action to complete that you have almost
    no control over. Instead, it's better to have these events occur out of band.
    Popular methods of accomplishing this include cron jobs and job/task queues such
    as those implemented by Celery (which may be event-driven instead of scheduled
    to run at fixed time intervals such as cron jobs), to name a few.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的CLI工具非常有用，可以脚本化动作和行为，这些动作和行为在典型的Web应用程序的当前用户请求中可能被认为成本太高。你最不希望的是你的应用程序的用户等待几秒，甚至几分钟，以完成一些你几乎无法控制的操作。相反，最好让这些事件在带外发生。实现这一目标的流行方法包括cron作业和作业/任务队列，例如Celery实现的那些（可能是事件驱动的，而不是按照cron作业那样定期运行），等等。
- en: Summary
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: After reading through this chapter, you should be more familiar with the inner
    workings of Flask extensions and command line-based interfaces to the application
    via Flask-Script.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本章后，您应该对Flask扩展和基于命令行的应用程序接口（通过Flask-Script）的内部工作方式更加熟悉。
- en: We began by creating a simple application for the data corresponding to the
    repositories and issues hosted on GitHub and then installed and configured our
    `manage.py` script to act as our bridge for the Flask-Script default CLI runserver
    and shell commands. We added the `drop_db` and `init_db` global commands to replace
    the `database.py` script that we used in previous chapters. Once this was in place,
    we turned our attention to creating the script submanagers in Blueprints that
    we could control via the main `manage.py` interface script.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个简单的应用程序，用于存储在GitHub上托管的存储库和问题的数据，然后安装和配置了我们的`manage.py`脚本，以充当Flask-Script默认CLI
    runserver和shell命令的桥梁。我们添加了`drop_db`和`init_db`全局命令，以替换我们在之前章节中使用的`database.py`脚本。完成后，我们将注意力转向在蓝图中创建子管理器的脚本，我们可以通过主`manage.py`接口脚本进行控制。
- en: Finally, we implemented our own Flask extension that wrapped some basic configuration
    and resource instantiation of the `github3.py Github` API client. Once this was
    finished, we went back to our previously created submanager script and added the
    required functionality to fetch the list of issues stored on GitHub for a given
    repository ID.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实现了自己的Flask扩展，包装了一些基本配置和资源实例化的`github3.py Github` API客户端。完成后，我们回到之前创建的子管理脚本，并添加了获取存储在GitHub上的给定存储库ID的问题列表所需的功能。
- en: In the next chapter, we will take a deeper dive into third-party APIs, where
    we will build an application that uses the OAuth authorization protocol in order
    to implement user account creation and login via Twitter and Facebook.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入研究第三方API，我们将构建一个应用程序，该应用程序使用OAuth授权协议，以实现通过Twitter和Facebook进行用户帐户创建和登录。
