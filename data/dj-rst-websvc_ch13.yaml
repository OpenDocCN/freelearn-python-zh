- en: Creating API Views
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 API 视图
- en: 'In this chapter, we have to run our first version of a RESTful Web Service
    powered by Django. We will write API views to process different HTTP requests
    and we will perform HTTP requests with command-line and GUI tools. We will analyze
    how Django and Django REST framework process each HTTP request. We will gain an
    understanding of:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们必须运行由 Django 驱动的第一个版本的 RESTful Web 服务。我们将编写 API 视图来处理不同的 HTTP 请求，并使用命令行和
    GUI 工具执行 HTTP 请求。我们将分析 Django 和 Django REST framework 如何处理每个 HTTP 请求。我们将了解：
- en: Creating Django views combined with serializer classes
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建结合序列化器类的 Django 视图
- en: CRUD operations with Django views and the request methods
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Django 视图和请求方法进行 CRUD 操作
- en: Launching Django's development server
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动 Django 的开发服务器
- en: Making HTTP GET requests that target a collection of instances with command-line
    tools
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令行工具发送针对一组实例的 HTTP GET 请求
- en: Making HTTP GET requests that target a single instance with command-line tools
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令行工具发送针对单个实例的 HTTP GET 请求
- en: Making HTTP GET requests with command-line tools
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令行工具发送 HTTP GET 请求
- en: Making HTTP POST requests with command-line tools
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令行工具发送 HTTP POST 请求
- en: Making HTTP PUT requests with command-line tools
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令行工具发送 HTTP PUT 请求
- en: Making HTTP DELETE requests with command-line tools
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令行工具发送 HTTP DELETE 请求
- en: Making HTTP GET requests with Postman
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Postman 发送 HTTP GET 请求
- en: Making HTTP POST requests with Postman
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Postman 发送 HTTP POST 请求
- en: Creating Django views combined with serializer classes
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建结合序列化器类的 Django 视图
- en: 'We have created the necessary model and its serializer. It is time to code
    the necessary elements to process HTTP requests and produce HTTP responses. Now,
    we will create Django views that use the `ToySerializer` class that we created
    previously to return JSON representations of the entities for each HTTP request
    that our web service will handle. Open the `toys/views.py` file. The following
    lines show the initial code for this file with just one import statement and a
    comment that indicates we should create the views:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了必要的模型及其序列化器。现在是时候编写处理 HTTP 请求并生成 HTTP 响应的必要元素了。现在，我们将创建使用我们之前创建的 `ToySerializer`
    类的 Django 视图，以返回我们网络服务将处理的每个 HTTP 请求的实体 JSON 表示。打开 `toys/views.py` 文件。以下行显示了此文件的初始代码，只有一个导入语句和一个注释，表明我们应该创建视图：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will create our first version of the web service and we will use functions
    to keep the code as simple as possible. We will work with classes and more complex
    code in later examples. First, it is very important to understand how Django and
    Django REST framework work by way of a simple example.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建我们的第一个版本的网络服务，并使用函数来尽可能简化代码。在后续的示例中，我们将使用类和更复杂的代码。首先，通过一个简单的示例来理解 Django
    和 Django REST framework 的工作方式非常重要。
- en: 'Now, write the following lines in the `restful01/toys/views.py` file to create
    a `JSONResponse` class and declare two functions: `toy_list` and `toy_detail`.
    The code file for the sample is included in the `hillar_django_restful_03_01`
    folder, in the `restful01/toys/views.py` file:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `restful01/toys/views.py` 文件中写下以下行以创建一个 `JSONResponse` 类并声明两个函数：`toy_list`
    和 `toy_detail`。示例的代码文件包含在 `hillar_django_restful_03_01` 文件夹中的 `restful01/toys/views.py`
    文件中：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The highlighted lines show the expressions that evaluate the value of the `request.method`
    attribute to determine the actions to be performed based on the HTTP verb. The
    `JSONResponse` class is a subclass of the `django.http.HttpResponse` class. The
    `django.http.HttpResponse` superclass represents an HTTP response with string
    content.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的行显示了评估 `request.method` 属性值的表达式，以确定基于 HTTP 动词要执行的操作。`JSONResponse` 类是 `django.http.HttpResponse`
    类的子类。`django.http.HttpResponse` 超类表示具有字符串内容的 HTTP 响应。
- en: The `JSONResponse` class renders its content in JSON. The class just declares
    the `__init__` method that creates a `rest_framework.renderers.JSONRenderer` instance
    and calls its `render` method to render the received data in JSON and save the
    returned byte string in the `content` local variable. Then, the code adds the
    `'content_type'` key to the response header with `'application/json'` as its value.
    Finally, the code calls the initializer for the base class with the JSON byte
    string and the key-value pair added to the header. This way, the class represents
    a JSON response that we use in the two functions to easily return a JSON response
    in each HTTP request our web service will process. Since Django 1.7, the `django.http.JsonResponse`
    class has accomplished the same goal. However, we created our own class for educational
    purposes in this example as well as to understand the difference between an `HttpResponse`
    and a `JSONResponse`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSONResponse` 类以 JSON 格式渲染其内容。该类仅声明了 `__init__` 方法，该方法创建一个 `rest_framework.renderers.JSONRenderer`
    实例并调用其 `render` 方法以将接收到的数据渲染为 JSON 格式，并将返回的字节字符串保存到 `content` 本地变量中。然后，代码将 `''content_type''`
    键添加到响应头中，其值为 `''application/json''`。最后，代码使用 JSON 字节字符串和添加到头部的键值对调用基类的初始化器。这样，该类就代表了一个
    JSON 响应，我们在两个函数中使用它来轻松地在每个我们的网络服务将处理的 HTTP 请求中返回 JSON 响应。自 Django 1.7 以来，`django.http.JsonResponse`
    类已经实现了相同的目标。然而，在这个例子中，我们也创建了我们的类，目的是为了教育目的以及理解 `HttpResponse` 和 `JSONResponse`
    之间的区别。'
- en: The code uses the `@csrf_exempt` decorator in the two functions to ensure that
    the view sets a **CSRF** (short for **Cross-Site Request Forgery**) cookie. We
    do this to make it easier to test this example, which doesn't represent a production-ready
    web service. We will add security features to our RESTful Web Service later. Of
    course, it is very important to understand that we should never put a web service
    into production before configuring security and throttling rules.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在两个函数中使用 `@csrf_exempt` 装饰器以确保视图设置一个 **CSRF**（即 **跨站请求伪造**）cookie。我们这样做是为了使测试这个例子更容易，这个例子并不代表一个生产就绪的
    Web 服务。我们将在稍后添加到我们的 RESTful Web 服务中安全功能。当然，理解我们不应该在配置安全性和节流规则之前将 Web 服务投入生产是非常重要的。
- en: Note that the previous code has many problems that we will analyze and fix in
    the forthcoming chapters. However, first, we need to understand how some basic
    things work.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的代码有很多问题，我们将在接下来的章节中分析并修复。然而，首先，我们需要了解一些基本的事情是如何工作的。
- en: Understanding CRUD operations with Django views and the request methods
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 Django 视图和请求方法理解 CRUD 操作
- en: When the Django server receives an HTTP request, Django creates an `HttpRequest`
    instance, specifically a `django.http.HttpRequest` object. This instance contains
    metadata about the request, and this metadata includes an HTTP verb such as GET,
    POST, or PUT. The `method` attribute provides a string representing the HTTP verb
    or method used in the request.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Django 服务器接收到 HTTP 请求时，Django 创建一个 `HttpRequest` 实例，具体来说是 `django.http.HttpRequest`
    对象。此实例包含有关请求的元数据，这些元数据包括 HTTP 动词，如 GET、POST 或 PUT。`method` 属性提供了一个表示请求中使用的 HTTP
    动词或方法的字符串。
- en: When Django loads the appropriate view that will process the request, it passes
    the `HttpRequest` instance as the first argument to the `view` function. The `view`
    function has to return an `HttpResponse` instance, specifically a `django.http.HttpResponse`
    instance.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Django 加载将处理请求的适当视图时，它将 `HttpRequest` 实例作为第一个参数传递给 `view` 函数。`view` 函数必须返回一个
    `HttpResponse` 实例，具体来说是 `django.http.HttpResponse` 实例。
- en: 'The `toy_list` function lists all the toys or creates a new toy. The function
    receives an `HttpRequest` instance in the `request` argument. The function is
    capable of processing two HTTP verbs: `GET` and `POST`. The code checks the value
    of the `request.method` attribute to determine the code to be executed based on
    the HTTP verb.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`toy_list` 函数列出所有玩具或创建一个新的玩具。该函数在 `request` 参数中接收一个 `HttpRequest` 实例。该函数能够处理两种
    HTTP 动词：`GET` 和 `POST`。代码检查 `request.method` 属性的值以确定基于 HTTP 动词要执行的代码。'
- en: If the HTTP verb is `GET`, the expression `request.method == 'GET'` will evaluate
    to `True` and the code has to list all the toys. The code will retrieve all the
    `Toy` objects from the database, use the `ToySerializer` to serialize all of them
    and return a `JSONResponse` instance built with the data generated by the `ToySerializer`
    serializer. The code creates the `ToySerializer` instance with the `many=True`
    argument to specify that multiple instances have to be serialized and not just
    one. Under the hood, Django uses a `ListSerializer` instance when the `many` argument
    value is set to `True`. This way, Django is capable of serializing a list of objects.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 HTTP 动词是 `GET`，表达式 `request.method == 'GET'` 将评估为 `True`，代码必须列出所有玩具。代码将检索数据库中的所有
    `Toy` 对象，使用 `ToySerializer` 将它们全部序列化，并返回一个由 `ToySerializer` 序列化器生成数据的 `JSONResponse`
    实例。代码使用 `many=True` 参数创建 `ToySerializer` 实例，以指定必须序列化多个实例，而不仅仅是单个实例。在底层，当 `many`
    参数值设置为 `True` 时，Django 使用一个 `ListSerializer` 实例。这样，Django 能够序列化对象列表。
- en: If the HTTP verb is `POST`, the code has to create a new toy based on the JSON
    data that is included in the body of the HTTP request. First, the code uses a
    `JSONParser` instance and calls its `parse` method with the `request` parameter
    that the `toy_list` function receives as an argument to parse the toy data provided
    as `JSON` data in the request body and saves the results in the `toy_data` local
    variable. Then, the code creates a `ToySerializer` instance with the previously
    retrieved data and calls the `is_valid` method to determine whether the `Toy`
    instance is valid or not. If the instance is valid, the code calls the `save`
    method to persist the instance in the database and returns a `JSONResponse` with
    the saved data in its body and a status equal to `status.HTTP_201_CREATED`, that
    is, `201 Created`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 HTTP 动词是 `POST`，代码必须根据包含在 HTTP 请求体中的 JSON 数据创建一个新的玩具。首先，代码使用一个 `JSONParser`
    实例，并使用 `request` 参数调用其 `parse` 方法，该参数是 `toy_list` 函数作为参数接收的，以解析请求体中提供的作为 `JSON`
    数据的玩具数据，并将结果保存到 `toy_data` 本地变量中。然后，代码使用之前检索到的数据创建一个 `ToySerializer` 实例，并调用 `is_valid`
    方法来确定 `Toy` 实例是否有效。如果实例有效，代码将调用 `save` 方法将实例持久化到数据库中，并返回一个包含保存数据的 `JSONResponse`，状态等于
    `status.HTTP_201_CREATED`，即 `201 Created`。
- en: Whenever we have to return a specific status different from the default `200
    OK` status, it is a good practice to use the module variables defined in the `rest_framework.status`
    module and avoid using hard-coded numeric values. If you see `status=status.HTTP_201_CREATED`,
    as in the sample code, it is easy to understand that the status is an HTTP `201
    Created` status. If you read `status=201`, you have to remember what the number
    201 stands for in the HTTP status codes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们需要返回与默认的 `200 OK` 状态不同的特定状态时，使用 `rest_framework.status` 模块中定义的模块变量是一种良好的实践，避免使用硬编码的数值。如果你看到
    `status=status.HTTP_201_CREATED`，就像在示例代码中那样，很容易理解状态是一个 HTTP `201 Created` 状态。如果你看到
    `status=201`，你必须记住 HTTP 状态代码中的数字 201 代表什么。
- en: 'The `toy_detail` function retrieves, updates, or deletes an existing toy. The
    function receives an `HttpRequest` instance in the `request` argument and the
    identifier for the toy to be retrieved, updated, or deleted in the `pk` argument.
    The function is capable of processing three HTTP verbs: `GET`, `PUT`, and `DELETE`.
    The code checks the value of the `request.method` attribute to determine the code
    to be executed based on the HTTP verb.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`toy_detail` 函数检索、更新或删除现有的玩具。该函数接收一个 `HttpRequest` 实例作为 `request` 参数，以及要检索、更新或删除的玩具的标识符作为
    `pk` 参数。该函数能够处理三种 HTTP 动词：`GET`、`PUT` 和 `DELETE`。代码检查 `request.method` 属性的值，以确定根据
    HTTP 动词要执行的代码。'
- en: No matter what the HTTP verb is, the `toy_detail` function calls the `Toy.objects.get`
    method with the received `pk` as the `pk` argument to retrieve a `Toy` instance
    from the database based on the specified identifier, and saves it in the `toy`
    local variable. In case a toy with the specified identifier doesn't exist in the
    database, the code returns an `HttpResponse` with its status set to `status.HTTP_404_NOT_FOUND`,
    that is, `404 Not Found`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 无论 HTTP 动词是什么，`toy_detail` 函数都会使用接收到的 `pk` 作为 `pk` 参数调用 `Toy.objects.get` 方法，从数据库中根据指定的标识符检索一个
    `Toy` 实例，并将其保存到 `toy` 本地变量中。如果数据库中不存在具有指定标识符的玩具，代码将返回一个状态设置为 `status.HTTP_404_NOT_FOUND`
    的 `HttpResponse`，即 `404 Not Found`。
- en: If the HTTP verb is `GET`, the code creates a `ToySerializer` instance with
    `toy` as an argument and returns the data for the serialized toy in a `JSONResponse`
    that will include the default HTTP `200 OK` status. The code returns the retrieved
    toy serialized as JSON in the response body.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 HTTP 动词是 `GET`，代码将使用 `toy` 作为参数创建一个 `ToySerializer` 实例，并以包含默认 HTTP `200 OK`
    状态的 `JSONResponse` 返回序列化玩具的数据。代码将检索到的玩具序列化为 JSON 并返回到响应体中。
- en: If the HTTP verb is `PUT`, the code has to create a new toy based on the JSON
    data that is included in the HTTP request and use it to replace an existing toy.
    First, the code uses a `JSONParser` instance and calls its `parse` method with
    `request` as an argument to parse the toy data provided as JSON data in the request
    and saves the results in the `toy_data` local variable. Then, the code creates
    a `ToySerializer` instance with the `Toy` instance previously retrieved from the
    database (`toy`) and the retrieved data that will replace the existing data (`toy_data`).
    Then, the code calls the `is_valid` method to determine whether the `Toy` instance
    is valid or not. If the instance is valid, the code calls the `save` method to
    persist the instance with the replaced values in the database and returns a `JSONResponse`
    with the saved data serialized as JSON in its body and the default HTTP `200 OK`
    status. If the parsed data doesn't generate a valid `Toy` instance, the code returns
    a `JSONResponse` with a status equal to `status.HTTP_400_BAD_REQUEST`, that is
    `400 Bad Request`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 HTTP 动词是 `PUT`，代码必须根据包含在 HTTP 请求中的 JSON 数据创建一个新的玩具，并使用它来替换现有的玩具。首先，代码使用一个
    `JSONParser` 实例，并使用 `request` 作为参数调用其 `parse` 方法来解析请求中提供的作为 JSON 数据的玩具数据，并将结果保存到局部变量
    `toy_data` 中。然后，代码使用从数据库中先前检索到的 `Toy` 实例（`toy`）和将替换现有数据（`toy_data`）检索到的数据创建一个
    `ToySerializer` 实例。然后，代码调用 `is_valid` 方法来确定 `Toy` 实例是否有效。如果实例有效，代码将调用 `save` 方法以替换的值在数据库中持久化实例，并返回一个包含已保存数据序列化为
    JSON 的 `JSONResponse` 和默认 HTTP `200 OK` 状态。如果解析的数据不生成有效的 `Toy` 实例，代码将返回一个状态等于
    `status.HTTP_400_BAD_REQUEST` 的 `JSONResponse`，即 `400 Bad Request`。
- en: If the HTTP verb is `DELETE`, the code calls the `delete` method for the `Toy`
    instance previously retrieved from the database (`toy`). The call to the `delete`
    method erases the underlying row in the `toys_toy` table that we analyzed in the
    previous chapter. Thus, the toy won't be available anymore. Then, the code returns
    a `JSONResponse` with a status equal to `status`. `HTTP_204_NO_CONTENT` that is,
    `204 No Content`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 HTTP 动词是 `DELETE`，代码将调用从数据库中先前检索到的 `Toy` 实例（`toy`）的 `delete` 方法。对 `delete`
    方法的调用将擦除我们在上一章中分析的 `toys_toy` 表中的底层行。因此，玩具将不再可用。然后，代码返回一个状态等于 `status` 的 `JSONResponse`，即
    `HTTP_204_NO_CONTENT`，也就是 `204 No Content`。
- en: Routing URLs to Django views and functions
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 URL 路由到 Django 视图和函数
- en: 'Now, we have to create a new Python file named `urls.py` in the `toys` folder,
    specifically, the `toys/urls.py` file. The following lines show the code for this
    file, which defines the URL patterns that specify the regular expressions that
    have to be matched in the request to run a specific function previously defined
    in the `views.py` file. The code file for the sample is included in the `hillar_django_restful_03_01`
    folder, in the `restful01/toys/urls.py` file:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须在 `toys` 文件夹中创建一个名为 `urls.py` 的新 Python 文件，具体来说，是 `toys/urls.py` 文件。以下行显示了该文件的代码，它定义了指定请求中必须匹配的正则表达式，以便运行在
    `views.py` 文件中先前定义的特定函数。示例代码文件包含在 `hillar_django_restful_03_01` 文件夹中，位于 `restful01/toys/urls.py`
    文件中：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `urlpatterns` list makes it possible to route URLs to views. The code calls
    the `django.conf.urls.url` function with the regular expression that has to be
    matched and the `view` function defined in the `views` module as arguments to
    create a `RegexURLPattern` instance for each entry in the `urlpatterns` list.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`urlpatterns` 列表使得将 URL 路由到视图成为可能。代码使用 `django.conf.urls.url` 函数，将必须匹配的正则表达式和定义在
    `views` 模块中的 `view` 函数作为参数调用，为 `urlpatterns` 列表中的每个条目创建一个 `RegexURLPattern` 实例。'
- en: 'Now, we have to replace the code in the `urls.py` file in the `restful01` folder,
    specifically, the `restful01/urls.py` file. The file defines the root URL configurations,
    and therefore we must include the URL patterns declared in the previously coded
    `toys/urls.py` file. The following lines show the new code for the `restful01/urls.py`
    file. The code file for the sample is included in the `hillar_django_restful_03_01`
    folder, in the `restful01/urls.py` file:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须替换 `restful01` 文件夹中 `urls.py` 文件中的代码，具体来说，是 `restful01/urls.py` 文件。该文件定义了根
    URL 配置，因此我们必须包含在之前编写的 `toys/urls.py` 文件中声明的 URL 模式。以下行显示了 `restful01/urls.py`
    文件的新代码。示例代码文件包含在 `hillar_django_restful_03_01` 文件夹中，在 `restful01/urls.py` 文件中：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Launching Django's development server
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动 Django 的开发服务器
- en: Now, we can launch Django's development server to compose and send HTTP requests
    to our unsecured web service. Remember that we will add security later.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以启动 Django 的开发服务器来编写和发送 HTTP 请求到我们的未加密 Web 服务。请记住，我们稍后会增加安全性。
- en: 'Execute the following command in a Linux or macOS Terminal, or in the Windows
    Command Prompt or Powershell that has our previously created virtual environment
    activated. Make sure you are in the `restful01` folder within the virtual environment''s
    main folder:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 或 macOS 终端，或在已激活我们之前创建的虚拟环境的 Windows 命令提示符或 Powershell 中执行以下命令。确保您位于虚拟环境主文件夹内的
    `restful01` 文件夹中：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following lines show the output after we execute the previous command.
    The development server is listening at port `8000`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了执行上一个命令后的输出。开发服务器正在端口 `8000` 上监听：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With the previous command, we will start the Django development server and we
    will only be able to access it on our development computer. The previous command
    starts the development server at the default IP address, that is, `127.0.0.1`
    (`localhost`). It is not possible to access this IP address from other computers
    or devices connected to our LAN. Thus, if we want to make HTTP requests to our
    API from other computers or devices connected to our LAN, we should use the development
    computer IP address, `0.0.0.0` (for IPv4 configurations) or `::` (for IPv6 configurations)
    as the desired IP address for our development server.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上一个命令，我们将启动 Django 开发服务器，并且我们只能在我们的开发计算机上访问它。上一个命令在默认 IP 地址上启动开发服务器，即 `127.0.0.1`
    (`localhost`)。从连接到我们的局域网的其它计算机或设备无法访问此 IP 地址。因此，如果我们想从连接到我们的局域网的其它计算机或设备向我们的 API
    发送 HTTP 请求，我们应该使用开发计算机的 IP 地址，`0.0.0.0`（对于 IPv4 配置）或 `::`（对于 IPv6 配置）作为开发服务器的所需
    IP 地址。
- en: 'If we specify `0.0.0.0` as the desired IP address for IPv4 configurations,
    the development server will listen on every interface on port 8000\. When we specify
    `::` for IPv6 configurations, it will have the same effect. In addition, it is
    necessary to open the default port `8000` in our firewalls (software and/or hardware)
    and configure port-forwarding to the computer that is running the development
    server. The following command launches Django''s development server in an IPv4
    configuration and allows requests to be made from other computers and devices
    connected to our LAN:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为 IPv4 配置指定 `0.0.0.0` 作为所需的 IP 地址，开发服务器将在端口 8000 上监听每个接口。当我们为 IPv6 配置指定
    `::` 时，它将产生相同的效果。此外，有必要在我们的防火墙（软件和/或硬件）中打开默认端口 `8000` 并配置端口转发到运行开发服务器的计算机。以下命令以
    IPv4 配置启动 Django 的开发服务器，并允许从连接到我们的局域网的其它计算机和设备发出请求：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you decide to compose and send HTTP requests from other computers or devices
    connected to the LAN, remember that you have to use the development computer's
    assigned IP address instead of `localhost`. For example, if the computer's assigned
    IPv4 IP address is `192.168.2.103`, instead of `localhost:8000`, you should use
    `192.168.2.103:8000`. Of course, you can also use the hostname instead of the
    IP address.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您决定从连接到局域网的其它计算机或设备编写和发送 HTTP 请求，请记住您必须使用开发计算机分配的 IP 地址而不是 `localhost`。例如，如果计算机分配的
    IPv4 IP 地址是 `192.168.2.103`，那么您应该使用 `192.168.2.103:8000` 而不是 `localhost:8000`。当然，您也可以使用主机名而不是
    IP 地址。
- en: The previously explained configurations are very important because mobile devices
    might be the consumers of our RESTful Web Services and we will always want to
    test the apps that make use of our web services and APIs in our development environments.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 之前解释的配置非常重要，因为移动设备可能是我们 RESTful Web 服务的消费者，我们始终希望在我们的开发环境中测试使用我们的 Web 服务和 API
    的应用程序。
- en: Making HTTP GET requests that target a collection of instances
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向一组实例发送 HTTP GET 请求
- en: In [Chapter 1](dj-rst-websvc_ch11.html), *Installing the Required Software and
    Tools*, we installed command-line and GUI tools that were going to allow us to
    compose and send HTTP requests to the web services we were going to build throughout
    this book. Now, we will use the curl utility to make HTTP GET requests, specifically,
    HTTP GET requests that target a collection of toys. In case curl is not included
    in the path, make sure you replace curl with the full path to this utility.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](dj-rst-websvc_ch11.html)，“安装所需的软件和工具”中，我们安装了命令行和GUI工具，这些工具将允许我们编写并发送HTTP请求到本书中将要构建的Web服务。现在，我们将使用curl实用程序来发送HTTP
    GET请求，具体来说，是针对玩具集合的HTTP GET请求。如果curl未包含在路径中，请确保将curl替换为该实用程序的完整路径。
- en: Make sure you leave the Django development server running. Don't close the terminal
    or Command Prompt that is running this development server. Open a new Terminal
    in Linux or macOS, or a Command Prompt in Windows, and run the following command.
    It is very important that you enter the ending slash (`/`) because `/toys` won't
    match any of the patterns specified in `urlpatterns` in the `toys/urls.py` file.
    We aren't going to use options to follow redirects. Thus, we must enter `/toys/`,
    including the ending slash (`/`).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您让Django开发服务器继续运行。不要关闭运行此开发服务器的终端或命令提示符。在Linux或macOS中打开一个新的终端，或在Windows中打开一个命令提示符，并运行以下命令。您输入结束斜杠（`/`）非常重要，因为`/toys`不会匹配`toys/urls.py`文件中指定的任何模式。我们不会使用选项来跟随重定向。因此，我们必须输入`/toys/`，包括结束斜杠（`/`）。
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The previous command will compose and send the following HTTP request: `GET
    http://localhost:8000/toys/`. The request is the simplest case in our RESTful
    Web Service because it will match and run the `views.toy_list` function, that
    is, the `toy_list` function we coded within the `toys/views.py` file. The function
    just receives `request` as a parameter because the URL pattern doesn''t include
    any parameters. As the HTTP verb for the request is `GET`, the `request.method`
    property is equal to `''GET''`, and therefore, the function will execute the code
    that retrieves all the `Toy` objects and generates a JSON response with all of
    these `Toy` objects serialized.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将编写并发送以下HTTP请求：`GET http://localhost:8000/toys/`。这个请求是我们RESTful Web Service中最简单的情况，因为它将匹配并运行`views.toy_list`函数，即我们在`toys/views.py`文件中编写的`toy_list`函数。该函数仅接收`request`作为参数，因为URL模式不包含任何参数。由于HTTP请求的动词是`GET`，`request.method`属性等于`'GET'`，因此该函数将执行检索所有`Toy`对象并生成包含所有这些`Toy`对象的序列化JSON响应的代码。
- en: 'The following lines show an example response for the HTTP request, with three
    `Toy` objects in the JSON response:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了HTTP请求的一个示例响应，其中包含JSON响应中的三个`Toy`对象：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we might notice from the previous response, the curl utility displays the
    JSON response in a single line, and therefore, it is a bit difficult to read.
    It is possible to use different tools, including some Python scripts, to provide
    a better format to the response. However, we will use the HTTPie command-line
    tool we installed in our virtual environment for this purpose later.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从之前的响应中可能注意到的，curl实用程序将JSON响应显示为单行，因此阅读起来有点困难。我们可以使用不同的工具，包括一些Python脚本，来提供更好的响应格式。然而，我们将使用我们安装在我们虚拟环境中的HTTPie命令行工具来完成此目的。
- en: In this case, we know that the value of the `Content-Type` header key of the
    response is `application/json`. However, in case we want more details about the
    response, we can use the `-i` option to request curl to print the HTTP response
    headers and their key-value pairs. We can combine the `-i` and `-X` options by
    entering `-iX`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们知道响应的`Content-Type`头键的值是`application/json`。然而，如果我们想了解更多关于响应的细节，我们可以使用`-i`选项请求curl打印HTTP响应头及其键值对。我们可以通过输入`-iX`将`-i`和`-X`选项组合起来。
- en: 'Go back to the terminal in Linux or macOS, or the Command prompt in Windows,
    and run the following command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到Linux或macOS中的终端，或Windows中的命令提示符，并运行以下命令：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following lines show an example response for the HTTP request. The first
    lines show the HTTP response headers, including the status (`200 OK`) and the
    `Content-Type: application/json`. After the HTTP response headers, we can see
    the details for the three `Toy` objects in the JSON response:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '以下行显示了HTTP请求的一个示例响应。前几行显示了HTTP响应头，包括状态（`200 OK`）和`Content-Type: application/json`。在HTTP响应头之后，我们可以看到JSON响应中三个`Toy`对象的详细信息：'
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After we run the two requests, we will see the following lines in the window
    running the Django development server. The output indicates that the server received
    two HTTP requests with the `GET` verb and `/toys/` as the URI. The server processed
    both HTTP requests, returned a status code equal to `200`, and the response length
    was equal to `548` characters.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行这两个请求之后，我们将在运行 Django 开发服务器的窗口中看到以下行。输出表明服务器接收到了两个使用 `GET` 动词和 `/toys/` 作为
    URI 的 HTTP 请求。服务器处理了这两个 HTTP 请求，返回了状态码等于 `200`，响应长度等于 `548` 个字符。
- en: 'The response length might be different because the value for the primary key
    assigned to each toy will have an incidence in the response length. The first
    number after `HTTP/1.1."` indicates the returned status code (`200`) and the second
    number the response length (`548`):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 响应长度可能不同，因为分配给每个玩具的主键值将对响应长度产生影响。`HTTP/1.1."` 后的第一个数字表示返回的状态码（`200`），第二个数字表示响应长度（`548`）：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following image shows two Terminal windows side-by-side on macOS. The Terminal
    window on the left-hand side is running the Django development server and displays
    the received and processed HTTP requests. The Terminal window on the right-hand
    side is running `curl` commands to generate the HTTP requests. It is a good idea
    to use a similar configuration to check the output while we compose and send the
    HTTP requests. Notice that the JSON outputs are a bit difficult to read because
    they don''t use syntax highlighting:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了 macOS 上并排的两个终端窗口。左侧的终端窗口正在运行 Django 开发服务器，并显示接收和处理的 HTTP 请求。右侧的终端窗口正在运行
    `curl` 命令以生成 HTTP 请求。在编写和发送 HTTP 请求时使用类似的配置来检查输出是个好主意。请注意，由于没有使用语法高亮，JSON 输出读起来有点困难：
- en: '![](img/58c92084-44cd-45fa-9d0d-309ab5577703.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/58c92084-44cd-45fa-9d0d-309ab5577703.png)'
- en: Now, open a new Terminal in Linux or macOS, or a new Command Prompt in Windows,
    and activate the virtual environment we created. This way, you will be able to
    access the HTTPie utility we installed within the virtual environment.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 Linux 或 macOS 中打开一个新的终端，或在 Windows 中打开一个新的命令提示符，并激活我们创建的虚拟环境。这样，你将能够访问我们安装在该虚拟环境中的
    HTTPie 工具。
- en: 'We will use the `http` command to easily compose and send HTTP requests to
    `localhost:8000` and test the RESTful Web Service. HTTPie supports curl-like shorthand
    for localhost, and therefore we can use `:8000` as a shorthand that expands to
    `http://localhost:8000`. Run the following command and remember to enter the ending
    slash (`/`):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `http` 命令轻松地组合并发送 HTTP 请求到 `localhost:8000` 并测试 RESTful Web 服务。HTTPie
    支持 curl 类似的本地主机缩写，因此我们可以使用 `:8000` 作为缩写，它展开为 `http://localhost:8000`。运行以下命令，并请记住输入结束斜杠（`/`）：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The previous command will compose and send the following HTTP request: `GET
    http://localhost:8000/toys/`. The request is the same one we previously composed
    with the `curl` command. However, in this case, the HTTPie utility will display
    a colorized output and it will use multiple lines to display the JSON response,
    without any additional tweaks. The previous command is equivalent to the following
    command that specifies the `GET` method after `http`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组合并发送以下 HTTP 请求：`GET http://localhost:8000/toys/`。请求与之前使用 `curl` 命令组合的请求相同。然而，在这种情况下，HTTPie
    工具将显示彩色输出，并使用多行来显示 JSON 响应，无需任何额外调整。之前的命令等同于以下指定 `GET` 方法的命令：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following lines show an example response for the HTTP request, with the
    headers and the three `Toy` objects in the JSON response. It is indeed easier
    to understand the response compared with the results that were generated when
    we composed the HTTP request with curl. HTTPie automatically formats the JSON
    data received as a response and applies syntax highlighting, specifically, both
    colors and formatting:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行展示了针对 HTTP 请求的一个示例响应，其中包含了 JSON 响应中的头部信息和三个 `Toy` 对象。与使用 curl 组合 HTTP 请求时生成的结果相比，理解响应确实更容易。HTTPie
    会自动格式化接收到的 JSON 数据作为响应，并应用语法高亮，具体来说，包括颜色和格式：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can achieve the same results by combining the output generated with the curl
    command with other utilities. However, HTTPie provides us exactly what we need
    for working with RESTful Web Services such as the one we are building with Django.
    We will use HTTPie to compose and send HTTP requests, but we will always provide
    the equivalent curl command. Remember that curl is faster when you need to execute
    it many times, such as when you prepare automated scripts.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将 curl 命令生成的输出与其他工具结合使用来实现相同的结果。然而，HTTPie 为我们提供了与 Django 等构建的 RESTful
    Web 服务一起工作所需的一切。我们将使用 HTTPie 来组合和发送 HTTP 请求，但我们将始终提供等效的 curl 命令。记住，当你需要多次执行 curl
    时，curl 会更快，例如当你准备自动化脚本时。
- en: 'The following image shows two Terminal windows side-by-side on macOS. The Terminal
    window on the left-hand side is running the Django development server and displays
    the received and processed HTTP requests. The Terminal window on the right-hand
    side is running HTTPie commands to generate the HTTP requests. Notice that the
    JSON output is easier to read compared to the output generated by the curl command:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了 macOS 上并排的两个终端窗口。左侧的终端窗口正在运行 Django 开发服务器并显示接收和处理的 HTTP 请求。右侧的终端窗口正在运行
    HTTPie 命令以生成 HTTP 请求。请注意，与 curl 命令生成的输出相比，JSON 输出更容易阅读：
- en: '![](img/9a42efd6-5ca6-49ae-b908-4f8517f64a0b.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9a42efd6-5ca6-49ae-b908-4f8517f64a0b.png)'
- en: 'We can execute the `http` command with the `-b` option in case we don''t want
    to include the header in the response. For example, the following line performs
    the same HTTP request but doesn''t display the header in the response output,
    and therefore, the output will just display the JSON response:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不希望在响应中包含头部信息，可以使用 `-b` 选项执行 `http` 命令。例如，以下行执行了相同的 HTTP 请求，但不在响应输出中显示头部信息，因此输出将仅显示
    JSON 响应：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Making HTTP GET requests that target a single instance
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向单个实例发送 HTTP GET 请求
- en: 'Now, we will make HTTP GET requests that target a single `Toy` instance. We
    will select one of the toys from the previous list and we will compose an HTTP
    request to retrieve only the chosen toy. For example, in the previous list, the
    first toy has a `pk` value equal to `3` because the results are ordered by the
    toy''s name in ascending order. Run the following command to retrieve this toy.
    Use the `pk` value you have retrieved in the previous command for the first toy,
    as the pk number might be different if you execute the sample code or the commands
    more than once or you make changes to the `toys_toy` table. In this case, you
    don''t have to enter an ending slash (`/`) because `/toys/3/` won''t match any
    of the patterns specified in `urlpatterns` in the `toys/urls.py` file:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将向单个 `Toy` 实例发送 HTTP GET 请求。我们将从之前的列表中选择一个玩具，并编写一个 HTTP 请求来仅检索所选的玩具。例如，在之前的列表中，第一个玩具的
    `pk` 值等于 `3`，因为结果是根据玩具的名称按升序排序的。运行以下命令来检索此玩具。使用之前命令中检索到的第一个玩具的 `pk` 值，因为如果执行示例代码或命令多次，或者你对
    `toys_toy` 表进行了更改，`pk` 数字可能会有所不同。在这种情况下，你不需要输入结束斜杠（`/`），因为 `/toys/3/` 不会匹配 `toys/urls.py`
    文件中 `urlpatterns` 指定的任何模式：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The previous commands will compose and send the following HTTP request: `GET
    http://localhost:8000/toys/3/`. The request has a number after `/toys/`, and therefore,
    it will match `''^toys/(?P<pk>[0-9]+)$''` and run the `views.toy_detail` function,
    that is, the `toy_detail` function declared within the `toys/views.py` file. The
    function receives `request` and `pk` as parameters because the URL pattern passes
    the number specified after `/toys/` in the `pk` parameter.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组合并发送以下 HTTP 请求：`GET http://localhost:8000/toys/3/`。请求在 `/toys/` 后面有一个数字，因此它将匹配
    `'^toys/(?P<pk>[0-9]+)$'` 并运行 `views.toy_detail` 函数，即 `toys/views.py` 文件中声明的 `toy_detail`
    函数。该函数接收 `request` 和 `pk` 作为参数，因为 URL 模式将 `/toys/` 后面指定的数字传递给 `pk` 参数。
- en: 'As the HTTP verb for the request is `GET`, the `request.method` property is
    equal to `''GET''`, and therefore, the `toy_detail` function will execute the
    code that retrieves the `Toy` object whose primary key matches the `pk` value
    received as an argument and, if found, generates a JSON response with this `Toy`
    object serialized. The following lines show an example response for the HTTP request,
    with the `Toy` object that matches the `pk` value in the JSON response:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于请求的 HTTP 动词是 `GET`，因此 `request.method` 属性等于 `'GET'`，因此，`toy_detail` 函数将执行检索与作为参数接收的
    `pk` 值匹配的 `Toy` 对象的代码，如果找到，则生成包含此 `Toy` 对象序列化的 JSON 响应。以下行显示了 HTTP 请求的示例响应，其中
    JSON 响应中匹配 `pk` 值的 `Toy` 对象：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we will compose and send an HTTP request to retrieve a toy that doesn''t
    exist. For example, in the previous list, there is no toy with a `pk` value equal
    to `17500`. Run the following command to try to retrieve this toy. Make sure you
    use a `pk` value that doesn''t exist. We must make sure that the utilities display
    the headers as part of the response because the response won''t have a body:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将组合并发送一个 HTTP 请求来检索一个不存在的玩具。例如，在之前的列表中，没有 `pk` 值等于 `17500` 的玩具。运行以下命令尝试检索此玩具。确保您使用一个不存在的
    `pk` 值。我们必须确保实用工具将标题作为响应的一部分显示，因为响应将没有主体：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The previous commands will compose and send the following HTTP request: `GET
    http://localhost:8000/toys/17500`. The request is the same as the previous one
    we analyzed, with a different number for the `pk` parameter. The server will run
    the `views.toy_detail` function, that is, the `toy_detail` function declared within
    the `toys/views.py` file. The function will execute the code that retrieves the
    `Toy` object whose primary key matches the `pk` value received as an argument
    and a `Toy.DoesNotExist` exception will be thrown and captured because there is
    no toy with the specified `pk` value. Thus, the code will return an HTTP `404
    Not Found` status code. The following lines show an example header response for
    the HTTP request:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组合并发送以下 HTTP 请求：`GET http://localhost:8000/toys/17500`。请求与之前我们分析的那个相同，只是
    `pk` 参数的数字不同。服务器将运行 `views.toy_detail` 函数，即 `toys/views.py` 文件中声明的 `toy_detail`
    函数。该函数将执行检索与作为参数接收的 `pk` 值匹配的 `Toy` 对象的代码，并且由于没有与指定的 `pk` 值匹配的玩具，将抛出并捕获 `Toy.DoesNotExist`
    异常。因此，代码将返回 HTTP `404 Not Found` 状态码。以下行显示了 HTTP 请求的示例标题响应：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Making HTTP POST requests
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作 HTTP POST 请求
- en: 'Now, we will compose and send an HTTP request to create a new toy:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将组合并发送一个 HTTP 请求来创建一个新的玩具：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following is the equivalent `curl` command. It is very important to use
    the `-H "Content-Type: application/json"` option to indicate to curl that it should
    send the data specified after the `-d` option as `application/json` instead of
    the default `application/x-www-form-urlencoded`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '以下是对应的 `curl` 命令。非常重要的一点是，必须使用 `-H "Content-Type: application/json"` 选项来指示
    curl 应将 `-d` 选项之后指定的数据作为 `application/json` 发送，而不是默认的 `application/x-www-form-urlencoded`：'
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The previous commands will compose and send the following HTTP request: `POST
    http://localhost:8000/toys/` with the following JSON key-value pairs:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组合并发送以下 HTTP 请求：`POST http://localhost:8000/toys/`，附带以下 JSON 键值对：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The request specifies `/toys/`, and therefore, it will match the `''^toys/$''`
    regular expression and run the `views.toy_list` function, that is, the `toy_detail`
    function declared within the `toys/views.py` file. The function just receives
    `request` as a parameter because the URL pattern doesn''t include any parameters.
    As the HTTP verb for the request is `POST`, the `request.method` property is equal
    to `''POST''`, and therefore, the function will execute the code that parses the
    JSON data received in the request. Then, the function creates a new `Toy` and,
    if the data is valid, it saves the new `Toy` to the `toys_toy` table in the SQLite
    database. If the new `Toy` was successfully persisted in the database, the function
    returns an HTTP `201 Created` status code and the recently persisted `Toy` serialized
    to JSON in the response body. The following lines show an example response for
    the HTTP request, with the new `Toy` object in the JSON response:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请求指定 `/toys/`，因此，它将匹配正则表达式 `'^toys/$'` 并运行 `views.toy_list` 函数，即 `toys/views.py`
    文件中声明的 `toy_list` 函数。该函数仅接收 `request` 作为参数，因为 URL 模式不包含任何参数。由于请求的 HTTP 方法是 `POST`，因此
    `request.method` 属性等于 `'POST'`，因此该函数将执行解析请求中接收到的 JSON 数据的代码。然后，该函数创建一个新的 `Toy`，如果数据有效，则将新的
    `Toy` 保存到 SQLite 数据库的 `toys_toy` 表中。如果新的 `Toy` 在数据库中成功持久化，该函数将返回 HTTP `201 Created`
    状态码，并在响应体中将最近持久化的 `Toy` 序列化为 JSON。以下行显示了 HTTP 请求的示例响应，其中包含 JSON 响应中的新 `Toy` 对象：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Making HTTP PUT requests
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送 HTTP PUT 请求
- en: 'Now, we will compose and send an HTTP request to update an existing toy, specifically,
    the previously added toy. We have to check the value assigned to `pk` in the previous
    response and replace `4` in the command with the returned value. For example,
    if the value for `pk` was `4`, you should use `:8000/toys/4` instead of `:8000/toys/4`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将组合并发送一个 HTTP 请求来更新现有的玩具，具体来说，是之前添加的玩具。我们必须检查之前响应中分配给 `pk` 的值，并将命令中的 `4`
    替换为返回的值。例如，如果 `pk` 的值是 `4`，则应使用 `:8000/toys/4` 而不是 `:8000/toys/4`：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following is the equivalent `curl` command. As with the previous curl example,
    it is very important to use the `-H "Content-Type: application/json"` option to
    indicate `curl` to send the data specified after the `-d` option as `application/json`
    instead of the default `application/x-www-form-urlencoded`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '以下是对应的 `curl` 命令。与之前的 curl 示例一样，非常重要的一点是使用 `-H "Content-Type: application/json"`
    选项来指示 `curl` 将 `-d` 选项之后指定的数据作为 `application/json` 发送，而不是默认的 `application/x-www-form-urlencoded`：'
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The previous commands will compose and send the following HTTP request: `PUT
    http://localhost:8000/toys/4` with the following JSON key-value pairs:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组合并发送以下 HTTP 请求：`PUT http://localhost:8000/toys/4`，并带有以下 JSON 键值对：
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The request has a number after `/toys/`, and therefore, it will match the `''^toys/(?P<pk>[0-9]+)$''`
    regular expression and run the `views.toy_detail` function, that is, the `toy_detail`
    function declared within the `toys/views.py` file. The function receives `request`
    and `pk` as parameters because the URL pattern passes the number specified after
    `/toys/` in the `pk` parameter. As the HTTP verb for the request is `PUT`, the
    `request.method` property is equal to `''PUT''`, and therefore, the function will
    execute the code that parses the JSON data received in the request. Then, the
    function will create a `Toy` instance from this data and update the existing toy
    in the database. If the toy was successfully updated in the database, the function
    returns an HTTP `200 OK` status code and the recently updated `Toy` serialized
    to JSON in the response body. The following lines show an example response for
    the HTTP request, with the updated `Toy` object in the JSON response:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请求在 `/toys/` 后面有一个数字，因此，它将匹配正则表达式 `'^toys/(?P<pk>[0-9]+)$'` 并运行 `views.toy_detail`
    函数，即 `toys/views.py` 文件中声明的 `toy_detail` 函数。该函数接收 `request` 和 `pk` 作为参数，因为 URL
    模式将 `/toys/` 后面指定的数字作为 `pk` 参数传递。由于请求的 HTTP 方法是 `PUT`，因此 `request.method` 属性等于
    `'PUT'`，因此该函数将执行解析请求中接收到的 JSON 数据的代码。然后，该函数将根据这些数据创建一个 `Toy` 实例并更新数据库中的现有玩具。如果玩具在数据库中成功更新，该函数将返回
    HTTP `200 OK` 状态码，并在响应体中将最近更新的 `Toy` 序列化为 JSON。以下行显示了 HTTP 请求的示例响应，其中包含 JSON 响应中的更新后的
    `Toy` 对象：
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In order to successfully process a `PUT` HTTP request that updates an existing
    toy, we must provide values for all the required fields. We will compose and send
    an HTTP request to try to update an existing toy, and we will fail to do so because
    we will just provide a value for the name. As in the previous request, we will
    use the value assigned to `pk` in the last toy we added:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功处理更新现有玩具的 `PUT` HTTP 请求，我们必须为所有必需的字段提供值。我们将编写并发送一个 HTTP 请求来尝试更新一个现有的玩具，我们将无法做到这一点，因为我们只为名称提供了一个值。就像之前的请求一样，我们将使用最后添加的玩具中分配给
    `pk` 的值：
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令：
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The previous commands will compose and send the following HTTP request: `PUT
    http://localhost:8000/toys/4` with the following JSON key-value pair:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将编写并发送以下 HTTP 请求：`PUT http://localhost:8000/toys/4`，并带有以下 JSON 键值对：
- en: '[PRE32]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The request will execute the same code we explained for the previous request.
    As we didn''t provide all the required values for a `Toy` instance, the `toy_serializer.is_valid()`
    method will return `False` and the function will return an HTTP `400 Bad Request`
    status code and the details generated in the `toy_serializer.errors` attribute
    serialized to JSON in the response body. The following lines show an example response
    for the HTTP request, with the required fields that our request didn''t include
    values in the JSON response (`description`, `release_date`, and `toy_category`):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请求将执行我们之前解释的相同代码。由于我们没有为 `Toy` 实例提供所有必需的值，`toy_serializer.is_valid()` 方法将返回
    `False`，函数将返回 HTTP `400 Bad Request` 状态码，并将 `toy_serializer.errors` 属性中生成的详细信息序列化为
    JSON 放入响应体中。以下行显示了 HTTP 请求的一个示例响应，其中我们的请求在 JSON 响应中没有包含值的必需字段（`description`、`release_date`
    和 `toy_category`）：
- en: '[PRE33]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When we want our API to be able to update a single field for an existing resource,
    in this case, an existing toy, we should provide an implementation for the PATCH
    method. The PUT method is meant to replace an entire resource and the PATCH method
    is meant to apply a delta to an existing resource. We can write code in the handler
    for the PUT method to apply a delta to an existing resource, but it is a better
    practice to use the PATCH method for this specific task. We will work with the
    PATCH method later.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们希望我们的 API 能够更新现有资源的单个字段，在这种情况下，是一个现有的玩具，我们应该提供一个用于 PATCH 方法的实现。PUT 方法旨在替换整个资源，而
    PATCH 方法旨在对现有资源应用一个增量。我们可以在 PUT 方法的处理程序中编写代码来对现有资源应用增量，但使用 PATCH 方法执行此特定任务是一种更好的做法。我们将在稍后使用
    PATCH 方法。
- en: Making HTTP DELETE requests
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 HTTP DELETE 请求
- en: 'Now, we will compose and send an HTTP request to delete an existing toy, specifically,
    the last toy we added. As in our last HTTP request, we have to check the value
    assigned to `pk` in the previous response and replace `4` in the command with
    the returned value:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写并发送一个 HTTP 请求来删除一个现有的玩具，具体来说，是我们最后添加的玩具。就像我们之前的 HTTP 请求一样，我们必须检查前一个响应中分配给
    `pk` 的值，并将命令中的 `4` 替换为返回的值：
- en: '[PRE34]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令：
- en: '[PRE35]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The previous commands will compose and send the following HTTP request: `DELETE
    http://localhost:8000/toys/4`. The request has a number after `/toys/`, and therefore,
    it will match the `''^toys/(?P<pk>[0-9]+)$''` regular expression and run the `views.toy_detail`
    function, that is, the `toy_detail` function declared within the `toys/views.py`
    file. The function receives `request` and `pk` as parameters because the URL pattern
    passes the number specified after `/toys/` in the `pk` parameter. As the HTTP
    verb for the request is `DELETE`, the `request.method` property is equal to `''DELETE''`,
    and therefore, the function will execute the code that parses the JSON data received
    in the request. Then, the function creates a `Toy` instance from this data and
    deletes the existing toy in the database. If the toy was successfully deleted
    in the database, the function returns an HTTP `204 No Content` status code. The
    following lines show an example response to the HTTP request after successfully
    deleting an existing toy:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组成并发送以下HTTP请求：`DELETE http://localhost:8000/toys/4`。请求在`/toys/`之后有一个数字，因此它将匹配正则表达式`'^toys/(?P<pk>[0-9]+)$'`并运行`views.toy_detail`函数，即`toys/views.py`文件中声明的`toy_detail`函数。该函数接收`request`和`pk`作为参数，因为URL模式将`/toys/`之后指定的数字传递给`pk`参数。由于请求的HTTP动词是`DELETE`，所以`request.method`属性等于`'DELETE'`，因此该函数将执行解析请求中接收到的JSON数据的代码。然后，该函数从这个数据创建一个`Toy`实例并删除数据库中的现有玩具。如果玩具在数据库中成功删除，则函数返回HTTP
    `204 No Content`状态码。以下行显示了成功删除现有玩具后的HTTP请求的示例响应：
- en: '[PRE36]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Making HTTP GET requests with Postman
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Postman进行HTTP GET请求
- en: Now, we will use one of the GUI tools we installed in [Chapter 1](dj-rst-websvc_ch11.html),
    *Installing the Required Software and Tools*, specifically Postman. We will use
    this GUI tool to compose and send HTTP requests to the web service.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用我们在[第1章](dj-rst-websvc_ch11.html)中安装的GUI工具之一，即Postman。我们将使用此GUI工具来组成并发送HTTP请求到Web服务。
- en: The first time you execute Postman, you will see a modal that provides shortcuts
    to the most common operations. Make sure you close this modal so that we can focus
    on the main UI for Postman.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行Postman时，您将看到一个模态窗口，提供对最常见操作的快捷方式。请确保您关闭此模态窗口，以便我们可以专注于Postman的主UI。
- en: We will use the Builder tab in Postman to easily compose and send diverse HTTP
    requests to `localhost:8000` and test the RESTful Web Service with this GUI tool.
    Postman doesn't support curl-like shorthand for localhost, and therefore, we cannot
    use the same shorthand we have been using when composing requests with HTTPie.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Postman中的“构建器”选项卡来轻松地组成并发送各种HTTP请求到`localhost:8000`，并使用此GUI工具测试RESTful
    Web服务。Postman不支持curl-like的localhost简写，因此我们无法在用HTTPie组成请求时使用相同的简写。
- en: 'Select GET in the drop-down menu on the left-hand side of the Enter request
    URL textbox, and enter `localhost:8000/toys/` in this textbox on the right-hand
    side of the drop-down menu. Then, click Send and Postman will display the following
    information:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在“输入请求URL”文本框左侧的下拉菜单中选择“GET”，并在下拉菜单右侧的文本框中输入`localhost:8000/toys/`。然后，点击发送，Postman将显示以下信息：
- en: 'Status: `200 OK`.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态：`200 OK`。
- en: 'Time: The time it took for the request to be processed.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间：请求处理所需的时间。
- en: 'Size: The approximate response size (sum of body size plus headers size).'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大小：响应的大致大小（包括主体大小和头部大小）。
- en: 'Body: The response body with all the toys formatted as JSON with syntax highlighting.
    The default view for the body is Pretty and it activates syntax highlighting.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主体：响应的主体，所有玩具以JSON格式格式化，并带有语法高亮。主体的默认视图是“美化”，并且它激活语法高亮。
- en: The following screenshot shows the JSON response body in Postman for the HTTP
    GET request to `localhost:8000/toys/`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了Postman中HTTP GET请求到`localhost:8000/toys/`的JSON响应主体。
- en: '![](img/ca8e5bd9-10b8-49a1-9119-8747a04f05f9.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ca8e5bd9-10b8-49a1-9119-8747a04f05f9.png)'
- en: Click on the Headers tab on the right-hand side of the Body and Cookies tab
    to read the response headers. The following screenshot shows the layout for the
    response headers that Postman displays for the previous response. Notice that
    Postman displays the Status on the right-hand side of the response and doesn't
    include it as the first line of the key-value pairs that compose the headers,
    as when we worked with both the `curl` and `http` command-line utilities.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“正文”和“Cookies”选项卡右侧的“头部”选项卡来读取响应头部。以下截图显示了 Postman 为之前响应显示的响应头部布局。请注意，Postman
    在响应右侧显示状态，并且不将其包括在头部键值对的第一个行中，就像我们使用 `curl` 和 `http` 命令行工具时那样。
- en: '![](img/3ce07f6d-f8a9-4954-956b-e0ad58987534.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3ce07f6d-f8a9-4954-956b-e0ad58987534.png)'
- en: Making HTTP POST requests with Postman
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Postman 制作 HTTP POST 请求
- en: 'Now, we will use the Builder tab in Postman to compose and send an HTTP POST
    request to create a new toy. Perform the following steps:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用 Postman 中的“构建器”选项卡来编写并发送一个 HTTP POST 请求以创建一个新的玩具。请执行以下步骤：
- en: Click on the plus (**+**) button on the right-hand side of the tab that displayed
    the previous request. This way, you will create a new tab.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击显示上一个请求的选项卡右侧的加号（**+**）按钮。这样，您将创建一个新的选项卡。
- en: Select Request in the New drop-down menu located in the upper-left corner.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在位于右上角的“新建”下拉菜单中选择“请求”。
- en: Select POST in the drop-down menu on the left-hand side of the Enter request
    URL textbox.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“输入请求 URL”文本框左侧的下拉菜单中选择“POST”。
- en: Enter `localhost:8000/toys/` in that textbox on the right-hand side of the drop-down
    menu.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧的下拉菜单中的文本框中输入 `localhost:8000/toys/`。
- en: Click Body on the right-hand side of Authorization and Headers, within the panel
    that composes the request.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“正文”选项卡中，点击“正文”位于“授权”和“头部”右侧，在编写请求的面板中。
- en: Activate the raw radio button and select JSON (application/json) in the drop-down
    menu on the right-hand side of the binary radio button. Postman will automatically
    add a `Content-type = application/json` header, and therefore, you will notice
    the Headers tab will be renamed to Headers (1), indicating to us that there is
    one key-value pair specified for the request headers.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 激活“原始”单选按钮，并在二进制单选按钮右侧的下拉菜单中选择“JSON (application/json)”。Postman 将自动添加 `Content-type
    = application/json` 头部，因此您会注意到“头部”选项卡将被重命名为“头部（1）”，这表示我们已为请求头部指定了一个键值对。
- en: 'Enter the following lines in the textbox below the radio buttons, within the
    Body tab:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在单选按钮下方的文本框中输入以下行：
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following screenshot shows the request body in Postman:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 Postman 中的请求正文：
- en: '![](img/c6eb6181-8157-4d1b-aab0-acba39bb9d62.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c6eb6181-8157-4d1b-aab0-acba39bb9d62.png)'
- en: 'We followed the necessary steps to create an HTTP POST request with a JSON
    body that specifies the necessary key-value pairs to create a new toy. Click Send
    and Postman will display the following information:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遵循了创建具有 JSON 主体和指定创建新玩具所需键值对的 HTTP POST 请求的必要步骤。点击“发送”，Postman 将显示以下信息：
- en: 'Status: `201 Created`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态：`201 已创建`
- en: 'Time: The time it took for the request to be processed'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间：请求处理所需的时间
- en: 'Size: The approximate response size (sum of body size plus headers size)'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大小：响应的大致大小（正文大小加头部大小之和）
- en: 'Body: The response body with the recently added toy formatted as JSON with
    syntax highlighting'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正文：以 JSON 格式格式化并带有语法高亮的最近添加的玩具的响应正文
- en: 'The following screenshot shows the JSON response body in Postman for the HTTP
    POST request:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 Postman 中 HTTP POST 请求的 JSON 响应正文：
- en: '![](img/6405c361-5bce-4de4-a0cf-c2ae264a7139.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6405c361-5bce-4de4-a0cf-c2ae264a7139.png)'
- en: If we want to compose and send an HTTP PUT request with Postman, it is necessary
    to follow the previously explained steps to provide JSON data within the request
    body.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用 Postman 编写并发送一个 HTTP PUT 请求，必须遵循之前解释的步骤，在请求体中提供 JSON 数据。
- en: 'One of the nice features included in Postman is that we can easily review and
    run the HTTP requests we have made again by browsing the saved History shown on
    the left-hand side of the Postman window. The History panel displays a list with
    the HTTP verb followed by the URL for each HTTP request we have composed and sent.
    We just need to click on the desired HTTP request and click Send to run it again.
    The following screenshot shows the many HTTP requests in the History panel and
    the first HTTP GET request that was executed selected so it can be easily resent:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Postman包含的一个很好的功能是，我们可以通过浏览Postman窗口左侧显示的已保存历史记录，轻松地回顾和再次运行我们已发送的HTTP请求。历史记录面板显示了一个列表，其中包含每个我们编写的HTTP请求的HTTP动词和URL。我们只需点击所需的HTTP请求，然后点击发送即可再次运行它。以下截图显示了历史记录面板中的许多HTTP请求和第一个执行的HTTP
    GET请求，以便可以轻松地重新发送：
- en: '![](img/8bcea9b6-c921-4579-a657-906a1762f270.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8bcea9b6-c921-4579-a657-906a1762f270.png)'
- en: Test your knowledge
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: 'Let''s see whether you can answer the following questions correctly:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否能正确回答以下问题：
- en: 'The `urlpatterns` list declared in the `urls.py` file makes it possible to:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`urls.py`文件中声明的`urlpatterns`列表使得以下操作成为可能：
- en: Route URLs to Django models
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将URL路由到Django模型
- en: Route URLs to Django views
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将URL路由到Django视图
- en: Route URLs to Python primitives
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将URL路由到Python原始类型
- en: When the Django server receives an HTTP request, Django creates an instance
    of which of the following classes?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当Django服务器接收到HTTP请求时，Django会创建以下哪个类的实例？
- en: '`django.restframework.HttpRequest`'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`django.restframework.HttpRequest`'
- en: '`django.http.HttpRequest`'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`django.http.HttpRequest`'
- en: '`django.http.Request`'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`django.http.Request`'
- en: A view function has to return an instance of which of the following classes?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视图函数必须返回以下哪个类的实例？
- en: '`django.http.HttpResponse`'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`django.http.HttpResponse`'
- en: '`django.http.Response`'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`django.http.Response`'
- en: '`django.restfremework.HttpResponse`'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`django.restfremework.HttpResponse`'
- en: Whenever you have to return a specific status different from the default `200
    OK` status, it is a good practice to use the module variables defined in which
    of the following modules?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当你需要返回一个与默认`200 OK`状态不同的特定状态时，使用以下哪个模块中定义的模块变量是一个好习惯？
- en: '`rest_framework.HttpStatus`'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rest_framework.HttpStatus`'
- en: '`django.status`'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`django.status`'
- en: '`rest_framework.status`'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rest_framework.status`'
- en: If you want to retrieve a Toy instance whose primary key value is equal to `10`
    and save it in the toy variable, which line of code would you write?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想检索一个主键值等于`10`的Toy实例并将其保存到toy变量中，你应该编写哪一行代码？
- en: toy = Toy.get_by(pk=10)
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: toy = Toy.get_by(pk=10)
- en: toy = Toy.objects.all(pk=10)
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: toy = Toy.objects.all(pk=10)
- en: toy = Toy.objects.get(pk=pk)
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: toy = Toy.objects.get(pk=pk)
- en: The rights answers are included in the [Appendix](https://cdp.packtpub.com/django_restful_web_services__/wp-admin/post.php?post=44&action=edit#post_454), *Solutions*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 正确答案包含在[附录](https://cdp.packtpub.com/django_restful_web_services__/wp-admin/post.php?post=44&action=edit#post_454)，*解决方案*中。
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we executed our first version of a simple Django RESTful Web
    Service that interacts with an SQLite database. We wrote API views to process
    diverse HTTP requests on a collection of toys and on a specific toy. We worked
    with the following HTTP verbs: GET, POST, and PUT. We configured the URL patterns
    list to route URLs to views.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们执行了第一个版本的简单Django RESTful Web服务，该服务与SQLite数据库交互。我们编写了API视图来处理玩具集合和特定玩具上的各种HTTP请求。我们使用了以下HTTP动词：GET、POST和PUT。我们配置了URL模式列表，将URL路由到视图。
- en: Then, we started the Django development server and we used command-line tools
    (curl and HTTPie) to compose and send diverse HTTP requests to our RESTful Web
    Service. We learned how HTTP requests were processed in Django and our code. Finally,
    we worked with Postman, a GUI tool, to compose and send other HTTP requests to
    our RESTful Web Service.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们启动了Django开发服务器，并使用命令行工具（curl和HTTPie）向我们的RESTful Web服务发送各种HTTP请求。我们学习了Django和我们的代码如何处理HTTP请求。最后，我们使用Postman，一个图形用户界面工具，来编写并发送其他HTTP请求到我们的RESTful
    Web服务。
- en: Now that we understand the basics of a RESTful Web Service with Django REST
    framework and a simple SQLite database, we will work with a seriously powerful
    PostgreSQL database, use class-based views instead of function views, and we will
    take advantage of advanced features included in Django REST framework to work
    with different content types, without writing a huge amount of code. We will cover
    these topics in the next chapter.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了使用 Django REST framework 和简单的 SQLite 数据库构建 RESTful Web Service 的基础知识，我们将使用一个功能强大的
    PostgreSQL 数据库，使用基于类的视图代替函数视图，并且我们将利用 Django REST framework 中包含的先进功能来处理不同的内容类型，而无需编写大量代码。我们将在下一章中介绍这些主题。
