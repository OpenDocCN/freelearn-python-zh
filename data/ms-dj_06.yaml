- en: Chapter 6. Forms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。表单
- en: HTML forms are the backbone of interactive websites, from the simplicity of
    Google's single search box to ubiquitous blog comment submission forms to complex
    custom data-entry interfaces.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: HTML表单是交互式网站的支柱，从谷歌的单个搜索框的简单性到无处不在的博客评论提交表单到复杂的自定义数据输入界面。
- en: This chapter covers how you can use Django to access user-submitted form data,
    validate it and do something with it. Along the way, we'll cover `HttpRequest`
    and `Form` objects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了如何使用Django访问用户提交的表单数据，对其进行验证并执行某些操作。在此过程中，我们将涵盖`HttpRequest`和`Form`对象。
- en: Getting data from the Request Object
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从请求对象获取数据
- en: 'I introduced `HttpRequest` objects in [Chapter 2](ch02.xhtml "Chapter 2. Views
    and URLconfs"), *Views and URLconfs*, when we first covered view functions, but
    I didn''t have much to say about them at the time. Recall that each view function
    takes an `HttpRequest` object as its first parameter, as in our `hello()` view:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第2章](ch02.xhtml "第2章。视图和URLconfs")中介绍了`HttpRequest`对象，*视图和URLconfs*，当时我们首次涵盖了视图函数，但那时我对它们没有太多可说的。回想一下，每个视图函数都以`HttpRequest`对象作为其第一个参数，就像我们的`hello()`视图一样：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`HttpRequest` objects, such as the variable `request` here, have a number of
    interesting attributes and methods that you should familiarize yourself with,
    so that you know what''s possible. You can use these attributes to get information
    about the current request (that is, the user/web browser that''s loading the current
    page on your Django-powered site), at the time the view function is executed.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpRequest`对象，比如这里的变量`request`，有许多有趣的属性和方法，您应该熟悉它们，以便了解可能发生的情况。您可以使用这些属性来获取有关当前请求的信息（即加载Django站点上当前页面的用户/网络浏览器）在执行视图函数时。'
- en: Information about the URL
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于URL的信息
- en: '`HttpRequest` objects contain several pieces of information about the currently
    requested URL (*Table 6.1*).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpRequest`对象包含有关当前请求的URL的几个信息（*表6.1*）。'
- en: '| Attribute/method | Description | Example |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| 属性/方法 | 描述 | 示例 |'
- en: '| `request.path` | The full path, not including the domain but including the
    leading slash. | `"/hello/"` |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| `request.path` | 完整路径，不包括域名，但包括前导斜杠。 | `"/hello/"` |'
- en: '| `request.get_host()` | The host (that is, the "domain," in common parlance).
    | `"127.0.0.1:8000"` or `"www.example.com"` |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| `request.get_host()` | 主机（即俗称的“域名”）。 | `"127.0.0.1:8000"`或`"www.example.com"`
    |'
- en: '| `request.get_full_path()` | The `path`, plus a query string (if available).
    | `"/hello/?print=true"` |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| `request.get_full_path()` | `path`，加上查询字符串（如果有的话）。 | `"/hello/?print=true"`
    |'
- en: '| `request.is_secure()` | `True` if the request was made via HTTPS. Otherwise,
    `False`. | `True` or `False` |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `request.is_secure()` | 如果请求是通过HTTPS进行的，则为`True`。否则为`False`。 | `True`或`False`
    |'
- en: 'Table 6.1: HttpRequest methods and attributes'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.1：HttpRequest方法和属性
- en: 'Always use these attributes/methods instead of hard-coding URLs in your views.
    This makes for more flexible code that can be reused in other places. A simplistic
    example:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 始终使用这些属性/方法，而不是在视图中硬编码URL。这样可以使代码更灵活，可以在其他地方重用。一个简单的例子：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Other information about the Request
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求对象的其他信息
- en: '`request.META` is a Python dictionary containing all available HTTP headers
    for the given request-including the user''s IP address and user agent (generally
    the name and version of the web browser). Note that the full list of available
    headers depends on which headers the user sent and which headers your web server
    sets. Some commonly available keys in this dictionary are:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`request.META`是一个Python字典，包含给定请求的所有可用HTTP标头-包括用户的IP地址和用户代理（通常是Web浏览器的名称和版本）。请注意，可用标头的完整列表取决于用户发送了哪些标头以及您的Web服务器设置了哪些标头。该字典中一些常用的键是：'
- en: '`HTTP_REFERER`: The referring URL, if any. (Note the misspelling of `REFERER`).'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_REFERER`：引用的URL，如果有的话。（请注意`REFERER`的拼写错误）。'
- en: '`HTTP_USER_AGENT`: The user''s browser''s user-agent string, if any. This looks
    something like: `"Mozilla/5.0 (X11; U; Linux i686; fr-FR; rv:1.8.1.17) Gecko/20080829
    Firefox/2.0.0.17"`.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_USER_AGENT`：用户的浏览器的用户代理字符串，如果有的话。它看起来像这样：`"Mozilla/5.0 (X11; U; Linux
    i686; fr-FR; rv:1.8.1.17) Gecko/20080829 Firefox/2.0.0.17"`。'
- en: '`REMOTE_ADDR`: The IP address of the client, for example, `"12.345.67.89"`.
    (If the request has passed through any proxies, then this might be a comma-separated
    list of IP addresses, for example, `"12.345.67.89,23.456.78.90"`).'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`REMOTE_ADDR`：客户端的IP地址，例如`"12.345.67.89"`。（如果请求通过任何代理，则这可能是一个逗号分隔的IP地址列表，例如`"12.345.67.89,23.456.78.90"`）。'
- en: 'Note that because `request.META` is just a basic Python dictionary, you''ll
    get a `KeyError` exception if you try to access a key that doesn''t exist. (Because
    HTTP headers are external data-that is, they''re submitted by your users'' browsers-they
    shouldn''t be trusted, and you should always design your application to fail gracefully
    if a particular header is empty or doesn''t exist.) You should either use a `try`/`except`
    clause or the `get()` method to handle the case of undefined keys:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，因为`request.META`只是一个基本的Python字典，如果您尝试访问一个不存在的键，您将得到一个`KeyError`异常。（因为HTTP标头是外部数据-即它们是由您的用户的浏览器提交的-所以不应该信任它们，您应该始终设计您的应用程序，以便在特定标头为空或不存在时优雅地失败。）您应该使用`try`/`except`子句或`get()`方法来处理未定义键的情况：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'I encourage you to write a small view that displays all of the `request.META`
    data so you can get to know what''s in there. Here''s what that view might look
    like:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励您编写一个小视图，显示所有`request.META`数据，以便了解其中的内容。以下是该视图的样子：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Another good way to see what sort of information that the request object contains
    is to look closely at the Django error pages when you crash the system-there is
    a wealth of useful information in there, including all the HTTP headers and other
    request objects (`request.path` for example).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 查看请求对象包含的信息的另一种好方法是仔细查看Django错误页面，当您使系统崩溃时-那里有大量有用的信息，包括所有HTTP标头和其他请求对象（例如`request.path`）。
- en: Information about submitted data
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有关提交数据的信息
- en: 'Beyond basic metadata about the request, `HttpRequest` objects have two attributes
    that contain information submitted by the user: `request.GET` and `request.POST`.
    Both of these are dictionary-like objects that give you access to `GET` and `POST`
    data.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 关于请求的基本元数据之外，`HttpRequest`对象有两个属性，包含用户提交的信息：`request.GET`和`request.POST`。这两个都是类似字典的对象，可以访问`GET`和`POST`数据。
- en: '`POST` data generally is submitted from an HTML `<form>`, while `GET` data
    can come from a `<form>` or the query string in the page''s URL.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST`数据通常是从HTML `<form>`提交的，而`GET`数据可以来自页面URL中的`<form>`或查询字符串。'
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Dictionary-like objects**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**类似字典的对象**'
- en: When we say `request.GET` and `request.POST` are *dictionary-like* objects,
    we mean that they behave like standard Python dictionaries but aren't technically
    dictionaries under the hood. For example, `request.GET` and `request.POST` both
    have `get()`, `keys()` and `values()` methods, and you can iterate over the keys
    by doing `for key in request.GET`. So why the distinction? Because both `request.GET`
    and `request.POST` have additional methods that normal dictionaries don't have.
    We'll get into these in a short while. You might have encountered the similar
    term *file-like objects*-Python objects that have a few basic methods, like `read()`,
    that let them act as stand-ins for "real" file objects.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说`request.GET`和`request.POST`是*类似字典*的对象时，我们的意思是它们的行为类似于标准的Python字典，但在技术上并不是字典。例如，`request.GET`和`request.POST`都有`get()`、`keys()`和`values()`方法，您可以通过`for
    key in request.GET`来遍历键。那么为什么要区分呢？因为`request.GET`和`request.POST`都有标准字典没有的额外方法。我们将在短时间内介绍这些方法。您可能遇到过类似的术语*类似文件*的对象-具有一些基本方法（如`read()`）的Python对象，让它们可以充当"真实"文件对象的替代品。
- en: A simple form-handling example
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的表单处理示例
- en: 'Continuing the ongoing example of books, authors and publishers, let''s create
    a simple view that lets users search our book database by title. Generally, there
    are two parts to developing a form: the HTML user interface and the backend view
    code that processes the submitted data. The first part is easy; let''s just set
    up a view that displays a search form:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 继续图书、作者和出版商的示例，让我们创建一个简单的视图，让用户通过标题搜索我们的图书数据库。通常，开发表单有两个部分：HTML用户界面和处理提交数据的后端视图代码。第一部分很容易；让我们设置一个显示搜索表单的视图：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you learned in [Chapter 3](ch03.xhtml "Chapter 3. Templates"), *Templates*,
    this view can live anywhere on your Python path. For sake of argument, put it
    in `books/views.py`. The accompanying template, `search_form.html`, could look
    like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在[第3章](ch03.xhtml "第3章。模板")中学到的，这个视图可以存在于Python路径的任何位置。为了论证，将其放在`books/views.py`中。相应的模板`search_form.html`可能如下所示：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Save this file to your `mysite/templates` directory you created in [Chapter
    3](ch03.xhtml "Chapter 3. Templates"), *Templates*, or you can create a new folder
    `books/templates`. Just make sure you have `''APP_DIRS''` in your settings file
    set to `True`. The URLpattern in `urls.py` could look like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存到您在[第3章](ch03.xhtml "第3章。模板")中创建的`mysite/templates`目录中，*模板*，或者您可以创建一个新的文件夹`books/templates`。只需确保您的设置文件中的`'APP_DIRS'`设置为`True`。`urls.py`中的URL模式可能如下所示：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '(Note that we''re importing the `views` module directly, instead of something
    like `from mysite.views import search_form`, because the former is less verbose.
    We''ll cover this importing approach in more detail in [Chapter 7](ch07.xhtml
    "Chapter 7. Advanced Views and URLconfs"), *Advanced Views and Urlconfs*). Now,
    if you run the development server and visit `http://127.0.0.1:8000/search-form/`,
    you''ll see the search interface. Simple enough. Try submitting the form, though,
    and you''ll get a Django 404 error. The form points to the URL `/search/`, which
    hasn''t yet been implemented. Let''s fix that with a second view function:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: （请注意，我们直接导入`views`模块，而不是像`from mysite.views import search_form`这样的方式，因为前者更简洁。我们将在[第7章](ch07.xhtml
    "第7章。高级视图和URLconfs")中更详细地介绍这种导入方法，*高级视图和URLconfs*）。现在，如果您运行开发服务器并访问`http://127.0.0.1:8000/search-form/`，您将看到搜索界面。足够简单。不过，尝试提交表单，您将收到Django
    404错误。表单指向URL`/search/`，但尚未实现。让我们用第二个视图函数来修复这个问题：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For the moment, this merely displays the user''s search term, so we can make
    sure the data is being submitted to Django properly, and so you can get a feel
    for how the search term flows through the system. In short:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这只是显示用户的搜索词，这样我们可以确保数据被正确提交到Django，并且您可以感受搜索词是如何在系统中流动的。简而言之：
- en: The HTML `<form>` defines a variable `q`. When it's submitted, the value of
    `q` is sent via `GET` (`method="get"`) to the URL `/search/`.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML `<form>`定义了一个变量`q`。当提交时，`q`的值通过`GET`（`method="get"`）发送到URL`/search/`。
- en: The Django view that handles the URL `/search/` (`search()`) has access to the
    `q` value in `request.GET`.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理URL`/search/`（`search()`）的Django视图可以访问`request.GET`中的`q`值。
- en: 'An important thing to point out here is that we explicitly check that `''q''`
    exists in `request.GET`. As I pointed out in the `request.META` section preceding,
    you shouldn''t trust anything submitted by users or even assume that they''ve
    submitted anything in the first place. If we didn''t add this check, any submission
    of an empty form would raise `KeyError` in the view:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要指出的一个重要事情是，我们明确检查`request.GET`中是否存在`'q'`。正如我在前面的`request.META`部分中指出的，您不应信任用户提交的任何内容，甚至不应假设他们首先提交了任何内容。如果我们没有添加这个检查，任何空表单的提交都会在视图中引发`KeyError`：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Query string parameters
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询字符串参数
- en: Because `GET` data is passed in the query string (for example, `/search/?q=django`),
    you can use `request.GET` to access query string variables. In [Chapter 2](ch02.xhtml
    "Chapter 2. Views and URLconfs"), *Views and Urlconfs*, introduction of Django's
    URLconf system, I compared Django's pretty URLs to more traditional PHP/Java URLs
    such as `/time/plus?hours=3` and said I'd show you how to do the latter in [Chapter
    6](ch06.xhtml "Chapter 6. Forms"), *Forms*. Now you know how to access query string
    parameters in your views (like `hours=3` in this example)-use `request.GET`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`GET`数据是通过查询字符串传递的（例如，`/search/?q=django`），您可以使用`request.GET`来访问查询字符串变量。在[第2章](ch02.xhtml
    "第2章。视图和URLconfs")中，*视图和URLconfs*，介绍了Django的URLconf系统，我将Django的美观URL与更传统的PHP/Java
    URL进行了比较，例如`/time/plus?hours=3`，并说我会在[第6章](ch06.xhtml "第6章。表单")中向您展示如何做后者。现在您知道如何在视图中访问查询字符串参数（例如在这个示例中的`hours=3`）-使用`request.GET`。
- en: '`POST` data works the same way as `GET` data-just use `request.POST` instead
    of `request.GET`. What''s the difference between `GET` and `POST`? Use `GET` when
    the act of submitting the form is just a request to get data. Use `POST` whenever
    the act of submitting the form will have some side effect-*changing* data, or
    sending an e-mail, or something else that''s beyond simple *display* of data.
    In our book search example, we''re using `GET` because the query doesn''t change
    any data on our server. (See the http://www.w3.org/2001/tag/doc/whenToUseGet.html
    site) if you want to learn more about `GET` and `POST`.) Now that we''ve verified
    `request.GET` is being passed in properly, let''s hook the user''s search query
    into our book database (again, in `views.py`):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST`数据的工作方式与`GET`数据相同-只需使用`request.POST`而不是`request.GET`。`GET`和`POST`之间有什么区别？当提交表单的行为只是获取数据时使用`GET`。当提交表单的行为会产生一些副作用-更改数据、发送电子邮件或其他超出简单数据*显示*的操作时使用`POST`。在我们的图书搜索示例中，我们使用`GET`，因为查询不会改变服务器上的任何数据。（如果您想了解更多关于`GET`和`POST`的信息，请参阅http://www.w3.org/2001/tag/doc/whenToUseGet.html网站。）现在我们已经验证了`request.GET`是否被正确传递，让我们将用户的搜索查询连接到我们的图书数据库中（同样是在`views.py`中）：'
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A couple of notes on what we did here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们在这里所做的一些说明：
- en: Aside from checking that `'q'` exists in `request.GET`, we also make sure that
    `request.GET['q']` is a non-empty value before passing it to the database query.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了检查`'q'`是否存在于`request.GET`中，我们还确保在将其传递给数据库查询之前，`request.GET['q']`是一个非空值。
- en: We're using `Book.objects.filter(title__icontains=q)` to query our book table
    for all books whose title includes the given submission. The `icontains` is a
    lookup type (as explained in [Chapter 4](ch04.xhtml "Chapter 4. Models"), *Models*,
    and [Appendix B](apb.xhtml "Appendix B. Database API Reference"), *Database API
    Reference*), and the statement can be roughly translated as "Get the books whose
    title contains `q`, without being case-sensitive."
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`Book.objects.filter(title__icontains=q)`来查询我们的图书表，找到标题包含给定提交的所有书籍。`icontains`是一种查找类型（如[第4章](ch04.xhtml
    "第4章。模型")和[附录B](apb.xhtml "附录B。数据库API参考")中所解释的那样），该语句可以粗略地翻译为“获取标题包含`q`的书籍，而不区分大小写。”
- en: This is a very simple way to do a book search. We wouldn't recommend using a
    simple `icontains` query on a large production database, as it can be slow. (In
    the real world, you'd want to use a custom search system of some sort. Search
    the web for *open-source full-text search* to get an idea of the possibilities.)
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个非常简单的图书搜索方法。我们不建议在大型生产数据库上使用简单的`icontains`查询，因为它可能会很慢。（在现实世界中，您可能希望使用某种自定义搜索系统。搜索网络以获取*开源全文搜索*的可能性。）
- en: 'We pass `books`, a list of `Book` objects, to the template. The `search_results.html`
    file might include something like this:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`books`，一个`Book`对象的列表，传递给模板。`search_results.html`文件可能包括类似以下内容：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note usage of the `pluralize` template filter, which outputs an "s" if appropriate,
    based on the number of books found.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用`pluralize`模板过滤器，根据找到的书籍数量输出“s”。
- en: Improving our simple form-handling example
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进我们简单的表单处理示例
- en: As in previous chapters, I've shown you the simplest thing that could possibly
    work. Now I'll point out some problems and show you how to improve it. First,
    our `search()` view's handling of an empty query is poor-we're just displaying
    a **Please submit a search term.** message, requiring the user to hit the browser's
    back button.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前的章节一样，我向您展示了可能起作用的最简单的方法。现在我将指出一些问题，并向您展示如何改进它。首先，我们的`search()`视图对空查询的处理很差-我们只显示一个**请提交搜索词。**消息，要求用户点击浏览器的返回按钮。
- en: 'This is horrid and unprofessional, and if you ever actually implement something
    like this in the wild, your Django privileges will be revoked. It would be much
    better to redisplay the form, with an error preceding to it, so that the user
    can try again immediately. The easiest way to do that would be to render the template
    again, like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可怕的，不专业的，如果您真的在实际中实现了这样的东西，您的Django权限将被撤销。更好的方法是重新显示表单，并在其前面显示一个错误，这样用户可以立即重试。最简单的方法是再次渲染模板，就像这样：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '(Note that I''ve included `search_form()` here so you can see both views in
    one place.) Here, we''ve improved `search()` to render the `search_form.html`
    template again, if the query is empty. And because we need to display an error
    message in that template, we pass a template variable. Now we can edit `search_form.html`
    to check for the `error` variable:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: （请注意，我在这里包括了`search_form()`，这样您就可以在一个地方看到两个视图。）在这里，我们改进了`search()`，如果查询为空，就重新渲染`search_form.html`模板。因为我们需要在该模板中显示错误消息，所以我们传递了一个模板变量。现在我们可以编辑`search_form.html`来检查`error`变量：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can still use this template from our original view, `search_form()`, because
    `search_form()` doesn''t pass `error` to the template-so the error message won''t
    show up in that case. With this change in place, it''s a better application, but
    it now begs the question: is a dedicated `search_form()` view really necessary?'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以从我们原始的视图`search_form()`中使用这个模板，因为`search_form()`不会将`error`传递给模板，所以在这种情况下不会显示错误消息。有了这个改变，这是一个更好的应用程序，但现在问题是：是否真的需要一个专门的`search_form()`视图？
- en: 'As it stands, a request to the URL `/search/` (without any `GET` parameters)
    will display the empty form (but with an error). We can remove the `search_form()`
    view, along with its associated URLpattern, as long as we change `search()` to
    hide the error message when somebody visits `/search/` with no `GET` parameters:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，对URL`/search/`（没有任何`GET`参数）的请求将显示空表单（但带有错误）。只要我们在没有`GET`参数的情况下访问`/search/`，就可以删除`search_form()`视图及其相关的URLpattern，同时将`search()`更改为在有人访问`/search/`时隐藏错误消息：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this updated view, if a user visits `/search/` with no `GET` parameters,
    they'll see the search form with no error message. If a user submits the form
    with an empty value for `'q'`, they'll see the search form with an error message.
    And, finally, if a user submits the form with a non-empty value for `'q'`, they'll
    see the search results.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个更新的视图中，如果用户在没有`GET`参数的情况下访问`/search/`，他们将看到没有错误消息的搜索表单。如果用户提交了一个空值的`'q'`，他们将看到带有错误消息的搜索表单。最后，如果用户提交了一个非空值的`'q'`，他们将看到搜索结果。
- en: 'We can make one final improvement to this application, to remove a bit of redundancy.
    Now that we''ve rolled the two views and URLs into one and `/search/` handles
    both search-form display and result display, the HTML `<form>` in `search_form.html`
    doesn''t have to hard-code a URL. Instead of this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对此应用进行最后一次改进，以消除一些冗余。现在我们已经将两个视图和URL合并为一个，并且`/search/`处理搜索表单显示和结果显示，`search_form.html`中的HTML`<form>`不必硬编码URL。而不是这样：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It can be changed to this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 可以更改为这样：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `action=""` means *Submit the form to the same URL as the current page.*
    With this change in place, you won't have to remember to change the `action` if
    you ever hook the `search()` view to another URL.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`action=""` 表示*将表单提交到与当前页面相同的URL*。有了这个改变，如果您将`search()`视图连接到另一个URL，您就不必记得更改`action`。'
- en: Simple validation
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单验证
- en: 'Our search example is still reasonably simple, particularly in terms of its
    data validation; we''re merely checking to make sure the search query isn''t empty.
    Many HTML forms include a level of validation that''s more complex than making
    sure the value is non-empty. We''ve all seen the error messages on websites:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的搜索示例仍然相当简单，特别是在数据验证方面；我们只是检查确保搜索查询不为空。许多HTML表单包括比确保值非空更复杂的验证级别。我们都在网站上看到过错误消息：
- en: '*Please enter a valid e-mail address. ''foo'' is not an e-mail address.*'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*请输入一个有效的电子邮件地址。''foo''不是一个电子邮件地址。*'
- en: '*Please enter a valid five-digit U.S. ZIP code. ''123'' is not a ZIP code.*'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*请输入一个有效的五位数字的美国邮政编码。''123''不是一个邮政编码。*'
- en: '*Please enter a valid date in the format YYYY-MM-DD.*'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*请输入格式为YYYY-MM-DD的有效日期。*'
- en: '*Please enter a password that is at least 8 characters long and contains at
    least one number.*'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*请输入至少8个字符长且至少包含一个数字的密码。*'
- en: Let's tweak our `search()` view so that it validates that the search term is
    less than or equal to 20 characters long. (For sake of example, let's say anything
    longer than that might make the query too slow.) How might we do that?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调整我们的`search()`视图，以验证搜索词是否少于或等于20个字符长。（举个例子，假设超过这个长度可能会使查询变得太慢。）我们该如何做到这一点？
- en: 'The simplest possible thing would be to embed the logic directly in the view,
    like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是直接在视图中嵌入逻辑，如下所示：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, if you try submitting a search query greater than 20 characters long,
    it won''t let you search; you''ll get an error message. But that error message
    in `search_form.html` currently says `"Please submit a search term".`-so we''ll
    have to change it to be accurate for both cases:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您尝试提交一个超过20个字符长的搜索查询，它将不允许您进行搜索；您将收到一个错误消息。但是`search_form.html`中的错误消息目前说：“请提交搜索词”。-所以我们必须更改它以适应两种情况：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: There's something ugly about this. Our one-size-fits-all error message is potentially
    confusing. Why should the error message for an empty form submission mention anything
    about a 20-character limit?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些不好的地方。我们的一刀切错误消息可能会令人困惑。为什么空表单提交的错误消息要提及20个字符的限制？
- en: 'Error messages should be specific, unambiguous and not confusing. The problem
    is in the fact that we''re using a simple Boolean value for `error`, whereas we
    should be using a list of error message strings. Here''s how we might fix that:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 错误消息应该是具体的、明确的，不应该令人困惑。问题在于我们使用了一个简单的布尔值`error`，而我们应该使用一个错误消息字符串列表。以下是我们可能如何修复它：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we need make a small tweak to the `search_form.html` template to reflect
    that it''s now passed an `errors` list instead of an `error` Boolean value:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要对`search_form.html`模板进行小的调整，以反映它现在传递了一个`errors`列表，而不是一个`error`布尔值：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Making a contact form
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建联系表单
- en: 'Although we iterated over the book search form example several times and improved
    it nicely, it''s still fundamentally simple: just a single field, `''q''`. As
    forms get more complex, we have to repeat the preceding steps over and over again
    for each form field we use. This introduces a lot of cruft and a lot of opportunities
    for human error. Lucky for us, the Django developers thought of this and built
    into Django a higher-level library that handles form-and validation-related tasks.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们多次迭代了图书搜索表单示例并对其进行了良好的改进，但它仍然基本上很简单：只有一个字段`'q'`。随着表单变得更加复杂，我们必须一遍又一遍地重复前面的步骤，为我们使用的每个表单字段重复这些步骤。这引入了很多废料和很多人为错误的机会。幸运的是，Django的开发人员考虑到了这一点，并在Django中构建了一个处理表单和验证相关任务的更高级别库。
- en: Your first form class
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 您的第一个表单类
- en: Django comes with a form library, called `django.forms`, that handles many of
    the issues we've been exploring this chapter-from HTML form display to validation.
    Let's dive in and rework our contact form application using the Django forms framework.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Django带有一个表单库，称为`django.forms`，它处理了本章中我们探讨的许多问题-从HTML表单显示到验证。让我们深入研究并使用Django表单框架重新设计我们的联系表单应用程序。
- en: The primary way to use the forms framework is to define a `Form` class for each
    HTML `<form>` you're dealing with. In our case, we only have one `<form>`, so
    we'll have one `Form` class. This class can live anywhere you want-including directly
    in your `views.py` file-but community convention is to keep `Form` classes in
    a separate file called `forms.py`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用表单框架的主要方法是为您处理的每个HTML `<form>`定义一个`Form`类。在我们的情况下，我们只有一个`<form>`，所以我们将有一个`Form`类。这个类可以放在任何您想要的地方，包括直接放在您的`views.py`文件中，但社区约定是将`Form`类放在一个名为`forms.py`的单独文件中。
- en: 'Create this file in the same directory as your `mysite/views.py`, and enter
    the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在与您的`mysite/views.py`相同的目录中创建此文件，并输入以下内容：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is pretty intuitive, and it''s similar to Django''s model syntax. Each
    field in the form is represented by a type of `Field` class-`CharField` and `EmailField`
    are the only types of fields used here-as attributes of a `Form` class. Each field
    is required by default, so to make `email` optional, we specify `required=False`.
    Let''s hop into the Python interactive interpreter and see what this class can
    do. The first thing it can do is display itself as HTML:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是非常直观的，类似于Django的模型语法。表单中的每个字段都由`Field`类的一种类型表示-这里只使用`CharField`和`EmailField`作为`Form`类的属性。默认情况下，每个字段都是必需的，因此要使`email`可选，我们指定`required=False`。让我们进入Python交互解释器，看看这个类能做什么。它能做的第一件事是将自己显示为HTML：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Django adds a label to each field, along with `<label>` tags for accessibility.
    The idea is to make the default behavior as optimal as possible. This default
    output is in the format of an HTML `<table>`, but there are a few other built-in
    outputs:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Django为每个字段添加了标签，以及用于辅助功能的`<label>`标签。其目的是使默认行为尽可能优化。此默认输出采用HTML `<table>`格式，但还有其他几种内置输出：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note that the opening and closing `<table>`, `<ul>`, and `<form>` tags aren''t
    included in the output, so that you can add any additional rows and customization
    if necessary. These methods are just shortcuts for the common case of "display
    the entire form." You can also display the HTML for a particular field:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，输出中不包括开放和关闭的`<table>`、`<ul>`和`<form>`标签，因此您可以根据需要添加任何额外的行和自定义。这些方法只是常见情况下的快捷方式，即“显示整个表单”。您还可以显示特定字段的HTML：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The second thing `Form` objects can do is validate data. To validate data,
    create a new `Form` object and pass it a dictionary of data that maps field names
    to data:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Form`对象的第二个功能是验证数据。要验证数据，请创建一个新的`Form`对象，并将数据字典传递给它，将字段名称映射到数据：'
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once you''ve associated data with a `Form` instance, you''ve created a **bound**
    form:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您将数据与`Form`实例关联起来，就创建了一个**绑定**表单：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Call the `is_valid()` method on any bound `Form` to find out whether its data
    is valid. We''ve passed a valid value for each field, so the `Form` in its entirety
    is valid:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对任何绑定的`Form`调用`is_valid()`方法，以了解其数据是否有效。我们已为每个字段传递了有效值，因此整个`Form`都是有效的：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we don''t pass the `email` field, it''s still valid, because we''ve specified
    `required=False` for that field:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不传递`email`字段，它仍然有效，因为我们已经为该字段指定了`required=False`：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'But, if we leave off either `subject` or `message`, the `Form` is no longer
    valid:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们省略`subject`或`message`中的任何一个，`Form`将不再有效：
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can drill down to get field-specific error messages:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以深入了解特定字段的错误消息：
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Each bound `Form` instance has an `errors` attribute that gives you a dictionary
    mapping field names to error-message lists:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 每个绑定的`Form`实例都有一个`errors`属性，该属性为您提供了一个将字段名称映射到错误消息列表的字典：
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, for `Form` instances whose data has been found to be valid, a `cleaned_data`
    attribute is available. This is a dictionary of the submitted data, "cleaned up".
    Django''s forms framework not only validates data; it cleans it up by converting
    values to the appropriate Python types:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于数据已被发现有效的`Form`实例，将提供`cleaned_data`属性。这是提交的数据的“清理”。Django的表单框架不仅验证数据；它通过将值转换为适当的Python类型来清理数据：
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Our contact form only deals with strings, which are "cleaned" into string objects-but
    if we were to use an `IntegerField` or `DateField`, the forms framework would
    ensure that `cleaned_data` used proper Python integers or `datetime.date` objects
    for the given fields.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的联系表单只处理字符串，这些字符串被“清理”为字符串对象-但是，如果我们使用`IntegerField`或`DateField`，表单框架将确保`cleaned_data`使用适当的Python整数或`datetime.date`对象来表示给定字段。
- en: Tying form objects into views
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将表单对象与视图绑定
- en: 'Our contact form is not much good to us unless we have some way of displaying
    it to the user. To do this, we need to first update our `mysite/views`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 除非我们有一种方法将其显示给用户，否则我们的联系表单对我们来说没有太大用处。为此，我们首先需要更新我们的`mysite/views`：
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, we have to create our contact form (save this to `mysite/templates`):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须创建我们的联系表单（保存到`mysite/templates`）：
- en: '[PRE33]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And finally, we need to change our `urls.py` to display our contact form at
    `/contact/`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要更改我们的`urls.py`，以便在`/contact/`处显示我们的联系表单：
- en: '[PRE34]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Since we're creating a `POST` form (which can have the effect of modifying data),
    we need to worry about Cross Site Request Forgeries. Thankfully, you don't have
    to worry too hard, because Django comes with a very easy-to-use system for protecting
    against it. In short, all `POST` forms that are targeted at internal URLs should
    use the `{% csrf_token %}` template tag. More details about
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在创建一个`POST`表单（可能会导致修改数据的效果），我们需要担心跨站点请求伪造。幸运的是，您不必太担心，因为Django带有一个非常易于使用的系统来防止它。简而言之，所有针对内部URL的`POST`表单都应使用`{%
    csrf_token %}`模板标记。更多细节
- en: '`{% csrf_token %}` can be found in [Chapter 19](ch19.xhtml "Chapter 19. Security
    in Django"), *Security in Django*.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`{% csrf_token %}`可以在[第19章](ch19.xhtml "第19章。Django中的安全性")*Django中的安全性*中找到。'
- en: Try running this locally. Load the form, submit it with none of the fields filled
    out, submit it with an invalid e-mail address, then finally submit it with valid
    data. (Of course, unless you have configured a mail-server, you will get a `ConnectionRefusedError`
    when `send_mail()` is called.)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在本地运行此代码。加载表单，提交表单时没有填写任何字段，使用无效的电子邮件地址提交表单，最后使用有效数据提交表单。（当调用`send_mail()`时，除非您配置了邮件服务器，否则会收到`ConnectionRefusedError`。）
- en: Changing how fields are rendered
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改字段呈现方式
- en: 'Probably the first thing you''ll notice when you render this form locally is
    that the `message` field is displayed as an `<input type="text">`, and it ought
    to be a `<textarea>`. We can fix that by setting the field''s widget:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在本地呈现此表单时，您可能首先注意到的是`message`字段显示为`<input type="text">`，而应该是`<textarea>`。我们可以通过设置字段的小部件来解决这个问题：
- en: '[PRE35]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The forms framework separates out the presentation logic for each field into
    a set of widgets. Each field type has a default widget, but you can easily override
    the default, or provide a custom widget of your own. Think of the `Field` classes
    as representing **validation logic**, while widgets represent **presentation logic**.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 表单框架将每个字段的呈现逻辑分离为一组小部件。每种字段类型都有一个默认小部件，但您可以轻松地覆盖默认值，或者提供自定义小部件。将`Field`类视为**验证逻辑**，而小部件表示**呈现逻辑**。
- en: Setting a maximum length
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置最大长度
- en: 'One of the most common validation needs is to check that a field is of a certain
    size. For good measure, we should improve our `ContactForm` to limit the `subject`
    to 100 characters. To do that, just supply a `max_length` to the `CharField`,
    like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的验证需求之一是检查字段的大小。为了好玩，我们应该改进我们的`ContactForm`以将`subject`限制为100个字符。要做到这一点，只需向`CharField`提供`max_length`，如下所示：
- en: '[PRE36]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: An optional `min_length` argument is also available.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用可选的`min_length`参数。
- en: Setting initial values
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置初始值
- en: 'As an improvement to this form, let''s add an initial value for the `subject`
    field: `I love your site!` (A little power of suggestion can''t hurt.) To do this,
    we can use the `initial` argument when we create a `Form` instance:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对这个表单的改进，让我们为`subject`字段添加一个初始值：`I love your site!`（一点点建议的力量不会有害）。为此，我们可以在创建`Form`实例时使用`initial`参数：
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, the `subject` field will be displayed prepopulated with that kind statement.
    Note that there is a difference between passing initial data and passing data
    that binds the form. The biggest difference is that if you're just passing initial
    data, then the form will be unbound, which means it won't have any error messages.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`subject`字段将显示为预填充了这种陈述。请注意，传递初始数据和绑定表单的数据之间存在差异。最大的区别在于，如果你只是传递初始数据，那么表单将是未绑定的，这意味着它不会有任何错误消息。
- en: Custom validation rules
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义验证规则
- en: 'Imagine we''ve launched our feedback form, and the e-mails have started tumbling
    in. There''s just one problem: some of the submitted messages are just one or
    two words, which isn''t long enough for us to make sense of. We decide to adopt
    a new validation policy: four words or more, please.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们已经推出了我们的反馈表单，电子邮件已经开始涌入。只有一个问题：一些提交的消息只有一两个单词，这对我们来说不够长。我们决定采用一个新的验证策略：请至少四个单词。
- en: 'There are a number of ways to hook custom validation into a Django form. If
    our rule is something we will reuse again and again, we can create a custom field
    type. Most custom validations are one-off affairs, though, and can be tied directly
    to the `Form` class. We want additional validation on the `message` field, so
    we add a `clean_message()` method to our `Form` class:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以将自定义验证集成到Django表单中。如果我们的规则是我们将一遍又一遍地重用的，我们可以创建一个自定义字段类型。大多数自定义验证都是一次性的事务，可以直接绑定到`Form`类。我们想要在`message`字段上进行额外的验证，因此我们在`Form`类中添加了一个`clean_message()`方法：
- en: '[PRE38]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Django's form system automatically looks for any method whose name starts with
    `clean_` and ends with the name of a field. If any such method exists, it's called
    during validation. Specifically, the `clean_message()` method will be called after
    the default validation logic for a given field (in this case, the validation logic
    for a required `CharField`).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Django的表单系统会自动查找任何以`clean_`开头并以字段名称结尾的方法。如果存在这样的方法，它将在验证期间被调用。具体来说，`clean_message()`方法将在给定字段的默认验证逻辑之后被调用（在本例中，是必需的`CharField`的验证逻辑）。
- en: Because the field data has already been partially processed, we pull it out
    of `self.cleaned_data`. Also, we don't have to worry about checking that the value
    exists and is non-empty; that's done by the default validator. We naively use
    a combination of `len()` and `split()` to count the number of words. If the user
    has entered too few words, we raise a `forms.ValidationError`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因为字段数据已经部分处理，我们从`self.cleaned_data`中提取它。此外，我们不必担心检查该值是否存在且非空；这是默认验证器完成的。我们天真地使用`len()`和`split()`的组合来计算单词的数量。如果用户输入的单词太少，我们会引发一个`forms.ValidationError`。
- en: The string attached to this exception will be displayed to the user as an item
    in the error list. It's important that we explicitly return the cleaned value
    for the field at the end of the method. This allows us to modify the value (or
    convert it to a different Python type) within our custom validation method. If
    we forget the return statement, then `None` will be returned, and the original
    value will be lost.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 附加到此异常的字符串将显示为错误列表中的一项。重要的是我们明确地在方法的最后返回字段的清理值。这允许我们在自定义验证方法中修改值（或将其转换为不同的Python类型）。如果我们忘记了返回语句，那么将返回`None`，并且原始值将丢失。
- en: Specifying labels
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定标签
- en: 'By default, the labels on Django''s auto-generated form HTML are created by
    replacing underscores with spaces and capitalizing the first letter-so the label
    for the `email` field is "`Email`". (Sound familiar? It''s the same simple algorithm
    that Django''s models use to calculate default `verbose_name` values for fields.
    We covered this in [Chapter 4](ch04.xhtml "Chapter 4. Models"), *Models*). But,
    as with Django''s models, we can customize the label for a given field. Just use
    `label`, like so:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Django自动生成的表单HTML上的标签是通过用空格替换下划线并大写第一个字母来创建的-因此`email`字段的标签是"`Email`"。（听起来熟悉吗？这是Django模型用于计算字段默认`verbose_name`值的相同简单算法。我们在[第4章](ch04.xhtml
    "第4章。模型")中介绍过这一点，*模型*）。但是，与Django的模型一样，我们可以自定义给定字段的标签。只需使用`label`，如下所示：
- en: '[PRE39]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Customizing form design
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义表单设计
- en: Our `contact_form.html` template uses `{{ form.as_table }}` to display the form,
    but we can display the form in other ways to get more granular control over display.
    The quickest way to customize forms' presentation is with CSS.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`contact_form.html`模板使用`{{ form.as_table }}`来显示表单，但我们可以以其他方式显示表单，以便更精细地控制显示。自定义表单的呈现方式最快的方法是使用CSS。
- en: 'Error lists, in particular, could do with some visual enhancement, and the
    auto-generated error lists use `<ul class="errorlist">` precisely so that you
    can target them with CSS. The following CSS really makes our errors stand out:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 错误列表，特别是可以通过一些视觉增强，并且自动生成的错误列表使用`<ul class="errorlist">`，这样你就可以用CSS来定位它们。以下CSS确实让我们的错误更加突出：
- en: '[PRE40]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: While it's convenient to have our form's HTML generated for us, in many cases
    you'll want to override the default rendering. `{{ form.as_table }}` and friends
    are useful shortcuts while you develop your application, but everything about
    the way a form is displayed can be overridden, mostly within the template itself,
    and you'll probably find yourself doing this.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然为我们生成表单的HTML很方便，但在许多情况下，您可能希望覆盖默认的呈现方式。`{{ form.as_table }}`和其他方法在开发应用程序时是有用的快捷方式，但表单的显示方式可以被覆盖，主要是在模板本身内部，您可能会发现自己这样做。
- en: Each field's widget (`<input type="text">`, `<select>`, `<textarea>`, and so
    on.) can be rendered individually by accessing `{{ form.fieldname }}` in the template,
    and any errors associated with a field are available as `{{ form.fieldname.errors
    }}`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 每个字段的小部件（`<input type="text">`，`<select>`，`<textarea>`等）可以通过在模板中访问`{{ form.fieldname
    }}`来单独呈现，并且与字段相关的任何错误都可以作为`{{ form.fieldname.errors }}`获得。
- en: 'With this in mind, we can construct a custom template for our contact form
    with the following template code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们可以使用以下模板代码为我们的联系表单构建一个自定义模板：
- en: '[PRE41]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`{{ form.message.errors }}` displays a `<ul class="errorlist">` if errors are
    present and a blank string if the field is valid (or the form is unbound). We
    can also treat `form.message.errors` as a Boolean or even iterate over it as a
    list. For example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在错误，`{{ form.message.errors }}`会显示一个`<ul class="errorlist">`，如果字段有效（或表单未绑定），则显示一个空字符串。我们还可以将`form.message.errors`视为布尔值，甚至可以将其作为列表进行迭代。例如：
- en: '[PRE42]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the case of validation errors, this will add an "errors" class to the containing
    `<div>` and display the list of errors in an unordered list.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证错误的情况下，这将在包含的`<div>`中添加一个“errors”类，并在无序列表中显示错误列表。
- en: What's next?
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来呢？
- en: This chapter concludes the introductory material in this book-the so-called
    *core curriculum* The next section of the book, [Chapters 7](ch07.xhtml "Chapter 7. Advanced
    Views and URLconfs"), *Advanced Views and URLconfs*, to [Chapter 13](ch13.xhtml
    "Chapter 13. Deploying Django"), *Deploying Django*, goes into more detail about
    advanced Django usage, including how to deploy a Django application ([Chapter
    13](ch13.xhtml "Chapter 13. Deploying Django"), *Deploying Django*). After these
    first seven chapters, you should know enough to start writing your own Django
    projects. The rest of the material in this book will help fill in the missing
    pieces as you need them. We'll start in [Chapters 7](ch07.xhtml "Chapter 7. Advanced
    Views and URLconfs"), *Advanced Views and URLconfs*, by doubling back and taking
    a closer look at views and URLconfs (introduced first in [Chapter 2](ch02.xhtml
    "Chapter 2. Views and URLconfs"), *Views and URLconfs*).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束了本书的介绍性材料-所谓的*核心课程* 本书的下一部分，[第7章](ch07.xhtml "第7章.高级视图和URLconfs")，*高级视图和URLconfs*，到[第13章](ch13.xhtml
    "第13章.部署Django")，*部署Django*，将更详细地介绍高级Django用法，包括如何部署Django应用程序（[第13章](ch13.xhtml
    "第13章.部署Django")，*部署Django*）。在这七章之后，你应该已经了解足够的知识来开始编写自己的Django项目。本书中的其余材料将帮助您填补需要的空白。我们将从[第7章](ch07.xhtml
    "第7章.高级视图和URLconfs")开始，*高级视图和URLconfs*，通过回顾并更仔细地查看视图和URLconfs（首次介绍于[第2章](ch02.xhtml
    "第2章.视图和URLconfs")，*视图和URLconfs*）。
