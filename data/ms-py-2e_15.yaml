- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Scientific Python and Plotting
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 科学 Python 和绘图
- en: The Python programming language is quite suited for scientific work. This is
    due to it being really easy to program for while being powerful enough to do almost
    anything you need. This combination has spawned a whole bunch of (very large)
    Python projects, such as `numpy`, `scipy`, `matplotlib`, `pandas`, and so on,
    over the years. While these libraries are all large enough to warrant entire books
    for themselves, we can offer a little insight into where and when they can be
    useful so you have an idea of where to start.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Python 编程语言非常适合科学工作。这是因为编程非常容易，同时足够强大，几乎可以做你需要做的任何事情。这种组合催生了一系列（非常庞大）的 Python
    项目，如 `numpy`、`scipy`、`matplotlib`、`pandas` 等，这些项目在过去的几年中逐渐发展起来。虽然这些库都足够大，可以各自成为一本书的主题，但我们仍可以提供一些见解，让您了解它们何时何地有用，以便您知道从哪里开始。
- en: 'The major topics and libraries covered in this chapter are split into three
    sections:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主要主题和库被分为三个部分：
- en: '**Arrays and matrices**: NumPy, Numba, SciPy, Pandas, statsmodels, and xarray'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数组和矩阵**：NumPy、Numba、SciPy、Pandas、statsmodels 和 xarray'
- en: '**Mathematics and precise calculations**: gmpy2, Sage, mpmath, SymPy, and Patsy'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数学和精确计算**：gmpy2、Sage、mpmath、SymPy 和 Patsy'
- en: '**Plotting, graphing, and charting**: Matplotlib, Seaborn, Yellowbrick, Plotly,
    Bokeh, and Datashader'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绘图、图表和图表**：Matplotlib、Seaborn、Yellowbrick、Plotly、Bokeh 和 Datashader'
- en: It is very likely that not all libraries in this chapter are relevant to you,
    so don’t feel bad for not reading through all of it. However, I would recommend
    you at least look at the NumPy and Pandas sections briefly, as they are used heavily
    in the next chapter on machine learning.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能本章中并非所有库都与您相关，所以如果您没有阅读全部内容，请不要感到难过。然而，我建议您至少简要地查看 NumPy 和 Pandas 部分，因为它们在下一章关于机器学习的章节中被大量使用。
- en: Additionally, I would also recommend taking a look at the Matplotlib and Plotly
    sections, since those could be very useful in a wide range of scenarios.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我还建议您查看 Matplotlib 和 Plotly 部分，因为它们在许多场景中可能非常有用。
- en: Installing the packages
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装包
- en: 'As is always the case with Python libraries that are built on C and other non-Python
    code, installing is very platform-dependent. On most platforms, thanks to binary
    wheels, we can simply do:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于建立在 C 和其他非 Python 代码之上的 Python 库，安装通常非常依赖于平台。在大多数平台上，多亏了二进制轮，我们可以简单地这样做：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For this and the next chapter, however, I would recommend an alternative solution
    instead. While some of the libraries, such as `numpy`, are easy to install on
    most platforms, some of the other libraries are more challenging. For this reason,
    I would recommend the use of either the **Anaconda** distribution or one of the
    **Jupyter Docker Stacks**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于本章和下一章，我建议使用一种替代解决方案。虽然一些库，如 `numpy`，在大多数平台上安装起来很容易，但其他一些库则更具挑战性。因此，我建议使用
    **Anaconda** 发行版或 **Jupyter Docker Stacks** 之一。
- en: 'The Jupyter Docker Stacks require you to have Docker working on your system,
    but if you do, it can be extremely easy to launch very complicated systems that
    would be near impossible to set up otherwise. The list of available stacks can
    be found here: [https://jupyter-docker-stacks.readthedocs.io/en/latest/using/selecting.html#core-stacks](https://jupyter-docker-stacks.readthedocs.io/en/latest/using/selecting.html#core-stacks).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Jupyter Docker Stacks 需要您在系统上运行 Docker，但如果您已经运行了 Docker，那么启动非常复杂的系统将变得极其简单。可用的堆栈列表可以在以下位置找到：[https://jupyter-docker-stacks.readthedocs.io/en/latest/using/selecting.html#core-stacks](https://jupyter-docker-stacks.readthedocs.io/en/latest/using/selecting.html#core-stacks)。
- en: 'A good starting point for this chapter is the `jupyter/scipy-notebook` stack,
    which includes a huge list of packages such as `numpy`, `scipy`, `numba`, `matplotlib`,
    `cython`, and many more. Running this image (assuming you have Docker running)
    is as easy as:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的一个良好起点是 `jupyter/scipy-notebook` 堆栈，它包括一个庞大的包列表，例如 `numpy`、`scipy`、`numba`、`matplotlib`、`cython`
    以及更多。运行此镜像（假设您已经运行了 Docker）就像这样简单：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After running the command, it will give you some information on how to open
    Jupyter in your browser.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令后，它将为您提供如何在浏览器中打开 Jupyter 的相关信息。
- en: Arrays and matrices
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组和矩阵
- en: Matrices are at the heart of most scientific Python and artificial intelligence
    libraries because they are very convenient for storing a lot of related data.
    They are also suitable for really fast bulk processing, and calculations on them
    can be performed much faster than you could achieve with many separate variables.
    In some cases, these calculations can even be offloaded to the GPU for even faster
    processing.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵是大多数科学Python和人工智能库的核心，因为它们非常适合存储大量相关数据。它们也适合进行快速的批量处理，并且在这些矩阵上的计算可以比使用许多单独变量更快地完成。在某些情况下，这些计算甚至可以卸载到GPU上以实现更快的处理。
- en: Note that a 0D matrix is effectively a single number, a 1D matrix is a regular
    array, and there is no real limit to the number of dimensions you can use. It
    should be noted that both size and processing time quickly increase with multiple
    dimensions, of course.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，0维矩阵实际上是一个单独的数字，1维矩阵是一个常规数组，你可以使用的维度数量实际上没有真正的限制。应该注意的是，随着维度的增加，大小和处理时间都会迅速增加，当然。
- en: NumPy – Fast arrays and matrices
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NumPy – 快速数组和矩阵
- en: The `numpy` package spawned most of the scientific Python development and is
    still used at the core of many of the libraries covered in this chapter and the
    next. The library is largely (where it matters, at least) written in C, which
    makes it extremely fast; we will see a few benchmarks later, but depending on
    the operation, it can easily be 100 times faster than pure Python for the CPython
    interpreter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy`包催生了大多数科学Python开发，并且仍然被用于本章和下一章中涵盖的许多库的核心。该库大部分（至少在关键部分）是用C编写的，这使得它非常快；我们稍后会看到一些基准测试，但根据操作，它可能比纯Python的CPython解释器快100倍。'
- en: Since `numpy` has numerous features, we can only cover a few of the basics.
    But these already demonstrate how incredibly powerful (and fast) it is and why
    it is the basis for many of the other scientific Python packages in this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`numpy`具有众多功能，我们只能涵盖一些基础知识。但这些都已证明它有多么强大（并且快速），以及为什么它是本章中许多其他科学Python包的基础。
- en: The core feature of the `numpy` library is the `numpy.ndarray` object. The `numpy.ndarray`
    object is implemented in C and offers a very fast and memory-efficient array.
    It can be represented as a single-dimension array or a multi-dimensional matrix
    with very powerful slicing features. You can store any Python object in one of
    these arrays, but to take full benefit of the power of `numpy`, you will need
    to use numbers such as integers or floating point numbers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy`库的核心特性是`numpy.ndarray`对象。`numpy.ndarray`对象是用C实现的，提供了一个非常快速且内存高效的数组。它可以表示为单维数组或具有非常强大切片功能的多元矩阵。你可以将这些数组中的任何一个存储任何Python对象，但要充分利用`numpy`的强大功能，你需要使用诸如整数或浮点数之类的数字。'
- en: One important thing to note about `numpy` arrays is that they have a **fixed**
    size and cannot be resized because they reserve a contiguous block of memory.
    If you need to make them smaller or larger, you will need to create a new array.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`numpy`数组的一个重要注意事项是它们具有**固定**的大小，并且不能调整大小，因为它们保留了一个连续的内存块。如果你需要使它们更小或更大，你需要创建一个新的数组。
- en: 'Let’s look at a few basic examples of how this array can be used and why it
    is very convenient:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个数组的一些基本示例，以及为什么它非常方便：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, the slicing options of `numpy` are very powerful, but what is
    even more useful about these slices is that they are all references/views instead
    of copies.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`numpy`的切片选项非常强大，但这些切片更有用的地方在于它们都是引用/视图而不是副本。
- en: 'This means that if you modify the data in a slice, the original array will
    be modified as well. To illustrate using the array we created in the earlier examples:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果你修改了切片中的数据，原始数组也会被修改。为了说明，我们可以使用之前示例中创建的数组：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, after modifying the first row and the first column for each
    row, we now see that `a`, `b`, and consequently all slices of `a` and `b` have
    been modified; and all of that in a single operation instead of having to loop.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，在修改了每一行的第一行和第一列之后，我们现在可以看到`a`、`b`以及`a`和`b`的所有切片都已经修改；而且这一切都在一个操作中完成，而不是需要循环。
- en: 'Let’s try to run a simple benchmark to see how fast `numpy` can be at certain
    operations. If you are familiar with linear algebra, you undoubtedly know what
    a dot product is. If not, the dot product is an algebraic operation on two equal-length
    arrays of numbers, which are multiplied pair-wise and summed after. In mathematical
    terms, it looks like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试运行一个简单的基准测试，看看 `numpy` 在某些操作上有多快。如果你熟悉线性代数，你无疑知道什么是点积。如果不熟悉，点积是对两个长度相等的数字数组的代数运算，这些数组成对相乘并在之后求和。用数学术语来说，它看起来像这样：
- en: '![](img/B15882_15_001.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15882_15_001.png)'
- en: It is a rather simple procedure and not that computationally heavy, but still
    something that is much faster when executed through `numpy`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单的程序，计算量不是很大，但仍然是通过 `numpy` 执行时快得多的事情。
- en: 'The goal of the dot product is to apply the growth of the second vector (array)
    onto the first vector. When applied to matrices, this can be used to move/rotate/scale
    a point or even an *n*-dimensional object. Simply put, if you have a 3D model
    stored in `numpy`, you can run a full transform on it using `numpy.dot`. Some
    examples of these operations can be found in my `numpy-stl` package: [https://pypi.org/project/numpy-stl/.](https://pypi.org/project/numpy-stl/.)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 点积的目标是将第二个向量（数组）的增长应用到第一个向量上。当应用于矩阵时，这可以用来移动/旋转/缩放一个点或甚至一个 *n*-维对象。简单来说，如果你有一个存储在
    `numpy` 中的 3D 模型，你可以使用 `numpy.dot` 在其上运行完整的变换。这些操作的示例可以在我的 `numpy-stl` 包中找到：[https://pypi.org/project/numpy-stl/](https://pypi.org/project/numpy-stl/)。
- en: Within this example, we will keep to the standard dot product of two 1-dimensional
    arrays, however.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将坚持两个一维数组的标准点积。
- en: 'To easily time the results, we will execute this from an IPython shell:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了轻松计时结果，我们将从 IPython shell 中执行此操作：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this basic example, we can see that the pure Python version takes 78.7 ms
    and the `numpy` version takes 518 µs. That means that the `numpy` version is 150
    times faster. Depending on what you are trying to do and on the size of the array,
    the advantage can be far greater.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个基本示例中，我们可以看到纯 Python 版本需要 78.7 毫秒，而 `numpy` 版本需要 518 微秒。这意味着 `numpy` 版本快了
    150 倍。根据你试图做什么以及数组的大小，优势可能会更大。
- en: 'To create an array, there are several options available, but the following
    are the most useful in my experience:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数组有多种选项可用，但根据我的经验，以下是最有用的：
- en: '`numpy.array(source_array)` creates an array from a different array (as we
    saw in the previous example).'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numpy.array(source_array)` 从不同的数组（如前一个示例所示）创建一个数组。'
- en: '`numpy.arange(n)` creates an array with the given range. Effectively identical
    to `numpy.array(range(n))`.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numpy.arange(n)` 创建一个给定范围的数组。实际上等同于 `numpy.array(range(n))`。'
- en: '`numpy.zeros(n)` creates an array of size `n`, filled with zeros. It also supports
    tuples to create matrices: `numpy.zeros((x, y, z))`.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numpy.zeros(n)` 创建一个大小为 `n` 的数组，填充为零。它还支持元组来创建矩阵：`numpy.zeros((x, y, z))`。'
- en: '`numpy.fromfunction(function, (x, y, z))` creates an array with the given shape
    using the given function. It should be noted that this function will be passed
    the index/indices of the current item, so the `x`, `y`, and `z` indices in this
    case.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numpy.fromfunction(function, (x, y, z))` 使用给定的函数创建具有给定形状的数组。需要注意的是，此函数将传递当前项的索引/索引，所以在这个例子中是
    `x`、`y` 和 `z` 索引。'
- en: The `numpy` library has many more useful functions, but at the very least it
    offers an array with nearly unbeatable performance and a very easy-to-use interface.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy` 库有许多更多有用的函数，但至少它提供了一个几乎无与伦比的性能和非常易于使用的接口。'
- en: Numba – Faster Python on CPU or GPU
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Numba – 在 CPU 或 GPU 上更快的 Python
- en: 'We already covered the basics of `numba` in *Chapter 12*, *Performance – Tracking
    and Reducing Your Memory and CPU Usage*. Combined with `numpy`, `numba` gets even
    more powerful because it natively supports functions that broadcast over `numpy`
    arrays (`numpy` calls these `ufuncs` or **universal functions**), similar to how
    the built-in `numpy` functions work. The only important difference between a regular
    `numba` function and one that supports `numpy` per-element processing is which
    decorator function you use. Normally you would use `numba.jit()`; for `numpy`
    per-element processing you need to use the `numba.vectorize(...)` decorator with
    the input and output types as parameters:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 *第12章* 中介绍了 `numba` 的基础知识，*性能 – 跟踪和减少您的内存和CPU使用量*。结合 `numpy`，`numba` 变得更加强大，因为它原生支持广播到
    `numpy` 数组的函数（`numpy` 将这些称为 `ufuncs` 或 **通用函数**），类似于内置的 `numpy` 函数的工作方式。普通 `numba`
    函数和支持 `numpy` 每元素处理的函数之间的重要区别在于您使用的装饰器函数。通常您会使用 `numba.jit()`；对于 `numpy` 每元素处理，您需要使用带有输入和输出类型参数的
    `numba.vectorize(...)` 装饰器：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Adding 1 is a useless example of course, but you can do anything you want here,
    which makes it very useful. The real point is how easy it is; as long as your
    function is purely functional (in other words, does not mutate external variables),
    it can be made extremely fast with very little effort. That is also the reason
    why several of the other libraries in this chapter heavily depend on `numba` for
    their performance.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 加1当然是一个无用的例子，但你可以在这里做任何你想做的事情，这使得它非常有用。真正的要点是它有多容易；只要你的函数是纯函数式的（换句话说，不修改外部变量），就可以通过非常少的努力使其非常快。这也是为什么本章中其他几个库在性能上严重依赖
    `numba` 的原因。
- en: 'As we specified `numba.vectorize([numba.int64(numba.int64)])`, our function
    will only accept a 64-bit integer and will return a 64-bit integer. To create
    a function that takes two 32- or 64-bit floats and returns a 64-bit integer, we
    would use the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们指定的 `numba.vectorize([numba.int64(numba.int64)])`，我们的函数将只接受64位整数并返回64位整数。要创建一个接受两个32位或64位浮点数并返回64位整数的函数，我们可以使用以下代码：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In addition to the `numba.vectorize()` decorator, we have several other options
    available, such as the `numba.jitclass()` decorator for JIT-compiling an entire
    class, or the `numba.jit_module()` function to enhance an entire module.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `numba.vectorize()` 装饰器之外，我们还有其他一些选项可用，例如用于 JIT 编译整个类的 `numba.jitclass()`
    装饰器，或者用于增强整个模块的 `numba.jit_module()` 函数。
- en: SciPy – Mathematical algorithms and NumPy utilities
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SciPy – 数学算法和 NumPy 工具
- en: The `scipy` (Scientific Python) package contains a collection of mathematical
    algorithms for many different problems. The functions vary from signal processing
    to spatial algorithms to statistical functions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`scipy`（科学 Python）包包含针对许多不同问题的数学算法集合。函数范围从信号处理到空间算法到统计函数。'
- en: 'Here’s a list of some of the current sub-packages available in the `scipy`
    library (according to the `scipy` manual):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了 `scipy` 库中当前可用的某些子包（根据 `scipy` 手册）：
- en: '`cluster`: Clustering algorithms such as *k*-means'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cluster`：如 *k*-means 的聚类算法'
- en: '`fftpack`: Fast Fourier Transform routines'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fftpack`：快速傅里叶变换例程'
- en: '`integrate`: Integration and ordinary differential equation solvers'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`integrate`：积分和常微分方程求解器'
- en: '`interpolate`: Interpolation and spline smoothing functions'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`interpolate`：插值和样条平滑函数'
- en: '`linalg`: Linear algebra functions such as linear equation solving'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`linalg`：线性代数函数，如线性方程求解'
- en: '`ndimage`: *N*-dimensional image processing'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ndimage`：*N*-维图像处理'
- en: '`odr`: Orthogonal distance regression'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`odr`：正交距离回归'
- en: '`optimize`: Optimization and root-finding routines'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`optimize`：优化和根查找例程'
- en: '`signal`: Signal processing functions such as peak finding and spectral analysis'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`signal`：信号处理函数，如峰值查找和频谱分析'
- en: '`sparse`: Sparse matrices and associated routines to save memory'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sparse`：稀疏矩阵及其相关的内存节省例程'
- en: '`spatial`: Spatial data structures and algorithms for triangulation and plotting'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spatial`：用于三角剖分和绘图的空間数据结构和算法'
- en: '`stats`: Statistical distributions and functions'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stats`：统计分布和函数'
- en: As you can see, `scipy` features algorithms for a large range of topics and
    many of the functions are really fast, so it is definitely worth taking a look
    at.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`scipy` 提供了广泛主题的算法，其中许多函数都非常快，因此绝对值得一看。
- en: With most of these topics, you can already guess by their names whether or not
    they apply to your use case, but there are a few that warrant a small example.
    So, let’s look at one.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些大多数主题，你可以通过它们的名称猜测它们是否适用于你的用例，但也有一些需要一个小例子来证明。所以，让我们看看一个例子。
- en: Sparse matrices
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 稀疏矩阵
- en: One of the most useful features of `scipy` (in my opinion, at least) is `scipy.sparse`.
    This module allows you to create sparse arrays, which can save you a huge amount
    of memory. While a `numpy` array takes roughly the amount of memory you are reserving,
    the `sparse` arrays only store the non-zero values or the non-zero blocks/rows/columns,
    depending on the type you choose. In the case of `numpy`, storing 1 million 64-bit
    integers takes 64 million bits or 8 megabytes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`scipy`（至少在我看来）最有用的功能之一是`scipy.sparse`模块。这个模块允许你创建稀疏数组，这可以为你节省大量的内存。而`numpy`数组大约占用你预留的内存量，而稀疏数组只存储非零值或非零块/行/列，具体取决于你选择的数据类型。在`numpy`的情况下，存储一百万个64位整数需要6400万个比特或8MB。'
- en: Naturally, the advantage of a sparse array comes with a bunch of downsides,
    such as slower processing for certain operations or directions. The `scipy.sparse.csc_matrix`
    method, for example, produces sparse matrices that are really fast to slice in
    the column direction, but slow when slicing rows. Meanwhile, `scipy.sparse.csr_matrix`
    is the opposite.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，稀疏数组的好处伴随着一些缺点，比如某些操作或方向的处理速度较慢。例如，`scipy.sparse.csc_matrix`方法可以产生在列方向上切片非常快的稀疏矩阵，但在行方向上切片时则较慢。同时，`scipy.sparse.csr_matrix`则相反。
- en: 'Usage of sparse arrays is roughly as straightforward as a `numpy` array, but
    care has to be taken when selecting the specific sparse matrix type. The options
    are:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 稀疏数组的使用大致与`numpy`数组一样简单，但在选择特定的稀疏矩阵类型时需要小心。选项包括：
- en: '`bsr_matrix(arg1[, shape, dtype, copy, blocksize])`: Block Sparse Row matrix'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bsr_matrix(arg1[, shape, dtype, copy, blocksize])`: 块稀疏行矩阵'
- en: '`coo_matrix(arg1[, shape, dtype, copy])`: A sparse matrix in COOrdinate format.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`coo_matrix(arg1[, shape, dtype, copy])`: 基于坐标格式的稀疏矩阵。'
- en: '`csc_matrix(arg1[, shape, dtype, copy])`: Compressed Sparse Column matrix'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`csc_matrix(arg1[, shape, dtype, copy])`: 压缩稀疏列矩阵'
- en: '`csr_matrix(arg1[, shape, dtype, copy])`: Compressed Sparse Row matrix'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`csr_matrix(arg1[, shape, dtype, copy])`: 压缩稀疏行矩阵'
- en: '`dia_matrix(arg1[, shape, dtype, copy])`: Sparse matrix with DIAgonal storage'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dia_matrix(arg1[, shape, dtype, copy])`: 基于对角存储的稀疏矩阵'
- en: '`dok_matrix(arg1[, shape, dtype, copy])`: Dictionary Of Keys-based sparse matrix.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dok_matrix(arg1[, shape, dtype, copy])`: 基于键的字典稀疏矩阵。'
- en: '`lil_matrix(arg1[, shape, dtype, copy])`: Row-based List-Of-Lists sparse matrix'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lil_matrix(arg1[, shape, dtype, copy])`: 基于行的列表-列表稀疏矩阵'
- en: 'If you only need something like a large identity matrix, this can be extremely
    useful. It is easy to construct and takes very little memory. The following two
    matrices are identical in contents:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要类似一个大单位矩阵的东西，这可以非常有用。它很容易构建，并且占用非常少的内存。以下两个矩阵在内容上是相同的：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see here, the non-sparse version of the identity matrix (`x`) took
    10,000 times more memory. In this case, it is 800 megabytes versus 80 kilobytes,
    but if you have a much larger matrix this quickly becomes impossible. Since the
    matrix grows in size quadratically (`n^2`; the matrix above has size 10,000x10,000=100,000,000)
    this can make a very dramatic difference. The sparse matrix (in this case, at
    least) grows linearly (`n`).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，非稀疏版本的单位矩阵（`x`）占用的内存是前者的10000倍。在这种情况下，它是800MB对80KB，但如果你有一个更大的矩阵，这很快就会变得不可能。由于矩阵的大小是二次增长的（`n^2`；上面的矩阵大小为10,000x10,000=100,000,000），这可以造成非常显著的区别。稀疏矩阵（至少在这个例子中）是线性增长的（`n`）。
- en: For smaller non-sparse arrays (up to a billion numbers) the memory usage is
    still workable and it would take about 8 gigabytes of memory for a billion 64-bit
    numbers, but when you go beyond that, most systems will quickly run out of memory.
    As is often the case, these memory savings do come at the cost of increased CPU
    time for many operations, so I would not recommend replacing all of your `numpy`
    arrays with sparse arrays.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较小的非稀疏数组（多达十亿个数字），内存使用仍然可行，对于十亿个64位数字，大约需要8GB的内存，但当你超过这个范围时，大多数系统会很快耗尽内存。正如通常情况那样，这些内存节省是以增加许多操作的CPU时间为代价的，所以我不会建议将所有的`numpy`数组替换为稀疏数组。
- en: In conclusion, `scipy` is a versatile and very useful module that supports a
    wide variety of calculations and algorithms. If `scipy` has an algorithm available
    for your goal, it is likely one of the fastest options you are going to find within
    the Python ecosystem. Many of the functions are very domain-specific, however,
    so you can probably guess which are (and are not) useful for you.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，`scipy` 是一个多功能且非常有用的模块，支持广泛的计算和算法。如果 `scipy` 有适合您目标的算法，那么它很可能是您在 Python 生态系统中能找到的最快的选项之一。然而，许多函数非常特定于领域，因此您可能可以猜出哪些（以及哪些不是）对您有用。
- en: Pandas – Real-world data analysis
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pandas – 现实世界数据分析
- en: While the focus of `numpy`, `scipy`, and `sympy` is mostly mathematical, Pandas
    is focused more on real-world data analysis. With Pandas, you are generally expected
    to load data from some external source such as databases or CSV files. Once you
    have the data loaded, you can easily calculate statistics, visualize the data,
    or combine the data with other datasets.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `numpy`、`scipy` 和 `sympy` 的重点是数学，但 Pandas 更专注于现实世界的数据分析。使用 Pandas，通常期望您从外部源（如数据库或
    CSV 文件）加载数据。一旦加载数据，您就可以轻松计算统计数据、可视化数据或与其他数据集合并数据。
- en: To store data, Pandas offers two different data structures. The `pandas.Series`
    is a 1-dimensional array and the `pandas.DataFrame` is a 2-dimensional matrix
    where the columns can be labeled if needed. Internally these objects wrap a `numpy.ndarray`,
    so all `numpy` operations are still possible on these objects as well.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要存储数据，Pandas 提供了两种不同的数据结构。`pandas.Series` 是一个一维数组，而 `pandas.DataFrame` 是一个二维矩阵，如果需要，列可以标记。内部这些对象封装了一个
    `numpy.ndarray`，因此在这些对象上仍然可以进行所有 `numpy` 操作。
- en: 'Why do we need Pandas on top of `numpy`? It all comes down to convenience,
    and Pandas offers several features on top of `numpy` that are beneficial for doing
    real-world data analysis:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要在 `numpy` 之上使用 Pandas？这全部归结于便利性，Pandas 在 `numpy` 的基础上提供了几个对进行现实世界数据分析有益的特性：
- en: It can gracefully handle missing data. Within a `numpy` floating point number,
    you can store `NaN` (not a number), but not all `numpy` methods will handle that
    nicely without custom filtering.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以优雅地处理缺失数据。在 `numpy` 浮点数中，您可以存储 `NaN`（不是一个数字），但并非所有 `numpy` 方法都能很好地处理它，除非进行自定义过滤。
- en: As opposed to the fixed-size `numpy.ndarray`, columns can be added and removed
    to a `numpy.DataFrame` as desired.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与固定大小的 `numpy.ndarray` 相比，可以根据需要向 `numpy.DataFrame` 中添加和删除列。
- en: It provides bundled data management functions to easily group, aggregate, or
    transform data. While you can easily modify `numpy` data, grouping data is a lot
    harder out of the box.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了捆绑的数据管理函数，可以轻松地对数据进行分组、聚合或转换。虽然您可以轻松修改 `numpy` 数据，但默认情况下，从 `numpy` 中分组数据要困难得多。
- en: It also provides utility functions for data containing time series, allowing
    you to easily apply moving window statistics and compare newer to older data with
    very little effort.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还提供了用于包含时间序列数据的实用函数，允许您轻松应用移动窗口统计并轻松比较新旧数据。
- en: 'Let’s create a simple example that stores the release dates of major Python
    releases with their versions. The data is sourced from Wikipedia, which has a
    nice table that we can quickly use and copy: [https://en.wikipedia.org/wiki/History_of_Python#Table_of_versions](https://en.wikipedia.org/wiki/History_of_Python#Table_of_versions).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的示例，该示例存储了主要 Python 版本的发布日期及其版本。数据来源于维基百科，它有一个很好的表格，我们可以快速使用并复制：[https://en.wikipedia.org/wiki/History_of_Python#Table_of_versions](https://en.wikipedia.org/wiki/History_of_Python#Table_of_versions)。
- en: For brevity, we are showing a shortened version of the code here, but you can
    copy/paste the full table from Wikipedia or look in the GitHub project for this
    book.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我们在这里展示了代码的简短版本，但您可以从维基百科复制/粘贴完整的表格，或者查看此书的 GitHub 项目。
- en: 'First, let’s read the data into a dataframe:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将数据读入一个数据框中：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, we have the entire table stored in `data` as a tab-separated string.
    Since that includes the references that Wikipedia uses, we use a regular expression
    to clean up everything that looks like `[...]`. Lastly, we read the data into
    a `pandas.DataFrame` object using `pandas.read_table()`. The `read_table()` function
    supports either a filename or a file handle and, since we have the data as a string,
    we’re using `io.StringIO()` to convert the string to a file handle.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，整个表都存储在 `data` 中，作为一个制表符分隔的字符串。由于这包括维基百科使用的引用，我们使用正则表达式清理所有看起来像 `[...]`
    的内容。最后，我们使用 `pandas.read_table()` 将数据读入一个 `pandas.DataFrame` 对象。`read_table()`
    函数支持文件名或文件句柄，由于我们拥有字符串形式的数据，我们使用 `io.StringIO()` 将字符串转换为文件句柄。
- en: 'Now that we have the data, let’s see what we can do with it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了数据，让我们看看我们能用它做什么：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now that we know how to read the data from the table, let’s see how we can
    do something more useful with it. This time we are going to convert it into a
    time series so we can do analysis based on dates/times:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何从表中读取数据，让我们看看我们如何能更有效地使用它。这次我们将将其转换为时间序列，这样我们就可以基于日期/时间进行分析了：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: While you could do all of this with plain `numpy`, it is certainly much more
    convenient with `pandas`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以用普通的`numpy`做所有这些，但使用`pandas`肯定要方便得多。
- en: Input and output options
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输入和输出选项
- en: One huge advantage of Pandas is the huge amount of readily available input and
    output options. Let’s start by saying that this list will never be complete because
    you can easily implement your own method, or install a library to handle other
    types for you. We will see an example of this later in this chapter when we cover
    `xarray`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas的一个巨大优势是它提供了大量的现成输入和输出选项。让我们首先说，这个列表永远不会完整，因为你可以轻松实现自己的方法，或者安装一个库来为你处理其他类型。我们将在本章后面介绍`xarray`时看到这个例子。
- en: 'At the time of writing, the `pandas` library natively supports a huge list
    of input and/or output formats:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，`pandas`库原生支持大量的输入和/或输出格式：
- en: Common formats such as Pickle, CSV, JSON, HTML, and XML
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的格式，如Pickle、CSV、JSON、HTML和XML
- en: Spreadsheets such as Excel files
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如Excel文件之类的电子表格
- en: Data formats used by other statistical systems such as HDF5, Feather, Parquet,
    ORC, SAS, SPSS, and Stata
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他统计系统使用的数据格式，如HDF5、Feather、Parquet、ORC、SAS、SPSS和Stata
- en: Many types of databases using SQLAlchemy
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多使用SQLAlchemy的数据库类型
- en: If your preferred format is not on the list, the odds are that you can easily
    find a converter for it. Alternatively, it is fairly easy to write a converter
    yourself as you can implement them in plain Python.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的首选格式不在列表中，你很可能可以轻松找到它的转换器。或者，自己编写一个转换器也很容易，因为你可以用纯Python实现它们。
- en: Pivoting and grouping
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交叉表和分组
- en: 'One very useful feature of Pandas is the ability to **pivot** and **unpivot**
    a DataFrame. When pivoting, we can convert rows to columns based on their values,
    effectively grouping them. The `pandas` library has several options to pivot/unpivot
    your data:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas的一个非常有用的功能是能够**交叉表**和**逆交叉表**DataFrame。在交叉表操作时，我们可以根据它们的值将行转换为列，从而有效地对它们进行分组。`pandas`库有几个选项来交叉表/逆交叉表你的数据：
- en: '`pivot`: Returns a reshaped pivot table without aggregation (e.g. sum/count/etc.)
    support'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pivot`: 返回一个没有聚合（例如求和/计数等）支持的重新塑形的交叉表'
- en: '`pivot_table`: Returns a pivot table with aggregation support'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pivot_table`: 返回一个具有聚合支持的交叉表'
- en: '`melt`: Reverses the operation of `pivot`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`melt`: 反转`pivot`操作'
- en: '`wide_to_long`: A simpler version of `melt` that can be more convenient to
    use'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wide_to_long`: `melt`的一个更简单的版本，使用起来可能更方便'
- en: 'What can we achieve by pivoting? Let’s create a very simple example of some
    temperature measurements in a long list, and pivot them so we get the days as
    columns instead of rows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过交叉表操作我们能实现什么？让我们创建一个包含一些温度测量的长列表的非常简单的例子，并将它们交叉表操作，这样我们就能将日期作为列而不是行：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The way this data is set up is similar to how a data logging tool would usually
    return it, with a single row for a single measurement. However, this is often
    not the most convenient way to read or analyze the data, and that is where pivoting
    can really help.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这种数据设置的方式类似于数据记录工具通常会返回的方式，每行代表一个单独的测量值。然而，这通常不是读取或分析数据最方便的方式，这正是交叉表能真正帮助的地方。
- en: 'Let’s look at the mean room temperature per hour:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每小时的平均室温：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: That shows a row for each room and a column for each hour, with the values generated
    through `numpy.mean()`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了每个房间的行和每个小时的列，通过`numpy.mean()`生成的值。
- en: 'We can also get the mean room temperature per building, per room, per hour:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以得到每栋楼、每个房间每小时的平均室温：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, `pandas` handles missing values by showing `NaN` for the missing
    data and gives us a very nice aggregate result.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`pandas`通过显示缺失数据的`NaN`来处理缺失值，并给出了一个非常好的聚合结果。
- en: In addition to these pivoting features, Pandas provides a huge list of grouping
    functions that also allow you to aggregate results. The big advantage of the grouping
    feature over pivoting is that you can group over arbitrary ranges and functions.
    For time-based results, for example, you could choose to group per second, minute,
    hour, 5 minutes, or any other interval that might be useful to you.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些旋转功能之外，Pandas提供了一大串分组函数，这些函数也允许你聚合结果。与旋转相比，分组功能的一个大优点是你可以对任意范围和函数进行分组。例如，对于基于时间的结果，你可以选择按秒、分钟、小时、5分钟或任何对你有用的其他间隔进行分组。
- en: 'As a basic example with the data above:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 作为上面的基本示例：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This example already shows how the `groupby` feature can be used, but the real
    power comes when combining it with timestamps. For instance, you could do `pd.Grouper(freq='5min')`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子已经展示了如何使用`groupby`功能，但真正的力量在于将其与时间戳结合使用。例如，你可以使用`pd.Grouper(freq='5min')`。
- en: Merging
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合并
- en: 'Another extremely useful feature of Pandas is that you can merge data, similar
    to how you would join tables in a database. As is the case with pivoting, the
    `pandas` library has several join methods:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas的另一个极其有用的功能是，你可以合并数据，类似于在数据库中连接表。与旋转类似，`pandas`库有几种连接方法：
- en: '`pandas.merge`: The `merge` function is pretty much the straight equivalent
    of a database join. It can do inner, outer, left, right, and cross joins, similar
    to many databases. Additionally, it can validate if the relations between the
    columns are correct (i.e. one-to-one, one-to-many, many-to-one, and many-to-many),
    in a similar way to how referential integrity in a database functions.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pandas.merge`：`merge`函数基本上是数据库连接的直接等价。它可以执行内连接、外连接、左连接、右连接和交叉连接，类似于许多数据库。此外，它还可以验证列之间的关系是否正确（即一对一、一对多、多对一和多对多），类似于数据库中的引用完整性功能。'
- en: '`pandas.merge_ordered`: Similar to `merge` but allows for optional filling/interpolation
    using a function.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pandas.merge_ordered`：类似于`merge`，但允许使用函数进行可选的填充/插值。'
- en: '`pandas.merge_asof`: This function does a left join on the nearest key instead
    of requiring an exact match.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pandas.merge_asof`：此函数在最近的关键值上执行左连接，而不是要求精确匹配。'
- en: The ability to easily merge multiple `DataFrame` objects is a really powerful
    feature that is invaluable when processing real-world data.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 容易合并多个`DataFrame`对象的能力是一个非常强大的功能，在处理现实世界数据时非常有价值。
- en: Rolling or expanding windows
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 滚动或扩展窗口
- en: In Pandas, windows can help you to efficiently run calculations on rolling subsets
    of (expanding) data. Naively calculating is of course possible, but that can be
    highly inefficient and infeasible for larger datasets. With a **rolling window**,
    you can have a running mean, sum, or other function on a fixed window size in
    an efficient manner.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在Pandas中，窗口可以帮助你高效地对（扩展的）数据的滚动子集进行计算。当然，直接计算是可能的，但对于大型数据集来说可能非常低效和不可行。使用**滚动窗口**，你可以以高效的方式在固定窗口大小上获得移动平均、总和或其他函数。
- en: To illustrate, let’s assume you have an array with 100 items and you want to
    get the mean value using a window size of 10\. The naïve solution would be to
    sum the first 10 items and divide them by 10, then repeat that for items 1 to
    11, and so on.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，让我们假设你有一个包含100个项目的数组，并且你想使用窗口大小为10来获取平均值。直观的解决方案是先对前10个项目求和，然后除以10，然后对1到11的项目重复此操作，依此类推。
- en: For each of these, you would have to walk through all 10 items in the window.
    If we take `n` as the length of the array and `w` as the size of the window, this
    takes `O(n*w)` time. We can do much better if we keep track of the intermediate
    sum, however; if we simply add the next number and simultaneously remove the first
    number from our running sum, we can do the same in `O(n)` instead.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些，你将不得不遍历窗口中的所有10个项目。如果我们取`n`为数组的长度，`w`为窗口的大小，这将需要`O(n*w)`的时间。然而，如果我们跟踪中间的总和，我们可以做得更好；如果我们简单地添加下一个数字，并同时从我们的运行总和中去掉第一个数字，我们可以在`O(n)`内完成同样的工作。
- en: 'Let’s illustrate how `pandas` can take care of this for us:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来说明`pandas`是如何为我们处理这些的：
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The rolling window as we have seen above supports functions for count, sum,
    mean, median, variance, standard deviation, quantiles, and several more. If you
    need something special, you can also provide your own function.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，滚动窗口支持计数、求和、平均值、中位数、方差、标准差、分位数等函数。如果你需要特殊的功能，你也可以提供自己的函数。
- en: There are a few extra features to these windows. Instead of having all items
    calculated with the same weight, you can also use **weighted windows** to vary
    the weight of the items so recent data becomes more relevant than older data.
    In addition to regular weighted windows, you can also opt for **exponentially
    weighted windows** to increase the effect even further.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这些窗口有一些额外功能。除了使用相同的权重计算所有项目外，你还可以使用**加权窗口**来改变项目的权重，使最近的数据比旧数据更有相关性。除了常规加权窗口外，你还可以选择**指数加权窗口**来进一步增强效果。
- en: Lastly, we also have **expanding windows**. With these, you get the result from
    the beginning of the dataset up to your current point. If you were to sum a series
    with values `1, 2, 3, 4, 5`, it would return `1, 3, 6, 10, 15`, with each item
    being the total sum from the beginning of the series up to that point.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还有**扩展窗口**。使用这些窗口，你可以从数据集的开始到当前点获取结果。如果你要计算一个包含值 `1, 2, 3, 4, 5` 的序列的总和，它将返回
    `1, 3, 6, 10, 15`，其中每个项目都是从序列开始到该点的总和中。
- en: To conclude, the `pandas` library is extremely useful for analyzing data from
    varying sources. Since it was built on top of `numpy` it is also extremely fast,
    which makes it very convenient for in-depth analysis.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`pandas` 库对于分析来自不同来源的数据极为有用。由于它是建立在 `numpy` 之上的，因此它也非常快速，这使得它非常适合深入分析。
- en: If you ever have a large amount of data to process, or data from several different
    sources, give `pandas` a try and see if it can help you to sort it out.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要处理大量数据，或者来自几个不同来源的数据，不妨试试 `pandas`，看看它是否能帮助你整理数据。
- en: Statsmodels – Statistical models on top of Pandas
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Statsmodels – 基于 Pandas 的统计模型
- en: Similar to how `scipy` builds on top of `numpy`, we have `statsmodels` that
    builds on top of `pandas`. Initially, it was part of the `scipy` package, but
    later split off and greatly improved.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `scipy` 是建立在 `numpy` 之上的，我们也有 `statsmodels` 是建立在 `pandas` 之上的。最初，它是 `scipy`
    包的一部分，但后来分离出来并得到了极大的改进。
- en: The `statsmodels` library offers a host of statistical methods and plotting
    tools and can be used to create regression models, choice models, analysis of
    variance (ANOVA), forecasting, and more.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`statsmodels` 库提供了一系列统计方法和绘图工具，可用于创建回归模型、选择模型、方差分析 (ANOVA)、预测等。'
- en: 'A quick example of a weighted least squares regression, which attempts to fit
    a line to a set of data points, can be applied like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一个加权最小二乘回归的快速示例，它试图将一条线拟合到一组数据点，可以像这样应用：
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: While it still requires some background knowledge about statistics to be able
    to apply this properly, it does show how easily you can do a regression with `statsmodels`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它仍然需要一些关于统计学的背景知识才能正确应用，但它确实展示了如何容易地使用 `statsmodels` 进行回归。
- en: An abbreviated list of the models and analysis types that are currently supported
    by `statmodels` from the `statsmodels` manual follows.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `statsmodels` 手册中支持的模型和分析类型简短列表。
- en: 'Regression and linear models:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 回归和线性模型：
- en: Linear regression
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性回归
- en: Generalized linear models
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广义线性模型
- en: Generalized estimating equations
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广义估计方程
- en: Generalized additive models (GAMs)
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广义加性模型 (GAMs)
- en: Robust linear models
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鲁棒线性模型
- en: Linear mixed effects models
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性混合效应模型
- en: Regression with discrete dependent variable
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 离散因变量的回归
- en: Generalized linear mixed effects models
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广义线性混合效应模型
- en: ANOVA
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方差分析 (ANOVA)
- en: 'Time series analysis:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列分析：
- en: Generic time series analysis such as univariate and vector autoregressive models
    (ARs/VARs)
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用时间序列分析，如单变量和向量自回归模型 (ARs/VARs)
- en: Time series analysis by state space methods
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态空间方法进行的时间序列分析
- en: Vector autoregressions
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量自回归
- en: 'Other models:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 其他模型：
- en: Methods for survival and duration analysis
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生存和持续时间分析的方法
- en: Nonparametric methods
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非参数方法
- en: Generalized method of moments
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广义矩估计方法
- en: Multivariate statistics
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多变量统计
- en: The actual list of supported features is quite a bit longer, but this should
    give you a good indication as to whether it is a useful library for you. If you
    are familiar with statistical models, you should be able to get started with `statsmodels`
    rather quickly and the package is well documented with great examples.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，支持的功能列表相当长，但这应该能给你一个很好的指示，即它是否是一个对你有用的库。如果你熟悉统计模型，你应该能够快速开始使用 `statsmodels`，并且该包有很好的文档和示例。
- en: xarray – Labeled arrays and datasets
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: xarray – 标记数组和数据集
- en: The `xarray` library is very similar to `pandas` and is also built on top of
    `numpy`. The main differences are that `xarray` is multi-dimensional, whereas
    `pandas` supports one-dimensional and two-dimensional data only, and it was created
    with the **netCDF** (**Network Common Data Form**) formats in mind. The netCDF
    formats are commonly used for scientific research data, which (as opposed to CSV
    files, for example) contain both the data and metadata such as variable labels,
    data descriptions, and documentation, allowing for easy use in a multitude of
    software.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`xarray`库与`pandas`非常相似，也是建立在`numpy`之上的。主要区别在于`xarray`是多维的，而`pandas`只支持一维和二维数据，并且它是基于**netCDF**（**网络公共数据格式**）格式创建的。netCDF格式通常用于科学研究数据，与例如CSV文件不同，它们包含数据以及元数据，如变量标签、数据描述和文档，这使得在多种软件中易于使用。'
- en: 'The `xarray` library can easily work together with `pandas`, so for this example,
    we will re-use the data from our earlier `pandas` example. The other way around
    is also easily possible using the `to_dataframe()` method on an `xarray.DataArray`
    object (the standard `xarray` matrix object). In this example, we will assume
    that you still have the `df` variable available from the `pandas` example earlier:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`xarray`库可以轻松与`pandas`协同工作，因此在这个例子中，我们将重新使用我们之前`pandas`示例中的数据。反过来，使用`xarray.DataArray`对象上的`to_dataframe()`方法（标准的`xarray`矩阵对象）也是同样容易的。在这个例子中，我们假设您仍然有之前`pandas`示例中的`df`变量可用：'
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The syntax for the `groupby()` is slightly different from `pandas`, and less
    Pythonic (if you ask me) due to the use of strings over variables, but it essentially
    comes down to the same operation.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`groupby()`的语法与`pandas`略有不同，并且由于使用字符串而不是变量，所以不太Pythonic（如果问我），但它本质上归结为相同的操作。'
- en: 'In the `pandas` version, the order of the `count()` and the `[''Version'']`
    can be swapped to be even more similar. That is, the following is also valid and
    returns the same results:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pandas`版本中，`count()`和`['Version']`的顺序可以互换，使其更加相似。也就是说，以下也是有效的，并且返回相同的结果：
- en: '[PRE18]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Additionally, for this use case, I would argue that the output of `xarray` is
    not all that readable, but it certainly isn’t bad either. Often, you will have
    so many data points that you won’t be too interested in the raw data anyway.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于这个用例，我会说`xarray`的输出并不那么易于阅读，但当然也不算差。通常，您会有如此多的数据点，以至于您根本不会太关心原始数据。
- en: 'The real advantage to `xarray` over `pandas` (in my opinion, at least) is the
    support for multi-dimensional data. You can add as much as you want to the `Dataset`
    object:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 与`pandas`相比，`xarray`（至少在我看来）的真正优势是支持多维数据。您可以向`Dataset`对象添加尽可能多的内容：
- en: '[PRE19]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this case, we only added the `triangles` and the `points`, but you can add
    as much as you want and you can use `xarray` to combine these so you can reference
    multi-dimensional objects easily. Data combination can be achieved through several
    methods such as concatenation, merging to combine multiple datasets into one,
    combining based on field values, through per-row updates, and others.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只添加了`triangles`和`points`，但您可以添加尽可能多的内容，并且可以使用`xarray`将这些内容组合起来，以便轻松引用多维对象。数据组合可以通过多种方法实现，例如连接、合并以将多个数据集合并为一个，基于字段值组合，通过逐行更新，以及其他方法。
- en: When it comes down to `pandas` versus `xarray`, I would recommend simply giving
    them both a try and seeing which is more convenient for your use case. The libraries
    are very similar in features and usability and both have their own advantages.
    The multi-dimensionality of `xarray` is a huge advantage over `pandas` if you
    need it, however.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到`pandas`与`xarray`的比较时，我建议简单地尝试两者，看看哪一个更适合您的使用场景。这两个库在功能和可用性上非常相似，并且各自都有其优势。如果您需要，`xarray`的多维性相对于`pandas`来说是一个巨大的优势。
- en: If it’s all the same to you then I would currently recommend `pandas` over `xarray`,
    simply because it is currently the most used of the two, which results in more
    documentation/blog posts/books being available.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对您来说两者都一样，那么我目前会推荐使用`pandas`而不是`xarray`，仅仅因为它目前是两者中更常用的，这导致更多的文档/博客文章/书籍可用。
- en: STUMPY – Finding patterns in time series
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: STUMPY – 在时间序列中寻找模式
- en: The `stumpy` library offers several tools to automatically detect patterns and
    anomalies in your time series matrices. It is built upon `numpy`, `scipy`, and
    `numba` to provide great performance and gives you the possibility of employing
    GPU (video card) power as well, to process the data even faster.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`stumpy` 库提供了几个工具来自动检测时间序列矩阵中的模式和异常。它基于 `numpy`、`scipy` 和 `numba` 构建，以提供出色的性能，并为你提供了利用
    GPU（显卡）处理数据以实现更快处理的可能性。'
- en: Using `stumpy` you could, for example, automatically detect if a website is
    getting an abnormal number of visitors. One of the nice features of `stumpy` in
    this scenario is that, in addition to static matrices, you can also add more data
    in a streaming way, which allows you to do real-time analysis without too much
    overhead.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `stumpy`，例如，你可以自动检测一个网站是否正在获得异常数量的访客。在这个场景中，`stumpy` 的一个很好的特性是，除了静态矩阵外，你还可以以流式的方式添加更多数据，这允许你进行实时分析而无需太多开销。
- en: 'As an example, let’s assume we have a list of temperatures for a living room
    thermostat and see if we can find any repeating patterns:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们假设我们有一个客厅恒温器的温度列表，看看我们是否能找到任何重复的模式：
- en: '[PRE20]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The observant among you may have noticed that this distance matrix only has
    `4` rows for `6` values instead of the traditional `n*n` (`6*6` in this case)
    distance matrix. This is in part because we use a window size of `3` and we only
    look at the number of windows (which is `n-window_size+1=4`). A larger part is
    due to `stumpy` storing only the closest pairs, resulting in only requiring `O(n)`
    space instead of the normal `O(n*n)`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察的你们可能已经注意到，这个距离矩阵只有 `4` 行 `6` 个值，而不是传统的 `n*n`（在这个例子中是 `6*6`）距离矩阵。部分原因是因为我们使用了
    `3` 的窗口大小，我们只查看窗口的数量（即 `n-window_size+1=4`）。更大的部分原因是 `stumpy` 只存储最近的配对，从而只需要 `O(n)`
    的空间，而不是正常的 `O(n*n)`。
- en: While you can do these types of analysis with plain `numpy` as well, `stumpy`
    uses a very smart algorithm and relies heavily on `numba` for faster processing,
    so if you can use the library, I would recommend it.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你也可以用普通的 `numpy` 进行这些类型的分析，但 `stumpy` 使用一个非常智能的算法，并且高度依赖 `numba` 以实现更快的处理，所以如果你可以使用这个库，我推荐你使用它。
- en: Mathematics and precise calculations
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数学与精确计算
- en: Python has a decent number of mathematical functions and features built in,
    but there are cases where you need more advanced features or something faster.
    In this section, we will discuss a few libraries that help by introducing many
    extra mathematical functions and/or increase mathematical precision and/or performance
    quite a bit.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Python 内置了许多数学函数和特性，但在某些情况下，你需要更高级的功能或更快的速度。在本节中，我们将讨论几个库，这些库通过引入许多额外的数学函数、提高数学精度和/或性能来提供帮助。
- en: 'First, let’s discuss the options in the Python core libraries to store numbers
    and perform calculations with varying precision:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们讨论一下 Python 核心库中存储数字和执行不同精度计算的选项：
- en: '`int`: To store whole numbers (e.g. `1, 2, 3`), we have the `int` object in
    Python. The `int` is directly translated into a C `int64` on most systems as long
    as it can fit within 64-bit. Outside of that, it is internally cast to a Python
    `long` type (not to be confused with a C `long`), which can be arbitrarily large.
    This allows for infinite accuracy but only works as long as you use whole numbers.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`：在 Python 中，为了存储整数（例如 `1, 2, 3`），我们有 `int` 对象。只要它能在 64 位内适应，`int` 就会被直接转换为
    C 的 `int64`。超出这个范围，它会被内部转换为 Python 的 `long` 类型（不要与 C 的 `long` 混淆），它可以任意大。这允许无限精度，但只有在使用整数时才有效。'
- en: '`fractions.Fraction`: The `Fraction` object makes it possible to store fractional
    numbers (for example, `1/2`, `1/3`, `2/3`) and they are infinitely precise since
    they rely on two `int` (or `long`) objects internally as the denominator and the
    numerator. However, these only work if the number you are trying to store can
    be represented as a fraction. Irrational numbers such as Pi cannot be represented
    this way.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fractions.Fraction`：`Fraction` 对象使得存储分数数（例如，`1/2`、`1/3`、`2/3`）成为可能，并且由于它们内部依赖于两个
    `int`（或 `long`）对象作为分子和分母，它们是无限精确的。然而，这些只有在你要存储的数字可以表示为分数时才有效。例如，π 这样的无理数不能以这种方式表示。'
- en: '`float`: Floating point numbers make it really easy to store numbers that include
    decimals (for example `1.23`, `4.56`). These numbers are generally stored as a
    64-bit floating point, which is a combination of a sign (1 bit positive or negative),
    exponent (11 bits), and a fraction (52 bits), resulting in the following equation:![](img/B15882_15_002.png)
    . This means that a number such as 0.5 is stored using fraction 0 and exponent
    -1, resulting in: ![](img/B15882_15_003.png) . In the case of 0.5, this can be
    stored perfectly; in many other cases, this is problematic because not every number
    can be accurately described like this, which causes floating point inaccuracies.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`: 浮点数使得存储包含小数的数字（例如 `1.23`、`4.56`）变得非常容易。这些数字通常以 64 位浮点数的形式存储，它是由一个符号（1
    位正或负）、指数（11 位）和分数（52 位）的组合，导致以下方程：![](img/B15882_15_002.png) 。这意味着像 0.5 这样的数字使用分数
    0 和指数 -1 来存储，导致：![](img/B15882_15_003.png) 。在 0.5 的情况下，这可以完美存储；在许多其他情况下，这可能会出现问题，因为并非每个数字都可以像这样精确描述，这导致了浮点数的不精确。'
- en: '`decimal.Decimal`: The `Decimal` object allows for calculations with an arbitrary
    but specified precision. You can choose how many decimals you want, but it is
    not all that fast.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decimal.Decimal`: `Decimal` 对象允许进行具有任意但指定精度的计算。你可以选择你想要的位数，但它的速度并不快。'
- en: Several of the following libraries offer solutions to enhance the precision
    of your calculations.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下库中的几个提供了增强计算精度的解决方案。
- en: gmpy2 – Fast and precise calculations
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: gmpy2 – 快速且精确的计算
- en: The `gmpy2` library uses libraries that are written in C for really fast high-precision
    calculations. On Linux/Unix systems it will rely on GMP (hence the name); on Windows
    it will use MPIR, which is based on GMP. Additionally, the MPFR and MPC libraries
    are used for correctly rounding floating point real and complex numbers respectively.
    Lastly, it uses `mpz_lucas` and `mpz_prp` for really fast primality testing.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`gmpy2` 库使用用 C 语言编写的库，以实现真正快速的高精度计算。在 Linux/Unix 系统上，它将依赖于 GMP（因此得名）；在 Windows
    上，它将使用基于 GMP 的 MPIR。此外，MPFR 和 MPC 库分别用于正确地四舍五入浮点实数和复数。最后，它使用 `mpz_lucas` 和 `mpz_prp`
    进行快速素性测试。'
- en: 'Here’s a tiny example on how to get Pi to 1000 places, which you can’t easily
    do with the Python core library:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个如何将 π 计算到 1000 位的微小示例，这用 Python 核心库是难以轻易做到的：
- en: '[PRE21]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This library is invaluable if you need fast and high-precision calculations.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要快速且高精度的计算，这个库是无价的。
- en: 'For my personal use case, the `gmpy` library (`gmpy2` didn’t exist yet at that
    time) has been extremely helpful when competing in the fun online math challenge
    project called Project Euler: [https://projecteuler.net/](https://projecteuler.net/).'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我的个人用例，`gmpy` 库（当时 `gmpy2` 还不存在）在参加名为 Project Euler 的有趣在线数学挑战项目时非常有帮助：[https://projecteuler.net/](https://projecteuler.net/)。
- en: Sage – An alternative to Mathematica/Maple/MATLAB
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Sage – Mathematica/Maple/MATLAB 的替代品
- en: If you have ever taken an advanced math class in college or university, chances
    are that you have encountered software such as Mathematica, Maple, MATLAB, or
    Magma. Or perhaps you have used WolframAlpha, which is built on Mathematica. The
    Sage project is meant as a free and open source alternative to those really expensive
    software packages.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾在大学或学院上过高级数学课程，那么你很可能遇到过 Mathematica、Maple、MATLAB 或 Magma 等软件。或者你可能使用过基于
    Mathematica 的 WolframAlpha。Sage 项目旨在作为那些真正昂贵的软件包的免费和开源替代品。
- en: For reference, at the time of writing, the basic Mathematica Home edition, which
    can only run at 4 CPU cores at the same time, costs 413 euros (487 US dollars).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参考，在撰写本文时，基本 Mathematica Home 版本，只能同时运行在 4 个 CPU 核心上，售价为 413 欧元（487 美元）。
- en: The Sage package can be used to solve equations both numerically and exactly,
    plot charts, and perform many other tasks from the Sage interpreter. Similar to
    IPython and Jupyter, Sage offers its own interpreter with a custom language so
    it feels closer to mathematical packages such as Mathematica. Naturally, you could
    import the Sage code from regular Python as well.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Sage 软件包可以用来求解方程，无论是数值解还是精确解，绘制图表，以及从 Sage 解释器执行许多其他任务。类似于 IPython 和 Jupyter，Sage
    提供了自己的解释器，并使用自定义语言，因此感觉更接近 Mathematica 等数学软件包。当然，你也可以从常规 Python 中导入 Sage 代码。
- en: 'A small example of solving for a variable using Sage with the Sage interpreter:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Sage 和 Sage 解释器求解变量的一个小例子：
- en: '[PRE22]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this case, we asked Sage to solve an equation with three variables for us
    given the following constraints:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们要求 Sage 根据以下约束条件为我们解一个包含三个变量的方程：
- en: '![](img/B15882_15_004.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15882_15_004.png)'
- en: '![](img/B15882_15_005.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15882_15_005.png)'
- en: '![](img/B15882_15_006.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15882_15_006.png)'
- en: 'According to Sage (correctly), this results in:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Sage（正确地），结果是：
- en: '![](img/B15882_15_007.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15882_15_007.png)'
- en: If you are looking for a full-fledged mathematical software system (or some
    features of one), Sage is a good option.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找一个完整的数学软件系统（或其中的一些功能），Sage是一个不错的选择。
- en: mpmath – Convenient, precise calculations
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: mpmath – 方便、精确的计算
- en: The `mpmath` library is an all-round mathematical library offering functions
    for trigonometry, calculus, matrices, and many others while still maintaining
    a configurable precision.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`mpmath`库是一个全面的数学库，提供了三角学、微积分、矩阵以及其他许多函数，同时仍然可以配置精度。'
- en: Installing `mpmath` is really easy since it is pure Python and has no required
    dependencies, but it does offer speedups using Sage and `gmpy2` if they are available.
    This combines the benefits of the Sage and `gmpy2` libraries for speed with the
    convenience of a pure Python installation if those are not available.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`mpmath`是纯Python编写且没有必需的依赖项，因此安装它非常简单，但如果它们可用，它确实提供了使用Sage和`gmpy2`的速度提升。如果这些库不可用，这结合了Sage和`gmpy2`库的速度优势，以及纯Python安装的便利性。
- en: 'Let’s illustrate the advantages of configurable precision versus regular floating
    point numbers in Python:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来说明在Python中可配置精度与常规浮点数之间的优势：
- en: '[PRE23]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As you can see, both regular addition and `sum()` are both inaccurate. Python
    does have a better method available for this specific problem:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，常规加法和`sum()`都是不准确的。Python确实有更好的方法可以用于这个问题：
- en: '[PRE24]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When it comes to the general case, however, floating point math will always
    be inaccurate and at times that can be problematic. So, if your calculations do
    require floating point math but you want more accuracy, `mpmath` can help you:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当涉及到一般情况时，浮点数学总是不准确的，有时这可能会成为问题。所以，如果你的计算确实需要浮点数学但希望有更高的精度，`mpmath`可以帮到你：
- en: '[PRE25]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: While these results are obviously still not perfect (you would assume the result
    to be 1.0, like what `math.fsum()` produced), it can help to reduce floating point
    errors a lot more. Make sure to feed `mpmath` strings or integers, otherwise your
    variable can already introduce floating point errors. If we had used `x` in the
    sum instead of `y`, it would have resulted in floating point inaccuracy similar
    to regular Python math.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些结果显然仍然不完美（你会假设结果应该是1.0，就像`math.fsum()`产生的结果一样），但它可以帮助大大减少浮点误差。确保向`mpmath`提供字符串或整数，否则你的变量可能已经引入了浮点误差。如果我们用`x`而不是`y`来求和，它会导致与常规Python数学相似的浮点不精确。
- en: Naturally, `fpmath` can do a lot more than simply reduce your floating point
    errors, such as plotting and calculus, but I will leave that for you to explore.
    If you are looking for solutions to mathematical problems, this library should
    be on your list.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，`fpmath`可以做的不仅仅是减少你的浮点误差，比如绘图和微积分，但我将留给你去探索。如果你在寻找数学问题的解决方案，这个库应该在你的列表上。
- en: SymPy – Symbolic mathematics
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SymPy – 符号数学
- en: The `sympy` module is a library that you might never need, but it is such a
    great library that it should be covered. The goal of `sympy` is to be a fully
    featured **Computer Algebra System** (**CAS**) so you can manipulate mathematical
    expressions similar to how you would do so on paper.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`sympy`模块是一个你可能永远都不需要用到的库，但它是一个如此出色的库，应该被介绍。`sympy`的目标是成为一个功能齐全的**计算机代数系统**（CAS），这样你就可以像在纸上那样操作数学表达式。'
- en: 'Let’s start with a little demo on how we can express and solve an integral
    using `sympy`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个小演示开始，看看我们如何使用`sympy`表达和求解一个积分：
- en: '[PRE26]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Apologies if this gave you horrible flashbacks to some calculus exam, but I
    think it is amazing to be able to do this. This code first imports `sympy` using
    a wildcard because the equations would quickly become unreadable if all functions
    needed to be prefixed by `sympy`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这让你想起了某些微积分考试，我感到很抱歉，但我认为能够做到这一点真是太神奇了。这段代码首先使用通配符导入`sympy`，因为如果所有函数都需要以`sympy`为前缀，方程将很快变得难以阅读。
- en: After that, we use the `init_printing()` function with the Unicode flag enabled
    to tell `sympy` that our shell supports Unicode characters. This allows for pretty
    rendering of many mathematical formulas, but certainly not all of them. The alternatives
    to this are basic ASCII rendering (as you can imagine, this does not look too
    pretty for an integral), and LaTeX output, which can render as images (for example,
    when using Jupyter). There are actually several other rendering modes available,
    but they greatly depend on your environment so we will not be getting into those.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用带有Unicode标志的`init_printing()`函数来告诉`sympy`我们的shell支持Unicode字符。这允许渲染许多数学公式，但当然不是所有公式。这个替代方案是基本的ASCII渲染（正如你可以想象的那样，对于一个积分来说，这看起来并不太美观），以及LaTeX输出，它可以渲染为图像（例如，当使用Jupyter时）。实际上，还有其他几种渲染模式可用，但它们很大程度上取决于你的环境，所以我们不会深入探讨这些。
- en: Because you can use any variable name in an equation, we need to specifically
    declare `x`, `y`, and `z` as variables. Even though we only use `x` in this case,
    you will often need the others as well, so why not declare them in advance?
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你可以在方程中使用任何变量名，我们需要特别声明`x`、`y`和`z`为变量。尽管在这个例子中我们只使用了`x`，但你通常还需要其他变量，所以为什么不提前声明它们呢？
- en: 'Now we use the `Integral` function to declare the integral. Due to font limitations,
    the example above is not perfect, but the rendered integral should look like this
    in your shell or browser:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用`Integral`函数来声明积分。由于字体限制，上面的例子并不完美，但在你的shell或浏览器中渲染的积分应该看起来像这样：
- en: '![](img/B15882_15_008.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15882_15_008.png)'
- en: 'Lastly, we tell `sympy` to solve the integral using the `doit()` method. This
    correctly results in the equation:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们告诉`sympy`使用`doit()`方法来解决积分。这正确地得到了以下方程：
- en: '![](img/B15882_15_009.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15882_15_009.png)'
- en: The only nitpick I have here is that `sympy` omits the integration constant
    by default. Ideally, it would include the `+ C`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里的唯一小问题是`sympy`默认省略了积分常数。理想情况下，它应该包括`+ C`。
- en: If you’re looking to represent (and solve) an equation, `sympy` can certainly
    help. I personally think it is a really great library even though I have very
    little use for it.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找表示（并解决）方程的方法，`sympy`当然可以帮到你。我个人认为这是一个非常棒的库，尽管我很少使用它。
- en: Patsy – Describing statistical models
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Patsy – 描述统计模型
- en: 'Similar to how `sympy` can describe mathematical formulas in Python, `patsy`
    can describe statistical models, which makes it go hand in hand with the `statsmodels`
    package. It can also use regular Python functions or directly apply `numpy`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 与`sympy`可以在Python中描述数学公式类似，`patsy`可以描述统计模型，这使得它与`statsmodels`包相辅相成。它还可以使用常规Python函数或直接应用`numpy`：
- en: '[PRE27]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this example, we created a `numpy` array with a range from 2 to 6 and passed
    this to the `patsy.dmatrix()` function under the names `a`, `b`, and `c`, since
    duplicate names will be ignored. After that, we created the matrix using `patsy`;
    as you can see, the `+` in the `patsy` language tells it to add a new column.
    Those columns can be plain columns such as `a`, but they can also call functions
    such as `np.square(b)`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个从2到6范围的`numpy`数组，并以`a`、`b`和`c`的名称传递给`patsy.dmatrix()`函数，因为重复的名称将被忽略。之后，我们使用`patsy`创建了矩阵；正如你所看到的，`patsy`语言中的`+`告诉它添加一个新列。这些列可以是普通的列，如`a`，也可以调用函数，如`np.square(b)`。
- en: If you are familiar with the mathematics behind vectors and matrices, this library
    might feel very natural to you. At the very least, it can be a slightly more obvious
    way to declare how your data interacts.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉向量和矩阵背后的数学，这个库可能对你来说非常自然。至少，它是一个稍微明显一些的方式来声明你的数据是如何交互的。
- en: Plotting, graphing, and charting
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘图、图形和图表
- en: 'Being able to read, process, and write data is important, of course, but to
    understand the meaning of data it is often far more convenient to create a plot,
    graph, or chart. As the old adage goes: “A picture is worth a thousand words.”'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，能够读取、处理和写入数据很重要，但为了理解数据的意义，通常更方便的是创建一个图表、图形或图表。正如古老的谚语所说：“一图胜千言。”
- en: If you have experience with any of the libraries mentioned earlier in this chapter,
    you may know that many of them have options for graphical output. In (almost?)
    all cases, however, this is not really a built-in feature but a convenient shortcut
    to an external library such as `matplotlib`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这章前面提到的任何库中有所经验，你可能知道它们中的许多都提供了图形输出的选项。然而，在（几乎）所有情况下，这并不是一个真正的内置功能，而是一个方便的快捷方式，指向外部库，例如`matplotlib`。
- en: As is the case with several of the libraries mentioned in this chapter, there
    are multiple libraries with similar features and possibilities, so this is certainly
    not an exhaustive list. To make visual plotting easier, for these examples we
    will mostly rely on `jupyter-notebook` with the use of the `ipywidgets` to create
    interactive samples. As always, the code (in these cases, the `jupyter-notebooks`)
    can be found on GitHub at [https://github.com/mastering-python/code_2](https://github.com/mastering-python/code_2).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章中提到的几个库类似，存在多个具有相似功能和可能性的库，因此这当然不是一个详尽的列表。为了使可视化绘图更容易，对于这些示例，我们将主要依靠`jupyter-notebook`，并使用`ipywidgets`来创建交互式示例。一如既往，代码（在这些情况下，是`jupyter-notebooks`）可以在GitHub上找到，网址为[https://github.com/mastering-python/code_2](https://github.com/mastering-python/code_2)。
- en: Matplotlib
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Matplotlib
- en: The `matplotlib` library is the reliable standard for plotting and is supported
    by many of the scientific libraries in this chapter.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`matplotlib`库是可靠的绘图标准，并得到本章中许多科学库的支持。'
- en: Most of the libraries mentioned earlier in this chapter either explain how `matplotlib`
    can be used with the library, or even have utility functions to facilitate plotting
    with `matplotlib`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 本章前面提到的大多数库要么解释了如何使用`matplotlib`与库结合，要么甚至有实用函数来简化使用`matplotlib`的绘图。
- en: Does this mean that the `matplotlib` library is the gold standard for plotting?
    As usual, it depends. While `matplotlib` is certainly the most used scientific
    plotting Python library with a huge array of features, it is not always the most
    beautiful option. That doesn’t mean you cannot configure it to be pretty, but
    out of the box, the library focuses on easy-to-read, consistent results and works
    for everyone and all scenarios. Some of the prettier libraries might look fantastic
    on a web page and have very useful interactive features but are not that suited
    for publishing and printing.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着`matplotlib`库是绘图的金标准？像往常一样，这取决于。虽然`matplotlib`无疑是使用最广泛的科学绘图Python库，具有大量功能，但它并不总是最美观的选项。这并不意味着你不能配置它使其变得美观，但出厂时，库专注于易于阅读、一致的结果，适用于所有人所有场景。一些更美观的库可能在网页上看起来很棒，并且具有非常实用的交互功能，但并不适合出版和打印。
- en: 'The basic example is trivially easy:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 基本示例非常简单：
- en: '[PRE28]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Effectively, we only need `plt.plot()` to plot a basic chart:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们只需要`plt.plot()`来绘制基本图表：
- en: '![](img/B15882_15_01.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15882_15_01.png)'
- en: 'Figure 15.1: Matplotlib plot'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1：Matplotlib图表
- en: 'This simple example was very easy to plot, but `matplotlib` can do so much
    more. Let’s take a look at how we can combine a few graphs and make the plot interactive
    using `ipywidgets`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的示例非常容易绘制，但`matplotlib`可以做更多的事情。让我们看看我们如何结合几个图表，并使用`ipywidgets`使绘图交互式：
- en: '[PRE29]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This function generates the following figure:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数生成以下图表：
- en: '![](img/B15882_15_02.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15882_15_02.png)'
- en: 'Figure 15.2: Matplotlib in Jupyter Notebook with adjustable sliders'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2：Jupyter Notebook中的Matplotlib，带有可调节的滑块
- en: With a combination of `jupyter-notebook` and `matplotlib`, we can create interactive
    plots. If you run this in your own browser, not only can you drag the 3D plot
    around and view it from all sides, but you can also modify the `size` and `step`
    parameters by dragging the sliders.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 结合`jupyter-notebook`和`matplotlib`，我们可以创建交互式图表。如果你在自己的浏览器中运行它，不仅你可以拖动3D图表并在各个方向上查看它，你还可以通过拖动滑块来修改`size`和`step`参数。
- en: With regard to actual plot types supported by `matplotlib`, there are really
    too many options and variations to list here, but if you are looking for any type
    of chart, graph, or plot, you are likely to find a solution using `matplotlib`.
    Additionally, many of the scientific Python libraries natively support it, which
    makes it an easy choice. This short section really does not do justice to the
    depth and features of `matplotlib`, but fear not – we are far from done with it
    as it, is the basis of a few other plotting libraries in this chapter.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`matplotlib`支持的绘图类型，选项和变体实在太多，无法在此列出，但如果你在寻找任何类型的图表、图形或绘图，你很可能会在`matplotlib`中找到解决方案。此外，许多科学Python库原生支持它，这使得它成为一个容易的选择。这个简短的章节确实没有公正地体现`matplotlib`的深度和功能，但不用担心——我们离完成它还远着呢，因为它是本章中几个其他绘图库的基础。
- en: Seaborn
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Seaborn
- en: The `seaborn` library is related to `matplotlib` in a similar way to how `statsmodels`
    works on top of `pandas`. It provides an interface for `matplotlib` with a strong
    focus on statistical data. The major feature of `seaborn` is that it makes it
    really easy to automatically generate an entire grid of plots.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`seaborn` 库与 `matplotlib` 的关系类似于 `statsmodels` 在 `pandas` 之上的工作方式。它提供了一个针对统计数据的
    `matplotlib` 接口。`seaborn` 的主要特点是它使得自动生成整个网格图变得非常容易。'
- en: 'Additionally, which is very convenient for our examples, `seaborn` comes with
    some test data so we can show fully fledged demonstrations based on real data.
    To illustrate, let’s look at how easily we can create a very elaborate set of
    plots:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这对于我们的示例来说非常方便，`seaborn` 随带一些测试数据，因此我们可以基于真实数据展示完整的演示。为了说明，让我们看看我们如何轻松地创建一组非常复杂的图表：
- en: '[PRE30]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This produces the following set of plots:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下一系列图表：
- en: '![](img/B15882_15_03.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15882_15_03.png)'
- en: 'Figure 15.3: Seaborn pairplot render'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3：Seaborn对数图渲染
- en: While this still seems like a very elaborate call, you could actually get away
    with just using `sns.pairplot(df)` to get great results. Without the `hue=...`
    parameter, the results will not be split by species, however.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这看起来仍然是一个非常复杂的调用，但实际上你只需使用 `sns.pairplot(df)` 就可以得到很好的结果。如果没有 `hue=...` 参数，结果将不会按物种分割。
- en: 'The `seaborn` library has support for many types of plots:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`seaborn` 库支持许多类型的图表：'
- en: Relational plots such as line plots and scatter plots
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系图，如线图和散点图
- en: Distribution plots such as histograms
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布图，如直方图
- en: Categorical plots such as box plots
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类别图，如箱线图
- en: Matrix plots such as heatmaps
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵图，如热图
- en: The `seaborn` library also has many shortcuts for creating sets of plots or
    automatically processing the data using algorithms such as kernel density estimation.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`seaborn` 库也有许多创建图表集或使用如核密度估计等算法自动处理数据的快捷方式。'
- en: If you are looking for a nice-looking plotting library, `seaborn` is a very
    good option, especially due to the multi-plot grid features. The list of plots
    above are all specific plots, but as we saw with `pairplot`, `seaborn` can generate
    an entire grid of plots in just a single line of code, which is extremely useful.
    You could do the same with `matplotlib` directly, but it would probably take you
    a few dozen lines of code.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找一个看起来很棒的绘图库，`seaborn` 是一个非常好的选择，尤其是由于其多图网格功能。上面列出的图表都是特定图表，但正如我们在 `pairplot`
    中看到的，`seaborn` 只需一行代码就可以生成整个网格图，这非常实用。你可以直接使用 `matplotlib` 做同样的事情，但可能需要几十行代码。
- en: Yellowbrick
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Yellowbrick
- en: As is the case with `seaborn`, `yellowbrick` is also built on top of `matplotlib`.
    The difference is that `yellowbrick` is focused on visualizing machine learning
    results and depends on the scikit-learn (`sklearn`) machine learning library.
    The scikit-learn integration is also what makes this library very powerful in
    those scenarios; it natively understands the scikit-learn data structures so it
    can easily plot them for you with almost no configuration. In the next chapter,
    we will see more on scikit-learn.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `seaborn` 类似，`yellowbrick` 也是建立在 `matplotlib` 之上的。区别在于 `yellowbrick` 专注于可视化机器学习结果，并依赖于
    scikit-learn (`sklearn`) 机器学习库。scikit-learn 的集成也使得这个库在这些场景中非常强大；它原生理解 scikit-learn
    的数据结构，因此可以几乎无需配置就为你轻松绘制它们。在下一章中，我们将看到更多关于 scikit-learn 的内容。
- en: 'This example, straight from the `yellowbrick` manual, shows how you can visualize
    a regression in effectively a single line of code:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子直接来自 `yellowbrick` 手册，展示了你如何仅用一行代码可视化回归：
- en: '[PRE31]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This generates the following scatter plot:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这会生成以下散点图：
- en: '![](img/B15882_15_04.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15882_15_04.png)'
- en: 'Figure 15.4: Yellowbrick regression plot'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.4：Yellowbrick回归图
- en: These kinds of shortcut functions make it really easy to generate usable output
    and work on your regression instead of having to worry about how to properly plot
    the data. In addition to plotting regressions, `yellowbrick` has many more visualizers
    organized by analysis type. Similar to `seaborn`, `yellowbrick` can take care
    of not only the plotting but also the calculations and analysis for you.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这类快捷函数使得生成可用的输出并专注于回归分析变得非常容易，而不必担心如何正确地绘制数据。除了绘制回归图，`yellowbrick` 还提供了许多按分析类型组织的可视化工具。与
    `seaborn` 类似，`yellowbrick` 可以为你处理不仅绘图，还包括计算和分析。
- en: 'The `yellowbrick` library has functions for many types of analysis such as:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`yellowbrick` 库提供了许多类型分析的功能，例如：'
- en: '**Feature visualization**: Displaying features as scatter plots, detecting
    relationships and ranking them, creating a circular plot of related features,
    and so on'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特征可视化**：以散点图的形式显示特征，检测并排序它们，创建相关特征的圆形图等'
- en: '**Classification visualization**: Displaying the thresholds, precision, and
    the error prediction for classifications as line, area, or matrix plots'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分类可视化**：以线图、面积图或矩阵图的形式显示分类的阈值、精确度和错误预测'
- en: '**Regression visualization**: Displaying a scatter or a combination of scatter
    plots and histograms'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回归可视化**：显示散点图或散点图与直方图的组合'
- en: '**Cluster visualization**: Displaying maps to visualize the distance between
    the clusters'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚类可视化**：显示地图以可视化聚类之间的距离'
- en: '**Model selection visualization**: Displaying the learning curve through a
    combination of lines and area or showing the feature importance as a bar chart'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型选择可视化**：通过线条和面积或显示特征重要性的条形图来显示学习曲线'
- en: The `yellowbrick` library is currently the most convenient option for visualizing
    scikit-learn output, but most of the charting options also apply to other data
    types such as `pandas.DataFrame` objects, so it’s worth taking a look if `seaborn`
    does not suit your needs.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`yellowbrick`库是目前可视化scikit-learn输出的最方便的选择，但大多数图表选项也适用于其他数据类型，如`pandas.DataFrame`对象，所以如果`seaborn`不适合您的需求，值得一看。'
- en: Plotly
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Plotly
- en: The `plotly` library supports a lot of different types of plots and even has
    native support for controls such as sliders, so you can change parameters when
    viewing from a web browser. Additionally, similar to how `seaborn` makes usage
    of `matplotlib` much easier in some cases, `plotly` also includes Plotly Express
    (often denoted as `px`), which makes usage trivially easy.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`plotly`库支持许多不同类型的图表，甚至有对滑块等控件的原生支持，因此您可以在通过网页浏览器查看时更改参数。此外，类似于`seaborn`在某些情况下使`matplotlib`的使用更加容易，`plotly`也包括Plotly
    Express（通常表示为`px`），这使得使用变得极其简单。'
- en: 'To illustrate how easy Plotly Express can be, let’s try to replicate the plots
    we made with `seaborn`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明Plotly Express有多容易使用，让我们尝试复制我们用`seaborn`制作的图表：
- en: '[PRE32]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here is the result:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果：
- en: '![](img/B15882_15_05.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15882_15_05.png)'
- en: 'Figure 15.5: Plotly Express example output'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.5：Plotly Express示例输出
- en: While I would argue that the `seaborn` output is slightly prettier in this specific
    case, it does show just how easy it is to create useful plots using Plotly Express.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我可能会认为在这个特定情况下`seaborn`的输出稍微更美观一些，但它确实展示了使用Plotly Express创建有用图表的简便性。
- en: 'You might be wondering how easy or difficult it is to use the regular `plotly`
    API, as opposed to Plotly Express. For that, let’s see if we can replicate the
    3D `matplotlib` render:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道使用常规`plotly` API有多容易或困难，与Plotly Express相比。为此，让我们看看我们是否可以复制3D `matplotlib`渲染：
- en: '[PRE33]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here’s the final result with the two cosines plotted in 3D:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是两个余弦函数在3D中绘制的最终结果：
- en: '![](img/B15882_15_06.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15882_15_06.png)'
- en: 'Figure 15.6: 3D plot using plotly'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.6：使用plotly的3D绘图
- en: This is pretty much identical to `matplotlib`, and I would argue that it’s even
    slightly better due to being even more interactive (which the book cannot effectively
    show, unfortunately). By default, `plotly` features a very useful display of the
    values when you hover with the mouse and allows for really easy zooming and filtering
    interactively.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上与`matplotlib`相同，我会说它甚至稍微好一些，因为它的交互性更强（遗憾的是，这本书无法有效地展示这一点）。默认情况下，`plotly`在您用鼠标悬停时提供了一个非常有用的值显示，并允许您进行交互式的缩放和过滤。
- en: When it comes to the choice between `matplotlib` and `plotly`, I would recommend
    looking at your specific use case. I think `plotly` is slightly easier and more
    convenient to use, but `matplotlib` is deeply integrated with many scientific
    Python libraries, which makes it a very convenient option. As always, opinions
    vary, so make sure to take a look at both.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到在`matplotlib`和`plotly`之间进行选择时，我建议查看您的具体用例。我认为`plotly`使用起来稍微容易一些，也更方便，但`matplotlib`与许多科学Python库深度集成，这使得它成为一个非常方便的选择。像往常一样，意见各不相同，所以请确保查看两者。
- en: Bokeh
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bokeh
- en: The `bokeh` library is a beautiful and powerful visualization library with a
    strong focus on interactive visualizations in web browsers. Being able to make
    plots interactive can be extremely useful for analyzing the results. Instead of
    having to create multiple plots in a grid as we saw with `seaborn`, you can use
    a single grid and filter interactively. As this is a book, however, we cannot
    really demonstrate the full power of `bokeh`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`bokeh` 库是一个美丽且功能强大的可视化库，它专注于在网页浏览器中进行交互式可视化。能够使图表交互式可以非常有助于分析结果。与我们在 `seaborn`
    中看到的不同，你不需要在网格中创建多个图表，你可以使用单个网格并交互式地过滤。然而，由于这是一本书，我们无法真正展示 `bokeh` 的全部功能。'
- en: Before we get started with some examples, we need to talk about the two ways
    you can use `bokeh`. Effectively it comes down to **static** versus **dynamic**,
    where the static version uses a static snapshot of all data shown and the dynamic
    version loads data on demand.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始一些示例之前，我们需要讨论你可以使用 `bokeh` 的两种方式。实际上，这归结为**静态**与**动态**，静态版本使用所有显示数据的静态快照，而动态版本按需加载数据。
- en: 'The static version is similar to how `matplotlib` and most plotting libraries
    work: all data is contained in a single image or on a single web page without
    loading external resources. This works great for many cases, but not all.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 静态版本与 `matplotlib` 和大多数绘图库的工作方式相似：所有数据都包含在单个图像或单个网页上，无需加载外部资源。这对于许多情况来说效果很好，但并非所有情况都适用。
- en: What if you have a *lot* of data? A nice example of a visualization like this
    is Google Earth. You could never realistically download all of the data from Google
    Earth onto your computer (according to some estimates, currently over 100 petabytes
    of data), so you need to load it as you move around the map. For this purpose,
    `bokeh` has a server built in so the visualization can dynamically load the results
    as you filter. For the purpose of this book that makes little sense because it
    will be static in all cases, but we can show examples of both.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有很多数据呢？这种可视化的一个很好的例子是谷歌地球。你永远不可能现实地将谷歌地球上的所有数据下载到你的电脑上（据估计，目前超过100个拍字节的数据），所以你需要在你移动地图时加载它。为此，`bokeh`
    内置了一个服务器，以便在过滤时动态加载结果。对于这本书来说，这几乎没有意义，因为它在所有情况下都是静态的，但我们可以展示两个例子。
- en: 'First, let’s create a very basic plot:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个非常基础的图表：
- en: '[PRE34]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'From this, we get the sine and cosine rendered as lines:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，我们得到了以线条形式渲染的正弦和余弦函数：
- en: '![](img/B15882_15_07.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15882_15_07.png)'
- en: 'Figure 15.7: Bokeh basic render'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.7：Bokeh基本渲染
- en: As you can see, rendering basic *x*/*y* data as a line is really easy and does
    not look too different from the `matplotlib` output. If you look carefully, however,
    you might also notice the buttons on the right. These are what `bokeh` calls **tools**,
    and they can be used for zooming by either scrolling or by drawing a rectangle
    around what you wish to see. Panning can be done by dragging the image. It is
    also possible to save the render as an image file. If desired, you can create
    tooltips that respond to mouse clicks or mouse hovers.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，将基本的 *x*/*y* 数据渲染为线条非常简单，并且看起来与 `matplotlib` 的输出没有太大区别。如果您仔细观察，您可能会注意到右侧的按钮。这些就是
    `bokeh` 所称的**工具**，您可以通过滚动或绘制一个矩形来放大您希望看到的内容。通过拖动图像可以进行平移。您还可以将渲染保存为图像文件。如果需要，您还可以创建对鼠标点击或鼠标悬停做出响应的工具提示。
- en: 'Now let’s see if we can recreate a more advanced plot like the one we made
    with `seaborn`:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们是否可以重新创建一个像我们用 `seaborn` 创建的那样更高级的图表：
- en: '[PRE35]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This results in a collection of scatter plots and histograms:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了一系列散点图和直方图：
- en: '![](img/B15882_15_08.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15882_15_08.png)'
- en: 'Figure 15.8: Seaborn-like plots using Bokeh'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.8：使用Bokeh创建类似Seaborn的图表
- en: This somewhat resembles what we created with `seaborn`, but it still took quite
    a bit of effort to do. It does show how we can fairly easily combine several plots
    (and types of plots) together even when using a `pandas.DataFrame` as a source.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这在一定程度上类似于我们用 `seaborn` 创建的，但仍然需要相当多的努力。它确实展示了即使使用 `pandas.DataFrame` 作为数据源，我们也可以相当容易地将多个图表（和图表类型）组合在一起。
- en: Should you use `bokeh`? I think `bokeh` is a nicely documented plotting library
    with a lot of merits, but so are many of the others. In my opinion, the main feature
    of `bokeh` is the support for dynamic data loading through the `bokeh` server,
    which can be a really useful feature in some cases. As opposed to `plotly`, the
    `bokeh` server has more features for maintaining its own state, so chart changes
    can be made easily without recalculation.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用`bokeh`吗？我认为`bokeh`是一个文档齐全的绘图库，有很多优点，但其他很多库也是如此。在我看来，`bokeh`的主要特点是支持通过`bokeh`服务器动态加载数据，这在某些情况下可能非常有用。与`plotly`不同，`bokeh`服务器有更多用于维护其自身状态的功能，因此可以轻松地在不重新计算的情况下进行图表更改。
- en: Datashader
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Datashader
- en: 'The `datashader` library is a special case but I believe it deserves a mention.
    The `datashader` plotting library can be used for regular plotting, but it is
    specially optimized for high performance and large datasets. As a little example,
    this plot with 10 million data points only takes about a second to render:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`datashader`库是一个特殊情况，但我相信它值得提及。`datashader`绘图库可以用于常规绘图，但它特别优化了高性能和大数据集。作为一个小例子，这个包含1000万个数据点的图表只需大约一秒钟就可以渲染：'
- en: '[PRE36]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here is the plot generated by calculating the 10 million points:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是计算了1000万个点生成的图表：
- en: '![/var/folders/ph/3d51j84d2gg_pltczn6244q80000gn/T/com.microsoft.Word/Content.MSO/EC6EBE9A.tmp](img/B15882_15_09.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15882_15_09.png)'
- en: 'Figure 15.9: Datashader attractor render'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.9：Datashader吸引子渲染
- en: Exercises
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Due to the nature of this chapter, we have only covered the absolute basics
    of the mentioned libraries and they really do deserve much more. In this case,
    as an exercise, I recommend that you try and use some (or all) of the mentioned
    libraries and see if you can do something useful with them, using the variety
    of examples we have introduced already as inspiration.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章的性质，我们只涵盖了所提及库的绝对基础，它们确实值得更多。在这种情况下，作为一个练习，我建议你尝试使用一些（或全部）所提及的库，看看你是否可以用它们做一些有用的事情，使用我们已介绍的各种示例作为灵感。
- en: 'Some suggestions:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 一些建议：
- en: Create your own beautiful datashader plots
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你自己的美丽datashader图表
- en: Render the lines of code per project of your personal workspace
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染你个人工作空间中每个项目的代码行数
- en: Continuing from the lines of code per project, see if you can cluster the projects
    by programming language
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从每个项目的代码行数继续，看看你是否可以按编程语言对项目进行聚类
- en: 'Example answers for these exercises can be found on GitHub: [https://github.com/mastering-python/exercises](Chapter_15.xhtml).
    You are encouraged to submit your own solutions and learn about alternative solutions
    from others.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这些练习的示例答案可以在GitHub上找到：[https://github.com/mastering-python/exercises](Chapter_15.xhtml)。我们鼓励你提交自己的解决方案，并从他人的替代方案中学习。
- en: Summary
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has shown us a sample of the most commonly used and generic scientific
    Python libraries. While it covered a lot of libraries, there are many more available,
    especially when you start looking for domain-specific libraries. With regard to
    plotting alone, there are at least several other very big libraries that could
    be useful for your use cases but would be superfluous for this chapter.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向我们展示了最常用和通用的科学Python库的样本。虽然它涵盖了大量的库，但还有更多可用的库，尤其是在你开始寻找特定领域库的时候。仅就绘图而言，至少还有几个其他非常大的库可能对你的用例很有用，但在这个章节中却是多余的。
- en: To recap, we have covered the basics of working with NumPy matrices and Pandas
    data objects, both of which are important for the next chapter. We have also seen
    a few libraries that focus on mathematics and really precise calculations. Lastly,
    we have covered several plotting libraries, some of which will be used in the
    next chapter as well.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，我们已经涵盖了使用NumPy矩阵和Pandas数据对象的基础，这两者对于下一章都很重要。我们还看到了一些专注于数学和精确计算的库。最后，我们涵盖了几个绘图库，其中一些将在下一章中也会用到。
- en: Next up is the chapter about artificial intelligence and machine learning in
    Python. As is the case with this chapter, we cannot go into too much depth, but
    we can cover the most important technologies and libraries so you know where to
    look.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是关于Python中人工智能和机器学习的章节。正如本章的情况一样，我们无法深入探讨，但我们可以涵盖最重要的技术和库，以便你知道该往哪里看。
- en: Join our community on Discord
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://discord.gg/QMzJenHuJf](https://discord.gg/QMzJenHuJf)'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：[https://discord.gg/QMzJenHuJf](https://discord.gg/QMzJenHuJf)
- en: '![](img/QR_Code156081100001293319171.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code156081100001293319171.png)'
