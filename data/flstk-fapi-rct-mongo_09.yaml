- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Third-Party Services Integration with FastAPI and Beanie
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用FastAPI和Beanie进行第三方服务集成
- en: After learning about the tools that compose the FARM stack, you will see them
    combined in a more complex setting in this chapter. You will build on your knowledge
    of Pydantic and FastAPI to learn about **Beanie,** one of the most popular MongoDB
    **Object-Document Mappers** (**ODMs**), and how it can make your code more efficient
    and enhance your developer experience.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了构成FARM堆栈的工具之后，你将在本章中看到它们在一个更复杂的设置中结合使用。你将基于你对Pydantic和FastAPI的知识，了解**Beanie**，这是最受欢迎的MongoDB
    **对象-文档映射器**（**ODM**）之一，以及它如何使你的代码更高效并提升你的开发者体验。
- en: Finally, you will see how the stack’s flexibility is useful when you need to
    extend your application with external, third-party functionality. In this chapter,
    you will add a fully AI-based salesperson assistant that will make use of OpenAI
    to create catchy car descriptions, and then you will use the **Resend** API service
    to send automated emails.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将看到当需要扩展应用程序以包含外部第三方功能时，堆栈的灵活性如何有用。在本章中，你将添加一个完全基于AI的销售助手，该助手将利用OpenAI创建吸引人的汽车描述，然后你将使用**Resend**
    API服务发送自动化的电子邮件。
- en: These functionalities are becoming more and more central to web application
    requirements in the modern web, and through this chapter, you will see how the
    right set of tools can make application development more efficient.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能在现代Web应用程序的要求中变得越来越重要，通过本章，你将看到正确的一组工具如何使应用程序开发更高效。
- en: 'This chapter will walk you through the following tasks:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将指导你完成以下任务：
- en: Installing and using Beanie – a Python MongoDB ODM
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和使用Beanie – 一个Python MongoDB ODM
- en: Learning about the basic Beanie features (connections, CRUD operations, and
    aggregations)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Beanie的基本功能（连接、CRUD操作和聚合）
- en: Using FastAPI’s background tasks to handle long-running processes while maintaining
    the responsiveness of the application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用FastAPI的后台任务处理长时间运行的过程，同时保持应用程序的响应性
- en: Programmatically sending emails from an application
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从应用程序中编程发送电子邮件
- en: Integrating OpenAI’s ChatGPT (or any other **Large Language** **Model** (**LLM**))
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成OpenAI的ChatGPT（或任何其他**大型语言模型**（**LLM**））
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The technical requirements for this chapter are similar to the requirements
    in the chapters in which we created backends with FastAPI, with the addition of
    a couple of libraries and services for the email-sending functionality and AI
    integration:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求与我们在FastAPI中创建后端章节中的要求相似，增加了用于电子邮件发送功能和对AI集成的几个库和服务：
- en: Python 3.11.7 or higher
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.11.7或更高版本
- en: Visual Studio Code with the Python extensions set up (same as in [*Chapter 3*](B22406_03.xhtml#_idTextAnchor051))
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置了Python扩展的Visual Studio Code（与[*第3章*](B22406_03.xhtml#_idTextAnchor051)中相同）
- en: An account on MongoDB Atlas
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB Atlas上的账户
- en: An account on Render.com (if you wish to deploy the FastAPI backend)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Render.com上的账户（如果你希望部署FastAPI后端）
- en: An OpenAI account with API access, or a free, locally run LLM such as Llama
    2 or Llama 3 in case you do not want to deploy the app and incur costs
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有API访问权限的OpenAI账户，或者如果你不想部署应用程序并产生费用，可以使用免费的、本地运行的LLM，如Llama 2或Llama 3
- en: A Netlify account (free tier)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Netlify账户（免费级别）
- en: We strongly recommend starting with the free (or cheapest) tiers of the previous
    accounts and making sure that you feel comfortable within these environments.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议从之前账户的免费（或最便宜的）级别开始，并确保你在这些环境中感到舒适。
- en: With the technical requirements out of the way, let’s discuss the project you
    will build throughout this chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决了技术要求之后，让我们讨论你将在本章中构建的项目。
- en: Project outline
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: Staying with the situation that you operate a (small) used car sales agency,
    the requirements are somewhat similar to the ones in the previous chapters. You
    will build a backend for a web app that displays information and pictures of cars
    that are for sale. Unlike the previous chapters, now you will use an ODM, and
    you will include email sending and OpenAI integration, which will be handled by
    FastAPI’s background tasks.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在你运营一个（小型）二手车销售代理机构的情境下，要求与前面章节中的要求有些相似。你将构建一个用于显示待售汽车信息和图片的Web应用的后端。与前面的章节不同，现在你将使用ODM，并且将包括电子邮件发送和OpenAI集成，这些将由FastAPI的后台任务处理。
- en: The car data model will be handled by Pydantic and Beanie. The application will
    need authenticated users and, while you will use `iron-session`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 汽车数据模型将由Pydantic和Beanie处理。应用程序将需要认证用户，而你将使用`iron-session`。
- en: Finally, you will integrate an LLM API (in this case, OpenAI) to help create
    useful car model descriptions, list the pros and cons of the newly inserted car
    model for the marketing pages, and send tailored emails to specified recipients
    on every new car ad insertion.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将集成一个 LLM API（在这种情况下，是 OpenAI），以帮助创建有用的汽车模型描述，列出新插入的汽车模型在营销页面上的优缺点，并在每次新汽车广告插入时向指定的收件人发送定制电子邮件。
- en: Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: LLMs are machine learning systems designed specifically to generate and understand
    human language. Trained on huge datasets, they are able to perform efficiently
    on tasks such as text summarization and generation, translation, and image generation.
    In the last couple of years, LLMs have gained popularity and adoption, and their
    fields of implementation will only grow over time.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: LLMs 是专门设计用于生成和理解人类语言的机器学习系统。在大型数据集上训练后，它们能够在文本摘要和生成、翻译和图像生成等任务上高效执行。在过去的几年中，LLMs
    获得了流行和采用，并且随着时间的推移，它们的实施领域将只会增长。
- en: In the next section, you will learn how to create a backend with FastAPI and
    Beanie and how to integrate OpenAI and email-sending functionality.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将学习如何使用 FastAPI 和 Beanie 创建后端，以及如何集成 OpenAI 和电子邮件发送功能。
- en: Building the backend with FastAPI and Beanie
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 FastAPI 和 Beanie 构建后端
- en: For simplicity’s sake and to make the application as illustrative as possible,
    the API that you will build in this chapter will not differ too much from the
    one built in [*Chapter 7*](B22406_07.xhtml#_idTextAnchor118), *Building a Backend
    with FastAPI*. This way, you will be able to naturally pick up the main differences
    in the approaches of using Motor (or PyMongo) directly and the Beanie ODM.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化起见，并使应用程序尽可能具有说明性，本章中你将构建的 API 将与在 [*第 7 章*](B22406_07.xhtml#_idTextAnchor118)，*使用
    FastAPI 构建后端* 中构建的 API 差别不大。这样，你将能够自然地掌握使用 Motor（或 PyMongo）直接和 Beanie ODM 的方法之间的主要差异。
- en: '**Object-Relational Mappers** (**ORMs**) and **ODMs** are tools whose main
    purpose is to abstract the underlying database (whether it’s a relational or non-relational
    database) and facilitate the development process. Some famous Python examples
    include the **Django ORM** and **SQLAlchemy**—two proven and battle-tested solutions—as
    well as **SQLModel**, which was created by the creator of FastAPI and tightly
    integrated into the FastAPI/Pydantic world.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象关系映射器**（**ORMs**）和 **ODMs** 是工具，其主要目的是抽象底层数据库（无论是关系型数据库还是非关系型数据库），并简化开发过程。一些著名的
    Python 示例包括 **Django ORM** 和 **SQLAlchemy**——两个经过验证和实战检验的解决方案——以及由 FastAPI 的创建者创建的
    **SQLModel**，它与 FastAPI/Pydantic 世界紧密集成。'
- en: Two modern ODMs that are gaining traction and popularity among the Python and
    MongoDB community are **Beanie** ([https://beanie-odm.dev/](https://beanie-odm.dev/))
    and **Odmantic** ([https://art049.github.io/odmantic/](https://art049.github.io/odmantic/)).
    In this project, you will be working with the more mature and older one of the
    two—the Beanie ODM.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 和 MongoDB 社区中越来越受欢迎的两个现代 ODM 是 **Beanie** ([https://beanie-odm.dev/](https://beanie-odm.dev/))
    和 **Odmantic** ([https://art049.github.io/odmantic/](https://art049.github.io/odmantic/))。在这个项目中，你将使用这两个中更成熟、更老的那个——Beanie
    ODM。
- en: Introduction to the Beanie ODM
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Beanie ODM 简介
- en: Beanie is one of the most popular MongoDB ODMs for Python. ODMs are a programming
    technique that allows developers to work directly with classes (Python classes
    in our case) representing NoSQL documents. When using Beanie, each MongoDB collection
    is mapped to a corresponding document class that allows you to retrieve or aggregate
    data and perform CRUD operations, saving time by removing the necessity of boilerplate
    code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Beanie 是 Python 最受欢迎的 MongoDB ODM 之一。ODM 是一种编程技术，允许开发人员直接与表示 NoSQL 文档的类（在我们的例子中是
    Python 类）一起工作。使用 Beanie 时，每个 MongoDB 集合都映射到一个相应的文档类，这使得你可以检索或聚合数据，并执行 CRUD 操作，通过消除样板代码的必要性来节省时间。
- en: Beanie also handles MongoDB’s `ObjectId` type elegantly, and since its document
    class is based on Pydantic, you get to use all of the powerful validation and
    parsing features of Pydantic right out of the box.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Beanie 还优雅地处理 MongoDB 的 `ObjectId` 类型，并且由于其文档类基于 Pydantic，你可以直接使用 Pydantic 的所有强大验证和解析功能。
- en: 'In brief, some of Beanie’s salient features include the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Beanie 的显著特性包括以下内容：
- en: Asynchronous, based on the Motor driver and ideal for performant FastAPI apps
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步的，基于 Motor 驱动器，非常适合性能良好的 FastAPI 应用程序
- en: Based on Pydantic and compatible with Pydantic version 2
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 Pydantic 并兼容 Pydantic 版本 2
- en: Schema-based, with seamless handling of `ObjectId` string conversions
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于模式，无缝处理 `ObjectId` 字符串转换
- en: Simple CRUD operations, as well as support for MongoDB’s powerful aggregation
    framework
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的 CRUD 操作，以及支持 MongoDB 强大的聚合框架
- en: In the following section, you will begin creating a Beanie-powered application
    through which you will learn some features of the ODM.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将通过创建一个 Beanie 驱动的应用程序来开始学习 ODM 的某些功能。
- en: Creating the Beanie application
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 Beanie 应用程序
- en: You will learn how to use Beanie by creating a new application and exploring
    the functionality provided by the ODM—connecting to a database, mapping collections
    to document classes, and performing CRUD operations on the documents.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过创建一个新应用程序并探索 ODM 提供的功能来学习如何使用 Beanie——连接到数据库、将集合映射到文档类，以及在文档上执行 CRUD 操作。
- en: 'To begin the project and scaffold the FastAPI application, perform the following
    steps:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始项目并搭建 FastAPI 应用程序，请执行以下步骤：
- en: 'Create a new folder (`chapter9`) and a virtual environment with the following
    command:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件夹（`chapter9`）和一个虚拟环境，使用以下命令：
- en: '[PRE0]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Activate the virtual environment with the following command (for Linux or Mac):'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令激活虚拟环境（适用于 Linux 或 Mac）：
- en: '[PRE1]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Or, for a Windows system, use the following:'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，对于 Windows 系统，使用以下命令：
- en: '[PRE2]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Activate it and lay out an initial `requirements.txt` file with the following
    packages:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 激活它，并创建一个包含以下包的初始 `requirements.txt` 文件：
- en: '[PRE3]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Install the required packages by running the following command:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令安装所需的包：
- en: '[PRE4]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you look closely at the `requirements.txt` file you will notice that you
    are installing a new package—`fastapi-cors`—that is useful for managing the `.env`
    file and then create a `.gitignore` file with the following content:'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你仔细查看 `requirements.txt` 文件，你会注意到你正在安装一个新的包——`fastapi-cors`——它有助于管理 `.env`
    文件，然后创建一个包含以下内容的 `.gitignore` 文件：
- en: '[PRE5]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After getting the basic packages and settings ready, you will now create the
    models with Beanie.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在准备基本包和设置之后，你现在将使用 Beanie 创建模型。
- en: Defining the models with Beanie
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Beanie 定义模型
- en: 'Before scaffolding the main FastAPI application, you will learn how Beanie
    handles data models. As mentioned earlier, Beanie’s `Document` class represents
    documents that will eventually be saved into a MongoDB database, and these models
    inherit Beanie’s `Document` class, which itself is a Pydantic’s `BaseModel`-based
    class. As stated on the Beanie website: "The `Document` class in Beanie is responsible
    for mapping and handling the data from the collection. It is inherited from the
    `BaseModel` Pydantic class, so it follows the same data typing and parsing behavior."
    ([https://beanie-odm.dev/tutorial/defining-a-document/](https://beanie-odm.dev/tutorial/defining-a-document/))'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在搭建主要 FastAPI 应用程序之前，你将学习 Beanie 如何处理数据模型。如前所述，Beanie 的 `Document` 类代表最终将保存到
    MongoDB 数据库中的文档，这些模型继承自 Beanie 的 `Document` 类，而 `Document` 类本身是基于 Pydantic 的 `BaseModel`
    类。正如 Beanie 网站所述：“Beanie 中的 `Document` 类负责映射和处理集合中的数据。它继承自 Pydantic 的 `BaseModel`
    类，因此遵循相同的数据类型和解析行为。” ([https://beanie-odm.dev/tutorial/defining-a-document/](https://beanie-odm.dev/tutorial/defining-a-document/))
- en: 'Let’s begin creating the models, bearing in mind that the file will also contain
    several pure Pydantic models for validation of inputs and outputs (not all models
    will be Beanie-based, only the ones that map documents in collections):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建模型，同时记住该文件还将包含几个纯 Pydantic 模型，用于输入和输出的验证（并非所有模型都是基于 Beanie 的，只有映射集合中文档的模型）：
- en: 'Create a file named `models.py` in the root of the directory, and import the
    necessary modules:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在目录根目录下创建一个名为 `models.py` 的文件，并导入必要的模块：
- en: '[PRE6]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The only new import in this code is from Beanie: you are importing the `Document`
    class—the workhorse of Beanie for working with data—as well as `Link` (needed
    for referencing data, since you will not be embedding user data in car documents
    but referencing the users) and `PydanticObjectId`—a field type representing `ObjectId`
    compatible with Pydantic.'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码中唯一的新导入来自 Beanie：你正在导入 `Document` 类——Beanie 用于处理数据的工具类，以及 `Link`（用于引用数据，因为你不会在汽车文档中嵌入用户数据，而是引用用户）和
    `PydanticObjectId`——一个表示与 Pydantic 兼容的 `ObjectId` 字段类型。
- en: 'Continue working on the `models.py` file and create the base user model:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续在 `models.py` 文件上工作并创建基本用户模型：
- en: '[PRE7]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `User` model inherits from the Beanie `Document` class instead of the `BaseModel`
    class of Pydantic, but the rest is largely the same. In fact, the `Document` class
    is based on the `BaseModel` class and inherits its functionality—you were able
    to use a Pydantic field with the default factory for creating the `datetime` type.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`User`模型继承自Beanie的`Document`类而不是Pydantic的`BaseModel`类，但其余部分大致相同。实际上，`Document`类基于`BaseModel`类并继承其功能——你能够使用具有默认工厂的Pydantic字段来创建`datetime`类型。'
- en: 'Then, you used the `Settings` class to specify the name of the collection that
    will be used in MongoDB. This class is quite powerful and allows setting caching,
    indexing, validations upon saving, and much more, as you can see on the documentation
    page: [https://beanie-odm.dev/tutorial/defining-a-document/#settings](https://beanie-odm.dev/tutorial/defining-a-document/#settings).'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，你使用了`Settings`类来指定将在MongoDB中使用的集合名称。这个类非常强大，允许在保存时设置缓存、索引、验证以及更多功能，如你可以在文档页面看到：[https://beanie-odm.dev/tutorial/defining-a-document/#settings](https://beanie-odm.dev/tutorial/defining-a-document/#settings)。
- en: 'Continuing with the same `models.py` file, you will now provide a couple of
    Pydantic models used for specific purposes: registering a new user, logging the
    user in, and providing information about the current user:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续使用相同的`models.py`文件，你现在将提供一些用于特定目的的Pydantic模型：注册新用户、用户登录以及提供当前用户的信息：
- en: '[PRE8]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The previous code should feel familiar as it is completely based on Pydantic,
    so define the document model for the cars:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之前的代码应该感觉熟悉，因为它完全基于Pydantic，所以定义汽车的文档模型：
- en: '[PRE9]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The Beanie document model contains all the fields that you have used throughout
    the book, and a couple of new ones: two lists of strings that will include small
    text snippets of pros and cons for each car model—something along the lines of
    *c**ompact and easy to park*. Also, the car description is intentionally left
    blank—these fields will be populated later, in a background task, by an OpenAI
    chat-completion prompt.'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Beanie文档模型包含你在整本书中使用的所有字段，以及一些新的字段：两个字符串列表，将包含每个汽车模型的优点和缺点的小文本片段——类似于*c**ompact和易于停放。此外，汽车描述有意留空——这些字段将在稍后的后台任务中，通过OpenAI聊天完成提示来填充。
- en: 'The interesting part of this model is the `user` part: the `Link` field type
    provides a direct link to the user. You can check the documentation to see what
    is possible with Beanie relations and what the current limitations are: [https://beanie-odm.dev/tutorial/relations/](https://beanie-odm.dev/tutorial/relations/).'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个模型的有趣之处在于`user`部分：`Link`字段类型提供了一个直接链接到用户。你可以查看文档以了解Beanie关系可以实现什么以及当前的限制是什么：[https://beanie-odm.dev/tutorial/relations/](https://beanie-odm.dev/tutorial/relations/)。
- en: Beanie manages relationships through links in the respective fields, and at
    the time of writing, only top-level fields are supported. Links to related documents
    can be links, optional links, and lists of links, as well as backward links.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Beanie通过相应字段中的链接来管理关系，在撰写本文时，仅支持顶级字段。相关文档的链接可以是链接、可选链接以及链接列表，以及反向链接。
- en: 'Backward links are reverse relationships: if an object called `House` has a
    link to an owner—a `Person` object, for instance—then that `Person` object can
    have a backward link to all the houses that they own, through a backlink.'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 反向链接是反向关系：如果一个名为`House`的对象有一个指向所有者——例如一个`Person`对象——的链接，那么该`Person`对象可以通过反向链接拥有所有房屋。
- en: 'Finally, add an `UpdateCar` Pydantic model that will be used for updating cars:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加一个用于更新汽车的`UpdateCar` Pydantic模型：
- en: '[PRE10]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that you haven’t defined almost any validation on the fields—this is
    done only to save some space and simplify the model. Since Beanie is based on
    Pydantic, it can count on the full functionality of Pydantic and, thus, implement
    complex and powerful validations.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你几乎在字段上没有定义任何验证——这样做只是为了节省空间并简化模型。由于Beanie基于Pydantic，它可以依赖Pydantic的全部功能，从而实现复杂而强大的验证。
- en: With the models now defined, you can proceed to connect to the MongoDB database.
    It is important to have the models defined upfront, as their names will be fed
    to the Beanie initialization code, as you will see in the next section.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经定义了模型，你可以继续连接到MongoDB数据库。提前定义模型很重要，因为它们的名称将被输入到Beanie初始化代码中，你将在下一节中看到。
- en: Connecting to the MongoDB database
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到MongoDB数据库
- en: The Beanie ODM uses the `pydantic-settings` and its `BasicSettings` class for
    easy access to the environment variables inside your application.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Beanie ODM使用`pydantic-settings`及其`BasicSettings`类，以便在应用程序内部轻松访问环境变量。
- en: 'The process is very similar to the one used in [*Chapter 7*](B22406_07.xhtml#_idTextAnchor118),
    *Building a Backend* *with FastAPI*:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程与在[*第7章*](B22406_07.xhtml#_idTextAnchor118)中使用的类似，即*使用FastAPI构建后端*：
- en: Environment variables are stored in the `.``env` file.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境变量存储在`.env`文件中。
- en: '`pydantic-settings` is used to read the environment variables and create a
    settings object (through the `config.py` file).'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pydantic-settings`用于读取环境变量并创建一个设置对象（通过`config.py`文件）。'
- en: These settings, together with the models, are used to initialize the database
    connection to Atlas.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些设置，连同模型一起，用于初始化到Atlas的数据库连接。
- en: 'To create the database connection and use the models, perform the following
    steps:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建数据库连接并使用模型，请执行以下步骤：
- en: Define the configuration and environment variables by using `pydantic-settings`.
    Since you need the settings *before* initializing the database connection, and
    they are read from the environment, populate the `.env` file that will host the
    environment variables, which are then going to be read through the `config.py`
    file and instantiated into a settings object.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pydantic-settings`定义配置和环境变量。由于你需要在初始化数据库连接之前获取设置，并且它们是从环境中读取的，因此请填充将包含环境变量的`.env`文件，然后通过`config.py`文件读取并将它们实例化为设置对象。
- en: 'The `.env` file should contain the following entries:'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`.env`文件应包含以下条目：'
- en: '[PRE11]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You will set up the OpenAI and Resend API keys later, but for now, you can
    insert the other values for MongoDB Atlas and the `config.py`. Open the `config.py`
    file and create the `BaseConfig` class for reading the environment values and
    easy overriding of these values, based on the desired configuration:'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将在稍后设置OpenAI和Resend API密钥，但现在，你可以插入MongoDB Atlas和`config.py`的其他值。打开`config.py`文件，创建`BaseConfig`类以读取环境值并轻松覆盖这些值，基于所需的配置：
- en: '[PRE12]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The differences in connecting to a MongoDB database with Beanie compared to
    plain Motor-based connections become apparent in the `database.py` file that you
    will create in the same root directory and populate with the following code:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与使用Beanie连接MongoDB数据库相比，与基于Motor的普通连接的差异在`database.py`文件中变得明显，你将在同一根目录中创建此文件，并用以下代码填充：
- en: '[PRE13]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The initialization code is highlighted: the async `init_beanie` function needs
    the Motor client and the document models.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化代码被突出显示：异步`init_beanie`函数需要Motor客户端和文档模型。
- en: With the models defined and the database connection in place, you will now begin
    crafting the FastAPI application and the routers.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了模型并建立了数据库连接后，你现在将开始构建FastAPI应用程序和路由器。
- en: Creating the FastAPI application
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建FastAPI应用程序
- en: All the necessary pieces are ready, and now that you have the connection to
    the MongoDB database ready, you can start building the application. Use the freshly
    created `database.py` file for connecting to your MongoDB instance and wrap it
    into the lifespan context manager to ensure that the application connects when
    started and that the connection is deleted on shutdown.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 所有必要的组件都已就绪，现在你已经准备好了连接到MongoDB数据库的连接，可以开始构建应用程序。使用新创建的`database.py`文件连接到你的MongoDB实例，并将其包装在生命周期上下文管理器中，以确保应用程序启动时连接，并在关闭时删除连接。
- en: 'To create the main FastAPI application file (`app.py`), perform the following
    steps:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建主FastAPI应用程序文件（`app.py`），请执行以下步骤：
- en: 'Create the `app.py` file in the root directory, which will be very similar
    to the one created in [*Chapter 7*](B22406_07.xhtml#_idTextAnchor118), *Building
    a Backend* *with FastAPI*:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根目录中创建`app.py`文件，它将非常类似于在[*第7章*](B22406_07.xhtml#_idTextAnchor118)中创建的，即*使用FastAPI构建后端*：
- en: '[PRE14]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The connection initialization code is nested inside a lifespan event, like
    the previously used solution with Motor, while the rest of the code is just the
    inclusion of the routers that you will be creating soon and a root endpoint:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接初始化代码嵌套在一个生命周期事件中，就像之前使用Motor的解决方案一样，而其余的代码只是包含你即将创建的路由和一个根端点：
- en: '[PRE15]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you have installed a recent version of FastAPI (0.111 or later) that installs
    the `fastapi-cli` package, you can now start the development FastAPI server with
    the following command:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你已安装了FastAPI的较新版本（0.111或更高版本），该版本会安装`fastapi-cli`包，你现在可以使用以下命令启动开发FastAPI服务器：
- en: '[PRE16]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Alternatively, you can use the following standard code line:'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，你可以使用以下标准代码行：
- en: '[PRE17]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding code uses the new `fastapi-cli` package for easier development
    ([https://fastapi.tiangolo.com/fastapi-cli/](https://fastapi.tiangolo.com/fastapi-cli/)).
    `fastapi-cors` will provide a new endpoint called “health check.” If you try it
    out, you will see the environment variables related to CORS (`ALLOWED_CREDENTIALS`,
    `ALLOWED_METHODS`, `ALLOWED_ORIGINS`, and others), and they are now settable through
    the `.``env` file.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用了新的 `fastapi-cli` 包以简化开发([https://fastapi.tiangolo.com/fastapi-cli/](https://fastapi.tiangolo.com/fastapi-cli/))。`fastapi-cors`
    将提供一个名为“健康检查”的新端点。如果你尝试使用它，你会看到与CORS相关的环境变量（`ALLOWED_CREDENTIALS`、`ALLOWED_METHODS`、`ALLOWED_ORIGINS`
    等），并且现在可以通过 `.env` 文件进行设置。
- en: 'The FastAPI main application is now ready, but it needs two routers: one for
    users and one for cars, as well as the authentication logic. First, you will handle
    the authentication class along with the `users` router.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI主应用程序现在已准备就绪，但它需要两个路由器：一个用于用户和一个用于汽车，以及认证逻辑。首先，你将处理认证类以及 `users` 路由器。
- en: Creating the APIRouter class for the users and the authentication class
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建用户和认证类的APIRouter类
- en: The authentication class will encapsulate the authentication logic, similar
    to the one shown in [*Chapter 6*](B22406_06.xhtml#_idTextAnchor105), *Authentication
    and Authorization*, and create the accompanying **APIRouter** for managing users—registration,
    logging in, and verification.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 认证类将封装认证逻辑，类似于[*第6章*](B22406_06.xhtml#_idTextAnchor105) *认证和授权*中所示，并创建管理用户的配套
    **APIRouter**——注册、登录和验证。
- en: The `authentication.py` file will be identical to the previously used one for
    simplicity’s sake. The `authentication.py` file, located in the root of the project,
    contains the encoding and decoding JWT logic, the password encryption, and the
    dependency injection, as shown in [*Chapter 7*](B22406_07.xhtml#_idTextAnchor118),
    *Building a Backend* *with FastAPI*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，`authentication.py` 文件将与之前使用的文件相同。位于项目根目录的 `authentication.py` 文件包含 JWT
    编码和解码逻辑、密码加密和依赖注入，如[*第7章*](B22406_07.xhtml#_idTextAnchor118) *使用FastAPI构建后端*所示。
- en: 'We provide the file contents here, for your convenience:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在此提供文件内容，以方便您使用：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `user.py` router will be placed in the `/routers` folder, and it will expose
    three endpoints: for registering new users, for logging users in, and for verifying
    the user—given a `Bearer` token in the header. This last route is optional, as
    you will not use it directly in the next chapter (on Next.js) since we are opting
    for a simple cookie-based solution.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`user.py` 路由器将被放置在 `/routers` 文件夹中，并且它将公开三个端点：用于注册新用户、用于登录用户和用于验证用户——在头部提供
    `Bearer` 令牌。最后一个路由是可选的，因为在下一章（关于Next.js）中你不会直接使用它，因为我们选择了一个简单的基于cookie的解决方案。'
- en: 'To create the API router for users, perform the following steps:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建用户的API路由器，请执行以下步骤：
- en: 'Create a `routers/user.py` file and populate it to create the router for the
    users. This router is again similar to the Motor version, and it shares the same
    logic, but some differences are highlighted in the following code:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `routers/user.py` 文件并填充它以创建用户的路由器。这个路由器与Motor版本相似，并且它共享相同的逻辑，但在以下代码中突出了某些差异：
- en: '[PRE19]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The router showcases some of Beanie’s features: the direct querying of the
    `User` model (the `users` collection) with a MongoDB query, and the simple async
    creation of a new instance if the checks for existing users pass. In this case,
    you have two conditions: the username and the email must be available (not present
    in the collection). The querying syntax of Beanie is very intuitive: [https://beanie-odm.dev/tutorial/finding-documents/](https://beanie-odm.dev/tutorial/finding-documents/).'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 路由器展示了Beanie的一些功能：使用MongoDB查询直接查询 `User` 模型（`users` 集合），如果现有用户的检查通过，则简单异步创建一个新实例。在这种情况下，你有两个条件：用户名和电子邮件必须是可用的（不在集合中）。Beanie的查询语法非常直观：[https://beanie-odm.dev/tutorial/finding-documents/](https://beanie-odm.dev/tutorial/finding-documents/)。
- en: 'Create the login route in the `user.py` file:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `user.py` 文件中创建登录路由：
- en: '[PRE20]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The login functionality uses the `find_one` MongoDB method, which is available
    in Beanie.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 登录功能使用Beanie中可用的 `find_one` MongoDB方法。
- en: 'Finally, add the `/me` route, for verifying the logged-in user. This method
    uses the `get` method, which accepts an `ObjectId`:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加 `/me` 路由，用于验证已登录用户。此方法使用 `get` 方法，它接受一个 `ObjectId`：
- en: '[PRE21]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This completes the `users.py` APIRouter, which uses several Beanie querying
    methods. Now, you will create the `Car` router with Beanie ODM.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了 `users.py` APIRouter，它使用了几个Beanie查询方法。现在，你将使用Beanie ODM创建 `Car` 路由器。
- en: The Car APIRouter
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Car APIRouter
- en: 'Similar to what you have accomplished in the previous chapters, the `Cars`
    router will be in charge of performing some CRUD operations. For simplicity, you
    will implement only partial updates of the car instances: you will be able to
    update the fields defined in the `UpdateCar` model. Since the description and
    the lists of pros and cons will initially be empty, they need to be able to be
    updated later (by a call to OpenAI’s API).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章所完成的内容类似，`Cars`路由器将负责执行一些CRUD操作。为了简单起见，您将只实现汽车实例的部分更新：您将能够更新在`UpdateCar`模型中定义的字段。由于描述和优缺点列表最初为空，它们需要能够在以后更新（通过调用OpenAI的API）。
- en: 'To create the `Cars` router, in the `/routers` folder and the `cars.py` file,
    perform the following steps:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`Cars`路由器，在`/routers`文件夹和`cars.py`文件中，执行以下步骤：
- en: 'Begin by creating a `/routers/cars.py` file and list the initial imports (there
    will be some more added later, when you start implementing background tasks):'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个`/routers/cars.py`文件并列出初始导入（在开始实现后台任务时将添加更多）：
- en: '[PRE22]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'These imports are similar to the ones used when working with Motor directly;
    the main difference is the Beanie imports: `PydanticObjectId` (for handling ObjectIds
    with Pydantic) and `WriteRules`, which will enable the relationship of `Car` and
    `User` to be written to the MongoDB database as a reference.'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些导入与直接使用Motor时使用的导入类似；主要区别是Beanie的导入：`PydanticObjectId`（用于处理Pydantic的ObjectIds）和`WriteRules`，这将使`Car`和`User`的关系能够作为引用写入MongoDB数据库。
- en: 'Continuing with the file, you can now instantiate the authentication handler
    (`auth_handler`) class, the settings, and the router, as well as the Cloudinary
    configuration:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续处理文件，现在您可以实例化认证处理器(`auth_handler`)类、设置和路由器，以及Cloudinary配置：
- en: '[PRE23]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After having the necessary settings and authentication ready, you can create
    the first route—the `GET` handler, which in this case simply retrieves all the
    cars in the database:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在完成必要的设置和认证后，您可以创建第一条路由——`GET`处理器，在这种情况下，它只是简单地检索数据库中的所有汽车：
- en: '[PRE24]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create the `GET` method for getting one car instance by its ID:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建用于通过其ID获取单个汽车实例的`GET`方法：
- en: '[PRE25]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This implementation is also simple—it uses the `get()` shortcut to query the
    collection by `ObjectId`, which is elegantly handled by Beanie.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此实现也很简单——它使用`get()`快捷方式通过`ObjectId`查询集合，这由Beanie优雅地处理。
- en: 'The method for creating the new car instances is a bit more complex, but not
    too heavy. Since you are uploading an image (a file), you are using form data
    instead of JSON and the endpoint must upload the image to Cloudinary, obtain an
    image URL from Cloudinary, and only then insert it into the MongoDB database along
    with the other data:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建新汽车实例的方法稍微复杂一些，但并不太重。由于您正在上传图像（一个文件），您使用表单数据而不是JSON，并且端点必须将图像上传到Cloudinary，从Cloudinary获取图像URL，然后才能将图像与其他数据一起插入MongoDB数据库：
- en: '[PRE26]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The route for creating new resources uses the Beanie methods for getting a user
    by the ID (provided in the `Bearer` token in the header) and the `insert()` method
    for inserting a new car.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建新资源的路由使用Beanie方法通过ID（在请求头中的`Bearer`令牌中提供）获取用户，并使用`insert()`方法插入新汽车。
- en: Finally, `link_rule` allows you to save the salesperson’s ID ([https://beanie-odm.dev/tutorial/relations/](https://beanie-odm.dev/tutorial/relations/)).
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，`link_rule`允许您保存销售人员的ID（[https://beanie-odm.dev/tutorial/relations/](https://beanie-odm.dev/tutorial/relations/)）。
- en: 'The `update` method is similar to its Motor counterpart, and it could be easily
    incorporated into a dashboard to update or delete car model adverts:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`update`方法与Motor的对应方法类似，可以轻松地集成到仪表板中，用于更新或删除汽车型号广告：'
- en: '[PRE27]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Once again, you only update the fields that are provided in the request, using
    the Pydantic `model_dump` method to verify which fields are actually provided,
    leaving the other ones (which are `null` or `None`, in Python terminology) unaltered.
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次强调，您只更新请求中提供的字段，使用Pydantic的`model_dump`方法来验证哪些字段实际上被提供，其他字段（在Python术语中为`null`或`None`）保持不变。
- en: 'In the `delete` method, you only need to provide the selected document and
    invoke the `delete()` method:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`delete`方法中，您只需要提供所选文档并调用`delete()`方法：
- en: '[PRE28]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You have now completed your API routers, and you are ready to implement some
    more advanced functionality, which FastAPI and the FARM stack in general make
    a quick and fun task. Before being able to use the routers, however, you will
    need to import them into the `app.py` file. Open the `app.py` file and modify
    the imports at the top, adding the routers and aliasing them as cars and users:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经完成了您的 API 路由器，并准备好实现一些更高级的功能，FastAPI 和 FARM 栈通常使这项任务变得快速且有趣。然而，在使用路由器之前，您需要将它们导入到
    `app.py` 文件中。打开 `app.py` 文件并修改顶部的导入，添加路由器并将它们别名为 cars 和 users：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, integrate them in the application by modifying the same `app.py` file:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过修改相同的 `app.py` 文件将这些功能集成到应用程序中：
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With the routers hooked up, you will integrate a simple, yet functional, AI
    assistant that will provide marketing information about the newly inserted cars,
    and automatically send emails to the salespersons, to a list of customers, or
    to a group of subscribers.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 连接好路由器后，您将集成一个简单但实用的 AI 助手，该助手将提供有关新插入的汽车的市场信息，并自动向销售人员、客户列表或订阅者群体发送电子邮件。
- en: Background tasks with FastAPI
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FastAPI 的后台任务
- en: One of the most interesting features of FastAPI is how it handles background
    tasks—functions that should be run asynchronously after the response has already
    been sent to the client.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 最有趣的功能之一是它如何处理后台任务——这些任务应该在向客户端发送响应之后异步运行。
- en: There are many use cases for background tasks. Any operation that could potentially
    take some time, such as waiting for an external API call to return a response,
    sending emails, or creating a complex document based on data processing in the
    endpoint, is a potential candidate for a background task. In all these cases,
    it would be bad practice and lead to a horrible user experience to just let the
    application hang while waiting for the result. Instead, these tasks are handed
    to the background to be processed while the response is returned immediately.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 后台任务有许多用例。任何可能需要一些时间的操作，例如等待外部 API 调用返回响应、发送电子邮件或基于端点的数据处理创建复杂文档，都是后台任务的潜在候选者。在这些所有情况下，仅仅让应用程序挂起等待结果是不良的做法，会导致糟糕的用户体验。相反，这些任务被交给后台处理，而响应则立即返回。
- en: While very useful for simple tasks, background tasks shouldn’t be used for processes
    that require significant processing power and/or multitasking. In this case, a
    more robust tool such as **Celery** ([https://docs.celeryq.dev/](https://docs.celeryq.dev/))
    might be the best solution. Celery is a Python task queue framework that distributes
    work across threads or different machines.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对于简单任务非常有用，但不应将后台任务用于需要大量处理能力或/和多任务处理的进程。在这种情况下，一个更健壮的工具，如 **Celery** ([https://docs.celeryq.dev/](https://docs.celeryq.dev/))
    可能是最佳解决方案。Celery 是一个 Python 任务队列框架，可以在线程或不同的机器之间分配工作。
- en: FastAPI defines a class called `BackgroundTasks`, inherited from the **Starlette**
    web framework, which works simply and intuitively, as you will see in the following
    section when you use it to plug external services into your FastAPI application.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 定义了一个名为 `BackgroundTasks` 的类，它继承自 **Starlette** 网络框架，它简单直观，您将在以下部分使用它将外部服务连接到您的
    FastAPI 应用程序时看到。
- en: 'Before using background tasks for interfacing with third-party services, create
    a very simple task for demonstration purposes:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用后台任务与第三方服务接口之前，创建一个非常简单的任务以供演示：
- en: 'Create a file called `background.py` in the root of the project and populate
    it with the following code:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根目录下创建一个名为 `background.py` 的文件，并填充以下代码：
- en: '[PRE31]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This function is very simple—it sleeps for five seconds and then prints a message
    on the console.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此函数非常简单——它将在控制台上打印一条消息，等待五秒钟。
- en: The syntax for integrating the task into an endpoint will be shown in the following
    API router.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将任务集成到端点的语法将在以下 API 路由器中展示。
- en: Open the `/routers/user.py` file because you will attach this simple background
    task to the `login` function.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `/routers/user.py` 文件，因为您将把这个简单的后台任务附加到 `login` 函数上。
- en: This function could also perform some logging or some more complex and time-consuming
    operations that would block the response until completion, but in this case, a
    simple `print` statement will be used.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此函数还可以执行一些日志记录或一些更复杂且耗时的操作，这些操作会阻塞响应直到完成，但在此情况下，将使用一个简单的 `print` 语句。
- en: 'At the top of the file, import the background tasks and modify only the `login`
    endpoint in the following way:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件顶部导入后台任务，并仅以以下方式修改 `login` 端点：
- en: '[PRE32]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You can navigate to the address of the interactive documentation (127.0.0.1:8000/docs)
    and try to log in.
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以导航到交互式文档的地址（127.0.0.1:8000/docs）并尝试登录。
- en: 'If you have also installed HTTPie, you can leave one terminal running the FastAPI
    application in development mode, open another terminal, and issue a login POST
    request, making sure to use the correct username and password of a user that you
    have created before. For example, the following command tests logging in for the
    user `tanja`:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你已经安装了 HTTPie，你可以让一个终端以开发模式运行 FastAPI 应用，打开另一个终端，并发出登录 POST 请求，确保使用你之前创建的用户正确的用户名和密码。例如，以下命令测试了用户
    `tanja` 的登录：
- en: '[PRE33]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If you look at the first terminal, you will see the following message after
    five seconds:'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你查看第一个终端，五秒后你会看到以下信息：
- en: '[PRE34]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You have just created a straightforward, but potentially useful, background
    task and learned the syntax.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚创建了一个简单但可能很有用的后台任务，并学习了语法。
- en: In the next section, you will create two background tasks that will create a
    new car description using OpenAI’s API and email the logged-in user—the user that
    inserted the car—with the description and the car data.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将创建两个后台任务，使用 OpenAI 的 API 创建新的汽车描述，并将描述和汽车数据通过电子邮件发送给已登录的用户——即插入汽车的用户。
- en: Integrating OpenAI with FastAPI
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 OpenAI 集成到 FastAPI 中
- en: LLMs have been the buzzword in the last couple of years and they have been dominating
    the web development discourse, and it is becoming hard to find successful applications
    that aren’t using some form of LLM integration. Modern applications make use of
    image, text, and audio processing, and they might provide an edge to your next
    web application as well.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，LLM（大型语言模型）一直是热门词汇，它们主导着网络开发的讨论，而且越来越难以找到不使用某种形式的 LLM 集成的成功应用。现代应用利用图像、文本和音频处理，这可能会给你的下一个网络应用带来优势。
- en: 'In your car-selling and advertising application, you are going to use one of
    the simplest features of a behemoth such as OpenAI—the task at hand is to make
    things a bit easier on the salespersons and provide them a baseline marketing
    line for each new car that gets put on sale:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的汽车销售和广告应用中，你将使用 OpenAI 这样的巨无霸的一个最简单功能——当前的任务是让销售人员的工作变得更容易一些，并为每辆即将上市的新车提供一条基准营销线：
- en: 'After having obtained the OpenAI key and setting your environment variable,
    modify the `background.py` file:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在获取了 OpenAI 密钥并设置环境变量后，修改 `background.py` 文件：
- en: '[PRE35]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can easily swap OpenAI for another LLM, such as **Google Gemini**.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻松地将 OpenAI 替换为另一个 LLM，例如 **Google Gemini**。
- en: 'The following is one way to create a prompt for generating car data, but you
    will probably want to get more creative or conservative in the descriptions provided
    by OpenAI, depending on your case:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是一种创建用于生成汽车数据的提示的方法，但根据你的情况，你可能希望更加有创意或保守地使用 OpenAI 提供的描述：
- en: '[PRE36]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now that the prompt is ready to be generated, it is time to perform a call
    to the OpenAI API. Please always refer to the latest OpenAI API documentation
    ([https://platform.openai.com/docs/overview](https://platform.openai.com/docs/overview)),
    as it is subject to frequent modifications. Currently, at the time of writing,
    the following code demonstrates the way to communicate with the API, which you
    should paste into your `background.py` file:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在提示已经准备好生成，是时候调用 OpenAI API 了。请始终参考最新的 OpenAI API 文档（[https://platform.openai.com/docs/overview](https://platform.openai.com/docs/overview)），因为它经常发生变化。目前，在撰写本文时，以下代码演示了与
    API 通信的方式，你应该将其粘贴到你的 `background.py` 文件中：
- en: '[PRE37]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The preceding code makes a call to the OpenAI client through the chat completion
    method. You have selected a model (`gpt-4`), started the `messages` array, and
    set `max_tokens` and `temperature`. Again, for all the parameter settings, refer
    to the latest OpenAI documentation. In this case, you are limiting the number
    of tokens to 500 and setting the temperature to `0.2` (this quantity impacts the
    “creativity” and the “conservativeness” of the responses).
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码通过聊天完成方法调用 OpenAI 客户端。你已经选择了一个模型（`gpt-4`），启动了 `messages` 数组，并设置了 `max_tokens`
    和 `temperature`。再次提醒，对于所有参数设置，请参考最新的 OpenAI 文档。在这种情况下，你将令牌数量限制为 500，并将温度设置为 `0.2`（这个数量影响响应的“创意”和“保守性”）。
- en: 'After receiving the response from OpenAI, you parsed the JSON content (`car_info`)
    into a Python dictionary containing the desired keys: description (text) and two
    arrays of strings (pros and cons). Armed with this newly generated data, you performed
    a MongoDB update (through Beanie) that selects all the cars that match the brand,
    the make, and the production year, and you set their description, pros, and cons
    to the data returned by OpenAI. In case of an error, we simply display the error.'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在收到OpenAI的响应后，你将JSON内容（`car_info`）解析为包含所需键的Python字典：描述（文本）和两个字符串数组（优点和缺点）。有了这些新生成数据，你通过Beanie执行MongoDB更新，选择所有匹配品牌、型号和生产年份的汽车，并将它们的描述、优点和缺点设置为OpenAI返回的数据。如果发生错误，我们简单地显示错误。
- en: 'Now plug the background task into the `POST` endpoint. Open the `/routers/cars.py`
    file and import the newly created background function at the top:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将后台任务连接到`POST`端点。打开`/routers/cars.py`文件，并在顶部导入新创建的后台函数：
- en: '[PRE38]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The rest of the code will remain unaltered; you are only modifying the `POST`
    endpoint:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其余的代码将保持不变；你只修改`POST`端点：
- en: '[PRE39]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This could be performed in a much more granular way: you could await the generated
    ID of the newly inserted car and update only that particular instance. The function
    also lacks some basic validation for cases in which the provided car brand and
    make don’t exist, or in cases in which OpenAI doesn’t provide a valid response.
    The point is that the endpoint function returns the response immediately—that
    is, almost immediately, after performing the MongoDB insertion, and the description
    and the two arrays are updated later.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过更细粒度的方式进行：你可以等待新插入的汽车生成的ID，并仅更新那个特定实例。该函数还缺少一些基本验证，用于处理提供的汽车品牌和型号不存在的情况，或者OpenAI没有提供有效响应的情况。关键是端点函数立即返回响应——也就是说，在执行MongoDB插入后几乎立即，描述和两个数组稍后更新。
- en: 'If you try to rerun the development server and insert a car, you should see
    the newly created document (in Compass or Atlas) and, after a couple of seconds,
    the document will be updated with the initially empty fields: `description`, `pros`,
    and `cons`.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试重新运行开发服务器并插入一辆汽车，你应该会看到新创建的文档（在Compass或Atlas中），几秒钟后，文档将更新为最初为空的字段：`description`、`pros`和`cons`。
- en: 'You can imagine different scenarios that could be covered by this functionality:
    maybe the car description needs to be approved by a human being and then the advert
    is set to be published (by adding a published Boolean variable), maybe you want
    to send the email to all the registered users, and so on.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象出许多可能被这个功能覆盖的场景：可能需要由人类审核汽车描述，然后设置广告发布（通过添加已发布的布尔变量），可能你想向所有注册用户发送电子邮件，等等。
- en: The next section will take this background job a bit further and show you how
    you can quickly integrate emails into your application.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将进一步介绍这个后台工作，并展示你如何快速将电子邮件集成到你的应用程序中。
- en: Integrating emails into FastAPI
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将电子邮件集成到FastAPI中
- en: One of the most frequent requirements of modern web applications is sending
    automated emails. Today, there are numerous options for sending emails, and two
    of the most popular options are **Mailgun** and **SendGrid** by Twilio.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现代网络应用最常见的需求之一是发送自动化的电子邮件。今天，有众多发送电子邮件的选项，其中最受欢迎的两个选项是Twilio的**Mailgun**和**SendGrid**。
- en: Through this application, you will learn how to set up email functionality using
    a relatively new service called **Resend**. Their API-centric approach is very
    developer-friendly and easy to start with.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个应用程序，你将学习如何使用名为**Resend**的相对较新的服务设置电子邮件功能。他们的以API为中心的方法非常适合开发者，并且易于上手。
- en: Navigate to the Resend home page ([https://resend.com](https://resend.com))
    and create a free account. After logging in, navigate to the `FARMstack`. The
    key will be visible only once, so make sure to copy it and store it in the `.``env`
    file.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到Resend主页([https://resend.com](https://resend.com))并创建一个免费账户。登录后，导航到`FARMstack`。密钥只会显示一次，所以请确保复制并存储在`.``env`文件中。
- en: 'Perform the following steps to add Resend functionality to your application:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以将Resend功能添加到你的应用程序中：
- en: 'Install the `resend` package:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`resend`包：
- en: '[PRE40]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'After installing the `resend` package, update the `background.py` file:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`resend`包后，更新`background.py`文件：
- en: '[PRE41]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Update the `create_description` function to send a message once the response
    is returned from OpenAI:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`create_description`函数，以便在从OpenAI返回响应后发送消息：
- en: '[PRE42]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The recipient email should be the same email that you have signed up with Resend
    as it will be the only option until you register and verify your domain, but more
    than enough for development and testing purposes: [https://resend.com/docs/knowledge-base/](https://resend.com/docs/knowledge-base/).'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 收件人电子邮件地址应该是您在Resend上注册的同一电子邮件地址，因为这将是您注册和验证域名之前的唯一选项，但对于开发和测试目的来说已经足够：[https://resend.com/docs/knowledge-base/](https://resend.com/docs/knowledge-base/)。
- en: 'The `resend` package makes sending emails simple—you just perform a single
    call to the `resend.Emails.Send` function and define the parameters. In your case,
    the parameters are the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`resend`包使发送邮件变得简单——您只需调用一次`resend.Emails.Send`函数并定义参数。在您的案例中，参数如下：'
- en: '`to` – a list of recipient emails.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`to` – 收件人电子邮件列表。'
- en: '`from` – the email address of the sender. In this case, you will leave the
    default provided by Resend, but later on, you will replace it with your own domain
    address.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from` – 发件人的电子邮件地址。在这种情况下，您将保留Resend提供的默认地址，但稍后您将用您自己的域名地址替换它。'
- en: '`subject` – the subject of the email.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subject` – 邮件的主题。'
- en: '`html` – the HTML content of the email.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`html` – 邮件的HTML内容。'
- en: The parameters are fed to the `resend.Email.send()` function as a dictionary.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 参数以字典的形式传递给`resend.Email.send()`函数。
- en: The email HTML in this app is constructed directly from an `f-string` in Python,
    but you could always resort to more sophisticated and complex solutions with **Jinja2**
    (for a purely Python solution, since the backend is written in Python) or use
    React Email by Resend ([https://react.email/](https://react.email/)). Jinja2 is
    arguably the most popular Python HTML templating engine, and it is used by the
    Flask web framework, while React Email provides React-based email templates.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序中的邮件HTML内容直接由Python中的`f-string`构建，但您始终可以求助于更复杂和高级的解决方案，例如使用**Jinja2**（对于纯Python解决方案，因为后端是用Python编写的）或使用Resend的React
    Email（[https://react.email/](https://react.email/)）。Jinja2可以说是最流行的Python HTML模板引擎，它被Flask
    Web框架所使用，而React Email提供基于React的邮件模板。
- en: Note
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please refer to [*Chapter 7*](B22406_07.xhtml#_idTextAnchor118), *Building
    a Backend with FastAPI,* on deploying your backend to Render.com. The procedure
    will remain largely unchanged: just keep track of the environment variables and
    make sure to add the newly created ones (the OpenAI and Render keys). Alternatively,
    you can run the backend from this chapter in order to use it in the next chapter.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[*第7章*](B22406_07.xhtml#_idTextAnchor118)，*使用FastAPI构建后端*，了解如何将您的后端部署到Render.com。程序将基本保持不变：只需跟踪环境变量，并确保添加新创建的变量（OpenAI和Render密钥）。或者，您可以从本章运行后端，以便在下一章中使用它。
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned the basics of Beanie, a popular ODM library for
    MongoDB, built on top of Motor and Pydantic. You learned how to define models
    and define Beanie documents that map to MongoDB collections and how to query and
    perform CRUD operations with the ODM.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了Beanie的基础知识，这是一个基于Motor和Pydantic的流行ODM库，用于MongoDB。您学习了如何定义模型和定义与MongoDB集合映射的Beanie文档，以及如何使用ODM进行查询和执行CRUD操作。
- en: You built another FastAPI application in which you integrated third-party services
    with the help of background tasks, which is a FastAPI feature that allows slow-
    and long-running tasks to be executed in the background, while maintaining the
    app’s responsiveness.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 您构建了另一个FastAPI应用程序，在该应用程序中，您通过后台任务集成了第三方服务，这是FastAPI的一个功能，允许在后台执行慢速和长时间运行的任务，同时保持应用程序的响应性。
- en: This chapter also covered integrating the most popular AI service, ChatGPT,
    into your applications, providing intelligent additional data about your newly
    inserted entities. Finally, you learned how to implement a simple email-sending
    solution, which is common in many web applications.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还介绍了如何将最受欢迎的AI服务ChatGPT集成到您的应用程序中，为您的最新插入实体提供智能附加数据。最后，您学习了如何实现一个简单的邮件发送解决方案，这在许多Web应用程序中很常见。
- en: 'In the next chapter, you will dive into the most popular and advanced web framework
    based on React.js: **Next.js**. You will learn the basics of the latest version
    of Next.js (14) and discover the most important features that set it apart from
    other frontend or even full stack solutions.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将深入了解基于React.js的最受欢迎和最先进的Web框架：**Next.js**。您将学习Next.js最新版本（14）的基础知识，并发现使其与其他前端甚至全栈解决方案区别开来的最重要的特性。
