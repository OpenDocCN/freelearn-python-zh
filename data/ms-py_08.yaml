- en: Chapter 8. Metaclasses – Making Classes (Not Instances) Smarter
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。元类-使类（而不是实例）更智能
- en: The previous chapters have already shown us how to modify classes and functions
    using decorators. But that's not the only option to modify or extend a class.
    An even more advanced technique of modifying your classes before creation is the
    usage of **metaclasses**. The name already gives a hint to what it could be; a
    metaclass is a class containing meta information about a class.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 前几章已经向我们展示了如何使用装饰器修改类和函数。但这并不是修改或扩展类的唯一选项。在创建类之前修改你的类的更高级的技术是使用**元类**。这个名字已经暗示了它可能是什么；元类是一个包含有关类的元信息的类。
- en: The basic premise of a metaclass is a class that generates another class for
    you at definition time, so generally you wouldn't use it to change the class instances
    but only the class definitions. By changing the class definitions, it is possible
    to automatically add some properties to a class, validate whether certain properties
    are set, change inheritance, automatically register the class at a manager, and
    do many other things.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 元类的基本前提是在定义时为你生成另一个类的类，因此通常你不会用它来改变类实例，而只会用它来改变类定义。通过改变类定义，可以自动向类添加一些属性，验证是否设置了某些属性，改变继承关系，自动将类注册到管理器，并做许多其他事情。
- en: Although metaclasses are generally considered to be a more powerful technique
    than (class) decorators, effectively they don't differ too much in possibilities.
    The choice usually comes down to either convenience or personal preference.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管元类通常被认为是比（类）装饰器更强大的技术，但实际上它们在可能性上并没有太大的区别。选择通常取决于方便性或个人偏好。
- en: 'The following topics are covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Basic dynamic class creation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本的动态类创建
- en: Metaclasses with arguments
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带参数的元类
- en: Internals of class creation, the order of operations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类创建的内部工作原理，操作顺序
- en: Abstract base classes, examples and inner workings
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象基类、示例和内部工作原理
- en: Automatic plugin system using metaclasses
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用元类的自动插件系统
- en: Storing definition order of class attributes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储类属性的定义顺序
- en: Dynamically creating classes
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态创建类
- en: Metaclasses are the factories that create new classes in Python. In fact, even
    though you may not be aware of it, Python will always execute the `type` metaclass
    whenever you create a class.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 元类是在Python中创建新类的工厂。实际上，即使你可能不知道，Python在你创建一个类时总是会执行`type`元类。
- en: 'When creating classes in a procedural way, the `type` metaclass is used as
    a function. This function takes three arguments: `name`, `bases`, and `dict`.
    The name will become the `__name__` attribute, the `bases` is the list of inherited
    base classes and will be stored in `__bases__` and `dict` is the namespace dictionary
    that contains all variables and will be stored in `__dict__`.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在以程序方式创建类时，`type`元类被用作一个函数。这个函数接受三个参数：`name`，`bases`和`dict`。`name`将成为`__name__`属性，`bases`是继承的基类列表，将存储在`__bases__`中，`dict`是包含所有变量的命名空间字典，将存储在`__dict__`中。
- en: It should be noted that the `type()` function has another use as well. Given
    the arguments documented earlier, it creates a class given those specifications.
    Given a single argument with the instance of a class, it will return the class
    as well but from the instance. Your next question might be, "What happens if I
    call `type()` on a class definition instead of a class instance?" Well, that returns
    the metaclass for the class which is `type` by default.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意`type()`函数还有另一个用途。根据之前记录的参数，它会根据这些规格创建一个类。给定一个类实例的单个参数，它也会返回该类，但是从实例中返回。你下一个问题可能是，“如果我在类定义而不是类实例上调用`type()`会发生什么？”嗯，这会返回类的元类，默认为`type`。
- en: 'Let''s clarify this using a few examples:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用几个例子来澄清这一点：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding two definitions of `Spam` are completely identical; they both
    create a class with an instantiated property of `eggs` and `object` as a base.
    Let''s test if this actually works as you would expect:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个`Spam`的定义完全相同；它们都创建了一个具有`eggs`和`object`作为基类的类。让我们测试一下这是否像你期望的那样工作：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As expected, the results for the two are the same. When creating a class, Python
    silently adds the `type` metaclass and `custom` metaclasses are simply classes
    that inherit `type`. A simple class definition has a silent metaclass making a
    simple definition such as:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，这两个结果是相同的。在创建类时，Python会悄悄地添加`type`元类，而`custom`元类只是继承`type`的类。一个简单的类定义有一个隐式的元类，使得一个简单的定义如下：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Essentially identical to:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上与：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This raises the question that if every class is created by a (silent) metaclass,
    what is the metaclass of `type`? This is actually a recursive definition; the
    metaclass of `type` is `type`. This is the essence of what a custom metaclass
    is: a class that inherits type to allow class modification without needing to
    modify the class definition itself.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这引发了一个问题，即如果每个类都是由一个（隐式的）元类创建的，那么`type`的元类是什么？这实际上是一个递归定义；`type`的元类是`type`。这就是自定义元类的本质：一个继承了type的类，允许在不需要修改类定义本身的情况下修改类。
- en: A basic metaclass
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个基本的元类
- en: 'Since metaclasses can modify any class attribute, you can do absolutely anything
    you wish. Before we continue with more advanced metaclasses, let''s look at a
    basic example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于元类可以修改任何类属性，你可以做任何你想做的事情。在我们继续讨论更高级的元类之前，让我们看一个基本的例子：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, everything about the class definition can easily be modified
    using metaclasses. This makes it both a very powerful and a very dangerous tool,
    as you can easily cause very unexpected behavior.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，使用元类可以轻松修改类定义的所有内容。这使得它既是一个非常强大又是一个非常危险的工具，因为你可以很容易地引起非常意外的行为。
- en: Arguments to metaclasses
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元类的参数
- en: The possibility of adding arguments to a metaclass is a little-known feature,
    but very useful nonetheless. In many cases, simply adding attributes or methods
    to a class definition is enough to detect what to do, but there are cases where
    it is useful to be more specific.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 向元类添加参数的可能性是一个鲜为人知但非常有用的特性。在许多情况下，简单地向类定义添加属性或方法就足以检测要做什么，但也有一些情况下更具体的指定是有用的。
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This simplistic example may not be useful but the possibilities are. The only
    thing you need to keep in mind is that both the `__new__` and `__init__` methods
    need to be extended for this to work.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子可能没有用，但可能性是存在的。你需要记住的唯一一件事是，为了使其工作，`__new__` 和 `__init__` 方法都需要被扩展。
- en: Accessing metaclass attributes through classes
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过类访问元类属性
- en: 'When using metaclasses, it might be confusing to note that the class actually
    does more than simply construct the class, it actually inherits the class during
    the creation. To illustrate:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用元类时，可能会感到困惑，注意到类实际上不仅仅是构造类，它实际上在创建时继承了类。举个例子：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As can be seen in the preceding example, these methods are only available for
    the `class` objects and not the instances. The `spam` attribute and the `eggs`
    method are not accessible through the instance while they are accessible through
    the class. I personally don't see any useful cases for this behavior but it is
    definitely noteworthy.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的例子中所示，这些方法仅适用于 `class` 对象，而不适用于实例。`spam` 属性和 `eggs` 方法无法通过实例访问，但可以通过类访问。我个人认为这种行为没有任何有用的情况，但它确实值得注意。
- en: Abstract classes using collections.abc
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 collections.abc 的抽象类
- en: The abstract base classes module is one of the most useful and most used examples
    of metaclasses in Python, as it makes it easy to ensure that a class adheres to
    a certain interface without a lot of manual checks. We have already seen some
    examples of abstract base classes in the previous chapters, but now we will look
    at the inner workings of these and the more advanced features, such as custom
    ABCs.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象基类模块是 Python 中最有用和最常用的元类示例之一，因为它可以轻松确保类遵循特定接口，而无需进行大量手动检查。我们已经在前几章中看到了一些抽象基类的示例，但现在我们将看看这些抽象基类的内部工作原理和更高级的特性，比如自定义
    ABC。
- en: Internal workings of the abstract classes
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象类的内部工作原理
- en: 'First, let''s demonstrate the usage of the regular abstract base class:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们演示常规抽象基类的用法：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, the abstract base class blocks us from instantiating the classes
    until all the abstract methods have been inherited. In addition to the regular
    methods, `property`, `staticmethod`, and `classmethod` are also supported.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，抽象基类阻止我们在继承所有抽象方法之前实例化类。除了常规方法外，还支持 `property`、`staticmethod` 和 `classmethod`。
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So what does Python do internally? You could, of course, read the `abc.py` source
    code but I think a simple explanation would be better.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 Python 在内部做了什么呢？当然，你可以阅读 `abc.py` 源代码，但我认为简单的解释会更好。
- en: 'First, `abc.abstractmethod` sets the `__isabstractmethod__` property on the
    function to `True`. So if you don''t want to use the decorator, you can simply
    emulate the behavior by doing something along the lines of:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`abc.abstractmethod` 将 `__isabstractmethod__` 属性设置为 `True`。因此，如果你不想使用装饰器，你可以简单地模拟这种行为，做一些类似的事情：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After that, the `abc.ABCMeta` metaclass walks through all the items in a namespace
    and looks for objects where the `__isabstractmethod__` attribute evaluates to
    `True`. In addition to that, it walks through all bases and checks the `__abstractmethods__`
    set for every base class, in case the class inherits an `abstract` class. All
    the items where `__isabstractmethod__` still evaluates to `True` get added to
    the `__abstractmethods__` set which is stored in the class as `frozenset`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在那之后，`abc.ABCMeta` 元类遍历命名空间中的所有项目，并查找 `__isabstractmethod__` 属性评估为 `True` 的对象。除此之外，它还遍历所有基类，并检查每个基类的
    `__abstractmethods__` 集合，以防类继承了一个 `abstract` 类。所有 `__isabstractmethod__` 仍然评估为
    `True` 的项目都被添加到 `__abstractmethods__` 集合中，该集合存储在类中作为 `frozenset`。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we don't use `abc.abstractproperty`, `abc.abstractclassmethod`, and
    `abc.abstractstaticmethod`. Since Python 3.3 these have been deprecated as the
    `classmethod`, `staticmethod`, and `property` decorators are recognized by `abc.abstractmethod`
    so a simple `property` decorator followed by a `abc.abstractmethod` is recognized
    as well. Take care when ordering the decorators; `abc.abstractmethod` needs to
    be the innermost decorator for this to work properly.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不使用 `abc.abstractproperty`、`abc.abstractclassmethod` 和 `abc.abstractstaticmethod`。自
    Python 3.3 起，这些已被弃用，因为 `classmethod`、`staticmethod` 和 `property` 装饰器被 `abc.abstractmethod`
    所识别，因此简单的 `property` 装饰器后跟 `abc.abstractmethod` 也被识别。在对装饰器进行排序时要小心；`abc.abstractmethod`
    需要是最内层的装饰器才能正常工作。
- en: 'The next question now is about where the actual checks come in; the checks
    to see if the classes are completely implemented. This actually functions through
    a few Python internals:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是实际的检查在哪里进行；检查类是否完全实现。这实际上是通过一些 Python 内部功能实现的：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can easily emulate the same behavior with a `metaclass` ourselves, but it
    should be noted that `abc.ABCMeta` actually does more, which we will demonstrate
    in the next section. To mimic the behavior of the built-in abstract base class
    support, take a look at the following example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地自己使用 `metaclass` 模拟相同的行为，但应该注意 `abc.ABCMeta` 实际上做了更多，我们将在下一节中进行演示。为了模仿内置抽象基类支持的行为，看看下面的例子：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The actual implementation is a bit more complicated as it still needs to take
    care of the old style classes and the `property`, `classmethod`, and `staticmethod`
    types of methods. Additionally, it features caching, but this code covers the
    most useful part of the implementation. One of the most important tricks to note
    here is that the actual check is executed by decorating the `__new__` function
    of the actual class. This method is only executed once within a class so we can
    avoid the overhead of these checks for multiple instantiations.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的实现要复杂一些，因为它仍然需要处理旧式类和`property`、`classmethod` 和 `staticmethod` 类型的方法。此外，它还具有缓存功能，但这段代码涵盖了实现的最有用部分。这里最重要的技巧之一是实际的检查是通过装饰实际类的
    `__new__` 函数来执行的。这个方法在类中只执行一次，所以我们可以避免为多个实例化添加这些检查的开销。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The actual implementation of the abstract methods can be found by looking for
    `__isabstractmethod__` in the Python source code in the following files: `Objects/descrobject.c`,
    `Objects/funcobject.c`, and `Objects/object.c`. The Python part of the implementation
    can be found in `Lib/abc.py`.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象方法的实际实现可以通过在Python源代码中查找 `Objects/descrobject.c`、`Objects/funcobject.c` 和
    `Objects/object.c` 文件中的 `__isabstractmethod__` 来找到。实现的Python部分可以在 `Lib/abc.py`
    中找到。
- en: Custom type checks
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义类型检查
- en: 'Defining your own interfaces using abstract base classes is great, of course.
    But it can also be very convenient to tell Python what your class actually resembles
    and what kind of types are similar. For that, `abc.ABCMeta` offers a register
    function which allows you to specify which types are similar. For example, a custom
    list that sees the list type as similar:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，使用抽象基类来定义自己的接口是很好的。但是告诉Python你的类实际上类似于什么样的类型也是非常方便的。为此，`abc.ABCMeta` 提供了一个注册函数，允许你指定哪些类型是相似的。例如，一个自定义的列表将列表类型视为相似的：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As demonstrated with the last four lines, this is a one-way relationship. The
    other way around would generally be easy enough to realize through inheriting
    list, but that won't work in this case. `abc.ABCMeta` refuses to create inheritance
    cycles.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如最后四行所示，这是一个单向关系。反过来通常很容易通过继承列表来实现，但在这种情况下不起作用。`abc.ABCMeta` 拒绝创建继承循环。
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To be able to handle cases like these, there is another useful feature in `abc.ABCMeta`.
    When subclassing `abc.ABCMeta`, the `__subclasshook__` method can be extended
    to customize the behavior of `issubclass` and with that, `isinstance`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够处理这样的情况，`abc.ABCMeta` 中还有另一个有用的特性。在子类化 `abc.ABCMeta` 时，可以扩展 `__subclasshook__`
    方法来定制 `issubclass` 和 `isinstance` 的行为。
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `__subclasshook__` should return `True`, `False`, or `NotImplemented`, which
    would result in `issubclass` returning `True`, `False`, or the usual behavior
    when `NotImplemented` is raised.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`__subclasshook__` 应该返回 `True`、`False` 或 `NotImplemented`，这将导致 `issubclass`
    返回 `True`、`False` 或在引发 `NotImplemented` 时的通常行为。'
- en: Using abc.ABC before Python 3.4
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Python 3.4 之前使用 abc.ABC
- en: 'The `abc.ABC` class we have used in this paragraph is only available in Python
    versions 3.4 and higher, but it''s trivial to implement it in older versions.
    It''s little more than syntactic sugar for `metaclass=abc.ABCMeta`. To implement
    it yourself, you can simply use the following snippet:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本段中使用的 `abc.ABC` 类仅在 Python 3.4 及更高版本中可用，但在旧版本中实现它是微不足道的。它只是 `metaclass=abc.ABCMeta`
    的语法糖。要自己实现它，你可以简单地使用以下代码片段：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Automatically registering a plugin system
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动注册插件系统
- en: 'One of the most common uses of metaclasses is to have classes automatically
    register themselves as plugins/handlers. Examples of these can be seen in many
    projects, such as web frameworks. Those codebases are too extensive to usefully
    explain here though. Hence, we''ll show a simpler example showing the power of
    metaclasses as a self-registering `plugin` system:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 元类最常见的用途之一是让类自动注册为插件/处理程序。这些示例可以在许多项目中看到，比如Web框架。这些代码库太庞大了，在这里无法有用地解释。因此，我们将展示一个更简单的例子，展示元类作为自注册的
    `plugin` 系统的强大功能：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This example is a tad simplistic of course, but it's the basis for many plugin
    systems. Which is a very important thing to note while implementing systems like
    these; however, while metaclasses run at definition time, the module still needs
    to be imported to work. There are several options to do this; loading on-demand
    through the `get` method has my vote as that also doesn't add load time if the
    plugin is not used.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个例子有点简单，但它是许多插件系统的基础。这是在实现这样的系统时需要注意的一个非常重要的事情；然而，尽管元类在定义时运行，模块仍然需要被导入才能工作。有几种选项可以做到这一点；通过
    `get` 方法进行按需加载是我的选择，因为这样即使插件没有被使用也不会增加加载时间。
- en: The following examples will use the following file structure to get reproducible
    results. All files will be contained in a plugins directory.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将使用以下文件结构以获得可重现的结果。所有文件将包含在一个名为 plugins 的目录中。
- en: The `__init__.py` file is used to create shortcuts, so a simple import plugins
    will result in having `plugins.Plugins` available, instead of requiring importing
    `plugins.base` explicitly.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__.py` 文件用于创建快捷方式，因此简单的导入 plugins 将导致 `plugins.Plugins` 可用，而不需要显式导入
    `plugins.base`。'
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `base.py` file containing the `Plugins` collection and the `Plugin` base
    class:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 包含 `Plugins` 集合和 `Plugin` 基类的 `base.py` 文件：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And two simple plugins, `spam.py`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 和两个简单的插件，`spam.py`：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And `eggs.py`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 和 `eggs.py`：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Importing plugins on-demand
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按需导入插件
- en: The first of the solutions for the import problem is simply taking care of it
    in the `get` method of the `Plugins` metaclass. Whenever the plugin is not found
    in the registry, it should automatically load the module from the `plugins` directory.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 解决导入问题的第一个解决方案是在 `Plugins` 元类的 `get` 方法中处理它。每当在注册表中找不到插件时，它应该自动从 `plugins` 目录加载模块。
- en: The advantages of this approach are that not only the plugins don't explicitly
    need to be preloaded but also that the plugins are only loaded when the need is
    there. Unused plugins are not touched, so this method can help in reducing your
    applications' load times.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优势在于，不仅插件不需要显式预加载，而且只有在需要时才加载插件。未使用的插件不会被触及，因此这种方法有助于减少应用程序的加载时间。
- en: The downside is that the code will not be run or tested, so it might be completely
    broken and you won't know about it until it is finally loaded. Solutions for this
    problem will be covered in the testing chapter, [Chapter 10](ch10.html "Chapter 10. Testing
    and Logging – Preparing for Bugs"), *Testing and Logging – Preparing for Bugs*.
    The other problem is that if the code self-registers itself into other parts of
    an application then that code won't be executed either.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点是代码不会被运行或测试，所以它可能完全失效，直到最终加载时你才会知道。这个问题的解决方案将在测试章节中介绍，[第10章](ch10.html "第10章。测试和日志
    - 为错误做准备")，*测试和日志 - 为错误做准备*。另一个问题是，如果代码自注册到应用程序的其他部分，那么该代码也不会被执行。
- en: 'Modifying the `Plugins.get` method, we get the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`Plugins.get`方法，我们得到以下结果：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This results in the following when executing:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时会得到以下结果：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, this approach only results in running `import` once. The second
    time, the plugin will be available in the plugins dictionary so no loading will
    be necessary.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这种方法只会导入一次`import`。第二次，插件将在插件字典中可用，因此不需要加载。
- en: Importing plugins through configuration
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过配置导入插件
- en: While only loading the needed plugins is generally a better idea, there is something
    to be said to preload the plugins you will likely need. As explicit is better
    than implicit, an explicit list of plugins to load is generally a good solution.
    The added advantages of this method are that firstly you are able to make the
    registration a bit more advanced as you are guaranteed that it is run and secondly
    you can load plugins from multiple packages.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通常只加载所需的插件是一个更好的主意，但预加载可能需要的插件也有其优点。显式比隐式更好，显式加载插件列表通常是一个很好的解决方案。这种方法的附加优势是，首先你可以使注册更加先进，因为你保证它被运行，其次你可以从多个包中加载插件。
- en: 'Instead of importing in the `get` method, we will add a `load` method this
    time; a `load` method that imports all the given module names:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在`get`方法中，我们将这次添加一个`load`方法；一个导入所有给定模块名称的`load`方法：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Which can be called using the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下代码调用：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: A fairly simple and straightforward system to load the plugins based on settings,
    this can easily be combined with any type of settings system to fill the `load`
    method.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相当简单和直接的系统，根据设置加载插件，这可以很容易地与任何类型的设置系统结合使用来填充`load`方法。
- en: Importing plugins through the file system
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过文件系统导入插件
- en: Whenever possible, it is best to avoid having systems depend on automatic detection
    of modules on a filesystem as it goes directly against `PEP8`. Specifically, "explicit
    is better than implicit". While these systems can work fine in specific cases,
    they often make debugging much more difficult. Similar automatic import systems
    in Django have caused me a fair share of headaches as they tend to obfuscate the
    errors. Having said that, automatic plugin loading based on all the files in a
    plugins directory is still a possibility warranting a demonstration.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，最好避免让系统依赖于文件系统上模块的自动检测，因为这直接违反了`PEP8`。特别是，“显式比隐式更好”。虽然这些系统在特定情况下可以正常工作，但它们经常会使调试变得更加困难。在Django中类似的自动导入系统给我带来了不少头疼，因为它们往往会混淆错误。话虽如此，基于插件目录中所有文件的自动插件加载仍然是一个值得演示的可能性。
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If possible, I would try to avoid using a fully automatic import system as it's
    very prone to accidental errors and can make debugging more difficult, not to
    mention that the import order cannot easily be controlled this way. To make this
    system a bit smarter (even importing packages outside of your Python path), you
    can create a plugin loader using the abstract base classes in `importlib.abc`.
    Note that you will most likely still need to list the directories through `os.listdir`
    or `os.walk` though.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，我会尽量避免使用完全自动的导入系统，因为它很容易出现意外错误，并且会使调试变得更加困难，更不用说导入顺序无法轻松地通过这种方式进行控制。为了使这个系统变得更加智能（甚至导入Python路径之外的包），你可以使用`importlib.abc`中的抽象基类创建一个插件加载器。请注意，你很可能仍然需要通过`os.listdir`或`os.walk`列出目录。
- en: Order of operations when instantiating classes
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例化类时的操作顺序
- en: The order of operations during class instantiation is very important to keep
    in mind when debugging issues with dynamically created and/or modified classes.
    The instantiation of a class happens in the following order.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试动态创建和/或修改的类时，类实例化的操作顺序非常重要。类的实例化按以下顺序进行。
- en: Finding the metaclass
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找元类
- en: The metaclass comes from either the explicitly given metaclass on the class
    or `bases`, or by using the default `type` metaclass.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 元类来自于类的显式给定的元类或`bases`，或者使用默认的`type`元类。
- en: 'For every class, the class itself and the bases, the first matching of the
    following will be used:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个类，类本身和bases，将使用以下匹配的第一个：
- en: Explicitly given metaclass
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式给定的元类
- en: Explicit metaclass from bases
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从bases中显式元类
- en: '`type()`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type()`'
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that if no metaclass is found that is a subtype of all the candidate metaclasses,
    a `TypeError` will be raised. This scenario is not that likely to occur but certainly
    a possibility when using multiple inheritance/mixins with metaclasses.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果找不到是所有候选元类的子类型的元类，将引发`TypeError`。这种情况发生的可能性不太大，但在使用多重继承/混入元类时肯定是可能的。
- en: Preparing the namespace
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备命名空间
- en: The class namespace is prepared through the metaclass selected previously. If
    the metaclass has a `__prepare__` method, it will be called `namespace = metaclass`.`__prepare__(names,
    bases, **kwargs)`, where `**kwargs` originates from the class definition. If no
    `__prepare__` method is available, the result will be `namespace = dict()`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过之前选择的元类准备类命名空间。如果元类有一个`__prepare__`方法，它将被调用`namespace = metaclass.__prepare__(names,
    bases, **kwargs)`，其中`**kwargs`来自类定义。如果没有`__prepare__`方法可用，结果将是`namespace = dict()`。
- en: Note that there are multiple ways of achieving custom namespaces, as we saw
    in the previous paragraph, the `type()` function call also takes a `dict` argument
    which can be used to alter the namespace as well.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，有多种实现自定义命名空间的方法，正如我们在前一段中看到的，`type()`函数调用还接受一个`dict`参数，也可以用于修改命名空间。
- en: Executing the class body
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行类主体
- en: 'The body of the class is executed very similarly to normal code execution with
    one key difference, the separate namespace. Since a class has a separate namespace,
    which shouldn''t pollute the `globals()/locals()` namespaces, it is executed within
    that context. The resulting call looks something like this: `exec(body, globals(),
    namespace)` where `namespace` is the previously produced namespace.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 类的主体执行方式与普通代码执行非常相似，但有一个关键区别，即单独的命名空间。由于类有一个单独的命名空间，不应该污染`globals()/locals()`命名空间，因此在该上下文中执行。结果调用看起来像这样：`exec(body,
    globals(), namespace)`，其中`namespace`是先前生成的命名空间。
- en: Creating the class object (not instance)
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建类对象（而不是实例）
- en: Now that we have all the components ready, the actual class object can be produced.
    This is done through the `class_ = metaclass(name, bases, namespace, **kwargs)`
    call. This is, as you can see, actually identical to the `type()` call previously
    discussed. `**kwargs` here are the same as the ones passed to the `__prepare__`
    method earlier.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好所有组件，实际的类对象可以被生成。这是通过`class_ = metaclass(name, bases, namespace, **kwargs)`调用完成的。正如您所看到的，这实际上与之前讨论的`type()`调用完全相同。这里的`**kwargs`与之前传递给`__prepare__`方法的参数相同。
- en: It might be useful to note that this is also the object that will be referenced
    from the `super()` call without arguments.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这也是在`super()`调用中不带参数时将被引用的对象。
- en: Executing the class decorators
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行类装饰器
- en: Now that the class object is actually done already, the class decorators will
    be executed. Since this is only executed after everything else in the class object
    has already been constructed, it becomes difficult to modify class attributes,
    such as which classes are being inherited, and the name of the class. By modifying
    the `__class__` object you can still modify or overwrite these, but it is, at
    the very least, more difficult.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在类对象实际上已经完成，类装饰器将被执行。由于这仅在类对象中的所有其他内容已经构建完成后执行，因此变得更难修改类属性，例如继承哪些类以及类的名称。通过修改`__class__`对象，您仍然可以修改或覆盖这些内容，但至少更加困难。
- en: Creating the class instance
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建类实例
- en: From the class object produced previously, we can now finally create the actual
    instances as you normally would with a class. It should be noted that this step
    and the class decorators steps, unlike the earlier steps, are the only ones that
    are executed every time you instantiate a class. The steps before these two are
    only executed once per class definition.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 从先前生成的类对象中，现在我们可以像通常一样创建实际的实例。应该注意的是，与之前的步骤不同，这两个步骤和类装饰器步骤是唯一在每次实例化类时执行的步骤。在这两个步骤之前的步骤只在每个类定义时执行一次。
- en: Example
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: 'Enough theory! Let''s illustrate the creation and instantiation of the class
    objects so we can check the order of operations:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 足够的理论！让我们说明创建和实例化类对象的过程，以便检查操作顺序：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The example clearly shows the creation order of the class:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例清楚地显示了类的创建顺序：
- en: Preparing the namespace through `__prepare__`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`__prepare__`准备命名空间。
- en: Creating the class body using `__new__`.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`__new__`创建类主体。
- en: Initializing the metaclass using `__init__` (note that this is not the class
    `__init__`).
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`__init__`初始化元类（请注意，这不是类`__init__`）。
- en: Initializing the class through the class decorator.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过类装饰器初始化类。
- en: Initializing the class through the class `__init__` function.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过类`__init__`函数初始化类。
- en: One thing we can note from this is that the class decorators are executed each
    and every time the class is actually instantiated and not before that. This can
    be both an advantage and a disadvantage of course, but if you wish to build a
    register of all subclasses, it is definitely more convenient to use a metaclass
    since the decorator will not register until you instantiate the class.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从中注意到的一点是，类装饰器在实际实例化类时每次都会执行，而不是在此之前。当然，这既是优点也是缺点，但如果您希望构建所有子类的注册表，那么使用元类肯定更方便，因为装饰器在实例化类之前不会注册。
- en: In addition to this, having the power to modify the namespace before actually
    creating the class object (not the instance) can be very powerful as well. It
    can be convenient for sharing a certain scope between several class objects for
    example, or for easily ensuring that certain items are always available in the
    scope.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，在实际创建类对象（而不是实例）之前修改命名空间的能力也是非常强大的。例如，可以方便地在几个类对象之间共享特定范围，或者轻松确保某些项目始终在范围内可用。
- en: Storing class attributes in definition order
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按定义顺序存储类属性
- en: There are cases where the definition order makes a difference. For example,
    let's assume we are creating a class that represents a CSV (Comma Separated Values)
    format. The CSV format expects the fields to have a particular order. In some
    cases this will be indicated by a header but it's still useful to have a consistent
    field order. Similar systems are using in ORM systems such as SQLAlchemy to store
    the column order for table definitions and for the input field order within forms
    in Django.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况下，定义顺序是有影响的。例如，假设我们正在创建一个表示CSV（逗号分隔值）格式的类。CSV格式期望字段有特定的顺序。在某些情况下，这将由标题指示，但保持一致的字段顺序仍然很有用。类似的系统在ORM系统（如SQLAlchemy）中使用，用于存储表定义的列顺序以及在Django中的表单中的输入字段顺序。
- en: The classic solution without metaclasses
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 没有元类的经典解决方案
- en: An easy way to store the order of the fields is by giving the field instances
    a special `__init__` method which increments for every definition, so the fields
    have an incrementing index property. This solution can be considered the classic
    solution as it also works in Python 2.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单的存储字段顺序的方法是给字段实例一个特殊的`__init__`方法，每次定义都会增加，因此字段具有递增的索引属性。这种解决方案可以被认为是经典解决方案，因为它在Python
    2中也适用。
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: For convenience, and to make things prettier, we have added the `FieldsMeta`
    class. It is not strictly required here, but it automatically takes care of filling
    in the name if needed, and adds the `fields` list which contains a sorted list
    of fields.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，也为了使事情更美观，我们添加了`FieldsMeta`类。这里并不严格需要它，但它会自动填写名称（如果需要的话），并添加包含字段排序列表的`fields`列表。
- en: Using metaclasses to get a sorted namespace
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用元类获取排序的命名空间
- en: The previous solution is a bit more straightforward and supports Python 2 as
    well, but with Python 3 we have more options. As you have seen in the previous
    paragraphs, since Python 3 we have the `__prepare__` method, which returns the
    namespace. From the previous chapters you might also remember `collections.OrderedDict`,
    so let's see what happens when we combine them.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的解决方案更加直接，并且也支持Python 2，但是在Python 3中我们有更多的选择。正如你在前面的段落中看到的，自从Python 3以来，我们有了`__prepare__`方法，它返回命名空间。从前面的章节中，你可能还记得`collections.OrderedDict`，所以让我们看看当我们将它们结合起来会发生什么。
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, the fields are indeed in the order we defined them. `Spam` first
    and `eggs` after that. Since the class namespace is now a `collections.OrderedDict`
    instance, we know that the order is guaranteed. Instead of the regular not predetermined
    order of the Python `dict`. This demonstrates how convenient metaclasses can be
    to extend your classes in a generic way. Another big advantage of metaclasses,
    instead of a custom `__init__` method, is that the users won't lose the functionality
    if they forget to call the parent `__init__` method. The metaclass will always
    be executed, unless a different metaclass is added, that is.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，字段确实按照我们定义的顺序排列。`Spam`在前，`eggs`在后。由于类命名空间现在是`collections.OrderedDict`实例，我们知道顺序是有保证的。而不是Python
    `dict`的常规非确定性顺序。这展示了元类在以通用方式扩展类时可以多么方便。元类的另一个重要优势是，与自定义的`__init__`方法不同，如果用户忘记调用父类的`__init__`方法，他们也不会失去功能。元类总是会被执行，除非添加了不同的元类。
- en: Summary
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The Python metaclass system is something every Python programmer uses all the
    time, perhaps without even knowing about it. Every class should be created through
    some (subclass of) `type`, which allows for endless customization and magic. Instead
    of statically defining your class, you can now have it created as you normally
    would and dynamically add, modify, or remove attributes from your class during
    definition; very magical but very useful. The magic component, however, is also
    the reason it should be used with a lot of caution. While metaclasses can be used
    to make your life much easier, they are also amongst the easiest ways of producing
    completely incomprehensible code.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Python元类系统是每个Python程序员一直在使用的东西，也许甚至不知道。每个类都应该通过某个（子类）`type`来创建，这允许无限的定制和魔法。现在，你可以像平常一样创建类，并在定义期间动态添加、修改或删除类的属性；非常神奇但非常有用。然而，魔法组件也是它应该谨慎使用的原因。虽然元类可以让你的生活变得更轻松，但它们也是产生完全难以理解的代码的最简单方式之一。
- en: Regardless, there are some great use-cases for metaclasses and many libraries
    such as `SQLAlchemy` and `Django` use metaclasses to make your code work much
    easier and arguably better. Actually comprehending the magic that is used inside
    is generally not needed for the usage of these libraries, which makes the cases
    defendable. The question becomes whether a much better experience for beginners
    is worth some dark magic internally, and looking at the success of these libraries,
    I would say yes in this case.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，元类有一些很好的用例，许多库如`SQLAlchemy`和`Django`都使用元类来使你的代码工作更加轻松，而且可以说更好。实际上，理解内部使用的魔法通常对于使用这些库并不是必需的，这使得这些情况是可以辩护的。问题在于，对于初学者来说，是否值得使用更好的体验来换取一些内部的黑魔法，从这些库的成功来看，我会说在这种情况下是值得的。
- en: 'To conclude, when thinking about using metaclasses, keep in mind what Tim Peters
    once said: "Metaclasses are deeper magic than 99% of users should ever worry about.
    If you wonder whether you need them, you don''t."'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，当考虑使用元类时，请记住蒂姆·彼得斯曾经说过的话：“元类比99%的用户应该担心的更深奥。如果你想知道自己是否需要它们，那就不需要。”
- en: 'Now we will continue with a solution to remove some of the magic that metaclasses
    generate: documentation. The next chapter will show us how your code can be documented,
    how that documentation can be tested, and most importantly, how the documentation
    can be made smarter by annotating types in your documentation.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将继续解决一些元类产生的魔法：文档。下一章将向我们展示如何为代码编写文档，如何测试文档，并且最重要的是，如何通过在文档中注释类型来使文档更加智能。
