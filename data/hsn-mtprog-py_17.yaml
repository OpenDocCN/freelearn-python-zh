- en: '*Chapter 14*: Generating Code from AST'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第14章*：从抽象语法树生成代码'
- en: In this chapter, we will learn how to use ASTs in Python to generate code for
    various applications. We will apply these abstract syntax trees to metaprogramming
    to implement automatic code generated in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用Python中的AST为各种应用程序生成代码。我们将应用这些抽象语法树到元编程中，以实现本章中自动生成的代码。
- en: Automatic code generation is one way of making the life of a programmer easier.
    An abstract syntax tree is an excellent functionality that can help us generate
    code in a much simpler way.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 自动代码生成是使程序员生活更轻松的一种方式。抽象语法树是一个出色的功能，可以帮助我们以更简单的方式生成代码。
- en: The concept of AST is discussed with examples in [*Chapter 9*](B13426_09_Final_PG_epub.xhtml#_idTextAnchor124)
    of this book. In this chapter, we will be tapping the advantages of ASTs to generate
    code automatically. Code generation can be implemented to enable no-code or limited
    coding while developing applications. In this chapter, we will continue to use
    the example of *ABC Megamart* to generate code from ASTs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书第9章[*第9章*](B13426_09_Final_PG_epub.xhtml#_idTextAnchor124)中讨论了AST的概念，并附有示例。在本章中，我们将利用AST的优势来自动生成代码。代码生成可以实现，以便在开发应用程序时无需代码或仅限少量编码。在本章中，我们将继续使用*ABC
    Megamart*的例子来从AST生成代码。
- en: 'In this chapter, we will be looking at the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主要主题：
- en: Generating a simple class with a template
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模板生成简单类
- en: Generating multiple classes from a list
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从列表生成多个类
- en: Generating a class with attributes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成具有属性的类
- en: Generating a class with methods
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成具有方法的类
- en: Defining a custom class factory
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义自定义类工厂
- en: Developing a code generator to generate a simple library
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发代码生成器以生成简单库
- en: By the end of this chapter, you should be able to understand how to use the
    existing methods of the `ast` library in Python to enable your application to
    generate its own code, how to avoid repeating yourself, and how to generate code
    dynamically.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够理解如何使用Python中`ast`库的现有方法来使你的应用程序生成自己的代码，如何避免重复，以及如何动态生成代码。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code examples shared in this chapter are available on GitHub under the
    code for this chapter here: [https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter14](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter14).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中分享的代码示例可在GitHub上找到，地址为[https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter14](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter14)。
- en: Generating a simple class with a template
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模板生成简单类
- en: In this section, we will be looking at how to generate code for a class without
    actually defining the class itself. We will be creating a string-based template
    with the structure of a class we want to develop but not the actual code that
    can be executed. To explain this further, let us look at an example where we will
    generate a class named `VegCounter` by parsing a series of strings using the `ast`
    module.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何在不实际定义类本身的情况下生成类的代码。我们将创建一个基于字符串的模板，具有我们想要开发的类的结构，但不包含可执行的代码。为了进一步解释这一点，让我们看一个例子，我们将通过使用`ast`模块解析一系列字符串来生成名为`VegCounter`的类。
- en: 'The sequence of steps to be followed to generate code for a class is represented
    in the following flow diagram:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 生成类代码的步骤顺序表示在以下流程图中：
- en: '![Figure 14.1 – A code generation sequence for a simple class ](img/Figure_14.1_B13426.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图14.1 – 简单类的代码生成序列](img/Figure_14.1_B13426.jpg)'
- en: Figure 14.1 – A code generation sequence for a simple class
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 – 简单类的代码生成序列
- en: 'Let us look at the implementation of this example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个例子的实现：
- en: 'We will start by importing the `ast` library:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先导入`ast`库：
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let us now create a variable to pass the class name with which the code needs
    to be generated:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建一个变量，用于传递需要生成代码的类名：
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will next define a variable that becomes the template for the class generated
    in this example:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接下来将定义一个变量，它将成为本例中生成的类的模板：
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the next step, we will parse the class template with the parse method in
    the `ast` module:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，我们将使用`ast`模块中的`parse`方法解析类模板：
- en: '[PRE3]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output of the preceding code displays the abstract syntax tree of the class
    template:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述代码的输出显示了类模板的抽象语法树：
- en: '[PRE4]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding tree can be compiled and executed as follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的树可以按以下方式编译和执行：
- en: '[PRE5]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Thus, this leads to the following output:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这导致了以下输出：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the next step, we will unparse the tree to generate the actual code for
    the class:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，我们将反解析树以生成类的实际代码：
- en: '[PRE7]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Executing the preceding code leads to the following output:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的代码会导致以下输出：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the next step, let us write the preceding class code to a file named `classtemplate.py`:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，让我们将前面的类代码写入名为 `classtemplate.py` 的文件：
- en: '[PRE9]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `classtemplate` file looks as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`classtemplate` 文件看起来如下所示：'
- en: '![Figure 14.2 – The classtemplate.py file ](img/Figure_14.2_B13426.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.2 – `classtemplate.py` 文件](img/Figure_14.2_B13426.jpg)'
- en: Figure 14.2 – The classtemplate.py file
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.2 – `classtemplate.py` 文件
- en: 'Let us now import the `classtemplate` and create an object:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们导入 `classtemplate` 并创建一个对象：
- en: '[PRE10]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output is as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this section, we have generated a simple class code using the `ast` module.
    This example helps us in understanding the steps to be followed to generate code
    for a custom class since it is easier to start understanding code generation by
    starting simple. With this understanding, let us generate code for multiple classes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用 `ast` 模块生成了一个简单的类代码。这个例子帮助我们理解生成自定义类代码的步骤，因为从简单开始理解代码生成更容易。有了这个理解，让我们为多个类生成代码。
- en: Generating multiple classes from a list
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从列表生成多个类
- en: In this section, we will look at generating code for multiple classes dynamically
    using the `ast` module and its `unparse` method.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何使用 `ast` 模块及其 `unparse` 方法动态地为多个类生成代码。
- en: Generating the code for more than one class dynamically gives us a direction
    for implementing code generation for multiple functionalities of an application.
    The classes need not be for the same functionality and the class code thus generated
    can later be modified to include additional methods or attributes as required
    by the application. The skeletal class code will be generated through this example.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 动态地为多个类生成代码，为我们实现应用程序多个功能的代码生成提供了方向。这些类不需要具有相同的功能，因此生成的类代码可以稍后修改，以包括应用程序所需的额外方法或属性。示例中将生成骨架类代码。
- en: To understand this further, we will follow the sequence described in the following
    flow diagram.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步理解，我们将遵循以下流程图描述的顺序。
- en: '![Figure 14.3 – A code generation sequence for multiple classes ](img/Figure_14.3_B13426.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.3 – 多个类的代码生成序列](img/Figure_14.3_B13426.jpg)'
- en: Figure 14.3 – A code generation sequence for multiple classes
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.3 – 多个类的代码生成序列
- en: 'Let us now look at how to implement this scenario:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何实现这个场景：
- en: 'We will first define a variable that can be assigned a list of class names
    as values:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义一个变量，该变量可以分配一个包含类名的列表作为值：
- en: '[PRE12]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the next step, let us look at generating class templates for each of the
    class names from the preceding list:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，让我们看看如何从前面的列表中为每个类名生成类模板：
- en: '[PRE13]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The class templates are added to another list named `classgenerator`, and the
    list is as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 类模板被添加到另一个名为 `classgenerator` 的列表中，该列表如下所示：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To parse the string templates from the preceding output and generate their
    abstract syntax trees, let us create another list named `classtrees` and store
    the trees:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解析前面的输出中的字符串模板并生成它们的抽象语法树，让我们创建另一个名为 `classtrees` 的列表并存储这些树：
- en: '[PRE15]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The parsed class trees that are assigned to the `classtrees` list variable
    are displayed as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 分解的类树，分配给 `classtrees` 列表变量，显示如下：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this step, we will review one of the trees to ensure that the abstract syntax
    tree is generated for the class as expected:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本步骤中，我们将审查其中一个树以确保抽象语法树按预期为类生成：
- en: '[PRE17]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output is generated as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can further unparse the `classtrees` variable to generate the code for each
    class:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以进一步将 `classtrees` 变量反解析，为每个类生成代码：
- en: '[PRE19]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'An example output looks as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例输出如下所示：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let us further write all the generated classes into a file:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将所有生成的类写入一个文件：
- en: '[PRE21]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The generated `classtemplates.py` file looks as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 `classtemplates.py` 文件看起来如下所示：
- en: '![Figure 14.4 – The classtemplates.py file ](img/Figure_14.4_B13426.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.4 – `classtemplates.py` 文件](img/Figure_14.4_B13426.jpg)'
- en: Figure 14.4 – The classtemplates.py file
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.4 – `classtemplates.py` 文件
- en: 'Let us import the file and call an instance of each class to check if it works:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入文件并调用每个类的实例以检查其是否工作：
- en: '[PRE22]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下所示：
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this section, we have generated code for multiple classes using the `ast`
    module. This example is the next step toward working on automatic code generation
    for multiple functionalities or modules of an application.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用 `ast` 模块为多个类生成了代码。这个例子是朝着为应用程序的多个功能或模块自动生成代码的下一步。
- en: Generating a class with attributes
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成具有属性的类
- en: 'In this section, we will generate code for a class, along with a list of attributes,
    that will also be included dynamically in the class. Generating code for a class
    alone can give the initial skeletal structure for a module, whereas we need to
    add attributes if we want to make the class more specific. The following flow
    diagram represents the sequence of steps to be followed for this example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为包含动态包含在类中的属性列表的类生成代码。仅生成类的代码可以给出模块的初始骨架结构，而如果我们想使类更具体，则需要添加属性。以下流程图表示了本例要遵循的步骤序列：
- en: '![Figure 14.5 – A code generation sequence for a class with multiple attributes
    ](img/Figure_14.5_B13426.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.5 – 具有多个属性的类的代码生成序列](img/Figure_14.5_B13426.jpg)'
- en: Figure 14.5 – A code generation sequence for a class with multiple attributes
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.5 – 具有多个属性的类的代码生成序列
- en: 'Let us look at the code for this example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看本例的代码：
- en: 'We will first define a variable to provide `classname` as input, followed by
    a `classtemplate` to create the template of the class declaration:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义一个变量以提供 `classname` 作为输入，然后定义一个 `classtemplate` 来创建类声明的模板：
- en: '[PRE24]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the next step, let us define another variable to provide attribute names
    as input:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，让我们定义另一个变量以提供属性名称作为输入：
- en: '[PRE25]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let us further update `classtemplate` by providing each of the preceding attributes
    that are required to generate the class code:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们进一步更新 `classtemplate`，提供生成类代码所需的前述每个属性：
- en: '[PRE26]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let us now parse the `classtemplate` and review the abstract syntax tree:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们现在解析 `classtemplate` 并审查抽象语法树：
- en: '[PRE27]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The syntax tree for the preceding class template looks as follows:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述类模板的语法树如下所示：
- en: '[PRE28]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: All three variables – `items`, `countername`, and `billamount` added into the
    class template – are now part of the syntax tree. If we review the tree in detail,
    we can look at these variables under `body` | `assign` | `targets` | `name` |
    `id`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个变量 – `items`、`countername` 和 `billamount` – 现在都是语法树的一部分。如果我们详细审查树，我们可以在
    `body` | `assign` | `targets` | `name` | `id` 下查看这些变量。
- en: 'We can further unparse the tree and look at the code of the class:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以进一步解析树形结构并查看类的代码：
- en: '[PRE29]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output looks as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE30]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let us write the code to a file and import it:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将代码写入文件并导入：
- en: '[PRE31]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The generated code looks as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的代码如下所示：
- en: '![Figure 14.6 –The classtemplateattr.py file ](img/Figure_14.6_B13426.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.6 – classtemplateattr.py 文件](img/Figure_14.6_B13426.jpg)'
- en: Figure 14.6 –The classtemplateattr.py file
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.6 – classtemplateattr.py 文件
- en: 'We can import the `classtemplateattr.py` file and the class can be accessed
    as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以导入 `classtemplateattr.py` 文件，并且可以通过以下方式访问类：
- en: '[PRE32]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output is displayed as follows, with all the attributes and their corresponding
    values assigned:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示，所有属性及其对应值都已分配：
- en: '[PRE33]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this section, we have generated a class with multiple attributes without
    writing the code for the class. Instead, we have defined a template that takes
    in a class name and a list of attributes as input. With this understanding, we
    can look at generating a class with methods.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们生成了一个具有多个属性的类，而没有为类编写代码。相反，我们定义了一个模板，该模板接受类名和属性列表作为输入。有了这个理解，我们可以看看如何生成具有方法的类。
- en: Generating a class with methods
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成具有方法的类
- en: 'In this section, let us generate code for a class and its methods. Throughout
    this chapter, our goal is to generate code dynamically for building applications
    that can solve a specific purpose. Adding methods along with attributes makes
    the code generation for a class even more application-specific. We can look at
    two variations of this example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为类及其方法生成代码。在本章中，我们的目标是动态生成代码以构建具有特定目的的应用程序。添加属性和方法使类的代码生成更加特定于应用。我们可以查看这个例子的两种变体：
- en: Generating a class with an `init` method
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成具有 `init` 方法的类
- en: Generating a class with a user-defined method
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成具有用户定义方法的类
- en: Let’s discuss each in detail.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论每个部分。
- en: Generating a class with an init method
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成具有 `init` 方法的类
- en: 'In this example, let us generate code for a class and add an `init` method
    to the class and also initialize attributes. In this example, we will define a
    class for the vegetable counter of *ABC Megamart*. In the `init` method, let us
    initialize cart items from the vegetable counter of *ABC Megamart* in this class:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，让我们为类生成代码，并向类中添加一个`init`方法，并初始化属性。在这个例子中，我们将定义一个用于*ABC Megamart*蔬菜计数器的类。在`init`方法中，让我们在这个类中初始化来自*ABC
    Megamart*蔬菜计数器的购物车项目：
- en: '[PRE34]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The parsed class template generates the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 解析后的类模板生成了以下代码：
- en: '[PRE42]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The abstract syntax tree for this class is generated with the function definition,
    as represented in the following figure:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的抽象语法树是通过函数定义生成的，如下图中所示：
- en: '![Figure 14.7 – The function definition of the init method ](img/Figure_14.7_B13426.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图14.7 – 初始化方法的函数定义](img/Figure_14.7_B13426.jpg)'
- en: Figure 14.7 – The function definition of the init method
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.7 – 初始化方法的函数定义
- en: With this understanding, let us look at one more example of this same class
    by generating code for a user-defined method.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个理解，让我们通过生成用户定义方法的代码来看这个类的另一个示例。
- en: Generating a class with a user-defined method
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成具有用户定义方法的类
- en: 'In this section, let us look at a variation of the class by creating a template
    that generates a user-defined method for the class:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们通过创建一个模板来生成类的用户定义方法，看看类的变体：
- en: '[PRE48]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The parsed `classtemplate` generates the following code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 解析后的`classtemplate`生成了以下代码：
- en: '[PRE57]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The abstract syntax tree for this class is generated with the function definition,
    as represented in the following figure:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的抽象语法树是通过函数定义生成的，如下图中所示：
- en: '![Figure 14.8 – The function definition of the user-defined method ](img/Figure_14.8_B13426.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图14.8 – 用户定义方法的函数定义](img/Figure_14.8_B13426.jpg)'
- en: Figure 14.8 – The function definition of the user-defined method
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.8 – 用户定义方法的函数定义
- en: We can either use the `init` method when we want to initialize the cart items
    at the class level or use the attributes later. By contrast, the user-defined
    method can be used if we want to keep the attributes specific to the method and
    perform actions based on the attributes within the method.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想在类级别初始化购物车项目时，我们可以使用`init`方法，或者稍后使用属性。相比之下，如果我们想保持方法特定的属性并基于方法内的属性执行操作，则可以使用用户定义的方法。
- en: With this understanding, let us look at defining a custom class factory.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个理解，让我们来看定义自定义类工厂。
- en: Defining a custom class factory
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义自定义类工厂
- en: 'In this section, let us define a function named `classgenerator` that generates
    a custom class, attribute, and method using a class template as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们定义一个名为`classgenerator`的函数，该函数使用类模板生成自定义类、属性和方法，如下所示：
- en: '[PRE63]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In this section, we are making the code generation more dynamic by creating
    a function that can generate code with custom values for the class name, attribute
    name, and method name, respectively. This helps in creating custom code for multiple
    functionalities in an application.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们通过创建一个函数来使代码生成更加动态，该函数可以生成具有自定义类名、属性名和方法名的代码。这有助于在应用程序中创建针对多个功能的自定义代码。
- en: 'Let us provide a custom class name, attribute name, and method name as input
    to the preceding function:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将自定义类名、属性名和方法名作为输入提供给前面的函数：
- en: '[PRE73]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The generated class code is as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的类代码如下：
- en: '[PRE76]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: We can expand this example further by developing a code generator library in
    the following section.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在下一节通过开发一个代码生成库来进一步扩展这个示例。
- en: Developing a code generator to generate a simple library
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发一个生成简单库的代码生成器
- en: 'In this section, let us develop a simple code generator that generates code
    for a class with `get`, `set`, and `delete` properties for its custom attributes.
    The purpose of this section is to generate a complete library through automatic
    code generation. To fulfill this, let us write the following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们开发一个简单的代码生成器，该生成器为具有`get`、`set`和`delete`属性的类生成代码。本节的目的是通过自动代码生成生成一个完整的库。为了实现这一点，让我们编写以下代码：
- en: 'Let us define the code generator as follows:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们按照以下方式定义代码生成器：
- en: '[PRE83]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Let us further define the method to define the class template in the code generator
    as follows:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们进一步定义一个方法，用于在代码生成器中定义类模板，如下所示：
- en: '[PRE84]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We will now save the preceding code into a file named `codegenerator.py` and
    import the file as a library:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将前面的代码保存到名为`codegenerator.py`的文件中，并将该文件作为库导入：
- en: '[PRE85]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Let us define a dictionary object and assign multiple class names and their
    corresponding attribute names as input:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义一个字典对象，并将多个类名及其对应的属性名作为输入：
- en: '[PRE86]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Let us further define a function named `generatelib` and add `classes` as input
    parameters. This function takes in the class names and their attribute names as
    input and generates the code from the class templates of the `codegenerator` library:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们进一步定义一个名为 `generatelib` 的函数，并将 `classes` 作为输入参数。此函数接收类名及其属性名作为输入，并从 `codegenerator`
    库的类模板生成代码：
- en: '[PRE87]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'In this step, let us write the generated code into a file to generate a custom
    library that can be used further:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此步骤中，让我们将生成的代码写入文件，以生成一个可进一步使用的自定义库：
- en: '[PRE88]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The generated code is in the following format for each input class:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个输入类，生成的代码格式如下：
- en: '[PRE89]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'We can further import the generated library and define objects as follows:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以进一步导入生成的库，并按如下方式定义对象：
- en: '[PRE90]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The preceding code returns the following output:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码返回以下输出：
- en: '[PRE91]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: These are various examples of code generation that can be implemented using
    Python’s metaprogramming `ast` module.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是使用 Python 的元编程 `ast` 模块可以实现的代码生成各种示例。
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have looked at various examples to generate code for a custom
    class and a class with custom attributes. We have also covered examples of generating
    code for a custom class with methods and attributes. Finally, we have developed
    a code generator that can be used to develop a custom library using the concept
    of abstract syntax trees in Python.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了生成自定义类及其自定义属性代码的多个示例。我们还涵盖了生成具有方法和属性的定制类代码的示例。最后，我们开发了一个代码生成器，可以使用
    Python 中的抽象语法树概念来开发自定义库。
- en: Overall, we have seen various scenarios that can help us utilize the abstract
    syntax tree within Python’s `ast` module and generate dynamic code using Python
    metaprogramming.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，我们看到了各种场景，这些场景可以帮助我们利用 Python 的 `ast` 模块中的抽象语法树，并使用 Python 元编程生成动态代码。
- en: In the next chapter, we will be discussing a case study to which we can apply
    all the concepts of metaprogramming that we have covered so far in the book.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论一个案例研究，我们可以将本书中涵盖的所有元编程概念应用于此案例研究。
