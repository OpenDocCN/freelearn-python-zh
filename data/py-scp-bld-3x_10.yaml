- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Advanced and Modal Operators
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级和模式操作符
- en: Since [*Chapter 3*](B18375_03.xhtml#_idTextAnchor049), we have resorted to operators
    to implement our features in Blender.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 自从[*第3章*](B18375_03.xhtml#_idTextAnchor049)以来，我们就求助于操作符在Blender中实现我们的功能。
- en: Operators have already proved to be incredibly flexible, with custom properties
    and looks. They can be even more powerful once we learn how to override all their
    methods.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符已经证明具有极大的灵活性，具有自定义属性和外观。一旦我们学会了如何覆盖它们的所有方法，它们将变得更加强大。
- en: The operators encountered in the previous chapters run as soon as they are launched
    and finish immediately. If we need to, we can make the execution modal and let
    the operator listen to input events.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中遇到的操作符在启动后立即运行并立即完成。如果我们需要，我们可以使执行模式化，并让操作符监听输入事件。
- en: In this chapter, you will learn how to control the execution of an operator,
    and how you can write fully interactive operators.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何控制操作符的执行，以及如何编写完全交互式的操作符。
- en: 'This chapter will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding the operator flow
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解操作符流程
- en: Setting properties programmatically
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以编程方式设置属性
- en: Writing modal operators
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写模式操作符
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We will use Blender and Visual Studio Code in this chapter, but any other programmer
    text editor can be used. The examples created in this chapter can be found at
    [https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch10](https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch10).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Blender和Visual Studio Code，但任何其他程序员文本编辑器都可以使用。本章创建的示例可以在[https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch10](https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch10)找到。
- en: Understanding the operator flow
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解操作符流程
- en: We dealt with operators since [*Chapter 3*](B18375_03.xhtml#_idTextAnchor049),
    and we learned how their `poll` method checks whether the operator can be executed,
    while `execute` performs the operation and exits.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从[*第3章*](B18375_03.xhtml#_idTextAnchor049)开始处理操作符，并学习了它们的`poll`方法如何检查操作符是否可以执行，而`execute`则执行操作并退出。
- en: Then in [*Chapter 4*](B18375_04.xhtml#_idTextAnchor075), we added editable parameters
    to the *Elevator* operator, thanks to the `'REGISTER'` and `'``UNDO'` options.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在[*第4章*](B18375_04.xhtml#_idTextAnchor075)中，我们通过`'REGISTER'`和`'UNDO'`选项将可编辑参数添加到了*电梯*操作符中。
- en: We also learned about the clever trick to change a result in real time when
    a user changes a parameter – Blender secretly undoes the last operation and performs
    it again with the new options, hence the need for `'UNDO'`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解了一个聪明的技巧，当用户更改参数时可以实时更改结果——Blender秘密地撤销最后一个操作并再次执行它，因此需要`'UNDO'`。
- en: That became more evident in [*Chapter 7*](B18375_07.xhtml#_idTextAnchor171),
    when we learned how using **Edit** | **Adjust Last Operation** from the menu bar
    changes the result of the last operation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这在前面的[*第7章*](B18375_07.xhtml#_idTextAnchor171)中变得更加明显，当时我们学习了如何从菜单栏中使用**编辑**
    | **调整最后一个操作**来更改最后一个操作的结果。
- en: While those solutions allow us to get input parameters with ease, they don’t
    give access to the actual input events, such as the pressure of a key or the movement
    of a mouse.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些解决方案使我们能够轻松获取输入参数，但它们并不提供访问实际输入事件的能力，例如按键的压力或鼠标的移动。
- en: That would require a `execute` method instantly, so it couldn’t possibly wait
    for inputs; therefore, the events must be handled by another method.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这将需要立即的`execute`方法，因此它不可能等待输入；因此，事件必须由另一个方法处理。
- en: Another thing we cannot do in `execute` is set the operator’s editable parameters.
    Since Blender runs `execute` again when a parameter is changed, the user would
    find themselves unable to set a property, as it would be overridden immediately.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在`execute`中我们还不能做的事情是设置操作符的可编辑参数。由于Blender在参数更改时再次运行`execute`，用户会发现他们无法设置属性，因为它会被立即覆盖。
- en: Capturing events and initializing operator parameters are two tasks that cannot
    be performed by `execute`. Luckily, `execute` is not the only method involved
    when an operator is launched; we will see that an operator’s lifetime encompasses
    a set of methods, each of them with a specific purpose.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获事件和初始化操作符参数是`execute`无法执行的两个任务。幸运的是，当操作符启动时，涉及的不仅仅是`execute`方法；我们将看到操作符的生命周期包括一系列方法，每个方法都有其特定的目的。
- en: Steps of execution
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行步骤
- en: We know from [*Chapter 3*](B18375_03.xhtml#_idTextAnchor049), that the operator
    `poll` and `execute` methods are required, respectively, for validation and execution.
    In [*Chapter 5*](B18375_05.xhtml#_idTextAnchor100), we used `invoke` to make sure
    that the operator properties are displayed before it runs.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从[*第3章*](B18375_03.xhtml#_idTextAnchor049)中我们知道，操作符的`poll`和`execute`方法分别用于验证和执行。在[*第5章*](B18375_05.xhtml#_idTextAnchor100)中，我们使用了`invoke`来确保操作符属性在运行之前显示。
- en: 'Now, we will take a closer look at how operators are displayed and run:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将更详细地看看操作符是如何显示和运行的：
- en: Blender checks the return value of `poll`. If the result is `False`, the operator
    is grayed out; otherwise, the operator can be launched.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Blender检查`poll`的返回值。如果结果是`False`，则操作符会被灰色显示；否则，操作符可以被启动。
- en: The operator is launched, and it runs the `invoke` method. This method is optional;
    if we don’t write it, its step is skipped, and Blender runs `execute` directly.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作符被启动，并运行`invoke`方法。此方法为可选；如果我们不编写它，其步骤将被跳过，Blender将直接运行`execute`。
- en: One common use of `invoke` is the initialization of the operator’s variables
    or internal value; unlike conventional Python classes, operators don’t implement
    the traditional `__init__` method.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`invoke`的一个常见用途是初始化操作符的变量或内部值；与传统的Python类不同，操作符不实现传统的`__init__`方法。'
- en: Like `execute`, `invoke` must return an exit status, which can be `'FINISHED'`,
    `'CANCELLED'`, or `'RUNNING_MODAL'`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与`execute`一样，`invoke`必须返回一个退出状态，可以是`'FINISHED'`、`'CANCELLED'`或`'RUNNING_MODAL'`。
- en: If our operator is meant to listen for mouse and keyboard events, in `invoke`,
    we add it to the application `'RUNNING_MODAL'`.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们的操作符旨在监听鼠标和键盘事件，在`invoke`中，我们将它添加到应用程序`'RUNNING_MODAL'`。
- en: If the operator is part of the handlers, its `modal` method is executed at every
    trigger event (when a mouse cursor moves, a key is pressed, etc.), until the modal
    returns `'CANCELLED'` or `'FINISHED'`. Otherwise, to continue listening, it should
    return `'RUNNING_MODAL'`.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果操作符是处理程序的一部分，它的`modal`方法会在每次触发事件（当鼠标光标移动、按键按下等）时执行，直到modal返回`'CANCELLED'`或`'FINISHED'`。否则，为了继续监听，它应该返回`'RUNNING_MODAL'`。
- en: If `bl_options` is `{'REGISTER','UNDO'}`, the operator properties are displayed
    in a panel at the bottom left of the screen. The panel relies on the operator’s
    `draw` method.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`bl_options`是`{'REGISTER','UNDO'}`，则操作符属性将在屏幕左下角的面板中显示。该面板依赖于操作符的`draw`方法。
- en: By default, all the operator properties that are not flagged with `hidden` upon
    declaration are displayed in the panel. Reimplementing this method allows us to
    implement a custom design using the techniques learned in [*Chapter 5*](B18375_05.xhtml#_idTextAnchor100).
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，所有在声明时未标记为`hidden`的操作符属性都会在面板中显示。重新实现此方法允许我们使用在[*第5章*](B18375_05.xhtml#_idTextAnchor100)中学到的技术来实现自定义设计。
- en: Changing a value in the operator panel runs `execute` again, with updated properties.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在操作符面板中更改值会再次运行`execute`，并带有更新后的属性。
- en: The execution flow is summed up in *Figure 10**.1*, which helps us understand
    how the methods in the execution flow add up when an operator is launched.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 执行流程总结在*图10**.1*中，这有助于我们理解当操作符启动时，执行流程中的方法是如何累加的。
- en: '![Figure 10.1: The operator methods from the start to the end of the evaluation](img/Figure_10.01_B18375.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1：从评估开始到结束的操作符方法](img/Figure_10.01_B18375.jpg)'
- en: 'Figure 10.1: The operator methods from the start to the end of the evaluation'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：从评估开始到结束的操作符方法
- en: While `poll` is run by the interface every time that the operator is displayed,
    `invoke` is the first step of an operator flow, so we can use it to set the operator’s
    parameters programmatically and, from there, move to `execute` or `modal`. In
    the next section, we will use `invoke` to initialize the operator parameters according
    to the time of the day.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`poll`在每次操作符显示时都会由界面运行，但`invoke`是操作符流程的第一步，因此我们可以用它来以编程方式设置操作符的参数，并从那里移动到`execute`或`modal`。在下一节中，我们将使用`invoke`根据一天中的时间初始化操作符参数。
- en: Writing the “PunchClock” add-on
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写“PunchClock”插件
- en: Some tools can require the current date and time from the operating system clock.
    In Python, we can use the `datetime` module to get them in our scripts, generally
    for versioning or logging purposes. There are no Blender properties designed specifically
    for time units, but an hour and a minute can be stored as two separate integer
    properties of an operator.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一些工具可能需要从操作系统的时钟中获取当前日期和时间。在Python中，我们可以使用`datetime`模块在我们的脚本中获取它们，通常用于版本控制或日志记录目的。Blender没有专门为时间单位设计的属性，但小时和分钟可以存储为操作符的两个单独的整型属性。
- en: We know how to use the `default` argument to declare the initial value of a
    property, but what if that value is not always the same? For example, the current
    hour and minute change during the day, but `default` only sets static values.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道如何使用`default`参数来声明属性的初始值，但如果这个值并不总是相同怎么办？例如，一天中当前的小时和分钟会变化，但`default`只设置静态值。
- en: But since `invoke` is executed before all the other methods, we can set our
    default values programmatically in there.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 但由于`invoke`方法在所有其他方法之前执行，我们可以在其中以编程方式设置默认值。
- en: To demonstrate that, we will create an add-on to create a time format text in
    the current scene. By default, the text displays the current time of the day,
    but the user can change that.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我们将创建一个附加组件来在当前场景中创建时间格式文本。默认情况下，文本显示一天中的当前时间，但用户可以更改它。
- en: Creating the add-on script
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建附加脚本
- en: 'Let’s create the `ch10` folder in our Python project, and then in **Blender
    Preferences**, we set it as the **Scripts** folder and restart Blender:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Python项目中创建`ch10`文件夹，然后在**Blender首选项**中将其设置为**脚本**文件夹，并重新启动Blender：
- en: Select `PythonScriptingBlender/ch10/addons` in your file browser or programmer
    editor – for instance, **VS Code**.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的文件浏览器或程序员编辑器中选择`PythonScriptingBlender/ch10/addons` – 例如，**VS Code**。
- en: Create a new file by clicking on the **New** **File** icon.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**新建**图标创建一个新文件。
- en: Name the new file `punch_clock.py`.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新文件命名为`punch_clock.py`。
- en: Open the file for editing.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件进行编辑。
- en: Set the `PythonScriptingBlender/ch10` in the Blender **File Paths** preferences
    and restart Blender.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Blender的**文件路径**首选项中设置`PythonScriptingBlender/ch10`，并重新启动Blender。
- en: 'We store the add-on information in the `bl_info` dictionary, as usual:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像往常一样在`bl_info`字典中存储附加信息：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This add-on contains an operator, which will be available in the **Add** menu
    of the 3D Viewport.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此附加组件包含一个操作符，它将在3D视图的**添加**菜单中可用。
- en: We start with an operator that creates a text in the *HH:MM* format, like digital
    clocks, where *HH* stands for a 2-digit hour number and *MM* for the minutes.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个创建*HH:MM*格式文本的操作符开始，就像数字时钟一样，其中*HH*代表两位数的小时数，*MM*代表分钟。
- en: 'Hours and minutes are stored as `IntProperty`, ranging between `0` and `23`
    for the hours and `0` and `59` for the minutes. The operator’s code starts as
    follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 小时和分钟存储为`IntProperty`，小时的范围是`0`到`23`，分钟的范围是`0`到`59`。操作符的代码开始如下：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can add a new object if Blender is in `poll` is as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Blender处于`poll`状态，我们可以添加一个新的对象，如下所示：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In `execute`, we create new text data and set it to `{hour}:{min}`. The Blender
    type for text is named `FONT`, and its displayed text is stored in the `body`
    attribute.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在`execute`中，我们创建新的文本数据并将其设置为`{hour}:{min}`。Blender中文本的类型名为`FONT`，其显示的文本存储在`body`属性中。
- en: 'We use `:02` after a variable specifies that we want to display a 2-digit number
    – for instance, `f"{3:02}"` becomes `"03"`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在变量后面使用`:02`表示我们想要显示一个两位数 – 例如，`f"{3:02}"`变为`"03"`：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We create an object to link it to the current collection and see the text in
    the scene:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个对象将其链接到当前集合，并查看场景中的文本：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After that, we return `FINISHED` as execution state:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将执行状态返回为`FINISHED`：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first draft of our operator is ready, and now we create a `menu` function
    to add to the interface. We can use `time` in the search field, we end up with
    three relevant icons – `TIME`, `MOD_TIME`, and `SORTTIME`. Any of those will do;
    we will pick `TIME` in this example.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个操作符草稿已经准备好了，现在我们创建一个`menu`函数来添加到界面中。我们可以在搜索字段中使用`time`，最终得到三个相关的图标 – `TIME`、`MOD_TIME`和`SORTTIME`。任何这些都可以；在这个例子中我们将选择`TIME`。
- en: '![Figure 10.2: The time-related default icons in Icon Viewer](img/Figure_10.02_B18375.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2：图标查看器中的时间相关默认图标](img/Figure_10.02_B18375.jpg)'
- en: 'Figure 10.2: The time-related default icons in Icon Viewer'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：图标查看器中的时间相关默认图标
- en: 'We start `menu_func` with a `separator` to set our operator apart, and then
    we add our entry for `PunchClock` via `Layout.operator`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`menu_func`中使用`separator`开始，以将我们的操作符与其他内容区分开来，然后通过`Layout.operator`添加我们的`PunchClock`条目：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, we add and remove our operator and menu item in the `register` and
    `unregister` functions:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在`register`和`unregister`函数中添加和移除我们的操作符和菜单项：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If we restart Blender or refresh the **Add-ons** list, we should be able to
    see the **PunchClock** add-on.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新启动Blender或刷新**插件**列表，我们应该能够看到**PunchClock**插件。
- en: '![Figure 10.3: PunchClock, as displayed in the Add-ons list](img/Figure_10.03_B18375.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3：在插件列表中显示的PunchClock](img/Figure_10.03_B18375.jpg)'
- en: 'Figure 10.3: PunchClock, as displayed in the Add-ons list'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：在插件列表中显示的PunchClock
- en: At this stage, selecting **Add** | **Create Hour/Minutes Text** in the 3D Viewport
    top menu would add a text object displaying the time *00:00*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，在3D视图顶部的菜单中选择**添加** | **创建小时/分钟文本**会添加一个显示时间*00:00*的文本对象。
- en: We can get the current time from `datetime` and convert it to text, but we can
    do something even better – by setting `self.hour` and `self.mins` inside `invoke`,
    we will achieve the same result but also allow a user to change the displayed
    time.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从`datetime`获取当前时间并将其转换为文本，但我们可以做得更好——通过在`invoke`中设置`self.hour`和`self.mins`，我们将达到相同的结果，同时允许用户更改显示的时间。
- en: Using invoke to initialize properties
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`invoke`初始化属性
- en: 'To get the current time, we import `datetime` at the beginning of the script.
    The `import` section becomes the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取当前时间，我们在脚本开头导入`datetime`。导入部分变为以下内容：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, inside the operator class, we implement the `invoke` method. It can come
    right after `poll`, but any place under the `PunchClock` class will do:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在操作符类内部，我们实现`invoke`方法。它可以直接跟在`poll`之后，但只要在`PunchClock`类下面都可以：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, the hour and minute of the operator are set up in `invoke`, and then `execute`
    is called to carry on the operation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，操作符的小时和分钟在`invoke`中设置，然后调用`execute`以继续操作。
- en: Finishing with `execute` is important, as that’s what Blender expects when updating
    its operations chronology.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`execute`完成操作很重要，因为Blender在更新操作时间顺序时期望这样做。
- en: Launching **Create Hour/Minutes Text** now displays the current time in a new
    text object and allows us to change the hour and minute using the operator panel.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在启动**创建小时/分钟文本**会显示当前时间在一个新的文本对象中，并允许我们使用操作符面板更改小时和分钟。
- en: '![Figure 10.4: Adding editable hour and minute fields, set to the current time](img/Figure_10.04_B18375.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4：添加可编辑的小时和分钟字段，设置为当前时间](img/Figure_10.04_B18375.jpg)'
- en: 'Figure 10.4: Adding editable hour and minute fields, set to the current time'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4：添加可编辑的小时和分钟字段，设置为当前时间
- en: By using `invoke`, we have set our default values programmatically. That’s a
    common request in productions, since the desired defaults can change across projects,
    tasks, and departments.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`invoke`，我们以编程方式设置了默认值。这在生产中是一个常见请求，因为所需的默认值可能会随着项目、任务和部门的不同而变化。
- en: We have added our operator to the `execute` method directly.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们直接将我们的操作符添加到`execute`方法中。
- en: To prevent the menu from skipping `invoke`, we need to override the layout’s
    context in our menu function.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止菜单跳过`invoke`，我们需要在我们的菜单函数中覆盖布局的上下文。
- en: Ensuring default invoke in pop-up menus
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在弹出菜单中确保默认的`invoke`
- en: Layout elements can pass a custom context and force a design choice on operators.
    For example, buttons displayed outside the viewport avoid displaying operator
    properties, and pop-up menus bypass the `invoke` method.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 布局元素可以传递自定义上下文并强制对操作符进行设计选择。例如，显示在视口外的按钮会避免显示操作符属性，弹出菜单会绕过`invoke`方法。
- en: We have encountered this behavior in the *Displaying buttons* section of [*Chapter
    5*](B18375_05.xhtml#_idTextAnchor100), and in the *Writing the Action to Range
    add-on* section in [*Chapter 7*](B18375_07.xhtml#_idTextAnchor171).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第5章*](B18375_05.xhtml#_idTextAnchor100)的*显示按钮*部分和[*第7章*](B18375_07.xhtml#_idTextAnchor171)的*编写Action
    To Range插件*部分遇到了这种行为。
- en: We worked around those issues, respectively, by calling a properties dialog
    in `invoke`, or by using `invoke` to run even when the operator is launched from
    the `invoke`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在`invoke`中调用属性对话框或使用`invoke`来运行操作符，即使操作符是从`invoke`启动的，分别解决了这些问题。
- en: Therefore, we will change the layout’s `operator_context` to `"INVOKE_DEFAULT"`.
    We only need that for `PunchClock`, so, to minimize any potential impact on other
    menu entries, we add a new row and change only its `operator_context`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将布局的`operator_context`更改为`"INVOKE_DEFAULT"`。我们只需要为`PunchClock`这样做，因此，为了最小化对其他菜单项的潜在影响，我们添加了一个新行并仅更改其`operator_context`。
- en: 'Our menu function becomes the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下拉菜单函数变为以下内容：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: By executing `PunchClock` with its default context, we make sure that `invoke`
    is never skipped.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用默认上下文执行`PunchClock`，我们确保`invoke`永远不会被跳过。
- en: Now, the operator will always display its properties and let a user change them,
    but we can also implement a way to change the displayed time by just moving the
    mouse.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，操作员将始终显示其属性并允许用户更改它们，但我们也可以实现一种通过移动鼠标来更改显示时间的方法。
- en: In the next section, we will add operator response to mouse and keyboard input,
    making our operator a modal application handler.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将添加操作员对鼠标和键盘输入的响应，使我们的操作员成为modal应用程序处理程序。
- en: Adding modal behavior
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加modal行为
- en: In user interfaces, the term **modal** designates a sub-window or widget that
    takes all the user interaction for itself, until the operation is ended explicitly.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户界面中，术语**modal**指代一个子窗口或小部件，它为自己获取所有用户交互，直到操作被明确结束。
- en: Usually, operators are designed to return to the main application immediately.
    If we don’t want that, they should be added to the window manager’s modal handlers.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，操作员被设计为立即返回到主应用程序。如果我们不希望这样，它们应该被添加到窗口管理器的modal处理程序中。
- en: The operator is then considered modal and will listen to the user inputs until
    it’s closed manually.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，操作员被视为modal，并将监听用户输入，直到手动关闭。
- en: 'We can make `PunchClock` modal and use mouse movement to set our clock. Modal
    operators have two requirements:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使`PunchClock`成为modal，并使用鼠标移动来设置我们的时钟。modal操作员有两个要求：
- en: '`invoke` adds the operator to the handlers and returns `''RUNNING_MODAL''`.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invoke`将操作员添加到处理程序并返回`''RUNNING_MODAL''`。'
- en: '`modal` is implemented and returns `''RUNNING_MODAL''`. It returns `''FINISHED''`
    when a user ends it, or `''CANCELLED''` to exit with no changes.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modal`已实现并返回`''RUNNING_MODAL''`。当用户结束操作时，它返回`''FINISHED''`，或者返回`''CANCELLED''`以无更改退出。'
- en: We will start to implement the modal execution by changing `invoke` and its
    return value.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过更改`invoke`及其返回值来开始实现modal执行。
- en: Adding the operator to the modal handlers
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将操作员添加到modal处理程序
- en: Instead of passing to `execute`, `invoke` now calls the `modal_handler_add`
    method of the current `window_manager`, and then it returns `{'RUNNING_MODAL'}`.
    The return status notifies that the operator is running in Blender and listens
    to events.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`invoke`不再将参数传递给`execute`，而是调用当前`window_manager`的`modal_handler_add`方法，然后返回`{'RUNNING_MODAL'}`。返回状态通知操作员正在Blender中运行并监听事件。
- en: 'Since `modal` runs at every window update, we should keep it light and small.
    Adding objects to the scene is expensive, so we create and link the text in `invoke`,
    and only edit its body in `modal`. The `invoke` method stores `txt_crv` and `txt_obj`
    as operator member attributes:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`modal`在每次窗口更新时都会运行，我们应该保持它轻量级和小型。向场景添加对象是昂贵的，因此我们在`invoke`中创建和链接文本，并在`modal`中仅编辑其主体。`invoke`方法将`txt_crv`和`txt_obj`作为操作员成员属性存储：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The keywords that can be returned as status are listed in the API documentation
    ([https://docs.blender.org/api/3.3/bpy_types_enum_items/operator_return_items.xhtml](https://docs.blender.org/api/3.3/bpy_types_enum_items/operator_return_items.xhtml))
    and are as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 可以作为状态返回的关键字列在API文档中（[https://docs.blender.org/api/3.3/bpy_types_enum_items/operator_return_items.xhtml](https://docs.blender.org/api/3.3/bpy_types_enum_items/operator_return_items.xhtml)），如下所示：
- en: '`RUNNING_MODAL`: Keeps the operator running with Blender'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUNNING_MODAL`: 保持操作员在Blender中运行'
- en: '`CANCELLED`: The operator exited without doing anything, so no undo entry should
    be pushed'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CANCELLED`: 操作员在没有做任何事情的情况下退出，因此不应推送任何撤销条目'
- en: '`FINISHED`: The operator exited after completing its action'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FINISHED`: 操作员在完成其动作后退出'
- en: '`PASS_THROUGH`: Do nothing and pass the event on'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PASS_THROUGH`: 不做任何事情并将事件传递下去'
- en: '`INTERFACE`: Handled but not executed (pop-up menus)'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INTERFACE`: 已处理但未执行（弹出菜单）'
- en: We have already dealt with `'RUNNING_MODAL'`, `'CANCELLED'`, and `'FINISHED'`,
    while `'PASS_THROUGH'` is useful to pass an event to the rest of an application,
    even if our script was listening to it. `'INTERFACE'` is used in pop-up menus,
    but usually, we don’t need that for our scripts.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经处理了`'RUNNING_MODAL'`、`'CANCELLED'`和`'FINISHED'`，而`'PASS_THROUGH'`对于将事件传递到应用程序的其余部分非常有用，即使我们的脚本正在监听它。`'INTERFACE'`用于弹出菜单，但通常我们不需要在我们的脚本中使用它。
- en: Status is not everything!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 状态并非一切！
- en: It’s important to know that returning a status ratifies what was done in a method,
    but it doesn’t perform anything.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，返回状态确认了方法中完成的工作，但它本身并不执行任何操作。
- en: For instance, returning `'CANCELLED'` alone doesn’t undo what was done in a
    method; we should undo all the changes programmatically – for example, remove
    the objects that our method might have created, and then return `'CANCELLED'`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，仅返回`'CANCELLED'`并不能撤销方法中执行的操作；我们应该通过编程方式撤销所有更改——例如，删除方法可能创建的对象，然后返回`'CANCELLED'`。
- en: Now that the application handler will look for a `modal` method and run it,
    we can proceed with writing one for our operator.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序处理程序将查找`modal`方法并运行它，我们可以继续为我们的操作员编写一个。
- en: Writing the modal method
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写`modal`方法
- en: Once an operator is added to the handlers, the window manager will run its `modal`
    method at every event of the user interface. As with `invoke`, besides `self`
    and `context`, this method takes a third argument – `event`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将操作员添加到处理程序中，窗口管理器将在用户界面的每个事件上运行其`modal`方法。与`invoke`一样，除了`self`和`context`之外，此方法还接受第三个参数——`event`。
- en: The `event` argument contains information about what triggered any execution
    of `modal`. It can be a movement of a mouse or the press of a key.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`event`参数包含有关触发任何`modal`执行的触发器的信息。它可以是鼠标移动或按键。'
- en: The most relevant information is `type`, a string whose keywords are documented
    at [https://docs.blender.org/api/3.3/bpy_types_enum_items/event_type_items.xhtml](https://docs.blender.org/api/3.3/bpy_types_enum_items/event_type_items.xhtml).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最相关的信息是`type`，这是一个字符串，其关键字在[https://docs.blender.org/api/3.3/bpy_types_enum_items/event_type_items.xhtml](https://docs.blender.org/api/3.3/bpy_types_enum_items/event_type_items.xhtml)上有文档说明。
- en: 'Looking at `event.type`, we can find out what triggered the update, such as
    the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`event.type`，我们可以找出触发更新的原因，如下所示：
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This means that the user did just move the mouse.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着用户刚刚移动了鼠标。
- en: If the event was caused by the keyboard, `event.type` would be a letter, such
    as `"A"`, or a description of the key, such as `"LEFT_CTRL"`. The event type associated
    with numeric keys is the uppercase letters for that number – for example, `"THREE"`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事件是由键盘引起的，`event.type`将是一个字母，例如`"A"`，或者是对键的描述，例如`"LEFT_CTRL"`。与数字键相关的事件类型是该数字的大写字母——例如，`"THREE"`。
- en: In this example, moving the mouse toward the right increases the current time,
    and moving it to the left decreases it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，将鼠标向右移动会增加当前时间，而向左移动则会减少它。
- en: 'Like with real clocks, we can set either the hours or minutes – we add a Boolean
    property to distinguish between the two. The properties section becomes the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 就像真实的时钟一样，我们可以设置小时或分钟——我们添加一个布尔属性来区分两者。属性部分变为以下内容：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, we can finally write `PunchClock.modal`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们终于可以编写`PunchClock.modal`了。
- en: Moving the mouse updates the attributes associated with the cursor. For instance,
    the cursor position on the horizontal axis is stored as `mouse_x`, while the previous
    position is still available as `mouse_prev_x.` The difference between the two
    gives the movement direction.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 移动鼠标更新与光标相关的属性。例如，水平轴上的光标位置存储为`mouse_x`，而之前的位置仍然可用，作为`mouse_prev_x`。两者的差值给出了移动方向。
- en: 'We store that number as `delta` and divide it to slow the transition. A factor
    of 10 makes it slow enough for our purpose:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将那个数字存储为`delta`，然后除以它来减缓转换。10倍因子足以达到我们的目的：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`delta` is a float number, and as such, it cannot be summed with hour and mins,
    which are integers. For that reason, we round it to an integer value:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`delta`是一个浮点数，因此它不能与小时和分钟（整数）相加。因此，我们将它四舍五入到整数值：'
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We use `round` rather than `int` for this conversion. Since `int` approximates
    to the least or equal integer value, it would make the progress from one value
    to the next less smooth.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`round`而不是`int`进行此转换。因为`int`近似于最接近或等于的整数值，这会使从一个值到下一个值的进度不够平滑。
- en: 'The value of `set_hours` decides whether `delta` is added to the hours or the
    minutes:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_hours`的值决定了`delta`是添加到小时还是分钟：'
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To change `set_hours`, we resort to a key press. We make the user switch between
    hours and minutes by pressing the *Tab* key.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改`set_hours`，我们求助于按键。我们通过按*Tab*键让用户在小时和分钟之间切换。
- en: 'To get that key press, we ensure that `event.type` is `''TAB''` and `event.value`
    is `''PRESS''`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取那个按键，我们确保`event.type`是`'TAB'`且`event.value`是`'PRESS'`：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Boolean variables can only be `True` or `False`, which are each other’s negation.
    So, we have converted `set_hours` to its opposite by just using `not`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔变量只能是`True`或`False`，它们是对方的否定。因此，我们通过仅使用`not`将`set_hours`转换为它的对立面。
- en: Type is not enough!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 类型不足以！
- en: A key that is pressed will also be released, and this action will generate another
    event, whose value is `'RELEASE'`. Checking only `event.type` without checking
    `event.value` puts our code at the risk of responding to keystrokes twice.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 按下的键也会释放，这个动作将生成另一个事件，其值为`'RELEASE'`。仅检查`event.type`而不检查`event.value`会使我们的代码面临响应按键两次的风险。
- en: 'Lastly, when a user is happy with the displayed time, they can press *Return*
    and exit. Pressing *Return* triggers an event of type `''RET''`. We don’t need
    to bother with `event.value` for exit events. Once we return `{''FINISHED''}`,
    the operator stops, so there are no risks of duplicate execution:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当用户对显示的时间满意时，他们可以按下*Return*键并退出。按下*Return*键会触发类型为`'RET'`的事件。我们不需要担心退出事件中的`event.value`。一旦我们返回`{'FINISHED'}`，操作员就会停止，因此没有重复执行的风险：
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: However, what if the user has second thoughts and wants to exit the tool without
    doing anything? We can allow the operation to be aborted at the press of `'ESC'`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果用户犹豫不决并想在不做任何事情的情况下退出工具？我们可以允许在按下`'ESC'`时取消操作。
- en: 'To do that, the operator must clean after itself by deleting the text created
    in `invoke`, and then return `{''CANCELLED''}` to avoid being added to the undo
    queue:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，操作员必须在`invoke`中删除创建的文本后自行清理，然后返回`{'CANCELLED'}`以避免被添加到撤销队列：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: That was the last event covered by our operator. We ignore any other event and,
    by default, return `{'RUNNING_MODAL'}` as status to keep listening.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 那是我们操作员覆盖的最后一个事件。我们忽略任何其他事件，并默认返回`{'RUNNING_MODAL'}`作为状态以继续监听。
- en: 'So, the last line of `modal` is usually as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`modal`的最后一条通常是以下内容：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Calling **Reload Scripts**, and then **Add** | **Create Hour/Minutes Text**,
    creates a text of the current hour and starts listening to mouse/keyboard events.
    Moving the mouse left and right increases/decreases the current value, pressing
    *Tab* switches between hours and minutes, and pressing *Return* or *Esc* ends
    the operator.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 调用**重新加载脚本**，然后**添加** | **创建小时/分钟文本**，将创建当前小时的文本并开始监听鼠标/键盘事件。左右移动鼠标会增加/减少当前值，按下*Tab*键在小时和分钟之间切换，按下*Return*或*Esc*键结束操作员。
- en: Since all the action now takes place between `invoke` and `modal`, we could
    remove `execute`, but since `bl_options` is set to `{'REGISTER', 'UNDO'}`, Blender
    displays the operator properties. When a property is changed, the `execute` method
    is run.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有动作现在都在`invoke`和`modal`之间进行，我们可以删除`execute`，但由于`bl_options`设置为`{'REGISTER',
    'UNDO'}`，Blender会显示操作员属性。当属性更改时，会运行`execute`方法。
- en: We can see that after *Return* is pressed, **hour**, **min**, and **set_hours**
    can be changed in the operator panel.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，按下*返回*键后，**小时**、**分钟**和**设置小时**可以在操作面板中更改。
- en: '![Figure 10.5: Operator properties after modal has exited](img/Figure_10.05_B18375.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5：模态退出后的操作员属性](img/Figure_10.05_B18375.jpg)'
- en: 'Figure 10.5: Operator properties after modal has exited'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5：模态退出后的操作员属性
- en: That panel can be customized – operators have a `draw` method that works in
    the same way as `Panel.draw`, which we learned about in [*Chapter 5*](B18375_05.xhtml#_idTextAnchor100).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 那个面板可以自定义 - 操作员有一个`draw`方法，它的工作方式与我们在[*第五章*](B18375_05.xhtml#_idTextAnchor100)中了解到的`Panel.draw`相同。
- en: So, rather than displaying hours and minutes in a column, we could show them
    in a time format in the operator panel. In the next section, we will implement
    the `draw` method and change the **Create Hour/Minutes** **Text** panel.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以在操作面板中以时间格式显示小时和分钟，而不是按列显示。在下一节中，我们将实现`draw`方法并更改**创建小时/分钟** **文本**面板。
- en: Styling the operator panel
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作面板的样式
- en: 'We know that the operator panel is displayed in these circumstances:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道在这些情况下操作面板会显示：
- en: When `context.window_manager.invoke_props_dialog` is called explicitly.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当显式调用`context.window_manager.invoke_props_dialog`时。
- en: When `bl_options` is set to `{'REGISTER', 'UNDO'}` and the operator has finished.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`bl_options`设置为`{'REGISTER', 'UNDO'}`并且操作员已完成时。
- en: When `bl_options = {'``REGISTER', 'UNDO'}`.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`bl_options = {'``REGISTER', 'UNDO'}`。
- en: By default, all properties are displayed in a column layout. Most property types
    can be declared with a `hidden=True` flag, but that’s not the case for `BoolProperty`,
    so we cannot do it with `set_hours`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有属性都按列布局显示。大多数属性类型可以用`hidden=True`标志声明，但`BoolProperty`不是这种情况，所以我们不能在`set_hours`中这样做。
- en: As a workaround, we could change `set_hours` to `IntProperty`, with a `0` to
    `1` range and `hidden` set to `True`, but by implementing the `draw` method for
    our operator, we can just omit the properties that we don’t want to display.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种解决方案，我们可以将`set_hours`改为`IntProperty`，范围是`0`到`1`，并将`hidden`设置为`True`，但通过为我们的操作符实现`draw`方法，我们可以简单地省略我们不想显示的属性。
- en: Writing the draw method
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写绘制方法
- en: 'We want to change two things in the **Create Hour/Minutes** **Text** panel:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在**创建小时/分钟****文本**面板中更改两件事：
- en: The hour and minutes should be in the same row
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小时和分钟应在同一行
- en: The `set_hours` internal variable should not be displayed
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_hours`内部变量不应显示'
- en: 'Adding a `draw` method to an operator changes its layout. The method arguments
    are `self` and `context`, but we will only use the first. To display our properties
    on the same line, we will do the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 向操作符添加`draw`方法会改变其布局。方法参数是`self`和`context`，但我们只会使用第一个。为了在同一行显示我们的属性，我们将执行以下操作：
- en: Create a row to display hours and minutes.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一行来显示小时和分钟。
- en: Enable `align` for the new `row`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为新的`row`启用`align`。
- en: 'Set the alignment to `''CENTER''`:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对齐设置为`'CENTER'`：
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Use `row.prop` to display `self.hour`, `row.label` to display a semicolon,
    and `row.prop` again to display `self.mins`:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`row.prop`显示`self.hour`，使用`row.label`显示分号，然后再次使用`row.prop`显示`self.mins`：
- en: '[PRE22]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We have set the text of `hour` and `mins` to `""` because no explanation is
    required. As intended, no checkbox is displayed for `set_hours`, since it’s not
    mentioned in `draw`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`hour`和`mins`的文本设置为`""`，因为没有必要进行解释。正如预期的那样，没有显示`set_hours`的复选框，因为它在`draw`中没有提到。
- en: '![Figure 10.6: The custom hour/minutes operator panel](img/Figure_10.06_B18375.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6：自定义小时/分钟操作面板](img/Figure_10.06_B18375.jpg)'
- en: 'Figure 10.6: The custom hour/minutes operator panel'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6：自定义小时/分钟操作面板
- en: We could add more features, such as numeric input to set the hours, but since
    we have implemented all the operator methods, we can consider **PunchClock** finished.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加更多功能，例如数字输入来设置小时，但由于我们已经实现了所有操作符方法，我们可以认为**PunchClock**完成了。
- en: Although we will discuss other operators in the rest of the book, this is the
    last chapter that covers them specifically, as we have learned how to customize
    every step of their execution.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们将在本书的其余部分讨论其他操作符，但这将是专门介绍它们的最后一章，因为我们已经学会了如何自定义它们执行的每一步。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have gained a deep understanding of how operators are integrated in different
    parts of Blender and how we can manipulate their appearance and behavior. We have
    also learned how they can capture input and how they interact with the application
    event handler and interface.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经深入了解了操作符如何在Blender的不同部分中集成，以及我们如何操纵它们的外观和行为。我们还学习了它们如何捕获输入以及它们如何与应用程序事件处理程序和界面交互。
- en: This chapter marks the end of the second part of this book. The next chapter,
    *Object Modifiers*, is the start of *Part 3*, which deals with how the data of
    a scene is processed into the finished output.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 本章标志着本书第二部分的结束。下一章，*对象修饰符*，是*第三部分*的开始，该部分讨论了场景数据如何被处理成最终输出。
- en: Questions
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which operator method runs before the operator is launched?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个操作符方法在操作符启动之前运行？
- en: Can a user launch an operator if its `poll` method returns `False`?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果操作符的`poll`方法返回`False`，用户能否启动操作符？
- en: Can we set a default value on our operator parameters in a function?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们能否在函数中为操作符参数设置默认值？
- en: The `modal` method can only return the `'RUNNING_MODAL'` status – true or false?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`modal`方法只能返回`''RUNNING_MODAL''`状态——是或否？'
- en: Does returning `'CANCELLED'` undo everything we did in a method?
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回`'CANCELLED'`是否会撤销我们在方法中做的所有操作？
- en: Can we override the operator context of a menu or a panel layout?
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们能否在函数中为操作符参数设置默认值？
- en: Can we change the layout of an operator panel?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们能否改变操作面板的布局？
- en: 'Part 3: Delivering Output'
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：输出交付
- en: 'This part is centered on the final stages of the 3D pipeline: generating and
    deforming geometries and setting up the rendering and shading system. Automation
    of simple rigs and the construction of shader node trees are explored.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分主要关注3D管道的最终阶段：生成和变形几何形状以及设置渲染和着色系统。探索简单机架的自动化和着色器节点树的构建。
- en: 'This section comprises the following chapters:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包括以下章节：
- en: '[*Chapter 11*](B18375_11.xhtml#_idTextAnchor265), *Object Modifiers*'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B18375_11.xhtml#_idTextAnchor265)，*对象修饰符*'
- en: '[*Chapter 12*](B18375_12.xhtml#_idTextAnchor304), *Rendering and Shaders*'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B18375_12.xhtml#_idTextAnchor304)，*渲染和着色器*'
