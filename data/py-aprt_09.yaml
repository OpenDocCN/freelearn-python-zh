- en: Chapter 4 – Built-in types and the object model
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4章 - 内置类型和对象模型
- en: One of the most fundamental design elements of the Python language is its use
    of *objects*. Objects are the central data structure not only of user-level constructs
    but also many of the inner workings of the language itself. In this chapter we’ll
    start to to develop a sense of what this means, both in principle and in practice,
    and hopefully you’ll start to appreciate just how pervasive objects are throughout
    Python.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python语言最基本的设计元素之一是其对*对象*的使用。对象不仅是用户级构造的中心数据结构，也是语言本身许多内部工作的中心数据结构。在本章中，我们将开始发展对这一概念的理解，无论是在原则上还是在实践中，希望您开始意识到对象在整个Python中是多么普遍。
- en: We’ll take a look at what objects are, how you use them, and how you manage
    references to them. We’ll also start to explore the notion of *types* in Python,
    and we’ll see how Python’s types are both similar to and different from those
    in many other popular languages. As part this exploration we’ll take a more in-depth
    look at some collection types we’ve met already, and introduce a few more collection
    types as well.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看看对象是什么，如何使用它们以及如何管理对它们的引用。我们还将开始探索Python中*类型*的概念，并且我们将看到Python的类型既类似于许多其他流行语言中的类型，又有所不同。作为这一探索的一部分，我们将更深入地了解一些我们已经遇到的集合类型，并介绍一些其他集合类型。
- en: The nature of Python object references
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python对象引用的性质
- en: 'In previous chapters we’ve already talked about and used “variables” in Python,
    but what exactly is a variable? Consider something as straightforward as assigning
    an integer to a variable:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们已经讨论并在Python中使用了“变量”，但变量到底是什么？考虑将整数分配给变量这样简单的事情：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What’s really happening when we do this? First, Python creates an `int` *object*
    with a value of `1000`. This object is anonymous in the sense that it doesn’t,
    in and of itself, have a name (`x` or otherwise). It’s an object allocated and
    tracked by the Python runtime system.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时，实际上发生了什么？首先，Python创建了一个值为`1000`的`int` *对象*。这个对象在本质上是匿名的，因为它本身没有名称（`x`或其他）。它是由Python运行时系统分配和跟踪的对象。
- en: 'After creating the object, Python then creates an *object reference* with the
    name `x` and arranges for `x` ^([6](chap21.xhtml#fn-reference-names)) to refer
    to the `int(1000)` object:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 创建对象后，Python创建了一个名为`x`的*对象引用*，并安排`x` ^([6](chap21.xhtml#fn-reference-names))指向`int(1000)`对象：
- en: '![Assign the name ''x'' to an integer object with the value 1000](images/m04----x_equals_1000.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![将名称''x''分配给一个值为1000的整数对象](images/m04----x_equals_1000.png)'
- en: Assign the name ‘x’ to an integer object with the value 1000
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 将名称‘x’分配给一个值为1000的整数对象
- en: Reassigning a reference
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 重新分配引用
- en: 'Now we’ll modify the value of `x` with another assignment:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用另一个赋值来修改`x`的值：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This does **not** result any sort of change to the `int(1000)` object we previously
    constructed. Integer objects in Python are immutable and cannot be changed. In
    fact, what happens here is that Python first creates a new immutable integer object
    with the value 500 and then redirects the `x` reference to point at the new object:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这**不会**导致我们之前构造的`int(1000)`对象的任何更改。Python中的整数对象是不可变的，不能被更改。实际上，这里发生的是Python首先创建一个新的不可变整数对象，其值为500，然后将`x`引用重定向到新对象：
- en: '![Reassign the name ''x'' to a new integer object with the value 500](images/m04----x_equals_500.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![将名称''x''重新分配给一个值为500的新整数对象](images/m04----x_equals_500.png)'
- en: Reassign the name ‘x’ to a new integer object with the value 500
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 重新将名称‘x’分配给一个值为500的新整数对象
- en: Since we have no other references to the original `int(1000)` object, we now
    have no way of reaching it from our code. As a result, the Python garbage collector
    is free to collect it when and if it chooses. ^([7](chap21.xhtml#fn-garbage-collection))
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有对原始`int(1000)`对象的其他引用，我们现在无法从我们的代码中访问它。因此，Python垃圾收集器可以在选择时收集它。^([7](chap21.xhtml#fn-garbage-collection))
- en: Assigning one reference to another
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 分配一个引用给另一个引用
- en: 'When we assign from one variable to another, what we’re really doing is assigning
    from one object reference to another object reference, so that both references
    then refer to the same object. For example, let’s assign our existing variable
    `x` to a new variable `y`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从一个变量分配到另一个变量时，我们实际上是从一个对象引用分配到另一个对象引用，这样两个引用就指向同一个对象。例如，让我们将现有变量`x`分配给一个新变量`y`：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'That gives us this resulting reference-object diagram:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们了这个引用对象图：
- en: '![Assign the existing name ''x'' to the name ''y''](images/m04----y_equals_x.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![将现有名称''x''分配给名称''y''](images/m04----y_equals_x.png)'
- en: Assign the existing name ‘x’ to the name ‘y’
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将现有名称“x”分配给名称“y”
- en: 'Now both references refer to the same object. We now reassign `x` to another
    new integer:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在两个引用都指向同一个对象。我们现在将`x`重新分配给另一个新的整数：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Doing this gives us a reference-object diagram showing our two references and
    our two objects:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做会给我们一个引用对象图，显示我们的两个引用和两个对象：
- en: '![Assign a new integer 3000 to ''x''](images/m04----x_equals_3000.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![将一个新的整数3000分配给''x''](images/m04----x_equals_3000.png)'
- en: Assign a new integer 3000 to ‘x’
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个新的整数3000分配给‘x’
- en: In this case there is no work for the garbage collector to do because all of
    the objects are reachable from live references.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，垃圾收集器没有工作要做，因为所有对象都可以从活动引用中访问。
- en: Exploring value vs. identity with `id()`
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用`id()`探索值与标识的差异
- en: 'Let’s dig a little deeper into the relationship between objects and references
    using the built-in `id()` function. `id()` accepts any object as an argument and
    returns an integer identifier which is unique and constant for the lifetime of
    the object. Let’s re-run the previous experiment using `id()`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用内置的`id()`函数深入探讨对象和引用之间的关系。`id()`接受任何对象作为参数，并返回一个整数标识符，该标识符对于对象的整个生命周期是唯一且恒定的。让我们使用`id()`重新运行先前的实验：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here we see that initially `a` and `b` refer to different objects and, thus,
    `id()` gives us different values for each variable. However, when we then assign
    `a` to `b`, both names refer to the same object so `id()` gives the same value
    for both. The main lesson here is that `id()` can be used to establish the *identity*
    of an object independent of any particular reference to it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到最初 `a` 和 `b` 指向不同的对象，因此 `id()` 为每个变量给出了不同的值。然而，当我们将 `a` 分配给 `b` 时，两个名称都指向同一个对象，因此
    `id()` 为两者给出了相同的值。这里的主要教训是，`id()` 可以用来确定对象的 *身份*，而不依赖于对它的任何特定引用。
- en: Testing for equality of identity with `is`
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 `is` 测试身份相等
- en: 'In reality, the `id()` function is seldom used in production Python code. Its
    main use is in object model tutorials (such as this one!) and as a debugging tool.
    Much more commonly used than the `id()` function is the `is` operator which tests
    for equality of identity. That is, `is` tests whether two references refer to
    the same object:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在生产 Python 代码中很少使用 `id()` 函数。它的主要用途是在对象模型教程（比如这个！）和作为调试工具中。比 `id()` 函数更常用的是测试身份相等的
    `is` 运算符。也就是说，`is` 测试两个引用是否指向同一个对象：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We’ve already met the `is` operator earlier, in Chapter 1, when we tested for
    `None`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第一章已经遇到了 `is` 运算符，当时我们测试了 `None`：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It’s critical to remember that `is` is always testing *identity equality*, that
    is, whether two references refer to the exact same object. We’ll look in-depth
    at the other primary type of equality, *value equality*, in just a bit.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，`is` 总是测试 *身份相等*，也就是说，两个引用是否指向完全相同的对象。我们将深入研究另一种主要类型的相等，*值相等*，稍后会详细介绍。
- en: Mutating without mutating
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在不进行变异的情况下进行变异
- en: 'Even operations which seem naturally mutating in nature are not necessarily
    so. Consider the augmented assignment operator:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 即使看起来自然会进行变异的操作也不一定如此。考虑增强赋值运算符：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: At first glance, it appears that we’re asking Python to increment the integer
    value `t` by two. But the `id()` results here clearly show that `t` refers to
    two different objects before and after the augmented assignment.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，似乎我们要求 Python 将整数值 `t` 增加两个。但这里的 `id()` 结果清楚地显示，在增强赋值之前和之后，`t` 指向两个不同的对象。
- en: 'Rather than modifying integer objects, here’s a depiction of what’s actually
    happening. Initially, we have the name `t` referring to an `int(5)` object:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是修改整数对象，这里展示的实际发生的情况。最初，我们有名称 `t` 指向一个 `int(5)` 对象：
- en: '![''x'' refers to the integer 5](images/m04----t_plus_eq_2_01.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![''x'' 指向整数 5](images/m04----t_plus_eq_2_01.png)'
- en: ‘x’ refers to the integer 5
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ‘x’ 指向整数 5
- en: 'Next, to perform the augmented assignment of `2` to `t`, Python create an `int(2)`
    object behind the scenes. Note that we never have a named reference to this object;
    it’s managed completely by Python on our behalf:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了执行将 `2` 增强赋值给 `t`，Python 在幕后创建了一个 `int(2)` 对象。请注意，我们从未对此对象进行命名引用；它完全由
    Python 代表我们管理：
- en: '![Python creates an integer 2 behind the scenes](images/m04----t_plus_eq_2_02.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![Python 在幕后创建一个整数 2](images/m04----t_plus_eq_2_02.png)'
- en: Python creates an integer 2 behind the scenes
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Python 在幕后创建一个整数 2
- en: 'Python then performs the addition operation between `t` and the anonymous `int(2)`
    giving us — you guessed it! — another integer object, this time an `int(7)`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，Python 在 `t` 和匿名 `int(2)` 之间执行加法运算，得到 —— 你猜对了！ —— 另一个整数对象，这次是 `int(7)`：
- en: '![Python creates a new integer as the result of the addition](images/m04----t_plus_eq_2_03.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![Python 创建一个新的整数作为加法的结果](images/m04----t_plus_eq_2_03.png)'
- en: Python creates a new integer as the result of the addition
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Python 创建一个新的整数作为加法的结果
- en: 'Finally, Python’s augmented assignment operator reassigns the name `t` to the
    new `int(7)` object, leaving the other integer objects to be handled by the garbage
    collector:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Python 的增强赋值运算符将名称 `t` 重新分配给新的 `int(7)` 对象，使其他整数对象由垃圾收集器处理：
- en: '![Python reassigned the name ''t'' to the result of the addition](images/m04----t_plus_eq_2_04.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![Python 重新分配了名称 ''t'' 给加法的结果](images/m04----t_plus_eq_2_04.png)'
- en: Python reassigned the name ‘t’ to the result of the addition
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Python 重新分配了名称 ‘t’ 给加法的结果
- en: References to mutable objects
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 对可变对象的引用
- en: 'Python objects show this name-binding behavior for all types. *The assignment
    operator only ever binds object to names, it never copies an object by value*.
    To help make this point crystal clear, let’s look at another example using mutable
    objects: lists. Unlike the immutable `int`s that we just looked at, `list` objects
    have mutable state, meaning that the value of a `list` object can change over
    time.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Python 对所有类型都显示这种名称绑定行为。*赋值运算符只会将对象绑定到名称，它永远不会通过值复制对象*。为了更清楚地说明这一点，让我们看另一个使用可变对象的例子：列表。与我们刚刚看到的不可变的
    `int` 不同，`list` 对象具有可变状态，这意味着 `list` 对象的值可以随时间改变。
- en: 'To illustrate this, we first create an list object with three elements, binding
    the list object to a reference named `r`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，我们首先创建一个具有三个元素的列表对象，并将列表对象绑定到名为 `r` 的引用：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We then assign the reference `r` to a new reference `s`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将引用 `r` 分配给一个新的引用 `s`：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The reference-object diagram for this situation makes it clear that we have
    two names referring to a single `list` instance:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况的引用对象图表清楚地表明我们有两个名称指向单个 `list` 实例：
- en: '![''s'' and ''r'' refer to the same list object](images/m04----s_r_list.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![''s'' 和 ''r'' 指向同一个列表对象](images/m04----s_r_list.png)'
- en: ’s’ and ‘r’ refer to the same list object
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ‘s’ 和 ‘r’ 指向同一个列表对象
- en: 'When we modify the list referred to by `s` by changing the middle element,
    we see that the list referred to by `r` has changed as well:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过更改由 `s` 引用的列表来修改列表时，我们看到由 `r` 引用的列表也发生了变化：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Again, this is because the names `s` and `r` refer to the same *mutable* object
    ^([8](chap21.xhtml#fn-copying-lists)), a fact that we can verify by using the
    `is` keyword which we learned about earlier:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这是因为名称 `s` 和 `r` 指向相同的 *可变* 对象 ^([8](chap21.xhtml#fn-copying-lists))，我们可以通过使用之前学到的
    `is` 关键字来验证这一事实：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The main point of this discussion is that Python doesn’t really have variables
    in the metaphorical sense of a box holding a value. It only has named references
    to objects, and these references behave more like labels which allow us to retrieve
    objects. That said, it’s still common to talk about variables in Python because
    it’s convenient. We will continue to do so throughout this book, secure in the
    knowledge that you now understand what’s *really* going on behind the scenes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这次讨论的主要观点是，Python实际上并没有变量的隐喻意义上的值。它只有对对象的命名引用，这些引用的行为更像是标签，允许我们检索对象。也就是说，在Python中谈论变量仍然很常见，因为这很方便。我们将在本书中继续这样做，确信您现在了解了幕后发生了什么。
- en: Equality of value (equivalence) versus equality of identity
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 值的相等性（等同性）与身份的相等性
- en: 'Let’s contrast that behavior with a test for value-equality, or equivalence.
    We’ll create two identical lists:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将该行为与值相等性或等同性的测试进行对比。我们将创建两个相同的列表：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here we see that `p` and `q` refer to different objects, but that the objects
    they refer to have the same value.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到`p`和`q`指的是不同的对象，但它们指的对象具有相同的值。
- en: '![''p'' and ''q'' different list objects with identical values](images/m04----p_q_lists.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: ！['p'和'q'不同的列表对象，具有相同的值](images/m04----p_q_lists.png)
- en: ‘p’ and ‘q’ different list objects with identical values
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '''p''和''q''不同的列表对象，具有相同的值'
- en: 'As you would expect when testing for value-equality, an object should always
    be equivalent to itself ^([9](chap21.xhtml#fn-non-identical-objects)):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您期望的那样，在测试值相等性时，对象应始终等同于自身^([9](chap21.xhtml#fn-non-identical-objects))：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Value-equality and identity are fundamentally different notions of “equality”,
    and it’s important to keep them separate in your mind.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 值相等性和身份是“相等”的基本不同概念，重要的是要在脑海中将它们分开。
- en: It’s also worth noting that value comparison is something that is defined programatically.
    When you define types, you can control how that class determines value-equality.
    In contrast, identity comparison is defined by the language and you can’t change
    that behavior.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 值比较也值得一提，它是以编程方式定义的。当您定义类型时，您可以控制该类如何确定值的相等性。相反，身份比较是由语言定义的，您无法更改该行为。
- en: Argument passing semantics – pass by object-reference
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数传递语义 - 按对象引用传递
- en: Now let’s look at how all this relates to function arguments and return values.
    When we call a function, we literally create new name bindings — those declared
    in the function definition — to existing objects — those passed in at the call
    itself. ^([10](chap21.xhtml#fn-parameters-vs-arguments)) As such, it’s important
    to really understand Python reference semantics if you want to know how your functions
    work.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看所有这些与函数参数和返回值的关系。当我们调用函数时，我们实际上创建了新的名称绑定 - 那些在函数定义中声明的名称绑定 - 到现有对象 -
    那些在调用时传递的对象。^([10](chap21.xhtml#fn-parameters-vs-arguments)) 因此，如果您想知道您的函数如何工作，真正理解Python引用语义是很重要的。
- en: Modifying external objects in a function
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在函数中修改外部对象
- en: 'To demonstrate Python’s argument passing semantics, we’ll define a function
    at the REPL which appends a value to a list and prints the modified list. First
    we’ll create a `list` and give it the name `m`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示Python的参数传递语义，我们将在REPL中定义一个函数，该函数将一个值附加到列表并打印修改后的列表。首先我们将创建一个`list`并将其命名为`m`：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then we’ll define a function `modify()` which appends to, and prints, the list
    passed to it. The function accepts a single formal argument named `k`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将定义一个名为`modify()`的函数，该函数将附加到传递给它的列表并打印该列表。该函数接受一个名为`k`的单个形式参数：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We then call `modify()`, passing our list `m` as the actual argument:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用`modify()`，将我们的列表`m`作为实际参数传递：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This indeed prints the modified list with four elements. But what does our list
    reference `m` outside the function now refer to?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实打印了具有四个元素的修改后的列表。但是我们在函数外部的列表引用`m`现在指向什么？
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The list referred to by `m` has been modified because it is the self-same list
    referred to by `k` inside the function. As we mentioned at the beginning of the
    section, when we pass an object-reference to a function we’re essentially assigning
    from the actual argument reference, in this case `m`, to the formal argument reference,
    in this case `k`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由`m`引用的列表已被修改，因为它是函数内部由`k`引用的同一列表。正如我们在本节开头提到的，当我们将对象引用传递给函数时，我们实质上是将实际参数引用（在本例中为`m`）分配给形式参数引用（在本例中为`k`）。
- en: '![Referring to the same list in and out of a function](images/m04----list_argument.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: ！[在函数内外引用同一列表](images/m04----list_argument.png)
- en: Referring to the same list in and out of a function
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内外引用同一列表
- en: As we have seen, assignment causes the assigned-to reference to refer to the
    same object as the assigned-from reference. This is exactly what’s going on here.
    If you want a function to modify a copy of an object, it’s the responsibility
    of the function to do the copying.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，赋值会导致被赋值的引用指向与被赋值的引用相同的对象。这正是这里正在发生的事情。如果您希望函数修改对象的副本，那么函数有责任进行复制。
- en: Binding new objects in a function
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在函数中绑定新对象
- en: 'Let’s look at another instructive example. First, we’ll create a new list `f`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个有教育意义的例子。首先，我们将创建一个新列表`f`：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then we’ll create new a function `replace()`. As the name suggests, rather
    than modifying its arguments `replace()` will change the object that its parameter
    refers to:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将创建一个名为`replace()`的新函数。顾名思义，`replace()`不会修改其参数，而是会更改其参数所引用的对象：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We now call `replace()` with actual argument `f`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在使用实际参数`f`调用`replace()`：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is much as we’d expect. But what’s the value of the external reference
    `f` now?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们所期望的。但是外部引用`f`现在的值是多少？
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`f` still refers to the original, unmodified list. This time, the function
    did not modify the object that was passed in. What’s going on?'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`f`仍然指向原始的未修改列表。这一次，函数没有修改传入的对象。发生了什么？'
- en: 'The answer is this: the object reference `f` was assigned to the formal argument
    named `g`, so `g` and `f` did indeed refer to the same object, just as in the
    previous example.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是：对象引用`f`被分配给了形式参数`g`，所以`g`和`f`确实引用了同一个对象，就像前面的例子一样。
- en: '![Initially ''f'' and ''g'' refer to the same list object](images/m04----f_g_list_01.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![最初''f''和''g''引用相同的列表对象](images/m04----f_g_list_01.png)'
- en: Initially ‘f’ and ‘g’ refer to the same list object
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最初'f'和'g'引用相同的列表对象
- en: However, on the first line the of the function we re-assigned the reference
    `g` to point to a newly constructed list `[17, 28, 45]`, so within the function
    the reference to the original `[14, 23, 37]` list was overwritten, although the
    unmodified object itself was still pointed to by the `f` reference outside the
    function.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在函数的第一行，我们重新分配了引用`g`，指向一个新构造的列表`[17, 28, 45]`，所以在函数内部，对原始`[14, 23, 37]`列表的引用被覆盖了，尽管未修改的对象本身仍然被`f`引用在函数外部。
- en: '![After reassignment, ''f'' and ''g'' refer to different objects](images/m04----f_g_list_02.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![重新分配后，''f''和''g''引用不同的对象](images/m04----f_g_list_02.png)'
- en: After reassignment, ‘f’ and ‘g’ refer to different objects
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 重新分配后，'f'和'g'引用不同的对象
- en: Argument passing is reference binding
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数传递是引用绑定
- en: 'So we’ve seen that it’s quite possible to modify the objects through function
    argument references, but also that it’s possible to rebind the argument references
    to new values. If you want to change the contents of a list parameter and have
    the changes seen outside the function, you could modify the contents of the list
    like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们已经看到通过函数参数引用修改对象是完全可能的，但也可以重新绑定参数引用到新值。如果你想改变列表参数的内容，并且希望在函数外部看到这些变化，你可以像这样修改列表的内容：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And indeed, if you check the contents of `f` you’ll see that they have been
    modified:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，如果你检查`f`的内容，你会发现它们已经被修改了：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Function arguments are transferred by what is called “pass by object reference”.
    This means that the value of the *reference* is copied into the function argument,
    not the value of the referred to object; no objects are copied.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 函数参数是通过所谓的“对象引用传递”传递的。这意味着引用的*值*被复制到函数参数中，而不是所引用对象的值；没有对象被复制。
- en: Python return semantics
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python 返回语义
- en: Python’s `return` statement uses the same pass-by-object-reference semantics
    as function arguments. When you return an object from a function in Python, what
    you’re really doing is passing an object reference back to the caller. If the
    caller assigns the return value to a reference, they are doing nothing more than
    assigning a new reference to the returned object. This uses the exact same semantics
    and mechanics that we saw with explicit reference assignment and argument passing.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`return`语句使用与函数参数相同的对象引用传递语义。当你在Python中从函数返回一个对象时，你真正做的是将一个对象引用传递回调用者。如果调用者将返回值分配给一个引用，他们所做的只是将一个新的引用分配给返回的对象。这使用了与显式引用赋值和参数传递相同的语义和机制。
- en: 'We can demonstrate this by writing a function which returns its only argument:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过编写一个返回它的唯一参数的函数来证明这一点：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we create an object such as a list and pass it through this simple function,
    we see that it returns the very same object that we passed in:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建一个对象，比如一个列表，并通过这个简单的函数传递它，我们会发现它返回的是我们传入的完全相同的对象：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Remember that `is` only returns `True` when two names refer to the exact same
    objects, so example this shows that no copies of the list were made.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，只有当两个名称引用完全相同的对象时，`is`才会返回`True`，所以这个例子表明列表没有被复制。
- en: Function arguments in detail
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 详细的函数参数
- en: Now that we understand the distinction between object references and objects,
    we’ll look at some more capabilities of function arguments.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们理解了对象引用和对象之间的区别，我们将看一些函数参数的更多功能。
- en: Default parameter values
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 默认参数值
- en: 'The formal function arguments specified when a function is defined with the
    `def` keyword are a comma-separated list of the argument names. These arguments
    can be made optional by providing default values. Consider a function which prints
    a simple banner to the console:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`def`关键字定义函数时指定的形式函数参数是一个逗号分隔的参数名称列表。通过提供默认值，这些参数可以变成可选的。考虑一个函数，它在控制台上打印一个简单的横幅：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This function takes two arguments, and we provide a default value — in this
    case `'-'` — in a literal string. When we define functions using default arguments,
    the parameters with default arguments must come after those without defaults,
    otherwise we will get a `SyntaxError`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受两个参数，并且我们提供了一个默认值——在这种情况下是`'-'`——在一个字面字符串中。当我们使用默认参数定义函数时，具有默认参数的参数必须在没有默认值的参数之后，否则我们将得到一个`SyntaxError`。
- en: On line 2 of the function we multiply our border string by the length of the
    message string. This line shows two interesting features. First, it demonstrates
    how we can determine the number of items in a Python collection using the built-in
    `len()` function. Secondly, it shows how multiplying a string (in this case the
    single character string border) by an integer results in a new string containing
    the original string repeated a number of times. We use that feature here to make
    a string equal in length to our message.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数的第2行，我们将我们的边框字符串乘以消息字符串的长度。这一行展示了两个有趣的特点。首先，它演示了我们如何使用内置的`len()`函数确定Python集合中的项目数。其次，它展示了如何将一个字符串（在这种情况下是单个字符字符串边框）乘以一个整数，结果是一个包含原始字符串重复多次的新字符串。我们在这里使用这个特性来使一个与我们的消息长度相等的字符串。
- en: On lines 3 through 5 we print the full-width border, the message, and the border
    again.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在3到5行，我们打印全宽边框、消息和再次边框。
- en: 'When we call our `banner()` function, we don’t need to supply the border string
    because we’ve provided a default value:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用我们的`banner()`函数时，我们不需要提供边框字符串，因为我们提供了一个默认值：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'However, if we do provide the optional argument, it is used:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们提供可选参数，它会被使用：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Keyword arguments
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 关键字参数
- en: 'In production code, this function call is not particularly self documenting.
    We can improve that situation by naming the `border` argument at the call site:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产代码中，这个函数调用并不特别自我说明。我们可以通过在调用站点命名`border`参数来改善这种情况：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In this case the `message` string is called a “positional argument” and the
    `border` string a “keyword argument”. In a call, the positional arguments are
    matched up in sequence with the formal arguments declared in the function definition.
    The keyword arguments, on the other hand, are matched by name. If we use keyword
    arguments for both of our parameters, we have the freedom to supply them in any
    order:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`message`字符串被称为“位置参数”，`border`字符串被称为“关键字参数”。在调用中，位置参数按照函数定义中声明的形式参数的顺序进行匹配。另一方面，关键字参数则按名称进行匹配。如果我们为我们的两个参数使用关键字参数，我们可以自由地以任何顺序提供它们：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Remember, though, that all keyword arguments must be specified after any positional
    arguments.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住，所有关键字参数必须在任何位置参数之后指定。
- en: When are default arguments evaluated?
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 默认参数何时被评估？
- en: When you supply a default parameter value for a function, you do so by providing
    an *expression*. This expression can be a simple literal value, or it can be a
    more complex function call. In order to actually use the default value that you
    provide, Python has to at some point evaluate that expression.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当您为函数提供默认参数值时，您通过提供一个*表达式*来实现。这个表达式可以是一个简单的文字值，也可以是一个更复杂的函数调用。为了实际使用您提供的默认值，Python必须在某个时候评估该表达式。
- en: 'It’s crucial, then, to have an appreciation of exactly *when* Python evaluates
    the default value expression. This will help you to avoid a common pitfall which
    frequently ensnares newcomers to Python. Let’s examine this question closely using
    the Python standard library `time` module:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，关键是要确切了解Python何时评估默认值表达式。这将帮助您避免一个常见的陷阱，这个陷阱经常会使Python的新手陷入困境。让我们使用Python标准库`time`模块仔细研究这个问题：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can easily get the current time as a readable string by using the `ctime()`
    function of the `time` module:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`time`模块的`ctime()`函数轻松地将当前时间作为可读字符串获取：
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let’s write a function which uses a value retrieved from `ctime()` as a default
    argument value:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个使用从`ctime()`检索的值作为默认参数值的函数：
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'So far so good, but notice what happens when you call `show_default()` again
    a few seconds later:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利，但请注意当您几秒钟后再次调用`show_default()`时会发生什么：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'and again:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 再一次：
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see, the displayed time never progresses.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，显示的时间永远不会进展。
- en: Recall how we said that `def` is a statement that when executed binds a function
    definition to a function name? Well, the default argument expressions are evaluated
    only once, when the `def` statement is executed. In many cases the default value
    is a simple immutable constant like and integer or a string, so this does not
    cause any problems. But it can be a confusing trap for the unwary that usually
    shows up when you use mutable collections like lists as argument defaults.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们说过`def`是一个语句，当执行时将函数定义绑定到函数名吗？好吧，默认参数表达式只在`def`语句执行时评估一次。在许多情况下，默认值是一个简单的不可变常量，如整数或字符串，因此这不会引起任何问题。但是对于那些通常在使用可变集合作为参数默认值时出现的困惑陷阱，这可能是一个令人困惑的陷阱。
- en: 'Let’s take a closer look. Consider this function which uses an empty list as
    a default argument. It accepts a menu as a list of strings, appends the item `"spam"`
    to the list, and returns the modified menu:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看。考虑这个使用空列表作为默认参数的函数。它接受一个菜单作为字符串列表，将项目“spam”附加到列表中，并返回修改后的菜单：
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let’s create a simple breakfast of bacon and eggs:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来制作一个简单的培根和鸡蛋早餐：
- en: '[PRE37]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Naturally, we’ll add spam to it:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们会向其中添加垃圾邮件：
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We’ll do something similar for lunch:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为午餐做类似的事情：
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Nothing unexpected so far. But look what happens when you rely on the default
    argument by not passing an existing menu:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止没有什么意外的。但是看看当您依赖默认参数而不传递现有菜单时会发生什么：
- en: '[PRE40]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When we append `''spam''` to an empty menu we get just `spam`. This is probably
    still what you expected, but if we do that again we get two `spam`s added to our
    menu:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向空菜单添加`'spam'`时，我们只得到`spam`。这可能仍然是您所期望的，但如果我们再次这样做，我们的菜单中就会添加两个`spam`：
- en: '[PRE41]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And three:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 还有三个：
- en: '[PRE42]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'And four:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 还有四个：
- en: '[PRE43]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: What’s happening here is this. First, the empty list used for the default argument
    is created exactly once, when the `def` statement is executed. This is a normal
    list like any other we’ve seen so far, and Python will use this exact list for
    the entire execution of your program.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的情况是这样的。首先，在`def`语句执行时，用于默认参数的空列表被创建一次。这是一个像我们迄今为止看到的任何其他普通列表一样的列表，Python将在整个程序执行期间使用这个确切的列表。
- en: The first time we actually use the default, then, we end up adding `spam` directly
    to the default list object. When we use the default a second time, we’re using
    the same default list object — the one to which we just added `spam` – and we
    end up adding a second instance of `"spam"` to it. The third call adds a third
    spam, *ad infinitum*. Or perhaps *ad nauseum*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次我们实际使用默认值，然后，我们最终直接将“spam”添加到默认列表对象中。当我们第二次使用默认值时，我们使用的是同一个默认列表对象——我们刚刚添加了“spam”的对象，并且我们最终将第二个“spam”实例添加到其中。第三次调用会无限地添加第三个spam。或者也许是无限地恶心。
- en: 'The solution to this is straightforward, but perhaps not obvious: **Always
    use immutable objects such as integers or strings for default values**. Following
    this advice, we can solve this particular case by using the immutable `None` object
    as a sentinel:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题很简单，但也许不是显而易见的：**始终使用不可变对象，如整数或字符串作为默认值**。遵循这个建议，我们可以通过使用不可变的`None`对象作为标记来解决这个特定的问题：
- en: '[PRE44]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: and now our `add_spam()` function works as expected.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的`add_spam()`函数按预期工作。
- en: The Python type system
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python类型系统
- en: Programming languages can be distinguished by several characteristics, but one
    of the most important is the nature of their type systems. Python can be characterized
    as having a *dynamic* and *strong* type system. Let’s investigate what that means.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言可以通过几个特征来区分，但其中最重要的特征之一是它们的类型系统的性质。Python可以被描述为具有*动态*和*强*类型系统。让我们来研究一下这意味着什么。
- en: Dynamic typing in Python
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Python中的动态类型
- en: 'Dynamic typing means that the type of an object-reference isn’t resolved until
    the program is running, and it needn’t be specified up front when the program
    is written. Take a look at this simple function for adding two objects:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 动态类型意味着对象引用的类型直到程序运行时才能解析，并且在编写程序时无需事先指定。看一下这个简单的函数来添加两个对象：
- en: '[PRE45]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Nowhere in this definition do we mention any types. We can use `add()` with
    integers:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个定义中我们没有提到任何类型。我们可以用整数使用`add()`：
- en: '[PRE46]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'And we can use it for floats:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以用它来表示浮点数：
- en: '[PRE47]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You might be surprised to see that it even works for strings:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会惊讶地看到它甚至适用于字符串：
- en: '[PRE48]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Indeed, this function works for any types, like `list`, for which the addition
    operator has been defined:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这个函数适用于任何类型，比如`list`，对于这些类型，加法运算符已经被定义：
- en: '[PRE49]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'These examples illustrate the dynamism of the type system: the two arguments,
    `a` and `b`, of the `add()` function can reference any types of object.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例说明了类型系统的动态性：`add()`函数的两个参数`a`和`b`可以引用任何类型的对象。
- en: Strong typing in Python
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Python中的强类型
- en: 'The strength of the type system, on the other hand, can be demonstrated by
    attempting to `add()` types for which addition has not been defined, such as strings
    and floats:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，类型系统的强度可以通过尝试为未定义加法的类型（如字符串和浮点数）`add()`来证明：
- en: '[PRE50]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Trying to do this results in a `TypeError` because Python will not, in general,
    perform implicit conversions between object types or otherwise attempt to coerce
    one type to another. The primary exception to this is the conversion to `bool`
    used for if-statement and while-loop predicates. ^([11](chap21.xhtml#fn-not-the-type-system))
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这样做会导致`TypeError`，因为Python通常不会在对象类型之间执行隐式转换，或者试图将一种类型强制转换为另一种类型。这个主要的例外是用于if语句和while循环谓词的`bool`转换。^([11](chap21.xhtml#fn-not-the-type-system))
- en: Variable declaration and scoping
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量声明和作用域
- en: As we have seen, no type declarations are necessary in Python, and variables
    are essentially just untyped name bindings to objects. As such, they can be rebound
    – or reassigned – as often as necessary, even to object of different types.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Python中不需要类型声明，变量本质上只是未经类型化的名称绑定到对象。因此，它们可以被重新绑定 - 或重新分配 - 任意多次，甚至可以是不同类型的对象。
- en: But when we bind a name to an object, where is that binding stored? To answer
    that question, we must look at scopes and scoping rules in Python.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当我们将一个名称绑定到一个对象时，该绑定存储在哪里？要回答这个问题，我们必须看一下Python中的作用域和作用域规则。
- en: The LEGB rule
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: LEGB规则
- en: 'There are four types of *scope* in Python, and they are arranged in a hierarchy.
    Each scope is a context in which names are stored and in which they can be looked
    up. The four scopes from narrowest to broadest are:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Python中有四种*作用域*类型，它们按层次排列。每个作用域都是存储名称并在其中查找名称的上下文。从最狭窄到最宽广的四个作用域是：
- en: Local - names defined inside the current function.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地 - 在当前函数内定义的名称。
- en: Enclosing - names defined inside any and all enclosing functions. (This scope
    isn’t important for the contents of this book.)
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封闭 - 在任何封闭函数中定义的名称。（这个作用域对本书的内容并不重要。）
- en: Global - names defined at the top-level of a module. Each module brings with
    it a new global scope.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局 - 在模块的顶层定义的名称。每个模块都带有一个新的全局作用域。
- en: Built-in - names built-in to the Python language through the special `builtins`
    module.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置 - 通过特殊的`builtins`模块内置到Python语言中的名称。
- en: 'Together, these scopes comprise the LEGB rule:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这些作用域共同构成了LEGB规则：
- en: '**The LEGB Rule**'
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**LEGB规则**'
- en: '>'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: Names are looked up in the narrowest relevant context.
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 名称在最相关的上下文中查找。
- en: It’s important to note that scopes in Python do not, in general, correspond
    to the source-code blocks as demarcated by indentation. For-loops, with-blocks,
    and the like do not introduce new nested scopes.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，Python中的作用域通常不对应于缩进所标示的源代码块。for循环、with块等不会引入新的嵌套作用域。
- en: Scopes in action
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 作用域的实际应用
- en: 'Consider our `words.py` module. It contains the following global names:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们的`words.py`模块。它包含以下全局名称：
- en: '`main` - bound by `def main()`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main` - 由`def main()`绑定'
- en: '`sys` - bound by `import sys`'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sys` - 由`import sys`绑定'
- en: '`__name__` - provided by the Python runtime'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__name__` - 由Python运行时提供'
- en: '`urlopen` - bound by `from urllib.request import urlopen`'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`urlopen` - 由`from urllib.request import urlopen`绑定'
- en: '`fetch_words` - bound by `def fetch_words()`'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch_words` - 由`def fetch_words()`绑定'
- en: '`print_items` - bound by `def print_items()`'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print_items` - 由`def print_items()`绑定'
- en: Module scope name bindings are typically introduced by `import` statements and
    function or class definitions. It is possible to use other objects at module scope,
    and this is typically used for constants, although it can also be used for variables.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 模块范围名称绑定通常是由`import`语句和函数或类定义引入的。在模块范围内使用其他对象是可能的，这通常用于常量，尽管它也可以用于变量。
- en: 'Within the `fetch_words()` function we have the six local names:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在`fetch_words()`函数内部，我们有六个本地名称：
- en: '`word` - bound by the inner for-loop'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`word` - 由内部for循环绑定'
- en: '`line_words` - bound by assignment'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`line_words` - 通过赋值绑定'
- en: '`line` - bound by the outer for-loop'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`line` - 由外部for循环绑定'
- en: '`story_words` - bound by assignment'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`story_words` - 通过赋值绑定'
- en: '`url` - bound by the formal function argument'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url` - 由形式函数参数绑定'
- en: '`story` - bound by the with-statement'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`story` - 由with语句绑定'
- en: Each of these bindings is brought into existence at first use and continues
    to live within the function scope until the function completes, at which point
    the references will be destroyed.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这些绑定中的每一个都是在首次使用时创建的，并在函数完成时继续存在于函数作用域内，此时引用将被销毁。
- en: Identical names in global and local scope
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 全局和本地作用域中的相同名称
- en: 'Very occasionally we need to rebind a global name at module scope from within
    a function. Consider the following simple module:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 非常偶尔，我们需要在函数内部从模块范围重新绑定全局名称。考虑以下简单模块：
- en: '[PRE51]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If we save this module in `scopes.py`, we can import it into the REPL for experimentation:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个模块保存在`scopes.py`中，我们可以将其导入REPL进行实验：
- en: '[PRE52]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: When `show_count()` is called Python looks up the name `count` in the local
    namespace (L). It doesn’t find it so looks in the next most outer namespace, in
    this case the global module namespace (G), where it finds the name `count` and
    prints the referred-to object.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`show_count()`时，Python在本地命名空间（L）中查找名称`count`。它找不到，所以在下一个最外部的命名空间中查找，这种情况下是全局模块命名空间（G），在那里它找到名称`count`并打印所引用的对象。
- en: 'Now we call `set_count()` with a new value:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们用一个新值调用`set_count()`：
- en: '[PRE53]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We then call `show_count()` again:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们再次调用`show_count()`：
- en: '[PRE54]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: You might be surprised that `show_count()` displays `0` after the call to `set_count(5)`,
    so let’s work through what’s happening.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会惊讶，在调用`set_count(5)`后，`show_count()`显示`0`，所以让我们一起来看看发生了什么。
- en: When we call `set_count()`, the assignment `count = c` creates a *new* binding
    for the name `count` in the *local* scope. This new binding refers, of course,
    to the object passed in as `c`. Critically, no lookup is performed for the global
    `count` defined at module scope. We have created a new variable which shadows,
    and thereby prevents access to, the global of the same name.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`set_count()`时，赋值`count = c`在*本地*作用域中为名称`count`创建了一个*新*绑定。这个新绑定当然是指传递的对象`c`。关键是，在模块范围定义的全局`count`不会进行查找。我们创建了一个新变量，它遮蔽了同名的全局变量，从而阻止访问。
- en: The `global` keyword
  id: totrans-237
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`global`关键字'
- en: 'To avoid this shadowing of names in the global scope, we need to instruct Python
    to resolve the name `count` in the `set_count()` function to the `count` defined
    in the module namespace. We can do this by using the `global` keyword. Let’s modify
    `set_count()` to do so:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在全局范围内遮蔽名称，我们需要指示Python将`set_count()`函数中的名称`count`解析为模块命名空间中定义的`count`。我们可以使用`global`关键字来做到这一点。让我们修改`set_count()`来这样做：
- en: '[PRE55]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`global` introduces a binding in the local scope to a name from the global
    scope.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`global`在本地作用域中引入了一个来自全局作用域的名称绑定。'
- en: 'Quit and restart the Python interpreter to exercise our revised module:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 退出并重新启动Python解释器以运行我们修改后的模块：
- en: '[PRE56]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: It now demonstrates the required behaviour.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 它现在展示了所需的行为。
- en: '* * *'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Moment of zen
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 禅的时刻
- en: '![](images/m04----zen-special-cases.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](images/m04----zen-special-cases.png)'
- en: As we have shown, all variables in Python are references to objects, even in
    the case of basic types such as integers. This thorough approach to object orientation
    is a strong theme in Python and practically everything in Python is an object,
    including functions and modules.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所展示的，Python中的所有变量都是对象的引用，即使在基本类型（如整数）的情况下也是如此。这种对对象导向的彻底方法是Python的一个重要主题，实际上Python中的几乎所有东西都是对象，包括函数和模块。
- en: '* * *'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Everything is an object
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一切都是对象
- en: 'Let’s go back to our `words` module and experiment with it further at the REPL.
    On this occasion we’ll import just the module:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的`words`模块，并在REPL中进一步进行实验。这次我们只会导入模块：
- en: '[PRE57]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `import` statement binds a module object to the name `words` in the current
    namespace. We can determine the type of any object by using the `type()` built-in
    function:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`语句在当前命名空间中将模块对象绑定到名称`words`。我们可以使用`type()`内置函数确定任何对象的类型：'
- en: '[PRE58]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If we want to see the attributes of an object, we can use the `dir()` built-in
    function in a Python interactive session to introspect an object:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要查看对象的属性，我们可以在Python交互会话中使用`dir()`内置函数来审视对象：
- en: '[PRE59]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `dir()` function returns a sorted list of the module attribute names, including:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`dir()`函数返回模块属性名称的排序列表，包括：'
- en: The ones we defined such as the function `fetch_words()`
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义的一些，比如函数`fetch_words()`
- en: Any imported names such as `sys` and `urlopen`
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何导入的名称，比如`sys`和`urlopen`
- en: Various special *dunder* attributes such as `__name__` and `__doc__` which reveal
    the inner-workings of Python.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种特殊的*dunder*属性，比如`__name__`和`__doc__`，揭示了Python的内部工作。
- en: Inspecting a function
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查一个函数
- en: 'We can use the `type()` function on any of these attributes to learn more about
    them. For instance, we can see that `fetch_words` is a function object:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`type()`函数对任何这些属性进行更多了解。例如，我们可以看到`fetch_words`是一个函数对象：
- en: '[PRE60]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We can in turn use `dir()` on the function to reveal its attributes:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以反过来在函数上使用`dir()`来揭示它的属性：
- en: '[PRE61]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We can see here that function objects have *many* special attributes to do with
    how Python functions are implemented behind the scenes. For now, we’ll just look
    at a couple of simple attributes.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到函数对象有*许多*与Python函数在幕后实现方式有关的特殊属性。现在，我们只看一些简单的属性。
- en: 'As you might expect, its `__name__` attribute is the name of the function object
    as a string:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所期望的那样，它的`__name__`属性是函数对象的名称作为字符串：
- en: '[PRE62]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Likewise, `__doc__` is the docstring we provided, giving us some clues about
    how the built-in `help()` function might be implemented.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`__doc__`是我们提供的文档字符串，给出了一些关于内置`help()`函数如何实现的线索。
- en: '[PRE63]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This is just a small example of how you can introspect Python objects at runtime,
    and there are many more powerful tools that you can use to learn more about the
    objects you’re using. Perhaps the most instructive part of the example is that
    we were dealing with a *function object*, demonstrating that Python’s pervasive
    object orientation includes elements of the language that may not be accessible
    at all in other languages.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个小例子，展示了您可以在运行时审查Python对象，还有许多更强大的工具可以帮助您了解更多关于您正在使用的对象。也许这个例子最有教育意义的部分是，我们正在处理一个*函数对象*，这表明Python的普遍对象导向包括其他语言中可能根本无法访问的语言元素。
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: Python object references
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python对象引用
- en: Think of Python working in terms of named references to objects rather than
    variables and values.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Python视为对对象的命名引用，而不是变量和值。
- en: Assignment doesn’t put a value in a box. It attaches a name tag to an object.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值不会将值放入一个盒子中。它会将一个名称标签附加到一个对象上。
- en: Assigning from one reference to another puts two name tags on the same object.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一个引用分配到另一个引用会在同一个对象上放置两个名称标签。
- en: The Python garbage collector will reclaim unreachable objects - those objects
    with no name tag.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python垃圾收集器将回收不可达的对象-那些没有名称标签的对象。
- en: Object identity and equivalence
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象标识和等价性
- en: The `id()` function returns a unique and constant identifier but should rarely,
    if ever, be used in production.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id()`函数返回一个唯一且恒定的标识符，但在生产中很少使用。'
- en: The `is` operator determines equality of identity. That is, whether two names
    refer to the same object.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is`运算符确定身份的相等性。也就是说，两个名称是否引用同一个对象。'
- en: We can test for equivalence using the double-equals operator.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用双等号运算符测试等价性。
- en: Function arguments and return values
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数参数和返回值
- en: Function arguments are passed by object-reference, so functions can modify their
    arguments if they are mutable objects.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数参数通过对象引用传递，因此如果它们是可变对象，函数可以修改它们的参数。
- en: If a formal function argument is rebound through assignment, the reference to
    the passed-in object is lost. To change a mutable argument you should replace
    its *contents* rather than replacing the whole object.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果通过赋值重新绑定形式函数参数，则传入对象的引用将丢失。要更改可变参数，应该替换其*内容*而不是替换整个对象。
- en: The return statement also passes by object-reference. No copies are made.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回语句也通过对象引用传递。不会进行复制。
- en: Function arguments can be specified with defaults.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数参数可以指定默认值。
- en: Default argument expressions are evaluated only once when the `def` statement
    is executed.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认参数表达式在执行`def`语句时只被评估一次。
- en: The Python type system
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python类型系统
- en: Python uses dynamic typing, so we don’t need to specify reference types in advance.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python使用动态类型，因此我们不需要提前指定引用类型。
- en: Python uses strong typing. Types are not coerced to match.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python使用强类型。类型不会被强制匹配。
- en: Scopes
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围
- en: 'Python reference names are looked up in one of four nested scopes according
    to the LEGB rule: Local to functions, in Enclosing functions, in the Global (or
    module) namespace and Built-ins.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据LEGB规则，Python引用名称在四个嵌套范围中查找：局部函数中，封闭函数中，全局（或模块）命名空间中和内置函数。
- en: Global references can be read from a local scope
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局引用可以从局部范围读取
- en: Assigning to global references from a local scope requires that the reference
    be declared global using the global keyword.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从局部范围分配给全局引用需要使用global关键字声明引用为全局引用。
- en: Objects and introspection
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象和内省
- en: Everything in Python is an object, including modules and functions. They can
    be treated just like other objects.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的所有内容都是对象，包括模块和函数。它们可以像其他对象一样对待。
- en: The `import` and `def` keywords result in binding to named references.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import`和`def`关键字会绑定到命名引用。'
- en: The built-in `type()` function can be used to determine the type of an object.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置的`type()`函数可以用来确定对象的类型。
- en: The built-in `dir()` function can be used to introspect an object and return
    a list of its attribute names.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置的`dir()`函数可以用来内省对象并返回其属性名称的列表。
- en: The name of a function or module object can be accessed through its `__name__`
    attribute.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数或模块对象的名称可以通过其`__name__`属性访问。
- en: The docstring for a function or module object can be accessed through its `__doc__`
    attribute.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数或模块对象的文档字符串可以通过其`__doc__`属性访问。
- en: Miscellaneous
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 杂项
- en: We can use `len()` to measure the length of a string.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`len()`来测量字符串的长度。
- en: If we “multiply” a string by an integer we get a new string with multiple copies
    of the operand string. This is called the “repetition” operation.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们将字符串“乘以”一个整数，我们将得到一个新的字符串，其中包含操作数字符串的多个副本。这称为“重复”操作。
