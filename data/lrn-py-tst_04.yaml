- en: Chapter 4. Decoupling Units with unittest.mock
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。使用unittest.mock解耦单元
- en: Several times in the last couple of chapters, when faced with the problem of
    isolating tests from each other, I told you to just keep the problem in mind and
    said we'd deal with it in this chapter. Finally, it's time to actually address
    the problem.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几章中，有好几次在面临将测试相互隔离的问题时，我告诉你们只需将问题记在心里，并说我们会在本章中处理它。终于，是时候真正解决这个问题了。
- en: Functions and methods that do not rely on the behavior of other functions, methods,
    or data are rare; the common case is to have them make several calls to other
    functions or methods, and instantiate at least one instance of a class. Every
    one of these calls and instantiations breaks the unit's isolation; or, if you
    prefer to think of it this way, it incorporates more code into the isolated section.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 不依赖于其他函数、方法或数据的行为的函数和方法很少见；常见的情况是它们会调用其他函数或方法多次，并至少实例化一个类。这些调用和实例化中的每一个都会破坏单元的隔离；或者，如果你更喜欢这样想，它将更多的代码纳入了隔离部分。
- en: No matter how you look at it—as an isolation breaking or as expanding the isolated
    section—it's something you want to have the ability to prevent. Mock objects let
    you do this by taking the place of external functions or objects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你怎么看它——是作为隔离破坏者还是作为扩展隔离部分——这都是你想要有能力防止的事情。模拟对象通过取代外部函数或对象让你能够做到这一点。
- en: 'Using the `unittest.mock` package, you can easily perform the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`unittest.mock`包，你可以轻松执行以下操作：
- en: Replace functions and objects in your own code or in external packages, as we
    did with `time.time` in [Chapter 3](ch03.html "Chapter 3. Unit Testing with doctest"),
    *Unit Testing with doctest*.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用我们[第3章](ch03.html "第3章。使用doctest进行单元测试")中用到的`time.time`一样，替换你自己的代码或外部包中的函数和对象。
- en: Control how replacement objects behave. You can control what return values they
    provide, whether they raise an exception, even whether they make any calls to
    other functions, or create instances of other objects.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制替换对象的行为。你可以控制它们提供的返回值，是否抛出异常，甚至是否调用其他函数，或创建其他对象的实例。
- en: 'Check whether the replacement objects were used as you expected: whether functions
    or methods were called the correct number of times, whether the calls occurred
    in the correct order, and whether the passed parameters were correct.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查替换对象是否按预期使用：函数或方法是否被正确次数地调用，调用是否按正确的顺序发生，以及传递的参数是否正确。
- en: Mock objects in general
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一般的模拟对象
- en: All right, before we get down to the nuts and bolts of `unittest.mock`, let's
    spend a few moments talking about mock objects overall.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，在我们深入探讨`unittest.mock`的细节之前，让我们花几分钟时间来谈谈模拟对象的整体情况。
- en: Broadly speaking, mock objects are any objects that you can use as substitutes
    in your test code, to keep your tests from overlapping and your tested code from
    infiltrating the wrong tests. Thus, our fake `time.time` from [Chapter 3](ch03.html
    "Chapter 3. Unit Testing with doctest"), *Unit Testing with doctest*, was a mock
    object. However, like most things in programming, the idea works better when it
    has been formalized into a well-designed library that you can call on when you
    need it. There are many such libraries available for most programming languages.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 从广义上讲，模拟对象是你可以在测试代码中使用作为替代品的对象，以防止测试重叠，并确保被测试的代码不会渗透到错误的测试中。因此，我们来自[第3章](ch03.html
    "第3章。使用doctest进行单元测试")的假`time.time`，*使用doctest进行单元测试*，就是一个模拟对象。然而，就像编程中的大多数事情一样，当它被正式化为一个设计良好的库，你可以在需要时调用它时，这个想法会更好。大多数编程语言都有许多这样的库可用。
- en: 'Over time, the authors of mock object libraries have developed two major design
    patterns for mock objects: in one pattern, you can create a mock object and perform
    all of the expected operations on it. The object records these operations, and
    then you put the object into playback mode and pass it to your code. If your code
    fails to duplicate the expected operations, the mock object reports a failure.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，模拟对象库的作者已经为模拟对象开发了两种主要的设计模式：在一种模式中，你可以创建一个模拟对象，并对其执行所有预期的操作。对象记录这些操作，然后你将对象放入回放模式，并将其传递给你的代码。如果你的代码未能复制预期的操作，模拟对象会报告失败。
- en: In the second pattern, you can create a mock object, do the minimal necessary
    configuration to allow it to mimic the real object it replaces, and pass it to
    your code. It records how the code uses it, and then you can perform assertions
    after the fact to check whether your code used the object as expected.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种模式中，你可以创建一个模拟对象，进行必要的最小配置以允许它模仿它所替代的真实对象，并将其传递给代码。它会记录代码如何使用它，然后你可以在事后执行断言来检查代码是否按预期使用对象。
- en: The second pattern is *slightly* more capable in terms of the tests that you
    can write using it but, overall, either pattern works well.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用它编写的测试方面，第二种模式在功能上略胜一筹，但总体上，两种模式都工作得很好。
- en: Mock objects according to unittest.mock
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据unittest.mock的模拟对象
- en: Python has several mock object libraries; as of Python 3.3, however, one of
    them has been crowned as a member of the standard library. Naturally that's the
    one we're going to focus on. That library is, of course, `unittest.mock`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Python有几个模拟对象库；然而，截至Python 3.3，其中一个已经成为标准库的成员。自然地，我们将关注这个库。这个库当然是`unittest.mock`。
- en: The `unittest.mock` library is of the second sort, a record-actual-use-and-then-assert
    library. The library contains several different kinds of mock objects that, between
    them, let you mock almost anything that exists in Python. Additionally, the library
    contains several useful helpers that simplify assorted tasks related to mock objects,
    such as temporarily replacing real objects with mocks.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest.mock`库是第二种类型，一种记录实际使用情况然后断言的库。该库包含几种不同的模拟对象，它们共同让你可以模拟Python中几乎任何存在的东西。此外，该库还包含几个有用的辅助工具，简化了与模拟对象相关的各种任务，例如临时用模拟对象替换真实对象。'
- en: Standard mock objects
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准模拟对象
- en: The basic element of `unittest.mock` is the `unittest.mock.Mock` class. Even
    without being configured at all, `Mock` instances can do a pretty good job of
    pretending to be some other object, method, or function.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest.mock`的基本元素是`unittest.mock.Mock`类。即使没有进行任何配置，`Mock`实例也能很好地模仿其他对象、方法或函数。'
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are many mock object libraries for Python; so, strictly speaking, the
    phrase "mock object" could mean any object that was created by any of these libraries.
    From here on in this book, you can assume that a "mock object" is an instance
    of `unittest.mock.Mock` or one of its descendants.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Python，有许多模拟对象库；严格来说，“模拟对象”这个短语可能意味着由这些库中的任何一个创建的对象。从现在起，在这本书中，你可以假设“模拟对象”是`unittest.mock.Mock`或其子类的实例。
- en: Mock objects can pull off this impersonation because of a clever, somewhat recursive
    trick. When you access an unknown attribute of a mock object, instead of raising
    an `AttributeError` exception, the mock object creates a child mock object and
    returns that. Since mock objects are pretty good at impersonating other objects,
    returning a mock object instead of the real value works at least in the common
    case.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象能够通过一个巧妙且有些递归的技巧来完成这种模仿。当你访问模拟对象的未知属性时，而不是抛出`AttributeError`异常，模拟对象会创建一个子模拟对象并返回它。由于模拟对象擅长模仿其他对象，返回模拟对象而不是实际值在常见情况下是有效的。
- en: Similarly, mock objects are callable; when you call a mock object as a function
    or method, it records the parameters of the call and then, by default, returns
    a child mock object.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，模拟对象是可调用的；当你将模拟对象作为函数或方法调用时，它会记录调用参数，然后默认返回一个子模拟对象。
- en: A child mock object is a mock object in its own right, but it knows that it's
    connected to the mock object it came from—its parent. Anything you do to the child
    is also recorded in the parent's memory. When the time comes to check whether
    the mock objects were used correctly, you can use the parent object to check on
    all of its descendants.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一个子模拟对象是一个独立的模拟对象，但它知道它与它所来的模拟对象——它的父对象相连。你对子对象所做的任何操作也会记录在父对象的记忆中。当需要检查模拟对象是否被正确使用时，你可以使用父对象来检查其所有后代。
- en: 'Example: Playing with mock objects in the interactive shell (try it for yourself!):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：在交互式外壳中玩转模拟对象（亲自试试！）
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There are several important things demonstrated in this interactive session.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个交互式会话中展示了几个重要的事情。
- en: 'First, notice that the *same* mock object was returned each time that we accessed
    `mock.x`. This always holds true: if you access the same attribute of a mock object,
    you''ll get the same mock object back as the result.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意每次我们访问`mock.x`时都返回了相同的模拟对象。这始终成立：如果你访问模拟对象的相同属性，你将得到相同的模拟对象作为结果。
- en: The next thing to notice might seem more surprising. Whenever you call a mock
    object, you get the same mock object back as the return value. The returned mock
    isn't made new for every call, nor is it unique for each combination of parameters.
    We'll see how to override the return value shortly but, by default, you get the
    same mock object back every time you call a mock object. This mock object can
    be accessed using the `return_value` attribute name, as you might have noticed
    from the last statement of the example.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个需要注意的事情可能看起来更令人惊讶。无论何时调用模拟对象，你都会得到相同的模拟对象作为返回值。返回的模拟对象不是为每次调用而创建的，也不是为每个参数组合而唯一的。我们很快就会看到如何覆盖返回值，但默认情况下，每次调用模拟对象时，你都会得到相同的模拟对象。你可以使用
    `return_value` 属性名来访问这个模拟对象，正如你可能从示例的最后一句中注意到的。
- en: 'The `unittest.mock` package contains a `call` object that helps to make it
    easier to check whether the correct calls have been made. The `call` object is
    callable, and takes note of its parameters in a way similar to mock objects, making
    it easy to compare it to a mock object''s call history. However, the `call` object
    really shines when you have to check for calls to descendant mock objects. As
    you can see in the previous example, while `call(''Foo'', 1, 1)` will match a
    call to the parent mock object, if the call used these parameters, `call.x(''Foo'',
    1, 1)`, it matches a call to the child mock object named `x`. You can build up
    a long chain of lookups and invocations. For example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest.mock` 包包含一个 `call` 对象，它有助于更容易地检查是否已经进行了正确的调用。`call` 对象是可调用的，并以类似于模拟对象的方式记录其参数，这使得它很容易与模拟对象的调用历史进行比较。然而，`call`
    对象真正闪耀的时候是你必须检查对派生模拟对象的调用。正如你可以在前面的例子中看到，`call(''Foo'', 1, 1)` 将匹配对父模拟对象的调用，但如果调用使用了这些参数，`call.x(''Foo'',
    1, 1)`，它将匹配对名为 `x` 的子模拟对象的调用。你可以构建一个长长的查找和调用链。例如：'
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that the original invocation included `hello(23)`, but the call specification
    wrote it simply as `hello()`. Each call specification is only concerned with the
    parameters of the object that was finally called after all of the lookups. The
    parameters of intermediate calls are not considered. That's okay because they
    always produce the same return value anyway unless you've overridden that behavior,
    in which case they probably don't produce a mock object at all.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，原始调用包括了 `hello(23)`，但调用规范只是简单地将其写成 `hello()`。每个调用规范只关心最终被调用对象的参数。中间调用的参数不被考虑。这没关系，因为它们总是产生相同的返回值，除非你覆盖了这种行为，在这种情况下，它们可能根本不会产生模拟对象。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You might not have encountered an assertion before. Assertions have one job,
    and one job only: they raise an exception if something is not as expected. The
    `assert_has_calls` method, in particular, raises an exception if the mock object''s
    history does not include the specified calls. In our example, the call history
    matches, so the assertion method doesn''t do anything visible.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能之前没有遇到过断言。断言只有一个任务，而且只有一个任务：如果某事不是预期的，它会引发异常。特别是 `assert_has_calls` 方法，如果模拟对象的历史记录不包括指定的调用，则会引发异常。在我们的例子中，调用历史记录是一致的，所以断言方法没有做任何明显的操作。
- en: 'You *can* check whether the intermediate calls were made with the correct parameters,
    though, because the mock object recorded a call immediately to `mock.z.hello(23)`
    before it recorded a call to `mock.z.hello().stuff.howdy(''a'', ''b'', ''c'')`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，你可以检查中间调用是否使用了正确的参数，因为模拟对象在记录对 `mock.z.hello(23)` 的调用之前立即记录了对 `mock.z.hello().stuff.howdy('a',
    'b', 'c')` 的调用：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This also points out the `mock_calls` attribute that all mock objects carry.
    If the various assertion functions don't quite do the trick for you, you can always
    write your own functions that inspect the `mock_calls` list and check whether
    things are or are not as they should be. We'll discuss the mock object assertion
    methods shortly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这也指出了所有模拟对象都携带的 `mock_calls` 属性。如果各种断言函数对你来说还不够用，你总是可以编写自己的函数来检查 `mock_calls`
    列表，并验证事情是否如预期那样。我们很快就会讨论模拟对象断言方法。
- en: Non-mock attributes
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非模拟属性
- en: 'What if you want a mock object to give back something other than a child mock
    object when you look up an attribute? It''s easy; just assign a value to that
    attribute:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望模拟对象在查找属性时返回的不仅仅是子模拟对象，怎么办？这很简单；只需将值分配给该属性：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There''s one other common case where mock objects'' default behavior is wrong:
    what if accessing a particular attribute is supposed to raise an `AttributeError`?
    Fortunately, that''s easy too:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一个常见的情况是模拟对象的默认行为是错误的：如果访问特定属性应该引发一个`AttributeError`怎么办？幸运的是，这也很简单：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Non-mock return values and raising exceptions
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非模拟返回值和引发异常
- en: Sometimes, actually fairly often, you'll want mock objects posing as functions
    or methods to return a specific value, or a series of specific values, rather
    than returning another mock object.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，实际上相当频繁，您会希望模拟对象扮演函数或方法的角色，返回特定的值或一系列特定的值，而不是返回另一个模拟对象。
- en: 'To make a mock object always return the same value, just change the `return_value`
    attribute:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要使模拟对象始终返回相同的值，只需更改`return_value`属性：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you want the mock object to return different value each time it''s called,
    you need to assign an iterable of return values to the `side_effect` attribute
    instead, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望模拟对象在每次调用时返回不同的值，您需要将一个返回值序列分配给`side_effect`属性，如下所示：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you don''t want your mock object to raise a `StopIteration` exception, you
    need to make sure to give it enough return values for all of the invocations in
    your test. If you don''t know how many times it will be invoked, an infinite iterator
    such as `itertools.count` might be what you need. This is easily done:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不希望模拟对象引发`StopIteration`异常，您需要确保为测试中的所有调用提供足够的返回值。如果您不知道它将被调用多少次，一个无限迭代器，如`itertools.count`可能就是您需要的。这很容易做到：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you want your mock to raise an exception instead of returning a value, just
    assign the exception object to `side_effect`, or put it into the iterable that
    you assign to `side_effect`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望模拟在返回值而不是引发异常，只需将异常对象分配给`side_effect`，或者将其放入分配给`side_effect`的迭代器中：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `side_effect` attribute has another use, as well that we'll talk about.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`side_effect`属性还有另一个用途，我们将在后面讨论。'
- en: Mocking class or function details
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟类或函数的细节
- en: Sometimes, the generic behavior of mock objects isn't a close enough emulation
    of the object being replaced. This is particularly the case when it's important
    that they raise exceptions when used improperly, since mock objects are usually
    happy to accept any usage.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，模拟对象的一般行为并不能足够接近被替换对象的模拟。这尤其适用于当它们在不当使用时需要引发异常的情况，因为模拟对象通常乐于接受任何使用方式。
- en: 'The `unittest.mock` package addresses this problem using a technique called
    **speccing**. If you pass an object into `unittest.mock.create_autospec`, the
    returned value will be a mock object, but it will do its best to pretend that
    it''s the same object you passed into `create_autospec`. This means that it will:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest.mock`包使用一种称为**speccing**的技术来解决此问题。如果你将一个对象传递给`unittest.mock.create_autospec`，返回的值将是一个模拟对象，但它会尽力假装它就是传递给`create_autospec`的那个对象。这意味着它将：'
- en: Raise an `AttributeError` if you attempt to access an attribute that the original
    object doesn't have, unless you first explicitly assign a value to that attribute
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您尝试访问原始对象没有的属性，将引发一个`AttributeError`，除非您首先明确地为该属性分配一个值。
- en: Raise a `TypeError` if you attempt to call the mock object when the original
    object wasn't callable
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您尝试在原始对象不可调用时调用模拟对象，将引发一个`TypeError`。
- en: Raise a `TypeError` if you pass the wrong number of parameters or pass a keyword
    parameter that isn't viable if the original object was callable
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果传递了错误的参数数量或传递了在原始对象可调用时不合理的关键字参数，将引发一个`TypeError`。
- en: Trick `isinstance` into thinking that the mock object is of the original object's
    type
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欺骗`isinstance`认为模拟对象是原始对象类型的
- en: Mock objects made by `create_autospec` share this trait with all of their children
    as well, which is usually what you want. If you really just want a specific mock
    to be specced, while its children are not, you can pass the template object into
    the `Mock` constructor using the `spec` keyword.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由`create_autospec`创建的模拟对象与其所有子对象也共享这一特性，这通常是您想要的。如果您确实只想让特定的模拟对象被specced，而其子对象不是，您可以使用`spec`关键字将模板对象传递给`Mock`构造函数。
- en: 'Here''s a short demonstration of using `create_autospec`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用`create_autospec`的简短演示：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Mocking function or method side effects
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟函数或方法副作用
- en: Sometimes, for a mock object to successfully take the place of a function or
    method means that the mock object has to actually perform calls to other functions,
    or set variable values, or generally do whatever a function can do.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，为了使模拟对象能够成功地取代一个函数或方法，模拟对象实际上必须调用其他函数，设置变量值，或者一般地执行函数可以做的任何事情。
- en: This need is less common than you might think, and it's also somewhat dangerous
    for testing purposes because, when your mock objects can execute arbitrary code,
    there's a possibility that they stop being a simplifying tool for enforcing test
    isolation, and become a complex part of the problem instead.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这种需求不如你想象的那么常见，而且对于测试目的来说也有些危险，因为当你的模拟对象可以执行任意代码时，它们可能会停止成为强制测试隔离的简化工具，反而成为问题的一个复杂部分。
- en: Having said that, there are still times when you need a mocked function to do
    something more complex than simply returning a value, and we can use the `side_effect`
    attribute of mock objects to achieve this. We've seen `side_effect` before, when
    we assigned an iterable of return values to it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，仍然有需要模拟函数执行比简单地返回值更复杂操作的情况，我们可以使用模拟对象的 `side_effect` 属性来实现这一点。我们之前已经见过
    `side_effect`，当时我们给它分配了一个返回值序列。
- en: If you assign a callable to `side_effect`, this callable will be called when
    the mock object is called and passed the same parameters. If the `side_effect`
    function raises an exception, this is what the mock object does as well; otherwise,
    the `side_effect` return value is returned by the mock object.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将一个可调用对象分配给 `side_effect`，当模拟对象被调用并传递相同的参数时，这个可调用对象将被调用。如果 `side_effect`
    函数引发异常，模拟对象也会这样做；否则，模拟对象会返回 `side_effect` 的返回值。
- en: In other words, if you assign a function to a mock object's `side_effect` attribute,
    this mock object in effect becomes that function with the only important difference
    being that the mock object still records the details of how it's used.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果你将一个函数分配给模拟对象的 `side_effect` 属性，这个模拟对象实际上就变成了那个函数，唯一的区别是模拟对象仍然记录了它的使用细节。
- en: The code in a `side_effect` function should be minimal, and should not try to
    actually do the job of the code the mock object is replacing. All it should do
    is perform any expected externally visible operations and then return the expected
    `result.Mock` object assertion methods
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`side_effect` 函数中的代码应该是最小的，并且不应该尝试实际执行模拟对象所替代的代码的工作。它应该做的只是执行任何预期的外部可见操作，然后返回预期的
    `result.Mock` 对象断言方法。'
- en: As we saw in the *Standard mock objects* section, you can always write code
    that checks the `mock_calls` attribute of mock objects to see whether or not things
    are behaving as they should. However, there are some particularly common checks
    that have already been written for you, and are available as assertion methods
    of the mock objects themselves. As is normal for assertions, these assertion methods
    return `None` if they pass, and raise an `AssertionError` if they fail.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 *标准模拟对象* 部分所看到的，你总是可以编写代码来检查模拟对象的 `mock_calls` 属性，以查看事物是否按预期运行。然而，已经为你编写了一些特别常见的检查，这些检查作为模拟对象的断言方法提供。对于断言来说，这些断言方法在通过时返回
    `None`，在失败时引发 `AssertionError`。
- en: The `assert_called_with` method accepts an arbitrary collection of arguments
    and keyword arguments, and raises an `AssertionError` unless these parameters
    were passed to the mock the last time it was called.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert_called_with` 方法接受任意集合的参数和关键字参数，除非这些参数在上次调用模拟对象时被传递，否则会引发 `AssertionError`。'
- en: The `assert_called_once_with` method behaves like `assert_called_with`, except
    that it also checks whether the mock was only called once and raises `AssertionError`
    if that is not true.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert_called_once_with` 方法的表现类似于 `assert_called_with`，除了它还会检查模拟对象是否只被调用了一次。如果这不是真的，则会引发
    `AssertionError`。'
- en: The `assert_any_call` method accepts arbitrary arguments and keyword arguments,
    and raises an `AssertionError` if the mock object has never been called with these
    parameters.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert_any_call` 方法接受任意参数和关键字参数，如果模拟对象从未使用这些参数被调用，则会引发 `AssertionError`。'
- en: We've already seen the `assert_has_calls` method. This method accepts a list
    of call objects, checks whether they appear in the history in the same order,
    and raises an exception if they do not. Note that "in the same order" does not
    necessarily mean "next to each other." There can be other calls in between the
    listed calls as long as all of the listed calls appear in the proper sequence.
    This behavior changes if you assign a true value to the `any_order` argument.
    In that case, `assert_has_calls` doesn't care about the order of the calls, and
    only checks whether they all appear in the history.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了`assert_has_calls`方法。此方法接受一个调用对象列表，检查它们是否以相同的顺序出现在历史记录中，如果不出现，则引发异常。请注意，“以相同的顺序”并不一定意味着“相邻”。只要列出的调用都按正确的顺序出现，列表之间可以有其他调用。如果你将`any_order`参数设置为true值，则此行为会改变。在这种情况下，`assert_has_calls`不会关心调用的顺序，只检查它们是否都出现在历史记录中。
- en: The `assert_not_called` method raises an exception if the mock has ever been
    called.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert_not_called`方法如果模拟对象曾被调用，将引发异常。'
- en: Mocking containers and objects with a special behavior
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟具有特殊行为的容器和对象
- en: 'One thing the `Mock` class does not handle is the so-called magic methods that
    underlie Python''s special syntactic constructions: `__getitem__`, `__add__`,
    and so on. If you need your mock objects to record and respond to magic methods—in
    other words, if you want them to pretend to be container objects such as dictionaries
    or lists, or respond to mathematical operators, or act as context managers or
    any of the other things where syntactic sugar translates it into a method call
    underneath—you''re going to use `unittest.mock.MagicMock` to create your mock
    objects.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mock`类没有处理的是Python特殊语法构造背后的所谓魔法方法：`__getitem__`、`__add__`等等。如果你需要你的模拟对象记录并响应魔法方法——换句话说，如果你想它们假装是字典或列表等容器对象，或者响应数学运算符，或者作为上下文管理器或任何其他将语法糖转换为方法调用的东西——你将使用`unittest.mock.MagicMock`来创建你的模拟对象。'
- en: 'There are a few magic methods that are not supported even by `MagicMock`, due
    to details of how they (and mock objects) work: `__getattr__`, `__setattr__`,
    `__init__` , `__new__`, `__prepare__`, `__instancecheck__`, `__subclasscheck__`,
    and `__del__`.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们（和模拟对象）的工作细节，有一些魔法方法甚至不被`MagicMock`支持：`__getattr__`、`__setattr__`、`__init__`、`__new__`、`__prepare__`、`__instancecheck__`、`__subclasscheck__`和`__del__`。
- en: 'Here''s a simple example in which we use `MagicMock` to create a mock object
    supporting the `in` operator:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子，我们使用`MagicMock`创建一个支持`in`运算符的模拟对象：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Things work similarly with the other magic methods. For example, addition:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 其他魔法方法的工作方式也类似。例如，加法：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice that the return value of the addition is a mock object, a child of the
    original mock object, but the `in` operator returned a Boolean value. Python ensures
    that some magic methods return a value of a particular type, and will raise an
    exception if that requirement is not fulfilled. In these cases, `MagicMock's`
    implementations of the methods return a best-guess value of the proper type, instead
    of a child mock object.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，加法操作的返回值是一个模拟对象，它是原始模拟对象的子对象，但`in`运算符返回了一个布尔值。Python确保某些魔法方法返回特定类型的价值，如果不符合该要求，将引发异常。在这些情况下，`MagicMock`的方法实现返回一个最佳猜测的正确类型值，而不是子模拟对象。
- en: 'There''s something you need to be careful of when it comes to the in-place
    mathematical operators, such as `+=` (`__iadd__`) and `|=` (`__ior__`), and that
    is the fact that `MagicMock` handles them somewhat strangely. What it does is
    still useful, but it might well catch you by surprise:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用原地数学运算符（如`+=`（`__iadd__`）和`|=`（`__ior__`））时，你需要小心的一点是，`MagicMock`处理它们的方式有些奇怪。它所做的仍然是有用的，但它可能会让你感到意外：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What was that? Did it erase our call history? Fortunately, no, it didn't. What
    it did was assign the child mock created by the addition operation to the variable
    called mock. That is entirely in accordance with how the in-place math operators
    are supposed to work. Unfortunately, it has still cost us our ability to access
    the call history, since we no longer have a variable pointing at the parent mock
    object.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 那是什么？它删除了我们的通话记录吗？幸运的是，没有。它所做的只是将通过加法操作创建的子模拟对象分配给名为mock的变量。这完全符合原地数学运算符应有的工作方式。不幸的是，它仍然使我们失去了访问通话记录的能力，因为我们不再有一个指向父模拟对象的变量的引用。
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Make sure that you have the parent mock object set aside in a variable that
    won't be reassigned, if you're going to be checking in-place math operators. Also,
    you should make sure that your mocked in-place operators return the result of
    the operation, even if that just means `return self.return_value`, because otherwise
    Python will assign `None` to the left-hand variable.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算检查就地数学运算符，请确保将父模拟对象放在一个不会被重新分配的变量中。此外，你应该确保你的模拟就地运算符返回操作的结果，即使这意味着`return
    self.return_value`，否则Python将把`None`分配给左边的变量。
- en: 'There''s another detailed way in which in-place operators work that you should
    keep in mind:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在地运算符还有另一个你应该记住的详细工作方式：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Because the result of the operation is assigned to the original variable, a
    series of in-place math operations builds up a chain of child mock objects. If
    you think about it, that's the right thing to do, but it is rarely what people
    expect at first.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因为操作的结果被分配给了原始变量，一系列的就地数学运算构建了一个子模拟对象链。如果你这么想，那是对的，但人们一开始很少期望是这样。
- en: Mock objects for properties and descriptors
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性和描述符的模拟对象
- en: 'There''s another category of things that basic `Mock` objects don''t do a good
    job of emulating: **descriptors**.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的`Mock`对象在模拟某些事物方面并不擅长：**描述符**。
- en: Descriptors are objects that allow you to interfere with the normal variable
    access mechanism. The most commonly used descriptors are created by Python's property
    built-in function, which simply allows you to write functions to control getting,
    setting, and deleting a variable.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符是允许你干扰正常变量访问机制的对象。最常用的描述符是由Python的内置函数`property`创建的，它简单地允许你编写函数来控制获取、设置和删除变量。
- en: To mock a property (or other descriptor), create a `unittest.mock.PropertyMock`
    instance and assign it to the property name. The only complication is that you
    can't assign a descriptor to an object instance; you have to assign it to the
    object's type because descriptors are looked up in the type without first checking
    the instance.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要模拟属性（或其他描述符），创建一个`unittest.mock.PropertyMock`实例并将其分配给属性名称。唯一的复杂性是你不能将描述符分配给对象实例；你必须将其分配给对象的类型，因为描述符是在类型中查找的，而不是首先检查实例。
- en: 'That''s not hard to do with mock objects, fortunately:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，用模拟对象做这件事并不难：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The thing to be mindful of here is that the property is not a child of the object
    named mock. Because of this, we have to keep it around in its own variable because
    otherwise we'd have no way of accessing its history.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要注意的事情是，该属性不是名为mock的对象的子属性。正因为如此，我们必须保留它自己的变量，否则我们就无法访问其历史记录。
- en: The `PropertyMock` objects record variable lookup as a call with no parameters,
    and variable assignment as a call with the new value as a parameter.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`PropertyMock`对象将变量查找记录为不带参数的调用，将变量赋值记录为带有新值的参数的调用。'
- en: Tip
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can use a `PropertyMock` object if you actually need to record variable
    accesses in your mock object history. Usually you don't need to do that, but the
    option exists.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实需要在模拟对象的历史记录中记录变量访问，可以使用`PropertyMock`对象。通常你不需要这样做，但这个选项是存在的。
- en: 'Even though you set a property by assigning it to an attribute of a type, you
    don''t have to worry about having your `PropertyMock` objects bleed over into
    other tests. Each `Mock` you create has its own type object, even though they
    all claim to be of the same class:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你是通过将属性分配给类型的属性来设置属性的，你也不必担心你的`PropertyMock`对象会溢出到其他测试中。你创建的每个`Mock`都有自己的类型对象，尽管它们都声称属于同一个类：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Thanks to this feature, any changes that you make to a mock object's type object
    are unique to that specific mock object.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了这个特性，你对模拟对象类型对象所做的任何更改都是针对该特定模拟对象的。
- en: Mocking file objects
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟文件对象
- en: It's likely that you'll occasionally need to replace a file object with a mock
    object. The `unittest.mock` library helps you with this by providing `mock_open`,
    which is a factory for fake open functions. These functions have the same interface
    as the real open function, but they return a mock object that's been configured
    to pretend that it's an open file object.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会偶尔需要用模拟对象替换文件对象。`unittest.mock`库通过提供`mock_open`来帮助你，这是一个伪造打开函数的工厂。这些函数具有与真实打开函数相同的接口，但它们返回一个配置为假装是打开文件对象的模拟对象。
- en: 'This sounds more complicated than it is. See for yourself:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来比实际情况要复杂。请亲自看看：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you pass a string value to the `read_data` parameter, the mock file object
    that eventually gets created will use that value as the data source when its read
    methods get called. As of Python 3.4.0, `read_data` only supports string objects,
    not bytes.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将字符串值传递给 `read_data` 参数，最终创建的模拟文件对象将在其读取方法被调用时使用该值作为数据源。截至 Python 3.4.0，`read_data`
    只支持字符串对象，不支持字节。
- en: If you don't pass `read_data`, `read` method calls will return an empty string.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有传递 `read_data`，`read` 方法调用将返回一个空字符串。
- en: The problem with the previous code is that it makes the real open function inaccessible,
    and leaves a mock object lying around where other tests might stumble over it.
    Read on to see how to fix these problems.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码的问题在于它使真实打开函数不可访问，并留下一个模拟对象，其他测试可能会遇到它。请继续阅读以了解如何解决这些问题。
- en: Replacing real code with mock objects
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用模拟对象替换真实代码
- en: The `unittest.mock` library gives a very nice tool for temporarily replacing
    objects with mock objects, and then undoing the change when our test is done.
    This tool is `unittest.mock.patch`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest.mock` 库提供了一个非常棒的临时用模拟对象替换对象的工具，并在我们的测试完成后撤销更改。这个工具就是 `unittest.mock.patch`。'
- en: 'There are a lot of different ways in which that patch can be used: it works
    as a context manager, a function decorator, and a class decorator; additionally,
    it can create a mock object to use for the replacement or it can use the replacement
    object that you specify. There are a number of other optional parameters that
    can further adjust the behavior of the patch.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 那个 `patch` 可以以多种不同的方式使用：它作为一个上下文管理器、一个函数装饰器和一个类装饰器；此外，它还可以创建一个用于替换的模拟对象，或者使用您指定的替换对象。还有一些其他可选参数可以进一步调整
    `patch` 的行为。
- en: 'Basic usage is easy:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 基本用法很简单：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, `patch` dropped the mock open function created by `mock_open`
    over the top of the real open function; then, when we left the context, it replaced
    the original for us automatically.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`patch` 将由 `mock_open` 创建的模拟打开函数覆盖在真实打开函数之上；然后，当我们离开上下文时，它会自动为我们替换原始函数。
- en: The first parameter of `patch` is the only one that is required. It is a string
    describing the absolute path to the object to be replaced. The path can have any
    number of package and subpackage names, but it must include the module name and
    the name of the object inside the module that is being replaced. If the path is
    incorrect, `patch` will raise an `ImportError`, `TypeError`, or `AttributeError`,
    depending on what exactly is wrong with the path.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`patch` 的第一个参数是唯一必需的参数。它是一个描述要替换的对象的绝对路径的字符串。路径可以包含任意数量的包和子包名称，但必须包括模块名称和模块中被替换的对象的名称。如果路径不正确，`patch`
    将根据路径的具体错误抛出 `ImportError`、`TypeError` 或 `AttributeError`。'
- en: 'If you don''t want to worry about making a mock object to be the replacement,
    you can just leave that parameter off:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想担心创建一个模拟对象作为替换，您可以直接省略该参数：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `patch` function creates a new `MagicMock` for you if you don't tell it
    what to use for the replacement object. This usually works pretty well, but you
    can pass the new parameter (also the second parameter, as we used it in the first
    example of this section) to specify that the replacement should be a particular
    object; or you can pass the `new_callable` parameter to make patch use the value
    of that parameter to create the replacement object.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有告诉 `patch` 使用什么作为替换对象，`patch` 函数将为您创建一个新的 `MagicMock`。这通常工作得很好，但您可以通过传递新的参数（也是本节第一个示例中的第二个参数）来指定替换对象应该是特定的对象；或者您可以通过传递
    `new_callable` 参数来让 `patch` 使用该参数的值来创建替换对象。
- en: 'We can also force the patch to use `create_autospec` to make the replacement
    object, by passing `autospec=True`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过传递 `autospec=True` 来强制 `patch` 使用 `create_autospec` 创建替换对象：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `patch` function will normally refuse to replace an object that does not
    exist; however, if you pass it `create=True`, it will happily drop a mock object
    wherever you like. Naturally, this is not compatible with `autospec=True`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`patch` 函数会拒绝替换不存在的对象；但是，如果您传递 `create=True`，它将愉快地在您喜欢的任何地方放置一个模拟对象。当然，这与
    `autospec=True` 不兼容。
- en: The `patch` function covers the most common cases. There are a few related functions
    that handle less common but still useful cases.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`patch` 函数涵盖了最常见的用例。还有一些相关的函数处理较少见但仍很有用的用例。'
- en: The `patch.object` function does the same thing as `patch`, except that, instead
    of taking the path string, it accepts an object and an attribute name as its first
    two parameters. Sometimes this is more convenient than figuring out the path to
    an object. Many objects don't even have valid paths (for example, objects that
    exist only in a function local scope), although the need to patch them is rarer
    than you might think.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`patch.object`函数与`patch`做的是同样的事情，只不过它接受一个对象和一个属性名称作为其前两个参数，而不是路径字符串。有时这比找出对象的路径更方便。许多对象甚至没有有效的路径（例如，仅存在于函数局部作用域中的对象），尽管修补它们的需求比您想象的要少。'
- en: The `patch.dict` function temporarily drops one or more objects into a dictionary
    under specific keys. The first parameter is the target dictionary; the second
    is a dictionary from which to get the key and value pairs to put into the target.
    If you pass `clear=True`, the target will be emptied before the new values are
    inserted. Notice that `patch.dict` doesn't create the replacement values for you.
    You'll need to make your own mock objects, if you want them.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`patch.dict`函数临时将一个或多个对象放入字典中的特定键下。第一个参数是目标字典；第二个参数是从中获取键值对以放入目标字典的字典。如果您传递`clear=True`，则在插入新值之前将清空目标字典。请注意，`patch.dict`不会为您创建替换值。如果您想使用它们，您需要自己创建模拟对象。'
- en: Mock objects in action
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟对象在行动
- en: That was a lot of theory interspersed with unrealistic examples. Let's take
    a look at what we've learned and apply it to the tests from the previous chapters
    for a more realistic view of how these tools can help us.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 那是很多理论与不切实际的例子交织在一起。让我们回顾一下我们已经学到的内容，并将其应用到前几章的测试中，以便更真实地了解这些工具如何帮助我们。
- en: Better PID tests
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更好的PID测试
- en: The PID tests suffered mostly from having to do a lot of extra work to patch
    and unpatch `time.time`, and had some difficulty breaking the dependence on the
    constructor.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: PID测试主要受到必须进行大量额外工作来修补和取消修补`time.time`的影响，并且在打破对构造函数的依赖方面有一些困难。
- en: Patching time.time
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修补time.time
- en: 'Using `patch`, we can remove a lot of the repetitiveness of dealing with `time.time`;
    this means that it''s less likely that we''ll make a mistake somewhere, and saves
    us from spending time on something that''s kind of boring and annoying. All of
    the tests can benefit from similar changes:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`patch`，我们可以消除处理`time.time`的许多重复性；这意味着我们不太可能在某个地方犯错误，并节省了我们花费时间在某种程度上既无聊又令人烦恼的事情上。所有的测试都可以从类似的变化中受益：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Apart from using `patch` to handle `time.time`, this test has been changed.
    We can now use `assert` to check whether things are correct instead of having
    doctest compare the values directly. There's hardly any difference between the
    two approaches, except that we can place the `assert` statements inside the context
    managed by `patch`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`patch`来处理`time.time`之外，这个测试已经发生了变化。我们现在可以使用`assert`来检查事物是否正确，而不是让doctest直接比较值。这两种方法几乎没有区别，只不过我们可以将`assert`语句放在`patch`管理的上下文中。
- en: Decoupling from the constructor
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与构造函数解耦
- en: 'Using mock objects, we can finally separate the tests for the PID methods from
    the constructor, so that mistakes in the constructor cannot affect the outcome:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模拟对象，我们最终可以将PID方法的测试与构造函数分开，这样构造函数中的错误就不会影响结果：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: What we've done here is set up a mock object with the proper attributes, and
    pass it into `calculate_response` as the self-parameter. We could do this because
    we didn't create a PID instance at all. Instead, we looked up the method's function
    inside the class and called it directly, allowing us to pass whatever we wanted
    as the self-parameter instead of having Python's automatic mechanisms handle it.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是设置一个具有适当属性的模拟对象，并将其作为self参数传递给`calculate_response`。我们可以这样做，因为我们根本就没有创建PID实例。相反，我们在类内部查找方法的函数并直接调用它，这使得我们可以传递任何我们想要的作为self参数，而不是让Python的自动机制来处理它。
- en: Never invoking the constructor means that we're immune to any errors it might
    contain, and guarantees that the object state is exactly what we expect here in
    our `calculate_response` test.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 从不调用构造函数意味着我们对它可能包含的任何错误免疫，并保证了对象状态正是我们在`calculate_response`测试中期望的。
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've learned about a family of objects that specialize in
    impersonating other classes, objects, methods, and functions. We've seen how to
    configure these objects to handle corner cases where their default behavior isn't
    sufficient, and we've learned how to examine the activity logs that these mock
    objects keep, so that we can decide whether the objects are being used properly
    or not.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了一组专门模仿其他类、对象、方法和函数的对象家族。我们看到了如何配置这些对象以处理它们默认行为不足的边缘情况，并且我们学习了如何检查这些模拟对象所保留的活动日志，以便我们可以决定这些对象是否被正确使用。
- en: In the next chapter, we'll look at Python's `unittest` package, a more structured
    testing framework that is less useful for communicating with people than `doctest`
    is, but better able to handle the complexities of large-scale testing.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 Python 的 `unittest` 包，这是一个比 `doctest` 更为结构化的测试框架，它在与人沟通方面不如 `doctest`
    有用，但更能处理大规模测试的复杂性。
