- en: Lists and Pointer Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表和指针结构
- en: You will have already seen lists in Python. They are convenient and powerful.
    Normally, any time you need to store something in a list, you use python's built-in
    list implementation. In this chapter, however, we are more interested in understanding
    how lists work. So we are going to study list internals. As you will notice, there
    are different types of lists.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在Python中见过列表了。它们既方便又强大。通常，每次你需要将某物存储在列表中时，你都会使用Python的内置列表实现。然而，在本章中，我们更感兴趣的是了解列表是如何工作的。因此，我们将研究列表的内部机制。正如你所注意到的，存在不同类型的列表。
- en: Python's list implementation is designed to be powerful and to encompass several
    different use cases. We are going to be a bit more strict in our definition of
    what a list is.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Python的列表实现旨在强大且涵盖多个不同的用例。我们将对我们的列表定义更加严格。
- en: The concept of a node is very important to lists. We shall discuss them in this
    chapter, but this concept will, in different forms, come back throughout the rest
    of the book.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 节点的概念对列表非常重要。我们将在本章中讨论它们，但这个概念将以不同的形式贯穿整本书。
- en: 'The focus of this chapter will be the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点将是以下内容：
- en: Understand pointers in Python
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Python中的指针
- en: Treating the concept of nodes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理节点概念
- en: Implementing singly, doubly, and circularly linked lists
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现单链表、双链表和循环链表
- en: In this chapter, we are going to deal quite a bit with pointers. So it may be
    useful to remind ourselves what these are. To begin with, imagine that you have
    a house that you want to sell. Lacking time, you contact an agent to find interested
    buyers. So you pick up your house and take it over to the agent, who will in turn
    carry the house to anybody who may want to buy it. Ludicrous, you say? Now imagine
    that you have a few Python functions that work with images. So you pass high-resolution
    image data between your functions.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将大量处理指针。因此，提醒自己这些是什么可能是有用的。首先，想象一下你有一所房子想要出售。由于缺乏时间，你联系了一个经纪人来寻找感兴趣的买家。所以你拿起你的房子，带到经纪人那里，经纪人会把它带给任何可能想买的人。你可能会说这是荒谬的？现在想象一下你有几个处理图像的Python函数。所以你将在你的函数之间传递高分辨率的图像数据。
- en: Of course, you don't carry your house around. What you would do is write the
    address of the house down on a piece of scrap paper and hand it over to the agent.
    The house remains where it is, but the note containing the directions to the house
    is passed around. You might even write it down on several pieces of paper. Each
    one is small enough to fit in your wallet, but they all point to the same house.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不会把你的房子随身携带。你会做的是在一张废纸上写下房子的地址，然后把它交给经纪人。房子仍然在那里，但包含去房子方向的纸条被传递开来。你甚至可能把它写在几页纸上。每一页都足够小，可以放进你的钱包里，但它们都指向同一所房子。
- en: As it turns out, things are not very different in Python land. Those large image
    files remain in one single place in memory. What you do is create variables that
    hold the locations of those images in memory. These variables are small and can
    easily be passed around between different functions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在Python的世界里，事情并没有太大的不同。那些大图像文件在内存中仍然只有一个地方。你所做的是创建变量来保存这些图像在内存中的位置。这些变量很小，可以很容易地在不同的函数之间传递。
- en: 'That is the big benefit of pointers: they allow you to point to a potentially
    large segment of memory with just a simple memory address.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是指针的大好处：它们允许你用一个简单的内存地址指向一个可能很大的内存段。
- en: Support for pointers exists in your computer's hardware, where it is known as
    indirect addressing.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 指针的支持存在于你的计算机硬件中，这被称为间接寻址。
- en: 'In Python, you don''t manipulate pointers directly, unlike in some other languages,
    such as C or Pascal. This has led some people to think that pointers aren''t used
    in Python. Nothing could be further from the truth. Consider this assignment in
    the Python interactive shell:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，你不会像在C或Pascal等一些其他语言中那样直接操作指针。这导致一些人认为Python中没有使用指针。这完全不是事实。考虑在Python交互式shell中的这个赋值操作：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We would normally say that `s` is a variable of the type set. That is, `s` is
    a set. This is not strictly true, however. The variable `s` is rather a reference
    (a "safe" pointer) to a set. The set constructor creates a set somewhere in memory
    and returns the memory location where that set starts. This is what gets stored
    in `s`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常会说`s`是一个集合类型的变量。也就是说，`s`是一个集合。然而，这并不完全正确。变量`s`实际上是一个指向集合的引用（一个“安全的”指针）。集合构造函数在内存中创建一个集合，并返回该集合开始的内存位置。这就是存储在`s`中的内容。
- en: Python hides this complexity from us. We can safely assume that `s` is a set
    and that everything works fine.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Python隐藏了这种复杂性。我们可以安全地假设`s`是一个集合，并且一切正常。
- en: Arrays
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: An array is a sequential list of data. Being sequential means that each element
    is stored right after the previous one in memory. If your array is really big
    and you are low on memory, it could be impossible to find large enough storage
    to fit your entire array. This will lead to problems.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一系列数据的顺序列表。顺序意味着每个元素都存储在内存中紧随前一个元素之后。如果你的数组真的很大，而你内存又不足，可能无法找到足够大的存储空间来容纳整个数组。这将导致问题。
- en: Of course, the flip side of the coin is that arrays are very fast. Since each
    element follows from the previous one in memory, there is no need to jump around
    between different memory locations. This can be a very important point to take
    into consideration when choosing between a list and an array in your own real-world
    applications.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，硬币的另一面是数组非常快。由于每个元素在内存中紧随前一个元素，因此不需要在不同的内存位置之间跳跃。这在选择列表和数组时是一个非常重要的考虑点，尤其是在你自己的实际应用中。
- en: In the latter parts of [Chapter 2](ee04d80f-97b1-4a1b-b61f-8a830c0b78c5.xhtml),
    *Python Data Types and Structures*, we looked at the array data type and discovered
    the various operations that could be performed on it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ee04d80f-97b1-4a1b-b61f-8a830c0b78c5.xhtml)的后面部分，*Python数据类型和结构*中，我们研究了数组数据类型，并发现了可以对其执行的各种操作。
- en: Pointer structures
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指针结构
- en: Contrary to arrays, pointer structures are lists of items that can be spread
    out in memory. This is because each item contains one or more links to other items
    in the structure. What type of links these are dependent on the type of structure
    we have. If we are dealing with linked lists, then we will have links to the next
    (and possibly previous) items in the structure. In the case of a tree, we have
    parent-child links as well as sibling links. In a tile-based game where the game
    map is built up of hexes, each node will have links to up to six adjacent map
    cells.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组相反，指针结构是内存中可以分散的项的列表。这是因为每个项包含一个或多个指向结构中其他项的链接。这些链接的类型取决于我们拥有的结构类型。如果我们处理的是链表，那么我们将有指向结构中下一个（以及可能的前一个）项的链接。在树的情况下，我们有父子链接以及兄弟链接。在一个基于瓦片的游戏中，游戏地图由六边形组成，每个节点将链接到最多六个相邻的地图单元格。
- en: There are several benefits with pointer structures. First of all, they don't
    require sequential storage space. Second, they can start small and grow arbitrarily
    as you add more nodes to the structure.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 指针结构有几个优点。首先，它们不需要顺序存储空间。其次，它们可以从小开始，随着你向结构中添加更多节点而任意增长。
- en: As noted in [Chapter 2](ee04d80f-97b1-4a1b-b61f-8a830c0b78c5.xhtml), *Python
    Data Types and Structures*, however, this comes at a cost. If you have a list
    of integers, each node is going to take up the space of an integer, as well as
    an additional integer for storing the pointer to the next node.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[第2章](ee04d80f-97b1-4a1b-b61f-8a830c0b78c5.xhtml)中提到的，*Python数据类型和结构*，然而，这是有代价的。如果你有一个整数列表，每个节点将占用一个整数的空间，以及一个额外的整数来存储指向下一个节点的指针。
- en: Nodes
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点
- en: At the heart of lists (and several other data structures) is the concept of
    a node. Before we go any further, let us consider this idea for a while.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 列表（以及几种其他数据结构）的核心是节点这个概念。在我们继续前进之前，让我们考虑一下这个想法。
- en: 'To begin with, we shall create a few strings:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一些字符串：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now you have three variables, each with a unique name, a type, and a value.
    What we do not have is a way of saying in which way the variables relate to each
    other. Nodes allow us to do this. A node is a container of data, together with
    one or more links to other nodes. A link is a pointer.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有三个变量，每个变量都有一个独特的名称、类型和值。我们还没有一种方式来说明变量之间是如何相互关联的。节点允许我们做到这一点。节点是数据的容器，同时包含一个或多个指向其他节点的链接。链接是一个指针。
- en: A simple type of node is one that only has a link to the next node.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 简单类型的节点是只包含指向下一个节点的链接的节点。
- en: 'Of course, knowing what we do about pointers, we realize that this is not entirely
    true. The string is not really stored in the node, but is rather a pointer to
    the actual string:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，了解我们关于指针的知识，我们意识到这并不完全正确。字符串并不是真正存储在节点中，而是一个指向实际字符串的指针：
- en: '![](img/image_04_001.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_001.jpg)'
- en: Thus the storage requirement for this simple node is two memory addresses. The
    data attribute of the nodes are pointers to the strings `eggs` and `ham`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个简单节点的存储需求是两个内存地址。节点的数据属性是指向字符串`eggs`和`ham`的指针。
- en: Finding endpoints
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找端点
- en: 'We have created three nodes: one containing **eggs**, one **ham**, and another
    **spam**. The **eggs** node points to the **ham** node, which in turn points to
    the **spam** node. But what does the **spam** node point to? Since this is the
    last element in the list, we need to make sure its next member has a value that
    makes this clear.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了三个节点：一个包含**鸡蛋**，一个**火腿**，另一个**垃圾邮件**。**鸡蛋**节点指向**火腿**节点，而**火腿**节点又指向**垃圾邮件**节点。但**垃圾邮件**节点指向什么呢？由于这是列表中的最后一个元素，我们需要确保其下一个成员具有一个值，使其清晰明了。
- en: 'If we make the last element point to nothing then we make this fact clear.
    In python, we will use the special value `None` to denote nothing:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将最后一个元素指向空，那么我们就清楚地表明了这一点。在Python中，我们将使用特殊值`None`来表示空：
- en: '![](img/image_04_007.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_04_007.jpg)'
- en: The last node has its next point pointing to None. As such it is the last node
    in the chain of nodes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个节点的下一个指针指向`None`。因此，它是节点链中的最后一个节点。
- en: Node
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点
- en: 'Here is a simple node implementation of what we have discussed so far:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们之前讨论的简单节点实现的示例：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Do not confuse the concept of a node with Node.js, a server-side technology
    implemented in JavaScript.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将节点的概念与Node.js混淆，Node.js是一种用JavaScript实现的客户端技术。
- en: The `next` pointer is initialized to `None`, meaning that unless you change
    the value of `next`, the node is going to be an end-point. This is a good idea,
    so that we do not forget to terminate the list properly.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`next`指针被初始化为`None`，这意味着除非你更改`next`的值，否则节点将是一个终点。这是一个好主意，这样我们就不会忘记正确地终止列表。'
- en: You can add other things to the `node` class as you see fit. Just make sure
    that you keep in mind the distinction between node and data. If your node is going
    to contain customer data, then create a `Customer` class and put all the data
    there.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要向`node`类添加其他内容。只需确保你记住节点和数据之间的区别。如果你的节点将包含客户数据，那么创建一个`Customer`类并将所有数据放在那里。
- en: 'One thing you may want to do is implement the `__str__` method so that it calls
    the `__str__` method of the contained object is called when the node object is
    passed to print:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想实现`__str__`方法，以便在节点对象传递给打印时调用包含对象的`__str__`方法：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Other node types
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他节点类型
- en: We have assumed nodes that have a pointer to the next node. This is probably
    the simplest type of node. However, depending on our requirements, we can create
    a number of other types of nodes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设节点具有指向下一个节点的指针。这可能是最简单的节点类型。然而，根据我们的需求，我们可以创建许多其他类型的节点。
- en: 'Sometimes we want to go from A to B, but at the same time from B to A. In that
    case, we add a previous pointer in addition to the next pointer:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们希望从A到B，同时从B到A。在这种情况下，我们除了下一个指针外，还添加一个前一个指针：
- en: '![](img/image_04_003.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_04_003.jpg)'
- en: As you can see from the figure, we let both the last and the first nodes point
    to `None`, to indicate that we have reached they form the boundary of our list
    end-point. The first node’s previous pointer points to None since it has no predecessor,
    just as the last item’s next pointer points to `None` because it no successor
    node.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，我们让最后一个和第一个节点都指向`None`，以表示我们已经到达了列表的边界，即列表的终点。第一个节点的前一个指针指向`None`，因为它没有前驱，就像最后一个项目的下一个指针指向`None`，因为它没有后续节点。
- en: 'You might also be creating tiles for a tile-based game. In such a case, instead
    of previous and next, you might use north, south, east, and west. There are more
    types of pointers, but the principle is the same. Tiles at the end of the map
    will point to `None`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还在为基于瓦片的游戏创建瓦片。在这种情况下，你可能会使用北、南、东和西，而不是上一个和下一个。还有更多类型的指针，但原则是相同的。地图末尾的瓦片将指向`None`：
- en: '![](img/image_04_004.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_04_004.jpg)'
- en: You can take this as far as you need to. If you need to be able to move north-west,
    north-east, south-east, and south-west as well, all you have to do is add these
    pointers to your `node` class.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要做得更远。如果你需要能够向北西、东北、东南和西南移动，你只需要将这些指针添加到你的`node`类中。
- en: Singly linked lists
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单链表
- en: A singly linked list is a list with only one pointer between two successive
    nodes. It can only be traversed in a single direction, that is, you can go from
    the first node in the list to the last node, but you cannot move from the last
    node to the first node.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 单链表是只有两个连续节点之间有一个指针的列表。它只能单向遍历，也就是说，你可以从列表的第一个节点到最后的节点，但不能从最后一个节点移动到第一个节点。
- en: 'We can actually use the `node` class that we created earlier to implement a
    very simple singly linked list:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上可以使用我们之前创建的`node`类来实现一个非常简单的单链表：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next we link the nodes together so that they form a *chain*:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将节点链接在一起，形成一个*链*：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To traverse the list, you could do something like the following. We start by
    setting the variable `current` to the first item in the list:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要遍历列表，您可以做一些类似以下的事情。我们首先将变量`current`设置为列表中的第一个项目：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the loop we print out the current element after which we set current to point
    to the next element in the list. We keep doing this until we have reached the
    end of the list.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中，我们在打印当前元素后，将`current`设置为列表中的下一个元素。我们一直这样做，直到我们到达列表的末尾。
- en: 'There are, however, several problems with this simplistic list implementation:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种简单列表实现有几个问题：
- en: It requires too much manual work by the programmer
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要程序员进行太多的手动工作
- en: It is too error-prone (this is a consequence of the first point)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这太容易出错（这是第一个问题的后果）
- en: Too much of the inner workings of the list is exposed to the programmer
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表的内部工作太多地暴露给了程序员
- en: We are going to address all these issues in the following sections.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下几节中解决所有这些问题。
- en: Singly linked list class
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单链表类
- en: 'A list is clearly a separate concept from a node. So we start by creating a
    very simple class to hold our list. We will start with a constructor that holds
    a reference to the very first node in the list. Since this list is initially empty,
    we will start by setting this reference to `None`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表显然是一个与节点不同的概念。因此，我们首先创建一个非常简单的类来保存我们的列表。我们将从一个构造函数开始，该构造函数保留对列表中第一个节点的引用。由于这个列表最初是空的，我们将首先将这个引用设置为`None`：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Append operation
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 追加操作
- en: The first operation that we need to perform is to append items to the list.
    This operation is sometimes called an insert operation. Here we get a chance to
    hide away the `Node` class. The user of our `list` class should really never have
    to interact with Node objects. These are purely for internal use.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要执行的第一项操作是将项目添加到列表中。这个操作有时被称为插入操作。在这里，我们有机会将`Node`类隐藏起来。我们的`list`类的用户实际上永远不需要与Node对象交互。这些都是纯粹的内部使用。
- en: 'A first shot at an `append()` method may look like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`append()`方法的第一次尝试可能看起来像这样：'
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We encapsulate data in a node, so that it now has the next pointer attribute.
    From here we check if there are any existing nodes in the list (that is, does
    `self.tail` point to a Node). If there is none, we make the new node the first
    node of the list; otherwise, find the insertion point by traversing the list to
    the last node, updating the next pointer of the last node to the new node.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在节点中封装数据，因此它现在具有下一个指针属性。从这里我们检查列表中是否存在任何现有节点（即`self.tail`是否指向一个Node）。如果没有，我们将新节点作为列表的第一个节点；否则，通过遍历列表到最后一个节点，更新最后一个节点的下一个指针到新节点。
- en: 'We can append a few items:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以追加一些项目：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'List traversal will work more or less like before. You will get the first element
    of the list from the list itself:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 列表遍历将大致与之前相同。您将从列表本身获取列表的第一个元素：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A faster append operation
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更快的追加操作
- en: 'There is a big problem with the append method in the previous section: it has
    to traverse the entire list to find the insertion point. This may not be a problem
    when there are just a few items in the list, but wait until you need to add thousands
    of items. Each append will be slightly slower than the previous one. A **O**(n)
    goes to prove how slow our current implementation of the `append` method will
    actually be.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中`append`方法有一个大问题：它必须遍历整个列表来找到插入点。当列表中只有几个项目时，这可能不是问题，但等到您需要添加数千个项目时。每次追加都会比上一次稍微慢一些。**O**(n)证明了我们的`append`方法当前实现实际上有多慢。
- en: 'To fix this, we will store, not only a reference to the first node in the list,
    but also a reference to the last node. That way, we can quickly append a new node
    at the end of the list. The worst case running time of the append operation is
    now reduced from **O**(n) to **O**(1). All we have to do is make sure the previous
    last node points to the new node, that is about to be appended to the list. Here
    is our updated code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将存储，不仅是对列表中第一个节点的引用，还有对最后一个节点的引用。这样，我们就可以快速将新节点追加到列表的末尾。追加操作的运行时间最坏情况现在从**O**(n)减少到**O**(1)。我们只需要确保上一个最后一个节点指向即将追加到列表中的新节点。以下是我们的更新代码：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Take note of the convention being used. The point at which we append new nodes
    is through `self.head`. The `self.tail` variable points to the first node in the
    list.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意正在使用的约定。我们通过`self.head`追加新节点。`self.tail`变量指向列表中的第一个节点。
- en: Getting the size of the list
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取列表的大小
- en: 'We would like to be able to get the size of the list by counting the number
    of nodes. One way we could do this is by traversing the entire list and increasing
    a counter as we go along:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够通过计数节点的数量来获取列表的大小。我们可以这样做的一种方法是在遍历整个列表的同时增加一个计数器：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This works, but list traversal is potentially an expensive operation that we
    should avoid when we can. So instead, we shall opt for another rewrite of the
    method. We add a size member to the `SinglyLinkedList` class, initializing it
    to 0 in the constructor. Then we increment size by one in the `append` method:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这有效，但列表遍历可能是一个昂贵的操作，我们应该在可能的情况下避免它。因此，我们将选择对方法进行另一种重写。我们在`SinglyLinkedList`类中添加一个`size`成员，在构造函数中将它初始化为0。然后在`append`方法中增加`size`的值：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Because we are now only reading the size attribute of the node object, and not
    using a loop to count the number of nodes in the list, we get to reduce the worst
    case running time from **O**(n) to **O**(1).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在只读取节点对象的`size`属性，而不是使用循环来计算列表中节点的数量，我们将运行时间从**O**(n)降低到**O**(1)。
- en: Improving list traversal
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进列表遍历
- en: 'If you notice how we traverse our list. That one place where we are still exposed
    to the `node` class. We need to use `node.data` to get the contents of the node
    and `node.next` to get the next node. But we mentioned earlier that client code
    should never need to interact with Node objects. We can achieve this by creating
    a method that returns a generator. It looks as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到我们如何遍历我们的列表。那个我们仍然暴露在`node`类的地方。我们需要使用`node.data`来获取节点的内容，以及`node.next`来获取下一个节点。但之前我们提到过，客户端代码不应该需要与Node对象交互。我们可以通过创建一个返回生成器的方法来实现这一点。它看起来如下所示：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now list traversal is much simpler and looks a lot better as well. We can completely
    ignore the fact that there is anything called a Node outside of the list:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在列表遍历要简单得多，看起来也好多了。我们可以完全忽略列表外有任何名为Node的东西：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that since the `iter()` method yields the data member of the node, our
    client code doesn't need to worry about that at all.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于`iter()`方法产生节点的数据成员，我们的客户端代码根本不需要担心这一点。
- en: Deleting nodes
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除节点
- en: Another common operation that you would need to be able to do on a list is to
    delete nodes. This may seem simple, but we'd first have to decide how to select
    a node for deletion. Is it going to be by an index number or by the data the node
    contains? Here we will choose to delete a node by the data it contains.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要能够在列表上执行的一个常见操作是删除节点。这看起来可能很简单，但我们必须首先决定如何选择要删除的节点。是按索引号还是按节点包含的数据来删除？在这里，我们将选择按节点包含的数据来删除节点。
- en: 'The following is a figure of a special case considered when deleting a node
    from the list:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在从列表中删除节点时考虑的特殊情况的图示：
- en: '![](img/image_04_005.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_005.jpg)'
- en: When we want to delete a node that is between two other nodes, all we have to
    do is make the previous node directly to the successor of its next node. That
    is, we simply cut the node to be deleted out of the chain as in the preceding
    image.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要删除位于两个其他节点之间的节点时，我们只需要让前一个节点直接指向其下一个节点的后继节点。也就是说，我们只是简单地将要删除的节点从链中切出来，就像前面的图像中那样。
- en: 'Here is the implementation of the `delete()` method may look like:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete()`方法的实现可能看起来如下所示：'
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It should take a **O**(n) to delete a node.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该以**O**(n)的时间复杂度来删除一个节点。
- en: List search
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表搜索
- en: 'We may also need a way to check whether a list contains an item. This method
    is fairly easy to implement thanks to the `iter()` method we previously wrote.
    Each pass of the loop compares the current data to the data being searched for.
    If a match is found, `True` is returned, or else `False` is returned:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能还需要一种方法来检查列表是否包含一个项目。由于我们之前已经编写了`iter()`方法，这个方法实现起来相当简单。循环的每次迭代都会将当前数据与要搜索的数据进行比较。如果找到匹配项，则返回`True`，否则返回`False`：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Clearing a list
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清除列表
- en: 'We may want a quick way to clear a list. Fortunately for us, this is very simple.
    All we do is clear the pointers `head` and `tail` by setting them to `None`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望有一种快速清除列表的方法。幸运的是，这对我们来说非常简单。我们只需将指针`head`和`tail`清空，将它们设置为`None`：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In one fell swoop, we orphan all the nodes at the `tail` and `head` pointers
    of the list. This has a ripple effect of orphaning all the nodes in between.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一举一动，我们将列表尾部的`tail`和头部的`head`指针上的所有节点都变成了孤儿。这会对中间的所有节点产生连锁反应，使它们也成为孤儿。
- en: Doubly linked lists
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双向链表
- en: Now that we have a solid grounding on what a singly linked list is and the kind
    of operations that can be performed on it, we shall now turn our focus one notch
    higher to the topic of doubly linked lists.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对单链表及其上可以执行的操作有了坚实的理解，我们现在将注意力提升一个层次，转向双链表的话题。
- en: 'A doubly linked list is somehow similar to a singly linked list in that we
    make use of the same fundamental idea of stringing nodes together. In a Singly
    linked list, there exists one link between each successive node. A node in a doubly
    linked list has two pointers: a pointer to the next node and a pointer to the
    previous node:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 双链表在某种程度上与单链表相似，因为我们使用了将节点串联在一起的基本思想。在单链表中，每个连续节点之间存在一个链接。双链表中的节点有两个指针：一个指向下一个节点，一个指向前一个节点：
- en: '![](img/image_04_006.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_04_006.jpg)'
- en: A node in a singly linked list can only determine the next node associated with
    it. But the referenced node or next node has no way of telling who is doing the
    referencing. The flow of direction is **only one way**.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 单链表中的节点只能确定与其关联的下一个节点。但被引用的节点或下一个节点没有方法知道是谁在进行引用。方向的流动是**单向的**。
- en: In a doubly linked list, we add to each node the ability to not only reference
    the next node but also the previous node.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在双链表中，我们给每个节点添加了不仅能够引用下一个节点，还能引用前一个节点的功能。
- en: 'Let''s examine the nature of the linkages that exist between two successive
    nodes for better understanding:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查两个连续节点之间存在的链接的性质，以便更好地理解：
- en: '![](img/image_04_007.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_04_007.jpg)'
- en: With the existence of two pointers that point to the next and previous nodes,
    doubly linked lists become equipped with certain capabilities.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在指向下一个和前一个节点的两个指针，双链表具备了某些功能。
- en: Doubly linked lists can be traversed in any direction. Depending on the operation
    being performed, a node within a doubly linked list can easily refer to its previous
    node where necessary without having to designate a variable to keep track of that
    node. Because a Singly linked list can only be traversed in one direction it may
    sometimes mean moving to the start or beginning of the list in order to effect
    certain changes buried within the list.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 双链表可以双向遍历。根据操作的类型，双链表中的节点可以很容易地引用其前一个节点，而无需指定一个变量来跟踪该节点。因为单链表只能单向遍历，有时可能意味着移动到列表的开始或开头，以便对列表中埋藏的某些更改产生影响。
- en: Since there is immediate access to both next and previous nodes, deletion operations
    are much easier to perform, as you will see later on in this chapter.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可以立即访问前一个和后一个节点，删除操作将更容易执行，正如你将在本章后面看到的那样。
- en: A doubly linked list node
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双链表节点
- en: 'The Python code that creates a class to capture what a doubly linked list node
    is includes in its initializing method, the `prev`, `next`, and `data` instance
    variables. When a node is newly created, all these variables default to `None`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Python代码创建一个类来捕捉双链表节点是什么，包括其初始化方法中的`prev`、`next`和`data`实例变量。当一个节点被新创建时，所有这些变量默认为`None`：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `prev` variable holds a reference to the previous node, while the `next`
    variable continues to hold a reference to the next node.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`prev`变量持有对前一个节点的引用，而`next`变量继续持有对下一个节点的引用。'
- en: Doubly linked list
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双链表
- en: 'It is still important to create a class that captures the data that our functions
    will be operating on:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然重要的是创建一个类来捕捉我们的函数将要操作的数据：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For the purposes of enhancing the `size` method, we also set the `count` instance
    variable to 0\. `head` and `tail` will point to the head and tail of the list
    when we begin to insert nodes into the list.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增强`size`方法，我们还设置了`count`实例变量为0。当我们开始向列表中插入节点时，`head`和`tail`将指向列表的头和尾。
- en: We adopt a new convention where `self.head` points to the beginner node of the
    list and `self.tail` points to the latest node added to the list. This is contrary
    to the convention we used in the singly linked list. There are no fixed rules
    as to the naming of the head and tail node pointers.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们采用一个新的约定，其中`self.head`指向列表的起始节点，`self.tail`指向最新添加到列表中的节点。这与我们在单链表中使用的约定相反。关于头和尾节点指针的命名没有固定的规则。
- en: Doubly linked lists also need to provide functions that return the size of the
    list, inserts into the list, and also deletes nodes from the list. We will be
    examining some of the code to do this. Let's commence with the `append` operation.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '双链表还需要提供返回列表大小、插入列表以及从列表中删除节点的函数。我们将检查执行这些操作的代码。让我们从`append`操作开始。 '
- en: Append operation
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加操作
- en: 'During an `append` operation, it is important to check whether the `head` is
    `None`. If it is `None`, it means that the list is empty and should have the `head`
    set pointing to the just-created node. The `tail` of the list is also pointed
    at the new node through the head. By the end of these series of steps, `head`
    and `tail` will now be pointing to the same node:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在`append`操作期间，检查`head`是否为`None`非常重要。如果是`None`，则意味着列表为空，应该将`head`设置为指向刚刚创建的节点。列表的`tail`也通过头部指向新节点。通过这些步骤的结束，`head`和`tail`现在将指向相同的节点：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The following diagram illustrates the head and tail pointers of the doubly linked
    list when a new node is added to an empty list.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了在空列表中添加新节点时双链表的头部和尾部指针：
- en: '![](img/04_01.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/04_01.jpg)'
- en: 'The `else` part of the algorithm is only executed if the list is not empty.
    The new node''s previous variable is set to the tail of the list:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的`else`部分仅在列表不为空时执行。新节点的上一个变量被设置为列表的尾部：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The tail''s next pointer (or variable) is set to the new node:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 尾部的下一个指针（或变量）被设置为新节点：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Lastly, we update the tail pointer to point to the new node:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将尾指针更新为新节点：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Since an `append` operation increases the number of nodes by one, we increase
    the counter by one:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`append`操作会使节点数量增加一个，因此我们将计数器增加一个：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A visual representation of the `append` operation is as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 添加操作的视觉表示如下：
- en: '![](img/image_04_009.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_04_009.jpg)'
- en: Delete operation
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除操作
- en: Unlike the singly linked list, where we needed to keep track of the previously
    encountered node anytime we traversed the whole length of the list, the doubly
    linked list avoids that whole step. This is made possible by the use of the previous
    pointer.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与单链表不同，在遍历整个列表长度时，我们需要跟踪遇到的先前节点，双链表通过使用前向指针避免了这一步骤。
- en: 'The algorithm for removing nodes from a doubly linked list caters for basically
    four scenarios before deletion of a node is completed. These are:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 从双链表中删除节点之前，算法基本上处理四种场景。这些是：
- en: When the search item is not found at all
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当搜索项根本找不到时
- en: When the search item is found at the very beginning of the list
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当搜索项在列表的非常开始处找到时
- en: When the search item is found at the tail end of the list
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当搜索项在列表的尾部找到时
- en: When the search item is found somewhere in the middle of the list
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当搜索项在列表的中间位置找到时
- en: 'The node to be removed is identified when its `data` instance variable matches
    the data that is passed to the method to be used in the search for the node. If
    a matching node is found and subsequently removed, the variable `node_deleted`
    is set to `True`. Any other outcome results in `node_deleted` being set to `False`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当要删除的节点的`data`实例变量与传递给方法以用于搜索节点数据的数据匹配时，就识别出要删除的节点。如果找到匹配的节点并将其删除，则将变量`node_deleted`设置为`True`。任何其他结果都会导致`node_deleted`被设置为`False`：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the `delete` method, the `current` variable is set to the head of the list
    (that is, it points to the `self.head` of the list). A set of `if... else` statements
    are then used to search the various parts of the list to find the node with the
    specified data.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在`delete`方法中，`current`变量被设置为列表的头部（即，它指向列表的`self.head`）。然后使用一系列的`if...else`语句来搜索列表的各个部分以找到具有指定数据的节点。
- en: 'The `head` node is searched first. Since `current` is pointing at `head`, if
    `current` is None, it is presumed that the list has no nodes for a search to even
    begin to find the node to be removed:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先搜索`head`节点。由于`current`指向`head`，如果`current`是None，则假定列表没有节点，以至于无法开始搜索要删除的节点：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'However, if `current` (which now points to head) contains the very data being
    searched for, then `self.head` is set to point to the `current` next node. Since
    there is no node behind head now, `self.head.prev` is set to `None`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果`current`（现在指向头部）包含正在搜索的数据，则`self.head`被设置为指向`current`的下一个节点。由于现在头部后面没有节点，`self.head.prev`被设置为`None`：
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'A similar strategy is adopted if the node to be removed is located at the tail
    end of the list. This is the third statement that searches for the possibility
    that the node to be removed might be located at the end of the list:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要删除的节点位于链表的尾部，则采用类似的策略。这是第三个寻找要删除的节点可能位于链表末尾的可能性：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Lastly, the algorithm to find and remove a node loops through the list of nodes.
    If a matching node is found, `current`''s previous node is connected to current''s
    next node. After that step, `current`''s next node is connected to previous node
    of `current`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，查找和删除节点的算法遍历节点列表。如果找到一个匹配的节点，`current`的前一个节点连接到`current`的下一个节点。在此步骤之后，`current`的下一个节点连接到`current`的前一个节点：
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `node_delete` variable is then checked after all the `if-else` statements
    has been evaluated. If any of the `if-else` statements changed this variable,
    then it means a node has been deleted from the list. The count variable is therefore
    decremented by 1:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估完所有`if-else`语句后，然后检查`node_delete`变量。如果任何`if-else`语句改变了这个变量，那么这意味着链表中的一个节点已被删除。因此，计数变量减1：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As an example of deleting a node that is buried within a list, assume the existence
    of three nodes, A, B, and C. To delete node B in the middle of the list, we will
    essentially make A point to C as its next node, while making C point to A as its
    previous node:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设存在三个节点A、B和C。要删除列表中间的节点B，我们实际上将使A指向C作为其下一个节点，同时使C指向A作为其前一个节点：
- en: '![](img/image_04_010.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_04_010.jpg)'
- en: 'After such an operation, we end up with the following list:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的操作之后，我们得到以下列表：
- en: '![](img/image_04_011.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_04_011.jpg)'
- en: List search
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表搜索
- en: 'The search algorithm is similar to that of the `search` method in a singly
    linked list. We call the internal method `iter()` to return the data in all the
    nodes. As we loop through the data, each is matched against the data passed into
    the `contain` method. If there is a match, we return `True`, or else we return
    `False` to symbolize that no match was found:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索算法与单链表中的`search`方法类似。我们调用内部方法`iter()`来返回所有节点的数据。当我们遍历数据时，每个数据都与传递到`contain`方法中的数据进行匹配。如果找到匹配项，我们返回`True`，否则返回`False`以表示未找到匹配项：
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Our doubly linked list has a **O**(1) for the `append` operation and **O**(n)
    for the `delete` operation.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的双链表对于`append`操作的时间复杂度是**O**(1)，对于`delete`操作的时间复杂度是**O**(n)。
- en: Circular lists
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环链表
- en: A circular list is a special case of a linked list. It is a list where the endpoints
    are connected. That is, the last node in the list points back to the first node.
    Circular lists can be based on both singly and doubly linked lists. In the case
    of a doubly linked circular list, the first node also needs to point to the last
    node.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 循环链表是链表的一种特殊情况。它是一个端点相连的列表。也就是说，列表中的最后一个节点指向第一个节点。循环链表可以基于单链表和双链表。在双链表循环链表的情况下，第一个节点也需要指向最后一个节点。
- en: Here we are going to look at an implementation of a singly linked circular list.
    It should be straightforward to implement a doubly linked circular list, once
    you have grasped the basic concepts.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将查看单链表循环链表的实现。一旦掌握了基本概念，实现双链表循环链表应该很简单。
- en: We can reuse the `node` class that we created in the section on singly linked
    lists. As a matter of fact, we can reuse most parts of the `SinglyLinkedList`
    class as well. So we are going to focus on the methods where the circular list
    implementation differs from the normal singly linked list.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重用我们在单链表部分创建的`node`类。实际上，我们还可以重用`SinglyLinkedList`类的大部分内容。因此，我们将重点关注与正常单链表实现不同的循环链表方法。
- en: Appending elements
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加元素
- en: 'When we append an element to the circular list, we need to make sure that the
    new node points back to the tail node. This is demonstrated in the following code.
    There is one extra line as compared to the singly linked list implementation:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将一个元素添加到循环链表时，我们需要确保新节点指向尾部节点。以下代码展示了这一点。与单链表实现相比，这里多了一行：
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Deleting an element
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除一个元素
- en: 'We may think that we can follow the same principle as for append and simply
    make sure the head points to the tail. This would give us the following implementation:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会认为我们可以遵循与append相同的原理，只需确保头指针指向尾部。这将给出以下实现：
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As previously, there is just a single line that needs to change. It is only
    when we remove the tail node that we need to make sure that the head node is updated
    to point to the new tail node.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，只需要更改一行。只有当我们移除尾节点时，我们才需要确保头节点更新为指向新的尾节点。
- en: However, there is a serious problem with this code. In the case of a circular
    list, we cannot loop until current becomes `None`, since that will never happen.
    If you delete an existing node, you wouldn't see this, but try deleting a nonexistent
    node and you will get stuck in an indefinite loop.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这段代码存在一个严重的问题。在循环列表的情况下，我们不能通过直到`current`变为`None`来循环，因为这种情况永远不会发生。如果你删除一个现有的节点，你不会看到这个问题，但尝试删除一个不存在的节点，你将陷入一个不确定的循环中。
- en: 'We thus need to find a different way to control the `while` loop. We cannot
    check whether current has reached head, because then it will never check the last
    node. But we could use `prev`, since it lags behind current by one node. There
    is a special case, however. The very first loop iteration, `current` and `prev`,
    will point to the same node, namely the tail node. We want to ensure that the
    loop does run here, since we need to take the one node list into consideration.
    The updated `delete` method now looks as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要找到一种不同的方式来控制`while`循环。我们不能检查`current`是否到达了`head`，因为那样它将永远不会检查最后一个节点。但我们可以使用`prev`，因为它落后于`current`一个节点。然而，有一个特殊情况。在第一次循环迭代中，`current`和`prev`将指向同一个节点，即尾节点。我们想确保循环在这里确实运行，因为我们需要考虑只有一个节点的列表。更新后的`delete`方法现在如下所示：
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Iterating through a circular list
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历循环列表
- en: 'You do not need to modify the `iter()` method. It will work perfectly well
    for our circular list. But you do need to put in an exit condition when you are
    iterating through the circular list, otherwise your program will get stuck in
    a loop. Here is a way you could do this, by using a counter variable:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要修改`iter()`方法。它将完美适用于我们的循环列表。但当你遍历循环列表时，你确实需要设置一个退出条件，否则你的程序将陷入循环。这里有一种你可以这样做的方法，通过使用一个计数器变量：
- en: '[PRE36]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Once we have printed out 1,000 elements, we break out of the loop.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们打印出1,000个元素，我们就跳出循环。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have looked at linked lists. We have studied the concepts
    that underlie lists, such as nodes and pointers to other nodes. We implemented
    the major operations that occur on these types of list and saw how their worst
    case running times compare.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了链表。我们研究了列表背后的概念，例如节点和其他节点的指针。我们实现了这些类型列表上发生的主要操作，并看到了它们的运行时间最坏情况是如何比较的。
- en: 'In the next chapter, we are going to look at two other data structures that
    are usually implemented using lists: stacks and queues.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将探讨两种通常使用列表实现的其他数据结构：栈和队列。
