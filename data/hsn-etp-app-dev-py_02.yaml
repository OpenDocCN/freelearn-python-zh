- en: Design Patterns – Making a Choice
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式-做出选择
- en: When a software application development project is taken up, it is essentially
    thought of as a problem that requires a solution. When we start to develop the
    application, we start developing a solution specific to the given problem. Eventually,
    this solution may start getting reused in problems of a similar kind, and becomes
    a standard solution for solving such problems. As time passes, we see that a lot
    of problems that display the same pattern. Once we modify our standard solution
    to work on this observed pattern, we come up with a **design pattern**. Design
    patterns are no joke; they take years to produce, after being tried and tested
    for solving a great number of problems with a similar pattern.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当进行软件应用程序开发项目时，它本质上被视为需要解决的问题。当我们开始开发应用程序时，我们开始开发一个特定于给定问题的解决方案。最终，这个解决方案可能开始在类似问题中得到重复使用，并成为解决这类问题的标准解决方案。随着时间的推移，我们发现很多显示相同模式的问题。一旦我们修改我们的标准解决方案以适应这种观察到的模式，我们就提出了一个**设计模式**。设计模式不是闹着玩的；经过多年的尝试和测试，才能产生，用于解决大量具有相似模式的问题。
- en: The design patterns not only define the way in which we architect our software
    application, they also provide knowledge about what worked and what did not, while
    trying to solve a particular type of problem. There are times when no particular
    design pattern might suit the needs of a particular application and the developers
    are left with no choice but to come up with something unique.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式不仅定义了我们构建软件应用程序的方式，还提供了关于在尝试解决特定类型问题时什么有效和什么无效的知识。有时候，没有特定的设计模式可能适合特定应用程序的需求，开发人员别无选择，只能提出独特的解决方案。
- en: Are there some existing standard design patterns that can be used for a particular
    type of problem? How can we decide which design pattern to use for our problem?
    Can we deflect from a particular design pattern and use them while working on
    our solution? We will try to answer these questions as we progress through the
    chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 是否有一些现有的标准设计模式可以用于特定类型的问题？我们如何决定在我们的问题中使用哪种设计模式？我们可以偏离特定的设计模式并在解决方案中使用它们吗？随着我们在本章的进展，我们将尝试回答这些问题。
- en: 'By the end of this chapter, you will know about the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将了解以下内容：
- en: Design patterns and their classification
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计模式及其分类
- en: The object-oriented nature of Python, and how we can use it to implement some
    common design patterns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python的面向对象特性，以及我们如何使用它来实现一些常见的设计模式
- en: Use cases where a particular pattern may be used
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定模式可能被使用的用例
- en: Technical Requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code listings in this book can be found under `chapter02` directory at [https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python.](https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的代码清单可以在[https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python](https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python)的`chapter02`目录下找到。
- en: 'The code samples can be cloned by running the following command:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过运行以下命令克隆代码示例：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The instructions to run the code samples can be found under the `README.md`
    file present inside the chapter directory.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码示例的说明可以在章节目录内的`README.md`文件中找到。
- en: Design patterns
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式
- en: A design pattern defines a way in which we can organize our solution to a given
    problem. It does not define algorithms that can be used to solve the problem,
    but rather provides an abstraction about how, for example, the code should be
    organized, what classes need to be defined, what their granularity will be, and
    how the different objects will be created.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式定义了我们如何组织解决给定问题的方式。它不定义可以用来解决问题的算法，而是提供了关于例如代码应该如何组织，需要定义哪些类，它们的粒度将是什么，以及如何创建不同对象的抽象。
- en: 'The design patterns have gained a lot of traction, and the book *Design Patterns:
    Elements of Reusable Object-Oriented Software, *though published in 1994, still
    serves as a de facto reference when trying to understand design patterns.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式已经获得了很多关注，1994年出版的书籍《设计模式：可复用面向对象软件的元素》仍然是理解设计模式时的事实参考。
- en: 'A design pattern will usually consist of the following elements:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式通常包括以下元素：
- en: '**A problem statement**: A problem statement describes what we want to solve
    and hence also defines the design patterns we can use. The problem statement will
    tell us about the scope of the design that we are planning to pursue, the constraints
    that we may need to take care of, and at times how the different components will
    communicate with each other in the application.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题陈述**：问题陈述描述了我们想要解决的问题，因此也定义了我们可以使用的设计模式。问题陈述将告诉我们关于我们计划追求的设计范围，我们可能需要注意的约束，有时还会告诉我们应用程序中不同组件如何相互通信。'
- en: '**The solution**: A solution describes the design that makes up for the problem.
    It goes into detail about how the class hierarchies should be formed, how the
    objects will be formed, the relationship between the objects, and how the communication
    will take place between the different components. The solution will be an abstract
    design, not specifying the details of the implementation. This makes the solution
    generic, to be applied to a class of problems, without caring about what algorithms
    should be used to solve a particular problem.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决方案**：解决方案描述了弥补问题的设计。它详细说明了类层次结构应该如何形成，对象将如何形成，对象之间的关系以及不同组件之间的通信将如何进行。解决方案将是一个抽象设计，不指定实现的细节。这使得解决方案通用，可以应用于一类问题，而不用关心应该使用什么算法来解决特定问题。'
- en: '**The consequences**: In the world of software development, nothing comes for
    free. Everything has a cost, and we trade off one thing for another. What matters
    is whether the trade-off is justifiable or not. The same applies to the choice
    of design patterns, which come with consequences of their own. Most of the time,
    these consequences are in the terms of space and time trade-offs, and form an
    important part of evaluating alternative options if a particular design choice
    is not justifying the cost of trade-offs. Sometimes, the consequences may also
    define the implementation barriers of a language, and can often impact the reusability
    and flexibility of an application.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后果**：在软件开发世界中，没有免费的东西。一切都有代价，我们为一件事情而牺牲另一件事情。重要的是权衡是否合理。同样适用于设计模式的选择，它们也有自己的后果。大多数情况下，这些后果是空间和时间的权衡，是评估替代选项的重要部分，如果特定的设计选择不能证明权衡成本的合理性。有时，后果也可能定义语言的实现障碍，并且通常会影响应用程序的可重用性和灵活性。'
- en: The choice of a design pattern is not something that is common for every set
    of problems. What pattern will be used to solve the problem will be based upon
    several factors, such as the interpretation of the problem by the developers,
    any restraints on the programming language that need to be used, the deadlines
    associated with the project, and so on.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 选择设计模式并不是每组问题都通用的事情。解决问题将基于多种因素，如开发人员对问题的解释，需要使用的编程语言的限制，与项目相关的截止日期等。
- en: Classification of design patterns
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式的分类
- en: 'In the book *Design Patterns: Elements of Reusable Object-Oriented Software*,
    the design patterns have been classified into three major categories:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在书籍《设计模式：可重用面向对象软件的元素》中，设计模式被分类为三大类：
- en: '**Creational patterns**: These patterns define how the objects can be created
    so that your code can be made independent of which objects are present, and hence
    decouples it from the impact that may happen when new objects are introduced into
    the code base. This requires the isolation of the object creation logic from the
    code base. The patterns, such as Singleton and Factory, come under the category
    of creational patterns.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建模式**：这些模式定义了如何创建对象，以便您的代码可以独立于存在哪些对象，并因此使其与可能发生的新对象引入代码库的影响分离。这需要将对象创建逻辑与代码库隔离开来。Singleton和Factory等模式属于创建模式类别。'
- en: '**Structural patterns**: Unlike creational patterns, which deal with how the
    objects are created, the structural patterns are often used to describe ...'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构模式**：与创建模式不同，结构模式通常用于描述...'
- en: Defining the choice of design patterns
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义设计模式的选择
- en: 'When choosing a design pattern, we may want a certain set of characteristics
    that the design pattern should fulfill. Let''s take a look at what these characteristics
    may consist of if we were to use Python to implement our design pattern:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择设计模式时，我们可能希望设计模式具有一定的特征。让我们看看如果我们要使用Python来实现我们的设计模式，这些特征可能包括什么：
- en: '**Principle of least astonishment**: The Zen of Python says that the principle
    of least astonishment should be followed. That means that a design pattern being
    used should not surprise its user in terms of the behavior it is expected to show.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小惊讶原则**：Python之禅说应该遵循最小惊讶原则。这意味着使用的设计模式在行为方面不应该让用户感到惊讶。'
- en: '**Reduced coupling**: Coupling is defined as the degree to which the different
    components inside a software are interdependent on each other. A software with
    a high degree of coupling may be very hard to maintain, since a change to one
    component may require a change to a lot of other components. Coupling as an effect
    cannot be completely removed from the software, but the choice of design pattern
    should be made such that the degree of coupling can be minimized in the development
    process.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少耦合**：耦合被定义为软件内不同组件之间相互依赖的程度。具有高耦合度的软件可能很难维护，因为对一个组件的更改可能需要对许多其他组件进行更改。耦合作为一种影响无法完全从软件中移除，但应该选择设计模式，以便在开发过程中最小化耦合度。'
- en: '**Focus on simplicity**: Starting to develop a software with a design principle
    that is too generalized can do more harm than good. It may introduce a lot of
    unwanted functionality into the code base, which is used very sparingly or not
    used at all. The choice of design pattern should be made to focus more on providing
    a simple solution to the stated problem, rather than with a focus on how many
    common types of problems a particular design pattern can solve.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**专注于简单性**：开始开发一个软件时，过于泛化的设计原则可能会带来更多的害处。它可能会在代码库中引入许多不需要的功能，这些功能很少被使用或根本不被使用。设计模式的选择应该更多地专注于为所述问题提供简单的解决方案，而不是专注于特定设计模式可以解决多少常见类型的问题。'
- en: '**Avoid duplication**: A good choice of design pattern will help the developer
    to avoid duplicating the code logic and keep it in one place, from where the different
    components of the system can access it. The reduction in duplication of logic
    will not only save development time, but will also make the maintenance process
    easy, where the change in the logic will need to be done only at a single point,
    and not in multiple parts of the code base.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免重复**：良好的设计模式选择将帮助开发人员避免重复代码逻辑，并将其保留在一个位置，系统的不同组件可以从该位置访问。逻辑重复的减少不仅可以节省开发时间，还可以使维护过程变得简单，其中逻辑的更改只需要在一个地方进行，而不是在代码库的多个部分进行。'
- en: Object-oriented Python
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象的Python
- en: '**Object-oriented programming** (**OOP**) refers to the organization of code
    in a format where we are not concerned with the organization of methods, but rather
    we are concerned with the objects, their properties, and their behavior.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象编程**（**OOP**）指的是以一种不关心方法组织的格式组织代码，而是关心对象、它们的属性和行为。'
- en: An object may represent any logical entity, such as an animal, vehicle, and
    furniture, and will contain properties and behaviors describing them.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象可以代表任何逻辑实体，比如动物、车辆和家具，并且会包含描述它们的属性和行为。
- en: The basic building block of an OOP-based language is the **class** that often
    groups the logically related entities together into a single unit. When we need
    to work with this unit, we create a new instance of this unit known as the class
    object, and manipulate the object using the public interfaces exposed by the object.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程语言的基本构建块是**类**，通常将逻辑相关的实体组合成一个单一的单元。当我们需要使用这个单元时，我们创建这个单元的一个新实例，称为类对象，并使用对象公开的接口来操作对象。
- en: Object-oriented programming in Python ...
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的面向对象编程...
- en: The basic OOP principles
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本的面向对象编程原则
- en: A language cannot be considered an object-oriented language merely based on
    the fact that it supports classes and objects. The language will also need to
    support a set of different functionalities, such as encapsulation, polymorphism,
    composition, and inheritance, to be considered an object-oriented langauge. Python
    in this regard supports a lot of OOP-based concepts, but does it a bit differently
    due to its loosely typed nature. Let's take a look at how these features differ
    in Python.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个语言不能仅仅因为它支持类和对象就被认为是面向对象的语言。该语言还需要支持一系列不同的功能，比如封装、多态、组合和继承，才能被认为是面向对象的语言。在这方面，Python支持许多基于面向对象编程的概念，但由于其松散的类型特性，它的实现方式有些不同。让我们看看这些特性在Python中的区别。
- en: Encapsulation
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装
- en: Encapsulation is a term that is used to refer to the ability of a class to restrict
    the access to its members only through the public interfaces exposed by the object.
    The concept of encapsulation helps us in just working on the details about what
    we want to do with the object and not about how the object will deal with the
    changes internally.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 封装是一个术语，用来指代类限制对其成员的访问的能力，只能通过对象公开的接口来访问。封装的概念帮助我们只关注我们想要对对象做什么的细节，而不是对象如何处理内部的变化。
- en: In Python, the encapsulation is not strictly enforced, in that we do not have
    the support of access modifiers, such as private, public, and protected, which
    can be used to strictly control the access to a particular member inside a class.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，封装并不是严格执行的，因为我们没有访问修饰符的支持，比如私有、公共和受保护，这些可以严格控制类内部特定成员的访问。
- en: However, Python does support encapsulation with the help of name mangling, which
    can be used to restrict direct access to a particular property of a ...
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Python确实支持封装，借助名称修饰，可以用来限制对特定属性的直接访问...
- en: Composition
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合
- en: Composition is a property that is used to express a relationship between the
    different objects. The way this relationship is expressed in composition is by
    making an object an attribute of another object.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 组合是用来表达不同对象之间关系的属性。在组合中表达这种关系的方式是将一个对象作为另一个对象的属性。
- en: 'Python supports the concept of composition by allowing the programmer to build
    objects that can then be made part of other objects. For example, let''s take
    a look at the following code snippet:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Python通过允许程序员构建对象，然后将其作为其他对象的一部分来支持组合的概念。例如，让我们看下面的代码片段：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we can see from the example, we have made the `message_handler` object an
    attribute of the `watchdog` object. This marks one of the ways through which we
    can achieve composition in Python.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从例子中我们可以看到，我们已经将`message_handler`对象作为`watchdog`对象的属性。这标志着我们可以在Python中实现组合的一种方式。
- en: Inheritance
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: Inheritance is a way through which we create hierarchies in the objects, going
    from the most general to the most specific. A class that usually forms the base
    for another class is also known as a base class, whereas a class that inherits
    from a base class is known as a child class. For example, if a class `B` derives
    from class `A`, then we will say that class `B` is a child class of class `A`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是我们创建对象层次结构的一种方式，从最一般的到最具体的。通常作为另一个类的基础的类也被称为基类，而继承自基类的类被称为子类。例如，如果一个类`B`派生自类`A`，那么我们会说类`B`是类`A`的子类。
- en: Just like C++, Python supports the concept of both multiple and multilevel inheritance,
    but does not support the use of access modifiers while inheriting in a class that
    C++ supports.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 就像C++一样，Python支持多重和多层继承的概念，但不支持在继承类时使用访问修饰符的概念，而C++支持。
- en: Let's take a look at how inheritance can be achieved in Python by trying to
    model how a new request will look in our BugZot application. The following snippet
    gives ...
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在Python中实现继承，尝试模拟BugZot应用程序中的新请求将是什么样子。以下代码片段给出...
- en: Multiple inheritance in Python
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的多重继承
- en: 'Let''s take a look at an abstract example of how we can implement multiple
    inheritance in Python, as can be seen in the code snippet that follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个抽象的例子，展示了我们如何在Python中实现多重继承，可以在接下来的代码片段中看到：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The example shows how we can get multiple inheritance to work in Python. One
    interesting thing here is to understand how the method resolution order works
    in Python when we use multiple inheritance. So, let's take a look.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了我们如何在Python中实现多重继承。一个有趣的地方是要理解当我们使用多重继承时，Python中的方法解析顺序是如何工作的。让我们来看看。
- en: Method resolution order in multiple inheritance
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多重继承中的方法解析顺序
- en: So, based on the previous example, what happens if we create an object of the
    `C` class?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，基于前面的例子，如果我们创建一个`C`类的对象会发生什么呢？
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As we can see, only the derived class constructor was called here. So what
    if we wanted to call the parent class constructor also? For that, we will require
    the help of the `super()` call inside our class `C` constructor. To see it in
    action, let''s modify the implementation of `C` a little bit:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这里只调用了派生类的构造函数。那么如果我们想要调用父类的构造函数呢？为此，我们需要在我们的类`C`构造函数内部使用`super()`调用。为了看到它的作用，让我们稍微修改一下`C`的实现：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As soon as we created the object of the derived class, we can see that the derived
    class constructor was called first, followed by the constructor of the first inherited
    class. The `super()` call automatically ...
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了派生类的对象，我们可以看到派生类的构造函数首先被调用，然后是第一个继承类的构造函数。`super()`调用自动...
- en: Utilizing mixins
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用mixin
- en: Mixins is a concept that is present in every object-oriented language, and can
    be used to implement object classes that can be reused again and again in different
    places of the code. Projects such as Django web framework provide a lot of pre-built
    mixins, which can be used to achieve a certain set of functionality (for example,
    object manipulation, rendering of forms, and so on) in the custom classes we implement
    for our applications.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Mixin是每种面向对象语言中都存在的概念，可以用来实现可以在代码的不同位置重复使用的对象类。诸如Django Web框架之类的项目提供了许多预构建的mixin，可以用于在我们为应用程序实现的自定义类中实现一定的功能集（例如，对象操作、表单渲染等）。
- en: So, are mixins some special feature of the language? The answer to this is no,
    they are not some special feature, but rather are small classes that are not built
    to be turned into independent objects. Instead, they are built to provide some
    specified extra functionality to a class through the support of multiple inheritance.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，mixin是语言的一些特殊特性吗？答案是否定的，它们不是一些特殊特性，而是一些不打算成为独立对象的小类。相反，它们被构建为通过多重继承支持为类提供一些指定的额外功能。
- en: 'Going back to our sample application, BugZot, we will need a way to return
    the data from multiple objects in JSON format. Now, we have two options; we can
    build the functionality of returning JSON data at the level of individual methods,
    or we can build a mixin that can be reused again and again in multiple classes:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的示例应用BugZot，我们需要一种以JSON格式返回多个对象数据的方法。现在，我们有两个选择；我们可以在单个方法的级别构建返回JSON数据的功能，或者我们可以构建一个可以在多个类中重复使用的mixin：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, let''s imagine, if we wanted our bug class that we implemented in the
    example while trying to understand inheritance. All we needed to do was to just
    inherit `JSONMixin` in the `Bug` class:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们想象一下，如果我们想要我们在尝试理解继承时在示例中实现的bug类。我们所需要做的就是在`Bug`类中继承`JSONMixin`：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: And, by simply inheriting the class, we got the required functionality.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地继承该类，我们就得到了所需的功能。
- en: Abstract base classes
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象基类
- en: In OOP, abstract base classes are those classes that contain just the method
    declarations and not their implementations. These classes are not supposed to
    have independent objects, but rather are built to act as base classes. The classes
    that derive from the abstract base classes are required to provide implementation
    for the methods declared in the abstract classes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，抽象基类是那些只包含方法声明而不包含实现的类。这些类不应该有独立的对象，而是被构建为基类。从抽象基类派生的类需要为抽象类中声明的方法提供实现。
- en: 'In Python, although you can build abstract classes by not providing the implementation
    for the declared methods, the language in itself does not enforce that concept
    of derived classes to provide the implementation for the method. So, the following
    example will run perfectly fine if executed in Python:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，虽然你可以通过不提供已声明方法的实现来构建抽象类，但语言本身并不强制派生类为方法提供实现。因此，如果在Python中执行以下示例，它将完美运行：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Metaclasses
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元类
- en: Python provides a lot of features, some of which are directly visible to us,
    such as list comprehensions, dynamic type evaluation, and so on, and some of them
    not so directly. In Python, a lot of things can be considered magic, happening
    behind the scenes. One of them is the concept of metaclasses.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了许多特性，其中一些直接对我们可见，例如列表推导、动态类型评估等，而另一些则不那么直接。在Python中，许多事情都可以被认为是魔术，是在幕后发生的。其中之一就是元类的概念。
- en: In Python, everything is an object, be it a method or a class. Even inside Python,
    classes are considered to be first-class objects that can be passed on to methods,
    assigned to variables, and so on.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，一切都是对象，无论是方法还是类。即使在Python内部，类也被认为是可以传递给方法、分配给变量等的一等对象。
- en: But, as the concept of OOP states, every object denotes an instance of a class.
    So, if our classes are objects, then they should also be instances of some class.
    So, which class is that? The answer to this question is the `type` class. Every
    class in Python is an instance of the `type` class.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，正如面向对象编程的概念所述，每个对象都表示一个类的实例。因此，如果我们的类是对象，那么它们也应该是某个类的实例。那么这个类是什么？这个问题的答案是`type`类。Python中的每个类都是`type`类的实例。
- en: 'This can be verified quite easily, as shown in the following snippet:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以很容易地验证，如下面的代码片段所示：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These classes, whose object is a class, are known as metaclasses.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象是类的对象，被称为元类。
- en: 'In Python, we don''t often use metaclasses directly, because most of the time
    the problems we are trying to solve with the help of metaclasses can usually be
    solved through the use of some other simple solutions. But the metaclasses do
    provide us with a lot of power to how we create our classes. Let''s first take
    a look at how we can create our own metaclasses by designing a `LoggerMeta` class,
    which will enforce the instance class to provide a valid handler method for different
    log methods prefixed by `HANDLER_`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们不经常直接使用元类，因为大多数时候，我们试图通过其他简单的解决方案来解决元类的问题。但是元类确实为我们提供了很多创建类的方法。让我们首先看一下如何通过设计`LoggerMeta`类来创建我们自己的元类，该类将强制实例类为不同以`HANDLER_`为前缀的日志方法提供有效的处理程序方法：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, we have defined a `metaclass` named `LoggerMeta` by inheriting
    from the type class. (For defining any metaclass, we need to either inherit from
    the type class or any other metaclass. The concept of inheritance is applicable
    even during the `metaclass` creation.) Once we have declared our `metaclass`,
    we provide a definition for the `__init__` magic method in the `metaclass`. The
    `__init__` magic method of the metaclass takes in the class object, the name of
    the new class to be created, a list of base classes the new class will derive
    from, and a dictionary containing the properties of the new class that is used
    to initialize the new class.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过从type类继承来定义了一个名为`LoggerMeta`的`元类`。（为了定义任何元类，我们需要从type类或任何其他元类继承。继承的概念在`元类`创建期间也适用。）一旦我们声明了我们的`元类`，我们在`元类`中提供了`__init__`魔术方法的定义。元类的`__init__`魔术方法接收类对象、要创建的新类的名称、新类将派生自的基类列表以及包含用于初始化新类的属性的字典。
- en: Inside the `__init__` method, we have provided an implementation for verifying
    if the class properties whose name starts with `HANDLER_` have a valid handler
    assigned to them or not. In case the handler assigned to the property is not callable,
    we raise an `AttributeError` and prevent the creation of the class. And at the
    end of the `__init__` method, we return the call results of a base class `__init__`
    method.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在`__init__`方法中，我们提供了一个实现，用于验证以`HANDLER_`开头的类属性是否有有效的处理程序分配给它们。如果属性分配的处理程序不可调用，我们会引发`AttributeError`并阻止类的创建。在`__init__`方法的最后，我们返回基类`__init__`方法的调用结果。
- en: In the next example, we create two simple methods that will act as our handlers
    for dealing with error type messages and warning type messages.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个例子中，我们创建两个简单的方法，它们将充当我们处理错误类型消息和警告类型消息的处理程序。
- en: Moving on in the example, we define a class log whose metaclass is `LoggerMeta`.
    This class contains a few properties, such as `HANDLER_ERROR`, `HANDLER_WARN`,
    `HANDLER_INFO` and the magic method `__init__`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了一个元类为`LoggerMeta`的类日志。这个类包含一些属性，比如`HANDLER_ERROR`、`HANDLER_WARN`、`HANDLER_INFO`和魔术方法`__init__`。
- en: 'Now, let''s see what happens if we try to execute the provided example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如果我们尝试执行提供的例子会发生什么：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we can see from the output, as soon as the definition of class log was parsed
    by the interpreter to create the class, the metaclass `__init__` method was called,
    which validated the properties of the class and raised an `AttributeError`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，一旦解释器解析了类日志的定义以创建类，元类`__init__`方法就会被调用，验证类的属性并引发`AttributeError`。
- en: The metaclasses in Python provide us with a lot of power at our disposal and
    enable us to do a lot of things magically, for example, generating class properties
    based on the name of the methods, and keeping track of how many instances of a
    class have been initialized.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的元类为我们提供了很多强大的功能，并使我们能够以神奇的方式做很多事情，例如基于方法名称生成类属性，并跟踪类的实例化数量。
- en: With all the things we have learned about OOP and metaclasses in Python, let's
    now move on to using them to implement some of the design patterns in Python,
    and learning about how to decide upon the choice of the design pattern to use.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过学习Python中的面向对象编程和元类的所有内容，现在让我们继续使用它们来实现Python中的一些设计模式，并学习如何决定使用哪种设计模式。
- en: The Singleton pattern
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例模式
- en: The Singleton pattern is one of the patterns that finds its place in the book
    by *Gang of Four*, and which can have various uses where all we want is a class
    to have a single instance throughout an application.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式是《设计模式》一书中*四人帮*之一的模式，它可以在应用程序中有各种用途，我们希望一个类在整个应用程序中只有一个实例。
- en: The Singleton pattern enforces that a class will have only one instance that
    will be used by any of the components/modules inside an application. This kind
    of enforcement can be useful when we want to control the access to a resource
    using only one object. These type of resources can be log files, databases, crash-handling
    mechanisms, and so on.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式强制一个类只能有一个实例，该实例将被应用程序中的任何组件/模块使用。当我们想要控制只使用一个对象来访问资源时，这种强制可以很有用。这种类型的资源可以是日志文件、数据库、崩溃处理机制等。
- en: In most of the OOP-based languages, to implement the Singleton pattern, the
    first step is to make the class constructor private and then use a static method
    inside a class ...
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数基于面向对象的语言中，要实现单例模式，第一步是将类构造函数设为私有，然后在类内部使用静态方法...
- en: The __call__ magic method
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: __call__魔术方法
- en: 'The `__call__` magic method is special in context to Python metaclasses. Unlike
    the `__init__` method, which gets called when we create a new class from our metaclass,
    the `__call__` method is called when the object of the initialized class is created.
    To better understand this, let''s try to run the following example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`__call__`魔术方法在Python元类的上下文中是特殊的。与`__init__`方法不同，`__init__`方法在我们从元类创建新类时被调用，而`__call__`方法在初始化类的对象时被调用。为了更好地理解这一点，让我们尝试运行以下示例：'
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: From this example, it is clear that the `__init__` method is called once the
    interpreter has completed the initialization of a class based on the `metaclass`
    and the `__call__` method is called when the object of the class is created.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，可以清楚地看出`__init__`方法是在解释器完成基于`元类`的类初始化后被调用的，而`__call__`方法是在创建类的对象时被调用的。
- en: Now, with this understanding in place, let's build our database connection class,
    which will provide the hold of our database operations. In this example, we will
    just focus on the initialization part of the class, while providing the complete
    class implementation details in the later chapters.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了这个理解，让我们构建我们的数据库连接类，它将提供我们的数据库操作的支持。在这个例子中，我们只关注类的初始化部分，而将在后面的章节中提供完整的类实现细节。
- en: 'Now, under the `bugzot` directory, let''s create a file named `database.py`
    which will hold our database class:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`bugzot`目录下，让我们创建一个名为`database.py`的文件，其中将保存我们的数据库类：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this example, we have defined the database class that will help us establish
    a connection to the database. The different thing about this class is, whenever
    we try to create a new instance of this class, it will always return the same
    object. For example, let''s try to see what happens if we create two different
    objects of this same class:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了一个数据库类，它将帮助我们建立与数据库的连接。这个类的不同之处在于，无论我们尝试创建这个类的新实例时，它总是返回相同的对象。例如，让我们看看如果我们创建这个相同类的两个不同对象会发生什么：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, we can see that the same instance of the database object was
    returned when we tried to instantiate a new object of the class.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以看到，当我们尝试实例化该类的新对象时，返回的是数据库对象的相同实例。
- en: Now, let's take a look at one other interesting pattern, known as the **Factory**
    pattern.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看另一个有趣的模式，即**工厂**模式。
- en: The Factory pattern
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂模式
- en: During the development of large applications, there are certain cases where
    we might want to initialize a class dynamically, based upon the user input or
    some other dynamic factor. To achieve this, either we can initialize all the possible
    objects during the class instantiation and return the one that is required based
    on the inputs from the environment, or we can altogether defer the creation of
    class objects until an input has been received.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发大型应用程序时，有些情况下我们可能希望根据用户输入或其他动态因素动态初始化一个类。为了实现这一点，我们可以在类实例化期间初始化所有可能的对象，并根据环境输入返回所需的对象，或者可以完全推迟类对象的创建，直到收到输入为止。
- en: The Factory pattern is the solution to the latter case, where we develop a special
    method inside a class, which will be responsible for initializing the objects
    dynamically, based on the input from the environment.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂模式是后一种情况的解决方案，其中我们在类内部开发一个特殊的方法，负责根据环境输入动态初始化对象。
- en: Now, let's see how we can implement the Factory pattern in Python ...
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在Python中实现工厂模式...
- en: The Model-View-Controller pattern
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型-视图-控制器模式
- en: 'Let''s start the discussion about the MVC pattern with a diagram:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个图表开始讨论MVC模式：
- en: '![](Images/fa47a996-2063-4385-b24f-40db473eac1e.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fa47a996-2063-4385-b24f-40db473eac1e.png)'
- en: The diagram shows the flow of a request in an **Application** using the MVC
    pattern. When a user makes a new **Request**, the **Request** is intercepted by
    the **Application**, which then forwards the **Request** to the appropriate **Controller**
    for that **Request**. Once the **Request** is received by the **Controller**,
    it then interacts with the model, which performs some business logic based on
    the **Request** received by it. This could involve the updating of databases,
    or fetching some data. Once the business logic is executed by the **Model**, the
    **Controller** executes the **View** with any data that needs to be passed to
    the **View**, which then displays the **Response** for the **Request**.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 该图表显示了使用MVC模式的**应用程序**中请求的流程。当用户发出新的**请求**时，**应用程序**拦截**请求**，然后将**请求**转发给适当的**控制器**处理该**请求**。一旦**控制器**接收到**请求**，它将与模型交互，根据其收到的**请求**执行一些业务逻辑。这可能涉及更新数据库或获取一些数据。一旦**模型**执行了业务逻辑，**控制器**执行**视图**并传递给**视图**需要显示**请求**的任何数据。
- en: Although we will be implementing the MVC pattern later in the book, when we
    develop our BugZot application, let's take a look at the different components
    in the MVC pattern, and what roles they play.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将在本书的后面实现MVC模式，但在开发BugZot应用程序时，让我们来看看MVC模式中的不同组件以及它们扮演的角色。
- en: Controller
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器
- en: The controller acts as an intermediary between the model and the view. When
    a request is first made to the application, the controller intercepts the request
    and, based on that, decides which model and views need to be called. Once this
    is decided, the controller then executes the model to run the business logic,
    retrieving the data from the model. Once the data has been retrieved and model
    execution has been finished, the controller then executes the view with the data
    that is gathered from the model. Once the view execution is finished, the user
    sees a response from the view.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器充当模型和视图之间的中介。当首次向应用程序发出请求时，控制器拦截请求，并根据此决定需要调用哪个模型和视图。一旦决定了这一点，控制器就执行模型来运行业务逻辑，从模型中检索数据。一旦检索到数据并且模型执行完成，控制器就执行视图，并使用从模型中收集的数据。一旦视图执行完成，用户就会看到视图的响应。
- en: 'In a brief, the controller is responsible for doing the following operations:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，控制器负责执行以下操作：
- en: Intercepting the requests made to the application, and executing the required
    ...
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拦截应用程序发出的请求，并执行所需的...
- en: Model
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型
- en: The model is the place where the business logic of the application lives. Many
    a time, developers confuse a model with a database, which may be true for some
    web applications, but is otherwise not if considered in general.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 模型是应用程序的业务逻辑所在的地方。许多时候，开发人员会将模型与数据库混淆，这对于一些Web应用程序可能是正确的，但在一般情况下并非如此。
- en: The role of the model is to deal with the data, provide access to it, and allow
    for modifications as they are requested. This includes retrieving data from the
    database or filesystem, adding new data to it, and modifying the existing data
    when updates are required.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 模型的作用是处理数据，提供对数据的访问，并在请求时允许修改。这包括从数据库或文件系统检索数据，向其中添加新数据，并在需要更新时修改现有数据。
- en: A model is not concerned with how the data stored should be presented to the
    user or another component of the application, and hence decouples the presentation
    logic from the business logic. The model also doesn't change its schema frequently,
    and is more or less consistent throughout the application life cycle.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 模型不关心存储的数据应该如何呈现给用户或应用程序的其他组件，因此将呈现逻辑与业务逻辑解耦。模型也不经常更改其模式，并且在应用程序生命周期中基本保持一致。
- en: 'So, in brief, the model is responsible for performing the following roles:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，简而言之，模型负责执行以下角色：
- en: Provide methods to access the data stored in the application
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供访问应用程序中存储的数据的方法
- en: Decouple the presentation logic from business logic
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将呈现逻辑与业务逻辑解耦
- en: Provide persistence to the data being stored in the application
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为存储在应用程序中的数据提供持久性
- en: Provide a consistent interface to deal with the data
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一致的接口来处理数据
- en: View
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图
- en: The view is responsible for presenting the data to the user, or presenting an
    interface to the user through which they can manipulate the data stored in the
    model. The view in MVC is usually dynamic and changes frequently based on the
    changes that happen in the model. A view can also be considered to contain just
    the presentation logic for the application, without having consideration for how
    the data will be stored by the application and how it will be retrieved. Often,
    a view can be used to cache the presentation state to accelerate the display of
    the data.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 视图负责向用户呈现数据，或通过向用户呈现界面来操作模型中存储的数据。MVC中的视图通常是动态的，并根据模型中发生的更改频繁变化。视图也可以被认为仅包含应用程序的呈现逻辑，而不考虑应用程序将如何存储数据以及如何检索数据。通常，视图可以用于缓存呈现状态，以加速数据的显示。
- en: 'So, in brief, here are the functions performed by the view:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，简而言之，以下是视图执行的功能：
- en: Provide the presentation logic for the application to display the data stored
    in the application
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为应用程序提供呈现逻辑，以显示应用程序中存储的数据
- en: Provide the user with ...
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为用户提供...
- en: Summary
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through the concept of design patterns and how they
    can help us solve some of the commonly encountered problems in designing our applications.
    We then went through how to decide upon which design pattern to use, and if it
    is compulsory to choose one of the patterns that has already been defined. Moving
    further in the chapter, we explored some of the object-oriented capabilities of
    Python as a language, and also explored some examples of implementing abstract
    classes and metaclasses in Python, and how we can use them to build other classes
    and modify their behavior.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了设计模式的概念以及它们如何帮助我们解决设计应用程序中常遇到的一些问题。然后，我们讨论了如何决定使用哪种设计模式，以及是否有必要选择已经定义的模式之一。在本章的进一步探讨中，我们探索了Python作为一种语言的一些面向对象的能力，并且还探讨了在Python中实现抽象类和元类的一些示例，以及我们如何使用它们来构建其他类并修改它们的行为。
- en: Equipped with the knowledge of object-oriented Python, we moved on to implement
    some of the common design patterns, such as the Singleton and Factory patterns
    in Python, and also explored the MVC pattern, learning about what problems they
    try to solve.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了面向对象的Python知识后，我们继续在Python中实现一些常见的设计模式，如单例模式和工厂模式，并探索了MVC模式，了解它们试图解决的问题。
- en: Now with the knowledge of design patterns with us, it is time for us to understand
    how we can make the process of handling the data inside our application efficient.
    The next chapter takes us through the journey of exploring the different techniques
    that will help us in efficiently handling the database operations that are going
    to take place inside our applications.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们掌握了设计模式的知识，是时候了解如何使我们应用程序内部处理数据的过程更加高效了。下一章将带领我们探索不同的技术，帮助我们有效地处理应用程序内部将发生的数据库操作。
- en: Questions
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How can we implement the chain of responsibility pattern in Python, and what
    are some of the possible use cases where it can be used?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在Python中实现责任链模式，以及它可以使用的一些可能用例是什么？
- en: What are the differences between the `__new__` method and the `__init__` method?
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “__new__”方法和“__init__”方法之间有什么区别？
- en: How can we implement an abstract class using the ABCMeta class as the metaclass
    for the abstract class?
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使用ABCMeta类作为抽象类的元类来实现抽象类？
