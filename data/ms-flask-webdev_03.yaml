- en: Creating Views with Templates
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模板创建视图
- en: 'Now that we have our data in an easily accessible format, displaying the information
    in a web page becomes much easier. In this chapter, we will learn how to do the
    following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将数据以易于访问的格式整理好，在网页上显示信息变得容易多了。在本章中，我们将学习以下内容：
- en: Use the included templating language for Flask, Jinja, to dynamically create
    HTML for our SQLAlchemy models
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Flask 的内置模板语言 Jinja 动态创建我们的 SQLAlchemy 模型
- en: Use Jinja's methods to automate the creation of HTML and modify data for presentation
    inside a template
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Jinja 的方法来自动化 HTML 的创建并在模板内修改用于展示的数据
- en: Automatically create and validate HTML forms with Jinja
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Jinja 自动创建和验证 HTML 表单
- en: Jinja's syntax
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jinja 的语法
- en: '**Jinja** is a templating language written in Python. A **templating language**
    is a simple format that is designed to help automate the creation of documents.
    In any templating language, variables passed to the template replace predefined
    elements in the template. In Jinja, variable substitutions are defined by `{{
    }}`. The `{{ }}` syntax is called a **variable block**. There are also **control
    blocks** defined by `{% %}` that declare language functions, such as **loops**
    or `if` statements. For example, when the `Post` model from [Chapter 2](42af8825-fb77-4eb9-a010-7d7fc9644f7c.xhtml), *Creating
    Models with SQLAlchemy*, is passed to it, we get the following Jinja code:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jinja** 是一种用 Python 编写的模板语言。**模板语言**是一种简单的格式，旨在帮助自动化文档的创建。在任何模板语言中，传递给模板的变量将替换模板中的预定义元素。在
    Jinja 中，变量替换由 `{{ }}` 定义。`{{ }}` 语法被称为**变量块**。还有由 `{% %}` 定义的**控制块**，用于声明语言函数，例如**循环**或
    `if` 语句。例如，当将 [第 2 章](42af8825-fb77-4eb9-a010-7d7fc9644f7c.xhtml) 的 `Post` 模型传递给它时，我们得到以下
    Jinja 代码：'
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This produces the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下结果：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The variables displayed in a Jinja template can be any Python type or object
    as long as they can be converted into a string via the Python function `str()`.
    For example, a dictionary or a list passed to a template can have its attributes
    displayed via the following code:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jinja 模板中显示的变量可以是任何 Python 类型或对象，只要它们可以通过 Python 函数 `str()` 转换为字符串。例如，传递给模板的字典或列表可以通过以下代码显示其属性：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Many programmers prefer to use JavaScript to template and dynamically create
    their HTML documents to take the HTML rendering load off the server. This will
    not be covered in this chapter as it is an advanced JavaScript topic. However,
    many JavaScript templating engines use the `{{ }}` syntax as well. If you choose
    to combine Jinja and your JavaScript templates that are defined in your HTML files,
    then wrap the JavaScript templates in the `raw` control block to tell Jinja to
    ignore them, as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序员更喜欢使用 JavaScript 来模板化和动态创建他们的 HTML 文档，以减轻服务器的 HTML 渲染负载。这一内容在本章中不会涉及，因为它是一个高级
    JavaScript 主题。然而，许多 JavaScript 模板引擎也使用 `{{ }}` 语法。如果你选择将 Jinja 和你在 HTML 文件中定义的
    JavaScript 模板结合起来，那么请将 JavaScript 模板包裹在 `raw` 控制块中，以告诉 Jinja 忽略它们，如下所示：
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Filters
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤器
- en: 'It''s a common mistake to believe that Jinja and Python''s syntax are the same
    because of their similarity. However, there is a lot of difference between the
    two. As you will see in this section, normal Python functions do not really exist.
    Instead, in Jinja, variables can be passed to built-in functions that modify the
    variables for display purposes. These functions, called filters, are called in
    the variable block with the pipe character, `|`, as shown in the following code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 认为 Jinja 和 Python 的语法相同是一个常见的错误，因为它们很相似。然而，两者之间有很大的不同。正如你将在本节中看到的那样，正常的 Python
    函数实际上并不存在。相反，在 Jinja 中，变量可以传递给内置函数，这些函数用于显示目的修改变量。这些函数被称为过滤器，它们在变量块中使用管道字符 `|`
    调用，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Otherwise, if no arguments are passed to the filter, the parentheses can be
    omitted as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果没有向过滤器传递任何参数，可以省略括号，如下所示：
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Filters called control blocks can also be applied to blocks of text, as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 调用控制块的过滤器也可以应用于文本块，如下所示：
- en: '[PRE6]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There are many filters in Jinja; this book will cover only the most useful filters.
    For the sake of brevity, in each example, the output of each filter will be listed
    directly beneath the filter itself.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja 中有许多过滤器；本书将仅涵盖最有用的过滤器。为了简洁，在每个示例中，每个过滤器的输出将直接列在过滤器本身下方。
- en: For a full list of all the default filters in Jinja, visit [http://jinja.pocoo.org/docs/dev/templates/#list-of-builtin-filters](http://jinja.pocoo.org/docs/dev/templates/#list-of-builtin-filters).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看Jinja中所有默认过滤器的完整列表，请访问[http://jinja.pocoo.org/docs/dev/templates/#list-of-builtin-filters](http://jinja.pocoo.org/docs/dev/templates/#list-of-builtin-filters)。
- en: The default filter
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认过滤器
- en: 'If the passed variable is `None`, then replace it with a `default` value as
    follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递的变量是`None`，则将其替换为`default`值，如下所示：
- en: '[PRE7]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you wish to replace the variable with the `default` value, and if the variable
    evaluates to `False`, then pass `True` to the optional second parameter, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望用`default`值替换变量，并且变量评估为`False`，那么将`True`传递给可选的第二个参数，如下所示：
- en: '[PRE8]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The escape filter
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转义过滤器
- en: 'If the passed variable is a string of HTML, then the `&`, `<`, `>`, `''`, and
    `"` characters will be printed as HTML `escape` sequences:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递的变量是HTML字符串，那么`&`、`<`、`>`、`'`和`"`字符将被打印为HTML `escape`序列：
- en: '[PRE9]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The float filter
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浮点数过滤器
- en: 'The `float` filter converts the passed value to a floating point number with
    the Python `float()` function as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`float`过滤器使用Python的`float()`函数将传递的值转换为浮点数，如下所示：'
- en: '[PRE10]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The int filter
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`int`过滤器'
- en: 'The `int` filter converts the passed value to an integer with the Python `int()`
    function as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`int`过滤器使用Python的`int()`函数将传递的值转换为整数，如下所示：'
- en: '[PRE11]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The join filter
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接过滤器
- en: 'The `join` filter joins elements of a list with a string, and works in exactly
    the same way as the `list` method of the same name. It is given as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`join`过滤器将列表的元素与一个字符串连接起来，并且与同名的`list`方法的工作方式完全相同。它被这样给出：'
- en: '[PRE12]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The length filter
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 长度过滤器
- en: 'The `length` filter fills the same role as the Python `len()` function. It
    is used as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`length`过滤器与Python的`len()`函数扮演相同的角色。它被这样使用：'
- en: '[PRE13]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The round filter
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 四舍五入过滤器
- en: 'The `round` filter rounds off a float to the specified precision, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`round`过滤器将浮点数四舍五入到指定的精度，如下所示：'
- en: '[PRE14]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can also specify how you want the number to be rounded off, as shown in
    the following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以指定你想要如何进行四舍五入，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `common` option rounds such figures in the same way that a person would:
    Any number at or above 0.5 is rounded up, and any number lower than 0.5 is rounded
    down. The `floor` option always rounds the number down and the `ceil` option always
    rounds up, regardless of the decimal value.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`common`选项以人们通常的方式对这样的数字进行四舍五入：任何大于或等于0.5的数字向上舍入，任何小于0.5的数字向下舍入。`floor`选项始终向下舍入，而`ceil`选项始终向上舍入，无论小数部分是多少。'
- en: The safe filter
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全过滤器
- en: 'If you try to insert HTML into your page from a variable—for example, when
    you wish to display a blog post—Jinja will automatically try to add HTML `escape`
    sequences to the output. Look at the following example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试从一个变量中插入HTML到你的页面中——例如，当你希望显示一篇博客文章时——Jinja会自动尝试向输出添加HTML `escape`序列。看看下面的例子：
- en: '[PRE16]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is a necessary security feature. When an application has inputs that allow
    users to submit arbitrary text, it creates a vulnerability that a malicious user
    can use to input HTML code. For example, if a user were to submit a script tag
    as a comment and Jinja didn't have this feature, the script would be executed
    on all the browsers that visited the page.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个必要的安全特性。当一个应用程序有允许用户提交任意文本的输入时，它就会创建一个漏洞，恶意用户可以利用这个漏洞输入HTML代码。例如，如果用户提交一个脚本标签作为评论，并且Jinja没有这个特性，那么脚本将在访问页面的所有浏览器上执行。
- en: 'However, we still need a way to display HTML that we know is safe to show,
    such as the HTML of our blog posts. We can achieve this using the `safe` filter
    as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们仍然需要一种方法来显示我们知道是安全的HTML，例如我们博客文章的HTML。我们可以使用`safe`过滤器来实现这一点，如下所示：
- en: '[PRE17]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The title filter
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标题过滤器
- en: 'The `title` filter enables us to capitalize a string using the `title` case
    format as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`title`过滤器使我们能够使用`title`格式来大写一个字符串，如下所示：'
- en: '[PRE18]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The tojson filter
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换为JSON过滤器
- en: 'We use the `tojson` filter to pass the variable to the Python `json.dumps`
    function, as shown in the following code. Remember that your passed object must
    be serializable by the `json` module:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`tojson`过滤器将变量传递给Python的`json.dumps`函数，如下面的代码所示。请记住，你传递的对象必须可以被`json`模块序列化：
- en: '[PRE19]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This feature is most commonly used to pass SQLAlchemy models to JavaScript
    MVC frameworks upon the loading of the page load than waiting for an AJAX request.
    If you use `tojson` in this way, remember to pass the result to the `safe` filter
    as well to make sure that you don''t get HTML `escape` sequences in your JavaScript.
    Here is an example with a collection of models from `Backbone.js`, a popular JavaScript
    MVC framework:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能最常用于在页面加载时传递SQLAlchemy模型到JavaScript MVC框架，而不是等待AJAX请求。如果你以这种方式使用`tojson`，请记住将结果传递给`safe`过滤器，以确保你不会在JavaScript中得到HTML转义序列。以下是一个使用来自流行的JavaScript
    MVC框架`Backbone.js`的模型集合的示例：
- en: '[PRE20]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The truncate filter
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 截断过滤器
- en: 'The `truncate` filter takes a long string, returns a string cutoff at the specified
    length in characters, and appends an ellipsis, as shown in the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`truncate`过滤器接受一个长字符串，返回一个在指定字符长度处截断的字符串，并附加省略号，如下所示代码所示：'
- en: '[PRE21]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'By default, any words that are cut in the middle are discarded. To disable
    this, pass `True` as an extra parameter as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，任何在中间被截断的单词都将被丢弃。要禁用此功能，请按如下方式传递`True`作为额外的参数：
- en: '[PRE22]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Custom filters
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义过滤器
- en: 'Adding your own filter into Jinja is as simple as writing a Python function.
    To understand custom filters, we will look at an example. Our simple filter will
    count the number of occurrences of a substring in a string and return this figure.
    Look at the following call:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 将自己的过滤器添加到Jinja中就像编写一个Python函数一样简单。为了理解自定义过滤器，我们将查看一个示例。我们的简单过滤器将计算字符串中子字符串出现的次数并返回这个数字。查看以下调用：
- en: '[PRE23]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We need to write a new Python function with the following signature, where
    the first argument is the *piped *variable:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要编写一个具有以下签名的新的Python函数，其中第一个参数是*管道*变量：
- en: '[PRE24]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can define our filter as the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们的过滤器定义为以下：
- en: '[PRE25]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: To add this function to the list of available filters on **Jinja2**, we have
    to register it and add it to the `filters` dictionary of the `jinja_env` object
    in our `main.py` file. To do this, we can simply use a decorator that will handle
    this procedure for us—`@app.template_filter`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此函数添加到**Jinja2**的可用过滤器列表中，我们必须注册它并将它添加到我们的`main.py`文件中`jinja_env`对象的`filters`字典中。为此，我们可以简单地使用一个装饰器来为我们处理此过程——`@app.template_filter`。
- en: Comments
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注释
- en: 'Comments in the template are defined by `{# #}`, as shown in the following
    code. They will be ignored by Jinja, and will not be in the returned HTML code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '模板中的注释由`{# #}`定义，如下所示代码所示。它们将被Jinja忽略，并且不会出现在返回的HTML代码中：'
- en: '[PRE26]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Using if statements
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用if语句
- en: 'Using `if` statements in Jinja is similar to using them in Python. Anything
    that returns, or is, a Boolean determines the flow of the code, as shown in the
    following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jinja中使用`if`语句与在Python中使用它们类似。任何返回或为布尔值的东西都决定了代码的流程，如下所示代码所示：
- en: '[PRE27]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Filters can also be used in `if` statements, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器也可以在`if`语句中使用，如下所示：
- en: '[PRE28]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Loops
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: 'We can use loops in Jinja to iterate over any list or generator function, as
    follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Jinja中使用循环遍历任何列表或生成器函数，如下所示：
- en: '[PRE29]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Loops and `if` statements can be combined to mimic the `break` functionality
    in Python loops. In this example, the loop will only use the post `if post.text`
    is not `None`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 循环和`if`语句可以组合起来模拟Python循环中的`break`功能。在这个例子中，循环将仅在`post.text`不是`None`时使用后置`if`：
- en: '[PRE30]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Inside the loop, you have access to a special variable called `loop`, which
    gives you access to information about the `for` loop. For example, if we want
    to know the current index of the current loop to emulate the `enumerate` function
    in Python, we can use the index variable of the `loop` variable as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内部，你可以访问一个名为`loop`的特殊变量，它让你可以访问有关`for`循环的信息。例如，如果我们想知道当前循环的当前索引以模拟Python中的`enumerate`函数，我们可以使用`loop`变量的索引变量如下所示：
- en: '[PRE31]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This will produce the following output:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE32]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'All the variables and functions that the `loop` object exposes are listed in
    the following table:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`loop`对象公开的变量和函数列在以下表格中：
- en: '| **Variable** | **Description** |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| **变量** | **描述** |'
- en: '| `loop.index` | The current iteration of the loop (1 indexed) |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `loop.index` | 循环的当前迭代（从1开始计数） |'
- en: '| `loop.index0` | The current iteration of the loop (0 indexed) |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `loop.index0` | 循环的当前迭代（从0开始计数） |'
- en: '| `loop.revindex` | The number of iterations from the end of the loop (1 indexed)
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `loop.revindex` | 从循环末尾的迭代次数（从1开始计数） |'
- en: '| `loop.revindex0` | The number of iterations from the end of the loop (0 indexed)
    |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `loop.revindex0` | 从循环末尾的迭代次数（从0开始计数） |'
- en: '| `loop.first` | True if the current item is first in the iterator |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `loop.first` | 当前项是否是迭代器中的第一个项 |'
- en: '| `loop.last` | True if the current item is last in the iterator |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `loop.last` | 如果当前项是迭代器中的最后一个 |'
- en: '| `loop.length` | The number of items in the iterator |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `loop.length` | 迭代器中的项目数量 |'
- en: '| `loop.cycle` | The `helper` function to cycle between the items in the iterator
    (this is explained later) |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `loop.cycle` | 在迭代器中的项目之间循环的辅助函数（稍后解释）|'
- en: '| `loop.depth` | Indicates how deep in a recursive loop the loop currently
    is (starts at level 1) |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `loop.depth` | 指示循环当前在递归循环中的深度（从级别1开始） |'
- en: '| `loop.depth0` | Indicates how deep in a recursive loop the loop currently
    is (starts at level 0) |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `loop.depth0` | 指示循环当前在递归循环中的深度（从级别0开始） |'
- en: 'The `cycle` function is a function that goes through an iterator one item at
    a time in every loop. We can use the previous example to demonstrate, as shown
    in the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`cycle`函数是一个函数，它在每次循环中遍历迭代器中的一个项目。我们可以使用之前的示例来演示，如下所示：'
- en: '[PRE33]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This will output the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE34]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Macros
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 宏
- en: 'A **macro** is best understood as a function in Jinja that returns a template
    or HTML string. This is used to avoid reproducing code that is repeated over and
    over again and reduce it to one function call. For example, the following is a
    macro to add a Bootstrap CSS input and a label to your template:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**宏**最好理解为Jinja中的一个函数，它返回一个模板或HTML字符串。这用于避免重复代码，并将其简化为一个函数调用。例如，以下是一个宏，用于向模板添加Bootstrap
    CSS输入和标签：
- en: '[PRE35]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, to quickly add an input to a form in any template, call your macro using
    the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要快速在任何模板中添加一个输入到表单中，请使用以下方式调用您的宏：
- en: '[PRE36]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This will output the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE37]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Flask-specific variables and functions
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flask特定的变量和函数
- en: Flask makes several functions and objects available to you by default in your
    template.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Flask默认在模板中为您提供了几个函数和对象。
- en: The config object
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置对象
- en: 'Flask makes the current `config` object available in templates as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Flask通过以下方式在模板中提供当前`config`对象：
- en: '[PRE38]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The request object
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求对象
- en: 'The Flask `request` object refers to the current request:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Flask `request`对象指的是当前请求：
- en: '[PRE39]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The session object
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话对象
- en: 'The Flask `session` object is as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Flask `session`对象如下所示：
- en: '[PRE40]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The url_for() function
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`url_for()`函数'
- en: 'The `url_for` function returns the URL of a route by giving the route function
    name as a parameter, as shown in the following code. This allows URLs to be changed
    without worrying about where links will break:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`url_for`函数通过将路由函数名称作为参数返回路由的URL，如下所示。这允许在不担心链接会断开的情况下更改URL：'
- en: '[PRE41]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here, `home`is the name of a function that is registered as an endpoint on
    Flask,and the relative URL root associated with it, so on our `main.py`, we must
    define a function to deal with the HTTP request and register it on Flask using
    the decorator `app.route(rule, **options)`, as shown in the following code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`home`是注册为Flask端点的函数的名称，以及与其关联的相对URL根，因此在我们的`main.py`中，我们必须定义一个处理HTTP请求的函数，并使用装饰器`app.route(rule,
    **options)`将其注册到Flask上，如下所示：
- en: '[PRE42]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If we had a route that had positional arguments in the URL, we pass them as
    `kwargs`. They will be filled in for us in the resultant URL as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的路由在URL中有位置参数，我们将它们作为`kwargs`传递。它们将为我们填充在结果URL中，如下所示：
- en: '[PRE43]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'With the respective function that we use to handle the request, we restrict
    this method to handle only GET and POST HTTP requests, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们用来处理请求的相应函数，我们将此方法限制为仅处理GET和POST HTTP请求，如下所示：
- en: '[PRE44]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The get_flashed_messages() function
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`get_flashed_messages()`函数'
- en: 'The `get_flashed_messages()` function returns a list of all the messages passed
    through the `flash()` function in Flask. The `flash` function is a simple function
    that queues messages—which consist of Python tuples of (category, message) phrases—for
    the `get_flashed_messages` function to consume, as shown in the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_flashed_messages()`函数返回通过Flask中的`flash()`函数传递的所有消息的列表。`flash`函数是一个简单的函数，它将消息队列——由Python元组（类别，消息）短语组成——供`get_flashed_messages`函数消费，如下所示：'
- en: '[PRE45]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Proper feedback to the user is very important, and Flask makes it very simple
    to implement—for example, when handling a new post entry, we want to let the user
    know that his/her post was saved correctly. The `flash()` function accepts three
    different categories: `info`, `error`, and `warning`. Refer to the following code
    snippet:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的用户反馈非常重要，Flask使得实现这一点变得非常简单——例如，在处理新的帖子条目时，我们希望让用户知道他的/她的帖子已正确保存。`flash()`函数接受三个不同的类别：`info`、`error`和`warning`。请参考以下代码片段：
- en: '[PRE46]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Creating our views
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的视图
- en: To get started, we need to create a new folder named `templates` in our project
    directory. This folder will store all of our Jinja files, which are just HTML
    files with Jinja syntax mixed in. Our first template will be our home page, which
    will be a list of the first 10 posts with summaries. There will also be a view
    for a post that will just show the post content, the comments on the page, links
    to the author's user page, and links to tag pages. There will also be user and
    tag pages that show all the posts that have been made by a user and all the posts
    with a specific tag. Each page will also have a sidebar showing the five most
    recent posts and the top five most used tags.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要在项目目录中创建一个名为 `templates` 的新文件夹。这个文件夹将存储我们所有的 Jinja 文件，这些文件只是混合了 Jinja
    语法的 HTML 文件。我们的第一个模板将是我们的主页，它将是一个包含摘要的前10个帖子的列表。还将有一个用于帖子的视图，它将仅显示帖子内容、页面上的评论、作者的用户页面链接和标签页面链接。还将有用户和标签页面，显示用户发布的所有帖子以及具有特定标签的所有帖子。每个页面还将有一个侧边栏，显示最新的五个帖子以及使用最多的前五个标签。
- en: The view function
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图函数
- en: 'Because each page will have the same sidebar information, we can break that
    into a separate function to simplify our code. In the `main.py` file, add the
    following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个页面都会有相同的侧边栏信息，我们可以将其拆分为一个单独的函数以简化我们的代码。在 `main.py` 文件中，添加以下代码：
- en: '[PRE47]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The most recent posts query is straightforward, but the most popular tags query
    looks somewhat familiar, but a little odd. This is a bit outside the scope of
    this book, but using the SQLAlchemy `func` library to return a count on a group
    by query, we are able to order our tags by the most used tags. The `func` function
    is explained in detail at [http://docs.sqlalchemy.org/en/rel_1_0/core/sqlelement.html#sqlalchemy.sql.expression.func](http://docs.sqlalchemy.org/en/latest/core/functions.html#module-sqlalchemy.sql.expression).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最新的帖子查询很简单，但最受欢迎的标签查询看起来有些熟悉，但有点奇怪。这稍微超出了本书的范围，但使用 SQLAlchemy 的 `func` 库在分组查询上返回计数，我们能够按使用最多的标签对标签进行排序。`func`
    函数在 [http://docs.sqlalchemy.org/en/rel_1_0/core/sqlelement.html#sqlalchemy.sql.expression.func](http://docs.sqlalchemy.org/en/latest/core/functions.html#module-sqlalchemy.sql.expression)
    中有详细解释。
- en: 'The `home` page function in `main.py` will need all the posts ordered by their publish
    date in a pagination object and the sidebar information, as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.py` 中的 `home` 页面函数需要按发布日期排序的所有帖子以及侧边栏信息，如下所示：'
- en: '[PRE48]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note that using the `app.config['POSTS_PER_PAGE']` phrase gives us the option
    to configure it without having to change code, which is nice. It's a candidate
    config key for the main `Config` class, and let all environments inherit its value.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用 `app.config['POSTS_PER_PAGE']` 语句，我们可以配置它而无需更改代码，这是很棒的。它是一个主 `Config`
    类的候选配置键，并让所有环境继承其值。
- en: Here, we finally see how Flask and Jinja tie together. The Flask function `render_template`
    takes the name of a file in the folder `templates` and passes all the `kwargs`
    to the template as variables. Also, our `home` function now has multiple routes
    to handle pagination, and will default to the first page if there is nothing after
    the slash.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们终于看到了 Flask 和 Jinja 如何结合在一起。Flask 函数 `render_template` 接收 `templates`
    文件夹中文件的名称，并将所有 `kwargs` 作为变量传递给模板。此外，我们的 `home` 函数现在有多个路由来处理分页，如果没有在斜杠之后添加任何内容，则默认为第一页。
- en: 'Now that you have all the information that you need to write view functions,
    let''s define the first view functions that we need:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经拥有了编写视图函数所需的所有信息，让我们定义我们需要的第一个视图函数：
- en: '`GET /post/<POST_ID>` to render a specific post by its ID. This also renders
    all recent posts and tags.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `GET /post/<POST_ID>` 通过ID渲染特定的帖子。这也会渲染所有最近的帖子和标签。
- en: '`GET /posts_by_tag/<TAG_NAME>` to render all posts by a specific tag name.
    This also renders all recent posts and tags.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `GET /posts_by_tag/<TAG_NAME>` 通过特定的标签名称渲染所有帖子。这也会渲染所有最近的帖子和标签。
- en: '`GET /posts_by_user/<USER_NAME>` to render all posts authored by a specific
    user. This also renders all recent posts and tags.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `GET /posts_by_user/<USER_NAME>` 通过特定用户渲染所有帖子。这也会渲染所有最近的帖子和标签。
- en: 'This translates to the following view functions:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这对应以下视图函数：
- en: '[PRE49]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In Flask SQLAlchemy, there are two convenience functions that return HTTP `404`
    in the case of a nonexistent entry in the database, `get_or_404` and `first_or_404`,
    so on our get post by ID, as shown in the following code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Flask SQLAlchemy 中，有两个方便的函数，在数据库中不存在条目时返回 HTTP `404`，分别是 `get_or_404` 和 `first_or_404`，因此在我们根据ID获取帖子时，如下代码所示：
- en: '[PRE50]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'All posts made by a user can be returned using the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下代码返回用户发布的所有帖子：
- en: '[PRE51]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: However, this doesn't check the `posts_by_tag` function in the `main.py` file
    (see the provided code for this chapter). After all of your views are written,
    the only thing left to do is to write the templates.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并没有检查`main.py`文件中的`posts_by_tag`函数（请参阅本章提供的代码）。在你编写完所有视图之后，剩下的唯一事情就是编写模板。
- en: Writing the templates and inheritance
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写模板和继承
- en: Because this book does not focus on interface design, we will use the CSS library
    **Bootstrap** and avoid writing custom CSS. If you have never used it before,
    Bootstrap is a set of default CSS rules that make your website work well across
    all browsers and platforms, from desktop to mobile. Bootstrap has tools that allow
    you to easily control the layout of your website.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这本书不专注于界面设计，我们将使用CSS库**Bootstrap**并避免编写自定义CSS。如果你之前从未使用过它，Bootstrap是一套默认CSS规则，可以使你的网站在所有浏览器和平台上都能良好工作，从桌面到移动设备。Bootstrap有工具可以让你轻松控制你网站的布局。
- en: We will be downloading Bootstrap, JQuery, and Font Awesome directly from their
    CDN upon page load, but any extra assets you may need should be included in a
    project directory named `static`. It's common practice to use `static/css` for
    CSS, `static/js` for JavaScript, `static/img` for images, and `static/fonts` for
    fonts. One of the best ways to use Bootstrap is to download its `sass` files and
    use `sass `to customize it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在页面加载时直接从它们的CDN下载Bootstrap、JQuery和Font Awesome，但任何你可能需要的额外资源都应该包含在名为`static`的项目目录中。使用`static/css`为CSS、`static/js`为JavaScript、`static/img`为图像、`static/fonts`为字体是常见的做法。使用Bootstrap的最佳方式之一是下载其`sass`文件并使用`sass`进行自定义。
- en: For the official documentation about SASS and Bootstrap, visit [https://getbootstrap.com/docs/4.0/getting-started/theming/](https://getbootstrap.com/docs/4.0/getting-started/theming/).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 有关SASS和Bootstrap的官方文档，请访问[https://getbootstrap.com/docs/4.0/getting-started/theming/](https://getbootstrap.com/docs/4.0/getting-started/theming/)。
- en: Because every route will have a template assigned to it, each template will
    need the requisite HTML boilerplate code with our metainformation, style sheets,
    common JavaScript libraries, and so on. To keep our templates **DRY** (**don't
    repeat yourself**), we will use one of the most powerful features of Jinja, **template
    inheritance**. Template inheritance is when a child template can import a base
    template as a starting point and only replace marked sections in the base. You
    can also include full sections of Jinja templates from other files; this will
    allow you to set some rigid default sections.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个路由都将分配一个模板，每个模板都需要包含我们的元信息、样式表、常用JavaScript库等必要的HTML模板代码。为了使我们的模板**DRY**（**不要重复自己**），我们将使用Jinja最强大的功能之一，**模板继承**。模板继承是指子模板可以将基础模板作为起点导入，并仅替换基础模板中标记的部分。您还可以从其他文件中包含完整的Jinja模板部分；这将允许您设置一些固定的默认部分。
- en: The base template
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础模板
- en: 'We need to outline the base layout for our site, split it into sections, and
    give each section a specific purpose. The following diagram is an abstract description
    of the layout:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要概述我们网站的基线布局，将其分为几个部分，并为每个部分指定一个特定的用途。以下图表是对布局的抽象描述：
- en: '![](img/f31d75a6-e6b6-45aa-9297-14f2b0675f52.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f31d75a6-e6b6-45aa-9297-14f2b0675f52.png)'
- en: Some of these sections will always get rendered, and you don't want to repeat
    them on each template. Some possible options for these sections are the navigation
    bar, header, messages, and footer.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些部分将始终被渲染，你不想在每个模板中重复它们。这些部分的一些可能选项是导航栏、头部、消息和页脚。
- en: 'We will use the following include and block structure to maintain our DRY principal
    and implement the layout:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下包含和块结构来维护我们的DRY原则并实现布局：
- en: '**Include navbar**: Jinja2 template: `navbar.html`—Renders a navigation bar.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包含导航栏**：Jinja2模板：`navbar.html`—渲染导航栏。'
- en: '**Block head**: The header with the name of the site. Already includes the `head.html `Jinja2
    template.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**头部块**：带有网站名称的头部。已包含`head.html` Jinja2模板。'
- en: '**Include messages**: Jinja2 template: `messages.html`—Renders alerts for the
    users with different categories.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包含消息**：Jinja2模板：`messages.html`—为不同类别的用户渲染警报。'
- en: '**Block body:**'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主体块**：'
- en: '**Block left body**: Normally, templates will override this block.'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**左侧主体块**：通常，模板将覆盖此块。'
- en: '**Block right body**: This will display the most recent posts and tags.'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**右侧主体块**：这将显示最新的帖子标签。'
- en: '**Block footer**: Jinja2 template: `footer.html`.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**页脚块**：Jinja2模板：`footer.html`。'
- en: Note how the fixed sections, the ones that will almost always get rendered,
    already include templates even when inside blocks. The base template will handle
    these by default. If for some reason you want to override these, you just have
    to implement/inherit their block on the rendered template. For example, say that
    you want to render a whole body section on a certain page, taking the space of
    the right body section that displays the most recent posts and tags. A good candidate
    for this will be the login page.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，固定部分，即几乎总是会被渲染的部分，即使在块内部也已经包含了模板。基本模板会默认处理这些。如果出于某种原因你想覆盖这些，你只需在渲染模板上实现/继承它们的块即可。例如，假设你想要在某个页面上渲染整个主体部分，占据显示最新帖子标签的右侧主体部分的空间。一个好的候选者将是登录页面。
- en: 'To start our base template, we need a basic HTML skeleton and the Jinja2 block
    structure that we previously outlined (see the highlighted code in the following
    snippet):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始我们的基本模板，我们需要一个基本的 HTML 骨架和之前概述的 Jinja2 块结构（参见以下代码片段中的高亮部分）：
- en: '[PRE52]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This is the `base.html` template in the provided code in your `templates` directory.
    First, we include the Bootstrap and Font Awesome CSS, then implement the HTML
    body section, and finally include all the necessary JavaScript libraries.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这是提供的代码中 `templates` 目录中的 `base.html` 模板。首先，我们包含 Bootstrap 和 Font Awesome CSS，然后实现
    HTML 主体部分，最后包含所有必要的 JavaScript 库。
- en: The child templates
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子模板
- en: 'Now that we have outlined the base layout, we need to implement all the child
    pages that will extend the base. Take a look at the way we are implementing the
    home page and inherit/override the left body block, as shown in the following
    code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经概述了基本布局，我们需要实现所有扩展基本布局的子页面。看看我们是如何实现主页并继承/覆盖左侧主体块的，如下面的代码所示：
- en: '[PRE53]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Surprisingly simple, this template extends the base template has expected, and
    then overrides the `title` and `leftbody` block sections. Inside, the `leftbody` uses
    two macros to render the posts and their pagination. The macros help us to reuse
    Jinja2 code and use it like functions, and also to hide some complexity.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 意想不到地简单，这个模板扩展了基本模板并如预期那样，然后覆盖了 `title` 和 `leftbody` 块部分。在内部，`leftbody` 使用两个宏来渲染帖子及其分页。这些宏帮助我们重用
    Jinja2 代码，并像函数一样使用它，同时也隐藏了一些复杂性。
- en: 'The `render_posts` macro is in the `macros.html` that was imported at the top
    of the file. We use macros more or less like modules in Python, as shown in the
    following code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`render_posts` 宏位于文件顶部导入的 `macros.html` 中。我们使用宏的方式与 Python 中的模块类似，如下面的代码所示：'
- en: '[PRE54]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The macro iterates on each post, and on each `post.title`, there is a link to
    the Flask endpoint `post` with its respective post ID. As explained, we always
    use `url_for` to generate the right URL that references Flask's endpoints.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 宏遍历每个帖子，在 `post.title` 上，有一个链接指向 Flask 端点 `post`，并带有相应的帖子 ID。如前所述，我们始终使用 `url_for`
    生成正确的 URL，该 URL 引用 Flask 的端点。
- en: 'We are using this macro three times on the templates: to render all posts,
    all posts by a certain tag, and all posts by a certain user.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在模板中使用了这个宏三次：渲染所有帖子、特定标签的所有帖子以及特定用户的所有帖子。
- en: 'The `tag.html` template renders all posts by a certain tag, as shown in the
    following code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`tag.html` 模板渲染特定标签的所有帖子，如下面的代码所示：'
- en: '[PRE55]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If you look at the `user.html` template in the preceding code, you'll see that
    they are almost identical. These templates are called by the Flask endpoint functions `posts_by_tag` and `posts_by_user`.
    When rendering the templates, they pass arguments for the `tag`/`user` object
    and a list of posts, as we saw before.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看前面的代码中的 `user.html` 模板，你会看到它们几乎是相同的。这些模板是由 Flask 端点函数 `posts_by_tag` 和
    `posts_by_user` 调用的。在渲染模板时，它们传递 `tag`/`user` 对象和帖子列表的参数，就像我们之前看到的那样。
- en: 'Let''s check out how the blog site looks now. In the command line, call `init.sh` to
    build a Python virtualenv, and then migrate/create our database and insert some
    fake data, as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看现在博客网站的样子。在命令行中，调用 `init.sh` 来构建 Python 虚拟环境，然后迁移/创建我们的数据库并插入一些假数据，如下所示：
- en: '[PRE56]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Open `http://127.0.0.1:5000/` in your browser. You should see the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开 `http://127.0.0.1:5000/`。你应该看到以下内容：
- en: '![](img/ce1ce568-d1bd-431c-849b-3fef57b9d1b6.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ce1ce568-d1bd-431c-849b-3fef57b9d1b6.png)'
- en: The `init.sh` phrase calls the `test_data.py`, which inserts fake data into
    the database. This Python module uses the `faker` library to generate data for
    user names and post text and tags (using color names).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`init.sh` 命令行短语调用 `test_data.py`，该模块将假数据插入数据库。此 Python 模块使用 `faker` 库生成用户名、帖子文本和标签（使用颜色名称）的数据。'
- en: For more details regarding `faker`, you can go to [http://faker.readthedocs.io/en/master/](http://faker.readthedocs.io/en/master/).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`faker`的更多详细信息，您可以访问[http://faker.readthedocs.io/en/master/](http://faker.readthedocs.io/en/master/).
- en: 'The following code is an example taken from `test_data.py` that inserts users
    into the database and returns a list of user objects that is reused to insert
    posts:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是从`test_data.py`中摘取的示例，它将用户插入数据库并返回一个用户对象列表，该列表被重复用于插入帖子：
- en: '[PRE57]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `template` folder contains the following templates that are rendered using
    the aforementioned hierarchy:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`template`文件夹包含以下模板，这些模板使用上述层次结构进行渲染：'
- en: '`base.html`: Extended by all the other templates'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`base.html`：所有其他模板都扩展自它'
- en: '`footer.html`: Included by `base.html`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`footer.html`：由`base.html`包含'
- en: '`head.html`: Included by `base.html`'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`head.html`：由`base.html`包含'
- en: '`messages.html`: Included by `base.html`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`messages.html`：由`base.html`包含'
- en: '`navbar.html`: Included by `base.html`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`navbar.html`：由`base.html`包含'
- en: '`rightbody.html`: Included by `base.html`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rightbody.html`：由`base.html`包含'
- en: '`home.html`: Rendered by the `home` Flask endpoint function'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`home.html`：由`home` Flask端点函数渲染'
- en: '`post.html`: Rendered by the `post` Flask endpoint function'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post.html`：由`post` Flask端点函数渲染'
- en: '`tag.html`: Rendered by the `posts_by_tag` endpoint function'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tag.html`：由`posts_by_tag`端点函数渲染'
- en: '`user.html`: Rendered by the `posts_by_user` endpoint function'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user.html`：由`posts_by_user`端点函数渲染'
- en: Writing the other templates
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写其他模板
- en: Now that you know the ins and outs of inheritance, and you know which data is
    going to go to which template, you can have a clear idea of how to structure your
    web application to easily scale and maintain the same look and feel on every page.
    There is one final bit of functionality to add in this chapter—the ability for
    readers to add comments. For this, we will be using web forms.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了继承的方方面面，并且知道哪些数据将发送到哪个模板，您就可以清楚地了解如何构建您的Web应用程序，以便轻松扩展并在每个页面上保持相同的样式和感觉。在本章中，我们还需要添加一个最终的功能——允许读者添加评论。为此，我们将使用Web表单。
- en: Flask WTForms
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flask WTForms
- en: Adding forms to your application seems to be an easy task, but when you start
    coding the server-side code, the task of validating user input grows bigger and
    bigger as the form becomes more complex. Security is paramount, as the data is
    from an untrustworthy source, and is going to be entered into the database. **WTForms**
    is a library that handles server form validation for you by checking input against
    common form types. Flask WTForms is a Flask extension that is built on top of
    WTForms that adds features, such as Jinja HTML rendering, and protects you against
    attacks, such as SQL injection and cross-site request forgery. This extension
    is already installed in your virtualenv, because it's declared in the `requirements.txt`
    file.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用程序中添加表单似乎是一个简单的任务，但当您开始编写服务器端代码时，随着表单的复杂度增加，验证用户输入的任务也会越来越大。由于数据来自不可信的来源，并将被输入到数据库中，因此安全性至关重要。**WTForms**是一个库，通过检查输入与常见表单类型来为您处理服务器端表单验证。Flask
    WTForms是一个建立在WTForms之上的Flask扩展，它添加了诸如Jinja HTML渲染等功能，并保护您免受诸如SQL注入和跨站请求伪造等攻击。此扩展已安装在您的虚拟环境中，因为它已在`requirements.txt`文件中声明。
- en: Protecting yourself against SQL injection and cross-site request forgery is
    extremely important, as these are the most common forms of attacks that your website
    will receive. To learn more about these attacks, visit [https://en.wikipedia.org/wiki/SQL_injection](https://en.wikipedia.org/wiki/SQL_injection)
    and [https://en.wikipedia.org/wiki/Cross-site_request_forgery](https://en.wikipedia.org/wiki/Cross-site_request_forgery)
    for information on SQL injection and cross-site request forgery, respectively.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 保护自己免受SQL注入和跨站请求伪造的攻击至关重要，因为这些是您的网站最常收到的攻击形式。要了解更多关于这些攻击的信息，请访问[https://en.wikipedia.org/wiki/SQL_injection](https://en.wikipedia.org/wiki/SQL_injection)和[https://en.wikipedia.org/wiki/Cross-site_request_forgery](https://en.wikipedia.org/wiki/Cross-site_request_forgery)以获取有关SQL注入和跨站请求伪造的信息。
- en: 'To have Flask WTForms'' security measures working properly, we will need a
    **secret key**. A secret key is a random string of characters that will be used
    to cryptographically sign anything that needs to be tested for its authenticity.
    This cannot be just any string; it must be randomized and be of a certain length
    so that brute-force or dictionary attacks won''t be able to crack it in any viable
    amount of time. To generate a random string, enter a Python session and enter
    the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要使Flask WTForms的安全措施正常工作，我们需要一个**密钥**。密钥是一串随机字符，将用于对需要验证其真实性的任何内容进行加密签名。这不能是任何字符串；它必须是随机的，并且具有特定的长度，这样暴力破解或字典攻击就无法在可接受的时间内破解它。要生成随机字符串，进入Python会话并输入以下内容：
- en: '[PRE58]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You should generate a different secret key for each environment. Just copy
    the output from `os.urandom` and paste it into each environment `config` class,
    as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该为每个环境生成不同的密钥。只需复制`os.urandom`的输出并将其粘贴到每个环境的`config`类中，如下所示：
- en: '[PRE59]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: WTForms basics
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WTForms基础知识
- en: 'There are three main parts of WTForms—**forms**, **fields**, and **validators**.
    Fields are representations of input fields and perform rudimentary type checking,
    and validators are functions that are attached to fields that make sure that the
    data submitted in the form is within our constraints. The form is a class that
    contains fields and validators, and validates itself on a `POST` request. Let''s
    see this in action to get a better idea. In the `main.py` file, add the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: WTForms有三个主要部分——**表单**、**字段**和**验证器**。字段是输入字段的表示，并执行基本的类型检查，验证器是附加到字段上的函数，确保表单中提交的数据符合我们的约束。表单是一个包含字段和验证器的类，在`POST`请求上自行验证。让我们看看实际操作，以获得更好的理解。在`main.py`文件中，添加以下内容：
- en: '[PRE60]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Here, we have a class that inherits from Flask WTForm''s `Form` object and
    defines inputs with class variables that equal WTForm fields. The fields take
    an optional parameter, `validators`, which is a list of WTForm validators that
    will be applied to our data. The most commonly used fields are as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个从Flask WTForm的`Form`对象继承的类，并使用等于WTForm字段的类变量定义输入。字段接受一个可选参数`validators`，这是一个将应用于我们数据的WTForm验证器列表。最常用的字段如下：
- en: '`fields.DateField` and `fields.DateTimeField`: Represents a Python `date` or
    `datetime` object and takes an optional parameter format that takes a `stftime`
    format string to translate the data.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields.DateField`和`fields.DateTimeField`：表示Python的`date`或`datetime`对象，并接受一个可选参数格式，该参数接受一个`strftime`格式字符串以转换数据。'
- en: '`fields.IntegerField`: This attempts to coerce passed data to an integer and
    is rendered in the template as a number input.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields.IntegerField`：这尝试将传递的数据强制转换为整数，并在模板中以数字输入的形式呈现。'
- en: '`fields.FloatField`: This attempts to coerce passed data to a float and is
    rendered in the template as a number input.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields.FloatField`：这尝试将传递的数据强制转换为浮点数，并在模板中以数字输入的形式呈现。'
- en: '`fields.RadioField`: This represents a set of radio inputs and takes a `choices `parameter , which
    is a list of tuples that act as the displayed value and the returned value.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields.RadioField`：这表示一组单选输入，并接受一个`choices`参数，这是一个元组列表，用作显示值和返回值。'
- en: '`fields.SelectField`: Along with `SelectMultipleField`, this represents a set
    of radio inputs. It takes a `choices `parameter, which is a list of tuples that
    act as the displayed and returned values.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields.SelectField`：与`SelectMultipleField`一起，它表示一组单选输入。它接受一个`choices`参数，这是一个元组列表，用作显示和返回值。'
- en: '`fields.StringField`: This represents a normal text input, and will attempt
    to coerce the returned data to a string.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields.StringField`：这表示一个普通文本输入，并尝试将返回的数据强制转换为字符串。'
- en: For a full list of validators and fields, visit the WTForms documentation at
    [http://wtforms.readthedocs.org](http://wtforms.readthedocs.org).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完整的验证器和字段列表，请访问WTForms文档[http://wtforms.readthedocs.org](http://wtforms.readthedocs.org)。
- en: 'The most common validators are as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的验证器如下：
- en: '`validators.DataRequired()`'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validators.DataRequired()`'
- en: '`validators.Email()`'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validators.Email()`'
- en: '`validators.Length(min=-1, max=-1)`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validators.Length(min=-1, max=-1)`'
- en: '`validators.NumberRange(min=None, max=None)`'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validators.NumberRange(min=None, max=None)`'
- en: '`validators.Optional()`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validators.Optional()`'
- en: '`validators.Regexp(regex)`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validators.Regexp(regex)`'
- en: '`validators.URL()`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validators.URL()`'
- en: Each of these validations follows the Pythonic naming scheme. Therefore, it
    is rather straightforward as to what they do. All validators take an optional
    parameter called `message`, which is the error message that will be returned if
    the validator fails. If a message is not set, it uses the library defaults.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这些验证器都遵循Pythonic命名规范。因此，它们的作用相当直接。所有验证器都接受一个可选参数`message`，这是验证器失败时将返回的错误消息。如果没有设置消息，它将使用库的默认值。
- en: Custom validations
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义验证
- en: 'Writing a custom validation function is very simple. All that is required is
    to write a function that takes the `form` object and the `field` object as parameters
    and raises a WTForm. A `ValidationError` is raised if the data does not pass the
    test. Here is an example of a custom email validator:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 编写自定义验证函数非常简单。所需做的就是编写一个函数，该函数接受`form`对象和`field`对象作为参数，并抛出WTForm。如果数据未通过测试，则会抛出`ValidationError`异常。以下是一个自定义电子邮件验证器的示例：
- en: '[PRE61]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: To use this function, just add it to the list of validators for your field.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此功能，只需将其添加到您字段的验证器列表中。
- en: Posting comments
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布评论
- en: 'Now that we have our comment form and we understand how to build it, we need
    to add it to the start of our post view, as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了我们的评论表单，并且我们了解了如何构建它，我们需要将其添加到我们的帖子视图的开始处，如下所示：
- en: '[PRE62]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: First, we add the `POST` method to the list of our view's allowed methods. Then,
    a new instance of our form object is created. The `validate_on_submit()` method
    then checks whether the Flask request is a `POST` request. If it is a `POST` request,
    it sends the request form data to the form object. If the data is validated, then
    `validate_on_submit()` returns `True` and adds the data to the `form` object.
    We then take the data from each field, populate a new comment, and add it to the
    database. Note how we don't need to fill in the comment data, because we have
    set a default value for it in the SQLAlchemy model definition—in this case, the `datatime.now` function
    that is going to be evaluated upon the object creation.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`POST`方法添加到我们视图的允许方法列表中。然后创建我们表单对象的新实例。`validate_on_submit()`方法随后检查Flask请求是否为`POST`请求。如果是`POST`请求，它将请求表单数据发送到表单对象。如果数据通过验证，则`validate_on_submit()`返回`True`并将数据添加到`form`对象中。然后我们从每个字段中获取数据，填充一个新的评论，并将其添加到数据库中。注意我们不需要填写评论数据，因为我们已经在SQLAlchemy模型定义中为它设置了一个默认值——在这种情况下，是将在对象创建时评估的`datetime.now`函数。
- en: It is also important to ensure that we wrap all our database calls with a `try`/`except`
    block, and in the case of an error, roll back the session transaction and send
    proper feedback to the users.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 确保我们用`try`/`except`块包裹所有的数据库调用也很重要，如果发生错误，则回滚会话事务并向用户发送适当的反馈。
- en: Note the final `redirect` Flask call to the same endpoint, this time with an
    `HTTP GET`. This means that after a user inserts a new comment, the same page
    is rendered again with a clean form and shows the newly added comment.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 注意最后的`redirect` Flask调用到相同的端点，这次是`HTTP GET`。这意味着在用户插入一条新评论后，相同的页面会再次渲染，带有干净的表单并显示新添加的评论。
- en: If the form does not validate, or if we are handling an `HTTP GET`, we fetch
    the `Post` object from the database by `post_id`, collect all the related comments,
    and finally get all the necessary side-bar data.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表单未通过验证，或者我们正在处理`HTTP GET`请求，我们将通过`post_id`从数据库中获取`Post`对象，收集所有相关的评论，并最终获取所有必要的侧边栏数据。
- en: 'The template itself is divided into three main sections. The first renders
    the post, the second displays the form where the user can submit a new comment
    about the post, and the third is where we render all the comments related to the
    post. Let''s focus on the third section, as shown in the following code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 模板本身分为三个主要部分。第一个部分渲染帖子，第二个部分显示用户可以提交关于帖子的新评论的表单，第三个部分是我们渲染与帖子相关的所有评论的地方。让我们专注于第三个部分，如下面的代码所示：
- en: '[PRE63]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: There are several new things happening here. First, we declare an HTML form
    section and make it submit (using `HTTP POST`) to our `post` Flask endpoint function
    with the current post ID.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个新的变化。首先，我们声明一个HTML表单部分并使其提交（使用`HTTP POST`）到当前的帖子ID的`post` Flask端点函数。
- en: Next, the `form.hidden_tag()` method adds an anticross-site request forgery
    measure automatically.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`form.hidden_tag()`方法自动添加了防止跨站请求伪造的措施。
- en: Then, when calling `field.label`, an HTML label will automatically be created for
    our input. This can be customized when we define our `WTForm FlaskForm` class;
    if not, WTForm will pretty print the field name.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当调用 `field.label` 时，将为我们的输入自动创建一个 HTML 标签。这可以在我们定义 `WTForm FlaskForm` 类时进行自定义；如果不自定义，WTForm
    将以美观的方式打印字段名称。
- en: Next, we check for any errors using `field.errors`, and if there are any, we
    will iterate all of them and render the form validation message to the user. Finally,
    calling the field itself as a method will render the HTML code of that field.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `field.errors` 检查任何错误，如果有，我们将迭代所有错误并向用户渲染表单验证信息。最后，将字段本身作为方法调用将渲染该字段的
    HTML 代码。
- en: 'This third section of the template will display the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 模板中的第三部分将显示以下内容：
- en: '![](img/f0cdd727-2108-49f3-94e6-1f08c71f1c6f.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f0cdd727-2108-49f3-94e6-1f08c71f1c6f.png)'
- en: One challenge for the reader is to make a macro that takes a `form` object and
    an endpoint to send the `POST` request to and autogenerates HTML for the entire
    form tag. Refer to the WTForms documentation if you get stuck. It's tricky, but
    not too difficult.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 对于读者来说的一个挑战是制作一个宏，该宏接受一个 `form` 对象和一个用于发送 `POST` 请求的端点，并自动生成整个表单标签的 HTML。如果你遇到困难，请参考
    WTForms 文档。这很棘手，但并不太难。
- en: Summary
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Now, after only two chapters, you already have a fully functional blog. This
    is where a lot of books on web development technologies would end. However, there
    are still 10 more chapters to go to turn your utilitarian blog into something
    that a user would actually use for their website.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，仅仅两章之后，你已经拥有了一个功能齐全的博客。这是许多关于网络开发技术书籍的结束之处。然而，还有10章更多要学习，才能将你的实用博客变成用户真正用于他们网站的博客。
- en: In the next chapter, we will focus on structuring Flask apps to accommodate
    long-term development and larger scale projects.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将专注于构建 Flask 应用程序的结构，以适应长期发展和更大规模的项目。
