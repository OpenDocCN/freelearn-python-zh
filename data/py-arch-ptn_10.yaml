- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Advanced Event-Driven Structures
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级事件驱动结构
- en: As we saw in the previous chapter, event-driven architectures are quite flexible
    and capable of creating complex scenarios. In this chapter, we will see what are
    the possible event-driven structures that cover more advanced use cases and how
    to deal with their complexities.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中看到的，事件驱动架构非常灵活，能够创建复杂的场景。在本章中，我们将探讨可能的、覆盖更高级用例的事件驱动结构，以及如何处理它们的复杂性。
- en: We will see how some common applications like logs and metrics can be thought
    of as event-driven systems and use them to generate control systems that will
    feedback into the system producing the events.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到一些常见应用，如日志和指标，如何被视为事件驱动系统，并使用它们生成将反馈到产生事件的系统的控制系统。
- en: We will also discuss, with an example, how to create complex pipelines where
    different events are being produced and the system is coordinated. We will also
    move to a more general overview, introducing the bus as a concept to interconnect
    all the event-driven components.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将通过示例讨论如何创建复杂的管道，其中产生不同的事件，系统进行协调。我们还将转向更一般的概述，引入总线作为连接所有事件驱动组件的概念。
- en: We will introduce some general ideas on further complex systems to describe
    some of the challenges that these kinds of big event-driven systems can produce,
    such as the need to use CQRS techniques to retrieve information that crosses multiple
    modules. Finally, we will give some notes on how to test the system, paying attention
    to the different levels of tests.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍一些关于更复杂系统的一般想法，以描述这类大型事件驱动系统可能产生的挑战，例如需要使用CQRS技术检索跨越多个模块的信息。最后，我们将给出一些关于如何测试系统的注意事项，注意测试的不同级别。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Streaming events
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流式事件
- en: Pipelines
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道
- en: Defining a bus
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义总线
- en: More complex systems
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更复杂的系统
- en: Testing event-driven systems
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试事件驱动系统
- en: We will start by describing streams of events.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先描述事件流。
- en: Streaming events
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流式事件
- en: For some purposes, it can be good to just produce events that capture information
    and store it for later access. This structure is typical for instrumentation,
    for example, where we create an event every time there's an error. This event
    will contain information about things such as where the error was generated, debugging
    details to be able to understand it, and so on. The event is then sent, and the
    application continues recovering from the error.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，仅产生捕获信息并存储以供以后访问的事件可能是有益的。这种结构对于监控来说很典型，例如，每次发生错误时我们都会创建一个事件。这个事件将包含有关错误生成位置、调试细节以便理解等信息。然后事件被发送，应用程序继续从错误中恢复。
- en: The same can be done for specific parts of the code. For example, to capture
    an access time to a database, the timing and related data (like the specific query)
    can be captured and sent in an event.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以应用于代码的特定部分。例如，为了捕获对数据库的访问时间，可以捕获计时和相关数据（如特定查询）并作为事件发送。
- en: All those events should be compiled into a location to allow them to be queried
    and aggregated.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些事件都应该被编译到一个位置，以便可以查询和聚合。
- en: While usually not thought of as event-driven processes, this is pretty much
    how logs and metrics work. In the case of logs, the events are generally text
    strings that get fired whenever the code decides to create them. The logs are
    forwarded to a destination that allows us to search them later.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通常不将其视为事件驱动过程，但日志和指标的工作方式基本上就是这样。在日志的情况下，事件通常是文本字符串，每当代码决定创建它们时就会触发。日志被转发到允许我们稍后搜索的目的地。
- en: Logs can be stored in different formats. It's also common to create them in
    JSON to allow better searching.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 日志可以存储在不同的格式中。也常见的是以JSON格式创建它们，以便更好地搜索。
- en: These kinds of events are simple but can be very powerful by allowing us to
    discover what the program is executing in a live system.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这类事件简单但非常强大，因为它允许我们发现程序在实时系统中的执行情况。
- en: This instrumentation may also be used to enable controls or alerts when certain
    conditions are matched. A typical example of this is to alert us if the number
    of errors captured by logs crosses a certain threshold.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这种监控可能也被用来在满足某些条件时启用控制或警报。一个典型的例子是，如果日志捕获的错误数量超过某个阈值，就会向我们发出警报。
- en: '![](img/B17580_08_01.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17580_08_01.png)'
- en: 'Figure 8.1: Monitoring events flow'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：监控事件流程
- en: This can also be used to produce feedback systems, where the instrumentation
    monitoring the system can be used to determine whether to change something in
    the system itself. For example, capturing metrics to determine whether the system
    needs to scale up or scale down and change the number of servers available based
    on the amount of requests or other parameters.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以用来产生反馈系统，其中监控系统中的仪表可以用来确定是否需要在系统本身中更改某些内容。例如，捕获指标以确定系统是否需要扩展或缩减规模，并根据请求数量或其他参数更改可用的服务器数量。
- en: '![Diagram'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图'
- en: Description automatically generated](img/B17580_08_02.png)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_08_02.png)
- en: 'Figure 8.2: Feedback of scaling events'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：扩展事件的反馈
- en: This is not the only way a system can be monitored, though. This method of operation
    can also be used as a way of detecting quotas, for example, short-circuiting the
    processing of incoming requests if a certain quota has been exceeded.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是监控系统唯一的方法，但这种操作方法也可以用作检测配额的方式，例如，如果某个配额已超过，则短路处理传入的请求。
- en: '![Diagram'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![图'
- en: Description automatically generated](img/B17580_08_03.png)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_08_03.png)
- en: 'Figure 8.3: Monitor to detect quotas and stop extra requests'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：监控以检测配额并停止额外请求
- en: This structure is different from the upfront approach of setting a module that
    controls the system, relying instead on acting only when the threshold is breached,
    making the calculations in the background. This can reduce the amount of processing
    required upfront.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构与预先设置一个控制系统的模块的方法不同，而是依赖于仅在阈值被突破时采取行动，在后台进行计算。这可以减少预先需要的处理量。
- en: 'For example, for a quota of a maximum number of requests per minute, the process
    will be something like the following pseudocode:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于一个每分钟最大请求数量的配额，过程可能如下伪代码所示：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`check_quota_info` will be different in both cases. The upfront approach requires
    maintaining and storing information about the previous requests:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`check_quota_info`在这两种情况下将有所不同。预先的方法需要维护和存储有关先前请求的信息：'
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If the validation is done in an external system, based on the events generated,
    `check_quota_info` doesn''t need to store the information, rather just checking
    whether the quota has been exceeded:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果验证是在一个外部系统中完成的，基于生成的事件，`check_quota_info`不需要存储信息，而是只需检查配额是否已超过：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The whole check is performed in the backend monitoring system, based on the
    generated events, and then stored in the info. This detaches the logic for whether
    to apply the quota from the check itself, decreasing the latency. The counterpart
    is that the detection of the quota having been exceeded may be delayed, allowing
    some requests to be processed even if they shouldn't be according to the quota.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 整个检查都是在后端监控系统完成的，基于生成的事件，然后存储在信息中。这将从检查本身中分离出是否应用配额的逻辑，从而降低延迟。但另一方面，配额超过的检测可能会延迟，允许某些请求即使根据配额不应该被处理也能被处理。
- en: Ideally, the generated events should already be in use to monitor the requests
    received. This operation can be very useful as it reuses events generated for
    other uses, reducing the need to collect extra data.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，生成的事件应该已经用于监控接收到的请求。这个操作非常有用，因为它重用了为其他用途生成的事件，减少了收集额外数据的需求。
- en: At the same time, the check can be more complex and doesn't need to be done
    as each new request comes along. For example, for an hourly quota when multiple
    requests are received every second, perhaps a check every minute is good enough
    to ensure the quota is respected. This can save a big deal of processing power
    compared to checking the conditions every time a request is received.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，检查可以更复杂，并且不需要在每次收到新请求时都进行。例如，对于每小时配额，如果每秒收到多个请求，可能每分钟检查一次就足够确保遵守配额。与每次收到请求时检查条件相比，这可以节省大量的处理能力。
- en: This, of course, is highly dependent on the specific scales, characteristics,
    and requests involved in different systems. For some systems, upfront could be
    a better choice, as it's easier to implement and doesn't require a monitoring
    system. Always validate whether the options fit into your system before implementing.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这高度依赖于不同系统中涉及的具体规模、特性和请求。对于某些系统，预先的方法可能更好，因为它更容易实现，且不需要监控系统。在实施之前，始终要验证选项是否适合您的系统。
- en: We will talk in more detail specifically about logs and metrics in *Chapter
    12*, *Logging*, and *Chapter 13*, *Metrics*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第12章“日志”和第13章“指标”中更详细地讨论日志和指标。
- en: Pipelines
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道
- en: The flow of events doesn't have to be contained in a single system. The receiving
    end of the system can produce its own events, directed to other systems. Events
    will cascade into multiple systems, generating a process.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 事件流不必局限于单个系统。系统的接收端可以产生自己的事件，指向其他系统。事件将级联到多个系统，生成一个过程。
- en: This is a similar situation to the one presented previously, but in this case
    it's a more deliberate process aimed at creating specific data pipelines where
    the flow between systems is triggered and processed.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前提出的情况类似，但在这个情况下，它是一个更有目的性的过程，旨在创建特定的数据管道，其中系统之间的流动被触发和处理。
- en: A possible example of this is a system to rescale videos into different sizes
    and formats. When a video is uploaded into the system, it needs to be converted
    into multiple versions to be used in different situations. A thumbnail should
    also be created to display the first frame of the video before playing it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这的一个可能例子是一个将视频缩放到不同大小和格式的系统。当视频被上传到系统中时，它需要转换成多个版本以用于不同的情况。还应创建一个缩略图来显示视频播放前的第一帧。
- en: We will do this in three steps. First, a queue will receive the event to start
    the processing. This will trigger two events in two different queues to process
    the resize and the thumbnail generation independently. This will be our pipeline.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分三步进行。首先，一个队列将接收事件以开始处理。这将触发两个不同队列中的两个事件，分别独立处理缩放和缩略图生成。这将形成我们的管道。
- en: To store the input and output data, given that they are videos and images, we
    require external storage. We will use AWS S3, or more precisely, a mock for S3.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于输入和输出数据是视频和图像，我们需要外部存储来存储它们。我们将使用AWS S3，或者更确切地说，是S3的模拟。
- en: AWS S3 is an object storage service provided by Amazon in the cloud, very popular
    for being both easy to use and very stable. We will use a mock of S3 that will
    allow us to start a local service that behaves like S3, which will simplify our
    example.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: AWS S3是亚马逊在云中提供的一种对象存储服务，因其易于使用和非常稳定而非常受欢迎。我们将使用S3的模拟，这将允许我们启动一个类似S3的本地服务，这将简化我们的示例。
- en: 'Here is a high-level diagram of the system:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是系统的概要图：
- en: '![Diagram'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![图解'
- en: Description automatically generated](img/B17580_08_04.png)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_08_04.png)
- en: 'Figure 8.4: Video and image queue'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：视频和图像队列
- en: To get started, we need to upload the source video to the mock S3 and start
    the task. We will also require some way of checking the results. For that, two
    scripts will be available.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要将源视频上传到模拟S3并启动任务。我们还需要一种方式来检查结果。为此，将提供两个脚本。
- en: The code is available on GitHub at [https://github.com/PacktPublishing/Python-Architecture-Patterns/tree/main/chapter_08_advanced_event_driven](https://github.com/PacktPublishing/Python-Architecture-Patterns/tree/main/chapter_08_advanced_event_driven).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可在GitHub上找到：[https://github.com/PacktPublishing/Python-Architecture-Patterns/tree/main/chapter_08_advanced_event_driven](https://github.com/PacktPublishing/Python-Architecture-Patterns/tree/main/chapter_08_advanced_event_driven)。
- en: Let's start with the setup configuration.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从设置配置开始。
- en: Preparation
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备
- en: 'As outlined above, we have two key prerequisites: a queue backend and the mock
    S3 storage.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，我们有两个关键前提条件：一个队列后端和模拟的S3存储。
- en: 'For the queue backend, we will use Redis again. Redis is very easy to configure
    for multiple queues, and we''ll see how later. To start the Redis queue, we will
    again use Docker to download and run the official image:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于队列后端，我们再次使用Redis。Redis很容易配置多个队列，我们稍后会看到。为了启动Redis队列，我们再次使用Docker来下载和运行官方镜像：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This starts a Redis container exposed on the standard port `6379`. Note the
    `-d` option will keep the container running in the background.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这启动了一个在标准端口`6379`上暴露的Redis容器。注意，`-d`选项将使容器在后台运行。
- en: For the mock S3 service, we will use the same approach, starting a container
    that starts S3 Mock, a system that replicates the S3 API, but stores the files
    locally. This lets us avoid setting up a real S3 instance, which involves getting
    an AWS account, paying for our usage, and so on.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于模拟S3服务，我们将采用相同的方法，启动一个容器来启动S3 Mock，这是一个复制S3 API的系统，但文件是本地存储的。这让我们避免了设置真实的S3实例，这涉及到获取AWS账户，支付我们的使用费用等等。
- en: S3 Mock is a great option for development testing for S3 storage without using
    a real connection to S3\. We will see later how to connect to the mock with a
    standard module. The full documentation can be found at [https://github.com/adobe/S3Mock](https://github.com/adobe/S3Mock).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: S3 Mock 是一个在无需使用真实 S3 连接的情况下进行 S3 存储开发测试的绝佳选项。我们将在后面看到如何使用标准模块连接到模拟。完整文档可以在
    [https://github.com/adobe/S3Mock](https://github.com/adobe/S3Mock) 找到。
- en: 'To start S3 Mock, we will also use Docker:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动 S3 Mock，我们还将使用 Docker：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The container exposes the endpoint on port `9090`. We will direct the S3 requests
    toward this local port. We will use the `videos` bucket for storing all the data.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 容器在端口 `9090` 上公开端点。我们将把 S3 请求指向这个本地端口。我们将使用 `videos` 存储桶来存储所有数据。
- en: 'We will define three different Celery workers that will perform three different
    tasks: the base task, image task and video task. Each one will be pulling events
    from different queues.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义三个不同的 Celery 工作者，它们将执行三个不同的任务：基本任务、图像任务和视频任务。每个任务都将从不同的队列中拉取事件。
- en: This distinction of specific tasks for different workers is done deliberately
    for explanation purposes. In this example, there's probably not a good reason
    to make this distinction, as all the tasks can run in the same worker, and new
    events can be reintroduced in the same queue, and this is recommended, as we saw
    in the previous chapter. Sometimes, though, there are other conditions that may
    require a change of approach.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种为不同工作者指定特定任务的做法是故意为之，用于解释目的。在这个例子中，可能没有很好的理由来区分这一点，因为所有任务都可以在同一个工作者中运行，并且新事件可以重新引入到同一个队列中，正如我们在上一章中看到的，这是推荐的。然而，有时可能会有其他条件需要改变方法。
- en: For example, some of the tasks may require specific hardware for AI processing,
    use way more RAM or CPU power making it impractical to make all workers equal,
    or other reasons that will necessitate separating the workers. Still, be sure
    that there's a good reason to make the split. It will complicate the operation
    and performance of the system.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一些任务可能需要特定的硬件进行 AI 处理，使用更多的 RAM 或 CPU 功率，这使得所有工作者都相等变得不切实际，或者有其他需要分离工作者的原因。不过，确保有充分的理由进行分割。这将使系统的操作和性能复杂化。
- en: 'We will also use some third-party libraries. This includes Celery, as we saw
    in the previous chapter, but also other libraries, like `boto3`, `click`, and
    `MoviePy`. All the required libraries are available in the `requirements.txt`
    file so they can be installed with the following command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用一些第三方库。这包括我们在上一章中看到的 Celery，还包括其他库，如 `boto3`、`click` 和 `MoviePy`。所有必需的库都在
    `requirements.txt` 文件中，可以使用以下命令安装：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's start with the first stage of the process, the base task that will redirect
    to the other two.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从过程的第一个阶段开始，这是将重定向到其他两个阶段的基本任务。
- en: Base task
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本任务
- en: The main task will receive a path that contains the image. It will then create
    two tasks for the processing of the video resizing and the extraction of the thumbnail.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 主要任务将接收包含图像的路径。然后，它将为视频尺寸调整和缩略图提取创建两个任务。
- en: 'Here''s the code for `base_tasks.py`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `base_tasks.py` 的代码：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that we are creating three different queues here:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这里创建了三个不同的队列：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Redis allows us to create different databases easily by referring to them with
    an integer. So, we create database `0` for the base queue, database `1` for the
    images queue, and database `2` for the videos queue.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 允许我们通过整数引用轻松创建不同的数据库。因此，我们为基本队列创建数据库 `0`，为图像队列创建数据库 `1`，为视频队列创建数据库 `2`。
- en: We generate events in these queues with the `.send_task` function. Note that
    on each queue we send the proper task. We include the path as a parameter.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `.send_task` 函数在这些队列中生成事件。请注意，在每一个队列中我们发送适当的任务。我们将路径作为参数包含在内。
- en: Note that all parameters for the tasks are defined in the second parameter of
    `.send_task`. This requires that the parameter is a list of arguments. In this
    case, we only have a single parameter that needs still to be described as a list
    with `[path]`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有任务的参数都定义在 `.send_task` 的第二个参数中。这要求参数是一个参数列表。在这种情况下，我们只有一个需要描述为 `[path]`
    列表的单一参数。
- en: When the task is triggered, it will enqueue the next tasks. Let's take a look
    at the image task.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当任务被触发时，它将排队下一个任务。让我们看看图像任务。
- en: Image task
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图像任务
- en: 'To generate a thumbnail of the video, we need the help of two third-party modules:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成视频的缩略图，我们需要两个第三方模块的帮助：
- en: '*boto3*. This common library helps us connect to AWS services. In particular,
    we will use it to download and upload to our own mocked S3 service.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*boto3*。这个常用的库帮助我们连接到AWS服务。特别是，我们将使用它来下载和上传到我们自己的模拟S3服务。'
- en: You can check the whole `boto3` documentation at [https://boto3.amazonaws.com/v1/documentation/api/latest/index.html](https://boto3.amazonaws.com/v1/documentation/api/latest/index.html).
    It can be used to control all AWS APIs.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://boto3.amazonaws.com/v1/documentation/api/latest/index.html](https://boto3.amazonaws.com/v1/documentation/api/latest/index.html)查看整个`boto3`文档。它可以用来控制所有AWS
    API。
- en: '*MoviePy*. This is a library for working with video. We will extract the first
    frame as an independent file using this library.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*MoviePy*。这是一个用于处理视频的库。我们将使用这个库将第一帧提取为独立的文件。'
- en: The full `MoviePy` documentation is available at [https://zulko.github.io/moviepy/](https://zulko.github.io/moviepy/).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的`MoviePy`文档可在[https://zulko.github.io/moviepy/](https://zulko.github.io/moviepy/)找到。
- en: 'Both libraries are included in the `requirements.txt` file described earlier
    in the chapter and included in the GitHub repo. Let''s take a look at `image_tasks.py`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 之前章节中描述的`requirements.txt`文件和GitHub仓库中都包含了这两个库。让我们看看`image_tasks.py`：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Note that we define the Celery application with the correct database. We then
    describe the task. Let''s divide it into different steps. We first download the
    source file defined in `path` into a temporary file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用正确的数据库定义了Celery应用程序。然后我们描述任务。让我们将其分为不同的步骤。我们首先将`path`中定义的源文件下载到临时文件中：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that we define the endpoint to connect with `MOCK_S3`, which is our S3
    Mock container, exposed on `http://localhost:9090/` as we described before.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们定义了连接到`MOCK_S3`的端点，这是我们的S3模拟容器，如我们之前所述，暴露在`http://localhost:9090/`。
- en: Right after it we generate a temporary file to store the downloaded video. We
    define that the suffix of the temporary file to be `.mp4` so later `VideoPy` can
    detect properly that the temporary file is a video.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着，我们生成一个临时文件来存储下载的视频。我们定义临时文件的后缀为`.mp4`，这样稍后`VideoPy`可以正确地检测到临时文件是一个视频。
- en: Note the next steps are all inside the `with` block defining the temporary file.
    If it was defined outside of this block, the file would be closed and not available.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，接下来的步骤都在定义临时文件的`with`块内部。如果它在这个块外部定义，文件就会被关闭并且不可用。
- en: 'The next step is to load the file in `MoviePy` and then extract the first frame
    into another temporary file. This second temporary file has a suffix of `.png`
    to label it as an image:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将文件加载到`MoviePy`中，然后提取第一帧到另一个临时文件中。这个第二个临时文件的后缀为`.png`，以标识它是一个图像：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, the file is uploaded to S3 Mock, adding `.png` to the end of the original
    name:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，文件被上传到S3模拟，在原始名称的末尾添加`.png`：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Once again, pay attention to the indentation to be sure that the temporary files
    are available at the different stages.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意缩进，以确保在各个阶段临时文件都是可用的。
- en: The task to resize the video follows a similar pattern. Let's take a look.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 调整视频大小的任务遵循类似的模式。让我们看看。
- en: Video task
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视频任务
- en: 'The video Celery worker pulls from the video queue and performs similar steps
    to the image task:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 视频Celery工作进程从视频队列中提取并执行与图像任务类似的步骤：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The only difference from the image task is the resizing of the video to a height
    of 720 pixels and uploading the result:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与图像任务唯一的区别是将视频调整到720像素的高度并上传结果：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: But the general flow is very similar. Note that it's pulling from a different
    Redis database, corresponding to the video queue.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 但总体流程非常相似。注意它从不同的Redis数据库中提取，对应于视频队列。
- en: Connecting the tasks
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接任务
- en: 'To test the system, we need to start all the different elements. Each one is
    started in a different terminal so we can see their different logs:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试系统，我们需要启动所有不同的元素。每个元素都在不同的终端中启动，这样我们可以看到它们的不同的日志：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To start the process, we need a video to be processed in the system.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这个过程，我们需要一个要处理的视频在系统中。
- en: One possibility to find good, free, videos is to use [https://www.pexels.com/](https://www.pexels.com/),
    which has free stock content. For our example run, we will download the 4K video
    with URL [https://www.pexels.com/video/waves-rushing-and-splashing-to-the-shore-1409899/](https://www.pexels.com/video/waves-rushing-and-splashing-to-the-shore-1409899/).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 找到好的免费视频的一个可能性是使用[https://www.pexels.com/](https://www.pexels.com/)，它有免费的股票内容。在我们的示例运行中，我们将下载URL为[https://www.pexels.com/video/waves-rushing-and-splashing-to-the-shore-1409899/](https://www.pexels.com/video/waves-rushing-and-splashing-to-the-shore-1409899/)的4K视频。
- en: 'We will use the following script to upload the video to the S3 Mock storage
    and start the task:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下脚本将视频上传到 S3 Mock 存储并启动任务：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The start of the script describes the Celery queue, the base queue, that will
    be the start of the pipeline. We define several values related to the configuration,
    as we saw in the previous tasks. The only addition is `SOURCE_VIDEO_PATH`, which
    will host the video in S3 Mock.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的开始部分描述了 Celery 队列，即基础队列，它将是管道的起点。我们定义了与配置相关的几个值，正如我们在前面的任务中所看到的。唯一的增加是 `SOURCE_VIDEO_PATH`，它将在
    S3 Mock 中托管视频。
- en: In this script we use the same name to upload all files, overwriting it if the
    script is run again. Feel free to change this if it makes more sense to you to
    do it differently.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在此脚本中，我们使用相同的名称上传所有文件，如果脚本再次运行，则会覆盖它。如果您觉得这样做更有意义，请随意更改。
- en: We use the `click` library to generate an easy **command-line interface** (**CLI**).
    The following lines generate a simple interface that requests the name of the
    video to upload as the parameter of the function.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `click` 库生成一个简单的 **命令行界面**（**CLI**）。以下行生成一个简单的界面，要求输入要上传的视频名称作为函数的参数。
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`click` is a fantastic option to generate CLIs quickly. You can read more about
    it in its documentation here: [https://click.palletsprojects.com/](https://click.palletsprojects.com/).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`click` 是一个快速生成 CLIs 的绝佳选项。您可以在其文档中了解更多信息：[https://click.palletsprojects.com/](https://click.palletsprojects.com/)。'
- en: 'The content of the main function simply connects to our S3 Mock, creates the
    bucket if not set yet, uploads the file to `SOURCE_VIDEO_PATH`, and then sends
    the task to the queue to start the process:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 主函数的内容只是连接到我们的 S3 Mock，如果尚未设置，则创建存储桶，将文件上传到 `SOURCE_VIDEO_PATH`，然后将任务发送到队列以启动进程：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Let's run it and see the results.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行它并查看结果。
- en: Running the task
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行任务
- en: 'The script can be run after adding the name of the video to upload. Remember
    that all the libraries in `requirements.txt` need to be installed:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加视频名称后，您可以运行此脚本。请记住，`requirements.txt` 中的所有库都需要安装：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It will take a bit of time to upload the file to S3 Mock. Once called, the
    first worker to react is the base one. This worker will create two new tasks:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件上传到 S3 Mock 需要一些时间。一旦调用，首先响应的是基础工作者。这个工作者将创建两个新的任务：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The other two will start soon after. The image worker will display new logs,
    starting the image thumbnail creation:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个将在不久后开始。图像工作者将显示新的日志，开始创建图像缩略图：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The video worker will take longer as it needs to resize the video:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 视频工作者需要更长的时间，因为它需要调整视频大小：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To retrieve the results, we will use the `check_results.py` script, which downloads
    the contents of the S3 Mock storage:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索结果，我们将使用 `check_results.py` 脚本，该脚本下载 S3 Mock 存储的内容：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'By running it, we download the files into the local directory:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行它，我们将文件下载到本地目录：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can check the resulting files and confirm that they have been generated
    correctly. Note that `source_video.mp4` will be the same as your input video.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以检查生成的文件并确认它们已正确生成。请注意，`source_video.mp4` 将与您的输入视频相同。
- en: This example demonstrates how to set up a relatively complex pipeline where
    different queues and workers are triggered in a coordinated fashion. Note that
    while we directly used Celery to send the tasks to the queues, we could also have
    used Celery Flower and an HTTP request to do this.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例演示了如何设置一个相对复杂的管道，其中不同的队列和工作者在协调一致的方式下触发。请注意，虽然我们直接使用 Celery 将任务发送到队列，但我们也可以使用
    Celery Flower 和 HTTP 请求来完成此操作。
- en: Defining a bus
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义总线
- en: While we talked about the queue backend system, this hasn't been truly expanded
    to the concept of a bus. The term *bus* originates from the hardware buses that
    transmit data between different components of a hardware system. This makes them
    a central, multisource, and multidestination part of the system.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论队列后端系统时，这还没有真正扩展到总线的概念。术语 *总线* 来自于在硬件系统不同组件之间传输数据的硬件总线。这使得它们成为系统的一个中心、多源和多目的地的部分。
- en: A software bus is a generalization of this concept that allows us to interconnect
    several logical components.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 软件总线是对这个概念的推广，它允许我们互联多个逻辑组件。
- en: In essence, a bus is a component specialized in the transmission of data. This
    is an ordered communication compared to the usual alternative of connecting directly
    to the services through a network, without any intermediate component.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，总线是一种专门用于数据传输的组件。与直接通过网络连接到服务而无需任何中间组件的常规替代方案相比，这是一种有序的通信。
- en: As the bus is in charge of data transmission, that means that the sender doesn't
    need to know much other than the message to transmit and the queue to send it
    to. The bus itself will transmit to the destination or destinations.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于总线负责数据传输，这意味着发送者除了要知道要传输的消息和发送到的队列之外，不需要了解太多。总线本身将传输到目的地或目的地。
- en: The concept of a bus is closely related to that of the *message broker*. A message
    broker, though, typically includes more capacities than a pure bus, such as being
    able to transform messages along the way and use multiple protocols. Message brokers
    can be very complex and allow a huge amount of customization and decoupling of
    services. In general, most of the tools to support the usage of a bus will be
    labeled as message brokers, though some are more powerful than others.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 总线的概念与消息代理的概念密切相关。然而，消息代理通常具有比纯总线更多的能力，例如在途中转换消息和使用多个协议。消息代理可以非常复杂，允许大量定制和服务解耦。一般来说，大多数支持使用总线的工具都会被标记为消息代理，尽管有些比其他更强大。
- en: Though we will use the term "bus", some of the capacities will be more closely
    related to features such as routing messages, which should require tools considered
    message brokers. Analyze the requirements of your specific use cases and use a
    tool that can fulfil them.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将使用“总线”这个术语，但其中一些能力将更紧密地与诸如路由消息等功能相关联，这些功能可能需要被视为消息代理的工具。分析您特定用例的要求，并使用能够满足这些要求的工具。
- en: The bus will be then defined as a central point where all the event-related
    communication will be directed to. This simplifies the configuration, as the events
    can be routed to the proper destination without requiring a different endpoint.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，总线将被定义为所有与事件相关的通信都将指向的中心点。这简化了配置，因为事件可以路由到正确的目的地，而无需不同的端点。
- en: '![Diagram'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图'
- en: Description automatically generated](img/B17580_08_05.png)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_08_05.png)
- en: 'Figure 8.5: Message bussing'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：消息总线
- en: Internally, though, the bus will contain different logical divisions that allow
    the proper routing of messages. These are the queues.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在内部，总线将包含不同的逻辑分区，允许正确路由消息。这些就是队列。
- en: The routing can be complicated, if the bus allows for it, which is the case
    here.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果总线允许，路由可能会变得复杂，这里就是这种情况。
- en: 'In our example before, we used Redis as a bus. Though the connection URL is
    a little different, it can be refactored to make it a bit clearer:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，我们使用了Redis作为总线。尽管连接URL略有不同，但它可以被重构以使其更清晰：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This central location makes the configuration of all the different services
    easy, both for pushing events to the queues and pulling from them.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个中心位置使得配置所有不同的服务变得容易，无论是将事件推送到队列还是从队列中拉取。
- en: More complex systems
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更复杂的系统
- en: More complex systems can be created where the events pass through multiple stages
    and are even designed for easy plugin systems working from the same queue.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 可以创建更复杂的系统，其中事件通过多个阶段，甚至设计为易于插件系统的同一队列。
- en: This can create complicated setups where the data flows through complex pipelines
    and is processed by independent modules. These kinds of scenarios are typically
    seen on instrumentation that aims to analyze and process big quantities of data
    to try and detect patterns and behaviors.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以创建复杂的设置，其中数据通过复杂的管道流动，并由独立的模块处理。这类场景通常出现在旨在分析和处理大量数据以尝试检测模式和行为的仪器中。
- en: Imagine, for example, a system that makes bookings for a travel agency. There
    are a lot of searches and bookings requests that happen in the system, with associated
    purchases such as car rentals, luggage bags, food, and so on. Each of the actions
    produces a regular response (search, book, purchase, and so on), but an event
    describing the action will be introduced into a queue to be processed in the background.
    Different modules will analyze user behavior with different objectives in mind.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，例如，一个为旅行社预订的系统。系统中发生了大量的搜索和预订请求，以及相关的购买，如租车、行李箱、食物等。每个动作都会产生一个常规响应（搜索、预订、购买等），但描述该动作的事件将被引入队列以在后台处理。不同的模块将根据不同的目标分析用户行为。
- en: 'For example, the following modules could be added to this system:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下模块可以添加到这个系统中：
- en: Aggregate economic results by time, to obtain a global view of how the service
    is working over time. This can involve details such as purchases per day, revenue,
    margins, and so on.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按时间汇总经济结果，以获得服务随时间运行的全局视图。这可能包括每天的销售、收入、利润等细节。
- en: Analyze the behavior of regular users. Follow users to discover their patterns.
    What are they searching for before booking? Are they using offers? How often are
    they booking flights? How long is their average trip? Any outliers?
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析普通用户的行为。跟踪用户以发现他们的模式。他们在预订前搜索什么？他们是否使用优惠？他们多久预订一次航班？他们的平均旅行时间有多长？是否有异常情况？
- en: Be sure that there's enough inventory for purchases. Backorder any required
    elements, based on the items being purchased in the system. This includes also
    scheduling enough food for flights, based on pre-purchases.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保库存充足以供购买。根据系统中购买的物品，备货任何所需的元素。这还包括根据预先购买的食品安排足够的航班。
- en: Collect information about preferred destinations, based on searches.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据搜索收集关于首选目的地的信息。
- en: Trigger alerts for things like full flights that could lead to scheduling more
    planes for those days.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于可能导致安排更多飞机的满座航班等情况，触发警报。
- en: These modules are fundamentally about different things and present a different
    view on the system. Some are more oriented toward the behavior of users and marketing,
    while others are more related to logistics. Depending on the size of the system,
    it could be determined that the modules require a different, dedicated team to
    take care of each of them independently.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模块基本上是关于不同的事情，并从不同的角度看待系统。有些更倾向于用户行为和营销，而有些则更与物流相关。根据系统的大小，可能需要确定模块需要不同的、专门的团队来独立处理每个模块。
- en: '![Diagram'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![图'
- en: Description automatically generated](img/B17580_08_06.png)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_08_06.png)
- en: 'Figure 8.6: Bus from front end system to different modules'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：前端系统到不同模块的总线
- en: Note that each system will likely have its own storage to allow it to store
    the information. This could also lead to the creation of their own APIs to access
    this information once collected.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个系统可能都有自己的存储来允许它存储信息。这也可能导致创建自己的API来访问这些信息。
- en: To query the information, the system needs to query the databases of the modules
    where the data is stored. This can be an independent service, but it will likely
    be the same system's front end, as it will typically contain all the external
    interface and permissions handling.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要查询信息，系统需要查询存储数据的模块的数据库。这可能是一个独立的服务，但很可能是同一系统的前端，因为它通常包含所有外部接口和权限处理。
- en: This makes it necessary for the front end system to access the stored information,
    either by directly accessing the database or by using some API to access it. The
    front end system should model access to the data, as we saw in *Chapter 3*, *Data
    Modeling*, and will very likely require a model definition that abstracts the
    complex access to the data.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得前端系统访问存储的信息成为必要，无论是直接访问数据库还是通过使用某些API来访问。前端系统应该模拟数据访问，正如我们在*第3章*，*数据建模*中看到的，并且很可能需要一个抽象复杂数据访问的模型定义。
- en: The same event will be sent to the bus, and then the different services will
    receive it. To be able to do so, you'll need to get a bus that accepts subscriptions
    from several systems and delivers the same message to all subscribed systems.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的事件将被发送到总线上，然后不同的服务将接收它。为了能够这样做，你需要一个接受来自多个系统的订阅并给所有订阅系统传递相同消息的总线。
- en: This pattern is called *publish/subscribe* or *pub/sub*. The consumers of the
    events need to subscribe to the *topic*, which is, in pub/sub parlance, is the
    equivalent of a queue. Most buses accept this system, though it may require some
    work to configure.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式被称为*发布/订阅*或*pub/sub*。事件的消费者需要订阅*主题*，在pub/sub术语中，这相当于一个队列。大多数总线都接受这个系统，尽管可能需要一些工作来配置。
- en: For example, there's a library to allow Celery to work under this system available
    at [https://github.com/Mulugruntz/celery-pubsub](https://github.com/Mulugruntz/celery-pubsub).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，有一个库允许Celery在这个系统下工作，可以在[https://github.com/Mulugruntz/celery-pubsub](https://github.com/Mulugruntz/celery-pubsub)找到。
- en: Note that the workers in this case can create more events to be introduced.
    For example, any module will be able to create an alert, to which the alert system
    will be notified. For example, if the inventory is too low, it may require a quick
    alert at the same time it backorders, to be sure that action is taken quickly.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，工作者可以创建更多的事件来引入。例如，任何模块都将能够创建一个警报，警报系统将会被通知。例如，如果库存太低，它可能需要在同时下订单时发出快速警报，以确保快速采取行动。
- en: '![Diagram'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图'
- en: Description automatically generated](img/B17580_08_07.png)
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_08_07.png)
- en: 'Figure 8.7: Note that communication between the modules and the alerts also
    is done through the bus'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：注意模块和警报之间的通信也是通过总线进行的
- en: Complex event-driven systems can help you distribute the work between different
    components. In this example, you can see how the immediate response (booking a
    flight) is completely independent of the further detailed analysis in the background
    that can be used for longer-term planning. If all the components were added while
    the request was served, it could interfere with performance. The backend components
    can be swapped and upgraded while the front end system is unaffected.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的事件驱动系统可以帮助您在不同组件之间分配工作。在这个例子中，您可以看到即时响应（预订航班）与后台的进一步详细分析（可用于长期规划）是完全独立的。如果所有组件都在请求服务时添加，可能会影响性能。后端组件可以在前端系统不受影响的情况下进行交换和升级。
- en: To properly implement this kind of system, the event needs to use a standard
    format that's easy to adapt and extend, to ensure that any module that receives
    it can quickly scan through it and discard it if it's not necessary.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要正确实现这类系统，事件需要使用一种易于适应和扩展的标准格式，以确保任何接收它的模块都能快速扫描并通过它，如果它不是必需的。
- en: 'A good idea is to use a simple JSON structure like the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好主意是使用以下简单的JSON结构：
- en: '[PRE25]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'For example, when a search is produced, an event like this will be created:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当产生搜索时，将创建如下事件：
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `type` field makes easy to discard the event if it's not of interest to
    any module. For example, the `economic analysis` module will discard any `SEARCH`
    event. Other modules may require further processing. For example, the `user behavior`
    module will analyze `SEARCH` events where the `user` field in the `data` is set.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`type`字段使得如果事件对任何模块没有兴趣，可以很容易地丢弃它。例如，`经济分析`模块将丢弃任何`SEARCH`事件。其他模块可能需要进一步处理。例如，`用户行为`模块将分析`SEARCH`事件，其中`data`中的`user`字段被设置。'
- en: Keep in mind that an important element for event-driven systems is that the
    storage may not be common to all. Perhaps each independent module has its own
    database. You'll need to use the techniques for CQRS that we discussed in *Chapter
    3*, *Data Modeling*, to model data in these modules. In essence, you'll need to
    ask differently to read and to save new data, as writing new data requires the
    generation of events; and you'll need to model them as a business unit. What's
    more, the model may need to merge information from multiple modules in some cases.
    For example, if there's a query in the system that requires obtaining some economic
    information for a user, it needs to query both the `user behavior` module and
    the `economic analysis` module, while presenting the information as a unique model
    of `EconomicInfoUser`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，对于事件驱动系统来说，一个重要元素是存储可能不是通用的。也许每个独立的模块都有自己的数据库。您需要使用我们在*第3章*，*数据建模*中讨论的CQRS技术来在这些模块中建模数据。本质上，您需要以不同的方式读取和保存新数据，因为写入新数据需要生成事件；并且您需要将它们建模为业务单元。更重要的是，模型在某些情况下可能需要合并来自多个模块的信息。例如，如果系统中有一个需要获取用户某些经济信息的查询，它需要查询`用户行为`模块和`经济分析`模块，同时将信息呈现为`EconomicInfoUser`的唯一模型。
- en: When information is frequently accessed, it may make sense to duplicate it in
    several places. This goes against the single responsibility principle (that every
    feature should be the sole responsibility of a single module), but the alternative
    is to create complicated methods of access to get information that's commonly
    used. Be careful when designing and dividing the system to avoid these problems.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当信息频繁访问时，在多个地方重复它可能是有意义的。这违反了单一责任原则（即每个功能应该是单个模块的唯一责任），但另一种选择是创建复杂的方法来获取常用信息。在设计系统时，要小心划分，以避免这些问题。
- en: The flexible data structure will allow for new events to be generated, adding
    more information and allowing for controlled changes across the modules by enforcing
    the backward compatibility of changes. Then the different teams can work in parallel,
    improving the system without stepping on each other's toes too much.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 灵活的数据结构将允许生成新的事件，添加更多信息，并通过强制变化的向后兼容性，允许模块之间进行受控的更改。然后不同的团队可以并行工作，改进系统而不会过多地相互干扰。
- en: But ensuring that they behave correctly can be complicated, as there are multiple
    parts that interact with each other.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 但确保它们的行为正确可能很复杂，因为存在多个相互作用的部件。
- en: Testing event-driven systems
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试事件驱动系统
- en: Event-driven systems are very flexible and, in certain situations, can be incredibly
    useful in detaching different elements. But this flexibility and detachment can
    make them difficult to test to ensure that everything works as expected.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动系统非常灵活，在特定情况下，在分离不同元素方面可以非常有用。但这种灵活性和分离性可能会使它们难以测试以确保一切按预期工作。
- en: 'In general, unit tests are the fastest tests to generate, but the detached
    nature of event-driven systems makes them not very useful to properly test the
    reception of events. Sure, the events can be simulated, and the general behavior
    of receiving an event can be tested. But the problem is: how can we ensure that
    the event has been properly generated? And at the right moment?'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，单元测试是生成最快的测试，但事件驱动系统的独立性质使得它们在正确测试事件接收方面不太有用。当然，事件可以被模拟，接收事件的总体行为可以被测试。但问题是：我们如何确保事件已经被正确生成？并且是在正确的时间？
- en: The only option is to use integration tests to check the behavior of the system.
    But these tests are more expensive to design and run.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的选择是使用集成测试来检查系统的行为。但这些测试的设计和运行成本更高。
- en: There's always an endless debate about naming tests, what exactly a unit test
    is compared to an integration test, system test, acceptance test, and so on. To
    avoid getting into too deep a discussion here, at it's not the objective of the
    book, we will use the term *unit test* to describe tests that can only be run
    in a single module, and *integration test* to refer to those that require two
    or more modules interacting with each other to be successful. Unit tests will
    mock any dependence, but integration tests will actually call the dependence to
    be sure that the connection between modules works correctly.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 总是会有关于命名测试的无限争论，比如单元测试与集成测试、系统测试、验收测试等究竟是什么。为了避免在这里陷入过于深入的讨论，因为这并不是本书的目标，我们将使用“单元测试”一词来描述只能在单个模块中运行的测试，而“集成测试”则指那些需要两个或更多模块相互交互才能成功的测试。单元测试将模拟任何依赖，但集成测试将实际调用依赖以确保模块之间的连接正确无误。
- en: These two levels are significantly different in terms of the cost for each test
    written. Way more unit tests can be written and run than integration tests in
    the same period of time.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个级别在测试的每个测试的成本方面有显著差异。在相同的时间内可以编写和运行比集成测试多得多的单元测试。
- en: 'For example, in our previous example, to test that a purchase of food correctly
    triggers an alert, we need to:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的上一个例子中，为了测试购买食品是否正确触发警报，我们需要：
- en: Generate a call to purchase a food item.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个购买食品项目的调用。
- en: Produce the appropriate event.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 产生适当的事件。
- en: Handle the event in the inventory control. The current inventory should be configured
    as low, which will produce an alert event.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在库存控制中处理事件。当前的库存应配置为低，这将产生一个警报事件。
- en: Handle the alert event properly.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确处理警报事件。
- en: All these steps require configuration to be done in three different systems
    (the front-end system, the inventory control module, and the alert module), along
    with setting up the bus to connect them. Ideally, this test will require the system
    to be able to start up with an automation system to automate the tests. That requires
    every module involved to be automatable.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些步骤都需要在三个不同的系统中进行配置（前端系统、库存控制模块和警报模块），以及设置总线以连接它们。理想情况下，这个测试将需要系统能够启动自动化系统来自动化测试。这要求每个涉及的模块都应该是可自动化的。
- en: As we can see, this is a high bar in setting up and running tests, though it
    is still worth doing. To achieve a sane balance between integration and unit tests,
    we should grow them and apply some strategy to be sure that we have reasonable
    coverage for both.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这在进行测试设置和运行方面是一个很高的标准，尽管它仍然值得去做。为了在集成测试和单元测试之间达到合理的平衡，我们应该增长它们并应用一些策略以确保我们对两者都有合理的覆盖率。
- en: Unit tests are cheap, so every case should have healthy coverage by unit tests,
    where the external modules are mocked. This includes cases such as different input
    formats, different configurations, all flows, errors, and so on. Good unit tests
    should cover most possibilities from an isolation point of view, mocking the input
    of data and any sent event.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试成本低廉，因此每个案例都应该通过单元测试进行健康覆盖，其中外部模块被模拟。这包括不同输入格式、不同配置、所有流程、错误等情况。好的单元测试应该从隔离的角度覆盖大多数可能性，模拟数据的输入和任何发送的事件。
- en: 'For example, continuing the inventory control example, many unit tests can
    control the following requisites, all by changing the input request:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，继续库存控制示例，许多单元测试可以通过更改输入请求来控制以下需求：
- en: Purchase of an element with high inventory.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购买库存量高的元素。
- en: Purchase of an element with low inventory. This should produce an alert event.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购买库存量低的元素。这应该产生一个警报事件。
- en: Purchase of a non-existing element. This should generate an error.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购买一个不存在的元素。这应该生成一个错误。
- en: Event with invalid format. This should generate an error.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式无效的事件。这应该生成一个错误。
- en: Purchase of an element with zero inventory. This should generate an alert event.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购买库存量为零的元素。这应该生成一个警报事件。
- en: More cases, such as different kinds of purchases, formats, and so on.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多案例，例如不同类型的购买、格式等。
- en: Integration tests, on the other hand, should have only a few tests, mostly covering
    the "happy path". The *happy path* means that a regular representative event is
    being sent and processed, but doesn't produce expected errors. The objective of
    an integration test is to confirm that all the parts are connecting and working
    as expected. Given that integration tests are more expensive to run and operate,
    aim to implement only the most important, and keep an eye out for any test that
    isn't worth maintaining and can be pruned.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，集成测试应该只有少数几个测试，主要覆盖“愉快路径”。*愉快路径*意味着正在发送并处理一个常规的代表性事件，但不会产生预期的错误。集成测试的目标是确认所有部分都连接并按预期工作。鉴于集成测试的运行和操作成本更高，应仅实现最重要的测试，并密切关注任何不值得维护且可以修剪的测试。
- en: We described, in the above discussion on integration tests, a happy path scenario.
    The event triggers a handle in the inventory and generates an alert that's also
    handled. For integration tests, this is preferred over not generating an alert,
    as it stresses the system more.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述关于集成测试的讨论中，我们描述了一个愉快的路径场景。事件触发库存中的处理程序并生成一个同样被处理的警报。对于集成测试来说，这比不生成警报更有利，因为它更能考验系统。
- en: Though it depends on the system, the ratio of unit to integration test should
    be heavily weighted toward unit tests, sometimes by 20 times or more (meaning
    1 integration test for 20 unit tests).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这取决于系统，但单元测试与集成测试的比例应该严重偏向单元测试，有时高达20倍以上（意味着1个集成测试对应20个单元测试）。
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen more event-driven systems with a variety of advanced
    and complex architectures that can be designed. We have presented some of the
    flexibility and power that event-driven design can bring to a design, but also
    the challenges attached to event-driven design.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了更多的事件驱动系统，它们具有各种高级和复杂的架构，可以设计。我们展示了事件驱动设计可以给设计带来的灵活性和强大功能，但也提到了事件驱动设计所面临的挑战。
- en: We started by presenting common systems such as logs and metrics as event-driven
    systems, as they are, and considered how looking at them in this way allows us
    to create alerting and feedback systems that can be used to control the source
    of the events.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将日志和度量等常见系统作为事件驱动系统进行介绍，因为它们本身就是这样的，并考虑了以这种方式观察它们如何使我们能够创建用于控制事件来源的警报和反馈系统。
- en: We also presented an example with Celery of a more complex pipeline, including
    the usage of multiple queues and shared storage to generate multiple coordinated
    tasks, such as resizing a video and extracting a thumbnail.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提供了一个使用Celery的更复杂管道的例子，包括使用多个队列和共享存储来生成多个协调任务，例如调整视频大小和提取缩略图。
- en: We presented the idea of a bus, a shared access point for all events in the
    system, and looked at how we can generate more complex systems where events are
    delivered to multiple systems and cascade into complex actions. We also discussed
    the challenges of solving these complex interactions, both in terms of requiring
    the use of CQRS techniques to model information that can be read after the write
    is generated through events, and the demands in terms of testing at different
    levels with unit and integration tests.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提出了总线（bus）的概念，即系统中所有事件的共享访问点，并探讨了如何生成更复杂的系统，在这些系统中事件被发送到多个系统，并级联成复杂的行为。我们还讨论了解决这些复杂交互的挑战，包括在事件生成后需要使用CQRS技术来建模可读信息，以及在单元和集成测试不同级别上的需求。
- en: 'In the next chapter, we will see the two main architectures for complex systems:
    monolithic and microservices.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到复杂系统的两种主要架构：单体架构和微服务架构。
