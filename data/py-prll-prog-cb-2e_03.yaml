- en: Process-Based Parallelism
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于进程的并行
- en: In the previous chapter, we learned how to use threads to implement concurrent
    applications. This chapter will examine the process-based approach that we introduced
    in [Chapter 1](64fc65f9-fe29-4c34-9da7-13f272eaab9e.xhtml), *Getting Started with
    Parallel Computing and Python*. In particular, the focus of the chapter is on
    the Python `multiprocessing` module.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用线程来实现并发应用程序。本章将检查我们在[第1章](64fc65f9-fe29-4c34-9da7-13f272eaab9e.xhtml)，“Python并行计算入门”中介绍的过程方法。特别是，本章的重点是Python的`multiprocessing`模块。
- en: The Python `multiprocessing` module, which is a part of the standard library
    of the language, implements the shared memory programming paradigm, that is, the
    programming of a system that consists of *one or more processors* that have access
    to a shared memory.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`multiprocessing`模块，作为语言标准库的一部分，实现了共享内存编程范式，即由一个或多个具有访问共享内存的*处理器*组成的系统的编程。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Understanding Python's `multiprocessing` module
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Python的`multiprocessing`模块
- en: Spawning a process
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动一个进程
- en: Naming a process
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名一个进程
- en: Running processes in the background
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在后台运行进程
- en: Killing a process
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终止进程
- en: Defining a process in a subclass
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在子类中定义进程
- en: Using a queue to exchange objects
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用队列交换对象
- en: Using pipes to exchange objects
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用管道交换对象
- en: Synchronizing processes
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步进程
- en: Managing a state between processes
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在进程之间管理状态
- en: Using a process pool
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用进程池
- en: Understanding Python's multiprocessing module
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Python的`multiprocessing`模块
- en: The introduction of the Python `multiprocessing` documentation ([https://docs.python.org/2.7/library/multiprocessing.html#introduction](https://docs.python.org/2.7/library/multiprocessing.html#introduction))
    clearly mentions that all the functionality within this package requires the `main`
    module to be importable to the children ([https://docs.python.org/3.3/library/multiprocessing.html](https://docs.python.org/3.3/library/multiprocessing.html)).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Python `multiprocessing` 文档的介绍([https://docs.python.org/2.7/library/multiprocessing.html#introduction](https://docs.python.org/2.7/library/multiprocessing.html#introduction))明确指出，此包内的所有功能都需要`main`模块可被子进程导入([https://docs.python.org/3.3/library/multiprocessing.html](https://docs.python.org/3.3/library/multiprocessing.html))。
- en: 'The `__main__` module is not importable to the children in IDLE, even if you
    run the script as a file with IDLE. To get the correct result, we will run all
    the examples from Command Prompt:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在IDLE中，`__main__`模块不可被子进程导入，即使你以文件形式使用IDLE运行脚本。为了得到正确的结果，我们将从命令提示符运行所有示例：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, `multiprocessing_example.py` is the script's name.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`multiprocessing_example.py`是脚本的名称。
- en: Spawning a process
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动进程
- en: Spawning a process is the creation of a *child process* from a *parent process.*
    The latter continues its execution asynchronously or waits until the child process
    ends.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个进程是从*父进程*创建*子进程*的过程。后者异步执行或等待子进程结束。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The `multiprocessing` library allows spawning processes by following these
    steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiprocessing`库允许通过以下步骤启动进程：'
- en: '*Define* the `process` object.'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*定义*进程对象。'
- en: '*Call* the `start()` method of the process to run it.'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*调用*进程的`start()`方法来运行它。'
- en: '*Call* the `join()` method of the process. It waits until the process has completed
    the job and then exits.'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*调用*进程的`join()`方法。它等待进程完成工作后退出。'
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Let''s have a look at the following steps:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下步骤：
- en: 'To create a process, we need to import the `multiprocessing` module with the
    following command:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个进程，我们需要使用以下命令导入`multiprocessing`模块：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Each process is associated with the `myFunc(i)` function. This function outputs
    the numbers from `0` to `i`, where `i` is the ID associated with the process number:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个进程都与`myFunc(i)`函数相关联。此函数输出从`0`到`i`的数字，其中`i`是与进程号关联的ID：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, we define the `process` object with `myFunc` as the `target` function:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`myFunc`作为`target`函数定义`process`对象：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, we call the `start` and `join` methods on the process created:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在创建的进程上调用`start`和`join`方法：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Without the `join` method, child processes do not end and must be killed manually.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用`join`方法，子进程不会结束，必须手动终止。
- en: How it works...
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this section, we have therefore seen how it is possible to create processes
    by starting from a parent process. This feature is called *spawning a process*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本节中，我们已经看到如何从父进程开始创建进程。这个特性被称为*启动进程*。
- en: 'Python''s `multiprocessing` library allows easy process management by following
    three simple steps. The first step is the process definition through the `multiprocessing`
    class method, `Process`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `multiprocessing` 库通过以下三个简单步骤允许轻松地管理进程。第一步是通过 `multiprocessing` 类方法
    `Process` 进行进程定义：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `Process` method has as an argument of the function to spawn, `myFunc`,
    and any arguments of the function itself.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Process` 方法将 `myFunc` 函数作为要创建的函数的参数，以及函数本身的任何参数。'
- en: 'The following two steps are necessary to execute and exit the process:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 执行和退出进程的以下两个步骤是必要的：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To run the process and display the results, let''s open Command Prompt, preferably
    in the same folder containing the example file (`spawning_processes.py`), and
    then type the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行进程并显示结果，让我们打开命令提示符，最好是在包含示例文件（`spawning_processes.py`）的同一文件夹中，然后输入以下命令：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For each process created (there are six in all), the output of the target function
    is shown. Remember that this is a simple counter from `0` up to the index of the
    process ID:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于创建的每个进程（总共有六个），都会显示目标函数的输出。记住，这是一个从 `0` 到进程 ID 索引的简单计数器：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There's more...
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'This reminds us once again of the importance of instantiating the `Process`
    object within the main section: this is because the child process created imports
    the script file where the `target` function is contained. Then, by instantiating
    the `process` object within this block, we prevent an infinite recursive call
    of such instantiations.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次又一次提醒我们实例化 `Process` 对象在主部分的重要性：这是因为创建的子进程会导入包含 `target` 函数的脚本文件。然后，通过在这个块中实例化
    `process` 对象，我们防止了这种实例化的无限递归调用。
- en: 'A valid workaround is used to define the `target` function in a different script,
    namely `myFunc.py`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用有效的替代方案在另一个脚本中定义 `target` 函数，即 `myFunc.py`：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `main` program containing the process instance is defined in a second file
    (`spawning_processes_namespace.py`):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 包含进程实例的 `main` 程序定义在第二个文件（`spawning_processes_namespace.py`）中：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To run this example, type the following command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此示例，请输入以下命令：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The output is the same as the previous example.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与上一个示例相同。
- en: See also
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The official guide for the `multiprocessing` library can be found at [https://docs.python.org/3/](https://docs.python.org/3/).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiprocessing` 库的官方指南可以在 [https://docs.python.org/3/](https://docs.python.org/3/)
    找到。'
- en: Naming a process
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名进程
- en: In the previous example, we identified the processes and how to pass a variable
    to the target function. However, it is very useful to associate a name to the
    processes as debugging an application requires the processes to be well marked
    and identifiable.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们确定了进程以及如何将变量传递给目标函数。然而，将名称与进程关联非常有用，因为调试应用程序需要进程有良好的标记和可识别性。
- en: Getting ready
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: At some point in your code, it may be crucial to know what process is currently being
    executed. For this purpose, the `multiprocessing` library provides the `current_process()`
    method, which uses the `name` attribute to identify which process is currently
    running. In the following section, we'll learn about this topic.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码的某个地方，可能需要知道当前正在执行哪个进程。为此，`multiprocessing` 库提供了 `current_process()` 方法，它使用
    `name` 属性来识别当前正在运行的进程。在下一节中，我们将学习这个主题。
- en: How to do it...
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Let''s perform the following steps:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤：
- en: 'The `target` function for both the processes is the `myFunc` function. It outputs
    the process name by evaluating the `multiprocessing.current_process().name` method:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个进程的目标函数都是 `myFunc` 函数。它通过评估 `multiprocessing.current_process().name` 方法输出进程名称：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we create `process_with_name` simply by instantiating the `name` parameter
    and `process_with_default_name`:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过实例化 `name` 参数和 `process_with_default_name` 创建 `process_with_name`：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, the processes are started and then joined:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，启动进程并等待它们完成：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the `main` program, the processes are created using the same target function, `myFunc`.
    This function simply prints the process name.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 程序中，使用相同的目标函数 `myFunc` 创建进程。这个函数简单地打印进程名称。
- en: 'To run the example, open Command Prompt and type the following command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行示例，打开命令提示符并输入以下命令：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output looks like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来像这样：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There's more...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The main Python process is `multiprocessing.process._MainProcess`, while child
    processes are `multiprocessing.process.Process`. It can be tested by simply typing
    the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 主 Python 进程是 `multiprocessing.process._MainProcess`，而子进程是 `multiprocessing.process.Process`。可以通过简单地输入以下内容进行测试：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: See also
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关信息
- en: More on this topic can be found at [https://doughellmann.com/blog/2012/04/30/determining-the-name-of-a-process-from-python/](https://doughellmann.com/blog/2012/04/30/determining-the-name-of-a-process-from-python/).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于这个主题的信息可以在[https://doughellmann.com/blog/2012/04/30/determining-the-name-of-a-process-from-python/](https://doughellmann.com/blog/2012/04/30/determining-the-name-of-a-process-from-python/)找到。
- en: Running processes in the background
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在后台运行进程
- en: Running in the background is a mode of execution that is typical of some programs
    that do not require the presence or intervention of the user, and which may be
    concurrent to the execution of other programs (and therefore, it is only possible
    in multitasking systems), resulting in the user being unaware about it. Background
    programs typically perform long or time-consuming tasks such as peer-to-peer filesharing
    programs or defragmentation of filesystems. Many OS processes also run in the
    background.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在后台运行是某些不需要用户存在或干预的程序执行模式，并且可能与其他程序的执行并发（因此，它仅在多任务系统中才可行），导致用户对此一无所知。后台程序通常执行长时间或耗时的任务，如对等文件共享程序或文件系统的碎片整理。许多操作系统进程也在后台运行。
- en: In Windows, programs in this mode (scanning antiviruses or OS updates) often
    place an icon in the system tray (the area of the desktop next to the system clock)
    in order to signal their activity and adopt behaviors that reduce the use of resources
    so as to not interfere with the user's interactive activities, such as slowing
    down or causing interruptions. In Unix and Unix-like systems, processes that run
    in the background are called **daemons**. Using a task manager can highlight all
    running programs including those in the background.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，此模式下的程序（如扫描杀毒软件或操作系统更新）通常在系统托盘（系统时钟旁边的桌面区域）中放置一个图标，以表示其活动并采用减少资源使用的行为，以便不干扰用户的交互式活动，例如减慢速度或造成中断。在Unix和Unix-like系统中，在后台运行的进程被称为**守护进程**。使用任务管理器可以突出显示所有正在运行的程序，包括后台程序。
- en: Getting ready
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The `multiprocessing` module allows—through the daemonic option—to run background
    processes. In the following example, two processes are defined:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiprocessing`模块通过守护选项允许运行后台进程。在以下示例中，定义了两个进程：'
- en: '`background_process` with their `daemon` parameter set to `True`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`background_process`的`daemon`参数设置为`True`'
- en: '`NO_background_process` with their `daemon` parameter set to `False`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NO_background_process`的`daemon`参数设置为`False`'
- en: How to do it...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'In the following example, we implement a target function, namely `foo`, which
    displays the digits from `0` to `4` **if** the child process is in the **background**;
    otherwise, it prints the digits from `5` to `9`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们实现了一个目标函数，即`foo`，如果子进程在**后台**，则显示从`0`到`4`的数字；否则，打印从`5`到`9`的数字：
- en: 'Let''s import the relevant libraries:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入相关的库：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we define the `foo()` function. As previously specified, the printed
    digits depend on the value of the `name` parameter:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义`foo()`函数。如前所述，打印的数字取决于`name`参数的值：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we define the following processes: `background_process` and `NO_background_process`.
    Notice that the `daemon` parameter is set for the two processes:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义以下进程：`background_process`和`NO_background_process`。注意，这两个进程的`daemon`参数都设置了：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Note that only the `daemon` parameter of the process defines whether the process
    should run in the background or not. To run this example, type the following command:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，只有进程的`daemon`参数定义了进程是否应在后台运行。要运行此示例，请输入以下命令：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output clearly reports only the `NO_background_process` output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 输出清楚地报告了只有`NO_background_process`的输出：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output changes the setting of the `daemon` parameter for `background_process`
    to `False`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将`background_process`的`daemon`参数设置为`False`：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To run this example, type the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此示例，请输入以下命令：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output reports the execution of both the `background_process` and `NO_background_process` processes:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 输出报告了`background_process`和`NO_background_process`进程的执行：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: See also
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关信息
- en: A code snippet on how to run a Python script in the background in Linux can
    be found at [https://janakiev.com/til/python-background/](https://janakiev.com/til/python-background/).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中后台运行Python脚本的代码片段可以在[https://janakiev.com/til/python-background/](https://janakiev.com/til/python-background/)找到。
- en: Killing a process
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 终止进程
- en: There is no perfect software and even in the best applications, you can nest
    a bug that leads to blocking the application, which is why modern OSes have developed
    several methods to terminate the processes of applications in order to free the
    system resources and allow the user to use them for other operations as soon as
    possible. This section will show you how to kill a process in your multiprocessing
    application.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 没有完美的软件，即使在最好的应用中，你也可能嵌套一个会导致应用阻塞的错误，这就是为什么现代操作系统开发了多种方法来终止应用程序的进程，以便尽快释放系统资源并允许用户将它们用于其他操作。本节将向您展示如何在您的多进程应用程序中终止进程。
- en: Getting ready
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: It's possible to kill a process immediately by using the `terminate` method.
    Also, we use the `is_alive` method to keep track of whether the process is alive
    or not.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用`terminate`方法立即终止进程。此外，我们还使用`is_alive`方法来跟踪进程是否存活。
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'The following steps allow us to perform the recipe:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤允许我们执行配方：
- en: 'Let''s import the relevant libraries:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入相关的库：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, a simple `target` function is implemented. In this example, the `target`
    function, `foo()`, prints the first `10` digits:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，实现一个简单的`target`函数。在这个例子中，`target`函数`foo()`打印前`10`位数字：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the `main` program, we create a process monitoring its lifetime by the `is_alive`
    method; then, we finish it with a call to `terminate`:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`程序中，我们通过`is_alive`方法创建一个进程来监控其生命周期；然后，我们通过调用`terminate`来结束它：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, we verify the status code when the process is finished and read the attribute
    of the `ExitCode` process:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们验证进程完成时的状态代码并读取`ExitCode`进程的属性：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The possible values of `ExitCode` are as follows:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ExitCode`的可能值如下：'
- en: '`== 0`: No error was produced.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`== 0`：没有产生错误。'
- en: '`> 0`: The process had an error and exited that code.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`> 0`：进程出现错误并退出该代码。'
- en: '`< 0`: The process was killed with a signal of `-1 * ExitCode`.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`< 0`：进程被带有`-1 * ExitCode`信号的信号终止。'
- en: How it works...
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The sample code consists of a target function, `foo()`, whose task is to print
    out the first `10` integer numbers on the screen. In the `main` program, the process
    is executed and then killed by the `terminate` instruction. The process is then
    joined and `ExitCode` is determined.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码由一个目标函数`foo()`组成，其任务是打印屏幕上的前`10`个整数。在`main`程序中，进程被执行，然后通过`terminate`指令终止。进程随后被连接，并确定`ExitCode`。
- en: 'To run the code, type the following command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行代码，请输入以下命令：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, we get the following output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们得到以下输出：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice that the output value of the `ExitCode` code is equal to `**-**15`. The
    negative value of `-15` indicates that the child was terminated by an interrupt
    signal, which is identified by the number `15`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`ExitCode`代码的输出值等于`**-**15`。`-15`的负值表示子进程被中断信号终止，该信号由数字`15`标识。
- en: See also
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: On a Linux machine, a Python process can be identified and then killed simply
    by following the tutorial at [http://www.cagrimmett.com/til/2016/05/06/killing-rogue-python-processes.html](http://www.cagrimmett.com/til/2016/05/06/killing-rogue-python-processes.html).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux机器上，可以通过遵循[http://www.cagrimmett.com/til/2016/05/06/killing-rogue-python-processes.html](http://www.cagrimmett.com/til/2016/05/06/killing-rogue-python-processes.html)中的教程来识别并终止Python进程。
- en: Defining processes in a subclass
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在子类中定义进程
- en: The `multiprocessing` module provides access to process management functionalities.
    In this section, we'll learn about how to define a process in a subclass of the
    `multiprocessing.Process` class.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiprocessing`模块提供了对进程管理功能的访问。在本节中，我们将了解如何在`multiprocessing.Process`类的子类中定义进程。'
- en: Getting ready
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To implement a multiprocessing custom subclass, we need to do the following
    things:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现多进程自定义子类，我们需要做以下事情：
- en: '*Define* a subclass of the `multiprocessing.Process` class, redefining the
    `run()` method.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*定义* `multiprocessing.Process`类的子类，重新定义`run()`方法。'
- en: '*Override* the `_init__(self [,args])` method to add additional arguments,
    if needed.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*覆盖* `_init_(self [,args])`方法以添加所需的额外参数。'
- en: '*Override* the `run(self [,args])` method to implement what `Process` should
    do when it is started.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*覆盖* `run(self [,args])`方法以实现进程启动时应执行的操作。'
- en: Once you have created the new `Process` subclass, you can create an instance
    of it and then start by invoking the `start` method, which will, in turn, call
    the `run` method.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了新的`Process`子类，就可以创建其实例，然后通过调用`start`方法开始执行，这将反过来调用`run`方法。
- en: How to do it...
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Just consider a very simple example, as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 仅考虑一个非常简单的例子，如下所示：
- en: 'Import the relevant library first:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先导入相关库：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, define a subclass, `MyProcess`, overriding only the `run` method, which
    returns the process'' name:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义一个子类，`MyProcess`，只覆盖`run`方法，该方法返回进程的名称：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the `main` program, we define a subclass of `10` processes:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`程序中，我们定义了`10`个进程的子类：
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works...
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Each process subclass is represented by a class that extends the `Process`
    class and overrides the `run()` method. This method is the starting point of `Process`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程子类都由一个扩展`Process`类并覆盖`run()`方法的类表示。这是`Process`的起点：
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the `main` program, we create several objects of the `MyProcess()` type. The
    execution of the thread begins when the `start()` method is called:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`程序中，我们创建了几个`MyProcess()`类型的对象。线程的执行开始于调用`start()`方法时：
- en: '[PRE36]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `join()` command just handles the termination of processes. To run the
    script from Command Prompt, type the following command:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`join()`命令仅处理进程的终止。要从命令提示符运行脚本，请输入以下命令：'
- en: '[PRE37]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output looks like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来像这样：
- en: '[PRE38]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: There's more...
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In object-oriented programming, a subclass is a class that inherits all properties
    from a superclass, whether they are objects or methods. An alternative name to
    subclass is *derived class*. *Inheritance* is the specific term that indicates
    this process by which the daughter or derived classes inherit the properties of
    parent classes or superclasses.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，子类是从超类继承所有属性（无论是对象还是方法）的类。子类的另一个名称是*派生类*。*继承*是表示子类或派生类继承父类或超类属性的具体术语。
- en: You can think of a subclass as a particular genre of its superclass; in fact,
    it can use methods and/or attributes, as well as redefine them through *overriding*.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将子类视为其超类的一个特定流派；实际上，它可以使用方法和/或属性，并通过*重写*来重新定义它们。
- en: See also
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: More information on class definition techniques can be found at [http://buildingskills.itmaybeahack.com/book/python-2.6/html/p03/p03c02_adv_class.html](http://buildingskills.itmaybeahack.com/book/python-2.6/html/p03/p03c02_adv_class.html).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于类定义技术的信息可以在[http://buildingskills.itmaybeahack.com/book/python-2.6/html/p03/p03c02_adv_class.html](http://buildingskills.itmaybeahack.com/book/python-2.6/html/p03/p03c02_adv_class.html)找到。
- en: Using a queue to exchange data
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用队列交换数据
- en: A *queue* is a data structure of the **First-In, First-Out** (**FIFO**) type (the
    first input is the first to exit). A practical example is the queues to get a
    service, how to pay at the supermarket, or get your hair cut at the hairdresser.
    Ideally, you are served in the same order as you were presented to. This is exactly
    how a FIFO queue works.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**队列**是一种**先进先出**（**FIFO**）类型的数据结构（第一个输入的是第一个退出）。一个实际的例子是获取服务的队列，如何在超市付款，或者理发师那里理发。理想情况下，你被服务的顺序与你被呈现的顺序相同。这正是FIFO队列的工作方式。'
- en: Getting ready
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this section, we show you how to use a queue for a *producer-consumer* problem,
    that is a classic example of *process synchronization*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们向您展示如何使用队列来解决生产者-消费者问题，这是一个经典的进程同步示例。
- en: 'The **producer-consumer** problem describes two *processes*: one is the *producer*
    and the other is a *consumer*, sharing a **common** **buffer** of a **fixed**
    **size**.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**生产者-消费者**问题描述了两个**进程**：一个是**生产者**，另一个是**消费者**，它们共享一个**固定大小**的**公共**缓冲区。'
- en: The task of the *producer* is to generate data and to deposit it in the buffer
    continuously. At the same time, the *consumer* will use the data produced, removing
    it from the buffer from time to time. The problem is to ensure that the producer
    does not process new data if the buffer is full and that the consumer does not
    look for data if the buffer is empty. The solution for the producer is to suspend
    its execution if the buffer is full.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 生产者的任务是持续生成数据并将其存入缓冲区。同时，消费者将使用生产出的数据，并时不时地从缓冲区中移除它。问题在于确保当缓冲区满时，生产者不处理新数据，而当缓冲区空时，消费者不寻找数据。对于生产者的解决方案是，如果缓冲区满了，就暂停其执行。
- en: As soon as the consumer has taken an item from the buffer, the producer wakes
    up and starts to fill the buffer again. Similarly, the consumer will suspend if
    the buffer is empty. As soon as the producer has downloaded the data into the
    buffer, the consumer wakes up.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦消费者从缓冲区中取出一个项目，生产者就会醒来并开始再次填充缓冲区。同样，如果缓冲区为空，消费者将暂停。一旦生产者将数据下载到缓冲区中，消费者就会醒来。
- en: How to do it...
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'This solution can be implemented by means of communication strategies between
    processes, shared memory, or message passing. An incorrect solution could result
    in a deadlock, in which both processes wait to be awakened:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此解决方案可以通过进程之间的通信策略、共享内存或消息传递来实现。一个不正确的解决方案可能导致死锁，其中两个进程都在等待被唤醒：
- en: '[PRE39]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s perform the steps as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤执行：
- en: 'The `producer` class is responsible for entering `10` items in the queue by
    using the `put` method:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`producer`类负责通过`put`方法将`10`个项目放入队列：'
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `consumer` class has the task of removing the items from the queue (using
    the `get` method) and verifying that the queue is not empty. If this happens,
    then the flow inside the `while` loop ends with a `break` statement:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`consumer`类的任务是移除队列中的项目（使用`get`方法）并验证队列不为空。如果发生这种情况，则`while`循环中的流程将使用`break`语句结束：'
- en: '[PRE41]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `multiprocessing` class has its `queue` object instantiated in the `main` program:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`multiprocessing`类在`main`程序中实例化了其`queue`对象：'
- en: '[PRE42]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: How it works...
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Within the `main` program, we define the queue using the `multiprocessing.Queue` object.
    Then, it is passed as an argument to the `producer ` and `consumer` processes:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`程序中，我们使用`multiprocessing.Queue`对象定义队列。然后，它作为参数传递给`producer`和`consumer`进程：
- en: '[PRE43]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the `producer` class, the `queue.put` method is used to append new items
    to the queue:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在`producer`类中，使用`queue.put`方法将新项目追加到队列中：
- en: '[PRE44]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'While in the `consumer` class, the `queue.get` method is used to po*p* out
    the items:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在`consumer`类中，使用`queue.get`方法取出项目：
- en: '[PRE45]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Execute the code by typing the following command:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入以下命令执行代码：
- en: '[PRE46]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The following output reports the interaction between the producer and the consumer:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出报告了生产者和消费者之间的交互：
- en: '[PRE47]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: There's more...
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'A queue has the `JoinableQueue` subclass. This provides the following methods:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 队列有`JoinableQueue`子类。这提供了以下方法：
- en: '`task_done()`: This method indicates that a task is complete, for example,
    after using the `get()` method to fetch items from the queue. So `task_done()`
    must be used only by queue consumers.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`task_done()`: 此方法表示任务已完成，例如，在使用`get()`方法从队列中获取项目之后。因此，`task_done()`方法只能由队列消费者使用。'
- en: '`join()`: This method blocks the processes until all the items in the queue
    have been completed and processed.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`join()`: 此方法阻塞进程，直到队列中的所有项目都已完成并处理。'
- en: See also
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: A good tutorial on how to use a queue is available at [https://www.pythoncentral.io/use-queue-beginners-guide/](https://www.pythoncentral.io/use-queue-beginners-guide/).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关于如何使用队列的好教程可在[https://www.pythoncentral.io/use-queue-beginners-guide/](https://www.pythoncentral.io/use-queue-beginners-guide/)找到。
- en: Using pipes to exchange objects
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用管道交换对象
- en: 'A *pipe* does the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 管道执行以下操作：
- en: It returns a pair of connection objects connected by a pipe.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它返回一个通过管道连接的连接对象对。
- en: Every connection object has to send/receive methods to communicate between processes.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个连接对象都必须有发送/接收方法，以便在进程之间进行通信。
- en: Getting ready
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `multiprocessing` library allows you to implement a pipe data structure
    using the `multiprocessing.Pipe (duplex)` function. This returns a pair of objects, `(conn1,
    conn2)`, which represent the end of the pipe.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiprocessing`库允许您使用`multiprocessing.Pipe (duplex)`函数实现管道数据结构。这返回一个对象对`(conn1,
    conn2)`，代表管道的末端。'
- en: The `duplex` parameter determines whether the pipe for the last case is bidirectional
    (that is, `duplex = True`), or unidirectional (that is, `duplex = False`). `conn1`
    can only be used for receiving messages, and `conn2` can only be used for sending
    messages.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`duplex`参数确定最后一个案例的管道是否为双向（即`duplex = True`），或单向（即`duplex = False`）。`conn1`只能用于接收消息，而`conn2`只能用于发送消息。'
- en: Now, let's see how to exchange objects using pipes.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用管道交换对象。
- en: How to do it...
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here is a simple example of pipes. We have one process pipe that outputs numbers
    from `0` to `9`, and a second process pipe that takes the numbers and squares
    them:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的管道示例。我们有一个输出从`0`到`9`数字的进程管道，还有一个接收这些数字并将它们平方的第二个进程管道：
- en: 'Let''s import the `multiprocessing` library:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入`multiprocessing`库：
- en: '[PRE48]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `pipe` function returns a pair of connection objects connected by a *two-way*
    pipe. In the example, `out_pipe` contains the numbers from `0` to `9`, which were
    generated by the `target` function of `create_items`:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pipe`函数返回一个由双向管道连接的连接对象对。在示例中，`out_pipe`包含由`create_items`的`target`函数生成的从`0`到`9`的数字：'
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `multiply_items` function is based on two pipes, `pipe_1` and `pipe_2`:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`multiply_items`函数基于两个管道`pipe_1`和`pipe_2`：'
- en: '[PRE50]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This function returns the product of the elements of each pipe:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此函数返回每个管道元素的乘积：
- en: '[PRE51]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the `main` program,  `pipe_1`, and `pipe_2` are defined:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`程序中定义了`pipe_1`和`pipe_2`：
- en: '[PRE52]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'First, process `pipe_1` with numbers from `0` to `9`:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，处理`pipe_1`，使用从`0`到`9`的数字：
- en: '[PRE53]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, process `pipe_2`, which picks up the numbers from `pipe_1` and squares
    them:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，处理`pipe_2`，它从`pipe_1`中获取数字并将它们平方：
- en: '[PRE54]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Close the processes:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭进程：
- en: '[PRE55]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Print out the results:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印出结果：
- en: '[PRE56]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: How it works...
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Essentially, the two pipes, `pipe_1` and `pipe_2`, are created by the `multiprocessing.Pipe(True)`
    statement:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，两个管道`pipe_1`和`pipe_2`是通过`multiprocessing.Pipe(True)`语句创建的：
- en: '[PRE57]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The first pipe, `pipe_1`, simply created a list of integers from `0` to `9`,
    while the second pipe, `pipe_2`, processed each element of the list created by
    `pipe_1`, calculating the squared value of each element:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个管道`pipe_1`简单地创建了一个从`0`到`9`的整数列表，而第二个管道`pipe_2`则处理由`pipe_1`创建的列表中的每个元素，计算每个元素的平方值：
- en: '[PRE58]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Therefore, both processes are closed:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，两个进程都被关闭：
- en: '[PRE59]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'And the final result is printed:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果被打印出来：
- en: '[PRE60]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Execute the code by typing the following command:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入以下命令执行代码：
- en: '[PRE61]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The following result shows the square of the first `9` digits:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果显示了前`9`个数字的平方：
- en: '[PRE62]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: There's more...
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you need more than two points to communicate, then use a `Queue()` method.
    However, if you need absolute performance, then a `Pipe()` method is much faster
    because `Queue()` is built on top of `Pipe()`**.**
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要超过两个点来通信，那么使用`Queue()`方法。然而，如果你需要绝对性能，那么`Pipe()`方法要快得多，因为`Queue()`是建立在`Pipe()`之上的**。**
- en: See also
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: More information on Python and pipes can be found at [https://www.python-course.eu/pipes.php](https://www.python-course.eu/pipes.php%0d).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于Python和管道的信息可以在[https://www.python-course.eu/pipes.php](https://www.python-course.eu/pipes.php%0d)找到。
- en: Synchronizing processes
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步进程
- en: Multiple processes can work together to perform a given task. Usually, they
    share data. It is important that access to shared data by various processes does
    not produce inconsistent data. Processes that cooperate by sharing data must,
    therefore, act in an orderly manner in order for that data to be accessible. Synchronization
    primitives are quite like those encountered for the library and threading.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 多个进程可以协同工作以执行给定的任务。通常，它们共享数据。确保各种进程对共享数据的访问不会产生不一致的数据非常重要。因此，通过共享数据合作的进程必须以有序的方式行动，以便该数据可访问。同步原语与在库和线程中遇到的类似。
- en: 'Synchronization primitives are as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 同步原语如下：
- en: '**Lock**: This object can be in either the locked or unlocked state. A locked
    object has two methods, `acquire()` and `release()`, to manage access to a shared
    resource.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**锁**：此对象可以是锁定或解锁状态。锁定对象有两个方法，`acquire()`和`release()`，用于管理对共享资源的访问。'
- en: '**Event**: This object realizes simple communication between processes; one
    process signals an event and the other processes wait for it. An event object
    has two methods, `set()` and `clear()`, to manage its own internal flag.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件**：此对象实现了进程之间的简单通信；一个进程发出事件，而其他进程等待它。事件对象有两个方法，`set()`和`clear()`，用于管理其内部标志。'
- en: '**Condition**: This object is used to synchronize parts of a workflow, in sequential
    or parallel processes. It has two basic methods: `wait()` is used to wait for
    a condition and `notify_all()` is used to communicate the condition that was applied.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**条件**：此对象用于同步工作流程的各个部分，在顺序或并行过程中。它有两个基本方法：`wait()`用于等待条件，而`notify_all()`用于传达应用的条件。'
- en: '**Semaphore**: This is used to share a common resource, for example, to support
    a fixed number of simultaneous connections.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信号量**：这用于共享一个公共资源，例如，支持固定数量的同时连接。'
- en: '**RLock**: This defines the *recursive lock* object. The methods and functionality
    of RLock are the same as the `threading` module.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重入锁（RLock）**：这定义了*递归锁*对象。RLock的方法和功能与`threading`模块相同。'
- en: '**Barrier**: This divides a program into phases as it requires all processes
    to reach the barrier before any of the proceeds. Code that is executed after a
    barrier cannot be concurrent with the code that was executed before the barrier.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**屏障**：它将程序划分为阶段，因为它要求所有进程在继续之前都必须到达屏障。在屏障之后执行的代码不能与屏障之前执行的代码并发。'
- en: Getting ready
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: '*Barrier* objects in Python are used to wait for the execution of a fixed number
    of threads to complete before a given thread can proceed with the execution of
    the program.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的*屏障*对象用于在给定线程可以继续执行程序之前等待固定数量的线程执行完成。
- en: The following example shows how to synchronize simultaneous tasks with a `barrier()` object.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何使用`barrier()`对象同步同时任务。
- en: How to do it...
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's consider four processes, wherein process `p1` and process `p2` are managed
    by a barrier statement*,* while process `p3` and process `p4` have *no synchronization*
    directives.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑四个进程，其中进程`p1`和`p2`由屏障语句*管理，*而进程`p3`和`p4`没有*同步*指令。
- en: 'To do this, perform the following steps:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请执行以下步骤：
- en: 'Import the relevant libraries:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入相关库：
- en: '[PRE63]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The `test_with_barrier` function executes the barrier''s **`wait()`** method:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`test_with_barrier`函数执行屏障的`wait()`方法：'
- en: '[PRE64]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'When the two processes have called the `wait()` method, they are released simultaneously:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当两个进程都调用了`wait()`方法时，它们将同时释放：
- en: '[PRE65]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In the `main` program, we created four processes. However, we also need a barrier
    and lock primitive. The `2` parameter in the `Barrier` statement stands for the
    total number of processes to manage:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`程序中，我们创建了四个进程。然而，我们还需要一个屏障和锁原语。`Barrier`语句中的`2`参数代表要管理的进程总数：
- en: '[PRE66]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: How it works...
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Barrier` object provides one of the Python synchronization techniques with
    which single or multiple threads wait until a point in a set of activities and
    make progress together.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`Barrier`对象提供了Python同步技术之一，它允许单个或多个线程等待直到一组活动中的某个点，并一起进行进度。'
- en: 'In the `main` program, the `Barrier` object (that is, `synchronizer`) is defined
    through the following statement:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`程序中，通过以下语句定义了`Barrier`对象（即同步器）：
- en: '[PRE67]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Note that the number `2` within the parentheses represents the number of processes
    that the barrier should wait upon.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，括号内的数字`2`表示屏障应等待的进程数。
- en: 'Then, we implement a set of four processes, but only for the `p1` and `p2` processes.
    Note that `synchronizer` is passed as an argument:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们实现了一组四个进程，但只为`p1`和`p2`进程。请注意，`synchronizer`作为参数传递：
- en: '[PRE68]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Indeed, in the body of the `test_with_barrier` function, the barrier''s `wait()` method is
    used in order to synchronize the processes:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，在`test_with_barrier`函数的主体中，屏障的`wait()`方法被用来同步进程：
- en: '[PRE69]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'By running the script, we can see that the `p1` and `p2` processes print out
    the same timestamps as expected:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行脚本，我们可以看到`p1`和`p2`进程打印出预期的相同时间戳：
- en: '[PRE70]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: There's more...
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The following diagram shows you how a barrier works with the two processes:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了两个进程如何与屏障一起工作：
- en: '![](img/f9077bdf-036b-4f0e-90ea-0ddfd80fc58f.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f9077bdf-036b-4f0e-90ea-0ddfd80fc58f.png)'
- en: Process management with a barrier
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 使用屏障进行进程管理
- en: See also
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Please read [https://pymotw.com/2/multiprocessing/communication.html](https://pymotw.com/2/multiprocessing/communication.html)
    for more examples of process synchronization.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 请阅读[https://pymotw.com/2/multiprocessing/communication.html](https://pymotw.com/2/multiprocessing/communication.html)以获取更多进程同步的示例。
- en: Using a process pool
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用进程池
- en: The process pool mechanism allows the execution of a function across multiple
    input values to be parallelized, distributing *the* input data between processes. The
    process pool, therefore, allows implementing the so-called **data parallelism**
    that is based on the distribution of data through the different processes that
    operate on data in parallel.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 进程池机制允许跨多个输入值并行执行函数，在进程之间分配*输入数据*。因此，进程池允许实现所谓的**数据并行性**，这是基于通过不同进程的数据分布来实现的，这些进程并行地对数据进行操作。
- en: Getting ready
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `multiprocessing` library provides the `Pool` class for simple parallel
    processing tasks.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiprocessing`库提供了`Pool`类，用于简单的并行处理任务。'
- en: 'The `Pool` class has the following methods:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pool`类有以下方法：'
- en: '`apply()`: This blocks until the result is ready.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apply()`: 这将阻塞，直到结果准备好。'
- en: '`apply_async()`: This is a variant of the `apply()` ([https://docs.python.org/2/library/functions.html#apply](https://docs.python.org/2/library/functions.html#apply))
    method, which returns a result object. It is an asynchronous operation that will
    not lock the main thread until all the child classes are executed.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apply_async()`: 这是`apply()`方法（[https://docs.python.org/2/library/functions.html#apply](https://docs.python.org/2/library/functions.html#apply)）的一个变体，它返回一个结果对象。这是一个异步操作，直到所有子类执行完毕，它不会锁定主线程。'
- en: '`map()`: This is the parallel equivalent of the built-in `map()` ([https://docs.python.org/2/library/functions.html#map](https://docs.python.org/2/library/functions.html#map))
    function. This blocks until the result is ready, and it chops the iterable data
    in a number of chunks that are submitted to the process pool as separate tasks.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map()`: 这是内置的 `map()` ([https://docs.python.org/2/library/functions.html#map](https://docs.python.org/2/library/functions.html#map))
    函数的并行等效。它会在结果准备好之前阻塞，并将可迭代数据分割成多个块，作为单独的任务提交给进程池。'
- en: '`map_async()`: This is a variant of the `map()` ([https://docs.python.org/2/library/multiprocessing.html?highlight=pool%20class#multiprocessing.pool.multiprocessing.Pool.map](https://docs.python.org/2/library/multiprocessing.html?highlight=pool%20class#multiprocessing.pool.multiprocessing.Pool.map))
    method, which returns a `result` object. If a callback is specified, then it should
    be callable, which accepts a single argument. When the result becomes ready, a
    callback is applied to it (unless the call fails). A callback should be completed
    immediately; otherwise, the thread that handles the results will get blocked.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map_async()`: 这是 `map()` ([https://docs.python.org/2/library/multiprocessing.html?highlight=pool%20class#multiprocessing.pool.multiprocessing.Pool.map](https://docs.python.org/2/library/multiprocessing.html?highlight=pool%20class#multiprocessing.pool.multiprocessing.Pool.map))
    方法的变体，它返回一个 `result` 对象。如果指定了回调，则它应该是可调用的，接受单个参数。当结果准备好时，将应用回调（除非调用失败）。回调应该立即完成；否则，处理结果的线程将被阻塞。'
- en: How to do it…
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'This example shows you how to implement a process pool to perform a parallel
    application. We create a pool of four processes and then we use the pool''s `map`
    method to perform a simple function:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例展示了如何实现进程池以执行并行应用。我们创建了一个包含四个进程的池，然后我们使用池的 `map` 方法执行一个简单函数：
- en: 'Import the `multiprocessing` library:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `multiprocessing` 库：
- en: '[PRE71]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The `Pool` method applies `function_square` to the input element to perform
    a simple calculation:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Pool` 方法将 `function_square` 函数应用于输入元素以执行简单计算：'
- en: '[PRE72]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The parameter inputs are a list of integers from `0` to `100`:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参数输入是一个从 `0` 到 `100` 的整数列表：
- en: '[PRE73]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The total number of parallel processes is `4`:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并行进程的总数是 `4`：
- en: '[PRE74]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The `pool.map` method submits to the process pool as separate tasks:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pool.map` 方法将任务提交给进程池：'
- en: '[PRE75]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The result of the calculation is stored in `pool_outputs`:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算结果存储在 `pool_outputs` 中：
- en: '[PRE76]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: It is important to note that the result of the `pool.map()` method is equivalent
    to Python's built-in `map()` function, except that the processes run in parallel.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`pool.map()` 方法的输出与 Python 内置的 `map()` 函数的结果等效，只是进程是并行运行的。
- en: How it works…
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Here, we have created a pool of four processes using the following statement:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用以下语句创建了一个包含四个进程的池：
- en: '[PRE77]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Each process has a list of integers as input. Here, `pool.map` works in the
    same way as the map, but uses multiple processes, whose number, four, was previously defined
    during pool creation:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都有一个整数列表作为输入。在这里，`pool.map` 与 `map` 的工作方式相同，但使用多个进程，其数量，即四个，是在创建池时预先定义的：
- en: '[PRE78]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'To terminate the computation of the pool, the usual `close` and `join` functions are
    used:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 要终止进程池的计算，使用常规的 `close` 和 `join` 函数：
- en: '[PRE79]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'To execute this, type the following command:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此操作，请输入以下命令：
- en: '[PRE80]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This is the result that we get after completing the calculation:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完成计算后得到的结果：
- en: '[PRE81]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: There's more...
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In the previous example, we saw that `Pool` also provides the `map` method,
    which allows us to apply a function to a different set of data. In particular,
    the scenario in which the same operation is performed in parallel on the elements
    of the input is referred to as*data parallelism*.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们看到 `Pool` 也提供了 `map` 方法，这允许我们将函数应用于不同的数据集。特别是，在输入元素上并行执行相同操作的场景被称为*数据并行*。
- en: 'In the following example, in which we use `Pool` and `map`, we create `pool`
    with `5` workers and, through the `map` method,a function of `f` is applied to
    a list of `10` elements:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们使用 `Pool` 和 `map`，我们创建了一个包含 `5` 个工作者的 `pool`，并通过 `map` 方法将 `f` 函数应用于一个包含
    `10` 个元素的列表：
- en: '[PRE82]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The output is as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE83]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: See also
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考信息
- en: 'To learn more information about process pools, use the following link: [https://www.tutorialspoint.com/concurrency_in_python/concurrency_in_python_pool_of_processes.htm](https://www.tutorialspoint.com/concurrency_in_python/concurrency_in_python_pool_of_processes.htm).'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于进程池的信息，请使用以下链接：[https://www.tutorialspoint.com/concurrency_in_python/concurrency_in_python_pool_of_processes.htm](https://www.tutorialspoint.com/concurrency_in_python/concurrency_in_python_pool_of_processes.htm)。
