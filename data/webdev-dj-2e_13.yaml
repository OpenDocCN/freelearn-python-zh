- en: 13\. Generating CSV, PDF, and Other Binary Files
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13. 生成 CSV、PDF 以及其他二进制文件
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter teaches you how to generate files in different data formats, such
    as **CSV**, **PDF**, and other binary file formats (for example, Excel-compatible
    files) using some of the common libraries that are available inside Python. This
    knowledge will help you build web projects that let your users export and download
    records from your site into familiar CSV or Excel-based formats. You will also
    learn how to generate graph plots inside Python and render them as HTML and display
    them inside your web applications. Moreover, you will be able to build features
    that let users export your data in PDF format.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将教会你如何使用 Python 中的一些常用库生成不同数据格式的文件，例如 **CSV**、**PDF** 以及其他二进制文件格式（例如，兼容 Excel
    的文件）。这些知识将帮助你构建允许用户将网站上的记录导出并下载到熟悉的 CSV 或 Excel 格式的 Web 项目。你还将学习如何在 Python 中生成图表，并将其渲染为
    HTML，在 Web 应用程序中显示。此外，你将能够构建允许用户以 PDF 格式导出数据的特性。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: So far, we have learned the various aspects of the Django framework and explored
    how we can build web applications using Django with all the features and customizations
    we want.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了 Django 框架的各个方面，并探讨了如何使用 Django 构建具有我们所需的所有功能和自定义的 Web 应用程序。
- en: Let's say that while building a web application, we need to do some analysis
    and prepare some reports. We may need to analyze user demographics about how the
    platform is being used or generate data that can be fed into machine learning
    systems to find patterns. We want our website to display some of the results of
    our analysis in a tabular format and other results as detailed graphs and charts.
    Furthermore, we also want to allow our users to export the reports and peruse
    them further in applications such as Jupyter Notebook and Excel.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在构建 Web 应用程序时需要进行分析并准备一些报告。我们可能需要分析用户的人口统计信息，了解平台的使用情况，或者生成可以输入到机器学习系统中以寻找模式的数据。我们希望我们的网站能够以表格形式显示我们分析的一些结果，并以详细的图表和图形显示其他结果。此外，我们还希望允许我们的用户将报告导出，并在
    Jupyter Notebook 和 Excel 等应用程序中进一步查看。
- en: As we work our way through this chapter, we will learn how to bring these ideas
    to fruition and implement functionality in our web application that allows us
    to export records into structured formats such as tables through the use of **Comma-Separated
    Value** (**CSV**) files or Excel files. We will also learn how to allow our users
    to generate visual representations of the data we have stored inside our web application
    and export it as PDF so it can be distributed easily for quick reference.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们逐步学习本章内容，我们将了解如何将这些想法付诸实践，并在我们的 Web 应用程序中实现功能，使我们能够通过使用 **逗号分隔值**（**CSV**）文件或
    Excel 文件将记录导出为结构化格式，如表格。我们还将学习如何允许我们的用户生成我们存储在 Web 应用程序中的数据的视觉表示，并将其导出为 PDF 格式，以便可以轻松分发以供快速参考。
- en: Let's start our journey by learning how to work with CSV files in Python. Learning
    this skill will help us create functionality that allows our readers to export
    our data for further analysis.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从学习如何在 Python 中处理 CSV 文件开始我们的旅程。掌握这项技能将帮助我们创建允许我们的读者将我们的数据导出以进行进一步分析的功能。
- en: Working with CSV Files inside Python
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Python 中处理 CSV 文件
- en: There are several reasons we may need to export the data in our application.
    One of the reasons may involve performing analysis of that data – for example,
    we may need to understand the demographics of users registered on the application
    or extract patterns of application usage. We may also need to find out how our
    application is working for users to design future improvements. Such use cases
    require data to be in a format that can be easily consumed and analyzed. Here,
    the CSV file format comes to the rescue.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要将应用程序中的数据导出出去，原因有很多。其中一个原因可能涉及对该数据进行分析——例如，我们可能需要了解在应用程序上注册的用户的人口统计信息或提取应用程序使用的模式。我们可能还需要了解我们的应用程序对用户的工作情况，以便设计未来的改进。这些用例需要数据以易于消费和分析的格式存在。在这里，CSV
    文件格式就派上用场了。
- en: CSV is a handy file format that can be used to quickly export data from an application
    in a row-and-column format. CSV files usually have data separated by simple delimiters,
    which are used to differentiate one column from another, and newlines, which are
    used to indicate the start of a new record (or row) inside the table.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: CSV 是一种方便的文件格式，可以用于快速将数据从应用程序中以行和列的格式导出。CSV 文件通常使用简单的分隔符来分隔数据，这些分隔符用于区分一列与另一列，以及换行符，用于在表格内指示新记录（或行）的开始。
- en: Python has great support for working with CSV files in its standard library
    thanks to the `csv` module. This support enables the reading, parsing, and writing
    of CSV files. Let's take a look at how we can leverage the CSV module provided
    by Python to work on CSV files and read and write data from them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Python的标准库通过`csv`模块提供了对CSV文件的良好支持。这种支持使得读取、解析和写入CSV文件成为可能。让我们看看我们如何利用Python提供的CSV模块来处理CSV文件，并从中读取和写入数据。
- en: Working with Python's CSV Module
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python的CSV模块
- en: The `csv` module from Python provides us with the ability to interact with files
    that are in CSV format, which is nothing but a text file format. That is, the
    data stored inside the CSV files is human-readable.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`csv`模块为我们提供了与CSV格式文件交互的能力，CSV格式实际上是一种文本文件格式。也就是说，存储在CSV文件中的数据是可读的。
- en: The `csv` module requires that the file is opened before the methods supplied
    by the `csv` module can be applied. Let's take a look at how we can start with
    the very basic operation of reading data from CSV files.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`csv`模块要求在应用`csv`模块提供的方法之前打开文件。让我们看看我们如何从读取CSV文件的基本操作开始。'
- en: Reading Data from a CSV File
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从CSV文件读取数据
- en: 'Reading data from CSV files is quite easy and consists of the following steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从CSV文件读取数据相当简单，包括以下步骤：
- en: 'First, we open the file:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们打开文件：
- en: '[PRE0]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we are reading the file using the Python `open()` method and then passing
    it the name of the file from which the data is to be read.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，我们使用Python的`open()`方法读取文件，然后将要读取数据的文件名传递给它。
- en: 'Then, we read the data from the `file` object using the `csv` module''s `reader` method:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`csv`模块的`reader`方法从`file`对象中读取数据：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the first line, we imported the `csv` module, which contains the set of
    methods required to work on CSV files:'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第一行，我们导入了`csv`模块，它包含处理CSV文件所需的方法集：
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With the file opened, the next step is to create a CSV `reader` object by using
    the `csv` module''s `reader` method. This method takes in the `file` object as
    returned by the `open()` call and uses the `file` object to read the data from
    the CSV file:'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 文件打开后，下一步是使用`csv`模块的`reader`方法创建一个CSV`reader`对象。此方法接受由`open()`调用返回的`file`对象，并使用该`file`对象从CSV文件中读取数据：
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The data read by the `reader()` method is returned as a list of a list, where
    every sub-list is a new record and every value inside the list is a value for
    the specified column. Generally, the first record in the list is referred to as
    a header, which denotes the different columns that are present inside the CSV
    file, but it is not necessary to have a `header` field inside a CSV file.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过`reader()`方法读取的数据以列表的列表形式返回，其中每个子列表是一个新记录，列表中的每个值都是指定列的值。通常，列表中的第一个记录被称为标题，它表示CSV文件中存在的不同列，但CSV文件中不需要有`header`字段。
- en: 'Once the data is read by the `csv` module, we can iterate over this data to
    perform any kind of operation we may desire. This can be done as follows:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦数据被`csv`模块读取，我们就可以遍历这些数据以执行我们可能需要的任何操作。这可以按照以下方式完成：
- en: '[PRE4]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once the processing is done, we close the CSV file simply by using the `close()`
    method in Python''s file handler object:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦处理完成，我们可以通过在Python的文件处理对象中调用`close()`方法简单地关闭CSV文件：
- en: '[PRE5]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now let's look at our first exercise, where we will implement a simple module
    that helps us read a CSV file and output its contents on our screen.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的第一个练习，我们将实现一个简单的模块，帮助我们读取CSV文件并将内容输出到屏幕上。
- en: 'Exercise 13.01: Reading a CSV File with Python'
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.01：使用Python读取CSV文件
- en: 'In this exercise, you will read and process a CSV file inside Python using
    Python''s built-in `csv` module. The CSV file contains fictitious market data
    of several NASDAQ-listed companies:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将使用Python的内置`csv`模块在Python中读取并处理CSV文件。CSV文件包含几家纳斯达克上市公司虚构的市场数据：
- en: 'First, download the `market_cap.csv` file from the GitHub repository for this
    book by clicking the following link: [http://packt.live/2MNWzOV](http://packt.live/2MNWzOV).'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过点击以下链接从本书的GitHub存储库下载`market_cap.csv`文件：[http://packt.live/2MNWzOV](http://packt.live/2MNWzOV)。
- en: Note
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The CSV file consists of randomly generated data and does not correspond to
    any historical market trends.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: CSV文件由随机生成数据组成，并不对应任何历史市场趋势。
- en: 'Once the file is downloaded, open it and take a look at its contents. You will
    realize that the file contains a set of comma-separated values with each different
    record on its own line:![Figure 13.1: Contents of the market cap CSV file'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦文件下载完成，打开它并查看其内容。您会发现文件包含一组以逗号分隔的值，每个不同的记录都在自己的行上：![图 13.1：市值 CSV 文件内容
- en: '](img/B15509_13_01.jpg)'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15509_13_01.jpg)'
- en: 'Figure 13.1: Contents of the market cap CSV file'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 13.1：市值 CSV 文件内容
- en: 'Once the file is downloaded, you can proceed to write the first piece of code.
    For this, create a new file named `csv_reader.py` in the same directory where
    the CSV file was downloaded and add the following code inside it:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦文件下载完成，您可以继续编写第一段代码。为此，在 CSV 文件下载的同一目录中创建一个名为 `csv_reader.py` 的新文件，并在其中添加以下代码：
- en: '[PRE6]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let's try to understand what you just implemented in the preceding snippet of code.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们尝试理解您在上面的代码片段中刚刚实现的内容。
- en: 'After importing the `csv` module, to keep the code modular, you created a new
    method named `read_csv()` that takes in a single parameter, the filename to read
    the data from:'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在导入 `csv` 模块后，为了使代码模块化，您创建了一个名为 `read_csv()` 的新方法，它接受一个参数，即从其中读取数据的文件名：
- en: '[PRE7]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, if you are not familiar with the approach of opening the file shown in
    the preceding snippet, this is also known as the `with` block will have access
    to the `file` object, and once the code exits the scope of the `with` block, the
    file will be closed automatically.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，如果您不熟悉前面代码片段中显示的文件打开方法，这也被称为 `with` 块将有权访问 `file` 对象，一旦代码退出 `with` 块的作用域，文件将自动关闭。
- en: '[PRE8]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once this is done, you write the entry point method, from which your code will
    begin executing, by calling the `read_csv()` method and passing the name of the
    CSV file to read:'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成此操作后，您需要编写入口点方法，您的代码将从该方法开始执行，通过调用 `read_csv()` 方法并传递要读取的 CSV 文件名：
- en: '[PRE9]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With this, you are done and ready to parse your CSV file now. You can do this
    by running your Python file in the Terminal or Command Prompt as shown here:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这些步骤，您现在可以解析您的 CSV 文件了。您可以通过在终端或命令提示符中运行您的 Python 文件来完成此操作，如下所示：
- en: '[PRE10]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Or, on Windows, use **python csv_reader.py** as shown in *Figure 13.2*.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，在 Windows 上，如 *图 13.2* 所示，使用 **python csv_reader.py**。
- en: 'Once the code executes, you should expect to see the following output:'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码执行后，您应该会看到以下输出：
- en: '![Figure 13.2: Output from the CSV reader program'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 13.2：CSV 读取程序输出'
- en: '](img/B15509_13_02.jpg)'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15509_13_02.jpg)'
- en: 'Figure 13.2: Output from the CSV reader program'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2：CSV 读取程序输出
- en: With this, now you know how to read CSV file contents. Also, as you can see
    from the output of *Exercise 13.01*, *Reading a CSV File with Python*, the output
    for individual rows is represented in the form of a list.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，现在您已经知道了如何读取 CSV 文件内容。同时，如您从 *练习 13.01* 的输出中看到，使用 Python 读取 CSV 文件，单个行的输出以列表的形式表示。
- en: Now, let's look at how we can use the Python `csv` module to create new CSV
    files.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用 Python 的 `csv` 模块创建新的 CSV 文件。
- en: Writing to CSV Files Using Python
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Python 写入 CSV 文件
- en: In the previous section, we explored how we can use the `csv` module in Python
    to read the contents of the CSV-formatted files. Now, let us learn how we can
    write CSV data to files.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们探讨了如何使用 Python 的 `csv` 模块读取 CSV 格式文件的 内容。现在，让我们学习如何将 CSV 数据写入文件。
- en: 'Writing CSV data follows a similar approach as reading from a CSV file, with
    some minor differences. The following steps outline the process of writing data
    to CSV files:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 写入 CSV 数据的方法与从 CSV 文件读取类似，但有细微差别。以下步骤概述了将数据写入 CSV 文件的过程：
- en: 'Open the file in writing mode:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以写入模式打开文件：
- en: '[PRE11]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Obtain a CSV writer object, which can help us write data that is correctly
    formatted in the CSV format. This is done by calling the `writer()` method of
    the `csv` module, which returns a `writer` object, which can be used to write
    CSV format-compatible data to a CSV file:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取一个 CSV 写入器对象，这可以帮助我们写入正确格式化的 CSV 格式的数据。这是通过调用 `csv` 模块的 `writer()` 方法来完成的，它返回一个
    `writer` 对象，可以用来将 CSV 格式兼容的数据写入 CSV 文件：
- en: '[PRE12]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once the `writer` object is available, we can start writing the data. This
    is facilitated by the `write_row()` method of the `writer` object. The `write_row()`
    method takes in a list of values that it writes to the CSV file. The list itself
    indicates a single row and the values inside the list indicate the values of columns:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦 `writer` 对象可用，我们就可以开始写入数据。这可以通过 `writer` 对象的 `write_row()` 方法来实现。`write_row()`
    方法接收一个值列表，将其写入 CSV 文件。列表本身表示一行，列表内的值表示列的值：
- en: '[PRE13]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you want to write multiple records in a single call, you can also use the
    `writerows()` method of the CSV writer. The `writerows()` method behaves similarly
    to the `writerow()` method but takes a list of lists and can write multiple rows
    in one go:'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你想在单次调用中写入多个记录，你也可以使用 CSV 写入器的 `writerows()` 方法。`writerows()` 方法的行为类似于 `writerow()`
    方法，但它接受一个列表的列表，可以一次写入多行：
- en: '[PRE14]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once the records are written, we can then close the CSV file:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录写入后，我们可以关闭 CSV 文件：
- en: '[PRE15]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, let's apply what we've learned in the next exercise and implement a program
    that will help us in writing values to CSV files.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们应用我们学到的知识，并实现一个程序，帮助我们向 CSV 文件写入值。
- en: 'Exercise 13.02: Generating a CSV File Using Python''s csv Module'
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 13.02：使用 Python 的 csv 模块生成 CSV 文件
- en: 'In this exercise, you will use the Python `csv` module to create new CSV files:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将使用 Python 的 `csv` 模块来创建新的 CSV 文件：
- en: 'Create a new file named `csv_writer.py`, inside which you will write the code
    for the CSV writer. Inside this file, add the following code:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `csv_writer.py` 的新文件，在这个文件中，你需要编写 CSV 写入器的代码。在这个文件中，添加以下代码：
- en: '[PRE16]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With this code, you should now be able to create new CSV files easily. Now,
    going step by step, let''s understand what you are trying to do in this code:'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用这段代码，你现在应该能够轻松地创建新的 CSV 文件。现在，一步一步地，让我们理解你在这段代码中试图做什么：
- en: 'You define a new method called `write_csv()`, which takes three parameters:
    the name of the file to which the data should be written (`filename`), the list
    of column names that should be used as headers (`header`), and lastly a list of
    a list that contains the data that needs to be mapped to individual columns (`data`):'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你定义了一个名为 `write_csv()` 的新方法，它接受三个参数：数据应写入的文件名（`filename`）、用作标题的列名列表（`header`），以及最后是一个列表，其中包含需要映射到各个列的数据（`data`）：
- en: '[PRE17]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, with the parameters in place, the next step is to open the file to which
    the data needs to be written and map it to an object:'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，参数已经设置好了，下一步是打开需要写入数据的目标文件，并将其映射到一个对象：
- en: '[PRE18]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once the file is opened, you perform three main steps: first, obtain a new
    CSV writer object by using the `writer()` method from the `csv` module and passing
    it to the file handler that holds a reference to your opened file:'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 文件打开后，你执行三个主要步骤：首先，使用 `csv` 模块的 `writer()` 方法获取一个新的 CSV 写入器对象，并将其传递给包含打开文件引用的文件处理器：
- en: '[PRE19]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The next step involves using the CSV writer''s `writerow()` method to write
    your dataset''s header fields into the file:'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下一步是使用 CSV 写入器的 `writerow()` 方法将数据集的标题字段写入文件：
- en: '[PRE20]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once you have written the header, the last step is to write the data to the
    CSV file for the individual columns that are present. For this, use the `csv`
    module''s `writerows()` method to write multiple rows at once:'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在写入标题之后，最后一步是将数据写入 CSV 文件，针对现有的各个列。为此，使用 `csv` 模块的 `writerows()` 方法一次性写入多行：
- en: '[PRE21]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: We could also have merged the step of writing the header and data into a single
    line of code by having the header list as the first element of the data list and
    calling the `writerows()` method with the data list as a parameter.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们也可以通过将标题和数据合并为数据列表的第一个元素，并使用数据列表作为参数调用 `writerows()` 方法，将写入标题和数据的一步合并为单行代码。
- en: 'When you have created the methods that can write the provided data to a CSV
    file, you write the code for the entry point call, and inside it, set up the values
    for the header, data, and filename fields, and finally call the `write_csv()`
    method that you defined earlier:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你创建了可以将提供的数据写入 CSV 文件的方法后，你编写入口点调用的代码，并在其中设置标题、数据和文件名字段的值，最后调用你之前定义的 `write_csv()`
    方法：
- en: '[PRE22]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now with the code in place, execute the file you just created and see whether
    it creates the CSV file. To execute, run the following command:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在代码已经就绪，执行你刚刚创建的文件，看看它是否创建了 CSV 文件。要执行，请运行以下命令：
- en: '[PRE23]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once the execution finishes, you will see that a new file has been created
    in the same directory as the one in which you executed the command. When you open
    the file, the contents should resemble what you see in the following figure:'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行完成后，你将看到在执行命令的同一目录下创建了一个新文件。当你打开文件时，内容应该类似于以下图示：
- en: '![Figure 13.3: Output from the CSV writer sample_output.csv'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 13.3：CSV 写入器示例输出 sample_output.csv](img/B15509_13_03.jpg)'
- en: '](img/B15509_13_03.jpg)'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 13.3：CSV 写入器示例输出 sample_output.csv](img/B15509_13_03.jpg)'
- en: 'Figure 13.3: Output from the CSV writer sample_output.csv'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3：CSV 写入器示例输出 sample_output.csv
- en: With this, now you are well equipped to read and write the contents of CSV files.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经具备了读取和写入 CSV 文件内容的能力。
- en: With this exercise, we have learned how to write data to a CSV file. Now, it
    is time to look at some enhancements that can make reading and writing data to
    CSV files as a developer more convenient.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个练习，我们学习了如何将数据写入CSV文件。现在，是时候看看一些增强功能，这些功能可以使作为开发者的您在读取和写入CSV文件时更加方便。
- en: A Better Way to Read and Write CSV Files
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更好地读取和写入CSV文件的方法
- en: Now, there is one important thing that needs to be taken care of. If you remember,
    the data read by the CSV reader usually maps values to a list. Now, if you want
    to access the values of individual columns, you need to use list indexes to access
    them. This way is not natural and causes a higher degree of coupling between the
    program responsible for writing the file and the one responsible for reading the
    file. For example, what if the writer program shuffled the order of the rows?
    In this case, you now have to update the reader program to make sure it identifies
    correct rows. So, the question arises, do we have a better way to read and write
    values that, instead of using list indexes, uses column names while preserving
    the context?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有一件重要的事情需要注意。如果您还记得，CSV读取器读取的数据通常将值映射到列表。现在，如果您想访问单个列的值，您需要使用列表索引来访问它们。这种方式并不自然，并且会导致编写文件和读取文件之间的耦合度更高。例如，如果编写程序打乱了行的顺序怎么办？在这种情况下，您现在必须更新读取程序以确保它能够识别正确的行。因此，问题出现了，我们是否有更好的方法来读取和写入值，而不是使用列表索引，而是使用列名，同时保留上下文？
- en: The answer to this is yes, and the solution is provided by another set of CSV
    modules known as `DictReader` and `DictWriter`, which provide the functionality
    of mapping objects in a CSV file to `dict`, rather than to a list.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的答案是肯定的，解决方案由另一组名为`DictReader`和`DictWriter`的CSV模块提供，这些模块提供将CSV文件中的对象映射到`dict`的功能，而不是映射到列表。
- en: 'This interface is easy to implement. Let''s revisit the code you wrote in *Exercise
    13.01*, *Reading a CSV File with Python*. If you wanted to parse the code as dict,
    the implementation of the `read_csv()` method would need to be changed as shown here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口易于实现。让我们回顾一下您在*练习13.01*，*使用Python读取CSV文件*中编写的代码。如果您想将代码解析为字典，`read_csv()`方法的实现需要按如下所示更改：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As you will notice, the only change we did was to change `csv.reader()` to
    `csv.DictReader()`, which should represent individual rows in the CSV file as
    `OrderedDict`. You can also verify this by making this change and executing the
    following command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您将注意到，我们做的唯一改变是将`csv.reader()`改为`csv.DictReader()`，这应该将CSV文件中的单独行表示为`OrderedDict`。您也可以通过进行此更改并执行以下命令来验证这一点：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This should result in the following output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会产生以下输出：
- en: '![Figure 13.4: Output with DictReader'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.4：使用DictReader的输出'
- en: '](img/B15509_13_04.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15509_13_04.jpg)'
- en: 'Figure 13.4: Output with DictReader'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4：使用DictReader的输出
- en: 'As you can see in the preceding figure, the individual rows are mapped as key-value
    pairs in the dictionary. To access these individual fields in rows, we can use
    this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，单独的行被映射为字典中的键值对。要访问这些单独的行中的字段，我们可以使用以下方法：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: That should give us the value of the `stock_symbol` field from our individual records.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会给出我们单个记录中的`stock_symbol`字段的值。
- en: 'Similarly, you can also use the `DictWriter()` interface to operate on CSV
    files as dictionaries. To see this, let''s take a look at the `write_csv()` method
    in *Exercise 13.02*, *Generating a CSV File Using Python''s csv Module*, and modify
    it as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您也可以使用`DictWriter()`接口将CSV文件操作为字典。为了了解这一点，让我们看看*练习13.02*，*使用Python的csv模块生成CSV文件*中的`write_csv()`方法，并按如下方式修改它：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding code, we replaced `csv.writer()` with `csv.DictWriter()`, which
    provides a dictionary-like interface to interact with CSV files. `DictWriter()`
    also takes in a `fieldnames` parameter, which is used to map the individual columns
    in a CSV file before writing.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将`csv.writer()`替换为`csv.DictWriter()`，它提供了一个类似字典的接口来与CSV文件交互。`DictWriter()`还接受一个`fieldnames`参数，该参数用于在写入之前将CSV文件中的单独列映射。
- en: Next, to write this header, call the `writeheader()` method, which writes the
    `fieldname` header to the CSV file.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了写入这个标题，调用`writeheader()`方法，它将`fieldname`标题写入CSV文件。
- en: 'The final call involves the `writerows()` method, which takes in a list of
    dictionaries and writes them to the CSV file. For the code to work correctly,
    you also need to modify the data list to resemble the one shown here:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的调用涉及`writerows()`方法，它接受一个字典列表并将其写入CSV文件。为了使代码正确运行，您还需要修改数据列表，使其类似于以下所示：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With this, you will have enough knowledge to work with CSV files inside Python.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，你将拥有足够的知识来在 Python 中处理 CSV 文件。
- en: Since we are talking about how to deal with tabular data, specifically reading
    and writing it to files, let's take a look at one of the more well-known file
    formats used by one of the most popular tabular data editors – Microsoft Excel.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在讨论如何处理表格数据，特别是将其读取和写入文件，让我们看看最著名的文件格式之一，由最流行的表格数据编辑器之一——微软 Excel——所使用。
- en: Working with Excel Files in Python
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Python 处理 Excel 文件
- en: Microsoft Excel is a world-renowned software in the field of book-keeping and
    tabular record management. Similarly, the XLSX file format that was introduced
    with Excel has seen rapid and widespread adoption and is now supported by all
    the major product vendors.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 微软 Excel 是簿记和表格记录管理领域的世界知名软件。同样，随着 Excel 一起引入的 XLSX 文件格式也迅速得到广泛采用，并且现在所有主要产品供应商都支持它。
- en: You will find that Microsoft Excel and its XLSX format are used quite a lot
    in the marketing and sales departments of many companies. Let's say, for one such
    company's marketing department, you are building a web portal in Django that keeps
    track of the products purchased by users. It also displays data about the purchases,
    such as the time of purchase and the location where the purchase was made. The
    marketing and sales teams are planning to use this data to generate leads or to
    create relevant advertisements.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现微软 Excel 和其 XLSX 格式在许多公司的市场和销售部门中被广泛使用。比如说，对于某家公司的市场部门，你正在使用 Django 构建一个跟踪用户购买产品的网络门户。它还显示了关于购买的数据，例如购买时间和购买地点。市场和销售团队计划使用这些数据来生成潜在客户或创建相关的广告。
- en: Since the marketing and sales teams use Excel quite a lot, we might want to
    export the data available inside our web application in XLSX format, which is
    native to Excel. Soon, we will look at how we can make our website work with this
    XLSX format. But before that, let's quickly take a look at the usage of binary
    file formats.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于市场和销售团队大量使用 Excel，我们可能希望将我们网络应用内部的数据导出为 XLSX 格式，这是 Excel 的原生格式。很快，我们将探讨如何使我们的网站与这种
    XLSX 格式协同工作。但在那之前，让我们快速了解一下二进制文件格式的用法。
- en: Binary File Formats for Data Exports
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据导出的二进制文件格式
- en: Until now, we have worked mainly with textual data and how we can read and write
    it from text files. But often, text-based formats are not enough. For example,
    imagine you want to export an image or a graph. How will you represent an image
    or a graph as text, and how will you read and write to these images?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要处理的是文本数据以及如何从文本文件中读取和写入这些数据。但通常，基于文本的格式是不够的。例如，想象一下你想导出一张图片或一个图表。你将如何用文本表示一张图片或一个图表，以及你将如何读取和写入这些图片？
- en: 'In these situations, binary file formats can come to our rescue. They can help
    us read and write to and from a rich and diverse set of data. All commercial operating
    systems provide native support for working with both text and binary file formats,
    and it comes as no surprise that Python provides one of the most versatile implementations
    to work on binary data files. A simple example of this is the `open` command,
    which you use to state the format you would like to open a file in:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，二进制文件格式可以为我们提供帮助。它们可以帮助我们读取和写入丰富的数据集。所有商业操作系统都提供对文本和二进制文件格式的原生支持，Python
    提供了最灵活的实现之一来处理二进制数据文件，这并不令人惊讶。一个简单的例子是 `open` 命令，你使用它来指定你想要打开的文件格式：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, `b` indicates binary.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`b` 表示二进制。
- en: Starting from this section, we will now be dealing with how we can work on binary
    files and use them to represent and export data from our Django web application.
    The first of the formats we are going to look at is the XLSX file format made
    popular by Microsoft Excel.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从本节开始，我们现在将处理如何处理二进制文件，并使用它们来表示和从我们的 Django 网络应用中导出数据。我们将首先查看的是由微软 Excel 使之流行的
    XLSX 文件格式。
- en: So, let's dive into the handling of XLSX files with Python.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们深入探讨如何使用 Python 处理 XLSX 文件。
- en: Working with XLSX Files Using the XlsxWriter Package
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 XlsxWriter 包处理 XLSX 文件
- en: In this section, we will learn more about the XLSX file format and understand
    how we can work with it using the **XlsxWriter** package.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更深入地了解 XLSX 文件格式，并了解我们如何使用 **XlsxWriter** 包来与之协同工作。
- en: XLSX Files
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: XLSX 文件
- en: 'XLSX files are binary files that are used to store tabular data. These files
    can be read by any software that implements support for this format. The XLSX
    format arranges data into two logical partitions:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: XLSX文件是用于存储表格数据的二进制文件。这些文件可以被任何实现对该格式支持支持的软件读取。XLSX格式将数据安排为两个逻辑分区：
- en: '`Example_file.xlsx` is a workbook **(1)**:![Figure 13.5: Workbooks and Worksheets
    in Excel'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Example_file.xlsx`是一个工作簿**（1）**：![图13.5：Excel中的工作簿和工作表'
- en: '](img/B15509_13_05.jpg)'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15509_13_05.jpg]'
- en: 'Figure 13.5: Workbooks and Worksheets in Excel'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5：Excel中的工作簿和工作表
- en: '`Sheet1` and `Sheet2` are two worksheets **(2)**.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sheet1`和`Sheet2`是两个工作表**（2）**。'
- en: When working with XLSX format, these are the two units that we generally work
    on. If you know about relational databases, you can think of workbooks as databases
    and worksheets as tables.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理XLSX格式时，这两个是我们通常工作的单元。如果你了解关系数据库，你可以将工作簿视为数据库，将工作表视为表。
- en: With that, let's try to understand how we can start working on XLSX files inside Python.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，让我们尝试理解如何在Python中开始处理XLSX文件。
- en: The XlsxWriter Python Package
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: XlsxWriter Python包
- en: Python does not provide native support for working with XLSX files through its
    standard library. But thanks to the vast community of developers within the Python
    ecosystem, it is easy to find a number of packages that can help us manage our
    interaction with XLSX files. One popular package in this category is **XlsxWriter**.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Python的标准库没有提供对XLSX文件的原生支持。但是，多亏了Python生态系统中的庞大开发者社区，我们很容易找到许多可以帮助我们管理XLSX文件交互的包。在这个类别中，一个流行的包是**XlsxWriter**。
- en: '`XlsxWriter` is an actively maintained package by the developer community,
    providing support for interacting with XLSX files. The package provides a lot
    of useful functionalities and supports the creation and management of workbooks
    as well as worksheets in individual workbooks. You can install it by running the
    following command in Terminal or Command Prompt:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`XlsxWriter`是由开发者社区积极维护的包，提供与XLSX文件交互的支持。该包提供了许多有用的功能，并支持创建和管理工作簿以及单个工作簿中的工作表。您可以通过在终端或命令提示符中运行以下命令来安装它：'
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Once installed, you can import the `xlsxwriter` module as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你可以按照以下方式导入`xlsxwriter`模块：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: So, let's look at how we can start creating XLSX files with the support of the
    `XlsxWriter` package.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看如何利用`XlsxWriter`包开始创建XLSX文件。
- en: Creating a Workbook
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建工作簿
- en: 'To start working on XLSX files, we first need to create them. An XLSX file
    is also known as a workbook and can be created by calling the `Workbook` class
    from the `xlsxwriter` module as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始处理XLSX文件，我们首先需要创建它们。XLSX文件也称为工作簿，可以通过从`xlsxwriter`模块调用`Workbook`类来创建，如下所示：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The call to the `Workbook` class opens a binary file, specified with the `filename`
    argument, and returns an instance of `workbook` that can be used to further create
    worksheets and write data.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对`Workbook`类的调用打开一个由`filename`参数指定的二进制文件，并返回一个`workbook`实例，可以用来进一步创建工作表和写入数据。
- en: Creating a Worksheet
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建工作表
- en: 'Before we can start writing data to an XLSX file, we first need to create a
    worksheet. This can be done easily by calling the `add_worksheet()` method of
    the `workbook` object we obtained in the previous step:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始向XLSX文件写入数据之前，我们首先需要创建一个工作表。这可以通过调用我们在上一步中获得的工作簿对象的`add_worksheet()`方法轻松完成：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `add_worksheet()` method creates a new worksheet, adds it to the workbook,
    and returns an object mapping the worksheet to a Python object, through which
    we can write data to the worksheet.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_worksheet()`方法创建一个新的工作表，将其添加到工作簿中，并返回一个将工作表映射到Python对象的映射对象，通过这个对象我们可以将数据写入工作表。'
- en: Writing Data to the Worksheet
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向工作表写入数据
- en: 'Once a reference to the worksheet is available, we can start writing data to
    it by calling the `write` method of the `worksheet` object as shown:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦有了工作表的引用，我们可以通过调用`worksheet`对象的`write`方法开始向其写入数据，如下所示：
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As you can see, the `write()` method takes three parameters: a row number (`row_num`),
    a column number (`col_num`), and the data that belongs to the [`row_num, col_num`]
    pair as represented by `col_value`. This call can be repeated to insert multiple
    data items into the worksheet.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`write()`方法接受三个参数：行号（`row_num`）、列号（`col_num`）以及属于`[row_num, col_num]`对的`col_value`表示的数据。这个调用可以重复进行，以将多个数据项插入到工作表中。
- en: Writing the Data to the Workbook
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将数据写入工作簿
- en: 'Once all the data is written, to finalize the written datasets and cleanly
    close the XLSX file, you call the `close()` method on the workbook:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有数据都写入，为了最终确定写入的数据集并干净地关闭XLSX文件，您需要在工作簿上调用`close()`方法：
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This method writes any data that may be in the file buffer and finally closes
    the workbook. Now, let's use this knowledge to implement our own code, which will
    help us write data to an XLSX file.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法写入文件缓冲区中可能存在的任何数据，并最终关闭工作簿。现在，让我们利用这些知识来实现我们自己的代码，这将帮助我们向XLSX文件写入数据。
- en: Further Reading
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'It''s not possible to cover all the methods and features the `XlsxWriter` package
    provides in this chapter. For more information, you can read the official documentation:
    [https://xlsxwriter.readthedocs.io/contents.html](https://xlsxwriter.readthedocs.io/contents.html).'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，无法涵盖`XlsxWriter`包提供的所有方法和功能。更多信息，您可以阅读官方文档：[https://xlsxwriter.readthedocs.io/contents.html](https://xlsxwriter.readthedocs.io/contents.html)。
- en: 'Exercise 13.03: Creating XLSX Files in Python'
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 13.03：在Python中创建XLSX文件
- en: 'In this exercise, you will use the `XlsxWriter` package to create a new Excel
    (XLSX) file and add data to it from Python:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将使用`XlsxWriter`包创建一个新的Excel（XLSX）文件，并从Python向其中添加数据：
- en: 'For this exercise, you will need the `XlsxWriter` package installed on your
    system. You can install it by running the following command in your Terminal app
    or Command Prompt:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个练习，您需要在系统中安装`XlsxWriter`包。您可以通过在终端应用程序或命令提示符中运行以下命令来安装它：
- en: '[PRE36]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Once the command finishes, you will have the package installed on your system.
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦命令执行完毕，您将在系统中安装上该包。
- en: 'With the package installed, you can start writing the code that will create
    the Excel file. Create a new file named `xlsx_demo.py` and add the following code
    inside it:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在安装了包之后，您就可以开始编写创建Excel文件的代码了。创建一个名为`xlsx_demo.py`的新文件，并在其中添加以下代码：
- en: '[PRE37]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding code snippet, you have created a new function that will assist
    you in creating a new workbook in which you can store your data. Once you have
    created a new workbook, the next step is to create a worksheet that provides you
    with the tabular format needed for you to organize the data to be stored inside
    the XLSX workbook.
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，您已创建了一个新的函数，该函数将帮助您创建一个新的工作簿，您可以在其中存储数据。一旦创建了新的工作簿，下一步就是创建一个工作表，它为您提供了组织要存储在XLSX工作簿中的数据的表格格式。
- en: 'With the workbook created, create a new worksheet by adding the following code
    snippet to your `xlsx_demo.py` file:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建工作簿后，通过在您的`xlsx_demo.py`文件中添加以下代码片段来创建一个新的工作表：
- en: '[PRE38]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the preceding code snippet, you have created a new worksheet using the `add_worksheet()`
    method of the `workbook` object provided by the `XlsxWriter` package. This worksheet
    will then be used to write the data for the objects.
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，您已使用`XlsxWriter`包提供的`workbook`对象中的`add_worksheet()`方法创建了一个新的工作表。然后，这个工作表将被用来写入对象的数据。
- en: 'The next step is to create a helper function that can assist in writing the
    data to the worksheet in a tabular format defined by the row and column numbering.
    For this, add the following snippet of code to your `xlsx_writer.py` file:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建一个辅助函数，它可以协助将数据以表格格式写入工作表，该表格格式由行和列编号定义。为此，将以下代码片段添加到您的`xlsx_writer.py`文件中：
- en: '[PRE39]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the preceding code snippet, you have created a new function named `write_data()`
    that takes two parameters: the `worksheet` object to which the data needs to be
    written and the `data` object represented by a list of lists that needs to be
    written to the worksheet. The function iterates over the data passed to it and
    then writes the data to the row and column it belongs to.'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，您已创建了一个名为`write_data()`的新函数，该函数接受两个参数：需要写入的`worksheet`对象和表示为列表的列表的`data`对象，这些列表需要写入工作表。该函数遍历传递给它的数据，然后将数据写入其所属的行和列。
- en: 'With all the core methods now implemented, you can now add the method that
    can help close the `workbook` object cleanly, such that the data is written to
    the file without any file corruption happening. For this, implement the following
    code snippet in the `xlsx_demo.py` file:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在所有核心方法都已实现，您现在可以添加一个可以帮助干净地关闭`workbook`对象的方法，这样数据就可以写入文件而不会发生任何文件损坏。为此，在`xlsx_demo.py`文件中实现以下代码片段：
- en: '[PRE40]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The last step in the exercise is to integrate all the methods you have implemented
    in the previous steps. For this, create a new entry point method as shown in the
    following code snippet in your `xlsx_demo.py` file:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 练习的最后一步是将你在前几步中实现的所有方法集成在一起。为此，在你的 `xlsx_demo.py` 文件中创建一个新的入口点方法，如下面的代码片段所示：
- en: '[PRE41]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding code snippet, you first created a dataset that you want to
    write to the XLSX file in the form of a list of lists. Once that was done, you
    obtained a new `workbook` object, which will be used to create an XLSX file. Inside
    this `workbook` object, you then created a worksheet to organize your data in
    a row-and-column format and then wrote the data to the worksheet and closed the
    workbook to persist the data to the disk.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，你首先创建了一个数据集，你希望将其以列表的形式写入 XLSX 文件。一旦完成，你获得了一个新的 `workbook` 对象，该对象将用于创建
    XLSX 文件。在这个 `workbook` 对象内部，你创建了一个工作表来以行列格式组织你的数据，然后将数据写入工作表，并关闭工作簿以将数据持久化到磁盘。
- en: 'Now, let''s see whether the code you wrote works the way it is expected to
    work. For this, run the following command:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看你编写的代码是否按预期工作。为此，运行以下命令：
- en: '[PRE42]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Once the command is finished executing, you will see a new file with the name
    `sample_workbook.xlsx` being created in the directory where the command was executed.
    To verify whether it contains the correct results, open this file with either
    Microsoft Excel or Google Sheets and view the contents. It should resemble what
    you see here:'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦命令执行完毕，你将在命令执行的目录中看到一个名为 `sample_workbook.xlsx` 的新文件被创建。为了验证它是否包含正确的结果，你可以用
    Microsoft Excel 或 Google Sheets 打开此文件，查看内容。它应该看起来像这里所示：
- en: '![Figure 13.6: Excel sheet generated using xlsxwriter'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 13.6：使用 xlsxwriter 生成的 Excel 表格]'
- en: '](img/B15509_13_06.jpg)'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15509_13_06.jpg]'
- en: 'Figure 13.6: Excel sheet generated using xlsxwriter'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.6：使用 xlsxwriter 生成的 Excel 表格
- en: 'With the help of the `xlsxwriter` module, you can also apply formulas to your
    columns. For example, if you wanted to add another row that shows the average
    age of the people in the spreadsheet, you can do that simply by modifying the
    `write_data()` method as shown here:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `xlsxwriter` 模块的帮助下，你还可以将公式应用到你的列上。例如，如果你想添加一行来显示电子表格中人们的平均年龄，你可以通过简单地修改如下的
    `write_data()` 方法来实现：
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the preceding code snippet, you added an additional `write` call to the worksheet
    and used the `AVERAGE` function provided by Excel to calculate the average age
    of the people in the worksheet.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，你向工作表添加了一个额外的 `write` 调用，并使用了 Excel 提供的 `AVERAGE` 函数来计算工作表中人们的平均年龄。
- en: With this, you now know how we can generate Microsoft Excel-compatible XLSX
    files using Python and how to export tabular content that's easily consumable
    by the different teams in your organization.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，你现在知道了如何使用 Python 生成与 Microsoft Excel 兼容的 XLSX 文件，以及如何导出易于组织内部不同团队消费的表格内容。
- en: Now, let's cover another interesting file format that is widely used across
    the world.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来探讨另一个在全球范围内广泛使用的有趣文件格式。
- en: Working with PDF Files in Python
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Python 中处理 PDF 文件
- en: '**Portable Document Format** or **PDF** is one of the most common file formats
    in the world. You must have encountered PDF documents at some point. These documents
    can include business reports, digital books, and more.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**便携式文档格式**或**PDF**是世界上最常见的文件格式之一。你肯定在某些时候遇到过 PDF 文档。这些文档可以包括商业报告、数字书籍等等。'
- en: Also, do you remember ever having encountered websites that have a button that
    reads `Print` `page` `as` `PDF`? A lot of websites for government agencies readily
    provide this option, which allows you to print the web page directly as a PDF.
    So, the question arises, how can we do this for our web app? How should we add
    the option to export certain content as a PDF?
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还记得曾经遇到过有“打印”页面“作为 PDF”按钮的网站吗？许多政府机构的网站都提供了这个选项，允许你直接将网页打印成 PDF。因此，问题来了，我们如何为我们的
    Web 应用程序做这件事？我们应该如何添加导出某些内容为 PDF 的选项？
- en: Over the years, a huge community of developers has contributed a lot of useful
    packages to the Python ecosystem. One of those packages can help us achieve PDF
    file generation.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 几年来，一个庞大的开发者社区为 Python 生态系统贡献了大量的有用包。其中之一可以帮助我们实现 PDF 文件生成。
- en: Converting Web Pages to PDFs
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将网页转换为 PDF
- en: Sometimes, we may run into situations where we want to convert a web page into
    a PDF. For example, we may want to print a web page to store it as a local copy.
    This also comes in handy when trying to print a certificate that is natively displayed
    as a web page.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能会遇到想要将网页转换为 PDF 的情况。例如，我们可能想要打印网页以存储为本地副本。当尝试打印原生显示为网页的证书时，这也很有用。
- en: To help us in such efforts, we can leverage a simple library known as `weasyprint`,
    which is maintained by a community of Python developers and allows the quick and
    easy conversion of web pages to PDFs. So, let's take a look at how we can generate
    a PDF version of a web page.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们进行这样的努力，我们可以利用一个名为 `weasyprint` 的简单库，该库由一群 Python 开发者维护，并允许快速轻松地将网页转换为
    PDF。那么，让我们看看我们如何生成网页的 PDF 版本。
- en: 'Exercise 13.04: Generating a PDF Version of a Web Page in Python'
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 13.04：在 Python 中生成网页的 PDF 版本
- en: 'In this exercise, you will generate a PDF version of a website using Python.
    You will use a community-contributed Python module known as `weasyprint` that
    will help you generate the PDF:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将使用一个名为 `weasyprint` 的社区贡献的 Python 模块来生成 PDF 版本的网站。这个模块将帮助你生成 PDF：
- en: 'To make the code in the upcoming steps work correctly, install the `weasyprint`
    module on your system. To do this, run the following command:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使接下来的步骤中的代码正确工作，请在你的系统上安装 `weasyprint` 模块。为此，运行以下命令：
- en: '[PRE44]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: '`weasyprint` depends on the `cairo` library. In case you haven''t installed `cairo`
    libraries, usage of `weasyprint` might raise an error with the message: `libcairo-2.dll`
    `file` `not` `found`. If you''re facing this issue or any other issue installing
    the module, use the `requirements.txt` file we''ve provided on our GitHub repository
    at [http://packt.live/3btLoVV](http://packt.live/3btLoVV). Download the file to
    your disk and open your Terminal, shell or Command Prompt and type the following
    command (you will need to `cd` to the path where you saved this file locally):
    `pip install -r requirements.txt`. If that doesn''t work, follow the steps as
    mentioned in the `weasyprint` documentation: [https://weasyprint.readthedocs.io/en/stable/install.html](https://weasyprint.readthedocs.io/en/stable/install.html).'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`weasyprint` 依赖于 `cairo` 库。如果你还没有安装 `cairo` 库，使用 `weasyprint` 可能会引发错误，错误信息为：`libcairo-2.dll`
    `file` `not` `found`。如果你遇到这个问题或安装模块时遇到任何其他问题，请使用我们提供的位于 GitHub 仓库中的 `requirements.txt`
    文件，网址为 [http://packt.live/3btLoVV](http://packt.live/3btLoVV)。将文件下载到你的磁盘上，然后在终端、shell
    或命令提示符中输入以下命令（你需要 `cd` 到保存此文件的本地路径）：`pip install -r requirements.txt`。如果这还不行，请按照
    `weasyprint` 文档中提到的步骤进行操作：[https://weasyprint.readthedocs.io/en/stable/install.html](https://weasyprint.readthedocs.io/en/stable/install.html)。'
- en: 'With the package now installed, create a new file named `pdf_demo.py` that
    will contain the PDF generation logic. Inside this file, write the following code:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在包已经安装，创建一个名为 `pdf_demo.py` 的新文件，该文件将包含 PDF 生成逻辑。在这个文件中，编写以下代码：
- en: '[PRE45]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, let''s try to understand what this code does. In the first line, you imported
    the `HTML` class from the `weasyprint` package, which you installed in *step 1*:'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，让我们尝试理解这段代码的作用。在第一行，你从 `weasyprint` 包中导入了 `HTML` 类，这是你在 *步骤 1* 中安装的：
- en: '[PRE46]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This HTML class provides us with a mechanism through which we can read the HTML
    content of a website if we have its URL.
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个 HTML 类为我们提供了一个机制，通过这个机制，如果我们有网站的 URL，我们可以读取网站的 HTML 内容。
- en: 'In the next step, you created a new method named `generate_pdf()` that takes
    in two parameters, namely, the URL that should be used as the source URL for the
    generation of the PDF and the `pdf_file` parameter, which takes in the name of
    the file to which the document should be written:'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下一步中，你创建了一个名为 `generate_pdf()` 的新方法，它接受两个参数，即用作生成 PDF 的源 URL 的 URL 和 `pdf_file`
    参数，它接受要写入文档的文件名：
- en: '[PRE47]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, you passed the URL to the `HTML` class object you imported earlier. This
    caused the URL to be parsed by the `weasyprint` library and caused its HTML content
    to be read. Once this was done, you called the `write_pdf()` method of the `HTML`
    class object and provided to it the name of the file to which the content should
    be written:'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，你将 URL 传递给了你之前导入的 `HTML` 类对象。这导致 URL 被由 `weasyprint` 库解析，并读取其 HTML 内容。完成此操作后，你调用了
    `HTML` 类对象的 `write_pdf()` 方法，并提供了要写入内容的文件名：
- en: '[PRE48]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'After this, write the entry point code that sets up the URL (for this exercise,
    we will use the text version of the `generate_pdf()` method to generate the content:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，编写入口点代码来设置 URL（在这个练习中，我们将使用 `generate_pdf()` 方法的文本版本来生成内容）：
- en: '[PRE49]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, to see the code in action, run the following command:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，要查看代码的实际效果，请运行以下命令：
- en: '[PRE50]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Once the command finishes executing, you will have a new PDF file named `demo_page.pdf`
    that is saved in the same directory where the command was executed. When you open
    the file, it should resemble what you see here:'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦命令执行完成，您将在执行命令的同一目录下获得一个名为`demo_page.pdf`的新PDF文件。当您打开文件时，它应该看起来像这里所示：
- en: '![Figure 13.7: Web page converted to a PDF using weasyprint'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图13.7：使用weasyprint转换的网页'
- en: '](img/B15509_13_07.jpg)'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15509_13_07.jpg]'
- en: 'Figure 13.7: Web page converted to a PDF using weasyprint'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7：使用weasyprint转换的网页
- en: In the PDF file generated, we can see that the content seems to lack the formatting
    that the actual website has. This happens because the `weasyprint` package reads
    the HTML content but does not parse the attached CSS stylesheets for the page,
    so the page formatting is lost.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成的PDF文件中，我们可以看到内容似乎缺少了实际网站所具有的格式。这是因为`weasyprint`包读取了HTML内容，但没有解析页面附带的CSS样式表，因此页面格式丢失了。
- en: '`weasyprint` also makes it quite easy to change the formatting of a page. This
    can be done simply by introducing the stylesheet parameter to the `write_pdf()`
    method. A simple modification to our `generate_pdf()` method is described next:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`weasyprint`还使得更改页面格式变得非常简单。这可以通过向`write_pdf()`方法引入样式表参数来完成。接下来将描述对`generate_pdf()`方法的简单修改：'
- en: '[PRE51]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now, when the preceding code is executed, we will see that the font size for
    all the text inside the HTML body content of the page has a size of `8px` in the
    printed PDF version.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当执行前面的代码时，我们将看到页面的HTML内容体内的所有文本的字体大小在打印的PDF版本中为`8px`。
- en: Note
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `HTML` class in `weasyprint` is also capable of taking any local files as
    well as raw HTML string content and can use those files to generate PDFs. For
    further information, please visit the `weasyprint` documentation at [https://weasyprint.readthedocs.io](https://weasyprint.readthedocs.io).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`weasyprint`中的`HTML`类也能够接受任何本地文件以及原始HTML字符串内容，并可以使用这些文件生成PDF。有关更多信息，请访问`weasyprint`文档，链接为[https://weasyprint.readthedocs.io](https://weasyprint.readthedocs.io)。'
- en: So far, we have learned about how we can generate different types of binary
    files with Python, which can help us export our data in a structured manner or
    help us print PDF versions of our pages. Next, we will see how we can generate
    graph representations of our data using Python.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何使用Python生成不同类型的二进制文件，这可以帮助我们以结构化的方式导出我们的数据，或者帮助我们打印页面的PDF版本。接下来，我们将看到如何使用Python生成数据的图表表示。
- en: Playing with Graphs in Python
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Python中玩转图表
- en: Graphs are a great way to visually represent data that changes within a specific
    dimension. We come across graphs quite frequently in our day-to-day lives, be
    it weather charts for a week, stock market movements, or student performance report cards.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图表是可视化特定维度内变化数据的绝佳方式。我们在日常生活中经常遇到图表，无论是每周的天气图表，股市走势，还是学生成绩报告单。
- en: Similarly, graphs can come in quite handy when we are working with our web applications.
    For Bookr, we can use graphs as a visual medium to show the user information about
    the number of books they read each week. Alternatively, we can show them the popularity
    of a book over time based on how many readers were reading the given book at a
    specific time. Now, let's look at how we can generate plots with Python and have
    them show up on our web pages.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当我们在处理我们的Web应用程序时，图表也可以非常有用。对于Bookr，我们可以使用图表作为视觉媒介来向用户展示他们每周阅读的书籍数量。或者，我们可以根据特定时间有多少读者在阅读指定的书籍来展示书籍随时间的变化趋势。现在，让我们看看我们如何使用Python生成图表，并在我们的网页上显示它们。
- en: Generating Graphs with plotly
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用plotly生成图表
- en: Graphs can come in quite handy when trying to visualize patterns in the data
    maintained by our applications. There are a lot of Python libraries that help
    developers in generating static or interactive graphs.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试可视化我们应用程序维护的数据中的模式时，图表非常有用。有许多Python库可以帮助开发者生成静态或交互式图表。
- en: For this book, we will use `plotly`, a community-supported Python library that
    generates graphs and renders them on web pages. `plotly` is particularly interesting
    to us due to its ease of integration with Django.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这本书，我们将使用`plotly`，这是一个社区支持的Python库，它生成图表并在网页上渲染。`plotly`因其与Django集成的简便性而对我们特别有趣。
- en: 'To install it on your system, you can type in the following command in the
    command line:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的系统上安装它，您可以在命令行中输入以下命令：
- en: '[PRE52]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now that's done, let's take a look at how we can generate a graph visualization
    using `plotly`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经完成了，让我们看看如何使用 `plotly` 生成图形可视化。
- en: Setting Up a Figure
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置图形
- en: 'Before we can get started with generating a graph, we first need to initialize
    a `plotly` `Figure` object, which essentially acts as a container for our graph.
    A `plotly` `Figure` object is quite easy to initialize; it can be done by using
    the following code snippet:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始生成图形之前，首先需要初始化一个 `plotly` `Figure` 对象，它本质上是一个用于我们的图形的容器。`plotly` 的 `Figure`
    对象初始化非常简单；可以通过以下代码片段完成：
- en: '[PRE53]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `Figure()` constructor from the `graph_objs` module of `plotly` library
    returns an instance of the `Figure` graph container, inside which a graph can
    be generated. Once the `Figure` object is in place, the next thing that needs
    to be done is to generate a plot.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`plotly` 库的 `graph_objs` 模块的 `Figure()` 构造函数返回 `Figure` 图形容器的实例，在其中可以生成图形。一旦
    `Figure` 对象就位，下一步需要做的就是生成图形。'
- en: Generating a Plot
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成图形
- en: 'A plot is a visual representation of a dataset. This plot could be a scatter
    plot, a line graph, a chart, and so on. For example, to generate a scatter plot,
    the following code snippet is used:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图形是数据集的视觉表示。这个图形可以是散点图、折线图、图表等等。例如，要生成散点图，可以使用以下代码片段：
- en: '[PRE54]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `Scatter` constructor takes in the values for the *X*-axis and *Y*-axis
    and returns an object that can be used to build a scatter plot. Once the `scatter_plot`
    object is generated, the next step is to add this plot to our `Figure`. This can
    be done as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scatter` 构造函数接收 *X* 轴和 *Y* 轴的值，并返回一个可以用来构建散点图的对象。一旦生成了 `scatter_plot` 对象，下一步就是将其添加到我们的
    `Figure` 中。这可以通过以下方式完成：'
- en: '[PRE55]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `add_trace()` method is responsible for adding a plotting object to the
    figure and generating its visualization inside the figure.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_trace()` 方法负责将绘图对象添加到图形中，并在图形内生成其可视化。'
- en: Rendering a Plot on a Web Page
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在网页上渲染图形
- en: 'Once the plot is added to the figure, it can be rendered on a web page by calling
    the `plot` method from the `offline` plotting module of `plotly` library. This
    is shown in the following code snippet:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦图形被添加到图形中，就可以通过调用 `plotly` 库的 `offline` 绘图模块中的 `plot` 方法在网页上渲染它。以下是一个代码片段示例：
- en: '[PRE56]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `plot` method takes two primary parameters: the first is the figure that
    needs to be rendered and the second one is the HTML tag of the container inside
    which the figure HTML will be generated. The `plot` method returns fully integrated
    HTML that can be embedded in any web page or made a part of the template to render
    a graph.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`plot` 方法接受两个主要参数：第一个是需要渲染的图形，第二个是包含图形 HTML 的容器的 HTML 标签。`plot` 方法返回可以嵌入任何网页或作为模板的一部分以渲染图形的完整集成
    HTML。'
- en: Now, with this understanding of how graph plotting works, let's try a hands-on
    exercise to generate a graph for our sample dataset.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，了解了图形绘图的工作原理后，让我们尝试一个动手练习来为我们的样本数据集生成图形。
- en: 'Exercise 13.05: Generating Graphs in Python'
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 13.05：在 Python 中生成图形
- en: 'In this exercise, you will generate a Graph plot using Python. It will be a
    scatter plot that will represent two-dimensional data:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将使用 Python 生成一个图形图。它将是一个散点图，用于表示二维数据：
- en: 'For this exercise, you will be using the `plotly` library. To use this library,
    you first need to install it on the system. To do this, run the following command:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个练习，你将使用 `plotly` 库。要使用这个库，首先需要在系统上安装它。为此，运行以下命令：
- en: '[PRE57]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can install `plotly` and other dependencies for this exercise using the
    `requirements.txt` file we''ve provided on our GitHub repository: [http://packt.live/38y5OLR](http://packt.live/38y5OLR).'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以使用我们提供的 GitHub 仓库中的 `requirements.txt` 文件安装 `plotly` 和其他依赖项：[http://packt.live/38y5OLR](http://packt.live/38y5OLR)。
- en: 'With the library now installed, create a new file named `scatter_plot_demo.py`
    and add the following `import` statements inside it:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在库已经安装，创建一个名为 `scatter_plot_demo.py` 的新文件，并在其中添加以下 `import` 语句：
- en: '[PRE58]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Once the imports are sorted, create a method named `generate_scatter_plot()`
    that takes in two parameters, the values for the *X*-axis and the values for the
    *Y*-axis:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导入排序完成后，创建一个名为 `generate_scatter_plot()` 的方法，它接受两个参数，即 *X* 轴的值和 *Y* 轴的值：
- en: '[PRE59]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Inside this method, first, create an object to act as a container for the graph:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个方法中，首先创建一个作为图形容器的对象：
- en: '[PRE60]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Once the container for the graph is set up, create a new `Scatter` object with
    the values for the *X*-axis and *Y*-axis and add it to the graph `Figure` container:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦设置了图形的容器，创建一个新的 `Scatter` 对象，包含 *X* 轴和 *Y* 轴的值，并将其添加到图形 `Figure` 容器中：
- en: '[PRE61]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Once the scatter plot is ready and added to the figure, the last step is to
    generate the HTML, which can be used to render this plot inside a web page. To
    do this, call the `plot` method and pass the graph container object to it, and
    render the HTML inside an HTML `div` tag:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦散点图准备就绪并添加到图形中，最后一步是生成 HTML，这可以用来在网页中渲染此图形。为此，调用 `plot` 方法并将图形容器对象传递给它，然后在
    HTML `div` 标签内渲染 HTML：
- en: '[PRE62]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The complete `generate_scatter_plot()` method should look like this now:'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完整的 `generate_scatter_plot()` 方法现在应该看起来像这样：
- en: '[PRE63]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Once the HTML for the plot is generated, it needs to be rendered somewhere.
    For this, create a new method named `generate_html()`, which will take in the
    plot HTML as its parameter and render an HTML file consisting of the plot:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦生成了图形的 HTML，它需要被渲染到某个地方。为此，创建一个名为 `generate_html()` 的新方法，它将接受图形 HTML 作为其参数，并渲染一个包含图形的
    HTML 文件：
- en: '[PRE64]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Once the method is set up, the last step is to call it. For this, create a
    script entry point that will set up the values for the *X*-axis list and the *Y*-axis
    list and then call the `generate_scatter_plot()` method. With the value returned
    by the method, make a call to the `generate_html()` method, which will create
    an HTML page consisting of the scatter plot:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦设置了方法，最后一步是调用它。为此，创建一个脚本入口点，该入口点将设置 *X* 轴列表和 *Y* 轴列表的值，然后调用 `generate_scatter_plot()`
    方法。使用方法返回的值，调用 `generate_html()` 方法，该方法将创建一个包含散点图的 HTML 页面：
- en: '[PRE65]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'With the code in place, run the file and see what output is generated. To run
    the code, execute the following command:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码就绪后，运行文件并查看生成的输出。要运行代码，执行以下命令：
- en: '[PRE66]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Once the execution completes, there will be a new `plot_demo.html` file created
    in the same directory in which the script was executed. Upon opening the file,
    you should see the following:'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦执行完成，将在脚本执行的同一目录中创建一个新的 `plot_demo.html` 文件。打开文件后，你应该看到以下内容：
- en: '![Figure 13.8: Graph generated in the browser using plotly'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 13.8：使用 plotly 在浏览器中生成的图形'
- en: '](img/B15509_13_08.jpg)'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_13_08.jpg)'
- en: 'Figure 13.8: Graph generated in the browser using plotly'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.8：使用 plotly 在浏览器中生成的图形
- en: With this, we have generated our first scatter plot, where different points
    are connected by a line.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经生成了第一个散点图，其中不同的点通过线条连接。
- en: In this exercise, you used the `plotly` library to generate a graph that can
    be rendered inside a browser for your readers to visualize data.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你使用了 `plotly` 库来生成一个可以在浏览器中渲染的图形，以便你的读者可视化数据。
- en: Now, you know how you can work with graphs in Python and how to generate HTML
    pages from them.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经知道了如何在 Python 中处理图形以及如何从它们生成 HTML 页面。
- en: But as a web developer, how you can use these graphs in Django? Let's find out.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 但作为一个网页开发者，你如何在 Django 中使用这些图形呢？让我们来找出答案。
- en: Integrating plotly with Django
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 plotly 与 Django 集成
- en: The graphs generated by `plotly` are quite easy to embed in Django templates.
    Since the `plot` method returns a fully contained HTML that can be used to render
    a graph, we can use the HTML returned as a template variable in Django and pass
    it as it is. The Django templating engine will then take care of adding this generated
    HTML to the final template before it is shown in the browser.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `plotly` 生成的图形很容易嵌入到 Django 模板中。由于 `plot` 方法返回一个完整的 HTML，可以用来渲染图形，因此我们可以将返回的
    HTML 作为 Django 模板变量传递，并保持原样。然后，Django 模板引擎将负责在浏览器显示之前将生成的 HTML 添加到最终的模板中。
- en: 'Some sample code for doing this is shown next:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 下面展示了进行此操作的示例代码：
- en: '[PRE67]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The preceding code will cause the `{{ plt_div }}` content used inside the template
    to be replaced by the HTML stored inside the `scatter_plot_demo` variable, and
    the final template to render the scatter plot of the number of books read per
    week.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将导致模板内使用的 `{{ plt_div }}` 内容被存储在 `scatter_plot_demo` 变量中的 HTML 替换，并渲染每周阅读书籍数量的散点图。
- en: Integrating Visualizations with Django
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将可视化与 Django 集成
- en: In the preceding sections, you have learned how data can be read and written
    in different formats that cater to the different needs of users. But how can we
    use what we've learned to integrate with Django?
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你已经学习了如何以不同的格式读取和写入数据，以满足用户的不同需求。但我们如何将所学知识与 Django 集成呢？
- en: For example, in Bookr, we might want to allow the user to export a list of books
    that they have read or visualize their book reading activity over a year. How
    can that be done? The next exercise in this chapter focuses on that aspect, where
    you will learn how the components we have seen so far can be integrated into Django
    web applications.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 Bookr 中，我们可能希望允许用户导出他们已阅读的书籍列表或可视化他们一年的阅读活动。这该如何实现？本章的下一个练习将专注于这个方面，你将学习如何将我们迄今为止看到的组件集成到
    Django 网络应用程序中。
- en: 'Exercise 13.06: Visualizing a User''s Reading History on the User Profile Page'
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 13.06：在用户个人资料页面上可视化用户的阅读历史
- en: In this exercise, you will aim to modify the user's profile page such that the
    user can visualize their book reading history when they visit their profile page
    on Bookr.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你的目标是修改用户的个人资料页面，以便用户在访问 Bookr 上的个人资料页面时可以可视化他们的阅读历史。
- en: 'Let''s look at how this can be done:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何实现这一点：
- en: 'To get started with integrating the ability to visualize the reading history
    of the user, you first need to install the `plotly` library. To do this, run the
    following command in your terminal:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始集成可视化用户阅读历史的功能，你首先需要安装 `plotly` 库。为此，请在您的终端中运行以下命令：
- en: '[PRE68]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Note
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can install `plotly` and other dependencies for this exercise using the
    `requirements.txt` file we''ve provided on our GitHub repository: [http://packt.live/3scIvPp](http://packt.live/3scIvPp).'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以使用我们提供的 GitHub 仓库中的 `requirements.txt` 文件安装 `plotly` 和其他依赖项：[http://packt.live/3scIvPp](http://packt.live/3scIvPp)。
- en: 'Once the library is installed, the next step is to write the code that will
    fetch the total books read by the user as well as the books read by the user on
    a per-month basis. For this, create a new file named `utils.py` under the `bookr`
    application directory and add the required imports, which will be used to fetch
    the book reading history of the user from the `Review` model of the `reviews` application:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 库安装完成后，下一步是编写代码，以获取用户阅读的总书籍数量以及按月阅读的书籍。为此，在 `bookr` 应用程序目录下创建一个名为 `utils.py`
    的新文件，并添加所需的导入，这些导入将用于从 `reviews` 应用程序的 `Review` 模型中获取用户的阅读历史：
- en: '[PRE69]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Next, create a new utility method named `get_books_read_by_month()`, which takes
    in the username of the user for whom the reading history needs to be fetched.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为 `get_books_read_by_month()` 的新实用方法，该方法接收需要获取阅读历史的用户名。
- en: 'Inside the method, we query the `Review` model and return a dictionary of books
    read by the user on a per-month basis:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该方法内部，我们查询 `Review` 模型，并按月返回用户阅读的书籍字典：
- en: '[PRE70]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, let''s examine the following query, which is responsible for fetching
    the results of books read this year on a monthly basis:'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，让我们检查以下查询，该查询负责按月获取今年阅读的书籍结果：
- en: '[PRE71]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This query can be broken down into the following components:'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此查询可以分解为以下组件：
- en: '`year` field can be easily accessed from our `date_created` field by appending
    `__year`.'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过添加 `__year`，可以轻松访问我们的 `date_created` 字段中的 `year` 字段。
- en: '`values()` call to select only the `month` field from the `date_created` attribute
    of the `Review` model on which you are going to run the group by operation.'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `values()` 调用来选择将要执行分组操作的 `Review` 模型的 `date_created` 属性中的 `month` 字段。
- en: '`annotate` method to the `QuerySet` instance returned by the `values()` call.'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将 `annotate` 方法应用于 `values()` 调用返回的 `QuerySet` 实例。
- en: 'Once you have the utilities file in place, the next thing is to write the view
    function, which is going to help in showing the books-read-per-month plot on the
    user''s profile page. For this, open the `views.py` file under the `bookr` directory
    and start by adding the following imports to it:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦放置好实用文件，下一步就是编写视图函数，这将有助于在用户的个人资料页面上显示每月阅读的书籍图表。为此，打开 `bookr` 目录下的 `views.py`
    文件，并首先添加以下导入：
- en: '[PRE72]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Once these imports are done, the next thing to do is to modify the view function
    that renders the profile page. Currently, the profile page is being handled by
    the `profile()` method inside the `views.py` file. Modify the method to resemble
    the one shown here:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些导入后，接下来要做的就是修改渲染个人资料页面的视图函数。目前，个人资料页面是由 `views.py` 文件中的 `profile()` 方法处理的。修改该方法，使其类似于以下所示：
- en: '[PRE73]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'In this method, you did a couple of things. The first thing was that you called
    the `get_books_read_by_month()` method and provided it with the username of the
    currently logged-in user. This method returns the list of books read by a given
    user on a per-month basis in the current year:'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个方法中，你做了几件事情。首先，你调用了`get_books_read_by_month()`方法，并提供了当前登录用户的用户名。该方法返回给定用户在当前年度按月阅读的书籍列表：
- en: '[PRE74]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The next thing you did was pre-initialize the *X*-axis and *Y*-axis for the
    graph with some default values. For this visualization, use the *X*-axis to display
    months and the *Y*-axis to display the number of books read.
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，你预先初始化了图表的*X*轴和*Y*轴的一些默认值。对于这个可视化，使用*X*轴显示月份，使用*Y*轴显示阅读的书籍数量。
- en: 'Now, since you already know that a year is going to have only 12 months, pre-initialize
    the *X*-axis with a value between `1` and `12`:'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，既然你已经知道一年只有12个月，预先初始化*X*轴的值在`1`和`12`之间：
- en: '[PRE75]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'For the books read, initialize the *Y*-axis with all the `12` indexes set to
    `0` as follows:'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于已阅读的书籍，将*Y*轴初始化为所有`12`个索引都设置为`0`，如下所示：
- en: '[PRE76]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Now, with the pre-initialization done, fill in some actual values for the books
    read per month. For this, iterate upon the list you got as a result of the call
    made to `get_books_read_by_month(user.username)` and extract the month and the
    book count for the month from it.
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，在完成预初始化后，为每月阅读的书籍填充一些实际值。为此，遍历`get_books_read_by_month(user.username)`调用结果得到的列表，从中提取月份和该月的书籍数量。
- en: 'Once the book count and month are extracted, the next step is to assign the
    `book_count` value to the `books_read` list at the month index:'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦提取了书籍数量和月份，下一步是将`book_count`值分配给`books_read`列表的月份索引：
- en: '[PRE77]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now, with the values for the axes set, generate a scatter plot using the `plotly` library:'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，在设置了轴的值后，使用`plotly`库生成散点图：
- en: '[PRE78]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Once the HTML for the plot is generated, pass it to the template using the
    `render()` method such that it can be visualized on the profile page:'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦生成了绘图HTML，请使用`render()`方法将其传递给模板，以便在个人资料页面上进行可视化：
- en: '[PRE79]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'With the view function done, the next step is to modify the template to render
    this graph. For this, open the `profile.html` file under the `templates` directory
    and add the following highlighted code to the file, just before the last `{% endblock
    %}` statement:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视图函数完成后，下一步是修改模板以渲染此图表。为此，打开`templates`目录下的`profile.html`文件，并在最后一个`{% endblock
    %}`语句之前添加以下突出显示的代码：
- en: '[PRE80]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'To try the visualization, run the following command and then navigate to your
    user profile by visiting `http://localhost:8080`:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要尝试可视化，运行以下命令，然后通过访问`http://localhost:8080`导航到您的用户个人资料：
- en: '[PRE81]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'You should see a page that resembles the one shown next:'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该会看到一个类似于下面显示的页面：
- en: '![Figure 13.9: User book reading history scatter plot'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图13.9：用户书籍阅读历史散点图]'
- en: '](img/B15509_13_09.jpg)'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15509_13_09.jpg]'
- en: 'Figure 13.9: User book reading history scatter plot'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.9：用户书籍阅读历史散点图
- en: In the preceding exercise, you saw how you can integrate a plotting library
    with Django to visualize the reading history of a user. Similarly, Django allows
    you to integrate any generic Python code into a web application, with the only
    constraint being that the data generated as a result of the integration should
    be transformed into a valid HTTP response that can be handled by any standard
    HTTP-compatible tool, such as a web browser or command-line tools such as CURL.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的练习中，你看到了如何将绘图库与Django集成以可视化用户的阅读历史。同样，Django允许你将任何通用Python代码集成到Web应用程序中，唯一的限制是，集成产生的数据应转换为有效的HTTP响应，以便任何标准HTTP兼容的工具可以处理，例如Web浏览器或命令行工具，如CURL。
- en: 'Activity 13.01: Exporting the Books Read by a User as an XLSLX File'
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动13.01：导出用户阅读的书籍为XLSX文件
- en: 'In this activity, you will implement a new API endpoint inside Bookr that will
    allow your users to export and download a list of books they have read as an XLSX
    file:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你将在Bookr中实现一个新的API端点，允许用户导出并下载他们已阅读的书籍列表作为XLSX文件：
- en: Install the `XlsxWriter` library.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`XlsxWriter`库。
- en: Inside the `utils.py` file created under the `bookr` application, create a new
    function that will help in fetching the list of books that have been read by the user.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`bookr`应用程序下创建的`utils.py`文件中，创建一个新的函数，该函数将帮助获取用户已阅读的书籍列表。
- en: Inside the `views.py` file under the `bookr` directory, create a new view function
    that will allow the user to download their reading history in the XLSX file format.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`bookr`目录下的`views.py`文件中，创建一个新的视图函数，允许用户以XLSX文件格式下载他们的阅读历史。
- en: To create an XLSX file inside the view function, first create a `BytesIO`-based
    in-memory file that can be used to store the data from the `XlsxWriter` library.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在视图函数中创建XLSX文件，首先创建一个基于`BytesIO`的内存文件，该文件可以用来存储来自`XlsxWriter`库的数据。
- en: Read the data stored inside the in-memory file using the `getvalue()` method
    of the temporary file object.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用临时文件对象的`getvalue()`方法读取内存文件中存储的数据。
- en: Finally, create a new `HttpResponse` instance with the `'application/vnd.ms-excel'`
    content type header, and then write the data obtained in step 5 to the response
    object.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个新的`HttpResponse`实例，并设置`'application/vnd.ms-excel'`内容类型头，然后将步骤5中获得的数据写入响应对象。
- en: With the response object prepared, return the response object from the view function.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备好响应对象后，从视图函数返回响应对象。
- en: With the view function ready, map it to a URL endpoint that can be visited by
    a user to download their book reading history.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视图函数准备就绪后，将其映射到用户可以访问以下载他们的书籍阅读历史的URL端点。
- en: Once you have the URL endpoint mapped, start the application and log in to it
    with your user account. Once done, visit the URL endpoint you just created, and
    if upon visiting the URL endpoint your browser starts to download an Excel file,
    you have successfully completed the activity.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您已将URL端点映射，启动应用程序并使用您的用户账户登录。完成后，访问您刚刚创建的URL端点，如果在访问URL端点时您的浏览器开始下载Excel文件，则表示您已成功完成该活动。
- en: Note
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可在[http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ)找到。
- en: Summary
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at how we can deal with binary files and how Python's
    standard library, which comes pre-loaded with the necessary tools, can allow us
    to handle commonly used file formats such as CSV. We then moved on to learning
    how to read and write CSV files in Python using Python's CSV module. Later, we
    worked with the `XlsxWriter` package, which provides us with the ability to generate
    Microsoft Excel-compatible files right from our Python environment without worrying
    about the internal formatting of the file.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何处理二进制文件，以及Python的标准库，它预装了必要的工具，可以让我们处理常用的文件格式，如CSV。然后，我们学习了如何使用Python的CSV模块在Python中读取和写入CSV文件。后来，我们使用了`XlsxWriter`包，它为我们提供了在Python环境中直接生成与Microsoft
    Excel兼容的文件的能力，无需担心文件的内部格式。
- en: The second half of the chapter was dedicated to learning how to use the `weasyprint`
    library to generate PDF versions of HTML pages. This skill can come in handy when
    we want to provide our users with an easy option to print the HTML version of
    our page with any added CSS styling of our choosing. The last section of the chapter
    discussed how we can generate interactive graphs in Python and render them as
    HTML pages that can be viewed inside the browser using the `plotly` library.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的后半部分致力于学习如何使用`weasyprint`库生成HTML页面的PDF版本。当我们想为用户提供一个方便的选项，让他们打印带有我们选择的任何CSS样式的HTML页面时，这项技能会很有用。本章的最后部分讨论了如何使用`plotly`库在Python中生成交互式图表，并将它们渲染为可以在浏览器中查看的HTML页面。
- en: In the next chapter, we will look at how we can test the different components
    we have been implementing in the previous chapters to make sure that code changes
    do not break our website's functionality.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何测试我们在前几章中实现的不同组件，以确保代码更改不会破坏我们网站的 功能。
