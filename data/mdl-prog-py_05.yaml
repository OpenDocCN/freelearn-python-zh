- en: Chapter 5. Working with Module Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。使用模块模式
- en: 'In the previous chapters, we have looked in detail at how Python modules and
    packages work, and learned how you can use them in your programs. When using modular
    programming techniques, you will find that the ways in which modules and packages
    are used tend to follow standard patterns. In this chapter, we will examine a
    number of these common patterns for using modules and packages to deal with a
    range of programming challenges. In particular, we will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们详细讨论了Python模块和包的工作原理，并学习了如何在程序中使用它们。在使用模块化编程技术时，你会发现模块和包的使用方式往往遵循标准模式。在本章中，我们将研究使用模块和包处理各种编程挑战的一些常见模式。特别是，我们将：
- en: Learn how the divide and conquer technique helps you to solve programming problems
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解分而治之技术如何帮助你解决编程问题
- en: See how the principle of abstraction helps you to separate what you want to
    do from how you do it
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看抽象原则如何帮助你将要做的事情与如何做它分开
- en: Discover how encapsulation allows you to hide the details of how information
    is represented from the rest of your system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解封装如何允许你隐藏信息表示的细节
- en: See that wrappers are modules that call other modules to simplify or alter the
    way a module is used
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看到包装器是调用其他模块以简化或改变模块使用方式的模块
- en: Learn how to create extensible modules
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何创建可扩展的模块
- en: Let's start by looking at the principle of divide and conquer.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从分而治之的原则开始。
- en: Divide and conquer
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分而治之
- en: Divide and conquer is the process of breaking a problem down into smaller parts.
    You might not know how to solve a particular problem, but by breaking it down
    into smaller parts, you can then solve each part in turn, which then solves the
    original problem.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 分而治之是将问题分解为较小部分的过程。你可能不知道如何解决一个特定的问题，但通过将其分解为较小的部分，然后依次解决每个部分，然后解决原始问题。
- en: 'This is a very general technique, of course, and doesn''t just apply to the
    use of modules and packages. However, modular programming helps you work through
    the divide and conquer process: as you break your problem down, you discover that
    you''ll need a part of your program which performs a given task or range of tasks,
    and Python modules (and packages) are the perfect way of organizing those tasks.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一个非常普遍的技术，并不仅适用于模块和包的使用。然而，模块化编程有助于你通过分而治之的过程：当你分解问题时，你会发现你需要程序的一部分来执行特定的任务或一系列任务，而Python模块（和包）是组织这些任务的完美方式。
- en: We have done this several times already in this book. For example, when faced
    with the challenge of creating a chart-generation library, we used the divide
    and conquer technique to come up with the notion of a **renderer** that could
    draw a single chart element. We then realized that we would need several different
    renderers, which translated perfectly to the `renderers` package containing a
    separate module for each renderer.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '在本书中，我们已经做过几次这样的事情。例如，当面临创建图表生成库的挑战时，我们使用了分而治之的技术，提出了可以绘制单个图表元素的**渲染器**的概念。然后我们意识到我们需要几个不同的渲染器，这完美地转化为包含每个渲染器单独模块的`renderers`包。 '
- en: The divide and conquer approach doesn't just suggest a possible modular structure
    for your code, it works the other way around too. As you think about the design
    for your program, you may come up with the notion of a module or package that
    does something related to the problem you're trying to solve. You might even map
    out the individual functions that each module and package provides. Even though
    you don't yet know how to solve the whole problem, this modular design helps you
    to clarify your thinking about the problem, which in turn makes it easier to use
    the divide-and-conquer approach to solve the remainder of the problem. In other
    words, modules and packages help you to *clarify your thinking* as you work through
    the divide and conquer process.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 分而治之的方法不仅建议了代码的可能模块化结构，也可以反过来使用。当你考虑程序的设计时，你可能会想到一个与你要解决的问题相关的模块或包的概念。你甚至可能会规划出每个模块和包提供的各个函数。尽管你还不知道如何解决整个问题，但这种模块化设计有助于澄清你对问题的思考，从而使使用分而治之的方法更容易解决问题的其余部分。换句话说，模块和包帮助你在分而治之的过程中澄清你的思路。
- en: Abstraction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象
- en: 'Abstraction is another very general programming pattern that applies to more
    than just modular programming. Abstraction is essentially the process of hiding
    complexity: separating *what* you want to do from *how* to do it.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象是另一个非常普遍的编程模式，适用于不仅仅是模块化编程。抽象本质上是隐藏复杂性的过程：将你想要做的事情与如何做它分开。
- en: 'Abstraction is absolutely fundamental to all computer programming. Imagine,
    for example, that you had to write a program that calculates two averages and
    then figures out the difference between the two. A simplistic implementation of
    this program might look something like the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象对所有的计算机编程都是绝对基础的。例如，想象一下，你必须编写一个计算两个平均数然后找出两者之间差异的程序。这个程序的简单实现可能看起来像下面这样：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see, the code that calculates the average of a list of numbers is
    repeated twice. This is inefficient, so you would normally write a function to
    avoid repeating yourself. This can be done in the following way:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，计算列表平均数的代码重复了两次。这是低效的，所以你通常会写一个函数来避免重复。可以通过以下方式实现：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Of course, you do this sort of thing every time you program, but it is actually
    quite an important process. When you create a function like this, the code inside
    the function deals with *how* to do something, while the code that calls that
    function simply knows *what* has to be done—and that the function will do it.
    In other words, the function *hides the complexity* of how the task is performed,
    allowing other parts of your program to simply call that function whenever they
    want that task to be performed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，每次编程时你都在做这种事情，但实际上这是一个非常重要的过程。当你创建这样一个函数时，函数内部处理*如何*做某事，而调用该函数的代码只知道*要*做什么，以及函数会去做。换句话说，函数*隐藏了*任务执行的复杂性，使得程序的其他部分只需在需要执行该任务时调用该函数。
- en: This type of process is called **abstraction**. Using this pattern, you *abstract
    away* the details of how something is done so that the rest of your program doesn't
    need to worry about it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这种过程称为**抽象**。使用这种模式，你可以*抽象出*某事物的具体细节，这样你的程序的其他部分就不需要担心这些细节。
- en: 'Abstraction doesn''t just apply to writing functions. The general principle
    of hiding complexity applies to groups of functions as well—and the module is
    a perfect way of grouping functions together. For example, your program might
    need to work with colors, and so you write a module named `colors` which contains
    various functions that allow you to create and work with color values. The various
    functions in the `colors` module know about color values and how to use them,
    so the rest of your program doesn''t need to worry about it. Using this module,
    you could do all sorts of interesting things with colors. For example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象不仅适用于编写函数。隐藏复杂性的一般原则也适用于函数组，而模块是将函数组合在一起的完美方式。例如，你的程序可能需要使用颜色，因此你编写了一个名为`colors`的模块，其中包含各种函数，允许你创建和使用颜色值。`colors`模块中的各种函数了解颜色值及如何使用它们，因此你的程序的其他部分不需要担心这些。使用这个模块，你可以做各种有趣的事情。例如：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Outside of this module, your code can simply concentrate on what it wants to
    do, without the slightest idea of how these various tasks are performed. By doing
    this, you are using the abstraction pattern to hide away the complexity of these
    color calculations from the rest of your program.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模块之外，你的代码可以专注于它想要做的事情，而不需要知道这些各种任务是如何执行的。通过这样做，你正在使用抽象模式将这些颜色计算的复杂性隐藏起来，使其不影响程序的其他部分。
- en: Abstraction is a fundamental technique for designing and writing modules and
    packages. For example, the Pillow library we used in the previous chapter provides
    a wide range of modules that allow you to load, manipulate, create, and save images.
    We can use this library without having any idea how these various operations are
    performed. For example, we could call `drawer.line((x1, y1), (x2, y2), color,
    width)` and not have to worry about the details of setting individual pixels within
    the image.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象是设计和编写模块和包的基本技术。例如，我们在上一章中使用的Pillow库提供了各种模块，允许你加载、操作、创建和保存图像。我们可以使用这个库而不需要知道这些各种操作是如何执行的。例如，我们可以调用`drawer.line((x1,
    y1), (x2, y2), color, width)`而不必担心设置图像中的单个像素的细节。
- en: One of the great things about applying the abstraction pattern is that you often
    don't know just how complex something will be when you first start implementing
    your code. For example, imagine that you are writing a point-of-sale system for
    a hotel bar. Part of your system will need to calculate the price to charge a
    customer for the drinks they order. There are various formulae we can use to calculate
    this price, based on the quantity, the type of liquor used, and so on. But one
    of the challenging features is the need to support *happy hour*, that is, a period
    of time during which drinks will be offered at a discounted rate.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 应用抽象模式的一个伟大之处在于，当你开始实现代码时，通常并不知道某事物的复杂程度。例如，想象一下，你正在为酒店酒吧编写一个销售点系统。系统的一部分需要计算顾客点酒时应收取的价格。我们可以使用各种公式来计算这个价格，根据数量、使用的酒类等。但其中一个具有挑战性的特点是需要支持*欢乐时光*，即在此期间饮料将以折扣价提供。
- en: 'At first, you are told that happy hour is between five and six each evening.
    So, using good modular techniques, you add the following function to your code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，你被告知欢乐时光是每天晚上五点到六点之间。因此，使用良好的模块化技术，你在代码中添加了以下函数：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can then use this function to separate how happy hour is calculated from
    what happens during happy hour. For example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以使用这个函数来分离计算欢乐时光的方法和欢乐时光期间发生的事情。例如：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'So far this is pretty simple, and you might be tempted to bypass the creation
    of the `is_happy_hour()` function completely. However, this function soon becomes
    more complicated when you discover that happy hour doesn''t apply on Sundays.
    So, you have to modify the `is_happy_hour()` function to support this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这还相当简单，你可能会想要完全绕过创建`is_happy_hour()`函数。然而，当你发现欢乐时光不适用于星期日时，这个函数很快就变得更加复杂。因此，你必须修改`is_happy_hour()`函数以支持这一点：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: But you then discover that happy hour doesn't apply on Christmas day or on Good
    Friday. While Christmas day is easy enough to calculate, the logic used to calculate
    when Easter is on a given year is much more complicated. If you're interested,
    the example code for this chapter includes an implementation of the `is_happy_hour()`
    function which includes support for Christmas day and Good Friday. Needless to
    say, the implementation is rather complex.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 但是你随后发现，欢乐时光不适用于圣诞节或耶稣受难日。虽然圣诞节很容易计算，但计算复活节在某一年的日期所使用的逻辑要复杂得多。如果你感兴趣，本章的示例代码包括`is_happy_hour()`函数的实现，其中包括对圣诞节和耶稣受难日的支持。不用说，这个实现相当复杂。
- en: Notice that our `is_happy_hour()` function becomes more and more complicated
    as we go along—we thought it would be quite simple at first but added requirements
    made it much more complicated. Fortunately, because we've abstracted away the
    details of how happy hour is calculated from the code that needs to know whether
    it is currently happy hour or not, only that one function needs to be updated
    to support this increased complexity.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，随着我们的`is_happy_hour()`函数的不断发展，它变得越来越复杂 - 起初我们以为它会很简单，但是添加的要求使它变得更加复杂。幸运的是，因为我们已经将计算快乐时光的细节从需要知道当前是否是快乐时光的代码中抽象出来，只需要更新一个函数来支持这种增加的复杂性。
- en: Encapsulation
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装
- en: Encapsulation is another programming pattern that often applies to modules and
    packages. Using encapsulation, you have a *thing*—for example, a color, a customer,
    or a currency—that you need to store data about, but you hide the representation
    of this data from the rest of your system. Rather than make the thing available
    directly, you provide functions for setting, retrieving, and manipulating the
    thing's data.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 封装是另一种经常适用于模块和包的编程模式。使用封装，你有一个*东西* - 例如，颜色、客户或货币 - 你需要存储关于它的数据，但是你将这些数据的表示隐藏起来，不让系统的其他部分知道。而不是直接提供这个东西，你提供设置、检索和操作这个东西数据的函数。
- en: 'To see how this works, let''s look back at a module we wrote in the previous
    chapter. Our `chart.py` module lets the user define a chart and set the various
    pieces of information about it. Here is a copy of the code that we wrote for this
    module:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这是如何工作的，让我们回顾一下我们在上一章中编写的一个模块。我们的`chart.py`模块允许用户定义一个图表并设置有关它的各种信息。这是我们为这个模块编写的代码的一个副本：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, the `new_chart()` function creates a new "chart" without making
    it clear to the rest of the system how the information about a chart is to be
    stored—we're using a dictionary here, but we could just as easily have used an
    object, a base64-encoded string, or whatever. The rest of the system doesn't care
    as it simply calls the various functions within the `chart.py` module to set the
    various values for a chart.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`new_chart()`函数创建了一个新的“图表”，而不清楚地告诉系统如何存储有关图表的信息 - 我们在这里使用了一个字典，但我们也可以使用一个对象、一个base64编码的字符串，或者其他任何东西。系统的其他部分并不关心，因为它只是调用`chart.py`模块中的各种函数来设置图表的各个值。
- en: 'Unfortunately, this isn''t quite a perfect example of encapsulation. Our various
    `set_XXX()` functions act as **setters**—they let us set the various values for
    a chart—but we just assume that our chart-generation functions can access the
    information about a chart directly from the chart''s dictionary. If this was going
    to be a pure example of encapsulation, we would also write the equivalent **getter**
    functions, for example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这并不是封装的一个完美的例子。我们的各种`set_XXX()`函数充当**设置器** - 它们让我们设置图表的各种值 - 但我们只是假设我们的图表生成函数可以直接从图表的字典中访问有关图表的信息。如果这将是封装的一个纯粹的例子，我们还将编写相应的**获取器**函数，例如：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With these getter functions added to our module, we now have a fully encapsulated
    module that allows us to store and retrieve information about a chart. The other
    parts of the `charter` package that want to use a chart would then call the getter
    functions to retrieve that chart's data, rather than accessing it directly.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这些获取器函数添加到我们的模块中，我们现在有了一个完全封装的模块，可以存储和检索关于图表的信息。`charter`包的其他部分想要使用图表时，将调用获取器函数来检索该图表的数据，而不是直接访问它。
- en: Tip
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: These examples of writing setter and getter functions in a module are slightly
    contrived; encapsulation is usually done using object-oriented programming techniques.
    However, as you can see, it is perfectly possible to use encapsulation when writing
    code that uses only modular programming techniques.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块中编写设置器和获取器函数的这些示例有点牵强；封装通常是使用面向对象编程技术来完成的。然而，正如你所看到的，当编写只使用模块化编程技术的代码时，完全可以使用封装。
- en: You might be wondering why on earth anyone would want to use encapsulation.
    Instead of writing `charts.get_title(chart)`, why not simply write `chart['title']`?
    The second version is shorter. It also avoids calling a function and so would
    be infinitesimally faster. Why bother with encapsulation at all?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你会想知道为什么有人会想要使用封装。为什么不直接写`charts.get_title(chart)`，而不是简单地写`chart['title']`？第二个版本更短。它还避免了调用函数，因此速度会更快。为什么要使用封装呢？
- en: There are two reasons why you should use encapsulation in your programs. Firstly,
    by using getter and setter functions, you hide the details of how your information
    is stored. This allows you to change the internal representation without affecting
    any other part of your program—and the one thing you can pretty much guarantee
    as you write your program is that you're going to be adding more information and
    features as you go along. This means that the internal representation of your
    data *will* change. By separating what you are storing from how it is stored,
    your system becomes more robust, and you can make changes without having to rewrite
    a lot of code. This is the hallmark of a good modular design.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中使用封装有两个原因。首先，通过使用获取器和设置器函数，你隐藏了信息存储的细节。这使你能够更改内部表示而不影响程序的任何其他部分 - 并且在编写程序时你几乎可以肯定的一件事是，你将不断添加更多的信息和功能。这意味着你的数据的内部表示*将*发生变化。通过将存储的内容与存储方式分离，你的系统变得更加健壮，你可以进行更改而无需重写大量代码。这是一个良好模块化设计的标志。
- en: The second major reason for using encapsulation is to allow your code to do
    something when the user sets a particular value. For example, if the user changes
    the quantity of an order, you can immediately recalculate the total price for
    that order. Another thing that setters often do is save the updated value to disk
    or into a database. You can also add error-checking and other logic to your setters
    in order to catch bugs that might otherwise be hard to track down.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用封装的第二个主要原因是允许您的代码在用户设置特定值时执行某些操作。例如，如果用户更改订单的数量，您可以立即重新计算该订单的总价格。设置器经常做的另一件事是将更新后的值保存到磁盘或数据库中。您还可以在设置器中添加错误检查和其他逻辑，以便捕获可能很难跟踪的错误。
- en: Let's take a detailed look at a Python module that uses the encapsulation pattern.
    For this example, let's pretend that we are writing a program for storing recipes.
    The user can create a database of favorite recipes and display these recipes when
    they want to use them.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看一下使用封装模式的Python模块。例如，假设我们正在编写一个用于存储食谱的程序。用户可以创建一个喜爱食谱的数据库，并在需要时显示这些食谱。
- en: Let's create a Python module to encapsulate the concept of a recipe. For this
    example, we'll store the recipe in memory to keep things simple. For each recipe,
    we will store the name, the number of servings the recipe produces, a list of
    ingredients, and a list of instructions the user needs to follow when making the
    recipe.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个Python模块来封装食谱的概念。在这个例子中，我们将食谱存储在内存中，以保持简单。对于每个食谱，我们将存储食谱的名称、食谱产生的份数、配料列表以及制作食谱时用户需要遵循的指令列表。
- en: 'Create a new Python source file, named `recipes.py`, and enter the following
    into this file:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`recipes.py`的新Python源文件，并输入以下内容到此文件中：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, we are once again using a Python dictionary to store our information.
    We could use a Python class or a `namedtuple` from the Python Standard Library.
    Alternatively, we could store our information in a database. For this example,
    however, we want to keep our code as simple as possible, and a dictionary is the
    easiest solution.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，我们再次使用Python字典来存储我们的信息。我们可以使用Python类或Python标准库中的`namedtuple`。或者，我们可以将信息存储在数据库中。但是，在这个例子中，我们希望尽可能简化我们的代码，字典是最简单的解决方案。
- en: After creating a new recipe, the user can call the various setter and getter
    functions to store and retrieve information about the recipe. We also have some
    helpful functions that let us add the instructions and ingredients one at a time,
    which is more convenient for the program we are writing.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新食谱后，用户可以调用各种设置器和获取器函数来存储和检索有关食谱的信息。我们还有一些有用的函数，让我们一次添加一条指令和配料，这对我们正在编写的程序更方便。
- en: 'Notice that when adding an ingredient to the recipe, the caller needs to supply
    three pieces of information: the name of the ingredient, the required quantity,
    and the units in which this quantity is measured. For example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当向食谱添加配料时，调用者需要提供三条信息：配料的名称、所需数量以及衡量此数量的单位。例如：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So far, we have encapsulated the concept of a recipe, allowing us to store the
    information we need and retrieve it when required. Because our module followed
    the encapsulation principle, we could change the way recipes are stored, add more
    information, and new behavior to our module without affecting the rest of the
    program.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经封装了食谱的概念，允许我们存储所需的信息，并在需要时检索它。由于我们的模块遵循了封装原则，我们可以更改存储食谱的方式，向我们的模块添加更多信息和新行为，而不会影响程序的其余部分。
- en: 'Let''s add one more useful function to our recipe:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再添加一个有用的函数到我们的食谱中：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This function returns a list of strings which can be printed out to summarize
    the recipe. Notice the `num_servings` parameter: this allows us to customize the
    recipe for a different number of servings. For example, if the user creates a
    recipe for three servings and wants to double it, the `to_string()` function can
    be called with a `num_servings` value of `6`, and the correct quantities will
    be included in the list of returned strings.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数返回一个字符串列表，可以打印出来以总结食谱。注意`num_servings`参数：这允许我们为不同的份数定制食谱。例如，如果用户创建了一个三份食谱并希望将其加倍，可以使用`to_string()`函数，并将`num_servings`值设为`6`，正确的数量将包含在返回的字符串列表中。
- en: 'Let''s take a look at how this module works. Open up a terminal or command-line
    window, use the `cd` command to go to the directory where you created your `recipes.py`
    file, and type `python` to start the Python interpreter. Then, try typing the
    following to create a recipe for pizza dough:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个模块是如何工作的。打开终端或命令行窗口，使用`cd`命令转到创建`recipes.py`文件的目录，并输入`python`启动Python解释器。然后，尝试输入以下内容以创建披萨面团的食谱：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So far so good. Let''s now use the `to_string()` function to print out the
    details of the recipe, doubling it to two servings:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利。现在让我们使用`to_string()`函数打印出食谱的详细信息，并将其加倍到两份：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'All going well, the recipe should be printed out for you:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一切顺利的话，食谱应该已经打印出来了：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, there are a few minor formatting issues. For example, the required
    quantity of Greek yogurt is listed as `2 cup` rather than `2 cups`. You can fix
    this easily enough if you want—but the important thing to notice is that the `recipes.py`
    module has encapsulated the idea of a recipe, allowing you (and other programs
    you write) to work with recipes without having to worry about the details.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，有一些次要的格式问题。例如，所需的希腊酸奶数量列为`2 cup`而不是`2 cups`。如果您愿意，您可以很容易地解决这个问题，但要注意的重要事情是`recipes.py`模块已经封装了食谱的概念，允许您（和您编写的其他程序）处理食谱而不必担心细节。
- en: As an exercise, you might like to try fixing the display of quantities in the
    `to_string()` function. You could also try writing a new function that creates
    a shopping list from a list of recipes, automatically combining quantities when
    two or more recipes use the same ingredient. If you work through these exercises,
    you'll soon notice that the implementation can get quite complicated, but by encapsulating
    the details in a module, you can hide these details from the rest of your program.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，你可以尝试修复`to_string()`函数中数量的显示。你也可以尝试编写一个新的函数，从食谱列表中创建一个购物清单，在两个或更多食谱使用相同的食材时自动合并数量。如果你完成了这些练习，你很快就会注意到实现可能会变得非常复杂，但通过将细节封装在一个模块中，你可以隐藏这些细节，使其对程序的其余部分不可见。
- en: Wrappers
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包装器
- en: 'A wrapper is essentially a group of functions that call other functions to
    do the work:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 包装器本质上是一组调用其他函数来完成工作的函数：
- en: '![Wrappers](graphics/B05012_5_01.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![包装器](graphics/B05012_5_01.jpg)'
- en: Wrappers are used to simplify an interface, to make a confusing or badly designed
    API easier to use, to convert data formats into something more convenient, and
    to implement cross-language compatibility. Wrappers are also sometimes used to
    add testing and error-checking code to an existing API.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 包装器用于简化接口，使混乱或设计不良的API更易于使用，将数据格式转换为更方便的形式，并实现跨语言兼容性。包装器有时也用于向现有API添加测试和错误检查代码。
- en: 'Let''s take a look at a real-world application of a wrapper module. Imagine
    that you work for a large bank and have been asked to write a program to analyze
    fund transfers to help identify possible fraud. Your program receives information,
    in real time, about every inter-bank funds transfer that takes place. For each
    transfer, you are given:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个包装器模块的真实应用。想象一下，你在一家大型银行工作，并被要求编写一个程序来分析资金转账，以帮助识别可能的欺诈行为。你的程序实时接收有关每笔银行间资金转账的信息。对于每笔转账，你会得到：
- en: The amount of the transfer
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转账金额
- en: The ID of the branch in which the transfer took place
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转账发生的分支的ID
- en: The identification code for the bank the funds are being sent to
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资金被发送到的银行的识别码
- en: Your task is to analyze the transfers over time to identify unusual patterns
    of activity. To do this, you need to calculate, for each of the last eight days,
    the total value of all transfers for each branch and destination bank. You can
    then compare the current day's totals against the average for the previous seven
    days, and flag any daily totals that are more than 50% above the average.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你的任务是分析随时间变化的转账，以识别异常的活动模式。为此，你需要计算过去八天的每个分支和目标银行的所有转账总值。然后，你可以将当天的总额与前七天的平均值进行比较，并标记任何日总额超过平均值50%以上的情况。
- en: 'You start by deciding how to represent the total transfers for a day. Because
    you need to keep track of this for each branch and destination bank, it makes
    sense to store these totals in a two-dimensional array:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从决定如何表示一天的总转账开始。因为你需要跟踪每个分支和目标银行的转账总额，所以将这些总额存储在一个二维数组中是有意义的：
- en: '![Wrappers](graphics/B05012_5_02.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![包装器](graphics/B05012_5_02.jpg)'
- en: 'In Python, this type of two-dimensional array is represented as a list of lists:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，这种二维数组的类型被表示为一个列表的列表：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can then keep a separate list of the branch ID for each row and another
    list holding the destination bank code for each column:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以保留一个单独的分支ID列表，每行一个，另一个列表保存每列的目标银行代码：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Using these lists, you can calculate the totals for a given day by processing
    the transfers that took place on that particular day:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些列表，你可以通过处理特定日期发生的转账来计算给定日期的总额：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So far so good. Once you have these totals for each day, you can then calculate
    the average and compare it against the current day's totals to identify the entries
    that are higher than 150% of the average.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利。一旦你得到了每天的总额，你可以计算平均值，并将其与当天的总额进行比较，以识别高于平均值150%的条目。
- en: 'Let''s imagine that you''ve written this program and managed to get it working.
    When you start using it, though, you immediately discover a problem: your bank
    has over 5,000 branches, and there are more than 15,000 banks worldwide that your
    bank can transfer funds to—that''s a total of 75 million combinations that you
    need to keep totals for, and as a result, your program is taking far too long
    to calculate the totals.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经编写了这个程序并设法让它工作。但当你开始使用它时，你立即发现了一个问题：你的银行有超过5000个分支，而你的银行可以向全球超过15000家银行转账，这总共需要为7500万种组合保留总额，因此，你的程序计算总额的时间太长了。
- en: 'To make your program faster, you need to find a better way of handling large
    arrays of numbers. Fortunately, there''s a library designed to do just this: **NumPy**.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使你的程序更快，你需要找到一种更好的处理大量数字数组的方法。幸运的是，有一个专门设计来做这件事的库：**NumPy**。
- en: 'NumPy is an excellent array-handling library. You can create huge arrays and
    perform sophisticated operations on an array with a single function call. Unfortunately,
    NumPy is also a dense and impenetrable library. It was designed and written for
    people with a deep understanding of mathematics. While there are many tutorials
    available and you can generally figure out how to use it, the code that uses NumPy
    is often hard to comprehend. For example, to calculate the average across multiple
    matrices would involve the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy是一个出色的数组处理库。你可以创建巨大的数组，并使用一个函数调用对数组执行复杂的操作。不幸的是，NumPy也是一个密集和晦涩的库。它是为数学深度理解的人设计和编写的。虽然有许多教程可用，你通常可以弄清楚如何使用它，但使用NumPy的代码通常很难理解。例如，要计算多个矩阵的平均值将涉及以下操作：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Figuring out what that last line does would require a trip to the NumPy documentation.
    Because of the complexity of the code that uses NumPy, this is a perfect example
    of a situation where a **wrapper module** can be used: the wrapper module can
    provide an easier-to-use interface to NumPy, so your code can use it without being
    cluttered with complex and confusing function calls.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 弄清楚最后一行的作用需要查阅NumPy文档。由于使用NumPy的代码的复杂性，这是一个使用**包装模块**的完美例子：包装模块可以为NumPy提供一个更易于使用的接口，这样你的代码就可以使用它，而不会被复杂和令人困惑的函数调用所淹没。
- en: 'To work through this example, we''ll start by installing the NumPy library.
    NumPy ([http://www.numpy.org](http://www.numpy.org)) runs on Mac OS X, Windows,
    and Linux machines. How you install it depends on which operating system you are
    using:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过这个例子，我们将从安装NumPy库开始。NumPy ([http://www.numpy.org](http://www.numpy.org))
    可以在Mac OS X、Windows和Linux机器上运行。你安装它取决于你使用的操作系统：
- en: For Mac OS X, you can download an installer from [http://www.kyngchaos.com/software/python](http://www.kyngchaos.com/software/python).
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Mac OS X，你可以从[http://www.kyngchaos.com/software/python](http://www.kyngchaos.com/software/python)下载安装程序。
- en: For MS Windows, you can download a Python "wheel" file for NumPy from [http://www.lfd.uci.edu/~gohlke/pythonlibs/#numpy](http://www.lfd.uci.edu/~gohlke/pythonlibs/#numpy).
    Choose the pre-built version of NumPy that matches your operating system and the
    desired version of Python. To use the wheel file, use the `pip install` command,
    for example, `pip install numpy-1.10.4+mkl-cp34-none-win32.whl`.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于MS Windows，你可以从[http://www.lfd.uci.edu/~gohlke/pythonlibs/#numpy](http://www.lfd.uci.edu/~gohlke/pythonlibs/#numpy)下载NumPy的Python“wheel”文件。选择与你的操作系统和所需的Python版本匹配的NumPy的预构建版本。要使用wheel文件，使用`pip
    install`命令，例如，`pip install numpy-1.10.4+mkl-cp34-none-win32.whl`。
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information about installing Python wheels, refer to [https://pip.pypa.io/en/latest/user_guide/#installing-from-wheels](https://pip.pypa.io/en/latest/user_guide/#installing-from-wheels).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有关安装Python wheel的更多信息，请参阅[https://pip.pypa.io/en/latest/user_guide/#installing-from-wheels](https://pip.pypa.io/en/latest/user_guide/#installing-from-wheels)。
- en: If your computer runs Linux, you can use your Linux package manager to install
    NumPy. Alternatively, you can download and build NumPy in source code form.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的计算机运行Linux，你可以使用你的Linux软件包管理器来安装NumPy。或者，你可以下载并构建NumPy的源代码形式。
- en: 'To ensure that NumPy is working, fire up your Python interpreter and enter
    the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保NumPy正常工作，启动你的Python解释器并输入以下内容：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'All going well, you should see a 2 x 2 matrix displayed:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一切顺利的话，你应该看到一个2 x 2的矩阵显示出来：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now that we have NumPy installed, let''s start working on our wrapper module.
    Create a new Python source file, named `numpy_wrapper.py`, and enter the following
    into this file:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了NumPy，让我们开始编写我们的包装模块。创建一个新的Python源文件，命名为`numpy_wrapper.py`，并输入以下内容到这个文件中：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: That's all for now; we'll add functions to this wrapper module as we need them.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了；我们将根据需要向这个包装模块添加函数。
- en: 'Next, create another Python source file, named `detect_unusual_transfers.py`,
    and enter the following into this file:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建另一个Python源文件，命名为`detect_unusual_transfers.py`，并输入以下内容到这个文件中：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, we are hardwiring the bank and branch codes for our example;
    in a real program, these values would be loaded from somewhere, such as a file
    or a database. Since we don't have any available data, we will use the `random`
    module to create some. We are also changing the name of the `numpy_wrapper` module
    to make it easier to access from our code.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们正在为我们的例子硬编码银行和分行代码；在一个真实的程序中，这些值将从某个地方加载，比如文件或数据库。由于我们没有可用的数据，我们将使用`random`模块来创建一些。我们还将更改`numpy_wrapper`模块的名称，以便更容易从我们的代码中访问。
- en: 'Let''s now create some funds transfer data to process, using the `random` module:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用`random`模块创建一些要处理的资金转账数据：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we randomly select a day, a bank code, a branch ID, and an amount, storing
    these values in the `transfers` list.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们随机选择一天、一个银行代码、一个分行ID和一个金额，将这些值存储在`transfers`列表中。
- en: 'Our next task is to collate this information into a series of arrays. This
    allows us to calculate the total value of the transfers for each day, grouped
    by the branch ID and destination bank. To do this, we''ll create a NumPy array
    for each day, where the rows in each array represent branches and the columns
    represent destination banks. We''ll then go through the list of transfers, processing
    them one by one. The following illustration summarizes how we process each transfer
    in turn:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个任务是将这些信息整理成一系列数组。这样可以让我们计算每天的转账总额，按分行ID和目标银行分组。为此，我们将为每一天创建一个NumPy数组，其中每个数组中的行代表分行，列代表目标银行。然后我们将逐个处理转账列表中的转账。以下插图总结了我们如何依次处理每笔转账：
- en: '![Wrappers](graphics/B05012_5_03.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![Wrappers](graphics/B05012_5_03.jpg)'
- en: First, we select the array for the day on which the transfer occurred, and then
    we select the appropriate row and column based on the destination bank and the
    branch ID. Finally, we add the amount of the transfer to that item within the
    day's array.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们选择发生转账的那一天的数组，然后根据目标银行和分行ID选择适当的行和列。最后，我们将转账金额添加到当天数组中的那个项目中。
- en: 'Let''s implement this logic. Our first task is to create a series of NumPy
    arrays, one for each day. Here, we immediately hit a snag: NumPy has many different
    options for creating arrays; in this case, we want to create an array that holds
    integer values and has its contents initialized to zero. If we used NumPy directly,
    our code would look like the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实现这个逻辑。我们的第一个任务是创建一系列NumPy数组，每天一个。在这里，我们立即遇到了一个障碍：NumPy有许多不同的选项用于创建数组；在这种情况下，我们想要创建一个保存整数值并且其内容初始化为零的数组。如果我们直接使用NumPy，我们的代码将如下所示：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is not exactly easy to understand, so we''re going to move this logic
    into our NumPy wrapper module. Edit the `numpy_wrapper.py` file, and add the following
    to the end of this module:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是很容易理解，所以我们将这个逻辑移到我们的NumPy包装模块中。编辑`numpy_wrapper.py`文件，并在这个模块的末尾添加以下内容：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we can create a new array by calling our wrapper function (`npw.new()`)
    and not have to worry about the details of how NumPy works at all. We have simplified
    the interface to this particular aspect of NumPy:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过调用我们的包装函数（`npw.new()`）来创建一个新的数组，而不必担心NumPy的工作细节。我们已经简化了NumPy的特定方面的接口：
- en: '![Wrappers](graphics/B05012_5_04.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![包装器](graphics/B05012_5_04.jpg)'
- en: 'Let''s now use our wrapper function to create the eight arrays that we will
    need, one for each day. Add the following to the end of the `detect_unusual_transfers.py`
    file:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用我们的包装函数来创建我们需要的八个数组，每天一个。在`detect_unusual_transfers.py`文件的末尾添加以下内容：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now that we have our NumPy arrays, we can use them as if they were nested Python
    lists. For example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了NumPy数组，我们可以像使用嵌套的Python列表一样使用它们。例如：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We just need to choose the appropriate array, and calculate the row and column
    numbers to use. Here is the necessary code, which you should add to the end of
    your `detect_unusual_transfers.py` script:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要选择适当的数组，并计算要使用的行和列号。以下是必要的代码，你应该将其添加到你的`detect_unusual_transfers.py`脚本的末尾：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now that we''ve collated the transfers into eight NumPy arrays, we want to
    use all this data to detect any unusual activity. For each combination of branch
    ID and destination bank code, we will need to do the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将转账整理成了八个NumPy数组，我们希望使用所有这些数据来检测任何不寻常的活动。对于每个分行ID和目标银行代码的组合，我们需要做以下工作：
- en: Calculate the average of the first seven days' activity.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算前七天活动的平均值。
- en: Multiply the calculated average by 1.5.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将计算出的平均值乘以1.5。
- en: If the activity on the eighth day is greater than the average multiplied by
    1.5, then we consider this activity to be unusual.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果第八天的活动大于平均值乘以1.5，那么我们认为这种活动是不寻常的。
- en: Of course, we need to do this for every row and column in our arrays, which
    would be very slow; this is why we're using NumPy. So, we need to calculate the
    average for multiple arrays of numbers, then multiply the array of averages by
    1.5, and finally, compare the values within the multiplied array against the array
    for the eighth day of data. Fortunately, these are all things that NumPy can do
    for us.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要对我们的数组中的每一行和每一列都这样做，这将非常慢；这就是为什么我们使用NumPy的原因。因此，我们需要计算多个数字数组的平均值，然后将平均值数组乘以1.5，最后，将乘以后的数组与第八天的数据数组进行比较。幸运的是，这些都是NumPy可以为我们做的事情。
- en: 'We''ll start by collecting together the seven arrays we need to average, as
    well as the array for the eighth day. To do this, add the following to the end
    of your program:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先收集我们需要平均的七个数组，以及第八天的数组。为此，将以下内容添加到你的程序的末尾：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To calculate the average of a list of arrays, NumPy requires us to use the
    following function call:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算一组数组的平均值，NumPy要求我们使用以下函数调用：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Since this is confusing, we will move this function into our wrapper. Add the
    following code to the end of the `numpy_wrapper.py` module:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这很令人困惑，我们将把这个函数移到我们的包装器中。在`numpy_wrapper.py`模块的末尾添加以下代码：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This lets us calculate the average of the seven day''s activity using a single
    call to our wrapper function. To do this, add the following to the end of your
    `detect_unusual_transfers.py` script:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们可以使用一个调用我们的包装函数来计算七天活动的平均值。为此，将以下内容添加到你的`detect_unusual_transfers.py`脚本的末尾：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see, using the wrapper makes our code much easier to understand.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，使用包装器使我们的代码更容易理解。
- en: 'Our next task is to multiply the array of calculated averages by 1.5, and compare
    the result against the current day''s totals. Fortunately, NumPy makes this easy:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个任务是将计算出的平均值数组乘以1.5，并将结果与当天的总数进行比较。幸运的是，NumPy使这变得很容易：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Because this code is so clear, there''s no advantage in creating a wrapper
    function for it. The resulting array, `unusual_transfers`, will be the same size
    as our `current` and `average` arrays, where each entry in the array is either
    `True` or `False`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这段代码如此清晰，所以为它创建一个包装器函数没有任何优势。结果数组`unusual_transfers`的大小与我们的`current`和`average`数组相同，数组中的每个条目都是`True`或`False`：
- en: '![Wrappers](graphics/B05012_5_05.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![包装器](graphics/B05012_5_05.jpg)'
- en: 'We''re almost done; our final task is to identify the array entries with a
    value of `True`, and tell the user about the unusual activity. While we could
    scan through every row and column to find the `True` entries, using NumPy is much
    faster. The following NumPy code will give us a list containing the row and column
    numbers for the `True` entries in the array:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了；我们的最后任务是识别数组中值为`True`的条目，并告诉用户有不寻常的活动。虽然我们可以扫描每一行和每一列来找到`True`条目，但使用NumPy会快得多。以下的NumPy代码将给我们一个包含数组中`True`条目的行和列号的列表：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'True to form, though, this code is hard to understand, so it''s a perfect candidate
    for another wrapper function. Go back to your `numpy_wrapper.py` module, and add
    the following to the end of the file:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，这段代码很难理解，所以它是另一个包装器函数的完美候选者。回到你的`numpy_wrapper.py`模块，并在文件末尾添加以下内容：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This function returns a list (actually an array) of `(row,col)` values for
    all the `True` entries in the array. Back in our `detect_unusual_activity.py`
    file, we can use this function to quickly identify the unusual activity:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数返回一个列表（实际上是一个数组），其中包含数组中所有`True`条目的`(行，列)`值。回到我们的`detect_unusual_activity.py`文件，我们可以使用这个函数快速识别不寻常的活动：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see, we use the `BRANCH_IDS` and `BANK_CODES` lists to convert from
    the row and column number back to the relevant branch ID and bank code. We also
    retrieve the average and current amounts for the suspicious activity. Finally,
    we print out this information to warn the user about the unusual activity.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们使用`BRANCH_IDS`和`BANK_CODES`列表来将行和列号转换回相关的分行ID和银行代码。我们还检索了可疑活动的平均值和当前金额。最后，我们打印出这些信息，警告用户有不寻常的活动。
- en: 'If you run your program, you should see an output that looks something like
    this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行你的程序，你应该会看到类似这样的输出：
- en: '[PRE36]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Because we are using random numbers for our financial data, the output will
    be random too. Try running the program a few times; you may not get any output
    at all if none of the randomly-generated values are suspicious.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在金融数据中使用随机数，所以输出也将是随机的。尝试运行程序几次；如果没有生成可疑的随机值，则可能根本没有输出。
- en: Of course, we are not really interested in detecting suspicious financial activity—this
    example is just an excuse for working with NumPy. What is far more interesting
    is the wrapper module that we created, hiding the complexity of the NumPy interface
    so that the rest of our program can concentrate on the job to be done.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们并不真正关心检测可疑的金融活动——这个例子只是一个借口，用来处理NumPy。更有趣的是我们创建的包装模块，它隐藏了NumPy接口的复杂性，使得我们程序的其余部分可以集中精力完成工作。
- en: If we were to continue developing our unusual activity detector, we would no
    doubt add more functionality to our `numpy_wrapper.py` module as we found more
    NumPy functions that we wanted to wrap.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续开发我们的异常活动检测器，毫无疑问，我们会在`numpy_wrapper.py`模块中添加更多功能，因为我们发现了更多想要封装的NumPy函数。
- en: This is just one example of a wrapper module. As we mentioned earlier, simplifying
    a complex and confusing API is just one use for a wrapper module; they can also
    be used to convert data from one format to another, add testing and error-checking
    code to an existing API, and call functions that are written in a different language.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是包装模块的一个例子。正如我们之前提到的，简化复杂和混乱的API只是包装模块的一个用途；它们还可以用于将数据从一种格式转换为另一种格式，向现有API添加测试和错误检查代码，并调用用其他语言编写的函数。
- en: Note that, by definition, a wrapper is always *thin*—while there might be code
    in a wrapper (for example, to convert a parameter from an object into a dictionary),
    the wrapper function always ends up calling another function to do the actual
    work.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，根据定义，包装器始终是*薄*的——虽然包装器中可能有代码（例如，将参数从对象转换为字典），但包装器函数最终总是调用另一个函数来执行实际工作。
- en: Extensible modules
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可扩展模块
- en: Most of the time, the functionality provided by a module is known in advance.
    The module's source code implements a well-defined set of behavior, and that is
    all the module does. In some situations, however, you may need a module where
    the behavior of the module is not completely defined at the time you write it.
    Other parts of your system can *extend* the behavior of the module in various
    ways. Modules that are designed to be extended are called **extensible modules**.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，模块提供的功能是预先知道的。模块的源代码实现了一组明确定义的行为，这就是模块的全部功能。然而，在某些情况下，您可能需要一个模块，在编写时模块的行为并不完全定义。系统的其他部分可以以各种方式*扩展*模块的行为。设计为可扩展的模块称为**可扩展模块**。
- en: One of the great things about Python is that it is a *dynamic* language. You
    don't need to define and compile all your code before it will run. This makes
    it easy to create extensible modules using Python.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Python的一个伟大之处在于它是一种*动态*语言。您不需要在运行之前定义和编译所有代码。这使得使用Python创建可扩展模块变得很容易。
- en: 'In this section, we will look at three different ways in which a module can
    be made extensible: through the use of **dynamic imports**, by writing **plugins**,
    and using **hooks**.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一下模块可以被扩展的三种不同方式：通过使用**动态导入**，编写**插件**，以及使用**钩子**。
- en: Dynamic imports
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态导入
- en: 'In the previous chapter, we created a module called `renderers.py` which selected
    an appropriate renderer module to draw a chart element using a given output format.
    The following is an abbreviated copy of this module''s source code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了一个名为`renderers.py`的模块，它选择了一个适当的渲染器模块，以使用给定的输出格式绘制图表元素。以下是该模块源代码的摘录：
- en: '[PRE37]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This module is interesting because it implements, in a limited way, the concept
    of extensibility. Notice that the `renderer.draw()` function calls a `draw()`
    function within another module to do the actual work; which module is used depends
    on the desired chart format and the element to be drawn.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块很有趣，因为它以有限的方式实现了可扩展性的概念。请注意，`renderer.draw()`函数调用另一个模块内的`draw()`函数来执行实际工作；使用哪个模块取决于所需的图表格式和要绘制的元素。
- en: This module is not truly extensible because the list of possible modules is
    determined by the `import` statements at the top of the module. However, it is
    possible to turn this into a fully extensible module by making use of `importlib`.
    This is a module in the Python Standard Library that gives a developer access
    to the internal mechanism used to import modules; using `importlib`, you can import
    modules dynamically.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块并不真正可扩展，因为可能的模块列表是由模块顶部的`import`语句确定的。然而，可以通过使用`importlib`将其转换为完全可扩展的模块。这是Python标准库中的一个模块，它使开发人员可以访问用于导入模块的内部机制；使用`importlib`，您可以动态导入模块。
- en: 'To understand how this works, let''s look at an example. Create a new directory
    to hold your source code, and in this directory, create a new module named `module_a.py`.
    Enter the following code into this module:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这是如何工作的，让我们看一个例子。创建一个新的目录来保存您的源代码，在这个目录中，创建一个名为`module_a.py`的新模块。将以下代码输入到这个模块中：
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, create a copy of this module, named `module_b.py`, and edit the `say_hello()`
    function to print *Hello from module_b*. Then, repeat the process to create `module_c.py`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个名为`module_b.py`的此模块的副本，并编辑`say_hello()`函数以打印*Hello from module_b*。然后，重复这个过程来创建`module_c.py`。
- en: 'We now have three modules that all implement a function named `say_hello()`.
    Now, create another Python source file in the same directory, and name it `load_module.py`.
    Then, enter the following into this file:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有三个模块，它们都实现了一个名为`say_hello()`的函数。现在，在同一个目录中创建另一个Python源文件，并将其命名为`load_module.py`。然后，输入以下内容到这个文件中：
- en: '[PRE39]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This program prompts the user to enter a string using the `input()` statement.
    We then call `importlib.import_module()` to import the module with that name,
    and call that module's `say_hello()` function.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序提示用户使用`input()`语句输入一个字符串。然后，我们调用`importlib.import_module()`来导入具有该名称的模块，并调用该模块的`say_hello()`函数。
- en: 'Try running this program, and when prompted, type in `module_a`. You should
    see the following message displayed:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行这个程序，当提示时，输入`module_a`。你应该会看到以下消息显示：
- en: '[PRE40]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Try repeating this process with the other modules. If you type in the name of
    a non-existent module, you'll get an `ImportError`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试用其他模块重复这个过程。如果输入一个不存在的模块名称，你会得到一个`ImportError`。
- en: 'Of course, `importlib` isn''t limited to importing modules in the same directory
    as the current module; you can include package names if you want. For example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`importlib`并不仅限于导入与当前模块相同目录中的模块；如果需要，你可以包括包名。例如：
- en: '[PRE41]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Using `importlib`, you can import a module dynamically—you don''t need to know
    the name of the module at the time you write your program. We could use this to
    rewrite the `renderer.py` module from the previous chapter to make it fully extensible:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`importlib`，你可以动态地导入一个模块——在编写程序时不需要知道模块的名称。我们可以使用这个来重写上一章的`renderer.py`模块，使其完全可扩展：
- en: '[PRE42]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice the use of the special `__package__` variable. This holds the name of
    the package enclosing the current module; using this allows us to import a module
    relative to the package that the `renderer.py` module is part of.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到了特殊的`__package__`变量的使用。它保存了包含当前模块的包的名称；使用这个变量允许我们相对于`renderer.py`模块所属的包导入模块。
- en: The great thing about dynamic imports is that you don't need to know what all
    the modules are at the time you create your program. Using the `renderer.py` example,
    you could add new chart formats or elements by creating new renderer modules,
    and the system will import them when requested, without having to make any changes
    at all to your `renderer.py` module.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 动态导入的好处是，在创建程序时不需要知道所有模块的名称。使用`renderer.py`的例子，你可以通过创建新的渲染器模块来添加新的图表格式或元素，系统将在请求时导入它们，而无需对`renderer.py`模块进行任何更改。
- en: Plugins
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插件
- en: Plugins are modules that the user (or another developer) writes and "plugs in"
    to your program. Plugins are popular in many large systems such as WordPress,
    JQuery, Google Chrome, and Adobe Photoshop. Plugins are used to extend the functionality
    of an existing program.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 插件是用户（或其他开发人员）编写并“插入”到你的程序中的模块。插件在许多大型系统中很受欢迎，如WordPress、JQuery、Google Chrome和Adobe
    Photoshop。插件用于扩展现有程序的功能。
- en: In Python, it is easy to implement plugins using the same dynamic import mechanism
    we discussed in the previous section. The only difference is that instead of importing
    modules that are already part of your program's source code, you set up a separate
    directory where the user can place the plugins they want to add to your program.
    This could be as simple as creating a `plugins` directory at the top level of
    your program, or you could store your plugins in a directory outside of your program's
    source code, and modify `sys.path` so that the Python interpreter can find the
    modules in that directory. Either way, your program will use `importlib.import_module()`
    to load the desired plugin, and then access the functions and other definitions
    within the plugin just like you would access functions and other definitions in
    any other Python module.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，使用我们在上一节讨论过的动态导入机制很容易实现插件。唯一的区别是，不是导入已经是程序源代码一部分的模块，而是设置一个单独的目录，用户可以将他们想要添加到程序中的插件放在其中。这可以简单地创建一个`plugins`目录在程序的顶层，或者你可以将插件存储在程序源代码之外的目录中，并修改`sys.path`以便Python解释器可以在该目录中找到模块。无论哪种方式，你的程序都将使用`importlib.import_module()`来加载所需的插件，然后像访问任何其他Python模块中的函数和其他定义一样访问插件中的函数和其他定义。
- en: The sample code available for this chapter includes a simple plugin loader which
    shows how this mechanism works.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供的示例代码包括一个简单的插件加载器，展示了这种机制的工作方式。
- en: Hooks
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 钩子
- en: A **hook** is a way of allowing external code to be called at particular points
    in your program. A hook is usually a function—your program checks to see if a
    hook function has been defined, and if so, it calls this function at an appropriate
    time.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**钩子**是允许外部代码在程序的特定点被调用的一种方式。钩子通常是一个函数——你的程序会检查是否定义了一个钩子函数，如果是，就会在适当的时候调用这个函数。'
- en: 'Let''s look at a concrete example. Imagine that you have a program that includes
    the ability to log a user in and out. Part of your program may include the following
    module, which we will call `login_module.py`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个具体的例子。假设你有一个程序，其中包括记录用户登录和退出的功能。你的程序的一部分可能包括以下模块，我们将其称为`login_module.py`：
- en: '[PRE43]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, imagine that you want to add a hook that gets called whenever the user
    logs in. Adding this to your program would involve the following changes to this
    module:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下，你想要添加一个钩子，每当用户登录时都会被调用。将这个功能添加到你的程序中将涉及对这个模块的以下更改：
- en: '[PRE44]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'With this code in place, other parts of your system can hook into your login
    process by setting their own login hook function, which does something whenever
    the user logs in. For example:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这段代码，系统的其他部分可以通过设置自己的登录钩子函数来连接到你的登录过程，这样每当用户登录时就会执行一些操作。例如：
- en: '[PRE45]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: By implementing this login hook, you have extended the behavior of the login
    process without altering the login module itself.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现这个登录钩子，你扩展了登录过程的行为，而不需要修改登录模块本身。
- en: 'There are a couple of things to be aware of with hooks:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子有一些需要注意的事项：
- en: Depending on the behavior you are implementing a hook for, the value returned
    by the hook function might be used to alter the behavior of your code. For example,
    if the login hook returned `False`, the user might be blocked from logging in.
    This doesn't apply to every hook, but it can be a very useful way of giving a
    hook function more control over what happens in your program.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据你为其实现钩子的行为，钩子函数返回的值可能会被用来改变你的代码的行为。例如，如果登录钩子返回`False`，用户可能会被阻止登录。这并不适用于每个钩子，但这是一个让钩子函数对程序中发生的事情有更多控制的非常有用的方式。
- en: In this example, we only allow a single hook function to be defined for each
    hook. Another way of implementing this would be to have a list of registered hook
    functions, and let your program add or remove hook functions as required. In this
    way, you could have several hook functions, which get called one after the other
    whenever something happens.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只允许为每个hook定义一个hook函数。另一种实现方式是拥有一个注册的hook函数列表，并让您的程序根据需要添加或删除hook函数。这样，您可以有几个hook函数，每当发生某些事情时依次调用它们。
- en: Hooks are an excellent way of adding specific points of extensibility to your
    modules. They are easy to implement and use, and unlike dynamic imports and plugins,
    they don't require you to put your code into a separate module. This means that
    hooks are an ideal way of extending your modules in a very fine-grained way.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Hooks是向您的模块添加特定可扩展性点的绝佳方式。它们易于实现和使用，与动态导入和插件不同，它们不要求您将代码放入单独的模块中。这意味着hooks是以非常精细的方式扩展您的模块的理想方式。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we saw that the ways in which modules and packages are used
    tend to follow standard patterns. We examined the divide-and-conquer pattern,
    which is the process of breaking a problem down into smaller parts, and saw how
    this technique both helps to structure your programs and clarify your thinking
    about the problem you are trying to solve.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到模块和包的使用方式往往遵循标准模式。我们研究了分而治之的模式，这是将问题分解为较小部分的过程，并看到这种技术如何帮助构建程序结构并澄清您对要解决的问题的思考。
- en: We next looked at the abstraction pattern, which is the process of hiding complexity
    by separating what you want to do from how to do it. We then examined the notion
    of encapsulation, which is where you store data about something but hide the details
    of how that data is represented from the rest of the system, and use getter and
    setter functions to provide access to that data.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看了抽象模式，这是通过将您想要做的事情与如何做它分开来隐藏复杂性的过程。然后我们研究了封装的概念，即存储有关某些事物的数据，但隐藏该数据的表示方式的细节，使用getter和setter函数来访问该数据。
- en: We then turned to the concept of wrappers, and saw how wrappers can be used
    to simplify the interface to a complex or confusing API, to convert data formats,
    to implement cross-language compatibility, and to add testing and error-checking
    code to an existing API.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们转向包装器的概念，并看到包装器如何用于简化复杂或令人困惑的API的接口，转换数据格式，实现跨语言兼容性，并向现有API添加测试和错误检查代码。
- en: Finally, we learned about extensible modules, and saw how we can use the techniques
    of dynamic module imports, plugins, and hooks to create a module that does more
    than you designed it to do. We saw that the dynamic nature of Python makes it
    ideally suited to the creation of extensible modules where the behavior of your
    modules is not completely defined at the time you write them.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们了解了可扩展模块，并看到我们可以使用动态模块导入、插件和hooks的技术来创建一个模块，它可以做的不仅仅是您设计它要做的事情。我们看到Python的动态特性使其非常适合创建可扩展模块，其中您的模块的行为在编写时并不完全定义。
- en: In the next chapter, we will learn how to design and implement modules that
    can be shared and reused in other programs.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何设计和实现可以在其他程序中共享和重用的模块。
