- en: Networking with MQTT, Python, and the Mosquitto MQTT Broker
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MQTT，Python和Mosquitto MQTT代理进行网络连接
- en: In the previous chapter, we created two Python servers and accompanying web
    pages using both a RESTful API and Web Socket approach to networking. In this
    chapter, we will cover another networking topology that is common in the IoT world,
    known as **MQTT **or **Message Queue Telemetry Transport***.*
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用RESTful API和Web Socket方法创建了两个Python服务器和相应的网页。在本章中，我们将涵盖另一种在物联网世界中常见的网络拓扑，称为**MQTT**或**消息队列遥测传输**。
- en: We will commence by setting up your development environment and installing the
    Mosquitto MQTT broker service on your Raspberry Pi. Then, we will learn about
    MQTT features using command-line tools that come with Mosquitto to help you to
    understand the core concepts in isolation. After that, we'll proceed to a Python
    IoT application that uses MQTT for its messaging layer—and yes, it'll be all about
    controlling the LED!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先设置您的开发环境，并在树莓派上安装Mosquitto MQTT代理服务。然后，我们将使用Mosquitto附带的命令行工具学习MQTT的特性，以帮助您单独理解核心概念。之后，我们将进行一个使用MQTT作为其消息传输层的Python物联网应用程序，是的，它将完全关于LED的控制！
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中涵盖以下主题：
- en: Installing the Mosquitto MQTT broker
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Mosquitto MQTT代理
- en: Learning MQTT by example
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过示例学习MQTT
- en: Introducing the Python Paho-MQTT client library
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Python Paho-MQTT客户端库
- en: Controlling an LED with Python and MQTT
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python和MQTT控制LED
- en: Building a web-based MQTT client
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建基于Web的MQTT客户端
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To perform the exercises in this chapter, you will need the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行本章的练习，您需要以下内容：
- en: Raspberry Pi 4 Model B
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树莓派4型B型号
- en: Raspbian OS Buster (with desktop and recommended software)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raspbian OS Buster（带桌面和推荐软件）
- en: A minimum of Python version 3.5
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少Python版本3.5
- en: These requirements are what the code examples in this book are based on. It's
    reasonable to expect that the code examples should work without modification on
    a Raspberry Pi 3 Model B or a different version of Raspbian OS as long as your
    Python version is 3.5 or higher.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些要求是本书中代码示例的基础。可以合理地期望代码示例应该可以在树莓派3型B型或不同版本的Raspbian OS上无需修改地运行，只要您的Python版本是3.5或更高。
- en: 'You will find this chapter''s source code in the `chapter04` folder in the
    GitHub repository available at the following URL: [https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT](https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下URL的GitHub存储库的`chapter04`文件夹中找到本章的源代码：[https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT](https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT)
- en: 'You will need to execute the following commands in a Terminal to set up a virtual
    environment and install the Python libraries required for the code in this chapter:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在终端中执行以下命令，以设置虚拟环境并安装本章代码所需的Python库：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following dependencies are installed from `requirements.txt`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从`requirements.txt`中安装以下依赖项：
- en: '**GPIOZero**: The GPIOZero GPIO library ([https://pypi.org/project/gpiozero](https://pypi.org/project/gpiozero))'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GPIOZero**：GPIOZero GPIO库（[https://pypi.org/project/gpiozero](https://pypi.org/project/gpiozero)）'
- en: '**PiGPIO**: The PiGPIO GPIO library ([https://pypi.org/project/pigpio](https://pypi.org/project/pigpio))'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PiGPIO**：PiGPIO GPIO库（[https://pypi.org/project/pigpio](https://pypi.org/project/pigpio)）'
- en: '**Paho-MQTT** **Client**: The Paho-MQTT client library ([https://pypi.org/project/paho-mqtt](https://pypi.org/project/paho-mqtt))'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Paho-MQTT** **客户端**：Paho-MQTT客户端库（[https://pypi.org/project/paho-mqtt](https://pypi.org/project/paho-mqtt)）'
- en: We will be working with the breadboard circuit we created in [Chapter 2](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml),
    *Getting Started with Python and IoT*, *Figure 2.7*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们在[第2章](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml)中创建的面包板电路进行工作，*使用Python和物联网入门*，*图2.7*。
- en: Installing the Mosquitto MQTT broker
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Mosquitto MQTT代理
- en: '**MQTT***,* or **Message Queue Telemetry Transport**, is a lightweight and
    simple messaging protocol targeted specifically for IoT applications. While a
    Raspberry Pi is powerful enough to leverage more complex messaging protocols,
    if you are using it as part of a distributed IoT solution, chances are you are
    going to encounter MQTT; hence, learning it is very important. Besides, its simplicity
    and open nature make it easy to learn and use.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**MQTT**，或**消息队列遥测传输**，是一种专门针对物联网应用的轻量级和简单的消息传输协议。虽然树莓派足够强大，可以利用更复杂的消息传输协议，但如果您将其用作分布式物联网解决方案的一部分，很可能会遇到MQTT；因此，学习它非常重要。此外，它的简单性和开放性使其易于学习和使用。'
- en: Our introduction to MQTT is going to be performed using a popular open source
    MQTT broker called *Mosquitto* that we will install on your Raspberry Pi.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为*Mosquitto*的流行开源MQTT代理来进行MQTT的介绍，并将其安装在您的树莓派上。
- en: The examples we cover in this chapter were performed with the Mosquitto broker
    and client version 1.5.7, which are MQTT protocol version 3.1.1-complaint. A different
    version of the broker or client tools will be suitable as long as they are MQTT
    protocol version 3.1.x-compatible.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的示例是使用Mosquitto代理和客户端版本1.5.7执行的，这是MQTT协议版本3.1.1兼容的。只要它们是MQTT协议版本3.1.x兼容的，代理或客户端工具的不同版本都将适用。
- en: 'To install the Mosquitto MQTT broker service and client tools, follow these
    steps:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Mosquitto MQTT代理服务和客户端工具，请按照以下步骤进行：
- en: 'Open a new Terminal window and execute the following `apt-get` command. This
    must be performed using `sudo`:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端窗口并执行以下`apt-get`命令。这必须使用`sudo`执行：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To ensure that the Mosquitto MQTT broker service has started, run the following
    command in the Terminal:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要确保Mosquitto MQTT代理服务已启动，请在终端中运行以下命令：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Check that the Mosquitto service has started with the following `service` command. We
    expect to see the `active (running)` text printed to the Terminal:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下`service`命令检查Mosquitto服务是否已启动。我们期望在终端上看到`active (running)`文本打印出来：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can check the Mosquitto and MQTT protocol version with the `mosquitto -h` command.
    Here, we see that the Mosquitto broker is using MQTT version 3.1.1:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`mosquitto -h`命令检查Mosquitto和MQTT协议版本。 在这里，我们看到Mosquitto代理使用的是MQTT版本3.1.1：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Next, we will configure Mosquitto so that it can serve web pages and handle
    Web Socket requests. We will use these features when we come to build a web page
    client later in this chapter.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将配置Mosquitto，以便它可以提供网页并处理Web套接字请求。 当我们在本章后面构建网页客户端时，我们将使用这些功能。
- en: 'In the `chapter4` folder, there is a file named `mosquitto_pyiot.conf`, which
    is partially replicated here. There is one line in this file that we need to check:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chapter4`文件夹中，有一个名为`mosquitto_pyiot.conf`的文件，这里部分复制了该文件。 此文件中有一行我们需要检查的内容：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For the exercises in this chapter, you need to update the `http_dir` setting
    on the last line so it's the absolute path to the `chapter04/mosquitto_www` folder
    on your Raspberry Pi. If you used the suggested folder, `/home/pi/pyiot`, when
    cloning the GitHub repository in [Chapter 1](fea8bc67-63b9-4cbc-9c02-82b4b9bbe5e0.xhtml)*,
    Setting Up Your Development Environment*, then the path listed previously is correct.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的练习，您需要更新最后一行的`http_dir`设置，使其成为树莓派上`chapter04/mosquitto_www`文件夹的绝对路径。 如果您在[第1章](fea8bc67-63b9-4cbc-9c02-82b4b9bbe5e0.xhtml)*，设置您的开发环境*中克隆GitHub存储库时使用了建议的文件夹`/home/pi/pyiot`，那么先前列出的路径是正确的。
- en: 'Next, we copy the configuration in `mosquitto_pyiot.conf` using the following `cp`
    command into the appropriate folder so that it can be loaded by Mosquitto:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用以下`cp`命令将`mosquitto_pyiot.conf`中的配置复制到适当的文件夹中，以便Mosquitto可以加载它：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now we restart the Mosquitto service to load our configuration:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们重新启动Mosquitto服务以加载我们的配置：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To check that the configuration has worked, visit the `http://localhost:8083` URL in
    a web browser on your Raspberry Pi, and you should see a page similar to the following
    screenshot:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检查配置是否有效，请在树莓派上的Web浏览器中访问`http://localhost:8083` URL，您应该看到类似以下截图的页面：
- en: '![](assets/525e2257-5a0c-4b58-a62a-8b11eb2f467e.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/525e2257-5a0c-4b58-a62a-8b11eb2f467e.png)'
- en: Figure 4.1 – Web page served by the Mosquitto MQTT broker
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 - Mosquitto MQTT代理提供的网页
- en: This is a giveaway to what we'll be doing later in this chapter! At the moment,
    while you can move the slider, it *will not* change the LED's brightness because
    we do not have the Python-side code running. We'll cover that in due course later
    in this chapter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章后面我们将要做的事情的线索！ 目前，虽然您可以移动滑块，但它*不会*改变LED的亮度，因为我们没有运行Python端的代码。 我们将在本章后面逐步介绍。
- en: 'If you experience problems getting the Mosquitto MQTT Broker to start, try
    the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在启动Mosquitto MQTT代理时遇到问题，请尝试以下操作：
- en: Execute `sudo mosquitto -v -c /etc/mosquitto/mosquitto.conf` in a Terminal.
    This will start Mosquitto in the foreground and any start up or configurations
    errors will be shown on your Terminal.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在终端中执行`sudo mosquitto -v -c /etc/mosquitto/mosquitto.conf`。 这将在前台启动Mosquitto，并且任何启动或配置错误都将显示在您的终端上。
- en: Read the troubleshooting comments in the `mosquitto_pyiot.conf` file for additional
    suggestions.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读`mosquitto_pyiot.conf`文件中的故障排除注释以获取其他建议。
- en: The default configuration of Mosquitto after installation creates an *unencrypted*
    and *unauthenticated* MQTT broker service. The Mosquitto documentation contains
    details regarding its configuration and how to enable authentication and encryption.
    You will find links in the *Further reading* section at the end of this chapter.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Mosquitto安装后的默认配置创建了一个*未加密*和*未经身份验证*的MQTT代理服务。 Mosquitto文档包含有关其配置以及如何启用身份验证和加密的详细信息。
    您将在本章末尾的*进一步阅读*部分找到链接。
- en: Now that we have Mosquitto installed and running, we can explore MQTT concepts
    and perform examples to see them in practice.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装并运行了Mosquitto，我们可以探索MQTT概念并执行示例以看到它们在实践中的应用。
- en: Learning MQTT by example
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过示例学习MQTT
- en: MQTT is a broker-based *publishing* and *subscription* messaging protocol (frequently
    paraphrased as *pub/sub*), while an MQTT *broker* (just like the Mosquitto MQTT
    broker we installed in the previous section) is a server that implements the MQTT
    protocol. By using an MQTT-based architecture, your applications can essentially
    hand off all complex messaging handling and routing logic to the broker so they
    can remain solution-focused.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT是基于代理的*发布*和*订阅*消息协议（经常被简化为*pub/sub*），而MQTT *代理*（就像我们在上一节中安装的Mosquitto MQTT代理）是实现MQTT协议的服务器。
    通过使用基于MQTT的架构，您的应用程序可以基本上将所有复杂的消息处理和路由逻辑交给代理，以便它们可以保持专注于解决方案。
- en: MQTT clients (for example, your Python programs and the command-line tools we
    are about to use) create a subscription with the broker and *subscribe* to message
    topics they are interested in. Clients *publish *messages to a topic, and it is
    the broker that is then responsible for all message routing and delivery assurances.
    Any client may assume the role of a subscriber, a publisher, or both.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT客户端（例如，您的Python程序和我们即将使用的命令行工具）与代理创建订阅并*订阅*它们感兴趣的消息主题。 客户端*发布*消息到主题，然后代理负责所有消息路由和传递保证。
    任何客户端都可以扮演订阅者、发布者或两者的角色。
- en: 'A simple conceptual MQTT-based system involving a pump, water tank, and controller
    application is illustrated in *Figure 4.2*:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4.2*展示了涉及泵、水箱和控制器应用程序的简单概念MQTT系统：'
- en: '![](assets/09bd86dd-a43b-4ff7-917c-c0be54738043.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/09bd86dd-a43b-4ff7-917c-c0be54738043.png)'
- en: Figure 4.2 – MQTT example
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 - MQTT示例
- en: 'Here is a high-level description of system components:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是系统组件的高级描述：
- en: Think of the *Water Level Sensor MQTT client* as the software connected to a
    water level sensor in a water tank. This client assumes the role of a *publisher*
    in our MQTT example. It periodically sends (that is, *publishes)* messages about
    how full the water tank is to the MQTT broker.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将*水位传感器MQTT客户端*视为连接到水箱中的水位传感器的软件。 在我们的MQTT示例中，此客户端扮演*发布者*的角色。 它定期发送（即*发布*）关于水箱装满了多少水的消息到MQTT代理。
- en: 'Think of the *Pump MQTT client* as a software driver that is capable of switching
    a water pump on or off. This client assumes both the role of a *publisher* and
    *subscriber* in our example:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将* Pump MQTT客户端*视为能够打开或关闭水泵的软件驱动程序。在我们的示例中，此客户端扮演*发布者*和*订阅者*的角色：
- en: As a *subscriber*, it can receive a message (via a *subscription)* instructing
    it to switch the pump on or off.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为*订阅者*，它可以接收一条消息（通过*订阅*）指示它打开或关闭水泵。
- en: As a *publisher*, it can send a message indicating whether the pump is on and
    pumping water or off.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为*发布者*，它可以发送一条消息，指示水泵是打开并抽水还是关闭。
- en: Think of the *Controller MQTT client* as the application where all of the control
    logic resides. This client also assumes both the roles of a *publisher* and *subscriber:*
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将*Controller MQTT客户端*视为所有控制逻辑所在的应用程序。此客户端还扮演*发布者*和*订阅者*的角色：
- en: As a *publisher*, this client can send a message that will tell the pump to
    switch on or off.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为*发布者*，此客户端可以发送一条消息，告诉水泵打开或关闭。
- en: As a *subscriber*, this client can receive messages from both the water tank
    level sensor and the pump.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为*订阅者*，此客户端可以从水箱水位传感器和水泵接收消息。
- en: By way of example, the *Controller MQTT client *application could be configured
    to switch on the pump when the water level in the tank falls below 50% and switch
    off the pump when the level reaches 100%. This controller application may also
    include a dashboard user interface that displays the current water level in the
    tank and a status light indicating whether the pump is on or off.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，*Controller MQTT客户端*应用程序可以配置为在水箱水位低于50％时打开水泵，并在水位达到100％时关闭水泵。此控制器应用程序还可以包括一个仪表板用户界面，显示水箱的当前水位以及指示水泵是否打开或关闭的状态灯。
- en: An important point to note regarding our MQTT system is that each client is
    unaware of the other clients—a client only ever connects to and interacts with
    the MQTT broker, which then routes messages as appropriate to clients. This routing
    is achieved using message *topics,* which we will cover later in the section entitled
    *Exploring MQTT topics and wildcards*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们的MQTT系统需要注意的一点是，每个客户端都不知道其他客户端，客户端只连接到MQTT代理并与之交互，然后代理将消息适当地路由到客户端。这通过使用消息*主题*来实现，我们将在标题为*探索MQTT主题和通配符*的部分中进行介绍。
- en: It's understandable why the pump would need to receive a message to tell it
    to turn on or off, but what about the pump's need to also send a message stating
    whether it is on or off? If you wondered about this, here is the reason. MQTT
    messages are send-and-forget, meaning that a client does not get an application-level
    response to a message that it publishes. So, in our example, while the controller
    client can publish a message asking the pump to turn on, without the pump publishing
    its status, the controller has no way of knowing whether the pump actually turned
    on.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 可以理解为什么水泵需要接收消息来告诉它打开或关闭，但是水泵还需要发送消息来说明它是打开还是关闭吗？如果您对此感到困惑，这就是原因。MQTT消息是发送并忘记的，这意味着客户端不会收到它发布的消息的应用级响应。因此，在我们的示例中，虽然控制器客户端可以发布一条消息要求水泵打开，但如果水泵不发布其状态，控制器就无法知道水泵是否真的打开了。
- en: In practice, the pump would publish its on/off status every time it turns on
    or off. This would allow the controller's dashboard to update the pump's status
    indicator in a timely manner. Furthermore, the pump would also periodically publish
    its status (just like the water level sensor) independent of any requests it receives
    to turn on or off. This way, the controller application can monitor the connection
    and availability of the pump and detect whether the pump goes offline.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，每次水泵打开或关闭时，水泵都会发布其开/关状态。这将允许控制器的仪表板及时更新水泵的状态指示器。此外，水泵还会定期发布其状态（就像水位传感器一样），而不依赖于其接收到的任何请求来打开或关闭。这样，控制器应用程序可以监视水泵的连接和可用性，并检测水泵是否脱机。
- en: For now, if you can grasp the basic ideas presented in the preceding example,
    then you are well on your way to understanding at a deeper level the core MQTT
    concepts that will be our focus for the remainder of this chapter. By the time
    we finish, you will have a fundamental end-to-end understanding of how to work
    with and design MQTT-based applications.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，如果您能理解前面示例中提出的基本思想，那么您就已经在更深入地理解本章其余部分将关注的核心MQTT概念的道路上了。到我们完成时，您将对如何使用和设计基于MQTT的应用程序有一个基本的端到端理解。
- en: We will start by learning how to publish and subscribe to messages.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从学习如何发布和订阅消息开始。
- en: Publishing and subscribing MQTT messages
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布和订阅MQTT消息
- en: 'Let''s work through the steps to send (that is, publish) and receive (that
    is, subscribe to) messages using MQTT:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤来发送（即发布）和接收（即订阅）使用MQTT的消息：
- en: 'In a Terminal, run the following command. `mosquitto_sub` (Mosquitto subscribe)
    is a command-line tool to *subscribe* to messages:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中运行以下命令。`mosquitto_sub`（Mosquitto订阅）是一个命令行工具，用于*订阅*消息：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The options are as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 选项如下：
- en: '`-v` (--verbose): verbose is so we get both the message *topic* and *message* payload
    printed on the Terminal.'
  id: totrans-78
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v`（-详细信息）：详细信息是为了在终端上打印消息*主题*和*消息*负载。'
- en: '`-h` (--host): localhost is the host of the broker we want to connect to; here
    it''s the one we just installed. The default port used is 1883.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-h`（-主机）：localhost是我们要连接的代理的主机；这里是我们刚刚安装的代理。使用的默认端口是1883。'
- en: '`-t` (--topic): `pyiot` is the topic we want to subscribe to and listen to.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-t`（-主题）：`pyiot`是我们要订阅和监听的主题。'
- en: 'In this chapter, we will require two and sometimes three Terminal sessions
    for the examples. The first line of a code block will indicate which Terminal
    you need to run a command in; for example, **Terminal #1** in the preceding code
    block, and **Terminal #2** in the following code block.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将需要两个或三个终端会话来进行示例。代码块的第一行将指示您需要在哪个终端中运行命令；例如，在前面的代码块中是**终端＃1**，在下面的代码块中是**终端＃2**。
- en: 'Open a second Terminal and run the following command.`mosquitto_pub` (Mosquitto
    publish) is a command-line tool to *publish* messages:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开第二个终端并运行以下命令。`mosquitto_pub`（Mosquitto发布）是一个命令行工具，用于*发布*消息：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s look at the options:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看选项：
- en: '`-h` and `-t` have the same meaning as in the preceding subscription command.'
  id: totrans-85
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-h`和`-t`的含义与前面的订阅命令相同。'
- en: '`-m ''hello!''` (--message) is the message we want to publish. Messages in
    MQTT are simple strings— if you''re wondering about JSON, it just needs to be
    serialized/deserialized to strings.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-m ''hello!''`（-message）是我们想要发布的消息。在MQTT中，消息是简单的字符串——如果你想知道JSON，它只需要被序列化/反序列化为字符串。'
- en: 'On **Terminal #1**, we see the topic and message, `hello!`, printed:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**终端#1**上，我们看到主题和消息`hello!`被打印出来：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The final line is in the format <*topic>* <*message payload>.*
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行的格式是<*topic>* <*message payload>*。
- en: The `hello!` message is preceded by the topic name, `pyiot`, because we have
    used the `-v` option to `mosquitto_sub`. Without the `-v` option, if we were subscribing
    to multiple topics, we could not identify which topic a message belonged to.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们使用了`-v`选项来订阅`mosquitto_sub`，所以`hello!`消息之前有主题名`pyiot`。如果没有`-v`选项，如果我们订阅多个主题，我们无法确定消息属于哪个主题。
- en: Now, we've learned how to publish and subscribe to messages with a simple topic.
    But is there any way we can organize these messages in a better way? Read on.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经学会了如何使用简单主题发布和订阅消息。但是有没有办法更好地组织这些消息呢？继续阅读。
- en: Exploring MQTT topics and wildcards
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索MQTT主题和通配符
- en: MQTT *topics* are used to categorize, or group, messages together in a hierarchical
    format. We have already been working with topics in our proceeding command-line
    examples, but in a non-hierarchical fashion. W*ildcards*, on the other hand, are
    special characters used by a *subscriber *to create flexible topic matching patterns.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT *主题* 用于以分层格式对消息进行分类或分组。我们已经在我们之前的命令行示例中使用主题，但是以非分层的方式。另一方面，通配符是订阅者用来创建灵活的主题匹配模式的特殊字符。
- en: 'Here are a few hierarchical topic examples from a hypothetical building with sensors.
    The hierarchy is delimited by the `/` character:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是来自具有传感器的假设建筑的一些分层主题示例。层次结构由`/`字符分隔：
- en: '`level1/lounge/temperature/sensor1`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`level1/lounge/temperature/sensor1`'
- en: '`level1/lounge/temperature/sensor2`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`level1/lounge/temperature/sensor2`'
- en: '`level1/lounge/lighting/sensor1`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`level1/lounge/lighting/sensor1`'
- en: '`level2/bedroom1/temperature/sensor1`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`level2/bedroom1/temperature/sensor1`'
- en: '`level2/bedroom1/lighting/sensor1`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`level2/bedroom1/lighting/sensor1`'
- en: There is no need to pre-create a topic on an MQTT broker. Using the *default* broker
    configuration (which we are), you just publish and subscribe to topics at will.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在MQTT代理上没有必要预先创建主题。使用*默认*代理配置（我们正在使用），您只需随意发布和订阅主题。
- en: When the Mosquitto broker is configured to use authentication, there is the
    possibility to restrict access to topics based on a client ID and/or username
    and password.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当Mosquitto代理配置为使用身份验证时，有可能根据客户端ID和/或用户名和密码限制对主题的访问。
- en: 'Messages *must* be published to a *specific* topic such as `pyiot`, while subscriptions
    can be made to a specific topic, or a range of topics, by using the wildcard characters, `+` and `#`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 消息*必须*发布到*特定*主题，如`pyiot`，而订阅可以通过使用通配符字符`+`和`#`订阅到特定主题或一系列主题：
- en: '`+` is used to match a single element of the hierarchy.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+`用于匹配层次结构的单个元素。'
- en: '`#` is used to match *all* remaining elements in a hierarchy (it can only be
    at the end of a topic query).'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#` 用于匹配层次结构中的*所有*剩余元素（它只能在主题查询的末尾）。'
- en: 'Subscriptions to topics and wildcards are best explained by example. Using
    the aforementioned hypothetical building with sensors, consider the examples in
    the following table:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对主题和通配符的订阅最好通过示例来解释。使用上述假设的建筑和传感器，考虑以下表中的示例：
- en: '| We want to subscribe to... | Wildcard topic | Topic matches |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 我们想要订阅... | 通配符主题 | 主题匹配 |'
- en: '| --- | --- | --- |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| All **temperature** sensors everywhere | `+/+/**temperature**/+` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 到处的**温度**传感器 | `+/+/**temperature**/+` |'
- en: '`level1/lounge/**temperature**/sensor1`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`level1/lounge/**temperature**/sensor1`'
- en: '`level1/lounge/**temperature**/sensor2`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`level1/lounge/**temperature**/sensor2`'
- en: '`level2/bedroom1/**temperature**/sensor1`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`level2/bedroom1/**temperature**/sensor1`'
- en: '|'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| All **light** sensors everywhere | `+/+/**lighting**/+` |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 所有地方的**灯**传感器 | `+/+/**lighting**/+` |'
- en: '`level1/lounge/**lighting**/sensor1`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`level1/lounge/**lighting**/sensor1`'
- en: '`level2/bedroom1/**lighting**/sensor1`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`level2/bedroom1/**lighting**/sensor1`'
- en: '|'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Every sensor on **level 2** | `**level2**/+/+/+` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| **level 2** 上的每个传感器 | `**level2**/+/+/+` |'
- en: '`**level2**/bedroom1/temperature/sensor1`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**level2**/bedroom1/temperature/sensor1`'
- en: '`**level2**/bedroom1/lighting/sensor1`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**level2**/bedroom1/lighting/sensor1`'
- en: '|'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Every sensor on **level 2**(a simpler way where `#` matches every remaining
    child) | `**level2**/#` |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| **level 2** 上的每个传感器（一个更简单的方法，其中`#`匹配每个剩余的子级） | `**level2**/#` |'
- en: '`**level2**/bedroom1/temperature/sensor1`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**level2**/bedroom1/temperature/sensor1'
- en: '`**level2**/bedroom1/lighting/sensor1`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**level2**/bedroom1/lighting/sensor1`'
- en: '|'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Only **sensor1** everywhere | `+/+/+/**sensor1**` |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 到处只有**sensor1** | `+/+/+/**sensor1**` |'
- en: '`level1/lounge/temperature/**sensor1**`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`level1/lounge/temperature/**sensor1**`'
- en: '`level1/lounge/lighting/**sensor1**`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`level1/lounge/lighting/**sensor1**`'
- en: '`level2/bedroom1/temperature/**sensor1**`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**level2**/bedroom1/temperature/**sensor1**`'
- en: '`level2/bedroom1/lighting/**sensor1**`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`level2/bedroom1/lighting/**sensor1**`'
- en: '|'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Only **sensor1** everywhere(a simpler way where `#` matches every remaining
    child) | `#/**sensor1**` | Invalid because # can only be at the end of the topic
    query |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 到处只有**sensor1**（一个更简单的方法，其中`#`匹配每个剩余的子级） | `#/**sensor1**` | 无效，因为#只能在主题查询的末尾
    |'
- en: '| Every topic | `#` | Matches everything |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 每个主题 | `#` | 匹配所有内容 |'
- en: '| Broker information | `$SYS/#` | This is a special reserved topic where the
    broker publishes information and runtime statistics. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 代理信息 | `$SYS/#` | 这是一个特殊的保留主题，代理在其中发布信息和运行时统计信息。 |'
- en: Table 1 - MQTT wildcard topic examples
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 表1 - MQTT通配符主题示例
- en: What may be evident from the preceding examples is that you need to take care
    when designing topic hierarchies for an application so that subscribing to multiple
    topics using wildcards is consistent, logical, and easy.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的示例中可以明显看出，您需要在设计应用程序的主题层次结构时小心，以便使用通配符订阅多个主题是一致的、逻辑的和简单的。
- en: If you are subscribing using the `+` or `#` wildcards with `mosquitto_sub`,
    remember to use the `-v` (--verbose) option so that the topic name is printed
    in the output, for example, `mosquitto_sub -h localhost -v -t '#'`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`mosquitto_sub`订阅使用`+`或`#`通配符，请记住使用`-v`（--verbose）选项，以便主题名称打印在输出中，例如`mosquitto_sub
    -h localhost -v -t '#'`。
- en: 'Try a few examples for yourself on the command line by mixing and matching
    the preceding topics and wildcards to get a feel for how topics and wildcards
    work. Following are the steps for one example where `mosquitto_sub` subscribes
    to all childtopics that have the parent *temperature* two levels down from the
    root topic:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行上尝试一些示例，通过混合和匹配前面的主题和通配符来感受主题和通配符的工作原理。以下是一个示例的步骤，其中`mosquitto_sub`订阅了所有从根主题下两级的父主题为*temperature*的子主题：
- en: 'In a Terminal, start a subscriber that subscribes to a wildcard topic:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个终端中，启动一个订阅通配符主题的订阅者：
- en: '[PRE11]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Using the topics from *Table 1 – MQTT wildcard topic examples,* here are two
    `mosquitto_pub` commands that will publish messages that will be received by the `mosquitto_sub`
    command in **Terminal #1**:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*表1 - MQTT通配符主题示例*中的主题，以下是两个`mosquitto_pub`命令，将发布的消息将被**终端#1**中的`mosquitto_sub`命令接收：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have just seen how to subscribe to topic hierarchies using the wildcard characters, `+`
    and `*`. Using topics and wildcards together is a design decision you'll need
    to make on a per-project level based on how your data needs to flow and how you
    envision it will be both published and subscribed by client applications. Time
    invested in designing a congruent yet flexible wildcard-based topic hierarchy
    will go a long way to helping you to build simpler and reusable client code and
    applications.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到如何使用通配符字符`+`和`*`订阅主题层次结构。使用主题和通配符一起是一个设计决策，您需要根据数据流动的需求以及您设想客户端应用程序发布和订阅的方式在每个项目级别上做出的。在设计一致而灵活的基于通配符的主题层次结构方面投入的时间将有助于帮助您构建更简单和可重用的客户端代码和应用程序。
- en: Next, we will learn all about message Quality of Service and how this impacts
    the messages you send through an MQTT Broker.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习有关消息服务质量的所有内容，以及这如何影响您通过MQTT Broker发送的消息。
- en: Applying Quality of Service to messages
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将服务质量应用于消息
- en: MQTT provides three **Quality of Service** (**QoS**) levels for *individual message delivery—*I
    am emphasizing *individual message delivery* because QoS levels apply to the delivery
    of individual messages and not to a topic. This will become clearer as you work
    through the examples.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT为*单个消息传递*提供了三个**服务质量**（**QoS**）级别 - 我强调*单个消息传递*，因为QoS级别适用于单个消息的传递，而不适用于主题。随着您逐步学习示例，这一点将变得更加清晰。
- en: 'While you, as the developer, stipulate the QoS for your messages, it''s the
    broker that is responsible for ensuring that the message delivery adheres to the
    QoS. Here is the QoS you can apply to a message and what they mean for delivery:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，您规定消息的QoS，而代理负责确保消息传递符合QoS。以下是您可以应用于消息的QoS以及它们对传递的含义：
- en: '| **QoS level** | **Meaning** | **Number of messages delivered** |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| **QoS级别** | **含义** | **传递的消息数量** |'
- en: '| Level 0 | The message will be delivered at most once, but maybe not at all.
    | 0 or 1 |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 级别0 | 该消息将被传递最多一次，但也可能根本不传递。 | 0或1 |'
- en: '| Level 1 | The message will be delivered at least once, but perhaps more.
    | 1 or more |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 级别1 | 该消息将至少传递一次，但可能更多。 | 1或更多 |'
- en: '| Level 2 | The message will be delivered exactly once. | 1 |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 级别2 | 该消息将被传递一次。 | 1 |'
- en: Table 2 – Message QoS levels
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 表2 - 消息QoS级别
- en: 'You might be asking the question: Level 0 and 1 seem a bit random, so why not
    just always use Level 2? The answer is *resources*. Let''s see why...'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会问：级别0和1似乎有点随机，那么为什么不总是使用级别2呢？答案是*资源*。让我们看看为什么...
- en: The broker and clients will consume more resources to process higher-level QoS
    messages than lower-level QoS messages—for example, the broker will need more
    time and memory to store and process messages, while both the broker and clients
    consume more time and network bandwidth with acknowledgment confirmations and
    connection handshaking.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 与较低级别的QoS消息相比，代理和客户端将消耗更多的资源来处理较高级别的QoS消息 - 例如，代理将需要更多的时间和内存来存储和处理消息，而代理和客户端在确认确认和连接握手时消耗更多的时间和网络带宽。
- en: For many use cases, including the examples that follow in this chapter, we will
    not notice a difference between QoS levels 1 and 2, nor will we be able to practically
    demonstrate them (Level 0 gets omitted for a good reason, which we'll see later
    on when we cover message retention and durable connections). However, set your
    mind to a distributed IoT system with thousands of sensors publishing thousands
    or more messages every minute, and now designing around QoS starts to make a little
    more sense.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多用例，包括本章后续的示例，我们将注意不到QoS级别1和2之间的区别，我们也无法实际演示它们（级别0由于一个很好的原因被省略，我们稍后将在消息保留和持久连接时看到）。然而，设想一个分布式物联网系统，其中成千上万的传感器每分钟发布成千上万条消息，现在围绕QoS设计开始变得更有意义。
- en: QoS levels apply to both message *subscriptions* and message *publishing,* which
    may seem odd when you first think it through. For example, a client may publish
    a message with a QoS of 1 to a topic, while another client may subscribe to that
    topic with a QoS of 2 (I know I said QoS relates to messages, not topics, but
    here it's the messages flowing *through* the topic that the QoS relates to). What
    QoS is this message, 1 or 2? For the subscriber, it's 1—let's find out why.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: QoS级别适用于消息订阅和消息发布，当你第一次思考时，这可能看起来有点奇怪。例如，一个客户端可以以QoS 1发布消息到一个主题，而另一个客户端可以以QoS
    2订阅该主题（我知道我说QoS与消息有关，而不是与主题有关，但在这里，它与通过主题流动的消息有关）。这条消息的QoS是1还是2？对于订阅者来说，是1——让我们找出原因。
- en: It's the *subscribing* client that chooses the *highest* QoS of messages it
    wants to receive—but it may get lower. So, effectively, this means the delivery
    QoS received by a client is downgraded to the lowest QoS of the publication or
    subscription.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅客户端选择它想要接收的消息的最高QoS，但可能会得到更低的QoS。因此，实际上，这意味着客户端接收的交付QoS被降级为发布或订阅的最低QoS。
- en: 'Here are a few examples for you to ponder:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些供您思考的示例：
- en: '| Publisher sends message | Subscriber subscribing at | What subscriber gets
    |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 发布者发送消息 | 订阅者订阅 | 订阅者获取的内容 |'
- en: '| --- | --- | --- |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| QoS 2 | QoS 0 | Delivery of message adhering to a QoS 0 (subscriber gets
    the message 0 or 1 time) |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| QoS 2 | QoS 0 | 传递符合QoS 0的消息（订阅者获取消息0次或1次）|'
- en: '| QoS 2 | QoS 2 | Delivery of message adhering to a QoS 2 (subscriber gets
    the message exactly once) |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| QoS 2 | QoS 2 | 传递符合QoS 2的消息（订阅者获取消息一次）|'
- en: '| QoS 0 | QoS 1 | Delivery of message adhering to QoS 0 (subscriber gets the
    message 0 or 1 time) |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| QoS 0 | QoS 1 | 传递符合QoS 0的消息（订阅者获取消息0次或1次）|'
- en: '| QoS 1 | QoS 2 | Delivery of message adhering to QoS 1 (subscriber gets the
    message 1 or more times) |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| QoS 1 | QoS 2 | 传递符合QoS 1的消息（订阅者获取消息1次或多次）|'
- en: '| QoS 2 | QoS 1 | Delivery of message adhering to QoS 1 (subscriber gets the
    message 1 or more times) |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| QoS 2 | QoS 1 | 传递符合QoS 1的消息（订阅者获取消息1次或多次）|'
- en: Table 3 – Publisher and subscriber QoS examples
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 表3 - 发布者和订阅者QoS示例
- en: The takeaway from these examples is that, in practice, when designing or integrating
    IoT solutions, you need to be aware of the QoS used by both publishers and subscribers
    on either side of a topic—QoS cannot be interpreted on either side in isolation.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些示例中可以得出的结论是，在实践中，设计或集成物联网解决方案时，您需要了解主题两侧的发布者和订阅者使用的QoS——QoS不能在任一侧单独解释。
- en: 'Following are the steps to play out QoS scenarios and see client-broker interactions
    in real time:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是播放QoS场景并实时查看客户端-代理交互的步骤：
- en: 'In a Terminal, run the following command to start a subscriber:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，运行以下命令启动订阅者：
- en: '[PRE13]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In a second Terminal, run the following command to publish a message:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二个终端中，运行以下命令发布消息：
- en: '[PRE14]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, we are again subscribing on **Terminal #1**, and publishing on **Terminal
    #2**. Here are the new options used with both `mosquitto_sub` and `mosquitto_pub`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次在**终端＃1**上订阅，并在**终端＃2**上发布。以下是与`mosquitto_sub`和`mosquitto_pub`一起使用的新选项：
- en: '`-d`: Turn on debugging messages'
  id: totrans-173
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d`：打开调试消息'
- en: '`-q <level>`: QoS level'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-q <level>`：QoS级别'
- en: With debugging enabled (`-d`), try changing the `-q` parameter (to 0, 1, or
    2) on either side and publishing new messages.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 启用调试（`-d`）后，尝试在任一侧更改`-q`参数（为0、1或2）并发布新消息。
- en: 'Observe the logged messages in **Terminal #1** and **Terminal #2**.'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察**终端＃1**和**终端＃2**中记录的消息。
- en: 'Among the debugging messages that will appear in **Terminal #1** and **Terminal
    #2**, you will obverse the QoS downgrade occurring at the subscription side (look
    for `q0`, `q1`, or `q2`) while, on both sides, you will also notice different
    debug messages depending on the QoS specified as the client and broker perform
    handshaking and exchange acknowledgments:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在**终端＃1**和**终端＃2**中将出现一些调试消息，您将观察到订阅端发生的QoS降级（寻找`q0`，`q1`或`q2`），而在双方，您还将注意到不同的调试消息，具体取决于客户端和代理执行握手和交换确认时指定的QoS：
- en: '[PRE15]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Following is the debug output for the subscriber on **Terminal #1**. Notice
    the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是**终端＃1**上订阅者的调试输出。请注意以下内容：
- en: 'At line (1), we subscribed using QoS 2 (`-q 2`). This is reflected in the debug
    output, `QoS: 2`, on line (2).'
  id: totrans-180
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第1行，我们使用QoS 2（`-q 2`）进行订阅。这在调试输出中反映为`QoS：2`，在第2行。
- en: 'On line (3), we see the QoS downgrade. The message received is QoS 1 (`q1`),
    which is the QoS that the message was published in **Terminal #1**.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第3行，我们看到了QoS的降级。接收到的消息是QoS 1（`q1`），这是消息在**终端＃1**中发布的QoS。
- en: QoS is one of the more complex MQTT concepts to grasp. You will find links in
    the *Further reading* section if you want to go deeper into QoS levels and the
    lower level communications that take place between publishers, subscribers, and
    the broker.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: QoS是较复杂的MQTT概念之一。如果您想更深入地了解QoS级别以及发布者、订阅者和代理之间进行的低级通信，您将在*进一步阅读*部分找到链接。
- en: Now that we have covered message QoS levels, we will next learn about two MQTT
    features that ensure offline clients can receive past messages when they come
    back online. We will also see how QoS levels impact these features.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了消息QoS级别，接下来我们将了解两个MQTT功能，确保离线客户端可以在重新上线时接收以前的消息。我们还将看到QoS级别如何影响这些功能。
- en: Retaining messages for later delivery
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保留消息以供以后传递
- en: 'An MQTT broker can be instructed to retain messages published to a topic. Message
    retention comes in two flavors, known as *retained messages* and *durable connections*:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT代理可以被指示保留发布到主题的消息。消息保留有两种类型，称为保留消息和持久连接：
- en: A **retained message** is where the broker retains the *last message* published
    on a topic. This is also commonly referred to as the *last known good message*,
    and any client subscribing to a topic automatically gets this message.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留消息是指代理保留在主题上发布的最后一条消息。这也通常被称为最后已知的好消息，任何订阅主题的客户端都会自动获取此消息。
- en: '**Durable connections** are also about retaining messages but in a different
    context. If a client tells the broker it wants a *durable connection*, then the
    broker retains QoS 1 and 2 messages for that client while it''s offline.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久连接**也涉及保留消息，但在不同的上下文中。如果客户端告诉代理它想要一个*持久连接*，那么代理将在客户端离线时保留QoS 1和2的消息。'
- en: Unless configured specifically, Mosquitto *does not* retain messages or connections
    across server restarts. To persist this information across a restart, a Mosquitto
    configuration file must contain the entry `persistence true`. A default installation
    of Mosquitto on a Raspberry Pi should include this entry, however, to be sure
    it has also been included in `mosquitto_pyiot.conf` that we installed earlier.
    Please consult the official Mosquitto documentation for more information and configuration
    parameters regarding persistence. You will find a link in the *Further reading*
    section at the end of the chapter.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 除非特别配置，Mosquitto *不会*在服务器重新启动时保留消息或连接。要在重新启动时保留此信息，Mosquitto配置文件必须包含条目`persistence
    true`。树莓派上Mosquitto的默认安装应该包括此条目，但是，为了确保它也包含在我们之前安装的`mosquitto_pyiot.conf`中。请参阅官方Mosquitto文档以获取有关持久性的更多信息和配置参数。您将在本章末尾的*进一步阅读*部分找到链接。
- en: Next, we will learn about retained messages and cover durable connections in
    the subsequent section.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习保留消息并在随后的部分中涵盖持久连接。
- en: Publishing a retained message
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发布保留消息
- en: A publisher can ask the broker to retain a message as the *last known good*
    message for a topic. Any newly connecting subscriber will immediately receive
    this last retained message.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 发布者可以要求代理保留一个消息作为主题的*最后已知的良好*消息。任何新连接的订阅者将立即收到这个最后保留的消息。
- en: 'Let''s step through an example to demonstrate retained messages:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来演示保留消息：
- en: 'Run the following, noting that we''re starting with **Terminal #2**, the publisher
    in this example:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令，注意我们从**终端#2**开始，这个示例中是发布者：
- en: '[PRE16]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A new option has been added,`-r` (--retain), to tell the broker that this message
    should be retained for the topic.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 已添加了一个新选项，`-r`（--retain），告诉代理应该为该主题保留此消息。
- en: Only a single retained message can exist for a topic. If you publish another
    message using the `-r` option, the previous retained message will be replaced.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一个主题只能存在一个保留的消息。如果使用`-r`选项发布另一条消息，则先前保留的消息将被替换。
- en: 'Start a subscriber in another Terminal, and immediately you will receive the
    retained message:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个终端中启动一个订阅者，然后立即您将收到保留的消息：
- en: '[PRE17]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Press *Ctrl* + *C* in **Terminal #1** to terminate `mosquitto_sub`.'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**终端#1**中按下*Ctrl* + *C*来终止`mosquitto_sub`。
- en: 'Start `mosquitto_sub` again using the same command from *step 2*, and you will
    see the retained message received again in **Terminal #1**.'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用与*步骤2*相同的命令启动`mosquitto_sub`，然后您将在**终端#1**中再次收到保留的消息。
- en: You can still publish normal messages (that is, *not* using the `-r` option),
    however, it's the last retained message indicated by the use of the `-r` option
    that newly connecting subscribers will receive.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您仍然可以发布普通消息（即*不*使用`-r`选项），但是，新连接的订阅者将接收到使用`-r`选项指示的最后保留的消息。
- en: 'Our final command shows how to clear a previously retained message:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的最后一个命令显示了如何清除先前保留的消息：
- en: '[PRE18]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we are publishing (with `-r`) an empty message with `-m ''`. Note that
    we can use `-n` as an alternative to `-m ''` to indicate an empty message. The
    effect of retaining an empty message is to actually clear the retained message.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在发布（使用`-r`）一个带有`-m ''`的空消息。请注意，我们可以使用`-n`作为`-m ''`的替代方法来指示空消息。保留空消息的效果实际上是清除保留的消息。
- en: When you send an empty message to a topic to remove a retained message, any
    clients currently subscribed to the topic (including offline clients with durable
    connections—see the next section) will receive the empty message, so your application
    code must test for and handle empty messages appropriately.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当您向主题发送空消息以删除保留的消息时，当前订阅该主题的任何客户端（包括具有持久连接的离线客户端-请参阅下一节）都将收到空消息，因此您的应用代码必须适当地测试和处理空消息。
- en: Now that you understand and know how to use retained messages, we can now explore
    the other type of message retention available with MQTT, called *durable connections*.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您了解并知道如何使用保留消息，我们现在可以探索MQTT中可用的另一种消息保留类型，称为*持久连接*。
- en: Creating durable connections
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建持久连接
- en: 'A client subscribing to a topic can ask the broker to retain, or queue, messages
    for it while it''s offline. This is known in MQTT terminology as a *durable connection*.
    For durable connections and delivery to work, the subscribing client needs to
    be configured and subscribe in a certain way, as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅主题的客户端可以要求代理在其离线时保留或排队消息。在MQTT术语中，这被称为*持久连接*。为了使持久连接和传递工作，订阅客户端需要以特定的方式进行配置和订阅，如下所示：
- en: The client *must* *provide* a unique client ID to the broker when it connects.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当客户端连接时，*必须*向代理提供唯一的客户端ID。
- en: The client *must subscribe* with a QoS 1 or 2 (levels 1 and 2 guarantee delivery,
    but level 0 does not).
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端*必须*使用QoS 1或2（级别1和2保证传递，但级别0不保证）进行订阅。
- en: The client is only guaranteed to get messages *published* with QoS 1 or 2.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端只有在使用QoS 1或2进行发布的消息时才能得到保证。
- en: The last two points concern an example where knowing QoS on both the publishing
    and subscribing sides of a topic is very important for IoT application design.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两点涉及了一个示例，其中了解主题的发布和订阅双方的QoS对于物联网应用程序设计非常重要。
- en: MQTT brokers can—and the default configuration of Mosquitto on the Raspberry
    Pi does—retain messages for durable connections between broker restarts.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT代理可以在代理重新启动时保留消息，树莓派上Mosquitto的默认配置也可以这样做。
- en: 'Let''s step through an example:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来演示：
- en: 'Start a subscriber, and then immediately terminate it with *Ctrl* + *C* so
    that it is offline:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动订阅者，然后立即使用*Ctrl* + *C*终止它，使其处于离线状态：
- en: '[PRE19]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The new options used are as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的新选项如下：
- en: '`-i <client id>` (–id <client id>) is a unique client ID (this is how the broker
    identifies the client).'
  id: totrans-218
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-i <client id>`（-id <client id>）是一个唯一的客户端ID（这是代理识别客户端的方式）。'
- en: '`-c` (--disable-clean-session) instructs the broker to keep any QoS 1 and 2
    messages that arrive at subscribed topics even while the client is disconnected
    (that is, *retain* the messages).'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-c`（--disable-clean-session）指示代理保留订阅主题上到达的任何QoS 1和2消息，即使客户端断开连接（即*保留*消息）。'
- en: It's worded a bit backward, but by starting the subscriber with the `-c` option,
    we've asked the broker to create a *durable connection* for our client by not
    clearing out any stored messages on connecting.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 措辞有点反向，但通过使用`-c`选项启动订阅者，我们已要求代理通过在连接时不清除任何存储的消息来为我们的客户端创建一个*持久连接*。
- en: If you subscribe to a range of topics using wildcards (for example, `pyiot/#`)
    and request a durable connection, then all messages for all topics in the wildcard
    hierarchy will be retained for your client.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用通配符订阅一系列主题（例如，`pyiot/#`），并请求持久连接，那么通配符层次结构中所有主题的所有消息都将保留给您的客户端。
- en: 'Publish a few messages (while the subscriber in **Terminal #1** is still offline):'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布一些消息（当**终端#1**中的订阅者仍然离线时）：
- en: '[PRE20]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Bring the subscriber in **Terminal #1** back online, and we will see that the
    messages published in *step 2* are delivered:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**终端#1**中的订阅者重新连接，我们将看到在*步骤2*中发布的消息被传送：
- en: '[PRE21]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Try *steps 1* to *3* again, only this time omit the `-c` option from the subscriber
    in *steps 1* and *3* and you will notice that no messages are retained. Also,
    when you connect *without* the `-c` flag when there are retained messages waiting
    to be delivered, then all retained messages are purged (and is how you would clear
    retained messages for a client if you wanted to).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 再次尝试*步骤1*至*3*，只是这次在*步骤1*和*3*中的订阅者中省略`-c`选项，您会注意到没有消息被保留。此外，当您在有保留消息等待传送时*不使用*`-c`标志连接时，那么所有保留消息都将被清除（这是您想要清除客户端的保留消息的方法）。
- en: If you are using both *retained messages* (that is, last known good message)
    and *durable connections* together on a single topic and reconnect an offline
    subscriber, you will *receive the retained message twice—*one is the *retained
    message,* while the second is from the *durable connection*.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在单个主题上同时使用*保留消息*（即最后已知的良好消息）和*持久连接*，并重新连接离线订阅者，您将*收到保留消息两次*—一次是*保留消息*，而第二次是来自*持久连接*的消息。
- en: When building solutions around MQTT, your knowledge of retained messages and
    durable connections will be key to designing systems that are resilient and reliable,
    particularly where you need to handle offline clients. Retained (last known good)
    messages are ideal for initializing a client when they come back online, while durable
    connections will help you to retain and deliver messages in bulk for any offline
    client that must be able to consume every message for topics that it subscribes
    to.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在围绕MQTT构建解决方案时，您对保留消息和持久连接的了解将对设计具有弹性和可靠性的系统至关重要，特别是在需要处理离线客户端的情况下。保留（最后已知的良好）消息非常适合在客户端重新上线时初始化客户端，而持久连接将帮助您为任何必须能够消费其订阅的每条消息的离线客户端保留和传送消息。
- en: Well done! We have covered a lot and you actually now know most of the core
    MQTT features you will use when building an MQTT-based IoT solution. Our last
    feature to learn about is known as a *Will*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！我们已经涵盖了很多内容，实际上您现在已经了解了构建基于MQTT的物联网解决方案时将使用的大多数核心MQTT功能。我们要了解的最后一个功能是称为*Will*。
- en: Saying goodbye with a Will
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用Will说再见
- en: Our final MQTT feature for exploration is known as a Will. A client (publisher
    or subscriber) can register a special *Will* message with the broker so that if
    the client dies and disconnects from the broker abruptly (for example, it loses
    its network connection or its batteries go flat), the broker on the clients' behalf
    will send out the *Will* message notifying subscribers of the device's demise.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探索的最后一个MQTT功能是称为Will。客户端（发布者或订阅者）可以向代理注册一个特殊的*Will*消息，以便如果客户端死机并突然断开与代理的连接（例如，它失去了网络连接或其电池耗尽），代理将代表客户端发送*Will*消息，通知订阅者设备的消亡。
- en: Wills are just a message and topic combination similar to what we have been
    using previously.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Will只是一个消息和主题组合，类似于我们之前使用的。
- en: 'Let''s see Wills in action, and for this, we''re going to need three Terminals:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Will的作用，为此，我们将需要三个终端：
- en: 'Open a Terminal and start a subscriber with the following command:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个终端，并使用以下命令启动一个订阅者：
- en: '[PRE22]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The new options are as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 新的选项如下：
- en: '`--will-payload`: This is the Will message.'
  id: totrans-237
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--will-payload`：这是Will消息。'
- en: '`--will-topic`: This is the topic the Will message will be published on. Here
    we are using the same topic that we are subscribing to, but it could be a different
    topic.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--will-topic`：这是Will消息将要发布的主题。在这里，我们使用与我们订阅的相同主题，但也可以是不同的主题。'
- en: '`--will-qos`: This is the QoS for the Will message.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--will-qos`：这是Will消息的QoS。'
- en: '`--will-retain`: If this option is present, then if the client disconnects
    abruptly, the Will message will be retained by the broker as the *retained (last
    known good) message* for the Will topic.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--will-retain`：如果存在此选项，那么如果客户端突然断开连接，Will消息将被代理保留为Will主题的*保留（最后已知的良好）消息*。'
- en: 'Start a subscriber in a second Terminal with the following command:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在第二个终端中启动一个订阅者：
- en: '[PRE23]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And in a third Terminal, publish a message using the following command:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第三个终端中，使用以下命令发布一条消息：
- en: '[PRE24]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once you execute the `mosquitto_pub` command in *step 3* on **Terminal #3**,
    you should see `hello` printed on *both* the subscribers in **Terminals #1** and
    **#2**.'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦在**终端#3**上执行*步骤3*中的`mosquitto_pub`命令，您应该会在**终端#1**和**#2**上都看到`hello`被打印出来。
- en: 'In **Terminal #1**, press *Ctrl* + *C* to terminate the subscriber that registered
    the Will with the broker. *Ctrl* + *C* is seen as a non-graceful or abrupt disconnection
    from the broker.'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**终端#1**中，按下*Ctrl* + *C*来终止向代理注册Will的订阅者。*Ctrl* + *C*被视为与代理的非优雅或突然断开连接。
- en: 'In **Terminal #2**, we will see the Will''s `Good Bye` message:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**终端#2**中，我们将看到遗嘱的“再见”消息：
- en: '[PRE25]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Okay, what about a graceful disconnection where the subscriber properly closes
    its connection with the broker? We can demonstrate this using the `-C` option
    with `mosquitto_sub`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么优雅地断开连接呢，订阅者如何正确地关闭与代理的连接？我们可以使用`mosquitto_sub`的`-C`选项来演示这一点。
- en: 'Restart the subscriber in **Terminal #1** with the following command:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令重新启动**终端#1**中的订阅者：
- en: '[PRE26]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The new `-C <count>` option tells `mosquitto_sub` to disconnect (gracefully)
    and exit after it has received the specified number of messages.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`-C <count>`选项告诉`mosquitto_sub`在接收到指定数量的消息后断开（优雅地）并退出。
- en: 'You will notice the `Good Bye` message printed immediately. This is because
    we specified the `--retain-will` option previously in **Terminal #1**. This option
    made the Will message become the retained or last known good message for the topic,
    so newly connecting clients will receive this message.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 您会立即注意到打印的“再见”消息。这是因为我们之前在**终端#1**中指定了`--retain-will`选项。此选项使遗嘱消息成为主题的保留或最后已知的好消息，因此新连接的客户端将接收此消息。
- en: 'In **Terminal #3**, publish a new message, and the subscriber in **Terminal
    #1** will exit. Notice in **Terminal #3** that the Will message, `Good Bye, Again`,
    is *not* received. This is because our **Terminal #1** subscriber disconnected
    *gracefully* from the broker because of the `-C` option—and in case you are wondering
    about `2` in  `-C 2`, the retained Will message counted as the first message.'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**终端#3**中，发布一条新消息，**终端#1**中的订阅者将退出。请注意，在**终端#3**中，不会收到遗嘱消息“再见，再见”。这是因为我们的**终端#1**订阅者因为`-C`选项而优雅地与代理断开连接，并且如果您想知道`-C
    2`中的`2`，则保留的遗嘱消息被计为第一条消息。
- en: Well done! If you have worked your way through each of the preceding MQTT examples,
    then you have covered the core concepts and use of MQTT and the Mosquitto broker.
    Do remember that all of these principles will apply to any MQTT broker or client
    since MQTT is an open standard.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！如果您已经完成了前面的每个MQTT示例，那么您已经涵盖了MQTT和Mosquitto代理的核心概念和用法。请记住，所有这些原则都适用于任何MQTT代理或客户端，因为MQTT是一个开放标准。
- en: So far, we've learned about message subscriptions and publication, how we segregate messages
    using topics, and how features including QoS, message retention, durable connections,
    and Wills can be leveraged to control how messages are managed and delivered.
    This knowledge alone provides you with the foundations to build complex and resilient
    distributed IoT systems using MQTT.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了消息订阅和发布，以及如何使用主题对消息进行分离，以及如何利用QoS、消息保留、持久连接和遗嘱来控制消息的管理和传递。单单这些知识就为您提供了构建复杂和有弹性的分布式物联网系统的基础，使用MQTT。
- en: I'll leave you with one final tip (which caught me out a few times when I started
    with MQTT).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我将给您留下一个最后的提示（当我开始使用MQTT时，这个提示几次让我困惑）。
- en: If your live, retained, or queued durable connection messages seem to be vanishing
    into a black hole, then check the QoS levels on both your subscribing and publishing
    clients. To monitor all messages, start a command-line subscriber with QoS 2,
    listening to the `#` topic, with both verbose and debug options enabled, for example, `mosquitto_sub
    -q 2 -v -d -h localhost -t '#'`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的实时、保留或排队的持久连接消息似乎消失在黑洞中，请检查订阅和发布客户端的QoS级别。要监视所有消息，请启动一个命令行订阅者，使用QoS 2，监听`#`主题，并启用详细和调试选项，例如`mosquitto_sub
    -q 2 -v -d -h localhost -t '#'`。
- en: We have now completed all of our examples from the MQTT-by-example section and
    learned how to interact with an MQTT broker from the command line. Next, I want
    to briefly make mention of public broker services. Following this, we'll get into
    code and see how we can leverage MQTT with Python.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了MQTT示例部分的所有示例，并学会了如何从命令行与MQTT代理进行交互。接下来，我想简要提一下公共代理服务。之后，我们将进入代码，看看如何利用Python与MQTT。
- en: Using MQTT broker services
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用MQTT代理服务
- en: There are several MQTT broker service providers on the internet that you can
    use to create MQTT-based messaging applications if you do not want to host your
    own MQTT broker. Many also offer free public MQTT brokers that you can use for
    testing and quick proofs-of-concept—but remember they are free and public, so
    do not publish any sensitive information!
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上有几家MQTT代理服务提供商，您可以使用它们创建基于MQTT的消息传递应用程序，如果您不想托管自己的MQTT代理。许多还提供免费的公共MQTT代理，供您用于测试和快速概念验证，但请记住它们是免费和公共的，因此不要发布任何敏感信息！
- en: If you experience frustration, disconnections, or unexpected behavior with a
    free public broker service, then test and verify your application with a local
    broker. You cannot reliably know or verify the traffic congestion, topic usage,
    or configuration details of an open public broker and how that may be impacting
    your application.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在使用免费公共代理服务时遇到挫折、断开连接或意外行为，请使用本地代理测试和验证您的应用程序。您无法可靠地了解或验证开放公共代理的流量拥塞、主题使用或配置细节以及这可能如何影响您的应用程序。
- en: 'Here are a few free public brokers you can try. Just replace the `-h`*localhost* option
    in the preceding examples with the address of the broker. Visit the following
    pages for more information and instructions:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些免费的公共代理，您可以尝试。只需将前面示例中的`-h`*localhost*选项替换为代理的地址。访问以下页面以获取更多信息和说明：
- en: '[https://test.mosquitto.org](https://test.mosquitto.org/)'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://test.mosquitto.org](https://test.mosquitto.org/)'
- en: '[http://broker.mqtt-dashboard.com](http://broker.mqtt-dashboard.com/)'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://broker.mqtt-dashboard.com](http://broker.mqtt-dashboard.com/)'
- en: '[https://ot.eclipse.org/getting-started](https://iot.eclipse.org/getting-started/#sandboxes)'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://ot.eclipse.org/getting-started](https://iot.eclipse.org/getting-started/#sandboxes)'
- en: In the following sections, we will move a level higher. Finally, we're up to
    the Python bit of MQTT! Rest assured that everything we just covered will be invaluable
    when you develop IoT applications that use MQTT because the command-line tools
    and examples we covered will become an important part of your MQTT development
    and debugging toolkit. We will be applying the core MQTT concepts we have learned
    already, only this time using Python and the Paho-MQTT client library.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将提升一个级别。最后，我们将进入MQTT的Python部分！请放心，我们刚刚讨论的一切在您开发使用MQTT的物联网应用程序时将非常宝贵，因为我们讨论的命令行工具和示例将成为您的MQTT开发和调试工具包的重要组成部分。我们将应用我们已经学到的核心MQTT概念，只是这次使用Python和Paho-MQTT客户端库。
- en: Introducing the Python Paho-MQTT client library
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Python Paho-MQTT客户端库
- en: Before we get into Python code, we first need an MQTT client library for Python.
    At the start of this chapter in the *Technical requirements* section, we installed
    the Paho-MQTT client library, which was part of `requirements.txt`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入Python代码之前，我们首先需要一个Python的MQTT客户端库。在本章的*技术要求*部分开始时，我们安装了Paho-MQTT客户端库，它是`requirements.txt`的一部分。
- en: If you are new to MQTT and have not read the preceding section, *Learning MQTT
    by example*, I recommend stopping now and reading it first so you gain an understanding
    of MQTT concepts and terminology that will be used in the Python examples that
    follow.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是MQTT的新手，并且还没有阅读前面的*通过示例学习MQTT*部分，我建议现在停下来先阅读它，以便您对接下来的Python示例中将使用的MQTT概念和术语有所了解。
- en: The Paho-MQTT client library comes from the Eclipse Foundation, which also maintains
    the Mosquitto MQTT broker. In the *Further reading* section, you will find a link
    to the official *Paho-MQTT Client Library API* documentation. After completing
    this chapter, if you wish to deepen your understanding of this library and its
    capabilities, I recommend reading through the official documentation and the examples
    found therein.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Paho-MQTT客户端库来自Eclipse基金会，该基金会还维护Mosquitto MQTT代理。在*进一步阅读*部分，您将找到指向官方*Paho-MQTT客户端库API*文档的链接。在完成本章后，如果您希望加深对该库及其功能的理解，我建议阅读官方文档和其中的示例。
- en: 'The Python Paho-MQTT library has three core modules:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Python Paho-MQTT库有三个核心模块：
- en: '**Client**: This gives you full life cycle management of MQTT in your Python
    application.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：这为您在Python应用程序中完全管理MQTT的生命周期。'
- en: '**Publisher**: This is a helper module for message publishing.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布者**：这是一个用于消息发布的辅助模块。'
- en: '**Subscriber**: This is a helper module for message subscribing.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订阅者**：这是一个用于消息订阅的辅助模块。'
- en: The client module is ideal if you are creating more complex and long-running
    IoT applications, whereas the publisher and subscriber helper modules are convenient
    for short-lived applications and situations where full life cycle management is
    not warranted.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端模块非常适合创建更复杂和长时间运行的物联网应用程序，而发布者和订阅者辅助模块适用于短暂的应用程序和不需要完全生命周期管理的情况。
- en: The following Python examples will connect to your local Mosquitto MQTT broker
    that we installed in the *Installing the Mosquitto MQTT broker* section previously.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Python示例将连接到我们之前在*安装Mosquitto MQTT代理*部分安装的本地Mosquitto MQTT代理。
- en: We will be using the Paho client module so we can create a more complete MQTT
    example. However, once you can follow and understand the client module, creating
    alternatives using the helper modules will be a piece of cake.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Paho客户端模块，以便我们可以创建一个更完整的MQTT示例。然而，一旦您能够理解并跟随客户端模块，使用辅助模块创建替代方案将变得轻而易举。
- en: As a reminder, we will be working with the breadboard circuit we created in
    [Chapter 2](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml)*, Getting Started with
    Python and IoT*, *Figure 2.7*.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，我们将使用我们在[第2章](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml)*Python和物联网入门*，*图2.7*中创建的面包板电路。
- en: Now that we have a basic familiarity with the Paho-MQTT library, we will next start
    by briefly reviewing what the Python program and the accompanying web page client
    do and see Paho-MQTT in action.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对Paho-MQTT库有了基本的了解，接下来我们将简要回顾Python程序和配套的网页客户端的功能，并看到Paho-MQTT的实际应用。
- en: Controlling an LED with Python and MQTT
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python和MQTT控制LED
- en: Previously, in the *Installing the Mosquitto MQTT broker* section, we tested
    the installation by visiting the `http://localhost:8083` URL, which gave us a
    web page with a slider. However, at the time, we could not change the LED's brightness.
    When you moved the slider, the web page was publishing MQTT messages to the Mosquitto
    broker, but no program was receiving the messages to change the LED's brightness.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在*安装Mosquitto MQTT代理*部分中，我们通过访问`http://localhost:8083` URL来测试安装，这给了我们一个带有滑块的网页。然而，当时我们无法改变LED的亮度。当您移动滑块时，网页会向Mosquitto代理发布MQTT消息，但没有程序接收消息来改变LED的亮度。
- en: In this section, we'll see the Python code that subscribes to a topic called
    `led` and processes the messages generated by the slider. We will start by running
    the Python code and making sure we can change the LED's brightness.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到Python代码订阅名为`led`的主题并处理滑块生成的消息。我们将首先运行Python代码，并确保我们可以改变LED的亮度。
- en: Running the LED MQTT example
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行LED MQTT示例
- en: 'You will find the code in the `chapter04/mqtt_led.py` file. Please review this
    file before proceeding to get an overall idea of what it contains and then follow
    these steps:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在`chapter04/mqtt_led.py`文件中找到代码。在继续之前，请先查看此文件，以便对其内容有一个整体的了解，然后按照以下步骤操作：
- en: 'Run the program in a Terminal with the following command:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在终端中运行程序：
- en: '[PRE27]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, open a second Terminal window and try the following, and the LED should
    turn on (be careful to make sure the JSON string is formed correctly):'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开第二个终端窗口并尝试以下操作，LED应该会亮起（请确保JSON字符串格式正确）：
- en: '[PRE28]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Did you notice the `-r` (`--retain`) option used in *step 2*? Terminate and
    restart `mqtt_led.py` and watch the log output in **Terminal #1** and the LED.
    You should notice on startup that `mqtt_led.py` receives the LED''s brightness
    value from the topic''s *retained message* and initializes the LED''s brightness
    accordingly.'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您是否注意到在*步骤2*中使用了`-r`(`--retain`)选项？终止并重新启动`mqtt_led.py`，并观察**终端#1**中的日志输出和LED。您应该注意到在启动时，`mqtt_led.py`从主题的*保留消息*接收LED的亮度值，并相应地初始化LED的亮度。
- en: Next, visit the `http://localhost:8083` URL and make sure the LED changes its
    brightness as you move the slider.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，访问`http://localhost:8083`的URL，并确保LED在您移动滑块时改变亮度。
- en: Leave the web page open, and try the command in *step 2* again. Observe what
    happens to the slider—it will stay in sync with the new level value you specified.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 保持网页打开，并再次尝试*步骤2*中的命令。观察滑块的变化——它将与您指定的新级别值保持同步。
- en: 'Next, let''s see durable connections in action. Terminate `mqtt_led.py` again
    and perform the following:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们看看持久连接是如何工作的。再次终止`mqtt_led.py`并执行以下操作：
- en: On the web page, move the slider around randomly for about 5 seconds. As you
    move the slider, messages are being published to the broker on the `led` topic.
    They will be queued for delivery to `mqtt_led.py` when it reconnects.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网页上，随机移动滑块大约5秒钟。当您移动滑块时，消息将被发布到`led`主题的代理中。当`mqtt_led.py`重新连接时，它们将被排队等待传递。
- en: Restart `mqtt_led.py` and observe the Terminal and LED. You will notice a flood
    of messages on the Terminal, and the LED will flicker as the queued messages are
    delivered and processed by `mqtt_led.py`.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新启动`mqtt_led.py`并观察终端和LED。您会注意到终端上有大量的消息，并且LED会闪烁，因为排队的消息被`mqtt_led.py`接收和处理。
- en: By default, Mosquitto is configured to queue 100 messages per client that are
    using a durable connection. A client is identified by its client ID that you provide
    when connecting to the broker.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Mosquitto配置为每个使用持久连接的客户端排队100条消息。客户端由其客户端ID标识，您在连接到代理时提供该ID。
- en: Now that we have interacted with and seen `mqtt_led.py` in action, let's take
    a look at its code.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经与`mqtt_led.py`进行了交互并看到它的运行情况，让我们来看看它的代码。
- en: Understanding the code
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解代码
- en: As we discuss the code found in `chapter04/mqtt_led.py`, pay particular attention
    to how the code connects to the MQTT broker and manages the connection life cycle.
    Furthermore, as we cover how the code receives and processes messages, try to
    relate the code workflow back to the command-line examples that we used to publish
    the message in the previous subsection, *Running the LED MQTT example*.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论在`chapter04/mqtt_led.py`中找到的代码时，特别注意代码如何连接到MQTT代理并管理连接生命周期。此外，当我们讨论代码如何接收和处理消息时，试着将代码工作流程与我们在上一小节中用于发布消息的命令行示例联系起来。
- en: Once you have an understanding of our Python code and how it integrates with
    our MQTT broker, you'll have an end-to-end working reference solution built around
    MQTT messaging that you can adapt for your own needs and projects.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您了解了我们的Python代码以及它如何与我们的MQTT代理集成，您将拥有一个端到端的工作参考解决方案，围绕MQTT消息构建，您可以根据自己的需求和项目进行调整。
- en: We will start by looking at the imports. As usual, we will skip over any common
    code that we have already covered in previous chapters, including logging setup
    and **GPIOZero**-related code.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从导入开始。通常情况下，我们将跳过我们在之前章节中已经涵盖过的任何常见代码，包括日志设置和**GPIOZero**相关的代码。
- en: Imports
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入
- en: 'The only new import we have in this example is for the Paho-MQTT client:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个例子中唯一新的导入是Paho-MQTT客户端：
- en: '[PRE29]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: At line (1), we are importing the Paho-MQTT `client` class and giving it the
    alias, `mqtt`. As mentioned previously, this is the client class that will allow
    us to create a full life cycle MQTT client in Python.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1行，我们导入Paho-MQTT `client`类，并给它起了别名`mqtt`。如前所述，这是一个客户端类，它将允许我们在Python中创建一个完整的生命周期MQTT客户端。
- en: Next, we will consider global variables.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将考虑全局变量。
- en: Global variables
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局变量
- en: 'The `BROKER_HOST` and `BROKER_POST` variables at line (2) are referring to
    our locally installed Mosquitto MQTT broker. Port `1883` is the standard default
    MQTT port:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2行的`BROKER_HOST`和`BROKER_POST`变量是指我们本地安装的Mosquitto MQTT代理。端口`1883`是标准默认的MQTT端口：
- en: '[PRE30]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: At line (3), we define `CLIENT_ID`, which will be the unique client identifier
    we use to identify our program with the Mosquitto MQTT broker. We *must* provide
    a unique ID to the broker so that we can use *durable connections*.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3行，我们定义了`CLIENT_ID`，这将是我们用来标识我们的程序与Mosquitto MQTT代理连接的唯一客户端标识符。我们*必须*向代理提供一个唯一的ID，以便我们可以使用*持久连接*。
- en: At line (4), we define the MQTT topic that our program will be subscribing to,
    while at line (5), the `client` variable is a placeholder that will be assigned
    the Paho-MQTT client instance, which we'll see shortly.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4行，我们定义了我们的程序将订阅的MQTT主题，而在第5行，`client`变量是一个占位符，将被分配Paho-MQTT客户端实例，我们很快就会看到。
- en: The set_led_level(data) method
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: set_led_level(data)方法
- en: '`set_led_level(data)` at line (6) is where we integrate with GPIOZero to change
    the brightness of our LED and the method similar to the corresponding methods
    we covered in [Ch](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml)[apter](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml) [3](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml),
    *Networking with RESTful APIs and Web Sockets Using Flask*, so we will not cover
    the internals here again:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_led_level(data)`在第6行是我们与GPIOZero集成以改变LED亮度的地方，方法类似于我们在[第3章](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml)中涵盖的相应方法，*使用Flask进行RESTful
    API和Web套接字的网络*，因此我们不会再次在这里涵盖内部情况：'
- en: '[PRE31]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The data parameter is expected to be a Python dictionary in the form of `{
    "level": 50 }`, where the integer is between 0 and 100 to indicate the brightness
    percentage.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '数据参数预期是一个Python字典，格式为`{ "level": 50 }`，其中整数介于0和100之间，表示亮度百分比。'
- en: Next, we have the callback functions for MQTT. We'll start by reviewing `on_connect()` and
    `on_disconnect()`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有MQTT的回调函数。我们将从审查`on_connect()`和`on_disconnect()`开始。
- en: The on_connect() and on_disconnect() MQTT callback methods
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: on_connect()和on_disconnect() MQTT回调方法
- en: The `on_connect()` and `on_disconnect()` callback handlers are examples of the
    full life cycle that is available using the Paho `client` class. We will see how
    to instantiate a Paho `client` instance and register these callbacks later when
    we cover the `init_mqtt()` method.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`on_connect()`和`on_disconnect()`回调处理程序是使用Paho `client`类提供的完整生命周期的示例。我们将在覆盖`init_mqtt()`方法时看到如何实例化Paho
    `client`实例并注册这些回调。'
- en: The parameters of interest to `on_connect()` at line (7) in the following code
    block are `client`, which is a reference to the Paho `client` class, and `result_code`,
    which is an integer describing the connection result. We see `result_code` used
    at line (8) to test the success of the connection. Notice the `connack_string()` method,
    which is used for a connection failure to translate `result_code` into a human-readable
    string.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码块的第7行，`on_connect()`感兴趣的参数是`client`，它是对Paho `client`类的引用，以及`result_code`，它是描述连接结果的整数。我们在第8行看到`result_code`用于测试连接的成功。注意`connack_string()`方法，它用于连接失败时将`result_code`转换为可读的字符串。
- en: When we speak of the MQTT *client* and see the `client` parameter at line (7)
    in the following code block, remember this is our Python code's client connection *to
    the broker*, NOT a reference to a client program such as the web page. This client
    parameter is very different in meaning to the client parameter we saw used in
    callback handlers for our Flask-SocketIO Web Socket server in *[Chapter 3](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml),
    Networking with RESTful APIs and Web Sockets Using Flask*.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论MQTT *client*并在以下代码块的第7行看到`client`参数时，请记住这是我们Python代码的客户端连接*到代理*，而不是指客户端程序，比如网页。这个客户端参数在意义上与我们在*[第3章](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml)中为Flask-SocketIO
    Web Socket服务器使用回调处理程序时看到的客户端参数非常不同。
- en: 'For reference, the `user_data` parameter can be used to pass around private
    data between a Paho client''s callback methods, while `flags` is a Python dictionary
    containing response and configuration hints from the MQTT broker:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 供参考，`user_data`参数可用于在Paho客户端的回调方法之间传递私有数据，而`flags`是一个包含MQTT代理的响应和配置提示的Python字典：
- en: '[PRE32]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: At line (9), we see the Paho `client` instance method, `subscribe()`, used to
    subscribe to the `led` topic using the `TOPIC` global variable, which we saw defined
    earlier. We also indicate to the broker that our subscription is a QoS level 2.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在第9行，我们看到Paho `client`实例方法`subscribe()`，用于使用我们之前定义的全局变量`TOPIC`订阅`led`主题。我们还告诉代理我们的订阅是QoS级别2。
- en: Always subscribe to topics in an `on_connect()` handler. This way, if the client
    ever loses the connection to the broker, it can re-establish subscriptions when
    it reconnects.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 总是在`on_connect()`处理程序中订阅主题。这样，如果客户端失去与代理的连接，它可以在重新连接时重新建立订阅。
- en: 'Next, at line (10) in the following, we have the `on_disconnect()` handler,
    where we are simply logging any disconnects. The method parameters have the same
    meanings as for the `on_connect()` handler:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在以下的第10行，我们有`on_disconnect()`处理程序，我们只是记录任何断开连接。方法参数的含义与`on_connect()`处理程序相同：
- en: '[PRE33]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We will now move on to the callback method that handles incoming messages for
    the `led` topic that we subscribed to in `on_connect()` on line (9).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将转到处理我们在`on_connect()`中订阅的`led`主题的回调方法，位于第9行。
- en: The on_message() MQTT callback method
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: on_message() MQTT回调方法
- en: It's the `on_message()` handler at line (11) that is called whenever a new message
    for a subscribed topic is received by our program. The message is available through
    the `msg` parameter, which is an instance of `MQTTMessage`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在第11行的`on_message()`处理程序在我们的程序接收到订阅主题的新消息时被调用。消息通过`msg`参数可用，它是`MQTTMessage`的一个实例。
- en: 'At line (12), we access the `payload` property of `msg` and decode it into
    a string. We expect our data to be a JSON string (for example, `{ "level": 100
    }`), so we parse the string into a Python dictionary using `json.loads()` and
    assign the result to `data`. If the message payload is not valid JSON, we catch
    the exception and log an error:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '在第12行，我们访问`msg`的`payload`属性并将其解码为字符串。我们期望我们的数据是一个JSON字符串（例如，`{ "level": 100
    }`），所以我们使用`json.loads()`将字符串解析为Python字典，并将结果赋给`data`。如果消息负载不是有效的JSON，我们捕获异常并记录错误：'
- en: '[PRE34]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Using the `topic` property of `msg` on line (13), we check that it matches our
    expected `led` topic, which it will in our case since our program is only subscribing
    to this specific topic. However, this provides a point of reference regarding
    where and how you would perform conditional logic and routing for a program that
    subscribes to multiple topics.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在第13行使用`msg`的`topic`属性，我们检查它是否与我们预期的`led`主题匹配，在我们的情况下，它会匹配，因为我们的程序只订阅这个特定的主题。然而，这提供了一个参考点，关于在订阅多个主题的程序中执行条件逻辑和路由的位置和方式。
- en: Finally, at line (14), we pass our parsed message to the `set_led_level()` method,
    which, as discussed, changes the brightness of our LED.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第14行，我们将解析的消息传递给`set_led_level()`方法，正如讨论的那样，这会改变LED的亮度。
- en: Next, we will learn how the Paho client is created and configured.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何创建和配置Paho客户端。
- en: The init_mqtt() method
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: init_mqtt()方法
- en: We see the Paho-MQTT `client` instance created and assigned to the global `client`
    variable at line (15). A reference to this object is the  `client` parameter we
    saw previously in the `on_connect()`, `on_disconnect()`, and `on_message()` methods.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第15行看到Paho-MQTT `client`实例被创建并分配给全局`client`变量。这个对象的引用是`client`参数，我们之前在`on_connect()`、`on_disconnect()`和`on_message()`方法中看到过。
- en: 'The `client_id` parameter is set to be the client name we defined earlier in
    `CLIENT_ID`, while `clean_session=False` tells the broker that it *must not clear*
    any stored messages for our client when we connect. As we discussed earlier in
    the command-line examples, this is the back-to-front way of saying we want a durable
    connection so any messages published to the `led` topic are stored for our client
    when it''s offline:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`client_id`参数设置为我们之前在`CLIENT_ID`中定义的客户端名称，而`clean_session=False`告诉代理在连接时*不要清除*我们的客户端的任何存储消息。正如我们在命令行示例中讨论的那样，这是说我们希望建立持久连接，因此当我们的客户端离线时，发布到`led`主题的任何消息都会为我们的客户端存储。'
- en: '[PRE35]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: An important point to note is on line (16). Our program is using the standard
    Python logging packages, so we need to make this call to `client.enable_logger()` to
    ensure that we get any Paho-MQTT client log message. Missing this call means helpful
    diagnostic information may not get logged.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一个重要点是在第16行。我们的程序使用标准的Python日志包，因此我们需要调用`client.enable_logger()`来确保我们获得任何Paho-MQTT客户端日志消息。如果缺少这个调用，可能会导致有用的诊断信息未被记录。
- en: Finally, at line (18), we connect to the Mosquitto MQTT broker. It's our `on_connect()`
    handler that will be called once the connection is established.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第18行，我们连接到Mosquitto MQTT代理。一旦连接建立，就会调用我们的`on_connect()`处理程序。
- en: Next, we will see how our program is started.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到我们的程序是如何启动的。
- en: Main entry point
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主入口点
- en: After initializing our LED and client instances, we get to the program's main
    entry point.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化LED和客户端实例之后，我们进入了程序的主入口点。
- en: 'We are registering a signal handler to capture *Ctrl* + *C* key combinations
    at line (19). The `signal_handler` method (not shown) simply turns off our LED
    and gracefully disconnects from the broker:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第19行注册了一个信号处理程序，以捕获*Ctrl* + *C*组合键。`signal_handler`方法（未显示）简单地关闭我们的LED并从代理中优雅地断开连接：
- en: '[PRE36]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: At line (20), the call to `client.loop_start()` is what allows our client to
    start, connect to the broker, and receive messages.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在第20行，调用`client.loop_start()`是允许我们的客户端启动、连接到代理并接收消息的方法。
- en: Did you notice that the LED program is stateless? We are not storing or persisting
    any LED level in code or to disk. All our program does is subscribe to a topic
    on the broker and change the LED's brightness using GPIOZero. We effectively hand
    all state management over to the MQTT broker by relying on MQTT's retained message
    (also known as the *last known good message*) facility.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否注意到LED程序是无状态的？我们没有在代码或磁盘中存储或持久化任何LED级别。我们的程序所做的就是订阅代理上的一个主题，并使用GPIOZero改变LED的亮度。我们通过依赖MQTT的保留消息（也称为*最后已知的好消息*）功能，将所有状态管理交给了MQTT代理。
- en: We have now finished exploring the Python code that interacts with both the
    LED and MQTT broker. We learned how to use the Python Paho-MQTT library to connect
    to an MQTT broker and subscribe to an MQTT topic. As we received messages on the
    subscribed topic, we saw how to process them and changed the brightness level
    of our LED according to the message payload.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了与LED和MQTT代理互动的Python代码的探索。我们学会了如何使用Python Paho-MQTT库连接到MQTT代理并订阅MQTT主题。当我们收到订阅主题上的消息时，我们看到了如何处理它们，并根据消息负载改变LED的亮度级别。
- en: The Python and Paho-MQTT framework and example we covered will provide you with
    a solid starting point for your own MQTT-based IoT projects.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍的Python和Paho-MQTT框架和示例将为您自己的基于MQTT的物联网项目提供一个坚实的起点。
- en: Next, we will be looking at a web client that uses MQTT together with Web Sockets.
    This web client will connect to our Mosquitto MQTT broker and publish messages
    to control our LED.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看一个使用MQTT和Web套接字的Web客户端。这个Web客户端将连接到我们的Mosquitto MQTT代理并发布消息以控制我们的LED。
- en: Building a web-based MQTT client
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建基于Web的MQTT客户端
- en: In [Chapter 3](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml), *Networking with
    RESTful APIs and Web Sockets Using Flask*, we covered a code example using Web
    Sockets, which included an HTML file and JavaScript web client. In this section,
    we will also be looking at a Web Socket-based web client built using HTML and
    JavaScript. However, this time, we will be leveraging the built-in Web Socket
    features provided by the Mosquitto MQTT broker and the compatible JavaScript Paho-JavaScript
    Web Sockets library (you will find a link to this library in the *Further reading*
    section).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml)中，*使用Flask进行RESTful API和Web套接字网络*，我们介绍了一个使用Web套接字的代码示例，其中包括一个HTML文件和JavaScript
    Web客户端。在本节中，我们还将查看使用HTML和JavaScript构建的基于Web套接字的Web客户端。然而，这一次，我们将利用Mosquitto MQTT代理提供的内置Web套接字功能以及兼容的JavaScript
    Paho-JavaScript Web套接字库（您将在*进一步阅读*部分找到此库的链接）。
- en: For comparison, in [Chapter 3](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml), *Networking
    with RESTful APIs and Web Sockets Using Flask*, we created our Web Socket server
    ourselves in Python using Flask-SocketIO, while our web client used the Socket.io
    JavaScript Web socket library.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对比，在[第3章](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml)中，*使用Flask进行RESTful API和Web套接字网络*，我们使用Flask-SocketIO在Python中自己创建了Web套接字服务器，而我们的Web客户端使用了Socket.io
    JavaScript Web套接字库。
- en: We interacted with the web client we are about to explore to control our LED
    previously in the  *Installing the Mosquitto MQTT broker *at section *step 7*. You
    might like to quickly review *step 7* to refamiliarize yourself with the web client
    and how to access it in your web browser.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前与即将探索的Web客户端进行了互动，以控制我们的LED，位于*安装Mosquitto MQTT代理*的第7步。您可能希望快速查看*第7步*，以重新熟悉Web客户端以及如何在Web浏览器中访问它。
- en: You will find the code for the web page client in the `chapter04/mosquitto_www/index.html` file. Please
    review this file before proceeding.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在`chapter04/mosquitto_www/index.html`文件中找到Web页面客户端的代码。请在继续之前查看此文件。
- en: Understanding the code
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解代码
- en: While the JavaScript library we are using in this example is different, you
    will find that the general structure and use of the JavsScript code are similar
    to the code we saw for the `socket.io`-based web client in [Chapter 3](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml)*,
    Networking with RESTful APIs and Web Sockets Using Flask*. As usual, we will start
    by looking at the imports.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在此示例中使用的JavaScript库不同，但您会发现JavsScript代码的一般结构和用法与我们在[第3章](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml)中看到的基于`socket.io`的Web客户端的代码类似，*使用Flask进行RESTful
    API和Web套接字的网络*。像往常一样，我们将从导入开始。
- en: Imports
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入
- en: 'Our web client imports the Paho-MQTT JavaScript client library at line (1):'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Web客户端在第1行导入了Paho-MQTT JavaScript客户端库：
- en: '[PRE37]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`paho-mqtt.js` can be also found in the `chapter04/mosquitto_www` folder.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`paho-mqtt.js`也可以在`chapter04/mosquitto_www`文件夹中找到。'
- en: The official documentation page for the Paho-MQTT JavaScript library is available
    at [https://www.eclipse.org/paho/clients/js](https://www.eclipse.org/paho/clients/js),
    while its official GitHub page is found at [https://github.com/eclipse/paho.mqtt.javascript](https://github.com/eclipse/paho.mqtt.javascript)[.](https://www.eclipse.org/paho/clients/js)
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: Paho-MQTT JavaScript库的官方文档页面位于[https://www.eclipse.org/paho/clients/js](https://www.eclipse.org/paho/clients/js)，而其官方GitHub页面位于[https://github.com/eclipse/paho.mqtt.javascript](https://github.com/eclipse/paho.mqtt.javascript)。
- en: When you explore the Paho-MQTT JavaScript API further, start at its GitHub site
    and make note of any breaking changes that are mentioned. The documentation pages
    are known to contain code fragments that do not reflect the latest GitHub code
    base.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 当您进一步探索Paho-MQTT JavaScript API时，请从其GitHub网站开始，并注意其中提到的任何重大更改。已知文档页面包含不反映最新GitHub代码库的代码片段。
- en: Next, we encounter the global variables.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们遇到了全局变量。
- en: Global variables
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局变量
- en: At line (2), we initialize a `Client_ID` constant that will identify our JavaScript
    client with the broker.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2行，我们初始化了一个`Client_ID`常量，用于标识我们的JavaScript客户端与代理的连接。
- en: 'Each Paho JavaScript MQTT client *must* have a unique *hostname, port,* and
    *client ID *combination when it connects to the broker. To ensure we can run multiple
    web pages on a single computer for testing and demonstration, we use a random
    number to create a quasi-unique client ID for each web page:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Paho JavaScript MQTT客户端*必须*在连接到代理时具有唯一的*主机名、端口*和*客户端ID*组合。为了确保我们可以在单台计算机上运行多个网页进行测试和演示，我们使用随机数为每个网页创建一个准唯一的客户端ID：
- en: '[PRE38]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: At line (3), we define the `TOPIC` constant with `led`, the name of the MQTT
    topic that we will be subscribing and publishing to shortly. Next, we create our
    client instance.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3行，我们使用`led`定义了`TOPIC`常量，这是我们将要订阅和发布的MQTT主题的名称。接下来，我们创建我们的客户端实例。
- en: The Paho JavaScript MQTT client
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Paho JavaScript MQTT客户端
- en: At line (4), we create our Paho-MQTT Client instance and assign it to the `client`
    variable.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4行，我们创建了我们的Paho-MQTT客户端实例并将其分配给`client`变量。
- en: 'The parameters to `Paho.MQTT.Client()` are the broker''s hostname and port.
    We are serving this web page via Mosquitto, so the broker''s host and port will
    be the same as web pages:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`Paho.MQTT.Client()`的参数是代理的主机名和端口。我们通过Mosquitto提供此网页，因此代理的主机和端口将与网页相同：'
- en: '[PRE39]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You may have noticed in the `http://localhost:8083` URL that the port is `8083`,
    while in Python we used port `1883`:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到在`http://localhost:8083`的URL中，端口是`8083`，而在Python中我们使用的是端口`1883`：
- en: Port `1883` is the MQTT protocol port on the broker. Our Python program connects
    directly to the broker on this port.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口`1883`是代理上的MQTT协议端口。我们的Python程序直接连接到代理的这个端口。
- en: We previously configured port `8083` as a Web Socket port on the Mosquitto broker.
    Web pages can speak HTTP and Web Socket protocols, not MQTT.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们之前将端口`8083`配置为Mosquitto代理上的Web套接字端口。Web页面可以使用HTTP和Web套接字协议，而不是MQTT。
- en: This raises an important point. While we're using the term MQTT in the context
    of our JavaScript code, we're really proxying the MQTT idea using Web Sockets back
    and forth to the broker.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这提出了一个重要的观点。虽然我们在JavaScript代码的上下文中使用MQTT这个术语，但我们实际上是使用Web套接字来代理MQTT的想法与代理来回传递。
- en: When we speak of the MQTT *client* and created the `client` instance at line
    (4), remember this is our JavaScript code's client connection *to the broker*.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈到MQTT *client*并在第4行创建了`client`实例时，请记住这是我们JavaScript代码的客户端连接*到代理*。
- en: Next, we see how to connect to the broker and register an `onConnect` handler
    function.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何连接到代理并注册`onConnect`处理程序函数。
- en: Connecting to the broker
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接到代理
- en: 'We define our `onConnectionSuccess()` handler at line (5), which will be called
    after our `client` successfully connects to the broker. When we successfully connect,
    we then update the web page to reflect the successful connection and enable the
    slider control:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第5行定义了`onConnectionSuccess()`处理程序，这将在我们的`client`成功连接到代理后调用。当我们成功连接时，我们将更新网页以反映成功的连接并启用滑块控件：
- en: '[PRE40]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Next, at line (6), we subscribe to the `led` topic. It's at line (7) that we
    connect to the broker. Notice that we're registering the `onConnectionSuccess`
    function as the `onSuccess` option.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在第6行，我们订阅了`led`主题。在第7行，我们连接到了代理。请注意，我们将`onConnectionSuccess`函数注册为`onSuccess`选项。
- en: Remember, similar to the Python example, always subscribe to topics in an
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，与Python示例类似，总是订阅主题
- en: '`onSuccess` handler. This way, if the client ever loses the connection to the
    broker, it can re-establish subscriptions when it reconnects.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`onSuccess`处理程序。这样，如果客户端失去与代理的连接，它可以在重新连接时重新建立订阅。'
- en: 'We also specify the `reconnect: true` option so that our client will automatically
    reconnect to the broker if it loses its connection.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还指定了`reconnect: true`选项，这样我们的客户端在失去连接时将自动重新连接到代理。'
- en: It has been observed that it may take up to a minute for the JavaScript Paho-MQTT
    client to reconnect after losing a connection, so please be patient. This is in
    contrast to the Python Paho-MQTT client, which reconnects almost instantly.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 已经观察到，JavaScript Paho-MQTT客户端在失去连接后可能需要一分钟才能重新连接，所以请耐心等待。这与Python Paho-MQTT客户端形成对比，后者几乎可以立即重新连接。
- en: Next, we have another two handlers to review.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有另外两个处理程序需要审查。
- en: The onConnectionLost and onMessageArrived handler methods
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: onConnectionLost和onMessageArrived处理程序方法
- en: 'In the following code, at lines (8) and (9), we see how to register an `onConnectionLost`
    and `onMessageArrived` handler with our Paho-MQTT `client` instance:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，第（8）行和（9）行，我们看到如何使用Paho-MQTT的`client`实例注册`onConnectionLost`和`onMessageArrived`处理程序：
- en: '[PRE41]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: These two functions are similar in principle to their corresponding functions
    in the socket.io example from the previous [Chapter 3](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml),
    *Networking with RESTful APIs and Web Sockets Using Flask*, in that they update
    the slider and web page text based on the data found in their respective `data`
    and `message` parameters.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数在原则上类似于之前[第3章](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml)中socket.io示例中的相应函数，即它们基于它们各自的`data`和`message`参数中的数据更新滑块和网页文本。
- en: Next, we have our document ready function.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有我们的文档准备函数。
- en: JQuery document ready function
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JQuery文档准备函数
- en: 'Finally, we encounter the document ready function at line (1o) where we initialize our
    web page content and register the event listener for the slider:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第（10）行，我们遇到了文档准备函数，其中我们初始化了我们的网页内容并注册了滑块的事件监听器：
- en: '[PRE42]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Within the sliders event handler at line (11), we see how to create an MQTT
    message. Notice the use of `JSON.stringify(payload)`. The `Paho.Message` constructor
    expects a `String` parameter, not an `Object`, so we must convert the payload
    variable (which is an `Object`) in to a string.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在第（11）行的滑块事件处理程序中，我们看到了如何创建一个MQTT消息。请注意`JSON.stringify(payload)`的使用。`Paho.Message`构造函数期望一个`String`参数，而不是一个`Object`，因此我们必须将payload变量（它是一个`Object`）转换为字符串。
- en: Starting at line (12), we set the message publication topic to `led` with `message.destinationName
    = TOPIC` before flagging its QoS level as 2.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 从第（12）行开始，我们将消息发布主题设置为`led`，并在标记其QoS级别为2之前，使用`message.destinationName = TOPIC`。
- en: Next, at line (13), with `message.retained = true`, we indicate that we want
    this message to be retained so that it is automatically delivered to new clients
    subscribing to the `led` topic. The retention of this message is what allows `mqtt_led.py`
    to reinitialize the LED's previous brightness between restarts.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在第（13）行，通过`message.retained = true`，我们指示希望保留此消息，以便它会自动传递给订阅`led`主题的新客户端。保留此消息是使`mqtt_led.py`能够在重新启动时重新初始化LED的先前亮度。
- en: Well Done! We have now covered both the Python and JavaScript sides of a simple
    MQTT-based application.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！我们现在已经涵盖了简单基于MQTT的应用程序的Python和JavaScript两方面。
- en: Summary
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have explored and practiced the core concepts of MQTT. After
    installing and configuring the Mosquitto MQTT broker on your Raspberry Pi, we
    moved straight into learning a range of examples on the command line. We learned
    how to publish and subscribe to MQTT messages, how to understand topic construction
    and name hierarchies, and how we can attach a QoS level to a message.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们探讨并实践了MQTT的核心概念。在您的树莓派上安装和配置Mosquitto MQTT代理之后，我们直接开始学习了一系列命令行示例。我们学习了如何发布和订阅MQTT消息，如何理解主题构建和名称层次结构，以及如何将QoS级别附加到消息上。
- en: We also covered durable connections and retained messages, two mechanisms offered
    by MQTT brokers for storing messages for later delivery. We concluded our walk-through
    of MQTT concepts by exploring a special message and topic type known as a *Will*,
    whereby a client can register a message with a broker that gets automatically
    published to a topic in cases where the client abruptly loses its connection.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还涵盖了MQTT代理提供的两种机制，即持久连接和保留消息，用于存储消息以供以后传递。我们通过探索一种称为*Will*的特殊消息和主题类型来结束了我们对MQTT概念的讲解，其中客户端可以向代理注册一条消息，在客户端突然失去连接时自动发布到主题。
- en: Next, we reviewed and walked through a Python program that used the Paho Python
    MQTT library to subscribe to an MQTT topic and control the brightness of our LED
    in response to the messages it received. We followed this with a walk-through
    of a web page built with the Paho JavaScript MQTT library that published the messages
    consumed by our Python program.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们回顾并讲解了一个使用Paho Python MQTT库订阅MQTT主题并根据接收到的消息控制LED亮度的Python程序。然后我们讲解了一个使用Paho
    JavaScript MQTT库构建的网页，该网页发布了Python程序消费的消息。
- en: You now have a working knowledge of MQTT and a practical code framework you
    can now leverage for your own IoT applications. This is in addition to the other
    networking approaches and code frameworks that we've explored in earlier chapters,
    such as the dweet.io service, Flask-RESTful, and Flask-SocketIO. Which approach
    you use for your projects all depends on what you are trying to create and, of
    course, your own personal preference. For larger projects and projects where you
    need to integrate with external systems, you may find yourself needing to leverage
    multiple approaches in tandem and even find the need to research and explore additional
    techniques. I do not doubt that your learning and understanding of the alternative
    networking approaches we've covered so far will be of value and help with your
    understanding of other approaches you encounter.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经掌握了MQTT的工作知识，并且有一个可以用于自己的物联网应用的实用代码框架。这是我们在之前章节中探讨过的其他网络方法和代码框架的补充，例如dweet.io服务、Flask-RESTful和Flask-SocketIO。您用于项目的方法取决于您要创建什么，当然还取决于您个人的偏好。对于较大的项目和需要与外部系统集成的项目，您可能需要同时利用多种方法，甚至需要研究和探索其他技术。我毫不怀疑，到目前为止我们所涵盖的其他网络方法的学习和理解将对您理解遇到的其他方法有所帮助。
- en: In the next chapter, *Connecting Python to the Physical World*, we will be exploring
    a range of topics related to how you connect your Raspberry Pi to the world. We
    will run through popular Python GPIO library options in addition to GPIOZero and
    PiGPIO and look at the different types of electronic interfacing options and configurations
    that are available with a Raspberry Pi. We also have a comprehensive exercise
    where we will be adding an analog-to-digital converter to your Raspberry Pi and
    using it to create a program to explore PWM techniques and concepts.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章《将Python连接到物理世界》中，我们将探讨一系列与将树莓派连接到世界的主题相关的话题。我们将介绍流行的Python GPIO库选项，以及GPIOZero和PiGPIO，并研究与树莓派一起使用的不同类型的电子接口选项和配置。我们还有一个全面的练习，我们将向您的树莓派添加一个模数转换器，并使用它创建一个程序来探索PWM技术和概念。
- en: Questions
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material. You will find the answers in the *Assessments*
    section of the book:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里有一些问题供您测试对本章材料的了解。您将在书的*评估*部分找到答案：
- en: What is MQTT?
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是MQTT？
- en: Your retained MQTT messages never get delivered. What should you check?
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您保留的MQTT消息从未被传递。您应该检查什么？
- en: Under what condition will an MQTT broker publish a *Will* message?
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么条件下，MQTT代理会发布*遗嘱*消息？
- en: You choose to use MQTT as your IoT application's messaging layer and must ensure
    that messages are sent and received. What is the minimum QoS level required?
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您选择使用MQTT作为物联网应用程序的消息传递层，并且必须确保消息被发送和接收。所需的最低QoS级别是多少？
- en: You develop an application using MQTT and use the Mosquitto broker, but now
    you need to use a different broker. What does this mean for your code base and
    deployment configuration?
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您使用MQTT开发了一个应用程序，并使用Mosquitto代理，但现在您需要使用不同的代理。这对您的代码库和部署配置意味着什么？
- en: 'Where in code (hint: which handler method) should you subscribe to MQTT topics
    and why?'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码中的哪个位置（提示：哪个处理程序方法）应该订阅MQTT主题，以及为什么？
- en: Further reading
  id: totrans-415
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: We covered the basics of MQTT from an operational level in this chapter. If
    you want to learn more about MQTT from a protocol and data level, HiveMQ (an MQTT
    broker and service provider) has an excellent 11-part series on the MQTT protocol
    available at [https://www.hivemq.com/blog/mqtt-essentials-part-1-introducing-mqtt](https://www.hivemq.com/blog/mqtt-essentials-part-1-introducing-mqtt/).
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从操作层面介绍了MQTT的基础知识。如果您想从协议和数据层面了解更多关于MQTT的知识，HiveMQ（一个MQTT代理和服务提供商）在[https://www.hivemq.com/blog/mqtt-essentials-part-1-introducing-mqtt](https://www.hivemq.com/blog/mqtt-essentials-part-1-introducing-mqtt/)上提供了一系列关于MQTT协议的精彩11部分系列文章。
- en: 'The home page of the Mosquitto MQTT broker and client tools are available at
    the following URL:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: Mosquitto MQTT代理和客户端工具的主页位于以下URL：
- en: Mosquitto MQTT broker: [https://mosquitto.org](https://mosquitto.org)
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mosquitto MQTT代理：[https://mosquitto.org](https://mosquitto.org)
- en: 'The documentation and API references for the Paho-MQTT libraries we used in
    this chapter are available at the following URLs:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中使用的Paho-MQTT库的文档和API参考资料可在以下URL找到：
- en: Paho-MQTT Python library: [https://www.eclipse.org/paho/clients/python](https://www.eclipse.org/paho/clients/python/)
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Paho-MQTT Python库：[https://www.eclipse.org/paho/clients/python](https://www.eclipse.org/paho/clients/python/)
- en: Paho-MQTT JavaSctipt library: [https://www.eclipse.org/paho/clients/js](https://www.eclipse.org/paho/clients/js)
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Paho-MQTT JavaScript库：[https://www.eclipse.org/paho/clients/js](https://www.eclipse.org/paho/clients/js)
- en: In addition to MQTT, HTTP RESTful APIs, and Web Sockets, there are complimentary
    communication protocols that are specially designed for constrained devices, known
    as CoRA and MQTT-NS. The Eclipse Foundation has a summary of these protocols available
    at [https://www.eclipse.org/community/eclipse_newsletter/2014/february/article2.php](https://www.eclipse.org/community/eclipse_newsletter/2014/february/article2.php).
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 除了MQTT，HTTP RESTful API和Web Sockets之外，还有一些专为受限设备设计的补充通信协议，称为CoRA和MQTT-NS。 Eclipse
    Foundation在[https://www.eclipse.org/community/eclipse_newsletter/2014/february/article2.php](https://www.eclipse.org/community/eclipse_newsletter/2014/february/article2.php)上提供了这些协议的摘要。
