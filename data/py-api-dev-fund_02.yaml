- en: 2\. Starting to Build Our Project
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2. 开始构建我们的项目
- en: Learning Objectives
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够：
- en: Build a Restful API service efficiently using the Flask-Restful package
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Flask-Restful包高效构建Restful API服务
- en: Build an extendable Flask project
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个可扩展的Flask项目
- en: Perform CRUD operations using the model
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模型执行CRUD操作
- en: Test RESTful APIs using curl, httpie, and Postman
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用curl、httpie和Postman测试RESTful API
- en: In this chapter, we will start to work on the food recipe-sharing platform and
    learn how to create a RESTful API application.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始着手构建食品菜谱分享平台，并学习如何创建RESTful API应用程序。
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简介
- en: Now that we've introduced APIs and learned a bit about HTTP and REST, we will
    work on building an application (the recipe-sharing app known as Smilecook). In
    this chapter, we aim to kick-start the actual project development. This is a recipe-sharing
    platform in which users can create accounts and share their own recipes with other
    users. As you can imagine, it will contain a lot of API endpoints for our users
    so that they can manage their recipes. We will be using the Flask-RESTful package
    to efficiently develop our RESTful API.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了API并了解了一些关于HTTP和REST的知识，我们将着手构建一个应用程序（名为Smilecook的菜谱分享应用程序）。在本章中，我们的目标是启动实际项目开发。这是一个用户可以创建账户并与其他用户分享他们自己的菜谱的菜谱分享平台。正如你所想象的那样，它将包含许多API端点，以便我们的用户可以管理他们的菜谱。我们将使用Flask-RESTful包来高效地开发我们的RESTful
    API。
- en: This chapter will talk about the **CRUD** (**Create, Read, Update, Delete**)
    of these recipes, as well as how to set the publish status of the recipe.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论这些菜谱的**CRUD**（**创建、读取、更新、删除**）操作，以及如何设置菜谱的发布状态。
- en: What is Flask-RESTful?
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是Flask-RESTful？
- en: Flask-RESTful is a Flask extension that allows us to quickly develop RESTful
    APIs. Compared to the built-in wrapper, `@app.route('/')`, which we discussed
    in the previous chapter, Flask-RESTful allows us to maintain and structure the
    API endpoints in a much better and easier way.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Flask-RESTful是一个Flask扩展，它允许我们快速开发RESTful API。与我们在上一章中讨论的内置包装器`@app.route('/')`相比，Flask-RESTful允许我们以更好、更简单的方式维护和结构化API端点。
- en: In this chapter, we will develop our project using this Flask extension so that
    you will see how we can structure our endpoints.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用这个Flask扩展来开发我们的项目，这样你将看到我们如何构建我们的端点。
- en: Using Flask-RESTful to Develop Our Recipe-Sharing Platform, "Smilecook"
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Flask-RESTful开发我们的菜谱分享平台，“Smilecook”
- en: In this book, we are going to develop a recipe-sharing platform called **Smilecook**.
    Beginning with this chapter, we will start adding functions to it. We believe
    this approach will help you learn about the key concepts and skills you will need
    so that you can develop this application and help it reach its full potential,
    while at the same time helping you understand the entire development workflow.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将开发一个名为**Smilecook**的菜谱分享平台。从本章开始，我们将开始向其中添加功能。我们相信这种方法将帮助你了解你需要的关键概念和技能，以便你可以开发这个应用程序并帮助它发挥其全部潜力，同时帮助你理解整个开发流程。
- en: First, we will build the basic CRUD functions of the recipes. The Flask-RESTful
    package allows us to structure our code in a more comprehensive way. We will define
    certain methods in a resource and link them to the endpoints. The flow of a GET
    request, for example, will be for the request to be sent to the endpoints (`http://localhost:5000/recipes`),
    which will then be handled by the `GET` method we are going to implement in the
    resource. This will result in the recipes being returned to us.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将构建菜谱的基本CRUD功能。Flask-RESTful包允许我们以更全面的方式组织我们的代码。我们将在资源中定义某些方法并将它们链接到端点。例如，GET请求的流程将是请求被发送到端点（`http://localhost:5000/recipes`），然后由我们在资源中将要实现的`GET`方法处理。这将导致菜谱返回给我们。
- en: 'Apart from the basic CRUD functions, we will also implement the publish and
    unpublish functions on these recipes. This can be done through the `PUT` and `DELETE`
    methods, which can be found in the `RecipePublishResource` class. We will link
    these two methods to the `http://localhost:5000/recipes/1/publish` endpoint (for
    the recipe whose *ID = 1*). For details of our endpoint design, please refer to
    the following table:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本的CRUD功能外，我们还将实现这些菜谱的发布和取消发布功能。这可以通过`PUT`和`DELETE`方法完成，这些方法可以在`RecipePublishResource`类中找到。我们将这两个方法链接到`http://localhost:5000/recipes/1/publish`端点（对于ID为1的菜谱）。关于我们端点设计的详细信息，请参考以下表格：
- en: '![](img/C15309_02_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C15309_02_01.jpg)'
- en: 'Figure 2.1: Details of our endpoint designs'
  id: totrans-19
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.1：我们端点设计的细节
- en: Virtual Environment
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟环境
- en: PyCharm will help us create a virtual environment. We want to develop our project
    in its own virtual environment in order to keep it isolated. Due to this, we will
    have absolute control over the versions of the packages that we are going to use.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm将帮助我们创建虚拟环境。我们希望在独立的虚拟环境中开发我们的项目，以便将其隔离。因此，我们将对我们将要使用的包的版本拥有绝对的控制权。
- en: The best way to learn is through practice. Let's get our hands dirty now!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 学习的最佳方式是通过实践。现在让我们动手试试吧！
- en: 'Exercise 5: Creating a Development Project in PyCharm'
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习5：在PyCharm中创建开发项目
- en: 'Before you start developing the Python application, you''ll need to create
    a development project in PyCharm. PyCharm manages things using projects. In this
    exercise, you will learn how to create a new development project in PyCharm called
    Smilecook. You will also need to install the necessary packages for this project.
    Let''s get started:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始开发Python应用程序之前，你需要在PyCharm中创建一个开发项目。PyCharm使用项目来管理事物。在这个练习中，你将学习如何在PyCharm中创建一个名为Smilecook的新开发项目。你还需要为这个项目安装必要的包。让我们开始吧：
- en: Create the project and name it **smilecook**:![](img/C15309_02_02.jpg)
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建项目并命名为**smilecook**![图片](img/C15309_02_02.jpg)
- en: 'Figure 2.2: Creating a project'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.2：创建项目
- en: Check the project structure and ensure that the virtual environment has been
    created. Once the module has been created, we will be able to see the project's
    hierarchy on the left-hand side panel. We can see the **venv** folder under the
    project folder, which was created and activated by PyCharm. Now, when we write
    code under this project, it will be run in the virtual environment:![](img/C15309_02_03.jpg)
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查项目结构并确保已创建虚拟环境。一旦创建了模块，我们就能在左侧面板上看到项目的层次结构。我们可以看到项目文件夹下的**venv**文件夹，这是由PyCharm创建和激活的。现在，当我们在这个项目下编写代码时，它将在虚拟环境中运行！![图片](img/C15309_02_03.jpg)
- en: 'Figure 2.3: Checking the project structure and ensuring that the virtual environment
    has been created'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.3：检查项目结构和确保已创建虚拟环境
- en: 'Install the required packages for this chapter. To do this, create a file called
    `requirements.txt` under our project folder. Type in the following code to specify
    the packages you want to install:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装本章所需的包。为此，在我们的项目文件夹下创建一个名为`requirements.txt`的文件。输入以下代码以指定您想要安装的包：
- en: '[PRE0]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Use the `pip` command to install these packages. After that, in the `pip` command
    to install the packages that we specified in the `requirements.txt` file:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pip`命令安装这些包。之后，在`pip`命令中安装我们在`requirements.txt`文件中指定的包：
- en: '[PRE1]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You should now see something similar in the following screenshot. Here, we can
    see that the packages are being installed on the virtual environment:![](img/C15309_02_04.jpg)
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在应该能在下面的屏幕截图中看到类似的内容。在这里，我们可以看到包正在虚拟环境中安装！![图片](img/C15309_02_04.jpg)
- en: 'Figure 2.4: Installing the packages on the virtual environment'
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.4：在虚拟环境中安装包
- en: Congratulations! You have created a PyCharm project for our Smilecook application.
    This is the first step of you embarking on your journey as a developer!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经为我们的Smilecook应用程序创建了一个PyCharm项目。这是你作为开发者踏上旅程的第一步！
- en: Creating a Recipe Model
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建菜谱模型
- en: As you can imagine, a recipe may have several attributes. To save every detail
    of these attributes, we will model the recipe using a class. This recipe class
    is going to have several essential attributes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，一个菜谱可能有多个属性。为了保存这些属性的每一个细节，我们将使用类来模拟菜谱。这个菜谱类将具有几个基本属性。
- en: 'Here is a brief description of the attributes that we will define in the recipe
    class:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们在菜谱类中将要定义的属性的简要描述：
- en: '`name`: The name of the recipe.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：菜谱的名称。'
- en: '`description`: The description of the recipe.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`：菜谱的描述。'
- en: '`num_of_servings`: The number of servings.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`num_of_servings`：份量。'
- en: '`cook_time`: The cooking time required. This is an integer whose units are
    in seconds.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cook_time`：所需的烹饪时间。这是一个以秒为单位的整数。'
- en: '`directions`: The directions.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`directions`：步骤。'
- en: '`is_publish`: The publish status of the recipe; the default is draft.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_publish`：菜谱的发布状态；默认为草稿。'
- en: In the next exercise, we will show you how to code the recipe class so that
    it has these attributes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将向您展示如何编码菜谱类，使其具有这些属性。
- en: 'Exercise 6: Creating the Recipe Model'
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习6：创建菜谱模型
- en: In this exercise, we will code the recipe model, step by step. The `recipe`
    class will contain the attributes that we discussed previously. The code file
    for this exercise can be found in `Lesson2/Exercise06/models/recipe.py`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将逐步编写食谱模型。`recipe` 类将包含我们之前讨论过的属性。本练习的代码文件可以在 `Lesson2/Exercise06/models/recipe.py`
    中找到。
- en: 'Now, let''s create the recipe class:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个食谱类：
- en: '*Right-click* on the project name, that is, Smilecook, and create a `Python
    Package`. Name it `models`:![](img/C15309_02_05.jpg)'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目名称，即 Smilecook 上，*右键点击* 创建一个 `Python 包`。将其命名为 `models`：![](img/C15309_02_05.jpg)
- en: 'Figure 2.5: Creating a Python package and naming it models'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2.5：创建一个 Python 包并将其命名为 models
- en: 'Then, create a file called `recipe.py` under `models` and type in the following
    code:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 `models` 下创建一个名为 `recipe.py` 的文件，并输入以下代码：
- en: '[PRE2]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let's pause for a while and examine the code here. First, we define `recipe_list
    = []` so that we can store the recipes in the application memory. Then, we define
    the `get_last_id` function to get the ID of our last recipe. Later, when we create
    a new recipe, we will use this method to evaluate the last ID in `recipe_list`
    so that we can come up with a new ID for the new recipe.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们暂停一下，检查这里的代码。首先，我们定义 `recipe_list = []` 以便在应用程序内存中存储食谱。然后，我们定义 `get_last_id`
    函数以获取我们最后一个食谱的 ID。稍后，当我们创建一个新的食谱时，我们将使用此方法来评估 `recipe_list` 中的最后一个 ID，以便我们可以为新的食谱生成一个新的
    ID。
- en: 'Define the recipe class using the following code. Type the following code into
    `recipe.py`, right after the `get_last_id` function that we implemented:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码定义食谱类。在 `recipe.py` 文件中，在 `get_last_id` 函数之后输入以下代码：
- en: '[PRE3]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Recipe` class has the `__init__` constructor method, which will take in
    parameters such as `name`, `description`, `num_of_servings`, `cook_time`, and
    `directions`, and create the recipe object based on that. The ID is self-incremented
    and `is_publish` is set to `false` by default. This means that, by default, the
    recipe will be set to draft (not published).
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Recipe` 类有一个 `__init__` 构造方法，它将接受如 `name`、`description`、`num_of_servings`、`cook_time`
    和 `directions` 等参数，并根据这些参数创建食谱对象。ID 是自增的，`is_publish` 默认设置为 `false`。这意味着默认情况下，食谱将被设置为草稿（未发布）。'
- en: 'In the same `Recipe` class, define the `data` method for returning the data
    as a dictionary object. You will recall that, in Python, indentation matters.
    The following code is indented since it is under the `Recipe` class:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的 `Recipe` 类中，定义一个 `data` 方法，用于将数据作为字典对象返回。你可能会记得，在 Python 中，缩进很重要。以下代码是缩进的，因为它位于
    `Recipe` 类内部：
- en: '[PRE4]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that we have built the recipe model, we will go ahead and build the API
    endpoint using Flask-RESTful.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了食谱模型，我们将继续使用 Flask-RESTful 构建API端点。
- en: Resourceful Routing
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源路由
- en: The main building blocks in Flask-RESTful are resources. Resources are built
    on top of Flask's pluggable view. The concept of resourceful routing is that we
    want to structure all the client requests around resources. In our recipe-sharing
    platform, we are going to group the CRUD actions on a recipe under `RecipeResource`.
    For publish and unpublish actions, we will group them under a different `RecipePublishResource`.
    This provides a clear structure that other developers can follow.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Flask-RESTful 的主要构建块是资源。资源建立在 Flask 的可插拔视图之上。资源路由的概念是我们希望将所有客户端请求围绕资源进行结构化。在我们的食谱分享平台上，我们将对
    `RecipeResource` 下的食谱的 CRUD 操作进行分组。对于发布和取消发布操作，我们将它们分组在不同的 `RecipePublishResource`
    下。这为其他开发者提供了一个清晰的架构。
- en: 'The way in which we can implement these resources is simple: we just need to
    inherit from the `flask_restful.Resource` class and implement the methods that
    correspond to the HTTP verb inside it.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实施这些资源的方式很简单：我们只需要从 `flask_restful.Resource` 类继承，并实现其中对应 HTTP 动词的方法。
- en: 'In the next exercise, we will define three subclasses: one for the collection
    of recipes, one for a single recipe, and one for publishing the recipe.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将定义三个子类：一个用于食谱集合，一个用于单个食谱，一个用于发布食谱。
- en: 'Exercise 7: Defining an API Endpoint for the Recipe Model'
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 7：为食谱模型定义 API 端点
- en: 'To build an API endpoint, we need to define a class that inherits from `flask_restful.Resource`.
    Then, we can declare the get and post methods inside the class. Let''s get started:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建 API 端点，我们需要定义一个继承自 `flask_restful.Resource` 的类。然后，我们可以在类内部声明 get 和 post
    方法。让我们开始吧：
- en: Create a folder called `resources` under the project and then create a file
    called `recipe.py` under the `resources` folder.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目下创建一个名为 `resources` 的文件夹，然后在 `resources` 文件夹下创建一个名为 `recipe.py` 的文件。
- en: Note
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The code file for this can be found in the [https://github.com/TrainingByPackt/Python-API-Development-Fundamentals/tree/master/Lesson02/Exercise07/resources](https://github.com/TrainingByPackt/Python-API-Development-Fundamentals/tree/master/Lesson02/Exercise07/resources).
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该代码文件可以在[https://github.com/TrainingByPackt/Python-API-Development-Fundamentals/tree/master/Lesson02/Exercise07/resources](https://github.com/TrainingByPackt/Python-API-Development-Fundamentals/tree/master/Lesson02/Exercise07/resources)中找到。
- en: 'Import the necessary packages, classes, and functions using the following code:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码导入必要的包、类和函数：
- en: '[PRE5]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Right after the preceding code import, create the `RecipeListResource` class.
    This class has `GET` and `POST` methods, which are used to get and create the
    recipe''s resources, respectively. We will finish the get method first:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的代码导入之后，创建`RecipeListResource`类。这个类有`GET`和`POST`方法，分别用于获取和创建食谱资源。我们首先完成`GET`方法：
- en: '[PRE6]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we have created and implemented the `RecipeListResource` class, which
    inherits from `flask-restful.Resource`. The `get` method that we implemented is
    for, getting all the public recipes back. It does this by declaring a `data` list
    and getting all the recipes with `is_publish` = `true` in `recipe_list`. These
    recipes are appended to our `data` list and returned to the users.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们创建并实现了`RecipeListResource`类，它继承自`flask-restful.Resource`。我们实现的`get`方法用于获取所有公开的食谱。它是通过声明一个`data`列表，并在`recipe_list`中获取所有`is_publish`等于`true`的食谱来完成的。这些食谱被追加到我们的`data`列表中，并返回给用户。
- en: 'Add the `post` method. This is used to create the recipe:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`post`方法。这是用来创建食谱的：
- en: '[PRE7]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this exercise, we have built two methods that handle the GET and POST client
    requests. The following table summarizes the methods that we have built in this
    exercise:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们构建了两个方法来处理GET和POST客户端请求。以下表格总结了我们在本练习中构建的方法：
- en: '![](img/C15309_02_06.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/C15309_02_06.jpg)'
- en: 'Figure 2.6: Client request methods that we used in this exercise'
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.6：在这个练习中我们使用的客户端请求方法
- en: Note
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: We have skipped the step to jsonify the object before returning data to the
    client because Flask-RESTful has already done that for us behind the scenes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们跳过了在将数据返回给客户端之前对对象进行序列化的步骤，因为Flask-RESTful已经在幕后为我们做了这件事。
- en: The `post` method that we built in this exercise is for creating a new recipe.
    It is a `POST` method. It does this by getting the JSON data back from the request
    using `request.get_json` and then creates the recipe object and stores that in
    `recipe_list`. Finally, it returns the recipe record with an HTTP status code
    **201 CREATED**.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本练习中构建的`post`方法用于创建新的食谱。这是一个`POST`方法。它是通过使用`request.get_json`从请求中获取JSON数据，然后创建食谱对象并将其存储在`recipe_list`中来完成的。最后，它返回带有HTTP状态码**201
    CREATED**的食谱记录。
- en: 'Exercise 8: Defining the Recipe Resource'
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习8：定义食谱资源
- en: 'In this exercise, we will define the recipe resource. We are going to use two
    methods: the get method, for getting back a single recipe; and the put method,
    for updating the recipe. Let''s get started:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将定义食谱资源。我们将使用两种方法：`get`方法，用于获取单个食谱；以及`put`方法，用于更新食谱。让我们开始吧：
- en: 'Define the `RecipeResource` resource and implement the `get` method by using
    the following sample code:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`RecipeResource`资源，并使用以下示例代码实现`get`方法：
- en: '[PRE8]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Similarly, `RecipeResource` also inherits from `flask-restful.Resource`. The
    get method we are implementing here is getting back a single recipe. We do that
    by searching for `recipe_id` in `recipe_list`. We will only get back those recipes
    with `is_publish = true`. If no such recipe is found, we will return the message
    **recipe not found**. Otherwise, we will return the recipe, along with an HTTP
    status of **200 OK**.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类似地，`RecipeResource`也继承自`flask-restful.Resource`。我们在这里实现的`get`方法是获取单个食谱。我们通过在`recipe_list`中搜索`recipe_id`来实现这一点。我们只会返回那些`is_publish
    = true`的食谱。如果没有找到这样的食谱，我们将返回消息**食谱未找到**。否则，我们将返回食谱，并附带HTTP状态**200 OK**。
- en: 'Implement the `put` method with the following code:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码实现`put`方法：
- en: '[PRE9]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The second method we've implemented here is `put`. It gets the recipe details
    from the client request using `request.get_json` and updates the recipe object.
    Then, it returns the HTTP status code **200 OK** if everything goes well.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在这里实现的第二个方法是`put`。它通过使用`request.get_json`从客户端请求中获取食谱详情，并更新食谱对象。如果一切顺利，它将返回HTTP状态码**200
    OK**。
- en: 'Here, we have built two methods for the recipe resources. The `GET` and `PUT`
    methods are used to handle the corresponding client request. The following table
    shows the methods that we have built for the `RecipeResource` class in this exercise:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为食谱资源构建了两个方法。`GET` 和 `PUT` 方法用于处理相应的客户端请求。下表显示了在本练习中为 `RecipeResource`
    类构建的方法：
- en: '![](img/C15309_02_07.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/C15309_02_07.jpg)'
- en: 'Figure 2.7: Methods that we have built for the RecipeResource class'
  id: totrans-92
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2.7：为 `RecipeResource` 类构建的函数
- en: 'Exercise 9: Publishing and Unpublishing the Recipes'
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 9：发布和取消发布食谱
- en: 'In the previous exercises, we created the recipe resources and their associated
    methods. Now, our Smilecook application can read/write actions on recipes. However,
    at the beginning of this chapter, we said that the recipes can have two Statuses
    (unpublished and published). This allows the user to continue updating their unpublished
    recipes before publishing them to the world. In this exercise, we will define
    the resource for publishing and unpublishing a recipe. Let''s get started:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的练习中，我们创建了食谱资源和它们相关的方法。现在，我们的 Smilecook 应用程序可以对食谱进行读写操作。然而，在本章的开头，我们提到食谱可以有两种状态（未发布和已发布）。这允许用户在将食谱发布到世界之前继续更新它们的未发布食谱。在本练习中，我们将定义发布和取消发布食谱的资源。让我们开始吧：
- en: 'Define the `RecipePublic` resource and implement the `put` method that will
    handle the HTTP PUT request:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `RecipePublic` 资源并实现一个 `put` 方法，它将处理 HTTP PUT 请求：
- en: '[PRE10]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`RecipePublishResource` inherits from `flask_restful.Resource`. The `put` method
    will locate the recipe with the passed-in `recipe_id` and update the `is_publish`
    status to true. Then, it will return `HTTPStatus.NO_CONTENT`, which shows us that
    the recipe has been published successfully.'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`RecipePublishResource` 继承自 `flask_restful.Resource`。`put` 方法将定位带有传入的 `recipe_id`
    的食谱，并将 `is_publish` 状态更新为 true。然后，它将返回 `HTTPStatus.NO_CONTENT`，这表明食谱已成功发布。'
- en: 'Implement the `delete` method, which will handle the HTTP DELETE request:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个 `delete` 方法，它将处理 HTTP DELETE 请求：
- en: '[PRE11]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `delete` method is the opposite of the `put` method. Instead of setting
    `is_publish` to `true`, it sets it to `false` in order to unpublish the recipe.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`delete` 方法是 `put` 方法的相反。它不是将 `is_publish` 设置为 `true`，而是将其设置为 `false` 以取消发布食谱。'
- en: You can also see that we are using these methods in a flexible manner; the `put`
    method is not necessarily for update, and the `delete` method is not necessarily
    for removal.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以看到我们以灵活的方式使用这些方法；`put` 方法不一定用于更新，`delete` 方法也不一定用于删除。
- en: 'The following table shows all the methods that we have created in this exercise.
    Now that we have all three resources ready (`RecipeListResource`, `RecipeResource`,
    and `RecipePublishResource`), we will discuss endpoint configuration:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了在本练习中我们创建的所有函数。现在我们已经准备好了所有三个资源（`RecipeListResource`、`RecipeResource` 和
    `RecipePublishResource`），我们将讨论端点配置：
- en: '![](img/C15309_02_08.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/C15309_02_08.jpg)'
- en: 'Figure 2.8: Methods that we used in this exercise'
  id: totrans-104
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2.8：本练习中使用的函数
- en: Note
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: If the client request is with an HTTP verb that has no corresponding handling
    method in the resource, Flask-RESTful will return the HTTP status code **405 Method
    Not Allowed**.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端请求使用在资源中没有相应处理方法的 HTTP 动词，Flask-RESTful 将返回 HTTP 状态码 **405 方法不允许**。
- en: Configuring Endpoints
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置端点
- en: Now that we have defined all our resources, we will set up some endpoints so
    that users can send requests to them. These endpoints can be accessed by the users
    and are connected to specific resources. We will be using the `add_resource` method
    on the API object to specify the URL for these endpoints and route the client
    HTTP request to our resources.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了所有资源，我们将设置一些端点，以便用户可以向它们发送请求。这些端点可供用户访问，并连接到特定资源。我们将使用 API 对象上的 `add_resource`
    方法来指定这些端点的 URL，并将客户端 HTTP 请求路由到我们的资源。
- en: For example, the `api.add_resource(RecipeListResource, '/recipes')` syntax is
    used to link the route (relative URL path) to `RecipeListResource` so that HTTP
    requests will be directed to this resource. Depending on the HTTP verb (for example,
    `GET`, and `POST`), the request will be handled by the corresponding methods in
    the resource accordingly.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`api.add_resource(RecipeListResource, '/recipes')` 语法用于将路由（相对 URL 路径）链接到
    `RecipeListResource`，以便 HTTP 请求将指向此资源。根据 HTTP 动词（例如，`GET` 和 `POST`），请求将由资源中的相应方法相应处理。
- en: 'Exercise 10: Creating the Main Application File'
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 10：创建主应用程序文件
- en: 'In this exercise, we will create our `app.py` file, which will be our main
    application file. We will set up Flask and initialize our `flask_restful.API`
    there. Finally, we will set up the endpoints so that users can send requests to
    our backend services. Let''s get started:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建我们的 `app.py` 文件，这是我们主要的应用程序文件。我们将在那里设置 Flask 并初始化我们的 `flask_restful.API`。最后，我们将设置端点，以便用户可以向我们的后端服务发送请求。让我们开始吧：
- en: Create the `app.py` file under the project folder.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目文件夹下创建 `app.py` 文件。
- en: 'Import the necessary classes using the following code:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码导入必要的类：
- en: '[PRE12]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Set up Flask and initialize `flask_restful.API` with our Flask app:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们的 Flask 应用设置 Flask 并初始化 `flask_restful.API`：
- en: '[PRE13]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add resource routing by passing in the URL so that it will route to our resources.
    Each resource will have its own HTTP method defined:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过传递 URL 来添加资源路由，以便它将路由到我们的资源。每个资源都将定义其自己的 HTTP 方法：
- en: '[PRE14]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: In `RecipeListResource`, we have defined the `get` and `post` methods. So, when
    there is a GET HTTP request to the "/recipes" URL route, it will invoke the `get`
    method under `RecipeListResource` and get back all the published recipes.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `RecipeListResource` 中，我们定义了 `get` 和 `post` 方法。因此，当有 GET HTTP 请求到 "/recipes"
    URL 路由时，它将调用 `RecipeListResource` 下的 `get` 方法，并获取所有已发布的食谱。
- en: 'In the preceding code, you will notice that we have used `<int: recipe_id >`
    in the code. It is there as a placeholder for the recipe ID. When a GET HTTP request
    has been sent to the `route "/recipes/2"` URL, this will invoke the get method
    under `RecipeResource` with a parameter, that is, `recipe_id = 2`.'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '在前面的代码中，你会注意到我们使用了 `<int: recipe_id >`。它在代码中作为食谱 ID 的占位符。当向 `route "/recipes/2"`
    URL 发送 GET HTTP 请求时，这将调用 `RecipeResource` 下的 get 方法，带有参数，即 `recipe_id = 2`。'
- en: 'Save `app.py` and *right-click* on it to run the application. Flask will then
    start up and run on the localhost (`127.0.0.1`) at port `5000`:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存 `app.py` 文件，然后右键单击它以运行应用程序。Flask 将在 localhost (`127.0.0.1`) 的端口 `5000` 上启动并运行：
- en: '![](img/C15309_02_09.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/C15309_02_09.jpg)'
- en: 'Figure 2.9: Flask started and running on localhost'
  id: totrans-124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2.9：Flask 在 localhost 上启动并运行
- en: Congratulations! You have completed the API endpoint. Now, let's move on to
    testing. You can either test it in curl/httpie or Postman.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经完成了 API 端点。现在，让我们继续进行测试。你可以在 curl/httpie 或 Postman 中进行测试。
- en: Making HTTP Requests to the Flask API using curl and httpie
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 curl 和 httpie 向 Flask API 发送 HTTP 请求
- en: Now, we are going to use the `httpie` and `curl` commands to test our API endpoints.
    We will test the functions for getting all the recipes back from the server and
    create/update/delete, publish, and unpublish the recipes. The best way to learn
    this is to complete a hands-on exercise. Let's get started!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用 `httpie` 和 `curl` 命令来测试我们的 API 端点。我们将测试从服务器获取所有食谱的函数以及创建/更新/删除、发布和取消发布的食谱。学习这个的最佳方式是通过动手练习。让我们开始吧！
- en: 'Exercise 11: Testing the Endpoints Using curl and httpie'
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 11：使用 curl 和 httpie 测试端点
- en: 'In this exercise, we are going to use the httpie and curl commands to send
    requests to the endpoints so that we can create our first recipe. We want you
    to get comfortable using the httpie and curl command-line testing tool. Let''s
    get started:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用 httpie 和 curl 命令向端点发送请求，以便我们可以创建我们的第一个食谱。我们希望你能够熟悉使用 httpie 和 curl
    命令行测试工具。让我们开始吧：
- en: 'Open the Terminal in PyCharm and type in the following commands. You can use
    either the httpie or curl command. The following is the httpie command (`= is
    for string and := is for non-string`):'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 PyCharm 中打开终端并输入以下命令。你可以使用 httpie 或 curl 命令。以下是一个 httpie 命令（`= 是字符串，:= 是非字符串`）：
- en: '[PRE15]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following is the curl command. The `-H` argument is used to specify the
    header in the client request. We will set `Content-Type: application/json` as
    the header here. The `-d` argument is used for HTTP POST data, that is, the recipe
    in JSON format:'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '以下是一个 curl 命令。`-H` 参数用于指定客户端请求中的头信息。在这里，我们将设置 `Content-Type: application/json`
    作为头信息。`-d` 参数用于 HTTP POST 数据，即 JSON 格式的食谱：'
- en: '[PRE16]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Examine the response, you should see the following. Carefully examine it, it
    should be the same recipe as the one that was used in our request in *Step 1*:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查响应，你应该看到以下内容。仔细检查它，它应该与我们在 *步骤 1* 中请求的相同食谱：
- en: '[PRE17]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Once the client request has been sent to the server using the HTTP `POST` method,
    the `post` method in `RecipeResource` will pick up the request and save the recipe
    in the request to the application memory. The new recipe will be appended in `recipe_list`.
    Once everything is done, it will return HTTP `201 CREATED` and the newly created
    recipe in JSON format.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦使用 HTTP `POST` 方法将客户端请求发送到服务器，`RecipeResource` 中的 `post` 方法将捕获请求并将食谱保存到应用程序内存中。新的食谱将被追加到
    `recipe_list` 中。一旦完成所有操作，它将返回 HTTP `201 CREATED` 状态码和以 JSON 格式的新创建的食谱。
- en: We have successfully created our first recipe on the platform. This recipe is
    stored on the server-side and we already have the API to retrieve it. Let's continue
    by creating our second recipe and retrieving all our recipes in one go.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在平台上成功创建了第一个食谱。这个食谱存储在服务器端，我们已经有获取它的 API。让我们继续创建第二个食谱并一次性检索所有食谱。
- en: 'Exercise 12: Testing the Auto-Incremented Recipe ID'
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 12：测试自动递增的食谱 ID
- en: 'Now that we have implemented the auto-incremented ID in our Smilecook application,
    let''s see how it works in practice. In this exercise, we will create the second
    recipe using the httpie and curl commands. Note that the ID is auto- incremented
    for our second recipe. Let''s get started:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在 Smilecook 应用程序中实现了自动递增的 ID，让我们看看它在实际中是如何工作的。在这个练习中，我们将使用 httpie 和 curl
    命令创建第二个食谱。注意，第二个食谱的 ID 会自动递增。让我们开始吧：
- en: 'Create a second recipe and note that the ID is automatically incremented. Send
    the following client request using httpie:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第二个食谱并注意 ID 会自动递增。使用 httpie 发送以下客户端请求：
- en: '[PRE18]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Alternatively, send the request using curl. Again, the `-H` argument is used
    to specify the header in the client request. We will set "`Content-Type: application/json`"
    as the header here. The `-d` argument is used for HTTP POST data, meaning that
    the recipe is in JSON format:'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '或者，使用 curl 发送请求。同样，`-H` 参数用于指定客户端请求中的头部。这里我们将设置 `"Content-Type: application/json"`
    作为头部。`-d` 参数用于 HTTP POST 数据，意味着食谱是以 JSON 格式：'
- en: '[PRE19]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You should see the following response. Examine it carefully, it should be the
    same recipe as the one that was used in our request in *Step 1*:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到以下响应。仔细检查它，它应该与我们在 *步骤 1* 中请求的相同食谱：
- en: '[PRE20]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Once the preceding client request has been sent to the server using the HTTP
    `POST` method, the `post` method in `RecipeResource` will pick up the request
    and save the recipe in the request to the application memory. The new recipe will
    be appended in `recipe_list`. This time, the ID will be automatically assigned
    to 2.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦使用 HTTP `POST` 方法将前面的客户端请求发送到服务器，`RecipeResource` 中的 `post` 方法将捕获请求并将食谱保存到应用程序内存中。新的食谱将被追加到
    `recipe_list` 中。这次，ID 将自动分配为 2。
- en: 'Exercise 13: Getting All the Recipes Back'
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 13：获取所有食谱
- en: 'In this exercise, we will be using the httpie and curl commands to get back
    all the recipes that we have created. We are doing this to ensure that our recipes
    are there in the backend server. Let''s get started:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用 httpie 和 curl 命令检索我们创建的所有食谱。我们这样做是为了确保我们的食谱在后端服务器上。让我们开始吧：
- en: 'Retrieve all the recipes by sending the following client request using httpie:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用 httpie 发送以下客户端请求来检索所有食谱：
- en: '[PRE21]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Alternatively, send the following request using curl. The `-i` argument is
    used to state that we want to see the response header. `-X GET` means that we
    are sending the client request using the HTTP `GET` method:'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，使用 curl 发送以下请求。`-i` 参数用于表示我们想要看到响应头部。`-X GET` 表示我们正在使用 HTTP `GET` 方法发送客户端请求：
- en: '[PRE22]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You should see the following response. Please examine it carefully:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到以下响应。请仔细检查：
- en: '[PRE23]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Once the preceding client request has been sent to the server using the HTTP
    GET method, the get method in `RecipeResource` will pick up the request and retrieve
    all the published recipes from `recipe_list` in the application memory.
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦使用 HTTP GET 方法将前面的客户端请求发送到服务器，`RecipeResource` 中的 `get` 方法将捕获请求并从应用程序内存中的
    `recipe_list` 中检索所有已发布的食谱。
- en: Note
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: We should see an empty list in the HTTP response because all the recipes we
    have created in the previous steps are in draft form (not published).
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们应该在 HTTP 响应中看到一个空列表，因为我们之前步骤中创建的所有食谱都是草稿形式（未发布）。
- en: 'Exercise 14: Testing the Recipe Resources'
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 14：测试食谱资源
- en: 'We have already tested the endpoints we built around the recipe resources.
    In this exercise, we will continue to use the httpie and curl commands to test
    the recipe publishing API. We can test it by sending requests asking to publish
    our recipes on the API endpoint. Let''s get started:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经测试了我们围绕食谱资源构建的端点。在这个练习中，我们将继续使用httpie和curl命令来测试食谱发布API。我们可以通过向API端点发送请求来发布我们的食谱来测试它。让我们开始吧：
- en: 'Modify the publish status of the recipe with ID 1\. We can send the following
    client request using the httpie command:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改ID为1的食谱的发布状态。我们可以使用httpie命令发送以下客户端请求：
- en: '[PRE24]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Alternatively, we can use the following curl command:'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，我们可以使用以下curl命令：
- en: '[PRE25]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Once the preceding client request has been sent to the server using the HTTP
    PUT method, the `put` method in `RecipePublishResource` will pick up the request
    and assign `recipe_id` to be 1\. The application will look for the recipe with
    `ID = 1` and update its publish status to `True`.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦使用HTTP PUT方法将前面的客户端请求发送到服务器，`RecipePublishResource`中的`put`方法将接收到请求并将`recipe_id`设置为1。应用程序将寻找ID为`1`的食谱并更新其发布状态为`True`。
- en: 'You should see the following response. Please examine it carefully:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到以下响应。请仔细检查：
- en: '[PRE26]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, retrieve all the published recipes and examine them. Then, send the following
    client request using httpie:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，检索所有已发布的食谱并检查它们。然后，使用httpie发送以下客户端请求：
- en: '[PRE27]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Alternatively, send the following request using curl. The `-i` argument is
    used to say that we want to see the response header. `-X GET` means that we are
    sending the client request using the HTTP GET method:'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，使用curl发送以下请求。`-i`参数表示我们想要看到响应头。`-X GET`表示我们正在使用HTTP GET方法发送客户端请求：
- en: '[PRE28]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You should see the following response. Please examine it carefully:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到以下响应。请仔细检查：
- en: '[PRE29]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Once the preceding client request has been sent to the server using the HTTP
    `GET` method, the get method in `RecipeResource` will pick up the request and
    retrieve all the published recipes from `recipe_list` in the application memory.
    This time, because the recipe with ID 1 has been set to publish, we shall see
    it in the HTTP response.
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦使用HTTP `GET`方法将前面的客户端请求发送到服务器，`RecipeResource`中的get方法将接收到请求并从应用程序内存中的`recipe_list`检索所有已发布的食谱。这次，因为ID为1的食谱已被设置为发布，所以我们应该在HTTP响应中看到它。
- en: 'Exercise 15: Negative Testing'
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习15：负面测试
- en: 'In the previous exercise, we successfully published our recipe. This is good
    because it shows us that the APIs that we''ve developed work. But the whole point
    of testing is to discover potential issues if any. We can perform so-called negative
    testing here. This is the process of deliberately testing the scenario with unwanted
    input. This exercise is going to test a request with an HTTP VERB that has no
    corresponding method defined in the resource. Let''s get started:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们成功发布了我们的食谱。这是好事，因为它表明我们开发的API是有效的。但测试的全部目的是发现潜在的问题（如果有的话）。我们在这里可以执行所谓的负面测试。这是故意使用不想要的输入测试场景的过程。这个练习将测试一个没有在资源中定义相应方法的HTTP动词的请求。让我们开始吧：
- en: 'Send the following request to the server-side. This HTTP method has not been
    defined; let''s see what happens:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向服务器发送以下请求。这个HTTP方法尚未定义；让我们看看会发生什么：
- en: '[PRE30]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following is the curl command, which does the same thing:'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是一个curl命令，它执行相同的事情：
- en: '[PRE31]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You should see the following response. Please examine it carefully:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到以下响应。请仔细检查：
- en: '[PRE32]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We should see a response with an HTTP status of `RecipeListResource`.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们应该看到一个带有`RecipeListResource` HTTP状态的响应。
- en: Negative testing is important. We always want our testing to be more complete
    and covers more scenarios.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 负面测试很重要。我们总是希望我们的测试更加完整，覆盖更多场景。
- en: 'Exercise 16: Modifying the Recipes'
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习16：修改食谱
- en: 'In our Smilecook application, authors are allowed to update their recipes.
    It is like a blogging platform, where the authors can take their time to perfect
    their work, even after it has been published. Since we have already built the
    API, we would like to test it using Postman. Let''s get started:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Smilecook应用程序中，作者被允许更新他们的食谱。它就像一个博客平台，作者可以在发布后花时间完善他们的作品。由于我们已经构建了API，我们希望使用Postman来测试它。让我们开始吧：
- en: 'Use the PUT method to send the request to `localhost:5000/recipes/1`, along
    with the new recipe details:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用PUT方法向`localhost:5000/recipes/1`发送请求，并附带新的食谱详情：
- en: '[PRE33]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Alternatively, send the following request using curl. The `-H` argument is
    used to specify the header in the client request. We will set "`Content-Type:
    application/json`" as the header here. The `-d` argument is used for HTTP POST
    data, meaning that the recipe will be in JSON format:'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '或者，使用 curl 发送以下请求。`-H` 参数用于指定客户端请求中的头信息。在这里，我们将设置头信息为 "`Content-Type: application/json`"。`-d`
    参数用于 HTTP POST 数据，意味着菜谱将以 JSON 格式存在：'
- en: '[PRE34]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You should see the following response. Please examine it carefully:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该会看到以下响应。请仔细检查：
- en: '[PRE35]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Once the preceding client request has been sent to the server using the HTTP
    PUT method, the `put` method in `RecipeResource` will pick up the request and
    assign `recipe_id` to be 1\. The application will look for the recipe with `id
    = 1` and update its details with those in the client request. The preceding response
    shows that the recipe with ID 1 is modified.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦使用 HTTP PUT 方法将前面的客户端请求发送到服务器，`RecipeResource` 中的 `put` 方法将捕获请求并将 `recipe_id`
    赋值为 1。应用程序将寻找 `id = 1` 的菜谱并使用客户端请求中的详细信息更新其详情。前面的响应显示，ID 为 1 的菜谱已被修改。
- en: We just finished testing another important feature. You have been doing great.
    Let's keep going!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚测试了另一个重要功能。你做得很好。让我们继续前进！
- en: 'Exercise 17: Getting Back Specific Recipes with a Certain ID'
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 17：通过特定 ID 获取特定菜谱
- en: 'So far, we have tested getting all the recipes back. But in the real world,
    a user will want to only get the recipes that they want to see. They can do this
    by using the recipe ID. This exercise will show you how to get a particular recipe
    with a certain ID. Let''s get started:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经测试了获取所有菜谱。但在现实生活中，用户可能只想获取他们想看的菜谱。他们可以通过使用菜谱 ID 来做到这一点。这个练习将向你展示如何获取具有特定
    ID 的特定菜谱。让我们开始吧：
- en: 'Send the following client request using httpie:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 httpie 发送以下客户端请求：
- en: '[PRE36]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Alternatively, use the following curl command, which does the same thing:'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，使用以下 curl 命令，它做的是同样的事情：
- en: '[PRE37]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Once the preceding client request has been sent to the server using the HTTP
    `GET` method, the get method in `RecipeResource` will pick up the request and
    assign `recipe_id` to be 1\. It will retrieve all the published recipes from `recipe_list`
    in the application memory with an HTTP status of HTTP `200`.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦使用 HTTP `GET` 方法将前面的客户端请求发送到服务器，`RecipeResource` 中的 get 方法将捕获请求并将 `recipe_id`
    赋值为 1。它将从应用程序内存中的 `recipe_list` 获取所有已发布的菜谱，HTTP 状态为 HTTP `200`。
- en: We have just tested our Smilecook application and confirmed that it can give
    us back the recipe we want.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚测试了我们的 Smilecook 应用程序，并确认它可以给我们返回我们想要的菜谱。
- en: 'Activity 3: Testing the APIs Using Postman'
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 3：使用 Postman 测试 API
- en: 'We added quite a few functions in the previous exercise. Now, we need to make
    sure that they work properly before we move on and develop other functions. In
    this activity, instead of using httpie/curl, we will be testing our API using
    Postman. Please follow these high-level steps:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的练习中，我们添加了相当多的功能。现在，在我们继续开发其他功能之前，我们需要确保它们能正常工作。在这个活动中，我们不会使用 httpie/curl，而是将使用
    Postman 来测试我们的 API。请按照以下高级步骤进行：
- en: Create the first recipe using Postman.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Postman 创建第一个菜谱。
- en: Create the second recipe using Postman.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Postman 创建第二个菜谱。
- en: Retrieve all the recipes using Postman.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Postman 获取所有菜谱。
- en: Set the recipes to published using Postman.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Postman 将菜谱设置为已发布。
- en: Retrieve all the recipes using Postman again.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用 Postman 获取所有菜谱。
- en: Modify the recipe using Postman.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Postman 修改菜谱。
- en: Get a specific recipe back using Postman.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Postman 获取特定菜谱。
- en: Note
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 293.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第 293 页找到。
- en: 'Activity 4: Implementing the Delete Recipe Function'
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 4：实现删除菜谱功能
- en: 'In this activity, you will implement the delete recipe function in the Smilecook
    application yourself. Do this by adding a delete function to `RecipeResource`,
    similar to what we did in the previous exercises. Then, we will follow the standard
    software development life cycle flow, which is used to test our implementation,
    using Postman. Follow these steps to complete this activity:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你将自己在 Smilecook 应用程序中实现删除菜谱功能。通过向 `RecipeResource` 添加删除功能，类似于我们在前面的练习中所做的。然后，我们将遵循标准的软件开发生命周期流程，使用
    Postman 来测试我们的实现。按照以下步骤完成此活动：
- en: Add the delete function to `RecipeResource`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将删除功能添加到 `RecipeResource`。
- en: Start up the Flask server for testing.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Flask 服务器进行测试。
- en: Create the first recipe using Postman.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Postman 创建第一个菜谱。
- en: Delete the recipe using Postman.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Postman 删除菜谱。
- en: Note
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 299.
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以在第 299 页找到。
- en: Summary
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we built the RESTful API using the Flask-RESTful package. By
    doing this, you have seen how simple and easy it is to perform such tasks. We
    are building our project in a structural manner, which allows us to easily extend
    the project in the subsequent chapters. In this chapter, we created the models
    and resources folder; we will be developing more models and resources later in
    this book. So far, our food recipe-sharing platform, Smilecook, is capable of
    performing CRUD, as well as setting the publish status of the recipe. We have
    also tested the application to make sure it is working properly. Finally, you
    started to realize the power of Postman, which greatly automates the whole testing
    process. In the next chapter, we will learn about how to perform data validation.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用 Flask-RESTful 包构建了 RESTful API。通过这样做，您已经看到了执行此类任务是多么简单和容易。我们以结构化的方式构建项目，这使得我们能够在后续章节中轻松扩展项目。在本章中，我们创建了模型和资源文件夹；本书后面我们将开发更多模型和资源。到目前为止，我们的美食食谱分享平台
    Smilecook 能够执行 CRUD 操作，以及设置食谱的发布状态。我们还测试了应用程序，以确保其正常运行。最后，您开始意识到 Postman 的强大功能，它极大地自动化了整个测试过程。在下一章中，我们将学习如何进行数据验证。
