- en: Chapter 5. Working with Audios
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 音频处理
- en: Decades ago, silent movies lit up the screen but later, it was audio effect
    that brought life into them. We deal with digital audio processing quite frequently
    when just playing a CD track, recording your own voice or converting songs into
    a different audio format. There are many libraries or multimedia frameworks available
    for audio processing. This chapter teaches some common digital audio processing
    techniques using Python bindings of a popular multimedia framework called GStreamer.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 几十年前，无声电影照亮了银幕，但后来，是音频效果让它们变得生动。在播放CD曲目、录制自己的声音或将歌曲转换为不同的音频格式时，我们经常处理数字音频处理。有许多库或多媒体框架可用于音频处理。本章将使用名为GStreamer的流行多媒体框架的Python绑定介绍一些常见的数字音频处理技术。
- en: 'In this chapter, we shall:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Learn basic concepts behind GStreamer multimedia framework
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习GStreamer多媒体框架背后的基本概念
- en: Use GStreamer API for audio processing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GStreamer API进行音频处理
- en: Develop some simple audio processing tools for 'everyday use'. We will develop
    tools that will batch convert audio file formats, record an audio, and play audio
    files
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一些简单的音频处理工具用于“日常使用”。我们将开发能够批量转换音频文件格式、录制音频和播放音频文件的工具
- en: So let's get on with it!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧！
- en: Installation prerequisites
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装必备条件
- en: Since we are going to use an external multimedia framework, it is necessary
    to install the packages mentioned in this section.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用外部多媒体框架，因此有必要安装本节中提到的软件包。
- en: GStreamer
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GStreamer
- en: GStreamer is a popular open source multimedia framework that supports audio/video
    manipulation of a wide range of multimedia formats. It is written in the C programming
    language and provides bindings for other programming languages including Python.
    Several open source projects use GStreamer framework to develop their own multimedia
    application. Throughout this chapter, we will make use of the GStreamer framework
    for audio handling. In order to get this working with Python, we need to install
    both GStreamer and the Python bindings for GStreamer.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: GStreamer是一个流行的开源多媒体框架，支持广泛的多媒体格式的音频/视频操作。它用C编程语言编写，并为包括Python在内的其他编程语言提供了绑定。许多开源项目使用GStreamer框架来开发自己的多媒体应用程序。在本章中，我们将使用GStreamer框架进行音频处理。为了与Python一起使用，我们需要安装GStreamer及其Python绑定。
- en: Windows platform
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows平台
- en: 'The binary distribution of GStreamer is not provided on the project website
    [http://www.gstreamer.net/](http://www.gstreamer.net/). Installing it from the
    source may require considerable effort on the part of Windows users. Fortunately,
    *GStreamer WinBuilds* project provides pre-compiled binary distributions. Here
    is the URL to the project website: [http://www.gstreamer-winbuild.ylatuya.es](http://www.gstreamer-winbuild.ylatuya.es)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: GStreamer的二进制发行版在项目网站[http://www.gstreamer.net/](http://www.gstreamer.net/)上未提供。从源代码安装可能需要Windows用户付出相当大的努力。幸运的是，*GStreamer
    WinBuilds*项目提供了预编译的二进制发行版。以下是项目网站的URL：[http://www.gstreamer-winbuild.ylatuya.es](http://www.gstreamer-winbuild.ylatuya.es)
- en: 'The binary distribution for GStreamer as well as its Python bindings (Python
    2.6) are available in the **Download** area of the website: [http://www.gstreamer-winbuild.ylatuya.es/doku.php?id=download](http://www.gstreamer-winbuild.ylatuya.es/doku.php?id=download)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: GStreamer的二进制发行版以及其Python绑定（Python 2.6）可在网站上的**下载**区域找到：[http://www.gstreamer-winbuild.ylatuya.es/doku.php?id=download](http://www.gstreamer-winbuild.ylatuya.es/doku.php?id=download)
- en: You need to install two packages. First, the GStreamer and then the Python bindings
    to the GStreamer. Download and install the GPL distribution of GStreamer available
    on the GStreamer WinBuilds project website. The name of the GStreamer executable
    is `GStreamerWinBuild-0.10.5.1.exe`. The version should be 0.10.5 or higher. By
    default, this installation will create a folder [C:\gstreamer](http://C:%5Cgstreamer)
    on your machine. The `bin` directory within this folder contains runtime libraries
    needed while using GStreamer.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装两个软件包。首先，安装GStreamer，然后安装GStreamer的Python绑定。从GStreamer WinBuilds项目网站下载并安装GStreamer的GPL发行版。GStreamer可执行文件名为`GStreamerWinBuild-0.10.5.1.exe`。版本应为0.10.5或更高。默认情况下，此安装将在您的机器上创建一个文件夹[C:\gstreamer](http://C:%5Cgstreamer)。该文件夹中的`bin`目录包含使用GStreamer时所需的运行时库。
- en: Next, install the Python bindings for GStreamer. The binary distribution is
    available on the same website. Use the executable `Pygst-0.10.15.1-Python2.6.exe`
    pertaining to Python 2.6\. The version should be 0.10.15 or higher.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，安装 GStreamer 的 Python 绑定。二进制分发可在同一网站上找到。使用适用于 Python 2.6 的可执行文件 `Pygst-0.10.15.1-Python2.6.exe`。版本应为
    0.10.15 或更高。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: GStreamer WinBuilds appears to be an independent project. It is based on the
    OSSBuild developing suite. Visit [http://code.google.com/p/ossbuild/](http://code.google.com/p/ossbuild/)
    for more information. It could happen that the GStreamer binary built with Python
    2.6 is no longer available on the mentioned website at the time you are reading
    this book. Therefore, it is advised that you should contact the developer community
    of OSSBuild. Perhaps they might help you out!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: GStreamer WinBuilds 似乎是一个独立的项目。它基于 OSSBuild 开发套件。有关更多信息，请访问 [http://code.google.com/p/ossbuild/](http://code.google.com/p/ossbuild/)。可能发生的情况是，使用
    Python 2.6 构建的 GStreamer 二进制文件在您阅读此书时可能不再在提到的网站上可用。因此，建议您联系 OSSBuild 的开发者社区。也许他们可以帮助您解决问题！
- en: Alternatively, you can build GStreamer from source on the Windows platform,
    using a Linux-like environment for Windows, such as Cygwin (http://www.cygwin.com/).
    Under this environment, you can first install dependent software packages such
    as Python 2.6, gcc compiler, and others. Download the `gst-python-0.10.17.2.tar.gz`
    package from the GStreamer website [http://www.gstreamer.net/](http://www.gstreamer.net/).
    Then extract this package and install it from sources using the Cygwin environment.
    The `INSTALL` file within this package will have installation instructions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以在 Windows 平台上从源代码构建 GStreamer，使用类似 Linux 的 Windows 环境，如 Cygwin（http://www.cygwin.com/）。在此环境中，您可以首先安装依赖软件包，如
    Python 2.6、gcc 编译器等。从 GStreamer 网站 [http://www.gstreamer.net/](http://www.gstreamer.net/)
    下载 `gst-python-0.10.17.2.tar.gz` 软件包。然后提取此软件包，并使用 Cygwin 环境从源代码安装它。此软件包内的 `INSTALL`
    文件将包含安装说明。
- en: Other platforms
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他平台
- en: Many of the Linux distributions provide GStreamer package. You can search for
    the appropriate `gst-python` distribution (for Python 2.6) in the package repository.
    If such a package is not available, install `gst-python` from the source as discussed
    in the earlier the *Windows platform* section.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Linux 发行版都提供 GStreamer 软件包。您可以在软件包仓库中搜索适当的 `gst-python` 发行版（针对 Python 2.6）。如果此类软件包不可用，可以从源代码安装
    `gst-python`，如前文所述的 *Windows 平台* 部分所述。
- en: If you are a Mac OS X user, visit [http://py26-gst-python.darwinports.com/](http://py26-gst-python.darwinports.com/).
    It has detailed instructions on how to download and install the package `Py26-gst-python
    version 0.10.17` (or higher).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是 Mac OS X 用户，请访问 [http://py26-gst-python.darwinports.com/](http://py26-gst-python.darwinports.com/)。它提供了关于如何下载和安装
    `Py26-gst-python 版本 0.10.17`（或更高版本）的详细说明。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Mac OS X 10.5.x (Leopard) comes with the Python 2.5 distribution. If you are
    using packages using this default version of Python, GStreamer Python bindings
    using Python 2.5 are available on the darwinports website: [http://gst-python.darwinports.com/](http://gst-python.darwinports.com/)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Mac OS X 10.5.x（Leopard）自带 Python 2.5 发行版。如果您使用的是使用此默认 Python 版本的软件包，可以在 darwinports
    网站上找到使用 Python 2.5 的 GStreamer Python 绑定：[http://gst-python.darwinports.com/](http://gst-python.darwinports.com/)
- en: PyGobject
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PyGobject
- en: 'There is a free multiplatform software utility library called ''GLib''. It
    provides data structures such as hash maps, linked lists, and so on. It also supports
    the creation of threads. The ''object system'' of GLib is called **GObject**.
    Here, we need to install the Python bindings for GObject. The Python bindings
    are available on the PyGTK website at: [http://www.pygtk.org/downloads.html](http://www.pygtk.org/downloads.html).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为 'GLib' 的免费多平台软件库。它提供诸如哈希表、链表等数据结构。它还支持线程的创建。GLib 的 '对象系统' 被称为 **GObject**。在这里，我们需要安装
    GObject 的 Python 绑定。Python 绑定可在 PyGTK 网站上找到：[http://www.pygtk.org/downloads.html](http://www.pygtk.org/downloads.html)。
- en: Windows platform
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows 平台
- en: 'The binary installer is available on the PyGTK website. The complete URL is:
    [http://ftp.acc.umu.se/pub/GNOME/binaries/win32/pygobject/2.20/](http://ftp.acc.umu.se/pub/GNOME/binaries/win32/pygobject/2.20/).
    Download and install version 2.20 for Python 2.6.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制安装程序可在 PyGTK 网站上找到。完整的网址是：[http://ftp.acc.umu.se/pub/GNOME/binaries/win32/pygobject/2.20/](http://ftp.acc.umu.se/pub/GNOME/binaries/win32/pygobject/2.20/)。下载并安装
    Python 2.6 的 2.20 版本。
- en: Other platforms
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他平台
- en: 'For Linux, the source tarball is available on the PyGTK website. There could
    even be binary distribution in the package repository of your Linux operating
    system. The direct link to the Version 2.21 of PyGObject (source tarball) is:
    [http://ftp.gnome.org/pub/GNOME/sources/pygobject/2.21/](http://ftp.gnome.org/pub/GNOME/sources/pygobject/2.21/).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Linux系统，源代码tar包可以在PyGTK网站上找到。甚至可能存在于您Linux操作系统的软件包仓库中的二进制发行版。PyGObject版本2.21（源代码tar包）的直接链接是：[http://ftp.gnome.org/pub/GNOME/sources/pygobject/2.21/](http://ftp.gnome.org/pub/GNOME/sources/pygobject/2.21/).
- en: If you are a Mac user and you have Python 2.6 installed, a distribution of PyGObject
    is available at [http://py26-gobject.darwinports.com/](http://py26-gobject.darwinports.com/).
    Install version 2.14 or later.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是Mac用户并且已安装Python 2.6，PyGObject的发行版可在[http://py26-gobject.darwinports.com/](http://py26-gobject.darwinports.com/)找到。安装2.14或更高版本。
- en: Summary of installation prerequisites
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装前提条件摘要
- en: The following table summarizes the packages needed for this chapter.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了本章所需的软件包。
- en: '| Package | Download location | Version | Windows platform | Linux/Unix/OS
    X platforms |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 软件包 | 下载位置 | 版本 | Windows平台 | Linux/Unix/OS X平台 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| GStreamer | [http://www.gstreamer.net/](http://www.gstreamer.net/) | 0.10.5
    or later | Install using binary distribution available on the Gstreamer WinBuild
    website:[http://www.gstreamer-winbuild.ylatuya.es/doku.php?id=download](http://www.gstreamer-winbuild.ylatuya.es/doku.php?id=download)Use
    `GStreamerWinBuild-0.10.5.1.exe` (or later version if available). | Linux: Use
    GStreamer distribution in package repository.Mac OS X: Download and install by
    following instructions on the website: [http://gstreamer.darwinports.com/](http://gstreamer.darwinports.com/).
    |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| GStreamer | [http://www.gstreamer.net/](http://www.gstreamer.net/) | 0.10.5或更高版本
    | 使用Gstreamer WinBuild网站上的二进制发行版进行安装：[http://www.gstreamer-winbuild.ylatuya.es/doku.php?id=download](http://www.gstreamer-winbuild.ylatuya.es/doku.php?id=download)
    使用`GStreamerWinBuild-0.10.5.1.exe`（或更高版本，如果可用）。 | Linux：使用软件包仓库中的GStreamer发行版。Mac
    OS X：按照网站上的说明下载和安装：[http://gstreamer.darwinports.com/](http://gstreamer.darwinports.com/).
    |'
- en: '| Python Bindings for GStreamer | [http://www.gstreamer.net/](http://www.gstreamer.net/)
    | 0.10.15 or later for Python 2.6 | Use binary provided by GStreamer WinBuild
    project. See [http://www.gstreamer-winbuild.ylatuya.es](http://www.gstreamer-winbuild.ylatuya.es)
    for details pertaining to Python 2.6. | Linux: Use gst-python distribution in
    the package repository.Mac OS X: Use this package (if you are using Python2.6):
    [http://py26-gst-python.darwinports.com/](http://py26-gst-python.darwinports.com/).Linux/Mac:
    Build and install from the source tarball. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| GStreamer的Python绑定 | [http://www.gstreamer.net/](http://www.gstreamer.net/)
    | Python 2.6的0.10.15或更高版本 | 使用GStreamer WinBuild项目提供的二进制文件。有关Python 2.6的详细信息，请参阅[http://www.gstreamer-winbuild.ylatuya.es](http://www.gstreamer-winbuild.ylatuya.es)。
    | Linux：使用软件包仓库中的gst-python发行版。Mac OS X：如果您使用Python 2.6，请使用此软件包。[http://py26-gst-python.darwinports.com/](http://py26-gst-python.darwinports.com/)有关详细信息。
    |'
- en: '| Python bindings for GObject "PyGObject" | Source distribution:[http://www.pygtk.org/downloads.html](http://www.pygtk.org/downloads.html)
    | 2.14 or later for Python 2.6 | Use binary package from`pygobject-2.20.0.win32-py2.6.exe`
    | Linux: Install from source if pygobject is not available in the package repository.Mac:
    Use this package on darwinports (if you are using Python2.6) See [http://py26-gobject.darwinports.com/](http://py26-gobject.darwinports.com/)
    for details. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| GObject的Python绑定“PyGObject” | 源代码发行版：[http://www.pygtk.org/downloads.html](http://www.pygtk.org/downloads.html)
    | Python 2.6的2.14或更高版本 | 使用`pygobject-2.20.0.win32-py2.6.exe`的二进制软件包。 | Linux：如果软件包仓库中没有pygobject，则从源代码安装。Mac：如果您使用Python
    2.6，请使用此软件包在darwinports上。[http://py26-gobject.darwinports.com/](http://py26-gobject.darwinports.com/)有关详细信息。
    |'
- en: Testing the installation
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装测试
- en: 'Ensure that the GStreamer and its Python bindings are properly installed. It
    is simple to test this. Just start Python from the command line and type the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 确保GStreamer及其Python绑定已正确安装。测试这一点很简单。只需从命令行启动Python，并输入以下内容：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If there is no error, it means the Python bindings are installed properly.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误，则表示Python绑定已正确安装。
- en: 'Next, type the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，输入以下内容：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If this import is successful, we are all set to use GStreamer for processing
    audios and videos!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此导入成功，那么我们就准备好使用GStreamer处理音频和视频了！
- en: If `import gst` fails, it will probably complain that it is unable to work some
    required DLL/shared object. In this case, check your environment variables and
    make sure that the PATH variable has the correct path to the `gstreamer/bin` directory.
    The following lines of code in a Python interpreter show the typical location
    of the `pygst` and `gst` modules on the Windows platform.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `import gst` 失败，它可能会抱怨它无法工作一些所需的 DLL/共享对象。在这种情况下，检查您的环境变量，并确保 PATH 变量包含 `gstreamer/bin`
    目录的正确路径。以下 Python 解释器中的代码行显示了 Windows 平台上 `pygst` 和 `gst` 模块的典型位置。
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, test if PyGObject is successfully installed. Start the Python interpreter
    and try importing the `gobject` module.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，测试 PyGObject 是否成功安装。启动 Python 解释器并尝试导入 `gobject` 模块。
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If this works, we are all set to proceed!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这成功了，我们就一切准备就绪了！
- en: A primer on GStreamer
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GStreamer 入门
- en: In this chapter, we will be using GStreamer multimedia framework extensively.
    Before we move on to the topics that teach us various audio processing techniques,
    a primer on GStreamer is necessary.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将广泛使用 GStreamer 多媒体框架。在我们学习各种音频处理技术之前，了解 GStreamer 的基础知识是必要的。
- en: So what is GStreamer? It is a framework on top of which one can develop multimedia
    applications. The rich set of libraries it provides makes it easier to develop
    applications with complex audio/video processing capabilities. Fundamental components
    of GStreamer are briefly explained in the coming sub-sections.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 GStreamer 是什么呢？它是一个框架，可以在其上开发多媒体应用程序。它提供的丰富库集使得开发具有复杂音频/视频处理能力的应用程序变得更加容易。GStreamer
    的基本组件将在接下来的小节中简要解释。
- en: 'Comprehensive documentation is available on the GStreamer project website.
    GStreamer Application Development Manual is a very good starting point. In this
    section, we will briefly cover some of the important aspects of GStreamer. For
    further reading, you are recommended to visit the GStreamer project website: [http://www.gstreamer.net/documentation/](http://www.gstreamer.net/documentation/)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: GStreamer 项目网站上有全面的文档。GStreamer 应用程序开发手册是一个非常好的起点。在本节中，我们将简要介绍 GStreamer 的一些重要方面。为了进一步阅读，建议您访问
    GStreamer 项目网站：[http://www.gstreamer.net/documentation/](http://www.gstreamer.net/documentation/)
- en: gst-inspect and gst-launch
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: gst-inspect 和 gst-launch
- en: We will start by learning the two important GStreamer commands. GStreamer can
    be run from the command line, by calling `gst-launch-0.10.exe` (on Windows) or
    `gst-launch-0.10` (on other platforms). The following command shows a typical
    execution of GStreamer on Linux. We will see what a `pipeline` means in the next
    sub-section.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先学习两个重要的 GStreamer 命令。GStreamer 可以通过命令行运行，通过调用 `gst-launch-0.10.exe`（Windows
    上）或 `gst-launch-0.10`（其他平台）。以下命令展示了 Linux 上 GStreamer 的典型执行。我们将在下一小节中看到 `pipeline`
    的含义。
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: GStreamer has a plugin architecture. It supports a huge number of plugins. To
    see more details about any plugin in your GStreamer installation, use the command
    `gst-inspect-0.10` (gst-inspect-0.10.exe on Windows). We will use this command
    quite often. Use of this command is illustrated here.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: GStreamer 具有插件架构。它支持大量的插件。要查看 GStreamer 安装中任何插件的更多详细信息，请使用命令 `gst-inspect-0.10`（Windows
    上的 `gst-inspect-0.10.exe`）。我们将经常使用此命令。此命令的使用在此处展示。
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, `decodebin` is a plugin. Upon execution of the preceding command, it prints
    detailed information about the plugin `decodebin`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`decodebin` 是一个插件。执行前面的命令后，它将打印有关插件 `decodebin` 的详细信息。
- en: Elements and pipeline
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元素和管道
- en: In GStreamer, the data flows in a pipeline. Various elements are connected together
    forming a pipeline, such that the output of the previous element is the input
    to the next one.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GStreamer 中，数据在管道中流动。各种元素连接在一起形成一个管道，使得前一个元素的输出成为下一个元素的输入。
- en: 'A pipeline can be logically represented as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 管道可以逻辑上表示如下：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, `Element1` through to `Element5` are the element objects chained together
    by the symbol `!`. Each of the elements performs a specific task. One of the element
    objects performs the task of reading input data such as an audio or a video. Another
    element decodes the file read by the first element, whereas another element performs
    the job of converting this data into some other format and saving the output.
    As stated earlier, linking these element objects in a proper manner creates a
    pipeline.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，从 `Element1` 到 `Element5` 是通过符号 `!` 连接起来的元素对象。每个元素执行特定的任务。其中一个元素对象负责读取输入数据，如音频或视频。另一个元素解码第一个元素读取的文件，而另一个元素则负责将数据转换为其他格式并保存输出。如前所述，以适当的方式链接这些元素对象创建了一个管道。
- en: The concept of a pipeline is similar to the one used in Unix. Following is a
    Unix example of a pipeline. Here, the vertical separator `|` defines the pipe.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 管道的概念与Unix中使用的类似。以下是一个Unix管道的示例。在这里，垂直分隔符 `|` 定义了管道。
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, the `ls -la` lists all the files in a directory. However, sometimes, this
    list is too long to be displayed in the shell window. So, adding `| more` allows
    a user to navigate the data.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ls -la` 列出了目录中的所有文件。然而，有时这个列表太长，无法在shell窗口中显示。因此，添加 `| more` 允许用户导航数据。
- en: Now let's see a realistic example of running GStreamer from the command prompt.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看从命令提示符运行GStreamer的现实示例。
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For a Windows user, the `gst` command name would be `gst-launch-0.10.exe`. The
    pipeline is constructed by specifying different elements. The `!symbol` links
    the adjacent elements, thereby forming the whole pipeline for the data to flow.
    For Python bindings of GStreamer, the abstract base class for pipeline elements
    is `gst.Element`, whereas `gst.Pipeline` class can be used to created pipeline
    instance. In a pipeline, the data is sent to a separate thread where it is processed
    until it reaches the end or a termination signal is sent.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows用户，`gst` 命令名称将是 `gst-launch-0.10.exe`。管道是通过指定不同的元素来构建的。`!symbol` 链接相邻的元素，从而形成整个数据流管道。对于GStreamer的Python绑定，管道元素的抽象基类是
    `gst.Element`，而 `gst.Pipeline` 类可以用来创建管道实例。在管道中，数据被发送到一个单独的线程进行处理，直到它到达末端或发送了终止信号。
- en: Plugins
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插件
- en: GStreamer is a plugin-based framework. There are several plugins available.
    A plugin is used to encapsulate the functionality of one or more GStreamer elements.
    Thus we can have a plugin where multiple elements work together to create the
    desired output. The plugin itself can then be used as an abstract element in the
    GStreamer pipeline. An example is `decodebin`. We will learn about it in the upcoming
    sections. A comprehensive list of available plugins is available at the GStreamer
    website [http://gstreamer.freedesktop.org](http://gstreamer.freedesktop.org).
    In this book, we will be using several of them to develop audio/video processing
    applications. For example, a plugin `Playbin` will be used for audio playback.
    In almost all applications to be developed, `decodebin` plugin will be used. For
    audio processing, the functionality provided by plugins such as `gnonlin, audioecho,
    monoscope, interleave`, and so on will be used.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: GStreamer是一个基于插件的框架。有多个插件可用。插件用于封装一个或多个GStreamer元素的功能。因此，我们可以有一个插件，其中多个元素协同工作以生成所需的输出。然后，该插件本身可以用作GStreamer管道中的抽象元素。例如，`decodebin`。我们将在接下来的章节中学习它。GStreamer网站上提供了可用的插件的综合列表
    [http://gstreamer.freedesktop.org](http://gstreamer.freedesktop.org)。在这本书中，我们将使用其中的一些来开发音频/视频处理应用程序。例如，将使用
    `Playbin` 插件进行音频播放。在几乎所有将要开发的应用程序中，都将使用 `decodebin` 插件。对于音频处理，将使用如 `gnonlin`、`audioecho`、`monoscope`、`interleave`
    等插件提供的功能。
- en: Bins
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 槽位
- en: In GStreamer, a bin is a container that manages the element objects added to
    it. A bin instance can be created using gst.Bin class. It is inherited from `gst.Element`
    and can act as an abstract element representing a bunch of elements within it.
    A GStreamer plugin decodebin is a good example representing a bin. The decodebin
    contains decoder elements. It auto-plugs the decoder to create the decoding pipeline.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在GStreamer中，bin是一个管理添加到其中的元素对象的容器。可以使用 `gst.Bin` 类创建bin实例。它继承自 `gst.Element`
    并可以作为表示其中的一组元素的抽象元素。GStreamer插件decodebin是一个很好的bin示例。decodebin包含解码器元素。它自动连接解码器以创建解码管道。
- en: Pads
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面板
- en: Each element has some sort of *connection points* to handle data input and output.
    GStreamer refers to them as *pads*. Thus an element object can have one or more
    "receiver pads" termed as **sink pads** that accept data from the previous element
    in the pipeline. Similarly, there are 'source pads' that take the data out of
    the element as an input to the next element (if any) in the pipeline. The following
    is a very simple example that shows how source and sink pads are specified.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 每个元素都有某种类型的**连接点**来处理数据输入和输出。GStreamer称它们为**垫**。因此，一个元素对象可以有一个或多个称为**接收垫**的“接收器垫”，它接受来自管道中前一个元素的数据。同样，还有从元素中取出数据作为管道中下一个元素（如果有的话）输入的**源垫**。以下是一个非常简单的示例，展示了如何指定源和接收垫。
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `fakesrc` is the first element in the pipeline. Therefore, it only has a
    source pad. It transmits the data to the next `linkedelement`, that is `fakesink`
    which only has a sink pad to accept elements. Note that, in this case, since these
    are `fakesrc` and `fakesink`, just empty buffers are exchanged. A pad is defined
    by the class `gst.Pad`. A pad can be attached to an element object using the `gst.Element.add_pad()`
    method.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`fakesrc`是管道中的第一个元素。因此，它只有一个源垫。它将数据传输到下一个`linkedelement`，即`fakesink`，它只有一个接收垫来接受元素。请注意，在这种情况下，由于这些是`fakesrc`和`fakesink`，只是交换了空缓冲区。垫是由`gst.Pad`类定义的。垫可以通过`gst.Element.add_pad()`方法附加到元素对象上。'
- en: The following is a diagrammatic representation of a GStreamer element with a
    pad. It illustrates two GStreamer elements within a pipeline, having a single
    source and sink pad.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个带有垫的GStreamer元素的示意图。它说明了管道内的两个GStreamer元素，它们有一个单独的源垫和接收垫。
- en: '![Pads](img/0165_05_01.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![垫](img/0165_05_01.jpg)'
- en: Now that we know how the pads operate, let's discuss some of special types of
    pads. In the example, we assumed that the pads for the element are always 'out
    there'. However, there are some situations where the element doesn't have the
    pads available all the time. Such elements request the pads they need at runtime.
    Such a pad is called a dynamic pad. Another type of pad is called ghost pad. These
    types are discussed in this section.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了垫的工作方式，让我们讨论一些特殊类型的垫。在示例中，我们假设元素的垫总是“在那里”。然而，在某些情况下，元素并不总是有可用的垫。这些元素在运行时请求它们需要的垫。这种垫被称为动态垫。另一种类型的垫称为幽灵垫。这些类型在本节中讨论。
- en: Dynamic pads
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态垫
- en: Some objects such as `decodebin` do not have pads defined when they are created.
    Such elements determine the type of pad to be used at the runtime. For example,
    depending on the media file input being processed, the `decodebin` will create
    a pad. This is often referred to as **dynamic pad** or sometimes the **available
    pad** as it is not always available in elements such as `decodebin`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一些对象，例如`decodebin`，在创建时并没有定义垫（pads）。这些元素决定了在运行时使用哪种类型的垫。例如，根据正在处理的媒体文件输入，`decodebin`将创建一个垫。这通常被称为**动态垫**，有时也称为**可用垫**，因为它并不总是在像`decodebin`这样的元素中可用。
- en: Ghost pads
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 幽灵垫
- en: As stated in the *Bins* section a **bin** object can act as an abstract element.
    How is it achieved? For that, the bin uses 'ghost pads' or 'pseudo link pads'.
    The ghost pads of a bin are used to connect an appropriate element inside it.
    A ghost pad can be created using `gst.GhostPad` class.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如在*Bin*部分所述，**bin**对象可以充当一个抽象元素。它是如何实现的？为了做到这一点，bin使用“幽灵垫”或“伪链接垫”。bin的幽灵垫用于连接其内部适当的位置。幽灵垫可以使用`gst.GhostPad`类创建。
- en: Caps
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Caps
- en: The element objects send and receive the data by using the pads. The type of
    media data that the element objects will handle is determined by the **caps**
    (a short form for **capabilities)**. It is a structure that describes the media
    formats supported by the element. The caps are defined by the class `gst.Caps`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 元素对象通过垫发送和接收数据。元素对象将处理哪种类型的媒体数据由**caps**（**能力**的简称）决定。它是一个描述元素支持的媒体格式的结构。caps是由`gst.Caps`类定义的。
- en: Bus
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bus
- en: A `bus` refers to the object that delivers the message generated by GStreamer.
    A message is a `gst.Message` object that informs the application about an event
    within the pipeline. A message is put on the bus using the `gst.Bus.gst_bus_post()`
    method. The following code shows an example usage of the `bus`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`bus`指的是传递GStreamer生成消息的对象。消息是一个`gst.Message`对象，它通知应用程序有关管道中的事件。消息是通过`gst.Bus.gst_bus_post()`方法放在总线上的。以下代码展示了`bus`的一个示例用法。'
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first line in the code creates a `gst.Bus` instance. Here the pipeline is
    an instance of `gst.PipeLine`. On the next line, we add a signal watch so that
    the bus gives out all the messages posted on that bus. Line 3 connects the signal
    with a Python method. In this example, the message is the signal string and the
    method it calls is `message_handler`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的第一行创建了一个 `gst.Bus` 实例。在这里，管道是 `gst.PipeLine` 的一个实例。在下一行，我们添加了一个信号监视器，以便总线发布该总线上的所有消息。第
    3 行将信号连接到一个 Python 方法。在这个例子中，消息是信号字符串，它调用的方法是 `message_handler`。
- en: Playbin/Playbin2
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Playbin/Playbin2
- en: Playbin is a GStreamer plugin that provides a high-level audio/video player.
    It can handle a number of things such as automatic detection of the input media
    file format, auto-determination of decoders, audio visualization and volume control,
    and so on. The following line of code creates a `playbin` element.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Playbin 是一个 GStreamer 插件，它提供了一个高级音频/视频播放器。它可以处理许多事情，例如自动检测输入媒体文件格式、自动确定解码器、音频可视化以及音量控制等。以下代码行创建了一个
    `playbin` 元素。
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It defines a property called `uri`. The **URI** (Uniform **Resource Identifier)**
    should be an absolute path to a file on your computer or on the Web. According
    to the GStreamer documentation, Playbin2 is just the latest unstable version but
    once stable, it will replace the Playbin.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 它定义了一个名为 `uri` 的属性。**URI**（统一资源标识符）应该是您计算机或网络上文件的绝对路径。根据 GStreamer 文档，Playbin2
    是最新的不稳定版本，但一旦稳定，它将取代 Playbin。
- en: A Playbin2 instance can be created the same way as a Playbin instance.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 可以像创建 Playbin 实例一样创建 Playbin2 实例。
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With this basic understanding, let us learn about various audio processing techniques
    using GStreamer and Python.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了这个基本理解之后，让我们学习使用 GStreamer 和 Python 的各种音频处理技术。
- en: Playing music
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放音乐
- en: Given an audio file, one the first things you will do is to play that audio
    file, isn't it? In GStreamer, what basic elements do we need to play an audio?
    The essential elements are listed as follows.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个音频文件，你首先要做的事情就是播放这个音频文件，对吧？在 GStreamer 中，我们需要哪些基本元素来播放音频？以下列出了必需的元素。
- en: The first thing we need is to open an audio file for reading
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先需要打开一个音频文件进行读取
- en: Next, we need a decoder to transform the encoded information
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个解码器来转换编码信息
- en: Then, there needs to be an element to convert the audio format so that it is
    in a 'playable' format required by an audio device such as speakers
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，需要一个元素来转换音频格式，使其成为音频设备（如扬声器）所需的“可播放”格式。
- en: Finally, an element that will enable the actual playback of the audio file
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，一个将启用实际播放音频文件的元素
- en: 'How will you play an audio file using the command-line version of GStreamer?
    One way to execute it using command line is as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你将如何使用 GStreamer 的命令行版本播放音频文件？一种使用命令行执行的方法如下：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `autoaudiosink` automatically detects the correct audio device on your
    computer to play the audio. This was tested on a machine with Windows XP and it
    worked fine. If there is any error playing an audio, check if the audio device
    on your computer is working properly. You can also try using element `sdlaudiosink`
    that outputs to the sound card via `SDLAUDIO` . If this doesn''t work, and you
    want to install a plugin for `audiosink` here is a partial list of GStreamer plugins:
    [http://www.gstreamer.net/data/doc/gstreamer/head/gst-plugins-good-plugins/html/](http://www.gstreamer.net/data/doc/gstreamer/head/gst-plugins-good-plugins/html/)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`autoaudiosink` 会自动检测您计算机上正确的音频设备来播放音频。这已在装有 Windows XP 的机器上测试过，效果良好。如果在播放音频时出现任何错误，请检查您计算机上的音频设备是否正常工作。您还可以尝试使用输出到声卡的元素
    `sdlaudiosink`，通过 `SDLAUDIO` 。如果这也不起作用，并且您想在此安装 `audiosink` 插件，以下是一些 GStreamer
    插件的列表：[http://www.gstreamer.net/data/doc/gstreamer/head/gst-plugins-good-plugins/html/](http://www.gstreamer.net/data/doc/gstreamer/head/gst-plugins-good-plugins/html/)'
- en: Mac OS X users can try installing `osxaudiosink` if the default `autoaudiosink`
    doesn't work.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Mac OS X 用户可以尝试安装 `osxaudiosink`，如果默认的 `autoaudiosink` 不起作用。
- en: The audio file should start playing with this command unless there are any missing
    plugins.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 音频文件应该使用此命令开始播放，除非有任何插件缺失。
- en: 'Time for action - playing an audio: method 1'
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 播放音频：方法 1
- en: There are a number of ways to play an audio using Python and GStreamer. Let's
    start with a simple one. In this section, we will use a command string, similar
    to what you would specify using the command-line version of GStreamer. This string
    will be used to construct a `gst.Pipeline` instance in a Python program.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python 和 GStreamer 播放音频有多种方法。让我们从一个简单的例子开始。在本节中，我们将使用一个命令字符串，类似于您使用 GStreamer
    命令行版本所指定的方式。这个字符串将用于在 Python 程序中构建一个 `gst.Pipeline` 实例。
- en: So, here we go!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，从这里开始吧！
- en: Start by creating an `AudioPlayer` class in a Python source file. Just define
    the empty methods illustrated in the following code snippet. We will expand those
    in the later steps.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 Python 源文件中创建一个 `AudioPlayer` 类。只需定义以下代码片段中所示的空方法。我们将在后续步骤中扩展这些方法。
- en: '[PRE14]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Lines 1 to 5 in the code import the necessary modules. As discussed in the Installation
    prerequisites section, the package pygst is imported first. Then we call pygst.require
    to enable the import of gst module.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码的第 1 到 5 行导入了必要的模块。如安装先决条件部分所述，首先导入 pygst 包。然后我们调用 pygst.require 以启用 gst 模块的导入。
- en: Now focus on the code block between lines 19 to 24\. It is the main execution
    code. It enables running the program until the music is played. We will use this
    or similar code throughout this book to run our audio application.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在关注第 19 到 24 行之间的代码块。这是主要的执行代码。它使程序运行直到音乐播放完毕。我们将在这本书的整个过程中使用此代码或类似代码来运行我们的音频应用程序。
- en: On line 21, the thread module is used to create a new thread for playing the
    audio. The method AudioPlayer.play is sent on this thread. The second argument
    of thread.start_new_thread is the list of arguments to be passed to the method
    play. In this example, we do not support any command-line arguments. Therefore,
    an empty tuple is passed. Python adds its own thread management functionality
    on top of the operating system threads. When such a thread makes calls to external
    functions (such as C functions), it puts the 'Global Interpreter Lock' on other
    threads until, for instance, the C function returns a value.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第 21 行，使用线程模块创建一个新的线程来播放音频。将 `AudioPlayer.play` 方法发送到这个线程。`thread.start_new_thread`
    的第二个参数是要传递给 `play` 方法的参数列表。在这个例子中，我们不支持任何命令行参数。因此，传递了一个空元组。Python 在操作系统线程之上添加了自己的线程管理功能。当这样的线程调用外部函数（如
    C 函数）时，它会将 '全局解释器锁' 放在其他线程上，直到例如 C 函数返回一个值。
- en: The gobject.threads_init() is an initialization function for facilitating the
    use of Python threading within the gobject modules. It can enable or disable threading
    while calling the C functions. We call this before running the main event loop.
    The main event loop for executing this program is created using gobject on line
    23 and this loop is started by the call evt_loop.run().
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`gobject.threads_init()` 是一个初始化函数，用于在 gobject 模块中方便地使用 Python 线程。它可以在调用 C 函数时启用或禁用线程。我们在运行主事件循环之前调用它。执行此程序的主事件循环是在第
    23 行使用 gobject 创建的，并且通过调用 `evt_loop.run()` 启动此循环。'
- en: Next, fill the `AudioPlayer` class methods with the code. First, write the constructor
    of the class.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，填充 `AudioPlayer` 类的方法代码。首先，编写类的构造函数。
- en: '[PRE15]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The pipeline is constructed by the method call on line 2\. The flag self.is_playing
    is initialized to False. It will be used to determine whether the audio being
    played has reached the end of the stream. On line 4, a method self.connectSignals
    is called, to capture the messages posted on a bus. We will discuss both these
    methods next.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管道是通过第 2 行的调用方法构建的。`self.is_playing` 标志初始化为 False。它将用于确定正在播放的音频是否已到达流的末尾。在第
    4 行，调用 `self.connectSignals` 方法，以捕获在总线上发布的消息。我们将在下一节讨论这两个方法。
- en: 'The main driver for playing the sound is the following `gst` command:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放声音的主要驱动程序是以下 `gst` 命令：
- en: '[PRE16]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding string has four elements separated by the symbol !. These elements
    represent the components we briefly discussed earlier.
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前面的字符串由四个元素组成，这些元素之间用符号 ! 分隔。这些元素代表我们之前简要讨论过的组件。
- en: The first element `filesrc location=C:/AudioFiles/my_music.mp3` defines the
    source element that loads the audio file from a given location. In this string,
    just replace the audio file path represented by `location` with an appropriate
    file path on your computer. You can also specify a file on a disk drive.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个元素 `filesrc location=C:/AudioFiles/my_music.mp3` 定义了源元素，它从给定位置加载音频文件。在这个字符串中，只需将表示
    `location` 的音频文件路径替换为您计算机上的适当文件路径。您也可以指定一个磁盘驱动器上的文件。
- en: Note
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If the filename contains namespaces, make sure you specify the path within
    quotes. For example, if the filename is my sound.mp3, specify it as follows: `filesrc
    location =\"C:/AudioFiles/my sound.mp3\`"'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果文件名包含命名空间，请确保您指定路径时使用引号。例如，如果文件名是my sound.mp3，请按照以下方式指定：`filesrc location
    =\"C:/AudioFiles/my sound.mp3\"`
- en: The next element loads the file. This element is connected to a `decodebin`.
    As discussed earlier, the `decodebin` is a plugin to GStreamer and it inherits
    `gst.Bin`. Based on the input audio format, it determines the right type of decoder
    element to use.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个元素是加载文件。此元素连接到一个`decodebin`。如前所述，`decodebin`是GStreamer的一个插件，它继承自`gst.Bin`。根据输入音频格式，它确定要使用的正确类型的解码器元素。
- en: The third element is audioconvert. It translates the decoded audio data into
    a format playable by the audio device.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第三个元素是audioconvert。它将解码的音频数据转换为音频设备可播放的格式。
- en: The final element, autoaudiosink, is a plugin; it automatically detects the
    audio sink for the audio output.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后一个元素autoaudiosink是一个插件；它自动检测音频输出设备。
- en: We have sufficient information now to create an instance of gst.Pipeline. Write
    the following method.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们有足够的信息来创建一个gst.Pipeline实例。编写以下方法。
- en: '[PRE17]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: An instance of gst.Pipeline is created on line 5, using the gst.parse_launch
    method.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第5行使用gst.parse_launch方法创建了一个gst.Pipeline实例。
- en: Now write the following method of class `AudioPlayer`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编写类`AudioPlayer`的以下方法。
- en: '[PRE18]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: On line 4, an instance of gst.Bus is created. In the introductory section on
    GStreamer, we already learned what the code between lines 4 to 6 does. This bus
    has the job of delivering the messages posted on it from the streaming threads.
    The add_signal_watch call makes the bus emit the message signal for each message
    posted. This signal is used by the method message_handler to take appropriate
    action.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第4行，创建了一个gst.Bus实例。在GStreamer的介绍部分，我们已经学习了第4到6行之间的代码做了什么。这个总线负责从流线程中传递它上面的消息。add_signal_watch调用使得总线为每个发布的消息发出消息信号。这个信号被message_handler方法用来采取适当的行动。
- en: 'Write the following method:'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写以下方法：
- en: '[PRE19]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: On line 2, we set the state of the gst pipeline to gst.STATE_PLAYING to start
    the audio streaming. The flag self.is_playing controls the while loop on line
    4\. This loop ensures that the main event loop is not terminated before the end
    of the audio stream is reached. Within the loop the call to time.sleep just buys
    some time for the audio streaming to finish. The value of flag is changed in the
    method message_handler that watches for the messages from the bus. On line 6,
    the main event loop is terminated. This gets called when the end of stream message
    is emitted or when some error occurs while playing the audio.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第2行，我们将gst管道的状态设置为gst.STATE_PLAYING以启动音频流。self.is_playing标志控制第4行的while循环。这个循环确保在音频流结束之前主事件循环不会被终止。在循环中，time.sleep的调用只是为音频流的完成争取了一些时间。标志的值在监视总线消息的方法message_handler中改变。在第6行，主事件循环被终止。这会在发出流结束消息或播放音频时发生错误时被调用。
- en: Next, develop method `AudioPlayer.message_handler`. This method sets the appropriate
    flag to terminate the main loop and is also responsible for changing the playing
    state of the pipeline.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，开发方法`AudioPlayer.message_handler`。此方法设置适当的标志以终止主循环，并负责更改管道的播放状态。
- en: '[PRE20]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this method, we only check two things: whether the message on the bus says
    the streaming audio has reached its end (gst.MESSAGE_EOS ) or if any error occurred
    while playing the audio stream (gst.MESSAGE_ERROR ). For both these messages,
    the state of the gst pipeline is changed from gst.STATE_PLAYING to gst.STATE_NULL.
    The self.is_playing flag is updated to instruct the program to terminate the main
    event loop.'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个方法中，我们只检查两件事：总线上的消息是否表示流音频已到达其末尾（gst.MESSAGE_EOS）或播放音频流时是否发生了错误（gst.MESSAGE_ERROR）。对于这两个消息，gst管道的状态从gst.STATE_PLAYING更改为gst.STATE_NULL。self.is_playing标志被更新以指示程序终止主事件循环。
- en: 'We have defined all the necessary code to play the audio. Save the file as
    PlayingAudio.py and run the application from the command line as follows:'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经定义了所有必要的代码来播放音频。将文件保存为PlayingAudio.py，然后按照以下命令从命令行运行应用程序：
- en: '[PRE21]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will begin playback of the input audio file. Once it is done playing, the
    program will be terminated. You can press Ctrl + C on Windows or Linux to interrupt
    the playing of the audio file. It will terminate the program.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将开始播放输入音频文件。一旦播放完毕，程序将被终止。您可以在Windows或Linux上按Ctrl + C来中断音频文件的播放。它将终止程序。
- en: What just happened?
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We developed a very simple audio player, which can play an input audio file.
    The code we wrote covered some of the most important components of GStreamer.
    These components will be useful throughout this chapter. The core component of
    the program was a GStreamer pipeline that had instructions to play the given audio
    file. Additionally, we learned how to create a thread and then start a `gobject`
    event loop to ensure that the audio file is played until the end.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开发了一个非常简单的音频播放器，它可以播放输入的音频文件。我们编写的代码涵盖了GStreamer的一些最重要的组件。这些组件将在本章中非常有用。程序的核心组件是一个GStreamer管道，其中包含播放给定音频文件的指令。此外，我们还学习了如何创建一个线程，然后启动一个`gobject`事件循环，以确保音频文件播放到结束。
- en: Have a go hero play audios from a playlist
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试英雄播放播放列表中的音频
- en: 'The simple audio player we developed can only play a single audio file, whose
    path is hardcoded in the constructed GStreamer pipeline. Modify this program so
    it can play audios in a "playlist". In this case, play list should define full
    paths of the audio files you would like to play, one after the other. For example,
    you can specify the file paths as arguments to this application or load the paths
    defined in a text file or load all audio files from a directory. Hint: In a later
    section, we will develop an audio file converter utility. See if you can use some
    of that code here.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开发了一个非常简单的音频播放器，它只能播放单个音频文件，其路径在构建的GStreamer管道中是硬编码的。修改此程序，使其能够播放“播放列表”中的音频。在这种情况下，播放列表应定义您想要依次播放的音频文件的完整路径。例如，您可以将文件路径指定为该应用程序的参数，或从文本文件中加载路径，或从目录中加载所有音频文件。提示：在后面的章节中，我们将开发一个音频文件转换实用程序。看看您是否可以使用其中的一些代码。
- en: Building a pipeline from elements
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从元素构建管道
- en: In the last section, a gst.Pipeline was automatically constructed for us by
    the gst.parse_launch method. All it required was an appropriate command string,
    similar to the one specified while running the command-line version of GStreamer.
    The creation and linking of elements was handled internally by this method. In
    this section, we will see how to construct a pipeline by adding and linking individual
    element objects. 'GStreamer Pipeline' construction is a fundamental technique
    that we will use throughout this chapter and also in other chapters related to
    audio and video processing.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，`gst.parse_launch`方法为我们自动构建了一个`gst.Pipeline`。它所需的所有只是一个合适的命令字符串，类似于运行GStreamer命令行版本时指定的命令字符串。元素的创建和链接由该方法内部处理。在本节中，我们将看到如何通过添加和链接单个元素对象来构建管道。'GStreamer
    Pipeline'构建是我们将在本章以及与其他音频和视频处理相关的章节中使用的根本技术。
- en: 'Time for action - playing an audio: method 2'
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 播放音频：方法2
- en: We have already developed code for playing an audio. Let's now tweak the method
    `AudioPlayer.constructPipeline` to build the `gst.Pipeline` using different element
    objects.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了播放音频的代码。现在让我们调整`AudioPlayer.constructPipeline`方法，使用不同的元素对象构建`gst.Pipeline`。
- en: Rewrite the `constructPipeline` method as follows. You can also download the
    file `PlayingAudio.py` from the Packt website for reference. This file has all
    the code we discussed in this and previous sections.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`constructPipeline`方法重写如下。您还可以从Packt网站下载`PlayingAudio.py`文件以供参考。此文件包含我们在本节和前几节中讨论的所有代码。
- en: '[PRE22]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We begin by creating an instance of class `gst.Pipeline`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建`gst.Pipeline`类的一个实例。
- en: Next, on line 2, we create the element for loading the audio file. Any new `gst`
    element can be created using the API method, `gst.element_factory_make`. The method
    takes the element name (string) as an argument. For example, on line 3, this argument
    is specified as `"filesrc`" in order to create an instance of element `GstFileSrc`.
    Each element will have a set of properties. The path of the input audio file is
    stored in a property `location` of `self.filesrc` element. This property is set
    on line 4\. Replace the file path string with an appropriate audio file path.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在第2行，我们创建用于加载音频文件的元素。任何新的`gst`元素都可以使用API方法`gst.element_factory_make`创建。该方法需要一个元素名称（字符串）作为参数。例如，在第3行，此参数指定为`"filesrc"`，以便创建`GstFileSrc`元素的实例。每个元素都将有一组属性。输入音频文件的路径存储在`self.filesrc`元素的属性`location`中。此属性在第4行设置。将文件路径字符串替换为适当的音频文件路径。
- en: Tip
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can get a list of all properties by running the`'gst-inspect-0.10`' command
    from a console window. See the introductory section on **GSreamer** for more details.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以通过在控制窗口中运行`'gst-inspect-0.10'`命令来获取所有属性的列表。有关**GSreamer**的更多详细信息，请参阅简介部分。
- en: The second optional argument serves as a custom name for the created object.
    For example, on line 20, the name for the `autoaudiosink` object is specified
    as `a_a_sink`. Like this, we create all the essential elements necessary to build
    the pipeline.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个可选参数用作创建的对象的定制名称。例如，在第20行，`autoaudiosink` 对象的名称指定为 `a_a_sink`。以此类推，我们创建了构建管道所需的所有基本元素。
- en: On line 23 in the code, all the elements are put in the pipeline by calling
    the `gst.Pipeline.add` method.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码的第23行，通过调用 `gst.Pipeline.add` 方法将所有元素放入管道中。
- en: The method `gst.element_link_many` establishes connection between two or more
    elements for the audio data to flow between them. The elements are linked together
    by the code on lines 26 and 27\. However, notice that we haven't linked together
    the elements `self.decodebin` and `self.audioconvert`. Why? That's up next.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法 `gst.element_link_many` 建立了两个或更多元素之间的连接，以便音频数据可以在它们之间流动。这些元素通过第26行和第27行的代码相互连接。然而，请注意，我们没有将元素
    `self.decodebin` 和 `self.audioconvert` 连接在一起。为什么？答案将在下文中揭晓。
- en: We cannot link the `decodebin` element with the `audioconvert` element at the
    time the pipeline is created. This is because `decodebin` uses dynamic pads. These
    pads are not available for connection with the `audioconvert` element when the
    pipeline is created. Depending upon the input data , it will create a pad. Thus,
    we need to watch out for a signal that is emitted when the `decodebin` adds a
    pad! How do we do that? It is done by the code on line 11 in the code snippet
    above. The "pad-added" signal is connected with a method, `decodebin_pad_added`.
    Whenever `decodebin` adds a dynamic pad, this method will get called.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不能在创建管道时将 `decodebin` 元素与 `audioconvert` 元素连接起来。这是因为 `decodebin` 使用动态垫。当管道创建时，这些垫不可用于与
    `audioconvert` 元素连接。根据输入数据，它将创建一个垫。因此，我们需要注意当 `decodebin` 添加垫时发出的信号！我们如何做到这一点？这是通过上面代码片段中的第11行代码完成的。“pad-added”信号与
    `decodebin_pad_added` 方法连接。每当 `decodebin` 添加一个动态垫时，此方法就会被调用。
- en: Thus, all we need to do is to manually establish a connection between `decodebin`
    and `audioconvert` elements in the method `decodebin_pad_added`. Write the following
    method.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们所需做的就是手动在 `decodebin` 和 `audioconvert` 元素之间建立连接，在 `decodebin_pad_added`
    方法中编写以下方法。
- en: '[PRE23]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The method takes the element (in this case it is self.decodebin ) and pad as
    arguments. The pad is the new pad for the decodebin element. We need to link this
    pad with the appropriate one on self.audioconvert.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该方法接受元素（在这种情况下是 self.decodebin）和垫作为参数。垫是 decodebin 元素的新垫。我们需要将这个垫与 self.audioconvert
    上的适当垫连接起来。
- en: On line 2 in this code snippet, we find out what type of media data the pad
    handles. Once the capabilities (caps) are known, we pass this information to the
    method `get_compatible_pad` of object `self.audioconvert`. This method returns
    a compatible pad which is then linked with `pad` on line 6.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此代码片段的第2行，我们找到了垫处理哪种类型的媒体数据。一旦知道了能力（caps），我们就将此信息传递给 `self.audioconvert` 对象的
    `get_compatible_pad` 方法。此方法返回一个兼容的垫，然后与第6行的 `pad` 连接。
- en: The rest of the code is identical with the one illustrated in the earlier section.
    You can run this program the same way described earlier.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码的其余部分与前面章节中展示的代码相同。你可以按照前面描述的方式运行此程序。
- en: What just happened?
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We learned some very crucial components of GStreamer framework. With the simple
    audio player as an example, we created a GStreamer pipeline 'from scratch' by
    creating various element objects and linking them together. We also learned how
    to connect two elements by 'manually' linking their pads and why that was required
    for the element `self.decodebin`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了 GStreamer 框架的一些非常关键组件。以简单的音频播放器为例，我们通过创建各种元素对象并将它们连接起来，从头开始创建了一个 GStreamer
    管道。我们还学习了如何通过“手动”连接它们的垫来连接两个元素，以及为什么这对于 `self.decodebin` 元素是必需的。
- en: Pop Quiz - element linking
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 突击测验 - 元素连接
- en: In the earlier example, most of the elements in the pipeline linked using `gst.element_link_many`
    in method `AudioPlayer.constructPipeline`. However, we did not link the elements
    `self.decodebin` and `self.audioconvert` at the time when the pipeline was constructed.
    Why? Choose the correct answer from the following.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，管道中的大多数元素在 `AudioPlayer.constructPipeline` 方法中使用 `gst.element_link_many`
    连接。然而，我们在构建管道时没有将 `self.decodebin` 和 `self.audioconvert` 元素连接起来。为什么？从以下选项中选择正确答案。
- en: We were just trying out a different technique of manually linking these elements
    together.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只是尝试了手动连接这些元素的不同技术。
- en: '`Decodebin` uses a dynamic pad that is created at the runtime. This pad is
    not available when the pipeline is created.'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Decodebin`使用在运行时创建的动态垫。当管道创建时，这个垫不可用。'
- en: We don't need to link these elements in the pipeline. The media data will just
    find its way somehow.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不需要在管道中链接这些元素。媒体数据会以某种方式找到自己的路径。
- en: What are you talking about? It is impossible to connect `decodebin` and `audioconvert`
    elements no matter what you try.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你在说什么？无论你尝试什么，都无法连接`decodebin`和`audioconvert`元素。
- en: Playing an audio from a website
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从网站上播放音频
- en: If there is an audio somewhere on a website that you would like to play, we
    can pretty much use the same AudioPlayer class developed earlier. In this section,
    we will illustrate the use of gst.Playbin2 to play an audio by specifying a URL.
    The code snippet below shows the revised AudioPlayer.constructPipeline method.
    The name of this method should be changed as it is playbin object that it creates.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果网站上某个地方有你想播放的音频，我们基本上可以使用之前开发的相同的AudioPlayer类。在本节中，我们将说明如何使用gst.Playbin2通过指定URL来播放音频。下面的代码片段显示了修改后的AudioPlayer.constructPipeline方法。这个方法的名字应该更改，因为它创建的是playbin对象。
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: On line 4, the gst.Playbin2 element is created using `gst.element_factory_make`
    method. The argument to this method is a string that describes the element to
    be created. In this case it is "playbin2" . You can also define a custom name
    for this object by supplying an optional second argument to this method. Next,
    on line 5 and 6, we assign values to the properties uri and buffer-size. Set the
    uri property to an appropriate URL , the full path to the audio file you would
    like to play.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4行，使用`gst.element_factory_make`方法创建了gst.Playbin2元素。这个方法的参数是一个描述要创建的元素的字符串。在这种情况下是"playbin2"。你也可以通过向这个方法提供一个可选的第二个参数来为这个对象定义一个自定义名称。接下来，在第5行和第6行，我们为uri和buffer-size属性赋值。将uri属性设置为适当的URL，即你想播放的音频文件的完整路径。
- en: Tip
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Note: When you execute this program, Python application tries to access the
    Internet. The anti-virus installed on your computer may block the program execution.
    In this case, you will need to allow this program to access the Internet. Also,
    you need to be careful of hackers. If you get the `fil_url` from an untrusted
    source, perform a safety check such as `assert not re.match("file://", file_url)`.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当你执行这个程序时，Python应用程序会尝试访问互联网。你电脑上安装的杀毒软件可能会阻止程序执行。在这种情况下，你需要允许这个程序访问互联网。同时，你也需要小心黑客。如果你从不可信的来源获取了`fil_url`，请执行安全检查，例如`assert
    not re.match("file://", file_url)`。
- en: Have a go hero use 'playbin' to play local audios
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 英雄尝试使用'playbin'播放本地音频
- en: 'In the last few sections, we learned different ways to play an audio file using
    Python and GStreamer. In the previous section, you must have noticed another simple
    way to achieve this, using a playbin or playbin2 object to play an audio. In the
    previous section, we learned how to play an audio file from a URL. Modify this
    code so that this program can now play audio files located in a drive on your
    computer. Hint: You will need to use the correct "uri" path. Convert the file
    path using Python''s module `urllib.pathname2url` and then append it to the string:
    `"file://`".'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后几个部分，我们学习了使用Python和GStreamer播放音频文件的不同方法。在前一个部分，你可能已经注意到了另一种实现这一点的简单方法，即使用playbin或playbin2对象来播放音频。在前一个部分，我们学习了如何从URL播放音频文件。修改这段代码，使这个程序现在可以播放位于你电脑驱动器上的音频文件。提示：你需要使用正确的"uri"路径。使用Python的模块`urllib.pathname2url`转换文件路径，然后将其附加到字符串："file://`"。
- en: Converting audio file format
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换音频文件格式
- en: Suppose you have a big collection of songs in wav file format that you would
    like to load on a cell phone. But you find out that the cell phone memory card
    doesn't have enough space to hold all these. What will you do? You will probably
    try to reduce the size of the song files right? Converting the files into mp3
    format will reduce the size. Of course you can do it using some media player.
    Let's learn how to perform this conversion operation using Python and GStreamer.
    Later we will develop a simple command-line utility that can be used to perform
    a batch conversion for all the files you need.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一大批wav格式的歌曲想要加载到手机上。但你发现手机内存卡没有足够的空间来存储所有这些。你会怎么做？你可能试图减小歌曲文件的大小，对吧？将文件转换为mp3格式会减小文件大小。当然，你可以使用某些媒体播放器来完成这个转换操作。让我们学习如何使用Python和GStreamer执行这个转换操作。稍后我们将开发一个简单的命令行工具，可以用于对所需的所有文件进行批量转换。
- en: Like in the earlier examples, let's first list the important building blocks
    we need to accomplish file conversion. The first three elements remain the same.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像在之前的示例中一样，让我们首先列出我们需要完成文件转换的重要构建块。前三个元素保持不变。
- en: As before, the first thing we need is to load an audio file for reading.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像之前一样，我们首先需要加载一个音频文件进行读取。
- en: Next, we need a decoder to transform the encoded information.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个解码器来转换编码信息。
- en: Then, there needs to be an element to convert the raw audio buffers into an
    appropriate format.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，需要有一个元素将原始音频缓冲区转换为适当的格式。
- en: An encoder is needed that takes the raw audio data and encodes it to an appropriate
    file format to be written.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要一个编码器，它将原始音频数据编码为适当的文件格式以写入。
- en: An element where the encoded data will be streamed to is needed. In this case
    it is our output audio file.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要一个元素，将编码的数据流式传输到其中。在这种情况下，它是我们的输出音频文件。
- en: Okay, what's next? Before jumping into the code, first check if you can achieve
    what you want using the command-line version of GStreamer.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，接下来是什么？在跳入代码之前，首先检查你是否可以使用GStreamer的命令行版本实现你想要的功能。
- en: '[PRE25]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Specify the correct input and output file paths and run this command to convert
    a wave file to an mp3\. If it works, we are all set to proceed. Otherwise check
    for missing plugins.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 指定正确的输入和输出文件路径，并运行此命令将波形文件转换为mp3。如果它工作，我们就准备好继续了。否则，检查是否有缺少的插件。
- en: You should refer to the GStreamer API documentation to know more about the properties
    of various elements illustrated above. Trust me, the `gst-inspect-0.10` (or `gst-inspect-0.10.exe`
    for Windows users) command is a very handy tool that will help you understand
    the components of a GStreamer plugin. The instructions on running this tool are
    already discussed earlier in this chapter.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该参考GStreamer API文档来了解上述各种元素的性质。相信我，`gst-inspect-0.10`（或Windows用户的`gst-inspect-0.10.exe`）命令是一个非常实用的工具，它将帮助你理解GStreamer插件的组件。关于运行此工具的说明已经在本章前面讨论过了。
- en: Time for action - audio file format converter
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 音频文件格式转换器
- en: 'Let''s write a simple audio file converter. This utility will batch process
    input audio files and save them in a user-specified file format. To get started,
    download the file AudioConverter.py from the Packt website. This file can be run
    from the command line as:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的音频文件转换器。这个实用程序将批量处理输入音频文件，并将它们保存为用户指定的文件格式。要开始，请从Packt网站下载文件AudioConverter.py。此文件可以从命令行运行，如下所示：
- en: '[PRE26]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Where, the `[options]` are as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，`[options]` 如下：
- en: '`--input_dir` : The directory from which to read the input audio file(s) to
    be converted.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--input_dir` : 从中读取要转换的输入音频文件（们）的目录。'
- en: '`--input_format:` The audio format of the input files. The format should be
    in a supported list of formats. The supported formats are "mp3", "ogg", and "wav".
    If no format is specified, it will use the default format as ".wav".'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--input_format:` 输入文件的音频格式。格式应该在一个支持的格式列表中。支持的格式有 "mp3"、"ogg" 和 "wav"。如果没有指定格式，它将使用默认格式
    ".wav"。'
- en: '`--output_dir` : The output directory where the converted files will be saved.
    If no output directory is specified, it will create a folder `OUTPUT_AUDIOS` within
    the input directory.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--output_dir` : 转换文件将被保存的输出目录。如果没有指定输出目录，它将在输入目录中创建一个名为 `OUTPUT_AUDIOS` 的文件夹。'
- en: '`--output_format:` The audio format of the output file. Supported output formats
    are "wav" and "mp3".'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--output_format:` 输出文件的音频格式。支持的输出格式有 "wav" 和 "mp3"。'
- en: Let's write this code now.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在让我们写下这段代码。
- en: Start by importing necessary modules.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导入必要的模块。
- en: '[PRE27]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now declare the following class and the utility function. As you will notice,
    several of the methods have the same names as before. The underlying functionality
    of these methods will be similar to what we already discussed. In this section
    we will review only the most important methods in this class. You can refer to
    file `AudioConverter.py` for other methods or develop those on your own.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在声明以下类和实用函数。你会注意到，其中许多方法与之前的方法名称相同。这些方法的底层功能将与我们已经讨论过的类似。在本节中，我们将仅回顾这个类中最重要的方法。你可以参考文件`AudioConverter.py`中的其他方法或自行开发这些方法。
- en: '[PRE28]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Look at the last few lines of code above. This is exactly the same code we used
    in the Playing Music section. The only difference is the name of the class and
    its method that is put on the thread in the call `thread.start_new_thread`. At
    the beginning, the function `audioFileExists()` is declared. It will be used to
    check if the specified path is a valid file path.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看上面代码的最后几行。这正是我们在播放音乐部分使用的相同代码。唯一的区别是类的名称和在`thread.start_new_thread`调用中放在线程上的方法名称。一开始，声明了`audioFileExists()`函数。它将被用来检查指定的路径是否是一个有效的文件路径。
- en: Now write the constructor of the class. Here we do initialization of various
    variables.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编写类的构造函数。在这里，我们初始化各种变量。
- en: '[PRE29]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The self.supportedOutputFormats is a tuple that stores the supported output
    formats. `self.supportedInputFormats` is a list obtained from the keys of `self.encoders`
    and stores the supported input formats. These objects are used in `self.processArguments`
    to do necessary checks. The dictionary `self.encoders` provides the correct type
    of encoder string to be used to create an encoder element object for the GStreamer
    pipeline. As the name suggests, the call to `self.constructPipeline()` builds
    a `gst.Pipeline` instance and various signals are connected using `self.connectSignals()`.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`self.supportedOutputFormats`是一个元组，用于存储支持的输出格式。`self.supportedInputFormats`是从`self.encoders`的键中获取的列表，用于存储支持的输入格式。这些对象在`self.processArguments`中用于进行必要的检查。字典`self.encoders`提供了用于创建GStreamer管道的编码器元素对象的正确类型的编码器字符串。正如其名所示，调用`self.constructPipeline()`构建了一个`gst.Pipeline`实例，并且使用`self.connectSignals()`连接了各种信号。'
- en: Next, prepare a GStreamer pipeline.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，准备一个GStreamer管道。
- en: '[PRE30]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This code is similar to the one we developed in the *Playing Music* sub-section.
    However there are some noticeable differences. In the Audio Player example, we
    used the `autoaudiosink` plugin as the last element. In the Audio Converter, we
    have replaced it with elements `self.encoder` and `self.filesink`. The former
    encodes the audio data coming out of the `self.audioconvert`. The encoder will
    be linked to the sink element. In this case, it is a `filesink`. The `self.filesink`
    is where the audio data is written to a file given by the `location` property.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码与我们之前在*播放音乐*子节中开发的代码类似。然而，有一些明显的不同。在音频播放器示例中，我们使用了`autoaudiosink`插件作为最后一个元素。在音频转换器中，我们用`self.encoder`和`self.filesink`元素替换了它。前者将`self.audioconvert`输出的音频数据进行编码。编码器将被连接到接收器元素。在这种情况下，它是一个`filesink`。`self.filesink`是将音频数据写入由`location`属性指定的文件的地方。
- en: The encoder string, `encoder_str` determines the type of encoder element to
    create. For example, if the output format is specified as "mp3" the corresponding
    encoder to use is "lame" mp3 encoder. You can run the gst-inspect-0.10 command
    to know more about the `lame` mp3 encoder. The following command can be run from
    shell on Linux.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编码器字符串`encoder_str`决定了要创建的编码器元素的类型。例如，如果输出格式指定为"mp3"，则相应的编码器是"lame" mp3编码器。您可以通过运行gst-inspect-0.10命令来了解更多关于`lame`
    mp3编码器的信息。以下命令可以在Linux的shell上运行。
- en: '[PRE31]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The elements are added to the pipeline and then linked together. As before,
    the `self.decodebin` and `self.audioconvert` are not linked in this method as
    the `decodebin` plugin uses dynamic pads. The `pad_added` signal from the `self.decodebin`
    is connected in the `self.connectSignals()` method.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 元素被添加到管道中，然后相互连接。和之前一样，在这个方法中，`self.decodebin`和`self.audioconvert`没有连接，因为`decodebin`插件使用动态垫。`self.decodebin`的`pad_added`信号在`self.connectSignals()`方法中被连接。
- en: Another noticeable change is that we have not set the `location` property for
    both, `self.filesrc` and `self.filesink`. These properties will be set at the
    runtime. The input and output file locations keep on changing as the tool is a
    batch processing utility.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个明显的改变是我们没有为`self.filesrc`和`self.filesink`两个属性设置`location`属性。这些属性将在运行时设置。由于这个工具是一个批处理工具，输入和输出文件的存储位置会不断变化。
- en: Let's write the main method that controls the conversion process.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写控制转换过程的主方法。
- en: '[PRE32]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The code between lines 2 to 26 is similar to the one developed in the Image
    File conversion utility in this book. Refer to the Reading and Writing Images
    section of [Chapter 2](ch02.html "Chapter 2. Working with Images") to know what
    that code does. All the input audio files are collected in the list `inputFileList`
    by the code between lines 2 to 6 . Then, we loop over each of these files. First,
    the output file path is derived based on user inputs and then the input file path.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第 2 行到 26 行之间的代码与本书中图像文件转换实用程序中开发的代码类似。请参阅第 2 章[处理图像](ch02.html "第 2 章。处理图像")的“读取和写入图像”部分，了解该代码的功能。所有输入音频文件都由第
    2 行到 6 行之间的代码收集到列表 `inputFileList` 中。然后，我们遍历这些文件中的每一个。首先，根据用户输入推导出输出文件路径，然后是输入文件路径。
- en: The highlighted line of code is the workhorse method, `AudioConverter.convert_single_audio`,
    that actually does the job of converting the input audio. We will discuss that
    method next. On line 43, the main event loop is terminated. The rest of the code
    in method convert is self-explanatory.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 突出的代码行是工作马力的方法，`AudioConverter.convert_single_audio`，它实际上执行了转换输入音频的工作。我们将在下一节讨论该方法。在第
    43 行，终止了主事件循环。`convert` 方法中的其余代码是自我解释的。
- en: The code in method `convert_single_audio` is illustrated below.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法 `convert_single_audio` 中的代码如下所示。
- en: '[PRE33]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As mentioned in the last step, `convert_single_audio` method is called within
    a for loop in the `self.convert()` . The for loop iterates over a list containing
    input audio file paths. The input and output file paths are given as arguments
    to this method. The code between lines 8-12 looks more or less similar to `AudioPlayer.play()`
    method illustrated in the *Play audio section*. The only difference is the main
    event loop is not terminated in this method. Earlier we did not set the location
    property for the file source and sink. These properties are set on lines 6 and
    7 respectively.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如上一步所述，`convert_single_audio` 方法在 `self.convert()` 中的 for 循环中被调用。for 循环遍历包含输入音频文件路径的列表。输入和输出文件路径作为参数传递给此方法。第
    8-12 行之间的代码看起来与 *播放音频* 部分中展示的 `AudioPlayer.play()` 方法大致相似。唯一的区别是此方法中没有终止主事件循环。之前我们没有为文件源和汇设置位置属性。这些属性分别在第
    6 行和第 7 行设置。
- en: 'Now what''s up with the code on lines 2 and 3? The call `repr(inPath)` returns
    a printable representation of the string `inPath`. The `inPath` is obtained from
    the ''for loop''. The `os.path.normpath` doesn''t work on this string. In Windows,
    if you directly use `inPath`, GStreamer will throw an error while processing such
    a path string. One way to handle this is to use `repr(string)` , which will return
    the whole string including the quotes . For example: if `inPath` be "C:/AudioFiles/my_music.mp3"
    , then `repr(inPath)` will return `"''C:\\\\AudioFiles\\\\my_music.mp3''`". Notice
    that it has two single quotes. We need to get rid of the extra single quotes at
    the beginning and end by slicing the string as `inPth[1:-1]`. There could be some
    other better ways. You can come up with one and then just use that code as a path
    string!'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在关于第 2 行和第 3 行的代码是什么情况？调用 `repr(inPath)` 返回字符串 `inPath` 的可打印表示。`inPath` 是从
    'for 循环' 中获得的。`os.path.normpath` 不适用于这个字符串。在 Windows 上，如果你直接使用 `inPath`，GStreamer
    在处理这样的路径字符串时会抛出错误。处理这个问题的一种方法是用 `repr(string)`，这将返回包括引号在内的整个字符串。例如：如果 `inPath`
    是 "C:/AudioFiles/my_music.mp3"，那么 `repr(inPath)` 将返回 `"'C:\\\\AudioFiles\\\\my_music.mp3'"`。注意，它有两个单引号。我们需要通过切片字符串为
    `inPth[1:-1]` 来去除开头和结尾的额外单引号。可能还有其他更好的方法。你可以想出一个，然后只需使用那个代码作为路径字符串即可！
- en: 'Let''s quickly skim through a few more methods. Write these down:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们快速浏览几个更多的方法。记下来：
- en: '[PRE34]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `connectSignal` method is identical to the one discussed in the *Playing
    music* section, except that we are also connecting the `decodebin` signal with
    a method `decodebin_pad_added`. Add a print statement to `decodebin_pad_added`
    to check when it gets called. It will help you understand how the dynamic pad
    works! The program starts by processing the first audio file. The method `convert_single_audio`
    gets called. Here, we set the necessary file paths. After that, it begins playing
    the audio file. At this time, the `pad_added` signal is generated. Thus based
    on the input file data, `decodebin` will create the pad.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`connectSignal` 方法与 *播放音乐* 部分中讨论的方法相同，不同之处在于我们还连接了 `decodebin` 信号与 `decodebin_pad_added`
    方法。在 `decodebin_pad_added` 中添加一个打印语句以检查何时被调用。这将帮助你理解动态垫的工作方式！程序从处理第一个音频文件开始。调用
    `convert_single_audio` 方法。在这里，我们设置了必要的文件路径。之后，它开始播放音频文件。此时，生成 `pad_added` 信号。因此，根据输入文件数据，`decodebin`
    将创建垫。'
- en: The rest of the methods such as `processArgs, printUsage`, and `message_handler`
    are self-explanatory. You can review these methods from the file `AudioConverter.py`.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其余的方法，如`processArgs, printUsage`和`message_handler`都是不言自明的。您可以从`AudioConverter.py`文件中查看这些方法。
- en: The audio converter should be ready for action now! Make sure that all methods
    are properly defined and then run the code by specifying appropriate input arguments.
    The following screenshot shows a sample run of audio conversion utility on Windows
    XP. Here, it will batch process all audio files in directory `C:\AudioFiles` with
    extension `.ogg` and convert them into mp3 file format . The resultant mp3 files
    will be created in directory `C:\AudioFiles\OUTPUT_AUDIOS`.![Time for action -
    audio file format converter](img/0165_5_2.jpg)
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在音频转换器应该已经准备好使用了！请确保所有方法都已正确定义，然后通过指定适当的输入参数来运行代码。以下截图显示了在Windows XP上音频转换实用程序的示例运行。在这里，它将批量处理目录`C:\AudioFiles`中所有扩展名为`.ogg`的音频文件，并将它们转换为mp3文件格式。结果mp3文件将创建在目录`C:\AudioFiles\OUTPUT_AUDIOS`中。![行动时间
    - 音频文件格式转换器](img/0165_5_2.jpg)
- en: What just happened?
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: A basic audio conversion utility was developed in the previous section. This
    utility can batch-convert audio files with ogg or mp3 or wav format into user-specified
    output format (where supported formats are wav and mp3). We learned how to specify
    encoder and filesink elements and link them in the GStreamer pipeline. To accomplish
    this task, we also applied knowledge gained in earlier sections such as creation
    of GStreamer pipeline, capturing bus messages, running the main event loop, and
    so on.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中开发了一个基本的音频转换实用程序。此实用程序可以将ogg或mp3或wav格式的音频文件批量转换为用户指定的输出格式（其中支持的格式是wav和mp3）。我们学习了如何指定编码器和filesink元素，并在GStreamer管道中链接它们。为了完成此任务，我们还应用了之前章节中获得的有关创建GStreamer管道、捕获总线消息、运行主事件循环等方面的知识。
- en: Have a go hero do more with audio converter
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让英雄尝试使用音频转换器做更多的事情
- en: The audio converter we wrote is fairly simple. It deserves an upgrade.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的音频转换器相当简单。它值得升级。
- en: Extend this application to support more audio output formats such as `ogg, flac`,
    and so on. The following pipeline illustrated one way of converting an input audio
    file into ogg file format.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展此应用程序以支持更多音频输出格式，例如`ogg, flac`等。以下管道展示了将输入音频文件转换为ogg文件格式的一种方法。
- en: '[PRE35]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Notice that we have an audio muxer, oggmux, that needs to be linked with encoder
    vorbisenc. Similarly, to create an MP4 audio file, it will need { faac ! mp4mux}
    as encoder and audio muxer. One of the simplest things to do is to define proper
    elements (such as encoder and muxer) and instead of constructing a pipeline from
    individual elements, use the `gst.parse_launch` method we studied earlier and
    let it automatically create and link elements using the command string. You can
    create a pipeline instance each time the audio conversion is called for. But in
    this case you would also need to connect signals each time the pipeline is created.
    Another better and simpler way is to link the audio muxer in the `AudioConverter.constructPipeline`
    method. You just need to check if it is needed based on the type of plugin you
    are using for encoding. In this case the code will be:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们有一个音频复用器，oggmux，需要与编码器vorbisenc链接。同样，要创建MP4音频文件，它将需要{ faac ! mp4mux}作为编码器和音频复用器。最简单的事情之一是定义适当的元素（如编码器和复用器），而不是从单个元素构建管道，而是使用我们之前学习过的`gst.parse_launch`方法，并让它自动使用命令字符串创建和链接元素。每次音频转换被调用时，您都可以创建一个管道实例。但在这个情况下，您还需要在每次创建管道时连接信号。另一种更好、更简单的方法是在`AudioConverter.constructPipeline`方法中链接音频复用器。您只需根据您使用的编码器插件类型检查是否需要它。在这种情况下，代码将是：
- en: '[PRE36]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The audio converter illustrated in this example takes input files of only a
    single audio file format. This can easily be extended to accept input audio files
    in all supported file formats (except for the type specified by the `--output_format`
    option). The `decodebin` should take care of decoding the given input data. Extend
    Audio Converter to support this feature. You will need to modify the code in the
    `AudioConverter.convert()` method where the input file list is determined.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中展示的音频转换器仅接受单一音频文件格式的输入文件。这可以轻松扩展以接受所有支持的音频文件格式（除了由`--output_format`选项指定的类型）。`decodebin`应负责解码给定的输入数据。扩展音频转换器以支持此功能。您需要修改`AudioConverter.convert()`方法中的代码，其中确定了输入文件列表。
- en: Extracting part of an audio
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提取音频的一部分
- en: Suppose you have recorded a live concert of your favorite musician or a singer.
    You have saved all this into a single file with MP3 format but you would like
    to break this file into small pieces. There is more than one way to achieve this
    using Python and GStreamer. We will use the simplest and perhaps the most efficient
    way of cutting a small piece from an audio track. It makes use of an excellent
    GStreamer plugin, called Gnonlin.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经记录了你最喜欢的音乐家或歌手的现场音乐会。你将这些内容保存到一个MP3格式的单个文件中，但现在你希望将这个文件分割成小块。使用Python和GStreamer有多种方法可以实现这一点。我们将使用最简单且可能是最有效的方法从音频轨道中切割一小部分。它利用了一个优秀的GStreamer插件，称为Gnonlin。
- en: The Gnonlin plugin
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gnonlin插件
- en: The multimedia editing can be classified as linear or non-linear. Non-linear
    multimedia editing enables control over the media progress in an interactive way.
    For example, it allows you to control the order in which the sources should be
    executed. At the same time it allows modifications to the position in a media
    track. While doing all this, note that the original source (such as an audio file)
    remains unchanged. Thus the editing is non-destructive. The Gnonlin or (G-Non-Linear)
    provides essential elements for non-linear editing of a multimedia. It has five
    major elements, namely, `gnlfilesource, gnlurisource, gnlcomposition, gnloperation`,
    and `gnlsource`. To know more about their properties, run gst-inspect-0.10 command
    on each of these elements.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 多媒体编辑可以分为线性或非线性。非线性多媒体编辑允许以交互式方式控制媒体进度。例如，它允许你控制源应该执行的顺序。同时，它还允许修改媒体轨道中的位置。在进行所有这些操作时，请注意原始源（如音频文件）保持不变。因此，编辑是非破坏性的。Gnonlin或（G-Non-Linear）为多媒体的非线性编辑提供了基本元素。它有五个主要元素，即`gnlfilesource,
    gnlurisource, gnlcomposition, gnloperation`和`gnlsource`。要了解更多关于它们属性的信息，请在每个元素上运行`gst-inspect-0.10`命令。
- en: 'Here, we will only focus on the element gnlfilesource and a few of its properties.
    This is really a GStreamer bin element. Like decodebin, it determines which pads
    to use at the runtime. As the name suggests, it deals with the input media file.
    All you need to specify is the input media source it needs to handle. The media
    file format can be any of the supported media formats. The gnlfilesource defines
    a number of properties. To extract a chunk of an audio, we just need to consider
    three of them:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只关注元素gnlfilesource及其一些属性。这实际上是一个GStreamer bin元素。像decodebin一样，它在运行时确定使用哪些垫。正如其名所示，它处理输入媒体文件。你需要指定的只是它需要处理的输入媒体源。媒体文件格式可以是任何支持的媒体格式。gnlfilesource定义了多个属性。要提取音频的一部分，我们只需要考虑其中三个：
- en: '`media-start:` The position in the input media file, which will become the
    start position of the extracted media. This is specified in nanoseconds.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`media-start:` 输入媒体文件中的位置，它将成为提取媒体的开始位置。这也以纳秒为单位指定。'
- en: '`media-duration:` Total duration of the extracted media file (beginning from
    `media-start)`. This is specified in nanoseconds as well.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`media-duration:` 提取媒体文件的总体时长（从`media-start`开始）。这以纳秒为单位指定。'
- en: '`uri:` The full path of the input media file. For example, if it is a file
    on your local hard drive, the `uri` will be something like `file:///C:/AudioFiles/my_music.mp3`.
    If the file is located on a website, then the `uri` will something of this sort:
    `http://path/to/file.mp3`.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uri:` 输入媒体文件的完整路径。例如，如果它位于你的本地硬盘上，`uri`将类似于`file:///C:/AudioFiles/my_music.mp3`。如果文件位于网站上，那么`uri`将类似于这种形式：`http://path/to/file.mp3`。'
- en: The gnlfilesource internally does operations like loading and decoding the file,
    seeking the track to the specified position, and so on. This makes our job easier.
    We just need to create basic elements that will process the information furnished
    by gnlfilesource, to create an output audio file. Now that we know the basics
    of gnlfilesource, let's try to come up with a GStreamer pipeline that will cut
    a portion of an input audio file.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: gnlfilesource内部执行诸如加载和解码文件、定位到指定的位置等操作。这使得我们的工作变得简单。我们只需要创建一些基本元素来处理gnlfilesource提供的信息，以创建一个输出音频文件。现在我们已经了解了gnlfilesource的基础知识，让我们尝试构建一个GStreamer管道，该管道可以从输入音频文件中切割一部分。
- en: First the `gnlfilesource` element that does the crucial job of loading, decoding
    the file, seeking the correct start position, and finally presenting us with an
    audio data that represents the portion of track to be extracted.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，gnlfilesource元素执行至关重要的任务，包括加载、解码文件、定位到正确的起始位置，最后向我们展示代表要提取的轨道部分的音频数据。
- en: An `audioconvert` element that will convert this data into an appropriate audio
    format.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`audioconvert`元素，将此数据转换成适当的音频格式。
- en: An encoder that encodes this data further into the final audio format we want.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个编码器，将此数据进一步编码成我们想要的最终音频格式。
- en: A sink where the output data is dumped. This specifies the output audio file.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个输出数据被丢弃的容器。这指定了输出音频文件。
- en: Try running the following from the command prompt by replacing the uri and location
    paths with appropriate file paths on your computer.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试从命令提示符运行以下命令，用你电脑上的适当文件路径替换 uri 和位置路径。
- en: '[PRE37]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This should create an extracted audio file of duration 15 seconds, starting
    at the initial position on the original file. Note that the media-start and media-duration
    properties take the input in nanoseconds. This is really the essence of what we
    will do next.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该创建一个时长为 15 秒的提取音频文件，从原始文件上的初始位置开始。请注意，media-start 和 media-duration 属性以纳秒为单位接收输入。这正是我们接下来要做的本质。
- en: Time for action - MP3 cutter!
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - MP3切割器！
- en: In this section we will develop a utility that will cut out a portion of an
    MP3 formatted audio and save it as a separate file.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发一个工具，它将从一个 MP3 格式的音频中提取一部分并保存为单独的文件。
- en: Keep the file `AudioCutter.py` handy. You can download it from the Packt website.
    Here we will only discuss important methods. The methods not discussed here are
    similar to the ones from earlier examples. Review the file `AudioCutter.py` which
    has all the necessary source code to run this application.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请将文件`AudioCutter.py`放在手边。你可以从 Packt 网站下载它。在这里，我们只讨论重要的方法。这里未讨论的方法与早期示例中的类似。请查看包含运行此应用程序所需所有源代码的文件`AudioCutter.py`。
- en: Start the usual way. Do the necessary imports and write the following skeleton
    code.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照常规方式开始。进行必要的导入并编写以下骨架代码。
- en: '[PRE38]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The overall code layout looks familiar doesn't it? The code is very similar
    to the code we developed earlier in this chapter. The key here is the appropriate
    choice of the file source element and linking it with the rest of the pipeline!
    The last few lines of code create a thread with method AudioCutter.run and run
    the main event loop as seen before.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整体代码布局看起来很熟悉，不是吗？代码与我们本章早期开发的代码非常相似。关键是适当选择文件源元素并将其与管道的其余部分连接起来！代码的最后几行创建了一个线程，并运行了之前看到的主事件循环。
- en: Now fill in the constructor of the class. We will keep it simple this time.
    The things we need will be hardcoded within the constructor of the `class AudioCutter`.
    It is very easy to implement a `processArgs()` method as done on many occasions
    before. Replace the input and output file locations in the code snippet with a
    proper audio file path on your computer.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在填写类的构造函数。这次我们将保持简单。我们需要的东西将硬编码在`class AudioCutter`的构造函数中。实现一个`processArgs()`方法非常简单，就像之前多次做的那样。将代码片段中的输入和输出文件位置替换为电脑上的正确音频文件路径。
- en: '[PRE39]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: the `self.media_start_time` is the new starting position of the mp3 file in
    seconds. This is the new start position for the extracted output audio. The `self.duration`
    variable stores the total duration extracted track. Thus, if you have an audio
    file with a total duration of 5 minutes, the extracted audio will have a starting
    position corresponding to 1 min, 40 seconds on the original track. The total duration
    of this output file will be 30 seconds, that is, the end time will correspond
    to 2 minutes, 10 seconds on the original track. The last two lines of this method
    build a pipeline and connect signals with class methods.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`self.media_start_time` 是 mp3 文件的新起始位置（以秒为单位）。这是提取输出音频的新起始位置。`self.duration`
    变量存储提取的音频的总时长。因此，如果你有一个总时长为 5 分钟的音频文件，提取的音频将对应于原始轨道上的 1 分钟，40 秒。此输出文件的总时长将是 30
    秒，即结束时间将对应于原始轨道上的 2 分钟，10 秒。此方法最后两行代码构建了一个管道并将信号与类方法连接起来。'
- en: Next, build the GStreamer pipeline.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，构建 GStreamer 管道。
- en: '[PRE40]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The highlighted line of code (line 3) creates the gnlfilesource. We call this
    as self.filesrc. As discussed earlier, this is responsible for loading and decoding
    audio data and presenting only the required portion of audio data that we need.
    It enables a higher level of abstraction in the main pipeline.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '突出的代码行（第 3 行）创建了 gnlfilesource。我们将其称为 self.filesrc。如前所述，它负责加载和解码音频数据，并仅提供我们需要的音频数据部分。它为主管道提供了更高层次抽象。 '
- en: The code between lines 9 to 13 sets three properties of `gnlfilesource, uri,
    media-start` and `media-duration` . The `media-start` and `media-duration` are
    specified in nanoseconds. Therefore, we multiply the parameter value (which is
    in seconds) by `gst.SECOND` which takes care of the units.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第9行到第13行之间的代码设置了`gnlfilesource`的三个属性：`uri`、`media-start`和`media-duration`。`media-start`和`media-duration`以纳秒为单位指定。因此，我们将参数值（以秒为单位）乘以`gst.SECOND`，以处理单位。
- en: The rest of the code looks very much similar to the Audio Converter example.
    In this case, we only support saving the file in mp3 audio format. The encoder
    element is defined on line 19. `self.filesink` determines where the output file
    will be saved. Elements are added to the pipeline by self.pipeline.add call and
    are linked together on line 32\. Note that the `gnlfilesource` element, `self.filesrc`,
    is not linked with `self.audioconvert` while constructing the pipeline. Like the
    `decodebin`, the `gnlfilesource` implements dynamic pads. Thus, the pad is not
    available when the pipeline is constructed. It is created at the runtime depending
    on the specified input audio format. The "pad_added" signal of `gnlfilesource`
    is connected with a method `self.gnonlin_pad_added`.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其余的代码看起来与音频转换器示例非常相似。在这种情况下，我们只支持以mp3音频格式保存文件。编码器元素在第19行定义。`self.filesink`确定输出文件将保存的位置。通过`self.pipeline.add`调用将元素添加到管道中，并在第32行将它们连接起来。请注意，在构建管道时，`gnlfilesource`元素`self.filesrc`没有与`self.audioconvert`连接。像`decodebin`一样，`gnlfilesource`实现了动态垫。因此，垫在构建管道时不可用。它根据指定的输入音频格式在运行时创建。`gnlfilesource`的`pad_added`信号与`self.gnonlin_pad_added`方法连接起来。
- en: Now write the `connectSignals` and `gnonlin_pad_added` methods.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编写`connectSignals`和`gnonlin_pad_added`方法。
- en: '[PRE41]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The highlighted line of code in method connectSignals connects the pad_added
    signal of gnlfilesource with a method gnonlin_pad_added. The gnonlin_pad_added
    method is identical to the decodebin_pad_added method of class AudioConverter
    developed earlier. Whenever gnlfilesource creates a pad at the runtime, this method
    gets called and here, we manually link the pads of gnlfilesource with the compatible
    pad on self.audioconvert.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`connectSignals`方法中高亮的代码行将`gnlfilesource`的`pad_added`信号与`gnonlin_pad_added`方法连接起来。`gnonlin_pad_added`方法与之前开发的`AudioConverter`类的`decodebin_pad_added`方法相同。每当`gnlfilesource`在运行时创建一个垫时，此方法就会被调用，在这里，我们手动将`gnlfilesource`的垫与`self.audioconvert`上的兼容垫连接起来。
- en: The rest of the code is very much similar to the code developed in the *Playing
    an audio* section. For example, `AudioCutter.run` method is equivalent to `AudioPlayer.play`
    and so on. You can review the code for remaining methods from the file `AudioCutter.py`.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其余的代码与*播放音频*部分中开发的代码非常相似。例如，`AudioCutter.run`方法相当于`AudioPlayer.play`等等。你可以从`AudioCutter.py`文件中查看剩余方法的代码。
- en: 'Once everything is in place, run the program from the command line as:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一切准备就绪后，从命令行运行程序，如下所示：
- en: This should create a new MP3 file which is just a specific portion of the original
    audio file.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这应该会创建一个新的MP3文件，它只是原始音频文件的一个特定部分。
- en: '[PRE42]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: What just happened?
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We accomplished creation of a utility that can cut a piece out of an MP3 audio
    file (yet keep the original file unchanged). This audio piece was saved as a separate
    MP3 file. We learned about a very useful plugin, called Gnonlin, intended for
    non-linear multimedia editing. A few fundamental properties of gnlfilesource element
    in this plugin to extract an audio file.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了创建一个可以切割MP3音频文件的一部分（同时保持原始文件不变）的实用程序。这个音频片段被保存为一个单独的MP3文件。我们了解了一个非常实用的插件，称为Gnonlin，用于非线性多媒体编辑。我们学习了此插件中`gnlfilesource`元素的一些基本属性，用于提取音频文件。
- en: Have a go hero extend MP3 cutter
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试扩展MP3切割器
- en: Modify this program so that the parameters such as `media_start_time` can be
    passed as an argument to the program. You will need a method like `processArguments()`.
    You can use either `getopt` or `OptionParser` module to parse the arguments.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改此程序，以便将如`media_start_time`之类的参数作为参数传递给程序。你需要一个像`processArguments()`这样的方法。你可以使用`getopt`或`OptionParser`模块来解析参数。
- en: Add support for other file formats. For example, extend this code so that it
    can extract a piece from a wav formatted audio and save it as an MP3 audio file.
    The input part will be handled by `gnlfilesource`. Depending upon the type of
    output file format, you will need a specific encoder and possibly an audio muxer
    element. Then add and link these elements in the main GStreamer pipeline.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加对其他文件格式的支持。例如，扩展此代码，使其能够从 wav 格式的音频中提取一段并保存为 MP3 音频文件。输入部分将由 `gnlfilesource`
    处理。根据输出文件格式类型，你可能需要一个特定的编码器，可能还需要一个音频多路复用器元素。然后添加并链接这些元素到主 GStreamer 管道中。
- en: Recording
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 录制
- en: After learning how to cut out a piece from our favorite music tracks, the next
    exciting thing we will have is a 'home grown' audio recorder. Then use it the
    way you like to record music, mimicry or just a simple speech!
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习如何从我们最喜欢的音乐曲目中剪裁片段之后，接下来令人兴奋的事情将是一个“自产”的音频录制器。然后你可以按你喜欢的方式用它来录制音乐、模仿或简单的讲话！
- en: Remember what pipeline we used to play an audio? The elements in the pipeline
    to play an audio were `filesrc ! decodebin ! audioconvert ! autoaudiosink` . The
    autoaudiosink did the job of automatically detecting the output audio device on
    your computer.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们用来播放音频的管道吗？播放音频的管道元素包括 `filesrc ! decodebin ! audioconvert ! autoaudiosink`。autoaudiosink
    执行自动检测计算机上的输出音频设备的工作。
- en: For recording purposes, the audio source is going to be from the microphone
    connected to your computer. Thus, there won't be any `filesrc` element. We will
    instead replace with a GStreamer plugin that automatically detects the input audio
    device. On similar lines, you probably want to save the recording to a file. So,
    the `autoaudiosink` element gets replaced with a `filesink` element.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 对于录制目的，音频源将来自连接到你的计算机的麦克风。因此，将不会有任何 `filesrc` 元素。我们将用自动检测输入音频设备的 GStreamer 插件来替换它。按照类似的思路，你可能还想将录音保存到文件中。因此，`autoaudiosink`
    元素将被替换为 `filesink` 元素。
- en: autoaudiosrc is an element we can possibly use for detecting input audio source.
    However, while testing this program on Windows XP, the autoaudiosrc was unable
    to detect the audio source for unknown reasons. So, we will use the `Directshow`
    audio capture source plugin called dshowaudiosrc, to accomplish the recording
    task. Run the `gst-inspect-0.10 dshowaudiosrc` command to make sure it is installed
    and to learn various properties of this element. Putting this plugin in the pipeline
    worked fine on Windows XP. The `dshowaudiosrc` is linked to the audioconvert.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: autoaudiosrc 是一个我们可以用来检测输入音频源的元素。然而，在 Windows XP 上测试这个程序时，autoaudiosrc 由于未知原因无法检测音频源。因此，我们将使用名为
    dshowaudiosrc 的 `Directshow` 音频捕获源插件来完成录制任务。运行 `gst-inspect-0.10 dshowaudiosrc`
    命令以确保它已安装，并了解此元素的各种属性。将此插件放入管道在 Windows XP 上运行良好。`dshowaudiosrc` 与 audioconvert
    相连接。
- en: With this information, let's give it a try using the command-line version of
    GStreamer. Make sure you have a microphone connected or built into your computer.
    For a change, we will save the output file in `ogg` format.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个信息，让我们尝试使用 GStreamer 的命令行版本。确保你的计算机连接了麦克风或内置了麦克风。为了改变一下，我们将输出文件保存为 `ogg`
    格式。
- en: '[PRE43]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The audioresample re-samples the raw audio data with different sample rates.
    Then the encoder element encodes it. The multiplexer or mux, if present, takes
    the encoded data and puts it into a single channel. The recorded audio file is
    written to the location specified by the filesink element.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: audioresample 使用不同的采样率重新采样原始音频数据。然后编码元素对其进行编码。如果存在，多路复用器或 mux 将编码数据放入单个通道。录制的音频文件将写入由
    filesink 元素指定的位置。
- en: Time for action - recording
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 录制
- en: Okay, time to write some code that does audio recording for us.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在是时候编写一些代码来为我们进行音频录制了。
- en: Download the file `RecordingAudio.py` and review the code. You will notice that
    the only important task is to set up a proper pipeline for audio recording. Content-wise,
    the other code is very much similar to what we learned earlier in the chapter.
    It will have some minor differences such as method names and print statements.
    In this section we will discuss only the important methods in the `class AudioRecorder`.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载文件 `RecordingAudio.py` 并查看代码。你会注意到唯一重要的任务是为音频录制设置一个合适的管道。在内容上，其他代码与我们之前在章节中学到的非常相似。它将有一些小的差异，例如方法名称和打印语句。在本节中，我们将仅讨论
    `class AudioRecorder` 中的重要方法。
- en: Write the constructor.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写构造函数。
- en: '[PRE44]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This is similar to the `AudioPlayer.__init__()` except that we have added a
    call to `processArgs()` and initialized the error reporting variable `self.error_message`
    and the variable that indicates the total duration of the recording.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这与`AudioPlayer.__init__()`类似，但我们添加了对`processArgs()`的调用，并初始化了错误报告变量`self.error_message`以及表示录音总时长的变量。
- en: Build the GStreamer pipeline by writing `constructPipeline` method.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过编写`constructPipeline`方法来构建GStreamer管道。
- en: '[PRE45]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We use the `dshowaudiosrc` (Directshow audiosrc) plugin as an audio source element.
    It finds out the input audio source which will be, for instance, the audio input
    from a microphone.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`dshowaudiosrc`（Directshow audiosrc）插件作为音频源元素。它找出输入音频源，例如，来自麦克风的音频输入。
- en: On line 9, we set the number of buffers property to the one specified by `self.num_buffers`.
    This has a default value as `-1` , indicating that there is no limit on the number
    of buffers. If you specify this value as `500` for instance, it will output `500`
    buffers (5 second duration) before sending a **End of Stream** message to end
    the run of the program.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第9行，我们将缓冲区数量属性设置为`self.num_buffers`指定的值。默认值为`-1`，表示没有缓冲区数量的限制。例如，如果你将其指定为`500`，它将在发送**流结束**消息以结束程序运行之前输出`500`个缓冲区（5秒时长）。
- en: On line 15, an instance of element 'audioresample' is created. This element
    is takes the raw audio buffer from the `self.audioconvert` and re-samples it to
    different sample rates. The encoder element then encodes the audio data into a
    suitable format and the recorder file is written to the location specified by
    `self.filesink`.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第15行，创建了一个名为'audioresample'的元素实例。该元素从`self.audioconvert`获取原始音频缓冲区，并将其重新采样到不同的采样率。编码器元素随后将音频数据编码成合适的格式，并将录音文件写入由`self.filesink`指定的位置。
- en: The code between lines 28 to 35 adds various elements to the pipeline and links
    them together.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第28行到35行之间的代码向管道添加了各种元素并将它们连接起来。
- en: Review the code in file `RecordingAudio.py` to add rest of the code. Then run
    the program to record your voice or anything that you want to record that makes
    an audible sound! Following are sample command-line arguments. This program will
    record an audio for 5 seconds.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看文件`RecordingAudio.py`中的代码以添加剩余的代码。然后运行程序以录制你的声音或任何你想录制的可听声音！以下是一些示例命令行参数。此程序将录制5秒钟的音频。
- en: '[PRE46]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: What just happened?
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We learned how to record an audio using Python and GStreamer. We developed a
    simple audio recording utility to accomplish this task. The GStreamer plugin,
    dshowaudiosrc, captured the audio input for us. We created the main GStreamer
    Pipeline by adding this and other elements and used it for the Audio Recorder
    program.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何使用Python和GStreamer录制音频。我们开发了一个简单的音频录制工具来完成这项任务。GStreamer插件dshowaudiosrc为我们捕获了音频输入。我们通过添加这个和其他元素创建了主要的GStreamer管道，并用于音频录制程序。
- en: Summary
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'This chapter gave us deeper insight into the fundamentals of audio processing
    using Python and the GStreamer multimedia framework. We used several important
    components of GStreamer to develop some frequently needed audio processing utilities.
    The main learning points of the chapter can be summarized as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 本章让我们对使用Python和GStreamer多媒体框架进行音频处理的基础有了更深入的了解。我们使用了GStreamer的几个重要组件来开发一些常用的音频处理工具。本章的主要学习要点可以总结如下：
- en: 'GStreamer installation: We learned how to install GStreamer and the dependent
    packages on various platforms. This set up a stage for learning audio processing
    techniques and will also be useful for the next chapters on audio/video processing.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GStreamer安装：我们学习了如何在各种平台上安装GStreamer及其依赖包。这为学习音频处理技术搭建了舞台，也将对下一章的音频/视频处理章节有所帮助。
- en: 'A primer on GStreamer: A quick primer on GStreamer helped us understand important
    elements required for media processing.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GStreamer入门：快速入门GStreamer帮助我们理解了媒体处理所需的重要元素。
- en: 'Use of GStreamer API to develop audio tools: We learned how to use GStremer
    API for general audio processing. This helped us develop tools such as an Audio
    player, a file format converter, an MP3 cutter, and audio recorder.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GStreamer API开发音频工具：我们学习了如何使用GStreamer API进行通用音频处理。这帮助我们开发了音频播放器、文件格式转换器、MP3切割器和音频录制器等工具。
- en: Now that we've learned about basic audio processing using GStreamer, we're ready
    to add some 'spice' to the audio. In the next chapter we will learn techniques
    that will help us add special effects to an audio.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了使用 GStreamer 进行基本音频处理，我们准备给音频添加一些“风味”。在下一章中，我们将学习一些技巧，这些技巧将帮助我们为音频添加特殊效果。
