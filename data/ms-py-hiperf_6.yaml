- en: Chapter 6. Generic Optimization Options
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 通用优化选项
- en: 'In the never-ending road to mastering optimization, we started by covering
    some tips and tricks in [Chapter 4](ch04.html "Chapter 4. Optimize Everything"),
    *Optimize Everything*. In [Chapter 5](ch05.html "Chapter 5. Multithreading versus
    Multiprocessing"), *Multithreading versus Multiprocessing*, we went over two major
    optimization strategies: multithreading and multiprocessing. We saw how they help
    us and when to use them.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在不断追求掌握优化的道路上，我们首先在[第4章](ch04.html "第4章. 优化一切")*优化一切*中介绍了一些技巧和窍门。在[第5章](ch05.html
    "第5章. 多线程与多进程")*多线程与多进程*中，我们讨论了两种主要的优化策略：多线程和多进程。我们看到了它们如何帮助我们以及何时使用它们。
- en: 'Finally, we will deal with one of the many implementations of the Python language
    (CPython). This implies that there are other alternatives to CPython. In this
    chapter, we''ll cover two of them:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将处理Python语言（CPython）的许多实现之一。这意味着除了CPython之外还有其他替代方案。在本章中，我们将介绍其中的两个：
- en: We'll cover PyPy, an alternative to the standard Python interpreter we've been
    using throughout the book. This one is written in Python and has some benefits
    over the standard version.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将介绍PyPy，这是本书中一直使用的标准Python解释器的替代方案。这个版本是用Python编写的，并且比标准版本有一些优势。
- en: We will talk about Cython, an optimizing static compiler, which will allow us
    to write Python code and tap into the power of C and C++ easily.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将讨论Cython，一个优化静态编译器，它将使我们能够轻松地编写Python代码并利用C和C++的强大功能。
- en: Both alternatives will provide developers with the opportunity to run code in
    a more optimized fashion, depending, of course, on the characteristics of that
    code. For each option, we'll look into what exactly they are, how to install them,
    and some example code on how to use them.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种替代方案都将为开发者提供以更优化方式运行代码的机会，当然，这取决于代码的特性。对于每个选项，我们将探讨它们究竟是什么，如何安装它们，以及一些示例代码来展示如何使用它们。
- en: PyPy
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PyPy
- en: Just like CPython is the standard implementation of the Python specifications
    and is written in C (of course), PyPy is an alternative implementation of Python,
    both for version 2.x and 3.x. It tries to mimic the behavior of the language that
    is written in RPython, a limited version of Python with static types.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 就像CPython是Python规范的官方实现，并且是用C语言编写的（当然），PyPy是Python的另一种实现，适用于2.x和3.x版本。它试图模仿RPython语言的行为，RPython是Python的一个静态类型限制版本。
- en: The PyPy project ([http://pypy.org/](http://pypy.org/)) is a continuation of
    another, older project called Psycho, which was a JIT compiler for Python, written
    in C. It worked great on 32-bit Intel processors, but it was never updated. Its
    latest stable release was in 2007, so it is now deprecated. PyPy took over in
    2007 with its 1.0 release. Although it was initially considered a research project,
    it grew over the years. Finally, in 2010, version 1.4 was released. With this
    version, there was an increase in confidence that systems written in PyPy were
    production ready and compatible with Python 2.5.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: PyPy项目([http://pypy.org/](http://pypy.org/))是另一个名为Psycho的较老项目的延续，Psycho是一个用C语言编写的Python
    JIT编译器。它在32位Intel处理器上工作得很好，但从未更新过。它的最新稳定版本是在2007年，因此现在已弃用。PyPy在2007年通过其1.0版本接管了Psycho。尽管最初被认为是一个研究项目，但随着时间的推移，它不断发展。最终，在2010年，发布了1.4版本。在这个版本中，人们对用PyPy编写的系统是生产就绪且与Python
    2.5兼容的信心有所增加。
- en: The latest stable version of PyPy, released in June 2014, is version 2.5, which,
    in turn, is compatible with Python 2.7\. There is also a beta release of PyPy3,
    which is, as expected, a version of PyPy that is compatible with Python 3.x.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: PyPy的最新稳定版本，于2014年6月发布，版本为2.5，它反过来与Python 2.7兼容。还有一个PyPy3的beta版本，正如预期的那样，是与Python
    3.x兼容的PyPy版本。
- en: 'The reason we will go over PyPy as a viable way of optimization for our scripts
    is due to these features:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍PyPy作为我们脚本优化可行方法的原因是这些特性：
- en: '**Speed**: One of the main features of PyPy is its speed boost over regular
    Python. This is due to the in-built **Just-in-time** (**JIT**) compiler. It provides
    flexibility over statically compiled code, since it can adapt to the current platform
    (processor type, OS version, and so on) during execution time. On the other hand,
    a statically compiled program would need one executable or every single combination
    of cases.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**：PyPy的主要特性之一是其相对于常规Python的速度提升。这得益于内置的**即时编译器**（**JIT**）。它提供了对静态编译代码的灵活性，因为它可以在执行时适应当前平台（处理器类型、操作系统版本等）。另一方面，静态编译程序可能需要一个可执行文件或每个单独的情况组合。'
- en: '**Memory**: Memory-consuming scripts will consume much less memory when executed
    using PyPy than with regular CPython.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存**：使用 PyPy 执行内存消耗型脚本时，比使用常规 CPython 消耗的内存要少得多。'
- en: '**Sandboxing**: PyPy provides a sandboxing environment where every call to
    an external C library is stubbed. These calls communicate with an external process
    that handles the actual policy. Although this feature is promising, it is still
    only a prototype and needs more work to become useful.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**沙盒**：PyPy 提供了一个沙盒环境，其中每个对外部 C 库的调用都被模拟。这些调用与处理实际策略的外部进程进行通信。尽管这个特性很有前景，但它仍然只是一个原型，需要更多的工作才能变得有用。'
- en: '**Stackless**: PyPy also provides a somewhat equivalent set of language features
    to the ones provided by Stackless Python ([http://www.stackless.com/](http://www.stackless.com/)).
    Some may even consider it a more powerful and flexible version than the latter.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无栈**：PyPy 也提供了一组与 Stackless Python 相当的语言功能（[http://www.stackless.com/](http://www.stackless.com/)）。有些人甚至认为它比后者更强大和灵活。'
- en: Installing PyPy
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 PyPy
- en: 'There are several ways to install PyPy into your system:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以将 PyPy 安装到您的系统中：
- en: You can download the binary files directly from their page ([http://pypy.org/download.html#default-with-a-jit-compiler](http://pypy.org/download.html#default-with-a-jit-compiler)).
    Just make sure you download the right file, according to the OS indication next
    to the link on their website. Otherwise, there is a good chance it won't work
    on your system:![Installing PyPy](img/B02088_06_08.jpg)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以直接从他们的页面下载二进制文件（[http://pypy.org/download.html#default-with-a-jit-compiler](http://pypy.org/download.html#default-with-a-jit-compiler)）。只需确保您下载了正确的文件，根据他们网站上链接旁边的操作系统指示即可。否则，有很大可能它不会在您的系统上运行：![安装
    PyPy](img/B02088_06_08.jpg)
- en: 'If you''re using a Linux distribution or OS X, you can check whether its official
    package repository contains the PyPy package. Normally, systems such as Ubuntu,
    Debian, Homebrew, MacPorts, Fedora, Gentoo, and Arch tend to have it already.
    For Ubuntu, you can use the following line of code:'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您使用的是 Linux 发行版或 OS X，您可以检查其官方软件包仓库是否包含 PyPy 软件包。通常，像 Ubuntu、Debian、Homebrew、MacPorts、Fedora、Gentoo
    和 Arch 这样的系统已经包含了它。对于 Ubuntu，您可以使用以下代码行：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Finally, another option is to download the source code and compile it yourself.
    This might be a harder task than downloading the binaries. However, if done correctly,
    it would assure you that the resulting installation is fully compatible with your
    system.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，另一个选项是下载源代码并自行编译。这可能比下载二进制文件更困难。然而，如果操作正确，这将确保生成的安装与您的系统完全兼容。
- en: Note
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Be warned though, compiling from source might sound like an easy task, but
    it will take a considerable amount of time. On an i7 with 8 GB of RAM, the entire
    process took about an hour, as shown in the following screenshot:'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但是要警告，从源代码编译可能听起来像是一项简单的任务，但它将花费相当多的时间。在一个 i7 处理器上，8 GB 的 RAM，整个过程大约花费了一个小时，如下面的截图所示：
- en: '![Installing PyPy](img/B02088_06_10.jpg)'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![安装 PyPy](img/B02088_06_10.jpg)'
- en: A Just-in-time compiler
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 即时编译器
- en: This is one of the main features provided by PyPy. It's the main reason for
    its superior speed results compared to regular Python (CPython).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 PyPy 提供的主要功能之一。这是它与常规 Python（CPython）相比速度更快的最主要原因。
- en: According to PyPy's official site, the performance might vary depending on the
    task, but on average, this compiler claims to be seven times faster than CPython.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 PyPy 的官方网站，性能可能会根据任务而变化，但平均而言，这个编译器声称比 CPython 快七倍。
- en: Normally, with standard compiled programs, we translate the entire source code
    into machine code before we even execute it the first time. Otherwise, we won't
    be able to try it. This is the standard set of steps that normally compiled programs
    go through (preprocessing and translation of the source code, and finally, assembling
    and linking).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对于标准编译程序，我们在第一次执行之前将整个源代码转换成机器代码。否则，我们将无法尝试它。这是通常编译程序经过的标准步骤（预处理和源代码翻译，最后是汇编和链接）。
- en: 'JIT means that the compilation of our code will take place during execution
    time instead of before it. What normally happens is that the code is translated
    in a two-step process:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: JIT 意味着我们的代码将在执行时而不是在执行前进行编译。通常发生的情况是，代码在两步过程中被翻译：
- en: First, the original source code is translated into an intermediate language.
    For some languages, such as Java, it is called bytecode.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，原始源代码被转换成中间语言。对于某些语言，如 Java，它被称为字节码。
- en: After we have the bytecode, we start compiling it and translating it into machine
    code, but only when we need it. One of the peculiarities of JIT compilers is that
    they only compile the code that needs to be run, and not everything at once.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们得到字节码后，我们开始编译它并将其转换为机器码，但仅在我们需要时进行。即时编译器的一个特点是它们只编译需要运行的代码，而不是一次性编译所有代码。
- en: The second step is what differentiates this type of implementation from other
    interpreted languages, such as CPython, when the bytecode is interpreted instead
    of being compiled. Additionally, JIT compilers normally cache compiled code so
    that the next time it is needed, the overhead of compilation will be avoided.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是区分此类实现与其他解释语言（如CPython，当字节码被解释而不是编译时）的不同之处。此外，即时编译器通常缓存编译后的代码，以便下次需要时避免编译开销。
- en: With all of this in mind, it is clear that for a program to take real advantage
    of a JIT compiler, it needs to run for at least a few seconds so that the instruction
    caching can take effect. Otherwise, the effect might be the opposite of what is
    intended, since the overhead of the compilation will be the only real-time difference
    that the developer will notice.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，很明显，为了使程序真正利用即时编译器，它至少需要运行几秒钟，以便指令缓存能够生效。否则，效果可能与预期相反，因为编译的开销将是开发者唯一能注意到的实时差异。
- en: One of the main advantages of using a JIT compiler is that the program being
    executed is able to optimize the machine code for the specific system it is running
    on (including CPU, OS, and so on). Thus, it provides a level of flexibility that
    is completely out of scope for static compiled (and even interpreted) programs.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用即时编译器的一个主要优点是正在执行的程序能够针对其运行的特定系统（包括CPU、操作系统等）优化机器码。因此，它提供了一种完全超出静态编译（甚至解释）程序范围的灵活性。
- en: Sandboxing
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 沙盒技术
- en: Although the sandboxing feature of PyPy is still considered as a prototype,
    we'll cover its basics internal workings to understand the potential it provides.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管PyPy的沙盒功能仍被视为原型，但我们将探讨其基本内部工作原理，以了解它提供的潜力。
- en: Sandboxing consists of providing a safe environment where untrusted Python code
    can run without any fear of causing harm to the host system.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 沙盒技术包括提供一个安全的环境，其中不受信任的Python代码可以运行，而无需担心对宿主系统造成损害。
- en: 'This is achieved in PyPy in particular through a two-process model:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在PyPy中，这特别通过双进程模型实现：
- en: On one side, we have a customized version of PyPy compiled specifically to function
    in the sandbox mode. In particular, this means that any library or system call
    (I/O for instance) gets marshaled into `stdout` waiting for a marshaled response
    back.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一方面，我们有一个定制的PyPy版本，专门编译以在沙盒模式下运行。特别是，这意味着任何库或系统调用（例如I/O）都会被打包到`stdout`，等待打包的响应返回。
- en: On the other hand, we have a container process, which could be running using
    PyPy or CPython. This process will take care of answering the library and system
    calls from the internal PyPy process:![Sandboxing](img/B02088_06_09.jpg)
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一方面，我们有一个容器进程，它可能正在使用PyPy或CPython运行。此进程将负责处理来自内部PyPy进程的库和系统调用：![沙盒技术](img/B02088_06_09.jpg)
- en: The preceding diagram shows the entire process where a piece of Python code
    that is executed in the sandbox mode is doing an external library call.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示显示了整个过程，其中在沙盒模式下执行的Python代码正在执行外部库调用。
- en: The container process is the one that decides what type of virtualization it
    provides. For instance, the inner process could be creating file handlers, which,
    in reality, are being faked by the container process. The process acts as a layer
    between the real OS and the sandboxed process.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 容器进程是决定提供哪种虚拟化的进程。例如，内部进程可能正在创建文件句柄，实际上这些句柄是由容器进程伪造的。该进程充当真实操作系统和沙盒进程之间的一个层。
- en: Note that the mechanics explained earlier are very different from sandboxing
    at the language level. The entire set of instructions is available to the developer.
    Thus, you achieve a very transparent and secure system with code that could very
    well run on a standard system and on a secured one.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面解释的机制与语言层面的沙盒技术非常不同。整个指令集都对开发者可用。因此，你可以通过代码实现一个非常透明且安全的系统，这些代码可以在标准系统和受保护系统中运行。
- en: Optimizing for the JIT
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化即时编译器
- en: Like we already discussed, the JIT from PyPy is what sets it apart from CPython's
    implementation. It is this same feature that makes it so fast when running Python
    code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，PyPy 的 JIT 是使其与 CPython 实现区分开来的因素。正是这个特性使得它在运行 Python 代码时如此之快。
- en: Just using PyPy directly on our unchanged Python code, we'll most likely get
    better results. However, we should take into account some guidelines if we want
    to optimize our code even further.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 直接在我们的未更改的 Python 代码上使用 PyPy，我们很可能会得到更好的结果。然而，如果我们想进一步优化我们的代码，我们应该考虑一些指导原则。
- en: Think of functions
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 想象函数
- en: JIT works by analyzing which functions are "hotter" (get executed more times)
    than others. Thus, we're better off structuring our code into functions, specifically
    for functions that will be executed repeatedly.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: JIT 通过分析哪些函数比其他函数“更热”（执行次数更多）来工作。因此，我们最好将我们的代码结构化为函数，特别是对于将被重复执行的函数。
- en: 'Let''s see a quick example. The following code will show the time difference
    between doing the same calculation directly inline versus having it encapsulated
    inside a function and dealing with the added time relating to the function lookup
    and the function call itself:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个快速示例。以下代码将显示直接内联执行相同计算与将其封装在函数内并处理与函数查找和函数调用本身相关的额外时间之间的时间差异：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code is very simple, but you can still see how the second output shows that
    it is the faster implementation. Regular old CPython will work the opposite way,
    since there is no real-time optimization of the code. The second approach will
    yield slightly worse results because of the overhead of the function lookup and
    function call code. However, PyPy and its JIT prove once again that if you want
    to optimize your code for them, you need to stop thinking the old way.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 代码非常简单，但你仍然可以看到第二个输出显示了它是更快的实现。普通的旧 CPython 将以相反的方式工作，因为没有对代码进行实时优化。第二种方法会因为函数查找和函数调用代码的开销而得到稍微差一点的结果。然而，PyPy
    和它的 JIT 再次证明，如果你想为它们优化代码，你需要停止用老的方式思考。
- en: '![Think of functions](img/B02088_06_11.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![想象函数](img/B02088_06_11.jpg)'
- en: 'The results from the preceding screenshot show what we''ve been discussing
    so far:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图结果显示了我们之前一直在讨论的内容：
- en: PyPy runs the same code considerably faster than CPython
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyPy 运行的代码比 CPython 快得多
- en: The JIT is optimizing our code in real time while CPython isn't
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JIT 正在实时优化我们的代码，而 CPython 则不是
- en: Consider using cStringIO to concatenate strings
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 考虑使用 cStringIO 来连接字符串
- en: This is not a small optimization, with respect to both code changes and achieved
    optimization. We've already covered the fact that for Python, strings are immutable
    objects. So, if we want to concatenate a large number of strings into a single
    one, we would be better off doing it with another structure instead of the string
    itself, since that would yield the worst performance.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个小优化，无论是从代码更改还是从实现的优化来看。我们已经讨论了对于 Python 来说，字符串是不可变对象的事实。所以，如果我们想将大量字符串连接成一个单一的字符串，我们最好使用另一种结构而不是字符串本身，因为那会带来最差的表现。
- en: In the case of PyPy, it still holds true. However, instead of using lists as
    the best option, we'll use the `cStringIO` module ([http://pymotw.com/2/StringIO/](http://pymotw.com/2/StringIO/)),
    which, as we'll see, provides the best results.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PyPy 的情况下，这仍然成立。然而，我们不会使用列表作为最佳选择，而是会使用 `cStringIO` 模块 ([http://pymotw.com/2/StringIO/](http://pymotw.com/2/StringIO/))，正如我们将看到的，它提供了最佳结果。
- en: 'Note that because of the nature of PyPy, mentioning `cStringIO` instead of
    `StringIO` might be confusing, since we''re referencing a C standard library instead
    of a pure Python one. This is correct and valid, since some of the C standard
    libraries common to CPython also work correctly on PyPy. In our case, the following
    code will calculate the time needed to perform the same concatenation operation
    in three different ways (using simple strings, using the `cStringIO` library,
    and finally, using lists):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于 PyPy 的特性，提到 `cStringIO` 而不是 `StringIO` 可能会令人困惑，因为我们引用的是 C 标准库而不是纯 Python
    库。这是正确和有效的，因为一些在 CPython 中常见的 C 标准库在 PyPy 上也能正确工作。在我们的例子中，以下代码将以三种不同的方式（使用简单字符串、使用
    `cStringIO` 库，最后使用列表）计算执行相同连接操作所需的时间：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Out of the three alternatives, `StringIO` is the best one in PyPy. It is much
    better than simple string concatenation, and even slightly better than using lists.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三种替代方案中，`StringIO` 在 PyPy 中是最好的。它比简单字符串连接要好得多，甚至比使用列表还要好一点。
- en: If we run the same code through CPython, we will get different results. Thus,
    the best solution is still using lists.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过 CPython 运行相同的代码，我们将得到不同的结果。因此，最好的解决方案仍然是使用列表。
- en: '![Consider using cStringIO to concatenate strings](img/B02088_06_12.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![考虑使用 cStringIO 来连接字符串](img/B02088_06_12.jpg)'
- en: The preceding screenshot corroborates this. Note how with PyPy, the first approach
    is especially bad performance-wise.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图证实了这一点。注意，在使用 PyPy 时，第一种方法在性能方面尤其糟糕。
- en: Actions that disable the JIT
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 禁用 JIT 的操作
- en: Although not directly an optimization, there are some specific methods that
    will disable the effectiveness of the JIT if we use them. So, it's important to
    know about these methods.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这并不是直接的优化，但有一些特定的方法，如果我们使用它们，将会降低 JIT 的有效性。因此，了解这些方法很重要。
- en: 'The following three methods from the `sys` module disable the JIT (according
    to the current version of PyPy; this could, of course, change in the future):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下来自 `sys` 模块的三种方法可以禁用 JIT（根据当前 PyPy 版本；当然，这在未来可能会改变）：
- en: '`_getframe`: This method returns a frame object from the `callstack`. It even
    accepts an optional depth parameter that returns frame objects back from the `callstack`.
    The performance penalty is quite big, so its use is recommended only when it is
    absolutely needed, such as when developing a debugger.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_getframe`：此方法从 `callstack` 返回一个帧对象。它甚至接受一个可选的深度参数，可以从 `callstack` 返回帧对象。性能惩罚相当大，因此只有在绝对需要时才推荐使用，例如在开发调试器时。'
- en: '`exc_info`: This method returns a tuple of three elements that provide information
    about the exception being handled. These elements are `type`, `value`, and `traceback`.
    They are explained here:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exc_info`：此方法返回一个包含三个元素的元组，提供了有关正在处理的异常的信息。这些元素是 `type`、`value` 和 `traceback`。它们在这里解释：'
- en: '`type`: This is the type of the exception being handled'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`：这是正在处理的异常的类型'
- en: '`value`: This gets the exception parameter'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`：此方法获取异常参数'
- en: '`traceback`: This gets the `traceback` object, which encapsulates a `callstack`
    object the moment the exception was thrown'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`traceback`：此方法获取 `traceback` 对象，它封装了异常抛出时的 `callstack` 对象'
- en: '`Settrace`: This method sets the tracing function, which allows you to trace
    Python code from within Python. As mentioned earlier, its use is not recommended
    unless it is absolutely necessary, since it needs to disable the JIT in order
    to work properly.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Settrace`：此方法设置跟踪函数，允许您在 Python 中跟踪 Python 代码。如前所述，除非绝对必要，否则不建议使用，因为它需要禁用
    JIT 才能正常工作。'
- en: Code sample
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码示例
- en: As a final example for this topic, let's take a look at the code from the `great_circle`
    function (explained later). The great circle calculation consists of finding the
    distance between two points on the earth's surface.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个主题的最后一个例子，让我们来看看 `great_circle` 函数的代码（稍后解释）。大圆计算包括在地球表面上找到两点之间的距离。
- en: The script will do a `for` loop of 5 million iterations. In particular, it calls
    the same function over and over (5 million times to be precise). This scenario
    is less than ideal for the CPython interpreter, since it will complete the function
    lookup that many times.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本将执行 500 万次迭代的 `for` 循环。特别是，它反复调用相同的函数（精确地说是 500 万次）。这种场景对于 CPython 解释器来说并不理想，因为它将完成那么多次函数查找。
- en: 'However, on the other hand and as we''ve already mentioned, calling the same
    function over time allows for PyPy''s JIT to start optimizing that call. This
    basically means that in our case, the code is already somewhat optimized for PyPy:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，另一方面，正如我们之前提到的，随着时间的推移调用相同的函数可以让 PyPy 的 JIT 开始优化这个调用。这基本上意味着在我们的情况下，代码已经对
    PyPy 进行了某种程度的优化：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code can be further optimized following the same principle we
    just mentioned. We can remove one line from the `great_circle` function into a
    separate function, optimizing that execution even further, as shown here:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码可以根据我们刚才提到的相同原则进一步优化。我们可以将 `great_circle` 函数中的一行移到单独的函数中，从而进一步优化执行，如下所示：
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can see how we moved the `acos` calculation into a separate function, since
    it was the most expensive line in the entire function (there is a total of six
    trig functions being called there). By moving that line into another function,
    we allowed the JIT to take care of optimizing its calls.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我们如何将 `acos` 计算移动到单独的函数中，因为它是整个函数中最昂贵的行（那里总共调用了六个三角函数）。通过将这一行移动到另一个函数中，我们允许
    JIT 处理其调用的优化。
- en: In the end, due to that simple change and the fact that we're using PyPy instead
    of regular Python, we have an execution time of 0.5 seconds. If, on the other
    hand, we were to run that same code using regular CPython, we would get a time
    of 4.5 seconds (on my current machine), which is considerably slower.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于这个简单的改变以及我们使用PyPy而不是常规Python的事实，我们的执行时间为0.5秒。相反，如果我们使用常规CPython运行相同的代码，我们将会得到4.5秒的时间（在我的当前机器上），这要慢得多。
- en: Cython
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cython
- en: Although technically, Cython ([http://cython.org/](http://cython.org/)) is not
    exactly an alternative to using the standard CPython interpreter, it will let
    us write Python code and compile it into C (something CPython doesn't do).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然技术上讲，Cython ([http://cython.org/](http://cython.org/)) 并非完全等同于使用标准的CPython解释器，但它允许我们编写Python代码并将其编译成C代码（这是CPython所不具备的）。
- en: You'll see that Cython could be considered a transpiler, which simply means
    it's a piece of software meant to translate source code from one language into
    another. There are other similar products out there, such as CoffeeScript and
    Dart. Both are very different languages, and both are translated into JavaScript.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到Cython可以被视为一个转译器，这仅仅意味着它是一段软件，旨在将源代码从一种语言翻译成另一种语言。还有其他类似的产品，例如CoffeeScript和Dart。两者都是截然不同的语言，并且都被翻译成JavaScript。
- en: 'In our case, Cython translates a super set of Python (an extended version of
    the language) into optimized C/C++ code. Then, it''s compiled into a Python extension
    module. This, in turn, allows the developer to:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，Cython将Python的超集（语言的扩展版本）转换为优化的C/C++代码。然后，它被编译成一个Python扩展模块。这反过来又允许开发者：
- en: Write Python code that calls back and forth C or C++ code natively
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写调用C或C++代码的Python代码
- en: Tune Python code into C-level performance using static-type declarations
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用静态类型声明将Python代码调整为C级性能
- en: Static typing is the key feature that allows this transpiler to generate optimized
    C code, thus letting Cython move out of the dynamic nature of Python into a more
    static, yet faster, territory (sometimes, even by several orders of magnitude).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类型是允许这个转译器生成优化C代码的关键特性，从而使Cython从Python的动态特性中脱离出来，进入一个更静态、更快的领域（有时甚至可以快几个数量级）。
- en: This, of course, makes the Python code more verbose, which, in turn, might hurt
    other aspects such as maintainability and readability. So, normally, using static
    typing is not recommended unless there is some kind of proof that clearly shows
    that adding it will indeed generate a faster running code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这使得Python代码更加冗长，这反过来可能会损害其他方面，如可维护性和可读性。因此，通常情况下，除非有某种明确的证据表明添加它确实会生成运行速度更快的代码，否则不建议使用静态类型。
- en: All C types are available for developers to use. Cython is prepared to automatically
    perform type conversion on assignment. In the special case of Python's arbitrary
    long integers, when casting to C's integers, a Python overflow error will be raised
    if an overflow does happen.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 所有C类型都可供开发者使用。Cython准备在赋值时自动执行类型转换。在Python的任意长整数特殊情况下，当转换为C的整数时，如果发生溢出，将引发Python溢出错误。
- en: 'The following table shows the same example written in pure Python and the Cython
    version:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 下表展示了纯Python版本和Cython版本的相同示例：
- en: '| Python version | Cython version |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| Python版本 | Cython版本 |'
- en: '| --- | --- |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The main difference in both codes is highlighted. It is only the definition
    of the types of every variable, both the parameters received by both functions,
    and the local variables used. With this alone, Cython can generate an optimized
    C version of the code on the left-hand side.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 两个代码之间的主要区别被突出显示。这仅仅是每个变量的类型定义，包括两个函数接收的参数以及使用的局部变量。仅凭这一点，Cython就可以生成左侧代码的优化C版本。
- en: Installing Cython
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Cython
- en: There are a couple of ways to install Cython into your system. However, for
    every case, the common requirement is to have a C compiler previously installed.
    We will not go over the steps required for this, because the instructions might
    vary from system to system.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Cython到你的系统中有几种方法。然而，在每种情况下，共同的要求是之前已经安装了一个C编译器。我们不会详细说明这一步骤，因为指令可能因系统而异。
- en: 'Once the C compiler is installed, in order to get Cython, you can perform these
    steps:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了C编译器，为了获取Cython，你可以执行以下步骤：
- en: 'Download the latest release from their website ([http://cython.org](http://cython.org)),
    unpack the tarball file, enter the directory, and run the following command:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从他们的网站上下载最新版本 ([http://cython.org](http://cython.org))，解压tarball文件，进入目录，并运行以下命令：
- en: '[PRE7]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you have the setup tools installed in your system, you can run this command:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你已经在系统中安装了设置工具，你可以运行此命令：
- en: '[PRE8]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you''re already using one of the following development environments, it''s
    quite likely that Cython is already installed in your system. However, you can
    use the earlier steps to update your current version as well:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你已经使用以下开发环境之一，那么Cython很可能已经安装在你的系统中。然而，你也可以使用前面的步骤来更新你的当前版本：
- en: Anaconda
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Anaconda
- en: Enthought Canopy
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Enthought Canopy
- en: PythonXY
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: PythonXY
- en: Sage
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sage
- en: Building a Cython module
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建Cython模块
- en: 'Cython is able to compile our code into C modules, which we can later import
    into our main code. In order to do this, you need to carry out the following steps:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Cython能够将我们的代码编译成C模块，我们稍后可以将这些模块导入到主代码中。为了做到这一点，你需要执行以下步骤：
- en: First, a `.pyx` file needs to be compiled (or translated) into a `.c` file by
    Cython. These are the source code files, basically Python code with some extensions
    added by Cython. We'll see some examples in a bit.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，需要使用Cython将`.pyx`文件编译（或转换）成`.c`文件。这些是源代码文件，基本上是带有Cython添加的一些扩展的Python代码。我们稍后会看到一些示例。
- en: The `.c` file will, in turn, be compiled into a `.so` library by the C compiler.
    This library can later be imported by Python.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`.c`文件将被C编译器编译成`.so`库。这个库稍后可以被Python导入。'
- en: 'There are several ways in which we can compile the code, as explained earlier:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，我们有几种方法可以编译代码：
- en: We can create a `distutils` setup file. Distutils is a module that facilitates
    the creation of other modules, so we can use it to generate our custom C-compiled
    ones.
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建一个`distutils`设置文件。Distutils是一个模块，它简化了其他模块的创建，因此我们可以使用它来生成我们自定义的C编译模块。
- en: We can run the `cython` command line to create a `.c` file from the `.pyx` one.
    Then, use the C compiler to manually compile the C code into the library.
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以运行`cython`命令行，从`.pyx`文件创建一个`.c`文件。然后，使用C编译器手动将C代码编译成库。
- en: Finally, another option would be to use the `pyximport` module and import the
    `.pyx` files as if they were `.py` files.
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，另一个选项是使用`pyximport`模块，并将`.pyx`文件作为`.py`文件导入。
- en: 'To illustrate the preceding points, let''s look at an example using the `distutils`
    option:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了说明前面的要点，让我们通过使用`distutils`选项来查看一个示例：
- en: '[PRE9]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That's it! The preceding code that is to be exported should be inside the `.pyx`
    file. The `setup.py` file will normally be the same. It will call the `setup`
    function with different variations of the parameters. Finally, it will call the
    `test.py` file, which imports our compiled library and makes use of it.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就这样！要导出的前面代码应该放在`.pyx`文件中。`setup.py`文件通常也是相同的。它将使用不同参数变体调用`setup`函数。最后，它将调用`test.py`文件，该文件导入我们的编译库并使用它。
- en: 'To effectively compile the code, you can use the following command:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了有效地编译代码，你可以使用以下命令：
- en: '[PRE10]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following screenshot shows the output from the preceding command. You can
    see how it doesn''t just translate (cythonize) the code, but also compiles the
    library using the C compiler installed:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了前面命令的输出。你可以看到它不仅翻译（cythonize）了代码，而且还使用了安装的C编译器来编译库：
- en: '![Building a Cython module](img/B02088_06_01.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![构建Cython模块](img/B02088_06_01.jpg)'
- en: 'The preceding example shows a very simple module. However, normally, for more
    complex cases, a Cython module is comprised of two types of files:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例显示了一个非常简单的模块。然而，通常，对于更复杂的情况，Cython模块由两种类型的文件组成：
- en: '**Definition files**: These have a `.pxd` extension and contain C declarations
    of names that need to be available to other Cython modules.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定义文件**：这些文件具有`.pxd`扩展名，包含需要供其他Cython模块使用的名称的C声明。'
- en: '**Implementation files**: These have a `.pyx` extension and contain the actual
    implementation of the functions declared on the `.pxd` files.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现文件**：这些文件具有`.pyx`扩展名，包含在`.pxd`文件中声明的函数的实际实现。'
- en: Definition files normally contain C type declarations, external C functions
    or variable declarations, and declarations of C functions defined in the module.
    They cannot contain the implementation of any C or Python function, nor can they
    contain the definition of any `Python` class or any executable lines.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 定义文件通常包含C类型声明、外部C函数或变量声明，以及模块中定义的C函数的声明。它们不能包含任何C或Python函数的实现，也不能包含任何`Python`类的定义或任何可执行行。
- en: On the other hand, an implementation file can have almost any kind of Cython
    statement.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，实现文件可以包含几乎任何类型的Cython语句。
- en: 'Here is a typical two-file module example taken from Cython''s official documentation
    ([http://docs.cython.org/src/userguide/sharing_declarations.html](http://docs.cython.org/src/userguide/sharing_declarations.html));
    it shows how to import `.pxd` files:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个典型的两文件模块示例，摘自 Cython 的官方文档（[http://docs.cython.org/src/userguide/sharing_declarations.html](http://docs.cython.org/src/userguide/sharing_declarations.html)）；它展示了如何导入
    `.pxd` 文件：
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: By default, when `cimport` is executed, it will look for a file called `modulename.pxd`
    in the search path. Whenever the definition file changes, each file importing
    it will need to be recompiled. Luckily, for us, the `Cythin.Build.cythonize` utility
    will take care of that.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当执行 `cimport` 时，它将在搜索路径中查找名为 `modulename.pxd` 的文件。每当定义文件更改时，导入它的每个文件都需要重新编译。幸运的是，对于我们来说，`Cythin.Build.cythonize`
    工具将负责这一点。
- en: Calling C functions
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用 C 函数
- en: 'Just like regular Python, Cython allows the developer to directly interface
    with C by calling functions compiled in external libraries. To import these libraries,
    the procedure is similar to the standard Python procedure:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 就像常规的 Python 一样，Cython 允许开发者通过调用外部库编译的函数来直接与 C 进行接口交互。为了导入这些库，其过程与标准的 Python
    过程类似：
- en: '[PRE12]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `cimport` statement is used in implementation or definition files in order
    to gain access to names declared in other files. Its syntax is exactly the same
    as standard Python's `import` statement.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`cimport` 语句用于实现或定义文件，以便访问在其他文件中声明的名称。其语法与标准 Python 的 `import` 语句完全相同。'
- en: 'If you also need to access the definition of some types defined in a library,
    you would need the header file (`.h` file). For these cases, with Cython it is
    not as simple as referencing the file. You''ll also need to redeclare the types
    and structures you will use:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还需要访问在库中定义的一些类型的定义，你需要头文件（`.h` 文件）。在这些情况下，使用 Cython 并不像引用文件那样简单。你还需要重新声明你将使用的类型和结构：
- en: '[PRE13]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding example performs the following actions for Cython:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例对 Cython 执行以下操作：
- en: It lets Cython know how to place a `#include` statement in the generated C code,
    referencing the library we're including
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它让 Cython 知道如何在生成的 C 代码中放置 `#include` 语句，引用我们包含的库
- en: It prevents Cython from generating any C code for the declarations inside the
    block
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它阻止 Cython 为该块内的声明生成任何 C 代码
- en: It treats all declarations inside the block as if they were made with `cdef
    extern`, which, in turn, means those declarations are defined elsewhere
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将块内的所有声明视为使用 `cdef extern` 创建的，这反过来意味着这些声明是在其他地方定义的
- en: Note that this syntax is required because Cython does not, at any moment, read
    the content of the header file. So, you still need to redeclare the content for
    it. As a caveat, you technically only need to redeclare the part that you'll use,
    leaving out anything that's not directly needed by your code. For instance, if
    you had a big structure declared in your header file with a lot of members, you
    could redeclare it with only the members you'd need. This would work since during
    compiling time, the C compiler would use the original code with the full version
    of the structure.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个语法是必需的，因为 Cython 在任何时候都不会读取头文件的内容。因此，你仍然需要重新声明其内容。作为一个警告，你实际上只需要重新声明你将使用的部分，省略掉任何你的代码不需要直接使用的部分。例如，如果你在你的头文件中声明了一个具有许多成员的大结构，你可以只重新声明你需要的成员。这会起作用，因为在编译时，C
    编译器会使用具有完整版本的结构的原代码。
- en: Solving naming conflicts
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决命名冲突
- en: An interesting problem arises when names from the imported functions are the
    same as the ones from your functions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当导入的函数的名称与你的函数的名称相同时，会出现一个有趣的问题。
- en: Say, you have your `myHeader.h` file that defines the `print_with_colors` function,
    and you need to wrap it in some Python function that you also want to call `print_with_colors`;
    Cython provides a way for you to work around this and keep the names as you want
    them.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个 `myHeader.h` 文件，它定义了 `print_with_colors` 函数，你需要将其包装在一个你也要调用 `print_with_colors`
    的 Python 函数中；Cython 提供了一种方法让你绕过这个问题，并保持你想要的名称。
- en: 'You can add `extern` C function declarations into a Cython declaration file
    (`.pxd` file) and then `cimport` it into your Cython code file as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `extern` C 函数声明添加到 Cython 声明文件（`.pxd` 文件）中，然后按照以下方式将其导入到你的 Cython 代码文件中：
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can also avoid renaming the function and use the name of the declaration
    file as a prefix:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以避免重命名函数，并使用声明文件的名称作为前缀：
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Both alternatives are valid, and the decision of using one over the other is
    completely up to the developer. For more information on this subject, head to:
    [http://docs.cython.org/src/userguide/external_C_code.html](http://docs.cython.org/src/userguide/external_C_code.html).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种选择都是有效的，使用哪种完全取决于开发者。有关此主题的更多信息，请参阅：[http://docs.cython.org/src/userguide/external_C_code.html](http://docs.cython.org/src/userguide/external_C_code.html)。
- en: Defining types
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义类型
- en: As mentioned earlier, Cython allows the developer to define the type of a variable
    or the return type of a function. In both cases, the keyword used for this is
    `cdef`. Typing is actually optional, since Cython will try to optimize the Python
    code by turning it into C. That being said, defining the static types where they're
    needed will certainly help.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Cython 允许开发者定义变量的类型或函数的返回类型。在这两种情况下，用于此的关键字是 `cdef`。实际上，类型声明是可选的，因为 Cython
    会尝试通过将其转换为 C 来优化 Python 代码。但话虽如此，在需要的地方定义静态类型肯定会很有帮助。
- en: 'Let''s now look at a very basic example of a piece of code in Python and how
    the same code executes in its three versions: pure Python, compiled by Cython
    without typing, and finally, compiled and using typing.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个 Python 代码片段的非常基础的例子，以及相同的代码在其三个版本中的执行情况：纯 Python、Cython 编译无类型和最后，编译并使用类型。
- en: 'The code is as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '| Python | Cython |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| Python | Cython |'
- en: '| --- | --- |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE16]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE17]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Thanks to the fact that we're declaring the `for` loop variable as a C integer.
    Cython will turn this loop into an optimized C `for` loop, which will be one of
    the major improvements to this code.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将 `for` 循环变量声明为 C 整数，Cython 会将这个循环转换为一个优化的 C `for` 循环，这将是对这段代码的主要改进之一。
- en: 'Now, we will set up a main file that will import that function:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将设置一个主文件，该文件将导入该函数：
- en: '[PRE18]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we will execute our script like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将像这样执行我们的脚本：
- en: '[PRE19]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We will get the following interesting results:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下有趣的结果：
- en: '| Pure Python version | Compiled without typing | Compiled with typing |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 纯 Python 版本 | 编译后无类型 | 编译后带类型 |'
- en: '| --- | --- | --- |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0.792 seconds | 0.694 seconds | 0.043 seconds |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 0.792 秒 | 0.694 秒 | 0.043 秒 |'
- en: Even though the non-optimized version of the code is faster than the pure Python
    one, we only see the real power of Cython when we start declaring the types.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管代码的非优化版本比纯 Python 版本更快，但我们只有在开始声明类型时才能看到 Cython 的真正威力。
- en: Defining types during function definitions
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在函数定义期间定义类型
- en: 'There are two different types of functions that can be defined in Cython:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cython 中可以定义两种不同类型的函数：
- en: '**Standard Python functions**: These are normal functions that are exactly
    like the ones declared in pure Python code. To do this, you need the standard
    `cdef` keyword, and these functions will receive Python objects as parameters
    and also return Python objects.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准 Python 函数**：这些是正常的函数，与纯 Python 代码中声明的函数完全相同。为此，你需要使用标准的 `cdef` 关键字，这些函数将接收
    Python 对象作为参数，并返回 Python 对象。'
- en: '**C functions**: These are the optimized versions of the standard functions.
    They take either Python objects or C values as parameters and can also return
    both. To define these, you need the special `cdef` keyword.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C 函数**：这些是标准函数的优化版本。它们可以接受 Python 对象或 C 值作为参数，也可以返回这两种类型。要定义这些函数，你需要使用特殊的
    `cdef` 关键字。'
- en: Either type of function can be called from within a Cython module. However (and
    this is a very important difference), if you want to call your functions from
    within your Python code, you either need to make sure the function is declared
    as standard or you need to use the special `cpdef` keyword. This keyword will
    create a wrapper object for the function. So, when the function is called from
    within Cython, it'll use the C function, and when called from within Python code,
    it'll use the Python version.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 任何类型的函数都可以在 Cython 模块内部调用。然而（这是一个非常重要的区别），如果你想在 Python 代码内部调用你的函数，你需要确保该函数被声明为标准类型，或者你需要使用特殊的
    `cpdef` 关键字。这个关键字将为函数创建一个包装对象。因此，当函数在 Cython 内部调用时，它将使用 C 函数，而当在 Python 代码内部调用时，它将使用
    Python 版本。
- en: When dealing with C types for the parameters of the function, an automatic conversion
    will be done (if possible) from the Python object to the C value. This is only
    currently possible for numeric types, `strings`, and `struct` types. If you attempt
    to use any other type, it will result in a compile-time error.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理函数的参数为 C 类型时，将自动进行（如果可能）从 Python 对象到 C 值的转换。目前这仅适用于数值类型、`字符串` 和 `struct`
    类型。如果你尝试使用任何其他类型，将导致编译时错误。
- en: 'The following simple example illustrates the difference between both modes:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下简单的例子说明了两种模式之间的区别：
- en: '[PRE20]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the return type or the type of parameter is left undefined, then it will
    be assumed to be a Python object.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果返回类型或参数类型未定义，则假定它是一个Python对象。
- en: Finally, C functions that don't return a Python object have no way to report
    Python exceptions to its caller. So, when an error occurs, a warning message is
    printed and the exception is ignored. This is, of course, far from ideal. Luckily,
    for us, there is a way around this.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，不返回Python对象的C函数没有向其调用者报告Python异常的方法。因此，当发生错误时，会打印一条警告消息，并忽略异常。当然，这远远不是理想的。幸运的是，我们有一个解决办法。
- en: 'We can use the `except` keyword during function definition. This keyword specifies
    that whenever an exception occurs inside the function, a specific value will be
    returned. Here is an example:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在函数定义中使用`except`关键字。这个关键字指定了当函数内部发生异常时，将返回一个特定的值。以下是一个例子：
- en: '[PRE21]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With the preceding code, whenever an exception occurs, `-1` will be returned.
    It is important that you don't manually return the exception value from your function.
    This is especially relevant if you define `False` to be your exception value because
    any `False` value will do here.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，每当发生异常时，将返回`-1`。重要的是你不需要从你的函数中手动返回异常值。这尤其相关，如果你将`False`定义为你的异常值，因为这里的任何`False`值都适用。
- en: 'For cases where any possible return value is a valid return value, then there
    is an alternate notation that you can use:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何可能的返回值都是有效返回值的情况，你可以使用另一种表示法：
- en: '[PRE22]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `?` sign sets `-1` as a possible exception value. When returned, Cython
    will call `PyErr_Occurred()` to make sure that it is really an error and not just
    a normal return action.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`?`符号将`-1`设置为可能的异常值。当返回时，Cython将调用`PyErr_Occurred()`以确保它确实是一个错误，而不是一个正常的返回操作。'
- en: 'There is one more variation of the `except` keyword, which makes sure to call
    `PyErr_Occurred()` after every return:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`except`关键字还有一个变体，确保在每次返回后调用`PyErr_Occurred()`：'
- en: '[PRE23]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The only real use of the preceding notation is for functions returning `void`
    that need to propagate errors. This is because in these special cases, there is
    no value to check; otherwise, there is no real use case for it.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表示法的唯一实际用途是对于返回`void`且需要传播错误的函数。这是因为在这些特殊情况下，没有值可以检查；否则，它没有真正的用例。
- en: A Cython example
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cython示例
- en: 'Let''s take a quick look at the same example we used for PyPy. It shows us
    how to improve the performance of a script. The code will again do the same calculation
    5 million times: from math, import `PI`, `acos`, `cos`, and `sin`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下我们之前为PyPy使用的相同例子。它展示了如何提高脚本的性能。代码将再次进行5000万次的相同计算：从`math`导入`PI`、`acos`、`cos`和`sin`：
- en: '[PRE24]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we will test it by running the function 5,000,000 times with the following
    script:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将通过以下脚本运行函数5000,000次来测试它：
- en: '[PRE25]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Again, as I've already mentioned earlier, if we run this script using the time
    command-line utility from Linux with the CPython interpreter, we will see that
    the resulting execution takes around 4.5 seconds to run (in my current system).
    Your numbers will most likely be different.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，正如我之前提到的，如果我们使用Linux中的time命令行工具和CPython解释器运行这个脚本，我们会看到执行结果大约需要4.5秒（在我的当前系统中）。你的数字可能有所不同。
- en: Instead of going to the profiler, like we did in earlier chapters, we'll go
    directly to Cython now. We'll implement some of the improvements we've been discussing
    into a Cython module that we can import from our test script.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在前面的章节中一样，我们将直接跳转到Cython。我们将把之前讨论的一些改进实现到一个Cython模块中，我们可以从我们的测试脚本中导入它。
- en: 'Here''s our first try at it:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的第一次尝试：
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see in the preceding code, all we did was give a C type to all the
    variables and parameters we're using in our code. This alone took the execution
    time from 4.5 seconds down to 3\. We shaved off 1.5 seconds, but we can probably
    do better.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的代码所示，我们只是给代码中使用的所有变量和参数赋予了一个C类型。仅此一项就将执行时间从4.5秒降低到3秒。我们节省了1.5秒，但我们可能做得更好。
- en: 'Our code is still using a Python library `math.` Since Cython allows us to
    mix Python and C libraries, it comes in handy when we''re in a hurry. It takes
    care of the conversions for us, but as we can see here, not without a cost. Let''s
    now try to remove the dependency of that Python library and call upon C''s `math.h`
    file:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码仍然使用Python库`math.`。由于Cython允许我们混合Python和C库，当我们匆忙时它非常有用。它为我们处理转换，但正如我们所看到的，这并非没有代价。现在让我们尝试移除对该Python库的依赖，并调用C的`math.h`文件：
- en: '[PRE27]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: After removing all references to the math Python library and working directly
    with C's `math.h` file, we went from the 3.5 seconds in our previously optimized
    code to an amazing 0.95 seconds.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在移除了对Python数学库的所有引用并直接使用C的`math.h`文件后，我们的代码从之前优化的3.5秒提升到了惊人的0.95秒。
- en: When to define a type
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时定义类型
- en: The previous example might seem obvious and simple to optimize. However, for
    bigger scripts, redeclaring every variable as a C variable and importing all C
    libraries instead of Python ones (whenever possible) is not always the best way
    to go.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子可能看起来很明显且易于优化。然而，对于更大的脚本，重新声明每个变量为C变量，并在可能的情况下导入所有C库而不是Python库（ whenever
    possible），并不总是最佳选择。
- en: Going about it this way will lead to readability and maintainability issues.
    It will also hurt the inherent flexibility of Python code. It could, in fact,
    even end up hurting the performance by adding unnecessary type checks and conversions.
    So, there must be a way to determine the best places to add types and switch libraries.
    This way is using Cython. Cython comes with the ability to annotate your source
    code and show you, very graphically, how each line of code can be translated into
    C code.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式进行操作将导致可读性和可维护性问题。它还会损害Python代码的固有灵活性。实际上，它甚至可能通过添加不必要的类型检查和转换来损害性能。因此，必须有一种方法来确定添加类型和切换库的最佳位置。这种方法是使用Cython。Cython具有注释源代码的能力，并以非常直观的方式显示每一行代码如何被翻译成C代码。
- en: 'Using the `-a` attribute in Cython, you can generate an HTML file that will
    highlight your code with yellow. The more yellow a line is, the more C-API interactions
    are required to translate that piece of code into C. White lines (lines without
    any color) are directly translated into C. Let''s look at how our original code
    is rendered under this new tool:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Cython的`-a`属性，你可以生成一个HTML文件，该文件将以黄色突出显示你的代码。线条越黄，将该代码片段翻译成C所需的C-API交互就越多。白色线条（没有任何颜色的线条）将直接翻译成C。让我们看看我们的原始代码在这个新工具下的渲染效果：
- en: '[PRE28]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following screenshot shows the HTML file generated from the preceding command:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 下一张截图显示了上一条命令生成的HTML文件：
- en: '![When to define a type](img/B02088_06_02.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![何时定义类型](img/B02088_06_02.jpg)'
- en: 'We can clearly see that most of our code needs at least a few interactions
    with the C-API in order to be translated into C (only line 4 is completely white).
    It is important to understand that our aim should be to get as many lines to white
    as possible. The lines with a **+** sign indicate that they can be clicked, and
    the C code generated will be displayed, as shown here:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以清楚地看到，我们的大部分代码至少需要与C-API进行几次交互才能被翻译成C（只有第4行是完全白色的）。重要的是要理解，我们的目标应该是尽可能多地使行变为白色。带有**+**符号的行表示可以点击，生成的C代码将显示如下：
- en: '![When to define a type](img/B02088_06_03.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![何时定义类型](img/B02088_06_03.jpg)'
- en: 'Now, by looking at our results, we can see that the lighter yellow lines are
    the simple assignments (lines 5, 7, 8, and 9). They can be easily fixed by doing
    what we initially did: declare those variables as C variables instead of letting
    them be Python objects, which would require us to convert code.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过查看我们的结果，我们可以看到浅黄色线条是简单的赋值（第5、7、8和9行）。它们可以通过我们最初的做法轻松修复：将这些变量声明为C变量，而不是让它们成为Python对象，这将需要我们转换代码。
- en: 'By doing the conversion, we will get something like the next screenshot. This
    screenshot shows the resulting report from analyzing the `great_circle_cy_v1.pyx`
    file:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 通过进行转换，我们将得到类似下一张截图的内容。这张截图显示了分析`great_circle_cy_v1.pyx`文件的结果报告：
- en: '![When to define a type](img/B02088_06_04.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![何时定义类型](img/B02088_06_04.jpg)'
- en: 'Much better! Now, those lines are fully white, except line 7, which is still
    light yellow. This is, of course, because that line is actually referencing the
    `math.pi` object. We could fix it simply by initializing the `pi` variable with
    a fixed value of `PI`. However, we still have the big yellow block, that is, lines
    12 and 13\. This is also due to our usage of the `math` library. So, after we
    get rid of it, we will get the following file:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在好多了！现在，这些行都是完全白色的，除了第 7 行，它仍然是浅黄色。这当然是因为这一行实际上引用了 `math.pi` 对象。我们可以简单地通过用固定的值
    `PI` 初始化 `pi` 变量来修复它。然而，我们仍然有一个大块的黄色，即第 12 和 13 行。这也是由于我们使用了 `math` 库。因此，在我们摆脱它之后，我们将得到以下文件：
- en: '![When to define a type](img/B02088_06_05.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![何时定义类型](img/B02088_06_05.jpg)'
- en: 'The preceding screenshot shows the final code we presented earlier. Almost
    all of our code is directly translatable to C, and we got a good performance out
    of it. Now, we still have two yellow lines: 6 and 18.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了之前我们展示的最终代码。我们的大部分代码可以直接翻译为 C，并且从中获得了良好的性能。现在，我们仍然有两个黄色的行：6 和 18。
- en: 'We can''t do much about line 6 because that function is the Python function
    we need to execute. If we were to declare it with `cdef`, we would not have access
    to it. However, again, line 18 is not completely white. This is because `great_circle`
    is a Python function and the returned value is a Python object, which needs to
    be wrapped and translated into a C value. If we click on it, we can see the generated
    code:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对第 6 行无能为力，因为那个函数是我们需要执行的 Python 函数。如果我们用 `cdef` 声明它，我们就无法访问它。然而，第 18 行并不完全是白色的。这是因为
    `great_circle` 是一个 Python 函数，返回值是一个 Python 对象，需要被包装并转换为 C 值。如果我们点击它，我们可以看到生成的代码：
- en: '![When to define a type](img/B02088_06_06.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![何时定义类型](img/B02088_06_06.jpg)'
- en: 'The only way we can fix this is by declaring our function with `cpdef`, which
    will create a wrapper for it. However, it will also let us declare the return
    type. So, we''re no longer returning a Python object. Instead, we''re returning
    a `double` value, and the resulting code and annotated screenshot is as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一能够修复这个问题的方法是通过使用 `cpdef` 声明我们的函数，这将为其创建一个包装器。然而，它也将允许我们声明返回类型。因此，我们不再返回一个
    Python 对象。相反，我们返回一个 `double` 值，结果代码和注释截图如下：
- en: '![When to define a type](img/B02088_06_07.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![何时定义类型](img/B02088_06_07.jpg)'
- en: We can see how the C code generated for the returned statement got simplified
    with this latest change. The performance got a small boost as well, since we went
    from 0.95 seconds down to 0.8 seconds.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，由于最新的更改，为返回语句生成的 C 代码得到了简化。性能也得到了小幅提升，因为我们从 0.95 秒降低到了 0.8 秒。
- en: Thanks to our analysis of the code, we were able to go one step further and
    optimize it a bit more. This technique is a good way to check your progress when
    optimizing code for Cython. This technique provides a visual and simple indicator
    of the complexity of the optimized code.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢我们对代码的分析，我们能够更进一步并对其进行一些优化。这种技术是检查为 Cython 优化代码进度的一个好方法。这种技术提供了一个直观且简单的指标，用于显示优化代码的复杂性。
- en: Note
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that in this particular case, the results obtained from going the Cython
    route for this optimization are not as good as the ones obtained using PyPy earlier
    in this chapter (0.8 seconds with Cython versus 0.5 seconds with PyPy).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个特定的情况下，通过 Cython 路线进行此优化获得的结果并不如本章前面使用 PyPy 获得的结果好（Cython 需要 0.8 秒，而 PyPy
    需要 0.5 秒）。
- en: Limitations
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 局限性
- en: Everything we've seen so far seems to indicate that Cython is a perfectly viable
    option to our performance needs. However, the truth is that Cython is not yet
    100 percent compatible with the Python syntax. Sadly, there are some limitations
    that we need to take into consideration before deciding to use this tool for our
    performance enhancement needs. From the current list of public bugs on the project,
    we can gather the list of current limitations.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所看到的一切似乎都表明 Cython 是满足我们性能需求的一个完美的选择。然而，事实是 Cython 还没有达到 100% 与 Python
    语法兼容。遗憾的是，在使用这个工具来满足我们的性能增强需求之前，我们需要考虑一些限制。从项目当前公开的 bug 列表中，我们可以收集到当前的限制列表。
- en: Generator expressions
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成器表达式
- en: 'These expressions are currently the ones that suffer the most, since they have
    several issues in the current version of Cython. These issues are as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这些表达式目前遭受的影响最大，因为它们在 Cython 当前版本中存在几个问题。这些问题如下：
- en: Using iterables inside the generator expression causes a problem since there
    are issues with the evaluation scope.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在生成器表达式中使用迭代器会导致问题，因为存在评估范围的问题。
- en: Also, related to iterables inside a generator, Cython appears to be evaluating
    them inside the generator's body. On the other hand, CPython does it outside,
    before creating the actual generator.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，与生成器内部的迭代器相关，Cython似乎是在生成器的主体内部评估它们的。另一方面，CPython则是在创建实际的生成器之前进行评估。
- en: Generators in Cpython have attributes that allow for introspection. Cython is
    still not fully up to date when it comes to supporting those attributes.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPython中的生成器具有允许进行内省的属性。Cython在支持这些属性方面仍然没有完全跟上。
- en: Comparison of char* literals
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串字面量的比较
- en: The current implementation of Cython performs comparsons of byte literals based
    on the pointers used, instead of the actual value of the string.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Cython当前的实现基于指针使用的字面量进行比较，而不是字符串的实际值。
- en: '[PRE29]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The preceding code will not always print `True`. It will depend on the pointer
    used to store the first string instead of depending on the actual string value.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码并不总是打印`True`。它将取决于存储第一个字符串的指针，而不是取决于实际的字符串值。
- en: Tuples as function arguments
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元组作为函数参数
- en: 'Although only a Python 2 feature, the language allows for the following syntax:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这只是Python 2的一个特性，但语言允许以下语法：
- en: '[PRE30]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: However, the preceding code is not even correctly parsed by Cython. This particular
    feature is flagged as probably "not fixable" in the future of Cython, since Python
    3.x has removed it as well.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，前面的代码甚至不能被Cython正确解析。这个特定的功能被标记为可能在Cython的未来版本中“无法修复”，因为Python 3.x也已经移除了它。
- en: Note
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the Cython team is expecting to fix most of the limitations mentioned
    earlier by the time they release version 1.0.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Cython团队预计在发布1.0版本之前修复大多数之前提到的限制。
- en: Stack frames
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 堆栈帧
- en: Currently, Cython is generating fake tracebacks as part of its exception propagation
    mechanics. They're not filling in `locals` and `co_code` values. In order to do
    this properly, they would have to generate the stack frames on function call time,
    incurring in a potential performance penalty. So, it is unclear whether they will
    fix this in the future or not.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Cython正在生成假的回溯作为其异常传播机制的一部分。它们没有填写`locals`和`co_code`值。为了正确地做到这一点，它们必须在函数调用时生成堆栈帧，这可能会带来潜在的性能惩罚。因此，不清楚它们是否会在未来修复这个问题。
- en: How to choose the right option
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何选择正确的选项
- en: Up to this point, we've gone over two different alternatives to radically optimize
    our code. However, how do we know which one is the right one? Or even better,
    which one is the best one?
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了两种不同的方法来彻底优化我们的代码。然而，我们如何知道哪一个是正确的？或者更好的是，哪一个才是最好的？
- en: 'The answer to both those questions is the same: *there is no single best or
    right one*. Whether one of the options is better or worse depends entirely on
    one or more of these aspects:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 对这两个问题的回答是相同的：*没有单一的最佳或正确选项*。哪一个选项更好或更差完全取决于一个或多个这些方面：
- en: The actual use case you're trying to optimize
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你试图优化的实际用例
- en: The familiarity of the developer with either Python or C
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者对Python或C的熟悉程度
- en: The importance of readability of your optimized code
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化代码的可读性很重要
- en: The amount of time at hand to perform the optimization
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用于执行优化的时间量
- en: When to go with Cython
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时选择Cython
- en: 'Here are the situations when you should go with Cython:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是当你应该选择Cython的情况：
- en: '**You''re familiar with C code**: It''s not like you''ll be coding in C, but
    you will be using principles that are common to C, such as static types, and C
    libraries, such as `math.h`. So, being familiar with the language and its internals
    will definitely be helpful.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你熟悉C代码**：你不会用C来编码，但你将使用与C共有的原则，例如静态类型，以及C库，如`math.h`。因此，熟悉该语言及其内部结构肯定会有所帮助。'
- en: '**Losing Python''s readability is not a problem**: The code you''ll write for
    Cython is not fully Python, so part of its readability will be lost.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**失去Python的可读性不是问题**：你为Cython编写的代码不是完全的Python代码，因此其可读性的一部分将会丢失。'
- en: '**Full support of the Python language is needed**: Even though Cython is not
    Python, it is more an extension than a subset of the language. So, if you need
    full compatibility with the language, Cython might be the right choice.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**需要完全支持Python语言**：尽管Cython不是Python，但它更像是语言的扩展而不是子集。因此，如果你需要与语言完全兼容，Cython可能是一个正确的选择。'
- en: When to go with PyPy
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时选择PyPy
- en: 'Here are the situations when you should go with PyPy:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你应该选择PyPy的情况：
- en: '**You''re not dealing with an execute once script**: PyPy''s JIT optimization
    is great if your script is a long running program, with loops that can be optimized,
    but if instead, the script you''re trying to improve will run once and be done,
    then PyPy is actually slower than the original CPython.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你不是在处理一次性执行的脚本**：如果你的脚本是一个长时间运行的程序，有可以优化的循环，那么PyPy的JIT优化非常出色，但如果你的脚本是一次性运行并完成的，那么实际上PyPy比原始CPython要慢。'
- en: '**Full support of third-party libraries is not required**: Even though PyPy
    is compatible with Python 2.7.x, it is not fully compatible with its external
    libraries, especially if they''re C libraries. So, depending on your code, PyPy
    might not really be an option.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不需要完全支持第三方库**：尽管PyPy与Python 2.7.x兼容，但它与其外部库（尤其是C库）并不完全兼容。因此，根据你的代码，PyPy可能并不是一个真正的选择。'
- en: '**You need your code to be compatible with CPython**: If you need your code
    to run for both implementations (PyPy and CPython), then the Cython alternative
    is completely out of the question. PyPy becomes the only option.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你需要你的代码与CPython兼容**：如果你需要你的代码在两种实现（PyPy和CPython）上都能运行，那么Cython方案就完全不可行。PyPy成为唯一的选择。'
- en: Summary
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we have covered two alternatives to the standard Python implementation.
    One is PyPy, which consists of a version of Python and is implemented in RPython.
    It has a JIT compiler in charge of optimizing the code during execution time.
    The other one is Cython, which is basically a transpiler of Python code into C
    code. We saw how each of them worked, how to install them, and how our code needed
    to be changed in order to gain benefits from using them.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了两种替代标准Python实现的方案。一个是PyPy，它包含一个Python版本，并使用RPython实现。它有一个负责在执行时优化代码的即时编译器。另一个是Cython，它基本上是将Python代码转换为C代码的编译器。我们看到了它们各自的工作原理、如何安装它们，以及我们的代码需要如何修改才能从中获益。
- en: Finally, we went over a few points on how and when to choose one over the other.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了如何以及何时选择其中一个而不是另一个的几个要点。
- en: 'In the next chapter, we''ll focus on a very specific use case for Python: number
    crunching. The topic is very common in the Python community, since the language
    is very often used for scientific purposes. We''ll cover three options that will
    help us write code faster: Numba, Parakeet, and pandas.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将专注于Python的一个非常具体的用例：数值计算。这个主题在Python社区中非常常见，因为这种语言经常用于科学目的。我们将介绍三个可以帮助我们更快编写代码的选项：Numba、Parakeet和pandas。
