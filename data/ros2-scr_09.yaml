- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Actions – When Services Are Not Enough
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作 – 当服务不足时
- en: 'In this chapter, we will explore the third communication type in ROS 2: actions.
    To understand actions, you need to have read the previous chapters on nodes, topics,
    and services.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 ROS 2 的第三种通信类型：动作。为了理解动作，你需要阅读关于节点、主题和服务的先前章节。
- en: Before we begin, I want to alert you that this chapter covers more advanced
    material compared to what we encountered previously and what’s to come.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我想提醒你，本章涵盖的内容比我们之前遇到的以及将要遇到的内容更为高级。
- en: If you already have some level of expertise, this chapter will satisfy you as
    it will give you a full overview of all three ROS 2 communication types. However,
    if you’re just getting started with ROS with zero experience, it might be a bit
    too much for you right now. This is OK, and topics/services are more than enough
    to get started with ROS 2\. You can skip this chapter (which is independent of
    future chapters) for now and continue with parameters and launch files. It might
    be a good idea to come back to it at a later stage after you’ve built more confidence
    by working on ROS 2 projects.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经具备一定程度的经验，本章将满足你的需求，因为它将为你提供所有三种 ROS 2 通信类型的全面概述。然而，如果你是 ROS 的初学者，没有任何经验，现在可能有点过于复杂。这是可以的，主题和服务已经足够你开始使用
    ROS 2。你现在可以跳过这一章（它独立于未来的章节），继续学习参数和启动文件。在你通过在 ROS 2 项目中工作建立更多信心之后，回头再看它可能是个好主意。
- en: 'Throughout this chapter, you will understand why you need actions and how they
    work by going through an example that we will build step by step. Then, you will
    write the code to make two nodes communicate with each other. We will use the
    code in the **ch6** folder (in this book’s GitHub repository: [https://github.com/PacktPublishing/ROS-2-from-Scratch](https://github.com/PacktPublishing/ROS-2-from-Scratch))
    as a starting point. You can find the final code in the **ch7** folder.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将通过逐步构建的示例来了解为什么需要动作以及它们是如何工作的。然后，你将编写代码使两个节点相互通信。我们将使用**ch6**文件夹中的代码（在此书的
    GitHub 仓库：[https://github.com/PacktPublishing/ROS-2-from-Scratch](https://github.com/PacktPublishing/ROS-2-from-Scratch)）作为起点。你可以在**ch7**文件夹中找到最终代码。
- en: By the end of this chapter, you will be able to write an action server and client
    and take advantage of all action features, such as feedback and cancel mechanisms.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够编写动作服务器和客户端，并利用所有动作功能，如反馈和取消机制。
- en: Even though topics and services are more than enough to get started, ROS 2 actions
    are important as they help you take your code to the next level and implement
    more complex behaviors in your robotics applications.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管主题和服务已经足够开始，但 ROS 2 动作同样重要，因为它们帮助你将代码提升到下一个层次，并在你的机器人应用中实现更复杂的行为。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What is a ROS 2 action?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 ROS 2 动作？
- en: Creating a custom action interface
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义动作接口
- en: Writing an action server
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写动作服务器
- en: Writing an action client
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写动作客户端
- en: Taking advantage of all the action mechanisms
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 充分利用所有动作机制
- en: Additional tools to handle actions
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理动作的附加工具
- en: What is a ROS 2 action?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 ROS 2 动作？
- en: To understand ROS 2 actions, we need to understand why we need them. That’s
    what we will focus on first. After that, I will explain how actions work through
    a real-life example.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解 ROS 2 动作，我们需要了解为什么需要它们。这是我们首先关注的内容。之后，我将通过一个真实生活中的例子解释动作是如何工作的。
- en: You quickly discovered actions in [*Chapter 3*](B22403_03.xhtml#_idTextAnchor092)
    by running some existing nodes and command-line tools. The intuition you built
    there will help you better understand the concepts in this chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过运行一些现有的节点和命令行工具，很快就在[*第 3 章*](B22403_03.xhtml#_idTextAnchor092)中发现了动作。在那里建立的感觉将帮助你更好地理解本章的概念。
- en: Let’s dive in and see why and when actions could be needed in a ROS 2 application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨，看看为什么以及何时在 ROS 2 应用中需要动作。
- en: Why actions?
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么需要动作？
- en: 'So far, we’ve looked at two forms of communication in ROS 2: topics and services.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了 ROS 2 的两种通信形式：主题和服务。
- en: '*Topics* are used by nodes to send and receive messages. Publishers will publish
    data on a topic, and subscribers will subscribe to the topic to receive the data.
    Thus, topics are perfect for sending data streams in your application.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*主题*被节点用来发送和接收消息。发布者将在主题上发布数据，而订阅者将订阅主题以接收数据。因此，主题非常适合在应用中发送数据流。'
- en: '*Services* are used for client/server interactions between nodes. The client
    sends a request to the server, after which the server executes or computes something
    and returns a response to the client.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*服务*用于节点之间的客户端/服务器交互。客户端向服务器发送请求，然后服务器执行或计算某些内容，并将响应返回给客户端。'
- en: So, that should be all, right? What else could we need?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这就应该是全部了，对吧？我们还需要什么？
- en: In its early days, ROS started with only topics and services. However, ROS developers
    quickly realized that something was missing for some robotics applications. Let’s
    see that with an example.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在其早期阶段，ROS只从主题和服务开始。然而，ROS开发者很快意识到，对于某些机器人应用来说，某些东西是缺失的。让我们用一个例子来看看。
- en: Imagine that you have a mobile robot with two wheels. First, you would create
    a node that’s responsible for controlling the wheels. This node would also be
    able to receive commands, such as **Move to (x, y) coordinates**. Those commands
    would be transformed into a velocity to apply to the wheels. However, you would
    also like to be able to get notified when the robot has finished moving.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个有两个轮子的移动机器人。首先，你会创建一个负责控制轮子的节点。这个节点还能够接收命令，例如**移动到(x, y)坐标**。这些命令将被转换成应用于轮子的速度。然而，你也会希望能够在机器人完成移动时得到通知。
- en: With what we know so far, ROS 2 services seem to be a good option. In this server
    node, you could implement a **/move_robot** service that will receive coordinates
    from a client. Once the command is received, the controller starts to move the
    wheels. Then, when the robot has reached its destination, the server returns a
    response to the client.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们目前所知，ROS 2服务似乎是一个不错的选择。在这个服务器节点中，你可以实现一个**/move_robot**服务，该服务将接收来自客户端的坐标。一旦收到命令，控制器开始移动轮子。然后，当机器人到达目的地时，服务器向客户端返回一个响应。
- en: 'To complete the communication, we must add a service client to another node.
    The client will send a request to the server with the (x,y) coordinates to reach.
    When the server returns the response, we know that the robot has finished moving—either
    successfully by reaching the destination or something prevented it and we get
    an error:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成通信，我们必须在另一个节点上添加一个服务客户端。客户端将发送一个包含要到达的(x,y)坐标的请求到服务器。当服务器返回响应时，我们知道机器人已经完成移动——要么成功到达目的地，要么被某些因素阻止，我们得到一个错误：
- en: '![Figure 7.1 – Using a service to control a two-wheeled robot](img/B22403_07_1.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 使用服务控制两轮机器人](img/B22403_07_1.jpg)'
- en: Figure 7.1 – Using a service to control a two-wheeled robot
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 使用服务控制两轮机器人
- en: What’s wrong with that?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这有什么问题吗？
- en: Well, moving a physical part of a robot in space can take some time. It could
    be a fraction of a second in some cases, but also maybe a few seconds, or even
    a few minutes. The point is that the service execution could take a significant
    amount of time.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，移动机器人空间中的物理部分可能需要一些时间。在某些情况下，这可能只是几秒钟，也可能是几秒钟，甚至几分钟。关键是服务执行可能需要相当长的时间。
- en: 'With that said, while the robot is moving, there are a few things you may want
    to do, and those things are missing when using services:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，当机器人移动时，你可能还想做几件事情，而这些事情在使用服务时是缺失的：
- en: Since the execution is taking some time, it would be nice to get some feedback
    from the server. With a service, the client has no idea of what’s happening on
    the server side. So, the client is completely blind and needs to wait for the
    response to get some information.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于执行需要一些时间，从服务器获取一些反馈将会很棒。使用服务时，客户端对服务器端发生的事情一无所知。因此，客户端完全处于盲状态，需要等待响应以获取一些信息。
- en: How can you cancel the current execution? That would seem a reasonable feature
    to have. After you start the execution on the server side, the client may want
    to cancel it. For example, let’s say the client node is also monitoring the environment
    with a camera. If an obstacle is detected, the client could ask the server to
    stop the execution. With what we have for now, the client can’t do anything but
    wait for the server to finish the execution.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何取消当前执行？这似乎是一个合理的功能。一旦你在服务器端开始执行，客户端可能想要取消它。例如，假设客户端节点还使用摄像头监控环境。如果检测到障碍物，客户端可以要求服务器停止执行。根据我们现在所拥有的，客户端除了等待服务器完成执行外，什么也不能做。
- en: 'Here’s the last point for now, although we could find more: how could the server
    correctly handle multiple requests? Let’s say you have two or more clients, each
    one sending a different request. How can you possibly choose between those requests
    on the server? How can the server refuse to execute a request, or choose to replace
    a request with a new one, without finishing the first request? Or, in another
    scenario, how can the server handle multiple requests at the same time? As an
    analogy, when you download files on your computer, the computer isn’t stuck with
    just one file. It can download multiple files at the same time. You can even decide
    to cancel one download while the others are still running.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在先说最后一个要点，尽管我们可以找到更多：服务器如何正确处理多个请求？假设你有两个或更多的客户端，每个客户端发送不同的请求。你如何在服务器上选择这些请求？服务器如何拒绝执行请求，或者选择用新的请求替换旧的请求，而不完成第一个请求？或者，在另一个场景中，服务器如何同时处理多个请求？作为一个类比，当你电脑上下载文件时，电脑不会只卡在一个文件上。它可以同时下载多个文件。你甚至可以在其他下载仍在运行时取消一个下载。
- en: Coming back to our example, you can see that a simple service is not enough.
    For this use case, we need more functionalities. What we could do is implement
    additional services, such as one to cancel a request. We could also add a new
    topic to publish some feedback about where the robot is during the execution.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的例子，你可以看到简单的服务是不够的。对于这个用例，我们需要更多的功能。我们可以做的是实现额外的服务，比如一个用于取消请求的服务。我们还可以添加一个新的主题来发布关于机器人在执行过程中的位置的一些反馈。
- en: There’s good news—you don’t have to do this. All these problems are solved by
    ROS 2 actions. The feedback mechanism, cancel mechanism, and other functionalities
    are also implemented directly in actions.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有好消息——你不必这样做。所有这些问题都是由 ROS 2 动作解决的。反馈机制、取消机制以及其他功能也在动作中直接实现。
- en: To conclude, services are perfect for client/server communication, but only
    if the action/computation is quick to execute. If the execution could take some
    time, and you want additional features such as feedback or cancellation, then
    actions are what you need.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，服务对于客户端/服务器通信来说非常完美，但只有当动作/计算快速执行时。如果执行可能需要一些时间，并且你想要额外的功能，如反馈或取消，那么动作就是你需要的。
- en: Now that you know why we need actions, it’s time to understand how they work.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了为什么我们需要动作，现在是时候了解它们是如何工作的了。
- en: How do actions work?
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动作是如何工作的？
- en: Let’s use the previous example, this time using a ROS 2 action instead of a
    service. I will show you how actions work at a high level, with the different
    interactions between the client and the server. Later in this chapter, we will
    dive into the code and see the implementation details.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用之前的例子，这次使用 ROS 2 动作而不是服务。我会向你展示动作在高级别是如何工作的，以及客户端和服务器之间的不同交互。在本章的后面部分，我们将深入代码，查看实现细节。
- en: 'We will use two nodes: one containing an **Action** **client**, and the other
    containing an **Action** **server** (this is the one responsible for controlling
    the wheels).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两个节点：一个包含**动作客户端**，另一个包含**动作服务器**（这是负责控制轮子的那个）。
- en: 'To understand how actions work, let’s follow the execution flow for one action:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解动作是如何工作的，让我们跟随一个动作的执行流程：
- en: '![Figure 7.2 – Execution flow for a ROS 2 action](img/B22403_07_2.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – ROS 2 动作的执行流程](img/B22403_07_2.jpg)'
- en: Figure 7.2 – Execution flow for a ROS 2 action
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – ROS 2 动作的执行流程
- en: 'Here are the steps for this flow:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个流程的步骤：
- en: The **Action client** will start the communication by sending a request to the
    **Action server**. For actions, the *request* is named *goal*. Hence, we won’t
    talk about requests here, but about **goals**. Here, the goal can be a (x, y)
    coordinate to reach.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**动作客户端**将通过向**动作服务器**发送请求来开始通信。对于动作，*请求*被命名为*目标*。因此，我们不会在这里讨论请求，而是关于**目标**。在这里，目标可以是到达的
    (x, y) 坐标。'
- en: The **Action server** receives the goal and decides to accept or reject it.
    The client immediately receives this response from the server. If the goal has
    been rejected, then the communication ends.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**动作服务器**接收目标并决定接受或拒绝它。客户端立即从服务器收到这个响应。如果目标被拒绝，那么通信结束。'
- en: If the goal is accepted, the server can start to process it and execute the
    corresponding action. With this example, the **Server node** will make the robot
    move.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果目标被接受，服务器就可以开始处理它并执行相应的动作。在这个例子中，**服务器节点**会让机器人移动。
- en: As soon as the client knows that the goal has been accepted, it will send a
    request to get the **Result** and wait for it (asynchronously, by registering
    a callback). For services, we talk about a *response*. For actions, this will
    be a *result*.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦客户端知道目标已被接受，它将发送一个请求以获取**结果**并等待它（通过注册回调异步地）。对于服务，我们谈论的是*响应*。对于动作，这将是一个*结果*。
- en: When the server is done executing the goal (either successfully or not), it
    will send the **Result** to the client. With this example, the result could be
    the final reached (x, y) coordinates.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当服务器完成目标的执行（无论是成功还是不成功）后，它将向客户端发送**结果**。以本例为例，结果可能是最终到达的（x，y）坐标。
- en: The client receives the **Result**, after which communication ends.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端在收到**结果**后，通信结束。
- en: This is how an action works, with a minimal set of functionalities. From the
    server side, a goal is received, accepted or rejected, then executed, and the
    result is returned. From the client side, a goal is sent, and if accepted, a request
    is sent and the result is received from the server.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是动作的工作方式，具有最小化的功能集。从服务器端来看，接收一个目标，接受或拒绝它，然后执行，并返回结果。从客户端来看，发送一个目标，如果被接受，则发送一个请求，并从服务器接收结果。
- en: 'On top of that, you can add extra functionalities, all of which are optional.
    Here are the additional mechanisms for actions:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以添加额外的功能，所有这些都是可选的。以下是动作的附加机制：
- en: '![Figure 7.3 – Action with all communication mechanisms](img/B22403_07_3.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 – 包含所有通信机制的动作](img/B22403_07_3.jpg)'
- en: Figure 7.3 – Action with all communication mechanisms
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 包含所有通信机制的动作
- en: 'Let’s take a closer look:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看：
- en: '**Feedback**: The server, while executing the goal, can send some feedback
    to the client. With this example, the feedback could be the current coordinates
    for the robot or even a completion rate. Thus, the client can know what’s happening
    during the goal’s execution.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反馈**：在执行目标的过程中，服务器可以向客户端发送一些反馈。以本例为例，反馈可以是机器人的当前坐标，甚至是完成率。因此，客户端可以了解目标执行过程中的情况。'
- en: '**Cancel**: After the goal has been accepted by the server and the goal is
    being executed on the server side, the client can decide to cancel that goal.
    To do so, it will send a cancel request that must be approved by the server. If
    the cancel request is accepted, then the server will try to finish the execution.
    So, in this example, it could make the robot stop. In the end, the server will
    still return a result to the client, whether the goal was successful, failed,
    or canceled.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**取消**：在服务器接受目标并正在服务器端执行目标之后，客户端可以决定取消该目标。为此，它将发送一个取消请求，该请求必须得到服务器的批准。如果取消请求被接受，那么服务器将尝试完成执行。因此，在本例中，它可以使机器人停止。最后，无论目标是否成功、失败或取消，服务器都将向客户端返回一个结果。'
- en: '**Goal status**: This is not so important for you as it’s an internal mechanism
    for actions that you will not use directly in your code (I just added it here
    for completeness). Each goal will get a state machine, with states such as *accepted*,
    *executing*, and others. With each change of state for a goal, the server will
    notify the client.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标状态**：这对您来说并不那么重要，因为它是动作的内部机制，您不会直接在代码中使用它（我只是为了完整性而添加了它）。每个目标都将获得一个状态机，具有如*接受*、*执行*等状态。对于每个目标状态的变化，服务器将通知客户端。'
- en: With this, you have seen all possible communication mechanisms that can be implemented
    within actions.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，你已经看到了可以在动作中实现的所有可能的通信机制。
- en: Note that in the preceding figure, some communications are represented with
    a red line, while others are presented with a green line. Behind the scenes, actions
    just use topics and services. Even if an action is a ROS 2 communication on its
    own, the underlying code is using the two other communication types. Here, red
    lines represent services, and green lines represent topics.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的图中，一些通信用红线表示，而其他通信用绿线表示。幕后，动作仅使用主题和服务。即使动作本身是ROS 2通信，底层的代码也在使用另外两种通信类型。在这里，红线代表服务，绿线代表主题。
- en: Thus, within an action, you have three services (send goal, cancel goal, and
    receive result) and two topics (feedback and goal status). The good news is that
    you don’t have to create those topics and services yourself—they are already implemented
    in the action mechanism. All you have to do is use the action client and server
    functionalities from the ROS 2 libraries.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在一个动作中，你有三个服务（发送目标、取消目标和接收结果）和两个主题（反馈和目标状态）。好消息是，你不必自己创建这些主题和服务——它们已经在动作机制中实现了。你只需要使用
    ROS 2 库中的动作客户端和服务器功能。
- en: To create an action, you will need to give it a **name** (for example, **move_robot**)
    so that the client knows where to send the goal. You will also need to use an
    **interface (goal,** **result, feedback)**.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个动作，你需要给它一个**名称**（例如，**move_robot**），这样客户端就知道将目标发送到哪里。你还需要使用一个**接口（目标、结果、反馈）**。
- en: One additional thing to note is that there can be only one action server. Just
    as for services, you can’t have two servers using the same name. On the other
    hand, you can have multiple action clients. Each client can also send multiple
    goals; that’s not a problem.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的事项是，只能有一个动作服务器。就像服务一样，你不能有两个使用相同名称的服务器。另一方面，你可以有多个动作客户端。每个客户端也可以发送多个目标；这不是问题。
- en: Wrapping things up
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: On top of topics and services, you can use actions to make your nodes communicate
    with each other. Now, when should you use topics, services, or actions?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在主题和服务之上，你可以使用动作使你的节点相互通信。现在，你何时应该使用主题、服务或动作？
- en: You should use *topics* when you want to send data streams between nodes. With
    topics, there’s no response. For example, this can work for publishing sensor
    data or sending a stream of commands to another node if you don’t need any confirmation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想在节点之间发送数据流时，你应该使用*主题*。使用主题时，没有响应。例如，这可以用于发布传感器数据或向另一个节点发送命令流，如果你不需要任何确认的话。
- en: '*Services* are perfect when you want client/server communication, but also
    if the action to execute is very quick, such as a computation or a simple action,
    such as switching on an LED.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想进行客户端/服务器通信，或者要执行的动作非常快，例如计算或简单的动作，如打开LED时，*服务*是完美的。
- en: Finally, you will use *actions* for anything that needs client/server communication
    and may take some time to execute, as well as when you also want to have mechanisms
    such as feedback and cancel.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将使用*动作*来进行任何需要客户端/服务器通信且可能需要一些时间来执行的事情，以及当你还想要有反馈和取消等机制时。
- en: 'Here are some important points about how actions work:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于动作如何工作的一些重要点：
- en: An action is defined by a name and an interface.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作由一个名称和一个接口定义。
- en: The name of an action follows the same rules as for topics and services. It
    must start with a letter and can be followed by other letters, numbers, underscores,
    tildes, and slashes. Also, as the action is *doing* something, the best practice
    is to start the name with a verb.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作名称遵循与主题和服务相同的规则。它必须以字母开头，后跟其他字母、数字、下划线、波浪号和斜杠。此外，由于动作是在*执行*某事，最佳实践是以动词开头命名。
- en: 'The interface contains three things: a goal, a result, and feedback. Both the
    client and server must use the same interface.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 界面包含三个元素：一个目标、一个结果和反馈。客户端和服务器必须使用相同的界面。
- en: An action server can only exist once, but you can send multiple goals from one
    or multiple action clients.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个动作服务器只能存在一次，但你可以从一个或多个动作客户端发送多个目标。
- en: Action clients aren’t aware of the node containing the server. They just know
    they have to use the action name and interface to reach the server.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作客户端不知道包含服务器的节点。它们只知道必须使用动作名称和接口来连接服务器。
- en: 'To implement an action communication, you will need to do the following at
    the very least:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现动作通信，你至少需要做以下事情：
- en: Send a goal from the client to the server.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从客户端向服务器发送一个目标。
- en: Accept (or not) the goal and execute it on the server.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受（或不接受）目标并在服务器上执行它。
- en: Once the goal is finished, return a result from the server to the client.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦目标完成，服务器需要向客户端返回一个结果。
- en: 'The following are some optional features you can add:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些你可以添加的可选功能：
- en: Send some execution feedback from the server to the client while the goal is
    being executed.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在目标执行期间，从服务器向客户端发送一些执行反馈。
- en: Allow the client to send a cancel request to the server. If accepted, finish
    the goal execution on the server side.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许客户端向服务器发送取消请求。如果被接受，则在服务器端完成目标执行。
- en: To write action servers and clients in your code, you must use the action functionality
    from the **rclpy.action** and **rclcpp_action** libraries.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要在代码中编写动作服务器和客户端，你必须使用来自 **rclpy.action** 和 **rclcpp_action** 库的动作功能。
- en: At this point, we can start writing some code. If you’re still a bit confused,
    don’t worry—actions are quite complex to grasp initially. They contain lots of
    different mechanisms. Everything will make more sense as we create an action and
    write the client and server code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以开始编写一些代码。如果你仍然有点困惑，不要担心——动作最初相当复杂。它们包含很多不同的机制。随着我们创建动作并编写客户端和服务器代码，一切都会更加清晰。
- en: Since we can’t test a client without a server, we will, as we did for services,
    start with the server side. To create a server, we need an action interface, so
    that will be our starting point.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有服务器我们无法测试客户端，因此我们将像为服务所做的那样，从服务器端开始。要创建一个服务器，我们需要一个动作接口，因此这将是我们的起点。
- en: Creating a custom action interface
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义动作接口
- en: To create an action interface, we first need to clearly define what we need
    to achieve with the action. Then, we can add the interface to the **my_robot_interfaces**
    package (in this section, we will continue using the packages we created in the
    previous chapters).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个动作接口，我们首先需要清楚地定义我们希望通过动作实现什么。然后，我们可以将接口添加到 **my_robot_interfaces** 包（在本节中，我们将继续使用我们在前几章中创建的包）。
- en: Defining the application and the interface we need
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义所需的应用程序和接口
- en: In the application that we will write in this chapter, the action server will
    be responsible for counting until a given number, with a delay between each count,
    so that we can simulate that the action takes some time and doesn’t return immediately.
    The client will have to send a number to the server so that the server can start
    to count. When the server finishes, it will send the result (last reached number)
    back to the client.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章我们将编写的应用程序中，动作服务器将负责计数直到一个给定的数字，每次计数之间有延迟，以便我们可以模拟动作需要一些时间并且不会立即返回。客户端需要向服务器发送一个数字，以便服务器可以开始计数。当服务器完成时，它将结果（最后达到的数字）发送回客户端。
- en: For example, let’s say the client sends the number 5 to the server, and there’s
    a delay of 0.5 seconds. The server will start to count from 0, up to 5, and wait
    0.5 seconds between each iteration. When finishing, the server will return 5 if
    it could count until the end, or the last reached number if the execution finished
    sooner (the goal was canceled, or any other reason that could make the server
    stop the goal). In addition to that, we will add some feedback about the current
    count while the server is executing the goal.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设客户端向服务器发送数字5，并且延迟为0.5秒。服务器将从0开始计数，直到5，并在每次迭代之间等待0.5秒。当完成时，如果服务器能够数到终点，则返回5，或者如果执行提前结束（目标被取消，或任何其他可能导致服务器停止目标的原因），则返回最后达到的数字。此外，我们将在服务器执行目标时添加一些关于当前计数的反馈。
- en: 'Before we write any code, we need to know what interface to use for the action.
    From the previous paragraph, we can see that we need the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写任何代码之前，我们需要知道要使用哪个接口进行动作。从前一段中，我们可以看到我们需要以下内容：
- en: '**Goal**: An integer for the target number and a float number for the delay'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标**：一个表示目标数字的整数和一个表示延迟的浮点数'
- en: '**Result**: An integer for the last reached number'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结果**：一个表示最后达到的数字的整数'
- en: '**Feedback**: An integer for the current count'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反馈**：一个表示当前计数的整数'
- en: For topics and services, you must first check whether you can find an existing
    interface that matches your needs as there are already a lot of them you can use
    without having to create a new one.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于主题和服务，你必须首先检查是否可以找到一个现有的接口来满足你的需求，因为已经有很多你可以使用而不需要创建一个新的接口。
- en: For actions, you could try to do the same, but there aren’t as many existing
    action interfaces. Actions are a bit more complex than the other communication
    types, so you would need to find an interface that matches the goal, result, and
    feedback for your application exactly. The probability of that is very low as
    each action will be quite different. Thus, for actions, we won’t try to find existing
    interfaces and create a custom one directly.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于动作，你可以尝试做同样的事情，但现有的动作接口并不多。动作比其他通信类型更复杂，因此你需要找到一个与你的应用程序的目标、结果和反馈完全匹配的接口。这种情况的可能性非常低，因为每个动作都将非常不同。因此，对于动作，我们不会尝试寻找现有的接口，而是直接创建一个自定义接口。
- en: Creating a new action interface
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个新的动作接口
- en: The process of creating an action interface will be the same as for topic and
    service interfaces. We will follow a similar approach.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 创建动作接口的过程将与主题和接口接口相同。我们将遵循类似的方法。
- en: First, you need to create and configure a package dedicated to interfaces. We
    did that in [*Chapter 5*](B22403_05.xhtml#_idTextAnchor211), in the *Creating
    a custom interface for a topic* section, with the **my_robot_interfaces** package.
    You can reuse this package to add your action interfaces. If you don’t have it,
    go back and configure it first, then continue with the following steps.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要创建和配置一个专门用于接口的包。我们在 [*第五章*](B22403_05.xhtml#_idTextAnchor211) 的 *为话题创建自定义接口*
    部分中做到了这一点，使用的是 **my_robot_interfaces** 包。你可以重用这个包来添加你的动作接口。如果你没有它，请先返回并配置它，然后继续以下步骤。
- en: 'In this package, we already have **msg** and **srv** folders for topic and
    service interfaces, respectively. We will add a third folder, named **action**,
    for—as you may have guessed—action interfaces:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个包中，我们已经有 **msg** 和 **srv** 文件夹，分别用于主题和接口接口。我们将添加一个名为 **action** 的第三个文件夹，用于——正如你可能猜到的——动作接口：
- en: '[PRE0]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this new folder, you will place all the action interfaces specific to your
    robot or application.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新文件夹中，你将放置所有特定于你的机器人或应用程序的动作接口。
- en: 'Now, create a new file for your action. Here are the rules you must follow
    regarding the filename:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为你的动作创建一个新文件。以下是关于文件名的规则：
- en: Use UpperCamelCase—for example, `CountUntil`.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用大驼峰命名法——例如，`CountUntil`。
- en: Don’t write `Action` or `Interface` in the name as this will add unnecessary
    redundancy.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在名称中使用 `Action` 或 `Interface`，因为这会增加不必要的冗余。
- en: Use `.action` for the file extension.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `.action` 作为文件扩展名。
- en: As a best practice, use a verb in the interface’s name—for example, `NavigateToPosition`,
    `OpenDoor`, `PickObjectFromTable`, or `FetchDrinkFromFridge`. Actions, just like
    services, are about performing an action or computation (which can take some time),
    so by using a verb, you make it very clear what the action is doing.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为最佳实践，在接口的名称中使用一个动词——例如，`NavigateToPosition`、`OpenDoor`、`PickObjectFromTable`
    或 `FetchDrinkFromFridge`。动作，就像服务一样，是关于执行一个动作或计算（这可能需要一些时间），所以通过使用一个动词，你可以非常清楚地知道动作在做什么。
- en: 'Since we want to count until a given number, let’s call the interface **CountUntil**:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要计数到指定的数字，因此我们可以将接口命名为 **CountUntil**：
- en: '[PRE1]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can write the definition for the action in this file. Since we have three
    different parts (goal, result, and feedback), we need to separate them. You must
    add three dashes (**---**) between the goal and the result, and another three
    dashes between the result and the feedback.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在该文件中编写动作的定义。由于我们有三个不同的部分（目标、结果和反馈），我们需要将它们分开。你必须在目标和结果之间添加三个短横线（**---**），并在结果和反馈之间再添加三个短横线。
- en: 'Even if you don’t want to send any feedback, or if the result is empty, you
    still have to add the two separations with three dashes (**---**). A very simple
    action definition with nothing in the result and feedback would look like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你不想发送任何反馈，或者结果为空，你仍然必须添加两个带有三个短横线的分隔符（**---**）。一个非常简单的动作定义，结果和反馈中没有任何内容，看起来像这样：
- en: '[PRE2]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For the goal, result, and feedback, you can use the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于目标、结果和反馈，你可以使用以下内容：
- en: Built-in types (`bool`, `byte`, `int64`, and so on).
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置类型（`bool`、`byte`、`int64` 等）。
- en: Existing message interfaces. For example, the goal of the action could contain
    `geometry_msgs/Twist`.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有的消息接口。例如，动作的目标可以包含 `geometry_msgs/Twist`。
- en: Note
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can’t include an action or service definition inside an action definition.
    You can only include messages (topic definition) inside the goal, result, or feedback.
    Those three parts can be seen as three independent messages.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能在动作定义中包含动作或服务定义。你只能在目标、结果或反馈中包含消息（主题定义）。这三个部分可以被视为三个独立的消息。
- en: 'Since we are creating a rather simple application, we will only use built-in
    types here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在创建一个相对简单的应用程序，我们在这里将只使用内置类型：
- en: '[PRE3]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As for topic and service interfaces, all fields inside the definition must follow
    the **snake_case** convention (use underscores between words, all letters must
    be lowercase, and no spaces).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于主题和接口接口，定义内部的所有字段都必须遵循 **snake_case** 规范（单词之间使用下划线，所有字母必须小写，且没有空格）。
- en: I’ve also added comments to specify which part is the goal, result, and feedback.
    You don’t need to do this—I only did it for your first action definition so that
    you don’t get confused. Often, people make mistakes regarding the order and put
    the feedback before the result, which can lead to hard-to-debug errors later.
    The order is goal, result, and then feedback.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我还添加了注释来指定哪个部分是目标、结果和反馈。你不需要这样做——我只是为了你的第一个动作定义这样做，以免你感到困惑。人们经常在顺序上犯错误，把反馈放在结果之前，这可能导致难以调试的错误。顺序是目标、结果，然后是反馈。
- en: 'Now that we’ve written our interface, we need to build it so that we can use
    it in our code. Go back to the **CMakeLists.txt** file of the **my_robot_interfaces**
    package. Since the package has already been configured, we just need to do one
    thing: add the relative path to the interface on a new line inside the **rosidl_generate_interfaces()**
    function. Don’t use any commas between the lines:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了接口，我们需要构建它，以便我们可以在代码中使用它。回到**my_robot_interfaces**包的**CMakeLists.txt**文件。由于包已经配置好了，我们只需要做一件事：在**rosidl_generate_interfaces()**函数内部的新行上添加接口的相对路径。行与行之间不要使用任何逗号：
- en: '[PRE4]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After this, save all files and build the **my_robot_interfaces** package:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，保存所有文件并构建**my_robot_interfaces**包：
- en: '[PRE5]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once built, source the environment. You should be able to find your new interface:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完成后，源环境。你应该能够找到你的新接口：
- en: '[PRE6]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you see the action definition, you know that your action interface has been
    successfully built, and you can now use it in your code. That’s what we will do,
    starting with the action server for our application.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到了动作定义，你就知道你的动作接口已经成功构建，你现在可以在你的代码中使用它了。这就是我们将要做的，从我们的应用程序的动作服务器开始。
- en: Writing an action server
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写动作服务器
- en: In this section, you’ll write your first action server. In this server, we will
    be able to receive goals. When a goal is received, we will decide whether to accept
    or reject it. If it’s accepted, we will execute the goal. For this application,
    executing the goal means we will start to count from zero to the target number
    and wait for the provided delay between each iteration. Once the goal has been
    executed, we will return a result to the client.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将编写你的第一个动作服务器。在这个服务器中，我们将能够接收目标。当接收到目标时，我们将决定是否接受或拒绝它。如果接受，我们将执行目标。对于这个应用，执行目标意味着我们将从零开始计数到目标数字，并在每次迭代之间等待提供的延迟。一旦执行了目标，我们将向客户端返回一个结果。
- en: That’s what we will implement in the code, starting with Python and then C++.
    In this section, we start only with the minimum functionalities for the action
    communication to work correctly. We will add the feedback and cancel mechanisms
    later. Since actions are a bit more complex than topics and services, let’s start
    simple and go step by step.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在代码中实现这一点，从 Python 开始，然后是 C++。在本节中，我们只开始实现动作通信所需的最小功能。我们将在稍后添加反馈和取消机制。由于动作比主题和服务稍微复杂一些，让我们从简单开始，一步一步来。
- en: For a better learning experience, make sure you use the GitHub code while following
    along as I will not necessarily display all lines in this chapter, only the important
    ones. The code for this section is located in the **count_until_server_minimal**
    file (with **.py** or **.cpp** appended at the end). We won’t use the **number_publisher**
    and **number_counter** nodes here.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得更好的学习体验，确保你在跟随时使用 GitHub 代码，因为我不会显示本章的所有行，只显示重要的行。本节的代码位于**count_until_server_minimal**文件中（文件末尾带有**.py**或**.cpp**扩展名）。我们在这里不会使用**number_publisher**和**number_counter**节点。
- en: Before we write any code for the server, we need to choose a name and interface
    for our action. Since we want to count until a given number, we will name the
    action **count_until**, and we will use the **CountUntil** interface we’ve just
    created.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在为服务器编写任何代码之前，我们需要为我们的动作选择一个名称和接口。由于我们想要计数到一个给定的数字，我们将动作命名为**count_until**，并使用我们刚刚创建的**CountUntil**接口。
- en: We now have everything we need to start writing the Python code.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经有了一切，可以开始编写 Python 代码。
- en: Writing a Python action server
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 Python 动作服务器
- en: You will need to write your action server inside a node. Create a new file named
    **count_until_server_minimal.py** inside the **my_py_pkg** package (along with
    the other Python files). Make this file executable.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在节点内部编写你的动作服务器。在**my_py_pkg**包（与其他 Python 文件一起）内创建一个名为**count_until_server_minimal.py**的新文件。使此文件可执行。
- en: Importing the interface and creating the server
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入接口并创建服务器
- en: Let’s start by setting up the action server.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先设置动作服务器。
- en: 'First, we must import a bunch of libraries and classes that we will need in
    the code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须导入我们将在代码中需要的许多库和类：
- en: '[PRE7]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Unlike topics and services, the action server is not directly included in the
    **Node** class. So, we need to import the **ActionServer** class from **rclpy.action**.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与主题和服务不同，动作服务器不是直接包含在**Node**类中的。因此，我们需要从**rclpy.action**导入**ActionServer**类。
- en: 'After this, you must also import the interface for the action:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，您还必须导入动作的接口：
- en: '[PRE8]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When you import an interface from another package, make sure to add the dependency
    to **my_robot_interfaces** in the **package.xml** file of **my_py_pkg** (you should
    have already done this if you’ve been following along):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当您从另一个包导入接口时，请确保将依赖项添加到**my_py_pkg**的**package.xml**文件中的**my_robot_interfaces**（如果您一直跟随，您应该已经这样做过了）：
- en: '[PRE9]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Going back to the **count_until_server_minimal.py** file, let’s create the
    action server in the node’s constructor (as stated in the introduction to this
    section, I’ll only display the important and relevant snippets; the full constructor
    code is available on GitHub):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 回到**count_until_server_minimal.py**文件，让我们在节点的构造函数中创建动作服务器（如本节介绍中所述，我将只显示重要和相关的片段；完整的构造函数代码可在GitHub上找到）：
- en: '[PRE10]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To create an action server with Python, you must use the **ActionServer** class
    we imported previously. Provide the following arguments:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Python创建动作服务器，您必须使用我们之前导入的**ActionServer**类。提供以下参数：
- en: '`self.create…()`. Here, it’s a bit different: the object (`self`) is provided
    as the first argument.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.create…()`。在这里，它有点不同：对象（`self`）作为第一个参数提供。'
- en: '`CountUntil` interface we’ve imported.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们导入的`CountUntil`接口。
- en: '`count_until`.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count_until`。'
- en: '**Goal callback**: When a goal is received, it will be processed inside this
    callback.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标回调**：当接收到目标时，它将在该回调内部处理。'
- en: '**Execute callback**: If the goal has been accepted in the goal callback, then
    it will be processed in the execute callback. This is where you will execute the
    action.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行回调**：如果在目标回调中接受了目标，它将在执行回调中处理。这是您执行动作的地方。'
- en: We specified two callback methods when creating the action server. When the
    node spins, the action server will be in *waiting mode*. As soon as a goal is
    received, the node will trigger the goal callback, and then the execute callback
    if needed. Let’s implement those callbacks.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建动作服务器时，我们指定了两个回调方法。当节点旋转时，动作服务器将处于*等待模式*。一旦接收到目标，节点将触发目标回调，如果需要，然后触发执行回调。让我们实现这些回调。
- en: Accepting or rejecting a goal
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接受或拒绝目标
- en: The action server can now receive goals. We need to decide whether to accept
    or reject them.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 动作服务器现在可以接收目标。我们需要决定是否接受或拒绝它们。
- en: 'Let’s start writing the goal callback, which is the first method to be called
    whenever a goal is received by the server:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编写目标回调，这是服务器接收到目标时首先调用的方法：
- en: '[PRE11]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this callback, we receive the goal that was sent by the client (it’s of the
    **CountUntil.Goal** type).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在此回调中，我们接收客户端发送的目标（它是**CountUntil.Goal**类型）。
- en: Note
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'An action interface contains a goal, a result, and feedback. You get one class
    for each message: `CountUntil.Goal`, `CountUntil.Result`, and `CountUntil.Feedback`.
    We will use all three in this chapter.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 动作接口包含一个目标、一个结果和反馈。您为每个消息获得一个类：`CountUntil.Goal`、`CountUntil.Result`和`CountUntil.Feedback`。我们将在本章中使用这三个类。
- en: The best practice is to validate the data you receive whenever you write the
    code for a server. For this application, let’s say we want to only accept positive
    target numbers. If the number is negative, we reject the goal.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的做法是在为服务器编写代码时，每次都验证您接收到的数据。对于这个应用程序，让我们假设我们只想接受正数目标。如果数字是负数，我们将拒绝目标。
- en: After validating the data, you need to return either **GoalResponse.ACCEPT**
    or **GoalResponse.REJECT** to accept or reject the goal, respectively. The client
    will be notified immediately of that decision. Then, if the goal is rejected,
    nothing more happens on the server side. If the goal is accepted, the execute
    callback will be triggered.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证数据后，您需要返回**GoalResponse.ACCEPT**或**GoalResponse.REJECT**以分别接受或拒绝目标。客户端将立即被告知该决定。然后，如果目标被拒绝，服务器端将不再发生任何事情。如果目标被接受，将触发执行回调。
- en: Executing the goal
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行目标
- en: 'Let’s implement the execute callback. Here’s the beginning of the code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现执行回调。以下是代码的开始部分：
- en: '[PRE12]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this callback, you get what’s called a goal handle, which is of the **ServerGoalHandle**
    type. I’ve made the argument type explicit so that we can get auto-completion
    with VS Code. This goal handle contains the goal information, but you can also
    use it to set the goal’s final state, which we will see in a minute.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个回调中，您会得到一个所谓的目标句柄，它属于**ServerGoalHandle**类型。我已经将参数类型明确化，这样我们就可以在 VS Code
    中获得自动完成功能。这个目标句柄包含目标信息，但您也可以用它来设置目标的最终状态，我们将在下一分钟看到这一点。
- en: 'The first thing you must typically do is extract the data from the goal. Here,
    we get the target number and delay that we will use when executing the action.
    Then, we initialize a few things: the result from the **CountUntil.Result** class,
    and a counter starting at **0**.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您通常必须做的第一件事是从目标中提取数据。在这里，我们获取目标数字和延迟，这些是我们执行动作时将使用的。然后，我们初始化一些事情：**CountUntil.Result**类的结果，以及从**0**开始的计数器。
- en: 'With this, we can start to execute the goal:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就可以开始执行目标：
- en: '[PRE13]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This part of the code will be different every time as it depends entirely on
    your application. Here, we’re incrementing the counter until the target number
    is reached, with a delay between each iteration.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分代码每次都会不同，因为它完全取决于您的应用程序。在这里，我们正在增加计数器，直到达到目标数字，每次迭代之间都有延迟。
- en: The point of using a delay here is just to make this method take more time so
    that we can simulate the behavior of an action. If we wanted to count as fast
    as possible, without any delay, we could have used a service since the action
    would finish almost immediately.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用延迟的目的只是为了让这个方法花费更多时间，以便我们可以模拟动作的行为。如果我们想尽可能快地计数，没有任何延迟，我们可以使用服务，因为动作几乎会立即完成。
- en: 'Once the execution is finished, we need to do two things—set a final state
    for the goal and return a result to the client:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行完成，我们需要做两件事——为目标设置最终状态，并返回一个结果给客户端：
- en: '[PRE14]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: During the execution of the action, the goal is in the *executing* state. When
    finishing the execution, you need to make it transition into a final state.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在动作执行期间，目标是处于*执行中*状态。当完成执行时，您需要让它过渡到最终状态。
- en: In this case, since everything went smoothly and we didn’t expect any problems
    during the execution, we set the goal to *succeeded* by using the **succeed()**
    method on the goal handle. If, for example, your action was responsible for moving
    the wheels of a robot, and if the communication with the wheels is lost during
    the execution, you would stop the action and set the goal to *aborted* with the
    **abort()** method. The last possible state is *canceled*, which we will see a
    bit later in this chapter.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，由于一切都很顺利，我们预计在执行过程中不会出现任何问题，所以我们通过在目标句柄上使用**succeed()**方法将目标设置为*成功*。例如，如果您的动作负责移动机器人的轮子，并且在执行过程中与轮子的通信丢失，您将停止动作，并使用**abort()**方法将目标设置为*已取消*。最后可能的状态是*已取消*，我们将在本章稍后看到。
- en: We’ve now written the minimal code for the action server to work properly. Before
    we write an action client, let’s switch to C++. If you only want to follow the
    Python explanations, then go ahead and skip the next section.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经编写了动作服务器正常工作的最小代码。在我们编写动作客户端之前，让我们切换到 C++。如果您只想跟随 Python 的解释，那么请继续跳过下一节。
- en: Writing a C++ action server
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 C++ 动作服务器
- en: The code logic for C++ actions is very similar to Python, but there are quite
    a few specificities about the syntax. We will focus mostly on those differences.
    Also, as the code starts to become quite large, I will not necessarily display
    the full code, only the important parts for comprehension. Make sure you take
    a look at this book’s GitHub repository to see the full code.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 动作的代码逻辑与 Python 非常相似，但语法有一些特定的差异。我们将主要关注这些差异。此外，由于代码开始变得相当庞大，我可能不会显示完整的代码，只显示理解所需的重要部分。请确保查看这本书的
    GitHub 仓库以查看完整的代码。
- en: Importing the interface and creating the server
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入接口并创建服务器
- en: Let’s start by setting up the action server. First, create a new file named
    **count_until_server_minimal.cpp** in the **src** directory of your **my_cpp_pkg**
    package.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先设置动作服务器。首先，在您的**my_cpp_pkg**包的**src**目录中创建一个名为**count_until_server_minimal.cpp**的新文件。
- en: 'Open the file and start by adding the necessary includes:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件，首先添加必要的包含：
- en: '[PRE15]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see, the action library is not a sub-library of **rclcpp**—it’s
    a completely independent one from a different package: **rclcpp_action**.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，动作库不是**rclcpp**的子库——它是一个完全独立的库，来自不同的包：**rclcpp_action**。
- en: 'For each new package we use, we need to add the dependency to the **package.xml**
    file of the **my_cpp_pkg** package:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们使用的每个新包，我们需要将依赖项添加到**my_cpp_pkg**包的**package.xml**文件中：
- en: '[PRE16]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You will also need to specify those dependencies in the **CMakeLists.txt**
    file:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要在**CMakeLists.txt**文件中指定这些依赖项：
- en: '[PRE17]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, when you create your executable, don’t forget to add both dependencies
    to the **ament_target_dependencies()** function:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当你创建你的可执行文件时，别忘了将这两个依赖项添加到**ament_target_dependencies()**函数中：
- en: '[PRE18]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Back to the **count_until_server_minimal.cpp** file, we add a few **using**
    lines to simplify the code (you can find those lines at the top of the file, under
    the **#include** lines). After that, you can add an action server to your class
    as a private attribute:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 回到**count_until_server_minimal.cpp**文件，我们添加一些**using**行来简化代码（你可以在文件的顶部找到这些行，在**#include**行下面）。之后，你可以在你的类中添加一个动作服务器作为私有属性：
- en: '[PRE19]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Once again, we’re going to use a shared pointer to keep the object.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将使用共享指针来保持对象。
- en: 'Then, in the constructor, you can create the action server:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在构造函数中，你可以创建动作服务器：
- en: '[PRE20]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For actions, the C++ syntax is stricter than Python. On top of the action interface,
    object to link to, and action name, you have to provide three callbacks (even
    if you don’t want to use them all):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对于动作，C++的语法比Python更严格。除了动作接口、要链接的对象和动作名称之外，你必须提供三个回调（即使你不想使用它们）：
- en: '**Goal callback**: To accept or reject incoming goals.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标回调**：用于接受或拒绝传入的目标。'
- en: '**Cancel callback**: To receive cancel requests.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**取消回调**：接收取消请求。'
- en: '**Execute callback**: This is called the *handle accepted callback* in C++,
    but I named it *execute callback* to make the code similar to the Python one.
    In this callback, we execute goals that have been accepted.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行回调**：在C++中，这被称为*处理已接受回调*，但我将其命名为*执行回调*，以便使代码与Python相似。在这个回调中，我们执行已接受的目标。'
- en: Note
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: I’ve designed this chapter so that we write minimal code first, and then add
    the extra optional features. However, the C++ `create_server()` method will not
    work if you don’t provide a cancel callback. Thus, what we will do for now is
    add this callback but not fully implement the cancel mechanism; we’ll do that
    later.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我设计这一章是为了我们先编写最少的代码，然后添加额外的可选功能。然而，如果你不提供取消回调，C++的`create_server()`方法将无法工作。因此，我们现在要添加这个回调，但不会完全实现取消机制；我们将在稍后完成。
- en: At this point, we need to implement the three callback methods.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们需要实现三个回调方法。
- en: Implementing the callbacks
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现回调
- en: The arguments inside the callbacks can be quite long to write. That’s why I
    suggest simplifying the code with **using** lines at the beginning, as well as
    double-checking everything as it’s easy to make mistakes.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数内部的参数可能相当长，难以书写。这就是为什么我建议在代码开头使用**using**行来简化代码，以及仔细检查一切，因为很容易出错。
- en: 'Here’s the beginning of the goal callback method:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这是目标回调方法的开头：
- en: '[PRE21]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here, you get a unique identifier for the goal and the goal itself (to be precise,
    this is a **const** shared pointer to the goal). In the callback, we validate
    the goal and then accept or reject it. For example, to accept the goal, you would
    return the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你得到一个目标唯一标识符以及目标本身（更准确地说，这是一个指向目标的**const**共享指针）。在回调中，我们验证目标，然后接受或拒绝它。例如，要接受目标，你会返回以下内容：
- en: '[PRE22]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The next callback method is the cancel callback, in which you can decide whether
    to accept or reject an incoming cancel request. As I will explain the cancel mechanism
    later in this chapter, I will skip this part now—you just have to write the callback
    so that the code can compile.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个回调方法是取消回调，你可以决定是否接受或拒绝传入的取消请求。由于我将在本章后面解释取消机制，我现在将跳过这部分内容——你只需要编写回调，以便代码可以编译。
- en: 'The most important callback here is the execute callback. In this method, we
    receive a goal handle (**const std::shared_ptr<CountUntilGoalHandle> goal_handle**).
    The first thing we must do is extract the data from the goal and initialize a
    few things:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最重要的回调是执行回调。在这个方法中，我们接收一个目标句柄（**const std::shared_ptr<CountUntilGoalHandle>
    goal_handle**）。我们必须做的第一件事是从目标中提取数据并初始化一些事情：
- en: '[PRE23]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You’ve probably started to get used to seeing shared pointers everywhere, and
    here is no exception. We don’t create a result object, but a shared pointer to
    a result object.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经习惯了到处看到共享指针，这里也不例外。我们不是创建一个结果对象，而是一个指向结果对象的共享指针。
- en: 'Then, to handle the waiting time between each count iteration, we use a **rclcpp::Rate**
    object. This is a bit different from what we did with Python. In this rate object,
    we have to pass the rate—that is, the frequency we want for the loop. For example,
    if the delay is 0.5 seconds, the frequency would be 2.0 Hz. We can now execute
    the action:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了处理每次计数迭代之间的等待时间，我们使用一个 **rclcpp::Rate** 对象。这与我们用 Python 做的事情有点不同。在这个速率对象中，我们必须传递速率——即我们想要的循环频率。例如，如果延迟是
    0.5 秒，频率将是 2.0 Hz。我们现在可以执行动作：
- en: '[PRE24]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we use the **sleep()** function of the rate object to pause the execution.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用速率对象的 **sleep()** 函数来暂停执行。
- en: 'Finally, once the **for** loop ends, we can finish the execution:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦 **for** 循环结束，我们可以完成执行：
- en: '[PRE25]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In Python, we would set the goal’s final state first, and then return the result.
    In C++, we don’t return anything (note the **void** return type). We send the
    result at the same time as setting the goal state.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，我们首先设置目标的最终状态，然后返回结果。在 C++ 中，我们不返回任何内容（注意 **void** 返回类型）。我们在设置目标状态的同时发送结果。
- en: Note
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Writing C++ code with actions starts to be quite complex, especially if you
    don’t have much C++ experience. If you feel completely lost, maybe either continue
    with Python only or, as mentioned previously, skip this chapter for now and come
    back to it later.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用动作编写 C++ 代码开始变得相当复杂，尤其是如果你没有太多 C++ 经验。如果你感到完全迷茫，也许可以只继续使用 Python，或者，如前所述，现在暂时跳过这一章，稍后再回来。
- en: That’s it for the C++ action server. We can now write the client node and try
    the communication.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 动作服务器的内容到此结束。我们现在可以编写客户端节点并尝试通信。
- en: Writing an action client
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写动作客户端
- en: We now have the minimal code required for the server to receive a goal, accept
    it, execute it, and return a result. At this point, we can write the client side
    of the communication.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了服务器接收目标、接受它、执行它并返回结果的必要最小代码。在这个时候，我们可以编写通信的客户端部分。
- en: The action client will send a goal to the server. It will then register a callback
    to find out whether the goal was accepted or rejected. If the goal is accepted,
    the client will register yet another callback to get the final result. That’s
    what we’re going to implement now—first with Python, then with C++.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 动作客户端将向服务器发送一个目标。然后，它将注册一个回调以确定目标是否被接受或拒绝。如果目标被接受，客户端将注册另一个回调以获取最终结果。这正是我们现在要实现的——首先用
    Python，然后用 C++。
- en: Where should you write the action client? In your own ROS 2 applications, you
    could add an action client to any node. As an example, let’s say you have a node
    that monitors the battery level of a mobile robot. This node could already have
    some publishers, subscribers, services, and so on. On top of all that, you can
    add an action client that will send a goal to another node (such as the server
    node, which controls the wheels of the robot) when the battery runs low.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在何处编写动作客户端？在你的 ROS 2 应用程序中，你可以在任何节点中添加动作客户端。例如，假设你有一个监控移动机器人电池电平的节点。这个节点可能已经有一些发布者、订阅者、服务等等。在所有这些之上，你可以添加一个动作客户端，当电池电量低时，它会向另一个节点（例如控制机器人轮子的服务器节点）发送目标。
- en: For this chapter, and to keep things simple, we will create a new node, just
    for the action client. You can then use this code as a template for adding an
    action client anywhere you want. You can find the code for this section in **count_until_client_minimal**
    (**.py** or **.cpp**).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，为了保持简单，我们将创建一个新的节点，专门用于动作客户端。然后你可以将此代码用作模板，添加到任何你想添加动作客户端的地方。你可以在此部分的 **count_until_client_minimal**
    中找到代码（**.py** 或 **.cpp**）。
- en: Let’s start with the Python action client.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 Python 动作客户端开始。
- en: Writing a Python action client
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 Python 动作客户端
- en: Create a new Python file named **count_until_client_minimal.py** in the **my_py_pkg**
    package. Make this file executable.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **my_py_pkg** 包中创建一个名为 **count_until_client_minimal.py** 的新 Python 文件。使此文件可执行。
- en: Creating an action client
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建动作客户端
- en: 'Let’s start by setting up the action client. First, add the dependencies we
    will need:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先设置动作客户端。首先，添加我们将需要的依赖项：
- en: '[PRE26]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As for the action server, we don’t get the action client directly from the **Node**
    class. Instead, we have to import **ActionClient** from **rclpy.action**.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 至于动作服务器，我们不是直接从 **Node** 类获取动作客户端。相反，我们必须从 **rclpy.action** 导入 **ActionClient**。
- en: We must also import the action interface, which should be the same as for the
    server. If we import this interface, we also need to add a dependency to the **package.xml**
    file. However, we have already done that, so there’s no need to add anything else.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须导入动作接口，它应该与服务器相同。如果我们导入这个接口，我们还需要在**package.xml**文件中添加一个依赖项。然而，我们已经做了，所以不需要添加任何其他内容。
- en: 'Then, in the node’s constructor, we create an action client:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在节点的构造函数中，我们创建一个动作客户端：
- en: '[PRE27]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We use the **ActionClient** class directly, and we pass three arguments: the
    object to bind to (**self**), the action interface, and the action name. Double-check
    that the name is the same as on the server side.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们直接使用**ActionClient**类，并传递三个参数：要绑定的对象（**self**）、动作接口和动作名称。请确保名称与服务器端相同。
- en: 'Then, to send a goal to the server, we add a new method:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了向服务器发送目标，我们添加一个新的方法：
- en: '[PRE28]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here are the steps for sending a goal from the client to the server:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 从客户端向服务器发送目标的过程如下：
- en: You can wait for the server with `wait_for_server()`. If you send a goal when
    the server isn’t up and running, you will get an error, so ensure it’s ready before
    you do anything. I didn’t provide a timeout here, so it will wait indefinitely.
    You could add a timeout and do something similar to what we did in [*Chapter 6*](B22403_06.xhtml#_idTextAnchor282),
    in the *Writing a service* *client* section.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用`wait_for_server()`等待服务器。如果您在服务器未启动和运行时发送目标，您将得到一个错误，所以确保它在您做任何事情之前已经准备好了。我没有提供超时，所以它将无限期地等待。您可以为它添加一个超时，并做类似我们在[*第6章*](B22403_06.xhtml#_idTextAnchor282)中在*编写服务*
    *客户端*部分所做的事情。
- en: 'Create a goal object from the interface: `Interface.Goal()`.'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从接口创建一个目标对象：`Interface.Goal()`。
- en: Fill in the goal fields. Any field you omit will get a default value (`0` for
    numbers, `""` for strings).
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写目标字段。您省略的任何字段都将获得默认值（数字为`0`，字符串为`""`）。
- en: Send the goal with `send_goal_async()`. This will return a Python `Future` object.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`send_goal_async()`发送目标。这将返回一个Python `Future`对象。
- en: Register a callback for the goal’s response so that you know it’s been accepted
    or rejected.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册一个目标响应的回调，以便您知道它已被接受或拒绝。
- en: Note that just as for services, we make an asynchronous call with **send_goal_async()**.
    This way, the method will return and we won’t block the execution. If we were
    to block the execution, we would also block the spin, and thus we would never
    get any response.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，就像对于服务一样，我们使用**send_goal_async()**进行异步调用。这样，方法将返回，我们不会阻塞执行。如果我们阻塞执行，我们也会阻塞旋转，因此我们永远不会得到任何响应。
- en: Implementing the callbacks
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现回调
- en: 'So far, we’ve sent a goal with the action client and registered a callback,
    **goal_response_callback()**. Let’s implement this method:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用动作客户端发送了一个目标并注册了一个回调，**goal_response_callback()**。让我们实现这个方法：
- en: '[PRE29]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this callback, we get a **ClientGoalHandle** object from the result of the
    Python **Future** object. From this goal handle, we can find out whether the goal
    was accepted or not.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个回调中，我们从Python **Future**对象的输出结果中获取一个**ClientGoalHandle**对象。从这个目标处理程序中，我们可以找出目标是否被接受。
- en: Please note that you won’t get the final result in this goal response callback.
    Here, we only get to know whether the server accepted the goal or not. If the
    goal is accepted, we know that the server will start executing it and return a
    result at some point.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您不会在这个目标响应回调中获得最终结果。在这里，我们只知道服务器是否接受了目标。如果目标被接受，我们知道服务器将开始执行它，并在某个时候返回一个结果。
- en: 'Then, in the client, we can register another callback for the goal result:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在客户端，我们可以为目标结果注册另一个回调：
- en: '[PRE30]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this callback, we get the goal’s final state and result after the server
    has finished executing the goal.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个回调中，我们在服务器完成目标执行后，获取目标的最终状态和结果。
- en: 'You can do anything you want with this result—here, we simply print it. As
    you can see, we will receive any of those three final states for the goal: **STATUS_SUCCEEDED**,
    **STATUS_ABORTED**, and **STATUS_CANCELED**.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以用这个结果做任何您想做的事情——在这里，我们只是简单地打印它。如您所见，我们将收到目标的三种最终状态之一：**STATUS_SUCCEEDED**、**STATUS_ABORTED**和**STATUS_CANCELED**。
- en: 'Finally, let’s not forget to call the **send_goal()** method. We will do this
    in the **main()** function, just after we initialize the node, and before we make
    the node spin:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，别忘了调用**send_goal()**方法。我们将在**main()**函数中这样做，就在初始化节点之后，在我们使节点旋转之前：
- en: '[PRE31]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This will ask the server to count until **5** and wait **0.5** seconds between
    each count.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这将要求服务器计数到**5**，并在每次计数之间等待**0.5**秒。
- en: Trying the communication
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尝试通信
- en: We can now try the communication between the client and server.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以尝试客户端和服务器之间的通信。
- en: Create an executable (in **setup.py**) for both the client and server nodes.
    Build the package and source the environment.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为客户端和服务器节点创建一个可执行文件（在**setup.py**中）。构建包并源环境。
- en: 'Then, start the server node and the client node in two different Terminals.
    You should see some logs in both Terminals as the communication progresses. In
    the end, you will get something like this for the server:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在两个不同的终端中启动服务器节点和客户端节点。随着通信的进行，您应该在两个终端中看到一些日志。最后，对于服务器，您将得到如下内容：
- en: '[PRE32]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'For the client:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 对于客户端：
- en: '[PRE33]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can see the flow of execution with the timestamp in each log. Here, we tested
    the case when the target number was positive—and thus, the goal was accepted.
    If you want, you can also test the case when the target number is negative; you
    should see the goal being rejected and not executed.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过每个日志中的时间戳看到执行流程。在这里，我们测试了目标数字为正的情况——因此，目标被接受。如果您愿意，您也可以测试目标数字为负的情况；您应该看到目标被拒绝而没有被执行。
- en: Now, let’s learn how to write an action client with C++.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何用C++编写动作客户端。
- en: Writing a C++ action client
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写C++动作客户端
- en: For the C++ code, I will focus on the few important points to notice in the
    **count_until_client_minimal.cpp** file.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 对于C++代码，我将关注**count_until_client_minimal.cpp**文件中需要注意的几个重要点。
- en: 'First, we have all the includes and **using** lines. Those are almost the same
    as for the C++ action server. However, for the goal handle, we get **ClientGoalHandle**
    (this was **ServerGoalHandle** in the server code):'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有所有的包含和**using**行。这些几乎与C++动作服务器相同。然而，对于目标处理，我们得到**ClientGoalHandle**（在服务器代码中是**ServerGoalHandle**）：
- en: '[PRE34]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To create an action client, we declare the client as a private attribute of
    the class:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个动作客户端，我们声明客户端为类的私有属性：
- en: '[PRE35]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, we initialize the client in the constructor:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在构造函数中初始化客户端：
- en: '[PRE36]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see (but that shouldn’t be a surprise anymore), we store a shared
    pointer to the action client. When initializing it, we provide the action interface,
    the object to bind to (**this**), and the action name, which should be the same
    as the one defined in the server code.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见（但这不应该再是惊喜了），我们存储了一个指向动作客户端的共享指针。初始化时，我们提供了动作接口、要绑定的对象（**this**）和动作名称，这个名称应该与服务器代码中定义的相同。
- en: 'At this point, we can create a **sendGoal()** method to send a goal to the
    server. This method follows the same steps as for the Python client. We wait for
    the server, then create a goal, fill in the goal fields, send the goal, and register
    a callback. However, there is a big difference in how we handle the callbacks:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，我们可以创建一个**sendGoal()**方法来向服务器发送目标。此方法遵循与Python客户端相同的步骤。我们等待服务器，然后创建一个目标，填写目标字段，发送目标，并注册回调。然而，我们在处理回调的方式上有一个很大的不同：
- en: '[PRE37]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In Python, we would chain the callbacks after sending the goal. In C++, you
    first need to create a **SendGoalOptions** object. In this object, you can register
    the different callback methods for your client. Here, we register the response
    and the result callback. Then, you must pass this object to the **async_send_goal()**
    method. This will register all the callbacks for when the node is spinning.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们在发送目标后链式调用回调。在C++中，您首先需要创建一个**SendGoalOptions**对象。在这个对象中，您可以注册客户端的不同回调方法。在这里，我们注册了响应和结果回调。然后，您必须将此对象传递给**async_send_goal()**方法。这将注册节点旋转时的所有回调。
- en: Now that we’ve registered two callbacks, we need to implement them.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经注册了两个回调，我们需要实现它们。
- en: 'In the goal response callback, to check if the goal was accepted or rejected,
    we can simply write the following:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在目标响应回调中，为了检查目标是否被接受或拒绝，我们可以简单地写下以下内容：
- en: '[PRE38]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If this returns **false**, we know the goal was rejected. If it returns **true**,
    there’s no need to do anything else in this callback as the result callback was
    already registered with the **SendGoalOptions** object.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个返回**false**，我们知道目标被拒绝了。如果它返回**true**，在这个回调中就没有必要做任何事情了，因为结果回调已经通过**SendGoalOptions**对象注册了。
- en: In the result callback, we get the goal’s final state with **result.code**.
    We can then compare it with the different codes in **rclcpp_action::ResultCode**,
    which are **SUCCEEDED**, **ABORTED**, and **CANCELED**. To get access to the actual
    result, we write **result.result**. This will be a shared pointer to the result
    object.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在结果回调中，我们通过**result.code**获取目标的最终状态。然后我们可以将其与**rclcpp_action::ResultCode**中的不同代码进行比较，这些代码是**SUCCEEDED**、**ABORTED**和**CANCELED**。要获取实际结果，我们写入**result.result**。这将是一个指向结果对象的共享指针。
- en: 'Finally, let’s not forget to call the **sendGoal()** method in the **main()**
    function:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，别忘了在 **main()** 函数中调用 **sendGoal()** 方法：
- en: '[PRE39]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: That’s about it for the C++ action client. After writing both the client and
    server, create an executable for both (in **CMakeLists.txt**); then, build, source,
    and run the two nodes. You can even try running the Python client with the C++
    server, or any other combination.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 C++ 动作客户端来说，这就结束了。在编写了客户端和服务器之后，为两者创建可执行文件（在 **CMakeLists.txt** 中）；然后，构建、源和运行这两个节点。你甚至可以尝试用
    C++ 服务器运行 Python 客户端，或者任何其他组合。
- en: 'Now that both the client and server are running correctly, we can add the extra
    functionalities we get with actions: feedback and cancel.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在客户端和服务器都运行正确后，我们可以添加通过动作获得的额外功能：反馈和取消。
- en: Taking advantage of all the action mechanisms
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用所有的动作机制
- en: The reason I’m talking about feedback and cancel mechanisms now and didn’t previously
    is to try not to overwhelm you with too much code at once. I know that actions
    are more complex than everything you’ve seen before with ROS 2\. The minimal code
    alone is already quite long and contains lots of small details you must pay attention
    to.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在谈论反馈和取消机制，而不是之前，是为了尽量不让你一次处理太多代码。我知道动作比之前在 ROS 2 中看到的任何东西都要复杂。仅最小代码就已经相当长，并且包含许多你必须注意的小细节。
- en: Also, as explained in the first part of this chapter, the feedback and cancel
    mechanisms are optional. You can create a fully working client/server communication
    without them.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如本章第一部分所解释的，反馈和取消机制是可选的。你可以创建一个无需它们的完整工作的客户端/服务器通信。
- en: 'We’re now going to improve the minimal code and add a few more functionalities
    so that we can take full advantage of ROS 2 actions. Here’s what you can do to
    prepare the files for this section:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将改进最小代码并添加更多功能，以便充分利用 ROS 2 动作。以下是你可以为此部分准备文件的步骤：
- en: Make a copy of the files containing `_minimal`.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制包含 `_minimal` 的文件。
- en: Rename those new files by removing the `_minimal`.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过删除 `_minimal` 重命名这些新文件。
- en: For example, you can make a copy of **count_until_client_minimal.py** (we won’t
    modify this file anymore) and rename the copy **count_until_client.py** (this
    is where we will add more code). You can find the same organization in this book’s
    GitHub repository.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以复制 **count_until_client_minimal.py**（我们不会再修改此文件）并将其重命名为 **count_until_client.py**（我们将在此处添加更多代码）。你可以在本书的
    GitHub 仓库中找到相同的组织结构。
- en: So, let’s explore the feedback and cancel mechanisms, starting with feedback,
    which is the easiest one.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们探索反馈和取消机制，从最简单的反馈开始。
- en: Adding the feedback mechanism
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加反馈机制
- en: 'When we wrote the action interface, we had to define three things: goal, result,
    and feedback. So far, we’ve only used the goal and result. The feedback is optional,
    and you could choose to leave it empty in the action definition. In this case,
    there’s nothing else to do.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写动作接口时，我们必须定义三件事：目标、结果和反馈。到目前为止，我们只使用了目标和结果。反馈是可选的，你可以在动作定义中将其留空。在这种情况下，就没有其他事情要做了。
- en: Since we’ve defined feedback in **CountUntil.action** (**int64 current_number**),
    let’s use it in our code so that we can make the server send feedback every time
    it increases the counter. The action client will be able to receive this feedback
    inside a callback.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在 **CountUntil.action** 中定义了反馈（**int64 current_number**），让我们在我们的代码中使用它，以便服务器每次增加计数器时都发送反馈。动作客户端将能够在回调中接收此反馈。
- en: Feedback with Python
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Python 的反馈
- en: Let’s start with the action server. There are just a few lines to add so that
    we can publish the feedback.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从动作服务器开始。只需添加几行代码，我们就可以发布反馈。
- en: 'Open **count_until_server.py**. In the **execute_callback()** method, at the
    same time as creating a result object, create a feedback object:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 **count_until_server.py**。在 **execute_callback()** 方法中，在创建结果对象的同时，创建一个反馈对象：
- en: '[PRE40]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, when you execute the goal, you have to do the following:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你执行目标时，你必须做以下事情：
- en: '[PRE41]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We must fill in the different fields of the feedback object and then send the
    feedback to the client with the **publish_feedback()** method from the goal handle.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须填写反馈对象的各个字段，然后使用目标句柄的 **publish_feedback()** 方法将反馈发送给客户端。
- en: That’s all there is to it for the server side. Now, let’s write the code to
    receive the feedback.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 对于服务器端来说，这就全部完成了。现在，让我们编写接收反馈的代码。
- en: 'Open the **count_until_client.py** file and modify the line where you send
    the goal with **send_goal_async()**:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 **count_until_client.py** 文件，并修改使用 **send_goal_async()** 发送目标的行：
- en: '[PRE42]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To get the feedback with a Python action client, you must register a callback
    function when you send the goal. Here’s the implementation for this callback:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Python动作客户端获取反馈，你必须在你发送目标时注册一个回调函数。以下是这个回调的实现：
- en: '[PRE43]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'With this, we get a feedback message and can access each field of that message.
    You can do anything you want with this feedback. For example, if your action client
    is asking for a robot to move to certain (x, y) coordinates, you might receive
    feedback on the current progress of the robot. From this, you could take any appropriate
    measure: cancel the goal (see the next section), send a new goal, and so on.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们得到一个反馈消息，可以访问该消息的每个字段。你可以用这个反馈做任何你想做的事情。例如，如果你的动作客户端要求机器人移动到特定的（x，y）坐标，你可能会收到关于机器人当前进度的反馈。从这个反馈中，你可以采取任何适当的措施：取消目标（参见下一节）、发送新的目标等等。
- en: 'That’s it regarding feedback. You can build your package again, source it,
    and run the two nodes. Here’s what you will see on the client side:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 关于反馈就到这里。你可以再次构建你的包，源码化它，并运行两个节点。以下是客户端将看到的内容：
- en: '[PRE44]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'It will continue as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 它将继续如下：
- en: '[PRE45]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: With this feedback, the client isn’t in the dark anymore. It can get to know
    what’s happening between sending the goal and receiving the result.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个反馈，客户端不再处于黑暗中。它可以了解在发送目标与接收结果之间的发生的事情。
- en: Feedback with C++
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C++中的反馈
- en: The behavior for adding the feedback for the action server in **count_until_server.cpp**
    is the same as it is for Python.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在`count_until_server.cpp`中添加动作服务器反馈的行为与Python相同。
- en: 'First, you must create a feedback object in the execute callback:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须在执行回调中创建一个反馈对象：
- en: '[PRE46]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The only difference is that we use a shared pointer here.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的不同之处在于我们在这里使用共享指针。
- en: 'Then, you must publish the feedback:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你必须发布反馈：
- en: '[PRE47]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'On the client side, the way a callback is registered is a bit different. Open
    **count_until_client.cpp** and add the following line to the **sendGoal()** method:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，注册回调的方式略有不同。打开`count_until_client.cpp`，并将以下行添加到`sendGoal()`方法中：
- en: '[PRE48]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: For a C++ action, we register all callbacks in the **SendGoalOptions** object
    that we pass to the **async_send_goal()** method.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 对于C++动作，我们在传递给`async_send_goal()`方法的`SendGoalOptions`对象中注册所有回调。
- en: 'Then, you can implement the callback:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以实现回调：
- en: '[PRE49]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, we receive both the goal handle and the feedback (as **const** shared
    pointers).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们接收目标句柄和反馈（作为**const**共享指针）。
- en: Note
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As you can see, whenever there’s an argument we don’t use in a function, I write
    `(void)`, followed by the argument. This is a way to prevent getting *unused parameter*
    warnings when compiling with `colcon build`. As a best practice, you should address
    all errors and warnings in your code when developing a ROS 2 application. If you
    don’t do this, you will end up with lots of ignored warnings, and you could miss
    the important ones, leading to hard-to-debug issues in the future.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，每当在函数中不使用一个参数时，我都会写`(void)`，然后是参数。这是在用`colcon build`编译时防止得到*未使用参数*警告的一种方法。作为一个最佳实践，在开发ROS
    2应用程序时，你应该解决代码中的所有错误和警告。如果你不这样做，你最终会有很多被忽略的警告，你可能会错过重要的警告，导致未来难以调试的问题。
- en: Now that the code is complete, you can compile the package and run the client
    and server nodes in two different Terminals. You should see a similar output to
    what we had for Python.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码已经完成，你可以编译包，并在两个不同的终端中运行客户端和服务器节点。你应该看到与Python类似的输出。
- en: Implementing the feedback mechanism is relatively easy. Now, let’s learn how
    to cancel a goal. This will be more complex and require the use of more advanced
    ROS 2 concepts.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 实现反馈机制相对简单。现在，让我们学习如何取消一个目标。这将更加复杂，需要使用更多高级的ROS 2概念。
- en: Adding the cancel mechanism
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加取消机制
- en: After sending a goal, the client can decide to ask the server to cancel it.
    The server will receive this request and accept (or not) to cancel the goal. If
    the cancel request is accepted, the server will take any appropriate action to
    cancel the execution of the goal. In the end, the server will still send a result
    to the client.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在发送一个目标后，客户端可以决定要求服务器取消它。服务器将接收这个请求并接受（或拒绝）取消目标。如果取消请求被接受，服务器将采取任何适当的行动来取消目标的执行。最后，服务器仍然会向客户端发送一个结果。
- en: What do we need to do in the code? In the server node, we will add another callback
    so that we can receive cancel requests and decide to accept or reject them. Then,
    in the execute callback, we will be able to check whether the goal should be canceled;
    if so, we will terminate the execution sooner.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在代码中做什么？在服务器节点中，我们将添加另一个回调，以便我们可以接收取消请求并决定接受或拒绝它们。然后，在执行回调中，我们将能够检查目标是否应该被取消；如果是这样，我们将提前终止执行。
- en: However, if we just do this, it’s not going to work and the cancel requests
    will never be received. Why is that? Let’s explore this question now.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们只是这样做，这是不会起作用的，取消请求也永远不会被接收。为什么是这样？让我们现在来探讨这个问题。
- en: Note
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This section introduces a few concepts that are outside the scope of this (beginner)
    book. I will talk about them briefly without going into full detail. If you’d
    like to understand these in more depth, feel free to explore the advanced concepts
    by yourself (you will find additional resources in [*Chapter 14*](B22403_14.xhtml#_idTextAnchor665)*).*
    You can see this section as a going further with actions section.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了一些超出本书（入门级）范围的概念。我将简要地谈论它们，而不会深入细节。如果你想更深入地了解这些概念，请自由探索高级概念（你将在[第14章](B22403_14.xhtml#_idTextAnchor665)中找到额外的资源）*。你可以将这一节视为关于动作的进一步探讨部分*。
- en: Understanding the problem with cancel and spin
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解取消和旋转的问题
- en: We will only focus on the server side here as this is where the issue will occur.
    I will explain what the issue is so that we can implement the solution later.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只关注服务器端，因为问题将在这里发生。我将解释问题所在，以便我们可以在稍后实施解决方案。
- en: 'So, when you start the action server, three callbacks will be registered: a
    goal callback, a cancel callback, and an execute callback.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当你启动动作服务器时，将注册三个回调：一个目标回调、一个取消回调和一个执行回调。
- en: 'With our current code, when the server receives a goal, here’s what happens:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们当前的代码，当服务器接收到一个目标时，以下是会发生的事情：
- en: The goal is received by the goal callback and is accepted or rejected.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标由目标回调接收并被接受或拒绝。
- en: If accepted, we execute the goal in the execute callback. Something crucial
    to note is that while we execute the goal with the `for` loop, the thread is blocked.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果被接受，我们在执行回调中执行目标。需要注意的是，当我们使用`for`循环执行目标时，线程被阻塞。
- en: Once the goal is executed, we return the result and exit from the execute callback.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦目标执行完成，我们就返回结果并从执行回调中退出。
- en: The problem is with *Step 2*. Since we’re blocking the execution, we’re blocking
    the spin mechanism.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 问题出在*第二步*。由于我们阻塞了执行，我们阻塞了旋转机制。
- en: When you make a node spin, what’s happening? As mentioned previously, the node
    will be kept alive and all callbacks can be processed. However, the spin is working
    in a single thread. This means that if you have one callback taking 5 seconds
    to execute, it will block the following callbacks for 5 seconds.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使一个节点旋转时，会发生什么？如前所述，节点将被保持活跃，所有回调都可以被处理。然而，旋转是在单个线程中工作的。这意味着如果你有一个回调需要5秒钟来执行，它将阻塞接下来的回调5秒钟。
- en: We never had any issues before because all the callbacks we wrote were very
    quick to execute. However, with the execute callback for an action, we’re in a
    situation where the execution could take quite some time, and thus block all the
    other callbacks.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前从未遇到过任何问题，因为我们编写的所有回调都非常快速地执行。然而，对于动作的执行回调，我们处于执行可能需要相当长时间的情况，因此会阻塞所有其他回调。
- en: That’s quite the problem. How can you ask to cancel a goal if the cancel request
    is only received after the goal’s execution has finished?
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是个问题。如果取消请求仅在目标执行完成后才被接收，你如何请求取消目标？
- en: 'To solve this problem, we have two possible solutions:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们有两个可能的解决方案：
- en: '**The classic programming way**: We could create a new thread in the execute
    callback. The callback can then exit while the goal is processed in the background.
    The spin continues, and thus, other callbacks can be called.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**经典编程方式**：我们可以在执行回调中创建一个新的线程。然后，回调可以退出，而目标在后台处理。这样，旋转继续，因此可以调用其他回调。'
- en: '**The ROS 2 way**: We can use a multi-threaded executor, which means that our
    spin mechanism will work not in a single thread, but in multiple threads. Thus,
    if one callback is blocking, you can still execute other callbacks—including the
    cancel callback.'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ROS 2的方式**：我们可以使用多线程执行器，这意味着我们的旋转机制将不在单个线程中工作，而是在多个线程中工作。因此，如果一个回调被阻塞，你仍然可以执行其他回调——包括取消回调。'
- en: Since we want to follow ROS 2 principles to stay consistent with other developers,
    we’re going to follow the ROS 2 way and solve that issue with a multi-threaded
    executor.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要遵循ROS 2原则以与其他开发者保持一致，我们将遵循ROS 2的方式，并使用多线程执行器来解决该问题。
- en: Note
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: I’m not going to go into more detail about single and multi-threaded executors
    here. I’m using them now so that we can implement the cancel mechanism correctly.
    Executors can be a great topic to explore after reading this book.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在这里详细介绍单线程和多线程执行器，我现在使用它们是为了正确实现取消机制。阅读完这本书后，执行器可以成为一个很好的探索主题。
- en: 'The process for the cancel mechanism in the server code will be the same for
    Python and C++:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器代码中取消机制的过程对于Python和C++将是相同的：
- en: Register a callback to handle cancel requests.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册一个回调来处理取消请求。
- en: Cancel the goal in the execute callback.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行回调中取消目标。
- en: Make the node spin with a multi-threaded executor.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用多线程执行器使节点旋转。
- en: Canceling with Python
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Python取消
- en: We will start with the server code, which can be found in **count_until_server.py**.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从服务器代码开始，该代码可以在**count_until_server.py**中找到。
- en: 'First, let’s register a callback to receive cancel requests:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们注册一个回调来接收取消请求：
- en: '[PRE50]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Here’s the callback’s implementation:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这是回调的实现：
- en: '[PRE51]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In this callback, you receive a goal handle corresponding to the goal the client
    wants to cancel. You can then create any kind of condition to decide whether the
    goal should be canceled or not. To accept, you must return **CancelResponse.ACCEPT**;
    to reject, you must return **CancelResponse.REJECT**. With this example, I kept
    things simple and we just accepted the cancel request without implementing any
    other checks.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个回调中，你将接收到一个与客户端想要取消的目标相对应的目标处理程序。然后你可以创建任何类型的条件来决定目标是否应该被取消。为了接受，你必须返回**CancelResponse.ACCEPT**；为了拒绝，你必须返回**CancelResponse.REJECT**。在这个例子中，我保持了简单，我们只是接受了取消请求而没有实现任何其他检查。
- en: 'Now, if the cancel request has been accepted, we need to do something about
    it. In the execute callback, while we’re executing the goal (inside the **for**
    loop), add the following code:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果取消请求已被接受，我们需要对此做出回应。在执行回调中，当我们正在执行目标（在**for**循环内部）时，添加以下代码：
- en: '[PRE52]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: When we accept a cancel request, an **is_cancel_requested** flag in the goal
    handle will be set to **True**. Now, in the execute callback, we simply need to
    check this flag.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们接受取消请求时，目标处理程序中的**is_cancel_requested**标志将被设置为**True**。现在，在执行回调中，我们只需要检查这个标志。
- en: What we do in the code is stop the current execution. If, for example, your
    action server controls the wheels of a robot, you could interpret **cancel** as
    “decelerate and stop moving,” “step on the side so we don’t block the main way,”
    or even “go back to base.” The way you handle the behavior for the cancellation
    depends on each application. Here, we just stop counting.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码中执行的操作是停止当前执行。例如，如果你的动作服务器控制机器人的轮子，你可以将**取消**解释为“减速并停止移动”，“走到一边以免阻塞主道”，或者甚至“返回基地”。你处理取消行为的方式取决于每个应用程序。在这里，我们只是停止计数。
- en: In the execute callback, you need to set the goal’s final state and return a
    result, even if you cancel the goal. Thus, we use the **canceled()** method to
    set the state, and we return a result that contains the last reached number. If
    the client asks the server to count to 10 and then cancels the goal when the counter
    is at 7, the result will contain 7.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行回调中，你需要设置目标的最终状态并返回一个结果，即使你取消了目标。因此，我们使用**canceled()**方法来设置状态，并返回包含最后达到的数字的结果。如果客户端要求服务器数到10然后当计数器在7时取消目标，结果将包含7。
- en: That’s it for the cancel mechanism. However, to make things work, as we’ve seen
    previously, we need to use a multi-threaded executor.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 取消机制就到这里。然而，为了使事情正常工作，正如我们之前看到的，我们需要使用多线程执行器。
- en: 'First, you’ll need to import the following:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要导入以下内容：
- en: '[PRE53]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: When using multi-threaded executors, we also need to use *callback groups*.
    Here, **ReentrantCallbackGroup** will allow all callbacks to be executed in parallel.
    This means that you can have several goal, cancel, and execute callbacks running
    at the same time for one action server.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用多线程执行器时，我们还需要使用**回调组**。在这里，**ReentrantCallbackGroup**将允许所有回调并行执行。这意味着你可以为同一个动作服务器同时运行多个目标、取消和执行回调。
- en: 'When you create the action server, add a **callback_group** argument:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建动作服务器时，添加一个**callback_group**参数：
- en: '[PRE54]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, modify the line to make the node spin in the **main()** function:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，修改**main()**函数中使节点旋转的行：
- en: '[PRE55]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: That’s all there is to it. It’s just a few lines of code, but adding this requires
    a good understanding of ROS 2 and its underlying mechanisms.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。这只是几行代码，但添加这些需要很好地理解 ROS 2 及其底层机制。
- en: 'Let’s write the code for the client so that we can send a cancel request for
    a goal that’s being executed. In **count_until_client.py**, add a method to cancel
    a goal:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写客户端的代码，以便我们可以发送取消正在执行的目标的请求。在 **count_until_client.py** 中添加一个取消目标的方法：
- en: '[PRE56]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Here, we’re using the goal handle that we saved in the goal response callback
    (**self.goal_handle_: ClientGoalHandle = future.result()**). From this goal handle
    object, we have access to a **cancel_goal_async()** method.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '这里，我们使用在目标响应回调中保存的目标处理程序（**self.goal_handle_: ClientGoalHandle = future.result()**）。从这个目标处理程序对象，我们可以访问一个
    **cancel_goal_async()** 方法。'
- en: 'So, where do we cancel the goal? This can be done from anywhere: from the feedback
    callback, an independent subscriber callback, and so on. It will depend on your
    application.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们在哪里取消目标？这可以在任何地方完成：从反馈回调、独立的订阅者回调等等。这取决于你的应用。
- en: To make a quick test, let’s arbitrarily decide that we want to cancel the goal
    if the **current_number** field from the feedback is greater than or equal to
    2\. It doesn’t make any sense (why would we ask to count until 5, only to cancel
    if the number reaches 2?), but it’s a quick way to test the cancel mechanism.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行快速测试，我们随意决定如果反馈中的 **current_number** 字段大于或等于 2，则取消目标。这没有任何意义（为什么我们要数到 5，然后当数字达到
    2 时取消？），但这是一种快速测试取消机制的方法。
- en: 'In the goal feedback callback, add the following code:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在目标反馈回调中添加以下代码：
- en: '[PRE57]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Then, build the package, source it, and run both the server and client. Here’s
    the log for the client:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，构建包，源代码，并运行服务器和客户端。以下是客户端的日志：
- en: '[PRE58]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'For the server, you will see this:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 对于服务器，你会看到以下内容：
- en: '[PRE59]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: With this, we used all the mechanisms available for actions. Now, you can comment
    the lines to cancel the goal from the feedback callback—this was just for testing
    purposes.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些机制，我们现在可以取消从反馈回调中取消目标的行——这只是为了测试目的。
- en: Canceling with C++
  id: totrans-396
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 C++ 取消
- en: In the server code (**count_until_server.cpp**), we added a cancel callback
    when we created the action server. This was mandatory so that the code could compile.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器代码（**count_until_server.cpp**）中，我们在创建动作服务器时添加了一个取消回调。这是强制性的，以便代码可以编译。
- en: 'In this callback, we just accept the cancel request:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个回调中，我们只是接受取消请求：
- en: '[PRE60]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Then, to handle the cancellation of the goal in the execute callback, add the
    following code to the **for** loop:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了在执行回调中处理目标的取消，将以下代码添加到 **for** 循环中：
- en: '[PRE61]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In C++, we check the **is_canceling()** method inside the goal handle. If it
    returns **true**, this means that a cancel request for this goal has been accepted,
    and we need to do something about it.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，我们在目标处理程序内部检查 **is_canceling()** 方法。如果它返回 **true**，这意味着已经接受了对该目标的取消请求，我们需要对此采取行动。
- en: We set the goal’s final state and result with **canceled()**, and we exit from
    the execute callback.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 **canceled()** 设置目标的最终状态和结果，并从执行回调中退出。
- en: That’s it for the cancel mechanism, but now we need to make the node spin with
    a multi-threaded executor.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 取消机制就到这里了，但现在我们需要使用多线程执行器使节点旋转。
- en: 'In the **main()** function, we must replace the **rclcpp::spin(node);** line
    with the following code:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **main()** 函数中，我们必须将 **rclcpp::spin(node);** 行替换为以下代码：
- en: '[PRE62]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Here, we create an executor, add the node, and make the executor spin. Then,
    as we did for Python, inside the node, we need to add a callback group. We can
    declare one as a private attribute:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们创建一个执行器，添加节点，并使执行器旋转。然后，就像我们对 Python 所做的那样，在节点内部，我们需要添加一个回调组。我们可以将其声明为一个私有属性：
- en: '[PRE63]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Finally, we modify the code in the node’s constructor to give a reentrant callback
    group to the action server, so that all callbacks can be executed in parallel:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们修改节点构造函数中的代码，给动作服务器提供一个可重入的回调组，这样所有回调都可以并行执行：
- en: '[PRE64]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We also need to add **rcl_action_server_get_default_options()** after the callbacks
    and before the callback group; otherwise, the compiler will complain about not
    finding an overload for the **create_server()** function.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在回调之后和回调组之前添加 **rcl_action_server_get_default_options()**；否则，编译器会抱怨找不到
    **create_server()** 函数的重载。
- en: 'Now that we’ve finished writing the server code, let’s send a cancel request
    from the client. In **count_until_client.cpp**, add a **cancelGoal()** method:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了服务器代码的编写，让我们从客户端发送取消请求。在 **count_until_client.cpp** 中添加一个 **cancelGoal()**
    方法：
- en: '[PRE65]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In C++, we cancel goals from the action client, not from the goal handle. To
    make things simpler here, we’re canceling all goals that could have been sent
    by this client.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，我们从动作客户端而不是从目标处理程序取消目标。为了使事情更简单，我们在这里取消所有可能由该客户端发送的目标。
- en: 'To test the cancel mechanism, we add those lines to the feedback callback:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试取消机制，我们将这些行添加到反馈回调中：
- en: '[PRE66]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Once you’ve completed the code, run your C++ action client and server nodes.
    You can also try any combination of Python and C++ nodes; they should behave the
    same way. Once you’ve tested your code, comment the lines to cancel the goal from
    the feedback callback.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 代码编写完成后，运行您的 C++ 行动客户端和服务器节点。您也可以尝试任何 Python 和 C++ 节点的组合；它们应该表现相同。测试完代码后，注释掉这些行以取消反馈回调中的目标。
- en: Let’s finish this chapter with a few more command-line tools that will help
    you when you’re developing applications with actions.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一些将帮助您在开发使用动作的应用程序时使用的更多命令行工具来结束这一章。
- en: Additional tools to handle actions
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理动作的附加工具
- en: 'Since actions are part of the core ROS 2 functionalities, they also get their
    own command-line tool: **ros2 action**.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 由于动作是 ROS 2 核心功能的一部分，它们也有自己的命令行工具：**ros2 action**。
- en: In this section, we’ll learn how to introspect actions, send a goal from the
    Terminal, and change an action name at runtime.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何检查动作、从终端发送目标以及在实际运行时更改动作名称。
- en: To see all the possible commands, type **ros2** **action -h**.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有可能的命令，键入 **ros2** **action -h**。
- en: Listing and introspecting actions
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出和检查动作
- en: Actions are based on topics and services. Since **rqt_graph** doesn’t support
    services (for now), we could see the topics for an action server and client, but
    that’s about it. Thus, **rqt_graph** won’t be very useful for introspecting actions.
    Because of this, we will use the **ros2** command-line tool here.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 动作基于主题和服务。由于 **rqt_graph** 目前不支持服务，我们可以看到动作服务器和客户端的主题，但仅此而已。因此，**rqt_graph**
    在检查动作时不会非常有用。因此，我们将在这里使用 **ros2** 命令行工具。
- en: Let’s learn how to find existing actions and how to get the interface for one
    action.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何查找现有动作以及如何获取一个动作的接口。
- en: 'Stop all nodes and start the **count_until_server** node (Python or C++ one).
    Then, list all available actions by running the following command:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 停止所有节点并启动 **count_until_server** 节点（Python 或 C++）。然后，运行以下命令列出所有可用的动作：
- en: '[PRE67]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Here, we found the **/count_until** action. As we’ve seen with topics and services,
    if you don’t provide any namespace for the name (we wrote **count_until** in the
    server code), a leading slash will be added automatically.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们找到了 **/count_until** 动作。正如我们通过主题和服务所看到的，如果您没有为名称提供任何命名空间（我们在服务器代码中写了 **count_until**），将自动添加一个前导斜杠。
- en: From this action name, we can get more information, including the action interface.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个动作名称，我们可以获取更多信息，包括动作接口。
- en: 'Run **ros2 action info <****action_name> -t**:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 **ros2 action info <****action_name> -t**：
- en: '[PRE68]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: From this, we can see that the action server is hosted in the **count_until_server**
    node, and we also find the action interface. For **ros2 action info** to show
    the interface, don’t forget to add **-t**; otherwise, you’ll just see the node’s
    name.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个结果中，我们可以看到动作服务器托管在 **count_until_server** 节点中，我们还找到了动作接口。为了使 **ros2 action
    info** 显示接口，别忘了添加 **-t**；否则，您只会看到节点的名称。
- en: 'Finally, we can get the interface:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以获取接口：
- en: '[PRE69]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This process is the same as what we followed for services. Now that we know
    the action name and interface, we can try the service directly from the Terminal.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程与我们对服务的处理过程相同。现在我们知道动作名称和接口，我们可以直接从终端尝试服务。
- en: Sending a goal from the Terminal
  id: totrans-436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从终端发送目标
- en: If you write a service server and want to try it before writing the action client,
    you can use the **ros2 action send_goal** command line.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您编写了一个服务服务器并想在编写动作客户端之前尝试它，您可以使用 **ros2 action send_goal** 命令行。
- en: 'The complete command is **ros2 action send_goal <action_name> <action_interface>
    "<goal_in_json>"**. You can also add **--feedback** after the command to receive
    the (optional) feedback from the server. Let’s try it out:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的命令是 **ros2 action send_goal <action_name> <action_interface> "<goal_in_json>"**。您也可以在命令后添加
    **--feedback** 以接收来自服务器的（可选）反馈。让我们试试看：
- en: '[PRE70]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'You will get the following result:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到以下结果：
- en: '[PRE71]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This command is very useful for developing action servers. However, it will
    only work well for actions for which the goal is simple. Here, we only have an
    integer number and a double number. If the goal contains an array of 20 3D points,
    you will spend more time trying to write the command correctly than implementing
    an action client. In this case, to go faster, use the action client we’ve written
    in this chapter as a template.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令对于开发动作服务器非常有用。然而，它只适用于目标简单的动作。在这里，我们只有一个整数和一个双精度数。如果目标包含一个由 20 个 3D 点组成的数组，你将花费更多的时间来正确编写命令，而不是实现动作客户端。在这种情况下，为了更快地完成，可以使用本章中编写的动作客户端作为模板。
- en: Topics and services inside actions
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动作内部的话题和服务
- en: 'By default, with **ros2 topic list** and **ros2 service list**, you won’t see
    the two topics and three services inside the action. However, they do exist—you
    just have to add **--include-hidden-topics** and **--****include-hidden-services**,
    respectively:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，使用 **ros2 topic list** 和 **ros2 service list**，你不会看到动作内部的两个话题和三个服务。然而，它们确实存在——你只需要分别添加
    **--include-hidden-topics** 和 **--include-hidden-services**：
- en: '[PRE72]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: With that, we’ve found all the topics and services that are being used. You
    can explore these a bit more by yourself by using the other **ros2 topic** and
    **ros2 service** command lines.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经找到了正在使用的话题和服务。你可以通过使用其他 **ros2 topic** 和 **ros2 service** 命令行来更深入地探索这些内容。
- en: 'Now, there’s one thing we’ve done for nodes, topics, and services: we’ve changed
    the name at runtime. For some reason, this feature isn’t available for actions
    yet. As a workaround, you can still do this by renaming the two topics and three
    services when you start the action server:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经为节点、话题和服务做了一件事：我们在运行时更改了名称。由于某种原因，这个特性目前还不能用于动作。作为替代方案，你仍然可以在启动动作服务器时重命名两个话题和三个服务：
- en: '[PRE73]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: With this, the action will be renamed **/count_until1**. The command is a bit
    ugly and prone to errors, but when we start nodes using launch files in [*Chapter
    9*](B22403_09.xhtml#_idTextAnchor443), in the *Configuring nodes inside a launch
    file* section, this won’t be a problem.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，动作将被重命名为 **/count_until1**。命令有点丑陋且容易出错，但当我们使用第 9 章 [*配置启动文件内的节点*](B22403_09.xhtml#_idTextAnchor443)
    中的启动文件启动节点时，这不会成为问题。
- en: With that, we’ve come to the end of this chapter. I haven’t added any challenges
    here as I think that this chapter itself is a big enough challenge. I would prefer
    you to spend your time continuing with the other concepts in this book instead
    of being stuck too long on actions, especially if you’re just getting started
    with ROS.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们来到了本章的结尾。我没有在这里添加任何挑战，因为我认为本章本身就是一个很大的挑战。我更愿意你花时间继续学习这本书中的其他概念，而不是长时间地停留在动作上，尤其是如果你是刚开始使用
    ROS。
- en: Summary
  id: totrans-451
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'In this chapter, you worked on ROS 2 actions. You created various actions to
    solve a problem that services don’t handle well: when the server may take some
    time to execute the request.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了 ROS 2 动作。你创建了各种动作来解决服务处理不好的问题：当服务器可能需要一些时间来执行请求时。
- en: With actions, you can properly handle this case. While the goal is being executed,
    you can get some feedback from the server, or even decide to cancel the goal.
    Also, you could handle several goals at the same time, queue them, replace one
    with another one, and so on (we haven’t seen this in this chapter as it’s something
    you can look into if you want to develop your skills further).
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 使用动作，你可以正确地处理这种情况。在目标执行过程中，你可以从服务器获取一些反馈，甚至可以决定取消目标。此外，你还可以同时处理多个目标，排队，用一个替换另一个，等等（我们在这章中没有看到这一点，但如果你想要进一步提高你的技能，你可以深入研究）。
- en: You can implement action servers and clients in your code using the **rclpy.action**
    library for Python and the **rclcpp_action** library for C++.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Python 的 **rclpy.action** 库和 C++ 的 **rclcpp_action** 库在你的代码中实现动作服务器和客户端。
- en: 'Here are the main steps for writing an action server:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是编写动作服务器的主要步骤：
- en: Since we’re on the server side, we must choose the action name and interface.
    Usually, for an action, you will have to create a custom interface (in a dedicated
    package).
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们在服务器端，我们必须选择动作名称和接口。通常，对于动作，你将不得不创建一个自定义接口（在一个专门的包中）。
- en: 'Then, you must import the interface into your code and create an action server
    in the constructor. Here, you will register three callback methods:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你必须将接口导入到你的代码中，并在构造函数中创建一个动作服务器。在这里，你将注册三个回调方法：
- en: '**Goal callback**: When the server receives a goal, choose whether to accept
    or reject it.'
  id: totrans-458
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标回调**：当服务器收到一个目标时，选择是否接受或拒绝它。'
- en: '**Execute callback**: After a goal has been accepted, you can execute it. During
    the execution of the goal, you can also publish optional feedback.'
  id: totrans-459
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行回调**：在目标被接受后，您可以执行它。在执行目标的过程中，您还可以发布可选的反馈。'
- en: '**Cancel callback (optional mechanism)**: If you receive a cancel request,
    you can accept or reject it. If accepted, you will have to cancel the current
    goal execution.'
  id: totrans-460
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**取消回调（可选机制）**：如果您收到取消请求，您可以接受或拒绝它。如果接受，您将不得不取消当前目标执行。'
- en: 'To write an action client, you must follow these steps:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写动作客户端，您必须遵循以下步骤：
- en: Find which name and interface you need to use so that you can communicate with
    the server.
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出您需要使用的名称和接口，以便您可以与服务器通信。
- en: Import the interface into your code and create an action client in the constructor.
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将接口导入到您的代码中，并在构造函数中创建一个动作客户端。
- en: 'Add a method to send a goal. After you send a goal, you will have to write
    several callbacks:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个发送目标的方法。在您发送目标后，您将不得不编写几个回调：
- en: '**Goal response callback**: You will know whether the goal has been accepted
    or rejected by the server.'
  id: totrans-465
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标响应回调**：您将知道服务器是否接受或拒绝了目标。'
- en: '**Goal result callback**: After the goal has been executed by the server, you
    will get the result and the goal’s final state here.'
  id: totrans-466
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标结果回调**：在服务器执行目标后，您将在这里获得结果和目标最终状态。'
- en: '**Feedback callback (optional)**: If the server publishes any feedback, you
    can receive it here.'
  id: totrans-467
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反馈回调（可选）**：如果服务器发布任何反馈，您可以在这里接收它。'
- en: Finally, from anywhere in the code, you can decide to cancel the execution of
    a currently active goal.
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您可以从代码的任何位置决定取消当前活动目标的执行。
- en: On top of all that, with the **ros2 action** command line, you can introspect
    your actions and send goals directly from the Terminal. Also, since actions are
    based on topics and services, you can introspect each underlying communication
    with **ros2 topic** and **ros2** **service**, respectively.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些之上，使用 **ros2 action** 命令行，您可以检查您的动作并直接从终端发送目标。此外，由于动作基于主题和服务，您可以使用 **ros2
    topic** 和 **ros2 service** 分别检查每个底层通信。
- en: Now, if you managed to get here while reading this book for the first time,
    congratulations—this chapter is probably one of the most difficult to follow.
    If you’re still wondering what I was talking about the whole time, don’t worry—you
    can come back to actions later once you’ve finished this book and become more
    experienced with ROS.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您在第一次阅读这本书时就已经成功到达这里，恭喜您——这一章可能是最难理解的章节之一。如果您还在想我一直在说什么，请不要担心——您可以在完成这本书并更熟悉
    ROS 后，稍后再回来学习动作。
- en: We’re now done with the three types of communication in ROS 2\. In the next
    chapter, we will go back to a more beginner level and continue to work on nodes.
    This time, we will learn how to customize nodes when we start them so that we
    can make our application more dynamic.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了 ROS 2 中的三种通信类型。在下一章中，我们将回到更基础的级别，并继续处理节点。这次，我们将学习如何在启动节点时自定义它们，以便使我们的应用程序更加动态。
