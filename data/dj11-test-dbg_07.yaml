- en: 'Chapter 7. When the Wheels Fall Off: Understanding a Django Debug Page'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。当车轮脱落：理解Django调试页面
- en: Just about the last thing you want when your code is running in production is
    for it to encounter an error so severe that the only message that can be returned
    to the client is "We're sorry, the server has encountered an error, please try
    again later." During development, however, these server error situations are among
    the best of the bad outcomes. They generally indicate an exception has been raised,
    and when that happens there is a wealth of information available to figure out
    what has gone wrong. When `DEBUG` is on, this information is returned, in the
    form of a Django debug page, as the response to the request that caused the error.
    In this chapter, we will learn how to understand and make use of the information
    provided by a Django debug page.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的代码在生产中运行时，您最不希望发生的事情之一就是遇到一个错误，这个错误严重到只能向客户端返回“对不起，服务器遇到了一个错误，请稍后再试”的消息。然而，在开发过程中，这些服务器错误情况是最糟糕的结果之一。它们通常表示已经引发了异常，当发生这种情况时，有大量信息可用于弄清楚出了什么问题。当`DEBUG`打开时，这些信息以Django调试页面的形式返回，作为导致错误的请求的响应。在本章中，我们将学习如何理解和利用Django调试页面提供的信息。
- en: 'Specifically, in this chapter we will:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，在本章中我们将：
- en: Continue development of the example survey application, making some typical
    mistakes along the way
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续开发示例调查应用程序，沿途犯一些典型的错误
- en: See how these mistakes manifest themselves in the form of Django debug pages
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看这些错误如何在Django调试页面的形式中表现出来
- en: Learn what information is provided on these debug pages
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解这些调试页面提供了哪些信息
- en: For each mistake, dig into the information available on the resulting debug
    page to see how it can be used to understand the error and determine how to fix
    it
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个错误，深入研究生成的调试页面上可用的信息，看看它如何被用来理解错误并确定如何修复它
- en: Starting the Survey voting implementation
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始调查投票实施
- en: 'In [Chapter 4](ch04.html "Chapter 4. Getting Fancier: Django Unit Test Extensions"),
    *Getting Fancier: Django Unit Test Extensions*, we began developing code to serve
    pages for the `survey` application. We implemented the home page view. This view
    generates a page that lists both active and recently closed surveys and provides
    links, as appropriate, to either take an active survey or display results from
    a closed survey. Both of these kinds of links route to the same view function,
    `survey_detail`, which further routes the request based on the state of the `Survey`
    for which details have been requested:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。变得更加花哨：Django单元测试扩展")中，*变得更加花哨：Django单元测试扩展*，我们开始开发代码为`survey`应用程序提供页面。我们实现了主页视图。这个视图生成一个页面，列出了活动和最近关闭的调查，并根据需要提供链接，以便参加活动调查或显示关闭调查的结果。这两种链接都路由到同一个视图函数`survey_detail`，该函数根据所请求的`Survey`的状态进一步路由请求：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We did not then, however, write the code to actually display an active `Survey`
    or display results from a `Survey`. Rather we created placeholder views and templates
    that simply state what the pages are eventually intended to show. For example,
    the `display_active_survey` function was left simply as:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们并没有编写代码来实际显示一个活动的`Survey`或显示`Survey`的结果。相反，我们创建了占位符视图和模板，只是简单地说明了这些页面最终打算显示的内容。例如，`display_active_survey`函数仅保留为：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The template it references, `active_survey.html`, contains:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 它引用的模板`active_survey.html`包含：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We will now pick up where we left off here and start replacing this placeholder
    view and template with real code that handles displaying an active `Survey`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将从上次离开的地方继续，并开始用处理显示活动“调查”的真实代码替换这个占位符视图和模板。
- en: What's involved in doing this? First, when a request comes in to display an
    active survey, we want to return a page that displays the list of questions in
    the `Survey`, each with their associated possible answers. Furthermore, we want
    to present these in a manner so that the user can participate in the `Survey`,
    and submit their chosen answers for the questions. Thus, we will need to present
    the question and answer data in an HTML form, and also have code on the server
    that handles receiving, validating, recording, and responding to posted `Survey`
    responses.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要什么？首先，当请求显示一个活动调查时，我们希望返回一个页面，显示`Survey`中的问题列表，每个问题都有其相关的可能答案。此外，我们希望以一种方式呈现这些问题和答案数据，以便用户可以参与`Survey`，并提交他们选择的问题答案。因此，我们需要以HTML表单的形式呈现问题和答案数据，并且还需要在服务器上编写代码，处理接收、验证、记录和响应发布的`Survey`响应。
- en: All of that is a lot to tackle at once. What is the smallest piece we can implement
    first that will allow us to start experimenting and verifying that we are moving
    in the right direction? We'll start with the display of a form that allows users
    to see a single question and choose from among its associated answers. First,
    though, let's get our development database set up with some reasonable test data
    to work with.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切一次性解决起来很多。我们可以先实现哪个最小的部分，以便我们开始实验并验证我们是否朝着正确的方向前进？我们将从显示一个允许用户查看单个问题并从其相关答案中选择的表单开始。不过，首先让我们在开发数据库中设置一些合理的测试数据来使用。
- en: Creating test data for voting
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为投票创建测试数据
- en: 'As it''s been a while since we were working with these models, we may no longer
    have any active surveys. Let''s start with a clean slate by running `manage.py
    reset survey`. Then, ensure the development server is running and use the admin
    application to create a new `Survey`, `Question`, and `Answers`. This is the `Survey`
    that will be used in the upcoming examples:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经有一段时间没有使用这些模型了，我们可能不再有任何活动调查。让我们通过运行`manage.py reset survey`来从头开始。然后，确保开发服务器正在运行，并使用管理应用程序创建一个新的`Survey`，`Question`和`Answers`。这是即将到来的示例中将使用的`Survey`：
- en: '![Creating test data for voting](img/7566_07_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![为投票创建测试数据](img/7566_07_01.jpg)'
- en: 'The `Answers` defined for the one `Question` in this `Survey` are:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为这个`Survey`中的一个`Question`定义的`Answers`是：
- en: '![Creating test data for voting](img/7566_07_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![为投票创建测试数据](img/7566_07_02.jpg)'
- en: That's enough to get started with. We can come back later and add more data
    as necessary. Now, we will move on to developing the form used to display a `Question`
    and choose one of its answers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这就足够开始了。我们可以随后返回并根据需要添加更多数据。现在，我们将继续开发用于显示一个`Question`并选择其答案的表单。
- en: Defining a question form for voting
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为投票定义问题表单
- en: 'The Django `forms` package provides a convenient framework for creating, displaying,
    validating, and processing HTML form data. Within the forms package, the `ModelForm`
    class is often useful for automatically building forms that represent models.
    We might initially think that using a `ModelForm` would come in handy for our
    task here, but a `ModelForm` would not provide what we need. Recall that the `survey`
    application `Question` model contains these fields:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Django的`forms`包提供了一个方便的框架，用于创建、显示、验证和处理HTML表单数据。在forms包中，`ModelForm`类通常用于自动构建代表模型的表单。我们可能最初认为使用`ModelForm`会对我们的任务有所帮助，但`ModelForm`不会提供我们所需要的。回想一下，`survey`应用程序`Question`模型包含这些字段：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Further, the `Answer` model is:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Answer`模型是：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A `ModelForm` contains HTML input fields for each field defined in the model.
    Thus, a `ModelForm` for the `Question` model would consist of a text input allowing
    the user to change the content of the `question` field, and a selection box allowing
    the user to select which `Survey` instance this `Question` is associated with.
    That's not at all what we want. Nor is a `ModelForm` built from the `Answer` model
    what we are looking for.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`ModelForm`包含模型中每个字段的HTML输入字段。因此，`Question`模型的`ModelForm`将包括一个文本输入，允许用户更改`question`字段的内容，并包括一个选择框，允许用户选择与之关联的`Survey`实例。这并不是我们想要的。从`Answer`模型构建的`ModelForm`也不是我们要找的。'
- en: Rather, we want a form that will display the text of the `question` field (but
    not allow the user to change that text), along with all of the `Answer` instances
    associated with the `Question` instance, in a manner that allows the user to select
    exactly one of the listed answers. That sounds like an HTML radio input group
    where the individual radio button values are defined by the set of `Answers` associated
    with the `Question` instance.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们想要一个表单，它将显示`question`字段的文本（但不允许用户更改该文本），以及与`Question`实例关联的所有`Answer`实例，以一种允许用户精确选择列出的答案之一的方式。这听起来像是一个HTML单选输入组，其中单选按钮的值由与`Question`实例关联的`Answers`集合定义。
- en: 'We can create a custom form to represent this, using the basic form field and
    widget classes provided by Django. Let''s create a new file, `survey/forms.py`,
    and put in it an initial attempt at implementing the form that will be used to
    display a `Question` and its associated answers:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个自定义表单来表示这一点，使用Django提供的基本表单字段和小部件类。让我们创建一个新文件，`survey/forms.py`，并在其中尝试实现将用于显示`Question`及其关联答案的表单：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This form is named `QuestionVoteForm` and has only one field, `answer`, which
    is a `ModelChoiceField`. This type of field allows selection from a set of choices
    defined by a `QuerySet`, specified by its `queryset` attribute. Since the correct
    set of answers for this field will depend on the specific `Question` instance
    for which the form is built, we omit specifying a `queryset` on the field declaration
    and set it later, in the `__init__` routine. We do, however, specify in the field
    declaration that we want to use a `RadioSelect` widget for display, instead of
    the default `Select` widget (which presents the choices in an HTML select drop-down
    box).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表单名为`QuestionVoteForm`，只有一个字段`answer`，它是一个`ModelChoiceField`。这种类型的字段允许从`QuerySet`定义的一组选择中进行选择，由其`queryset`属性指定。由于此字段的正确答案集将取决于构建表单的特定`Question`实例，因此我们在字段声明中省略了指定`queryset`，并在`__init__`例程中设置它。但是，我们在字段声明中指定，我们要使用`RadioSelect`小部件进行显示，而不是默认的`Select`小部件（它在HTML选择下拉框中呈现选择）。
- en: Following the declaration for the single `answer` field, the form defines an
    override for the `__init__` method. This `__init__` requires that a `question`
    argument be passed in when creating an instance of the form. After first calling
    the `__init__` superclass with whatever other arguments may have been provided,
    the passed `question` is used to set the `queryset` attribute for the `answer`
    field to be the set of answers that are associated with this `Question` instance.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个`answer`字段的声明之后，该表单定义了`__init__`方法的覆盖。这个`__init__`要求在创建表单实例时传入一个`question`参数。在首先使用可能提供的其他参数调用`__init__`超类之后，传递的`question`用于将`answer`字段的`queryset`属性设置为与此`Question`实例关联的答案集。
- en: 'In order to see if this form displays as intended, we need to create one of
    these forms in the `display_active_survey` function and pass it to the template
    for display. For now, we do not want to worry about displaying a list of questions;
    we''ll just pick one to pass to the template. So, we can change `display_active_survey`
    to be:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看这个表单是否按预期显示，我们需要在`display_active_survey`函数中创建一个这样的表单，并将其传递给模板进行显示。现在，我们不想担心显示问题列表；我们只会选择一个传递给模板。因此，我们可以将`display_active_survey`更改为：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now this function creates an instance of a `QuestionVoteForm` for the first
    question in the set of questions for the specified survey, and passes that form
    along to the template for rendering as the context variable `qvf`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个函数为指定调查的一组问题中的第一个问题创建了一个`QuestionVoteForm`的实例，并将该表单传递给模板以作为上下文变量`qvf`进行渲染。
- en: 'We also need to modify the template to display the passed form. To do this,
    change the `active_survey.html` template to be:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改模板以显示传递的表单。为此，请将`active_survey.html`模板更改为：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here we have added the necessary HTML elements to surround the Django form and
    make it a valid HTML form. We've used the form `as_p` method for display, just
    because it is easy. Long-term, we will likely replace that with custom output,
    but displaying the form in an HTML paragraph element will do for the present.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经添加了必要的HTML元素来包围Django表单，并使其成为有效的HTML表单。我们使用了`as_p`方法来显示表单，只是因为它很容易。长期来看，我们可能会用自定义输出来替换它，但是在目前，将表单显示在HTML段落元素中就足够了。
- en: Now, we are hopefully at a point where we can test and see whether our `QuestionVoteForm`
    displays what we want it to. We will try that next.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们希望能够测试并查看我们的`QuestionVoteForm`是否显示我们想要的内容。我们接下来会尝试。
- en: 'Debug page #1: TypeError at /'
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试页面＃1：/处的TypeError
- en: 'In order to see how the `QuestionVoteForm` is looking so far, we can first
    go to the survey home page and from there we should be able to click on the link
    for the one active survey we have, and see how the question and answer choices
    are displayed. How well does that work? Not so well. With the code changes we
    have made, we can no longer even display the home page. Instead, attempting to
    access it produces a debug page:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看`QuestionVoteForm`目前的样子，我们可以先转到调查主页，然后从那里我们应该能够点击我们拥有的一个活动调查的链接，看看问题和答案选择是如何显示的。效果如何？并不好。由于我们所做的代码更改，我们甚至无法显示主页。相反，尝试访问它会产生一个调试页面：
- en: '![Debug page #1: TypeError at /](img/7566_07_03.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![调试页面＃1：/处的TypeError](img/7566_07_03.jpg)'
- en: Yikes, that looks bad. Before we dig into the details of what the page is showing,
    let's try to understand what has happened here. We added a new form, and we changed
    the view used to display active surveys so that it creates one of the newly-defined
    forms. We also changed the template used by that view. But we did not change the
    home page view at all. So how could it now be broken?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 天啊，看起来很糟糕。在我们深入了解页面显示的细节之前，让我们先试着理解这里发生了什么。我们添加了一个新的表单，并且更改了用于显示活动调查的视图，以便创建新定义的表单之一。我们还更改了该视图使用的模板。但我们并没有改变主页视图。那么它怎么会出错呢？
- en: The answer is that the home page view itself is not broken, but something else
    is. That broken something else is preventing the home page view from even being
    called. Note that in order to call the home page view, the module that contains
    it (`survey.views`) must be imported without error. Thus, `survey.views` itself
    and anything it references when it is imported must be error-free. Even if nothing
    in the home page view, or even all of `survey.views`, is broken, an error may
    be raised on an attempt to call the home page view if an error has been introduced
    into any module imported as a result of importing `survey.views`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是主页视图本身并没有出错，但其他地方出了问题。这个出错的其他地方阻止了主页视图的调用。请注意，为了调用主页视图，包含它的模块（`survey.views`）必须被无错误地导入。因此，`survey.views`本身以及在导入时它引用的任何内容都必须是无错误的。即使主页视图中没有任何错误，甚至整个`survey.views`都没有问题，如果在导入`survey.views`的过程中引入了任何模块的错误，那么在尝试调用主页视图时可能会引发错误。
- en: The point is that changes made in one place may cause initially surprising breakage
    in what seems to be an entirely unrelated area. In fact, the other area is not
    entirely unrelated, but is somehow (usually via a chain of imports) connected
    to the area where the change was made. It is important in cases like this to focus
    attention on the right place in order to find and fix the error.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是，在一个地方做出的改变可能会导致最初令人惊讶的故障，而这似乎是完全无关的领域。实际上，另一个领域并不是完全无关的，而是以某种方式（通常通过一系列的导入）与做出改变的领域相连接。在这种情况下，重点放在正确的地方以找到并修复错误是很重要的。
- en: In this case, for example, staring blankly at the home page view code, because
    that is the code we were attempting to run, and trying to figure out what is wrong
    with it, would be fruitless. That is not where the problem is. Rather, we need
    to put aside any preconceived ideas we have about what code might have been running
    at the time of the error, and use the debug information presented to figure out
    what code was actually running. It can also be instructive to figure out why one
    bit of code ends up running when we were trying to run something else entirely,
    although it is not always necessary to do that in order to fix the problem at
    hand.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，例如，盯着主页视图代码发呆是没有用的，因为那是我们试图运行的代码，试图弄清楚问题出在哪里也是徒劳的。问题并不在那里。相反，我们需要放下我们对可能在错误发生时运行的代码的任何先入为主的想法，并利用呈现的调试信息来弄清楚实际运行的代码是什么。弄清楚为什么一部分代码最终运行了，而我们本来想运行的是另一些代码，也是有益的，尽管不总是必要的来解决手头的问题。
- en: Elements of the debug page
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试页面的元素
- en: Now let's turn our attention to the debug page we've encountered. There is quite
    a lot of information on it, split into four parts (only the first and beginning
    of the second are visible in the screenshot). In this section, we focus on what
    information, in general, is included in each part of the debug page, noting the
    values we see on this page simply as examples. Later in the chapter, we will see
    how the specific information presented on this debug page can be used to fix the
    error we have made.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们把注意力转向我们遇到的调试页面。页面上有很多信息，分成四个部分（截图中只能看到第一个部分和第二个部分的开头）。在本节中，我们重点关注调试页面的每个部分中通常包含的信息，注意我们在这个页面上看到的值只是作为示例。在本章的后面，我们将看到如何使用这个调试页面上呈现的具体信息来修复我们所犯的错误。
- en: Basic error information
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本错误信息
- en: The very top part of the debug page contains basic error information. Both the
    page title and the first line of the page body state the type of exception encountered,
    and the URL path contained in the request that triggered the exception. In our
    case, the type of exception is a **TypeError**, and the URL path is **/**. So,
    we see **TypeError at /** as the first line on the page.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 调试页面的顶部包含基本的错误信息。页面标题和页面正文的第一行都说明了遇到的异常类型，以及触发异常的请求中包含的URL路径。在我们的情况下，异常类型是**TypeError**，URL路径是**/**。因此，我们在页面上看到**TypeError
    at /**作为第一行。
- en: The second line contains the exception value. This is usually a specific description
    of what caused the error. In this case, we see **__init__() takes at least 2 non-keyword
    arguments (1 given)**.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行包含异常值。这通常是对导致错误的具体描述。在这种情况下，我们看到__init__()至少需要2个非关键字参数（给定1个）。
- en: 'Following the exception value is a list of nine items:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在异常值之后是一个包含九个项目的列表：
- en: '**Request Method**: The HTTP method specified in the request. In this case,
    it is **GET**.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求方法：请求中指定的HTTP方法。在这种情况下，它是GET。
- en: '**Request URL**: The full URL of the request. In this case it is **http://localhost:8000/**.
    The path part of this is a repeat of the path reported on the first line.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求URL：请求的完整URL。在这种情况下，它是http://localhost:8000/。其中的路径部分是第一行报告的路径的重复。
- en: '**Exception Type**: This is a repeat of the exception type included on the
    first line.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常类型：这是在第一行包括的异常类型的重复。
- en: '**Exception Value**: This is a repeat of the exception value included on the
    second line.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常值：这是在第二行包括的异常值的重复。
- en: '**Exception Location**: The line of code where the exception occurred. In this
    case, it is **/dj_projects/marketr/survey/forms.py in QuestionVoteForm, line 3**.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常位置：异常发生的代码行。在这种情况下，它是/dj_projects/marketr/survey/forms.py中的QuestionVoteForm，第3行。
- en: '**Python Executable**: The Python executable running at the time of the error.
    In this case, it is **/usr/bin/python**. This information is usually only interesting
    if you are doing something like testing with different Python versions.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python可执行文件：发生错误时运行的Python可执行文件。在这种情况下，它是/usr/bin/python。除非您正在使用不同的Python版本进行测试，否则这些信息通常只是有趣的。
- en: '**Python Version**: This identifies the version of Python that is running.
    Again, this will often be uninteresting unless you are testing with different
    Python versions. However, it can be a very useful bit of information when looking
    at problems reported by other people, if there is any suspicion that the problem
    may be dependent on the Python version.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python版本：这标识正在运行的Python版本。同样，除非您正在使用不同的Python版本进行测试，否则这通常不会引起兴趣。但是，当查看其他人报告的问题时，如果有任何怀疑问题可能取决于Python版本，这可能是非常有用的信息。
- en: '**Python Path**: The full Python path in effect. This is most often useful
    when the exception type relates to an error importing something. It can also come
    in handy when multiple versions of an add-on package have been installed in different
    places. This, plus an incorrect path specification, can cause an unexpected version
    to be used, which might lead to an error. Having the full Python path in use available
    helps in tracking down what is going on in this type of situation.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python路径：实际生效的完整Python路径。当异常类型涉及导入错误时，这通常是最有用的。当安装了不同版本的附加包时，这也可能会派上用场。这加上不正确的路径规范可能会导致使用意外的版本，这可能会导致错误。有可用的完整Python路径有助于跟踪这种情况下发生的情况。
- en: '**Server time**: This shows the date, time, and time zone at the server when
    the exception occurred. This can be useful for any views that return time-dependent
    results.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器时间：这显示了异常发生时服务器的日期、时间和时区。这对于返回与时间相关的结果的任何视图都是有用的。
- en: The exception type, exception value, and exception location are the first things
    to look at when presented with a debug page. These three items reveal what went
    wrong, why, and where it happened. Often, that is all you will need to know in
    order to fix the problem. Sometimes though, this basic information alone is not
    enough to understand and fix the error. In such situations, it may be helpful
    to know how the code got to where it ultimately ran into trouble. For that, the
    next part of the debug page is useful.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当出现调试页面时，异常类型、异常值和异常位置是首先要查看的三个项目。这三个项目揭示了出了什么问题，为什么以及发生了什么地方。通常，这就是您需要了解的一切，以便解决问题。但有时，仅凭这些基本信息就不足以理解和解决错误。在这种情况下，了解代码最终运行到哪里可能会有所帮助。对于这一点，调试页面的下一部分是有用的。
- en: Traceback
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回溯
- en: The traceback portion of the debug page shows how the thread of control got
    to where it encountered the error. At the top, it starts with the outermost level
    of the code that was running to process the request, showing where it called the
    next level down, then where the next call was made, ultimately ending at the bottom
    with the line of code that caused the exception. Thus, it is often the very bottom
    of the traceback (not visible in the screenshot) that is most interesting, though
    at times the path taken by the code to get there is the key to understanding and
    fixing what went wrong.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 调试页面的回溯部分显示了控制线程如何到达遇到错误的地方。在顶部，它从运行以处理请求的代码的最外层级别开始，显示它调用了下一个更低级别，然后显示下一个调用是如何进行的，最终在底部以导致异常的代码行结束。因此，通常是回溯的最底部（在截图中不可见）最有趣，尽管有时代码走过的路径是理解和修复出了问题的关键。
- en: 'For each call level shown in the traceback, there are three pieces of information
    displayed: first the line of code is identified, then it is shown, and then there
    is a line with a triangle and the text **Local vars**.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在回溯中显示的每个调用级别，都显示了三个信息：首先标识代码行，然后显示它，然后有一行带有三角形和文本本地变量。
- en: For example, the first bit of information for the top level in the traceback
    on this debug page identifies the line of code as **/usr/lib/python2.5/site-packages/django/core/handlers/base.py
    in get_response**. This shows the file containing the code and the name of the
    function (or method or class) within that file where the code was executing.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在调试页面上回溯的顶层的第一部分信息标识了代码行为/usr/lib/python2.5/site-packages/django/core/handlers/base.py
    in get_response。这显示了包含代码的文件以及在该文件中执行代码的函数（或方法或类）的名称。
- en: 'Next is a line with a darker background that shows: **83\. request.path_info)**.
    That looks a little odd. The number on the left is the line number within the
    file, and on the right are the contents of that line. In this case the call statement
    spans multiple lines, and we''re seeing only the last line of the call, which
    is not very informative. All we can tell is that **request.path_info** is being
    passed as the last argument to something. It might be nice to see the other lines
    of code around this line, which would make it clearer what was being called. In
    fact we can do that, just by clicking on the line:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个背景较暗的带有**83\. request.path_info)**的行。这看起来有点奇怪。左边的数字是文件内的行号，右边是该行的内容。在这种情况下，调用语句跨越了多行，我们只看到了调用的最后一行，这并不是很有信息量。我们只能知道**request.path_info**作为最后一个参数传递给了某个东西。看到这一行周围的其他代码行可能会更好，这样会更清楚正在调用什么。事实上，我们可以通过单击该行来做到这一点：
- en: '![Traceback](img/7566_07_04.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![Traceback](img/7566_07_04.jpg)'
- en: Aha! Now, we can see that something named **resolver.resolve** was being called
    and passed **request.path_info**. Clearly the code at this level is starting with
    the requested path and trying to determine what code should be called to handle
    the current request.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 啊哈！现在，我们可以看到有一个名为**resolver.resolve**的东西被调用并传递了**request.path_info**。显然，这个级别的代码是从请求的路径开始，并尝试确定应调用什么代码来处理当前请求。
- en: Clicking again anywhere within the displayed code will toggle the display of
    the surrounding code context back to the hidden state, so that only one line is
    displayed. Often, it's not necessary to see the surrounding code in the traceback,
    which is why it is hidden initially. But when it is helpful to see more, it is
    convenient that more context is just a click away.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 再次单击显示的代码的任何位置将切换周围代码上下文的显示状态，使得只显示一行。通常，不需要在回溯中看到周围的代码，这就是为什么它最初是隐藏的。但是当需要查看更多内容时，只需单击一下就很方便了。
- en: 'Local variables are contained in the third block of information displayed for
    each level of the traceback. These too are initially hidden, since they can take
    up quite a lot of space and clutter the page if they are displayed, making it
    hard to see at a glance what the flow of control was. Clicking on any **Local
    vars** line expands the block to show the list of local variables at that level
    and the value for each. For example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 本地变量包含在每个回溯级别显示的信息的第三个块中。这些变量最初也是隐藏的，因为如果它们被显示出来，可能会占用大量空间并且使页面混乱，从而很难一眼看清控制流是什么样的。单击任何**Local
    vars**行会展开该块，显示该级别的本地变量列表和每个变量的值。例如：
- en: '![Traceback](img/7566_07_05.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![Traceback](img/7566_07_05.jpg)'
- en: We do not need to fully understand the Django code running here in order to
    guess based on the names and values for the variables shown, that the code is
    trying to look up the view that handles displaying the home page. Clicking again
    on the **Local vars** line toggles the block back to being hidden.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要完全理解此处运行的Django代码，就可以根据显示的变量的名称和值猜测，代码正在尝试查找处理显示主页的视图。再次单击**Local vars**行会将该块切换回隐藏状态。
- en: 'There is one final very useful feature of the traceback section of the debug
    page. Right next to the **Traceback** heading is a link: **Switch to copy-and-paste
    view**. Clicking that link changes the traceback display into one that can be
    usefully copied and pasted elsewhere. For example on this page, clicking that
    link produces a text box that contains:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 调试页面的回溯部分还有一个非常有用的功能。在**Traceback**标题旁边有一个链接：**切换到剪切和粘贴视图**。单击该链接会将回溯显示切换为可以有用地复制和粘贴到其他地方的显示。例如，在本页上，单击该链接会产生一个包含以下内容的文本框：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, this block of information contains both the basic traceback
    plus some other useful information pulled from other sections on the debug page.
    It is far less complete than what is available on the full debug page, but it
    is often enough to get help from others when solving a problem. If you find you
    cannot solve a problem yourself and want to ask others for help, it is this information
    that you want to provide to others, not a screenshot of the debug page.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这一块信息包含了基本的回溯以及从调试页面的其他部分提取的一些其他有用信息。它远不及完整调试页面上提供的信息，但通常足以在解决问题时从他人那里获得帮助。如果您发现自己无法解决问题并希望向他人寻求帮助，那么您想要向他人提供的就是这些信息，而不是调试页面的截图。
- en: 'In fact, the cut-and-paste view itself has a button at the bottom: **Share
    this traceback on a public Web site**. If you press that button, the cut-and-paste
    version of the traceback information will be posted to the [dpaste.com](http://dpaste.com)
    site, and you will be taken to that site where you can either record the assigned
    URL for reference or delete the entry.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，剪切和粘贴视图本身底部有一个按钮：**在公共网站上共享此回溯**。如果您按下该按钮，回溯信息的剪切和粘贴版本将被发布到[dpaste.com](http://dpaste.com)网站，并且您将被带到该网站，在那里您可以记录分配的URL以供参考或删除该条目。
- en: 'Clearly this button will only work if your computer is connected to the Internet
    and can reach [dpaste.com](http://dpaste.com). If you try it and don''t have connectivity
    to that site, you''ll get an error reported by your browser that it is unable
    to connect to [dpaste.com](http://dpaste.com). Pressing the back button will return
    you to the debug page. [Chapter 10](ch10.html "Chapter 10. When All Else Fails:
    Getting Outside Help"), *When All Else Fails: Getting Outside Help*, will go into
    more detail on techniques for getting additional help with intractable problems.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，只有在您的计算机连接到互联网并且可以访问[dpaste.com](http://dpaste.com)时，此按钮才能正常工作。如果您尝试并且无法连接到该网站，您的浏览器将报告无法连接到[dpaste.com](http://dpaste.com)的错误。单击返回按钮将返回到调试页面。[第10章](ch10.html
    "第10章。当一切都失败时：寻求外部帮助")，*当一切都失败时：寻求外部帮助*，将更详细地介绍解决棘手问题时获取额外帮助的技巧。
- en: 'When clicked, the **Switch to copy-and-paste view** link is automatically replaced
    by another link: **Switch back to interactive view**. Thus, it is easy to toggle
    between the two forms of the traceback information.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 单击**切换到复制和粘贴视图**链接时，该链接会自动替换为另一个链接：**切换回交互视图**。因此，在回溯信息的两种形式之间切换很容易。
- en: Request information
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求信息
- en: Following the traceback information section on the debug page is detailed request
    information. Often you will not need to look at this section at all, but when
    an error is triggered by some odd characteristic of the request being processed,
    this section can be invaluable. It is split into five subsections, each described
    below.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试页面上的回溯信息部分之后是详细的请求信息。通常情况下，您不需要查看这个部分，但是当错误是由正在处理的请求的一些奇怪特征触发时，这个部分就非常有价值。它分为五个小节，每个小节都在下面描述。
- en: GET
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GET
- en: This section contains a list of all the keys and their values in the `request.GET`
    dictionary. Alternatively, if the request had no GET data, the string **No GET
    data** is displayed.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部分包含了`request.GET`字典中所有键和它们的值的列表。或者，如果请求没有GET数据，则显示字符串**没有GET数据**。
- en: POST
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: POST
- en: This section contains a list of all the keys and their values in the `request.POST`
    dictionary. Alternatively, if the request had no POST data, the string **No POST
    data** is displayed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部分包含了`request.POST`字典中所有键和它们的值的列表。或者，如果请求没有POST数据，则显示字符串**没有POST数据**。
- en: FILES
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件
- en: This section contains a list of all the keys and their values in the `request.FILES`
    dictionary. Note that the displayed information here is just the file name uploaded,
    not the actual file data (which could be quite large). Alternatively, if no file
    data was uploaded with the request, the string **No FILES data** is displayed.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部分包含了`request.FILES`字典中所有键和它们的值的列表。请注意，这里显示的信息只是上传的文件名，而不是实际的文件数据（这可能相当大）。或者，如果请求没有上传文件数据，则显示字符串**没有文件数据**。
- en: COOKIES
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Cookies
- en: This section contains any cookies sent by the browser with the request. For
    example, if the `contrib.sessions` application is listed in `INSTALLED_APPS`,
    you will see the `sessionid` cookie that it uses listed here. Alternatively, if
    the browser did not include any cookies with the request, the string **No cookies
    data** is displayed.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部分包含了浏览器发送的任何cookie。例如，如果`contrib.sessions`应用程序在`INSTALLED_APPS`中列出，您将在这里看到它使用的`sessionid`
    cookie。或者，如果浏览器没有在请求中包含任何cookie，则显示字符串**没有cookie数据**。
- en: META
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元数据
- en: This section contains a list of all the keys and their values in the `request.META`
    dictionary. This dictionary contains all of the HTTP request headers, in addition
    to other variables that have nothing to do with HTTP.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部分包含了`request.META`字典中所有键和它们的值的列表。这个字典包含了所有的HTTP请求头，以及与HTTP无关的其他变量。
- en: For example, if you look at the contents of this section as reported when you
    are running the development server, you will see it lists all of the environment
    variables that were exported in the environment of the command prompt where the
    development server is running. That is because this dictionary is initially set
    to the value of the Python `os.environ` dictionary, and then additional values
    are added. Thus, there can be a lot of extraneous information listed here, but
    if you ever need to check up on the value of an HTTP header, for example, you
    can find it in here.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您在运行开发服务器时查看这个部分的内容，您将看到它列出了在开发服务器运行的命令提示符的环境中导出的所有环境变量。这是因为这个字典最初被设置为Python
    `os.environ`字典的值，然后添加了其他值。因此，这里可能列出了很多无关紧要的信息，但是如果您需要检查HTTP头的值，您可以在这里找到它。
- en: Settings
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置
- en: The final part of the debug page is an exhaustive list of the settings in effect
    at the time of the error. This is another section that you may rarely need to
    look at, but when you do it, is very helpful to have it listed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 调试页面的最后部分是错误发生时生效的所有设置的详尽列表。这是另一个您可能很少需要查看的部分，但当您需要时，将会非常有帮助。
- en: 'Two items from this section: the installed applications, and the installed
    middleware, are included in the cut-and-paste version of the debug information
    mentioned earlier, since they are often helpful to know when analyzing problems
    posted by others.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部分包括两项内容：安装的应用程序和安装的中间件，它们都包含在前面提到的调试信息的剪切和粘贴版本中，因为它们在分析他人发布的问题时通常是很有帮助的。
- en: If you glance through this section of the debug page, you may notice that the
    values of some settings are not actually reported, but rather a string of asterisks
    is listed instead. This is a way of hiding information that should not be casually
    exposed to any users who may see a debug page. The hiding technique is applied
    to any setting that has the string `PASSWORD` or `SECRET` in its name.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您浏览调试页面的这个部分，您可能会注意到一些设置的值实际上并没有报告，而是列出了一串星号。这是一种隐藏信息的方式，不应该随意暴露给可能看到调试页面的任何用户。这种隐藏技术适用于任何设置中包含`PASSWORD`或`SECRET`字符串的设置。
- en: Note that this hiding technique is applied only to the values as they are reported
    in the settings section of the debug page. It does not imply that it is safe to
    run with `DEBUG` enabled for a production site. It is still possible to retrieve
    sensitive information from a debug page. For example, this would be the case if
    the value of a password setting is stored in a local variable, as will be typical
    when it is being used to set up a connection to the database or mail server. If
    an exception is raised during the connection attempt, the password value can be
    retrieved from the local variable information in the traceback section of the
    page.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这种隐藏技术仅适用于调试页面设置部分中报告的值。这并不意味着在生产站点中启用`DEBUG`是安全的。仍然有可能从调试页面中检索到敏感信息。例如，如果密码设置的值存储在本地变量中，那么当它被用于建立到数据库或邮件服务器的连接时，典型情况下会发生这种情况。如果在连接尝试期间引发异常，密码值可以从页面的回溯部分的本地变量信息中检索出来。
- en: We've now finished with the general description of the information available
    on a debug page. Next, we will see how to use the specific information on the
    page we have encountered in order to track down and fix the error in the code.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了调试页面上可用信息的一般描述。接下来，我们将看到如何使用我们遇到的页面上的具体信息来追踪并修复代码中的错误。
- en: Understanding and fixing the TypeError
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解和修复TypeError
- en: 'What went wrong that led to the debug page we''ve encountered here? In this
    case, the basic error information is enough to identify and fix the problem. We
    have a **TypeError** reported, with an exception value of **__init__() takes at
    least 2 non-keyword arguments (1 given)**. Furthermore, the location of the code
    that caused the error is **/dj_projects/marketr/survey/forms.py in QuestionVoteForm,
    line 3**. Looking at that line we see:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 导致我们遇到的调试页面出现问题的原因是什么？在这种情况下，基本的错误信息足以识别和修复问题。我们报告了一个**TypeError**，异常值为**__init__()至少需要2个非关键字参数（给出了1个）**。此外，导致错误的代码的位置是**/dj_projects/marketr/survey/forms.py中的QuestionVoteForm，第3行**。看看那一行，我们看到：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We have not specified all of the necessary arguments to create a `ModelChoiceField`.
    If you are new to Python, the specifics of the error message may be a bit confusing,
    as that line of code doesn't reference anything named `__init__` nor does it appear
    to pass any non-keyword arguments, yet the message says one was given. The explanation
    for that is that `__init__` is the method called by Python when an object is created,
    and it, like all object instance methods, automatically receives a reference to
    itself as its first positional argument.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有指定创建`ModelChoiceField`所需的所有必要参数。如果您是Python的新手，错误消息的具体内容可能有点令人困惑，因为代码行中没有引用任何名为`__init__`的东西，也没有传递任何非关键字参数，但错误消息却说给出了一个。其解释是，`__init__`是Python在创建对象时调用的方法，它和所有对象实例方法一样，自动接收一个对自身的引用作为其第一个位置参数。
- en: 'Thus the one non-keyword argument that has been supplied is `self`. What is
    missing? Checking the documentation, we find that `queryset` is a required argument
    for a `ModelChoiceField`. We omitted it because the correct value is not known
    at the time the field is declared, but only when an instance of the form containing
    the field is created. We cannot just leave it out though, so we need to specify
    something as the `queryset` value when the field is declared. What should it be?
    As it is going to be reset as soon as any instance of the form is created, `None`
    will probably do. So let''s try changing that line to:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，已经提供的一个非关键字参数是`self`。缺少什么？检查文档，我们发现`queryset`是`ModelChoiceField`的一个必需参数。我们省略了它，因为在声明字段时并不知道正确的值，而只有在创建包含该字段的表单的实例时才知道。但我们不能只是将其省略，因此我们需要在声明字段时指定`queryset`值。应该是什么？因为它将在创建表单的任何实例时立即重置，所以`None`可能会起作用。所以让我们尝试将那一行改为：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Does that work? Yes, if we click the browser reload page button we now get
    the survey home page:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这样行得通吗？是的，如果我们点击浏览器重新加载页面按钮，我们现在可以得到调查首页：
- en: '![Understanding and fixing the TypeError](img/7566_07_06.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![理解和修复TypeError](img/7566_07_06.jpg)'
- en: 'Again, if you are new to Python the fact that the fix worked might seem a bit
    confusing. The error message says that at least two non-keyword arguments are
    needed, but we did not add a non-keyword argument with the fix. The message makes
    it sounds like the only correct fix might be to supply the `queryset` value as
    a non-keyword argument:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果您是Python的新手，修复方法的有效性可能会有点令人困惑。错误消息说至少需要两个非关键字参数，但我们没有使用修复方法添加非关键字参数。错误消息似乎表明，唯一正确的修复方法可能是将`queryset`值作为非关键字参数提供：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Clearly that's not the case, though, since the alternative fix shown above does
    work. The explanation for this is that the message is not referring to how many
    non-keyword arguments are specified by the caller, but rather how many are specified
    in the declaration of the target method (that is the `__init__` method of `ModelChoiceField`
    in this case). The caller is free to pass arguments using keyword syntax, even
    if they are not listed as keyword arguments in the method declaration, and the
    Python interpreter will match them up correctly. Thus, the first fix works fine.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 显然情况并非如此，因为上面显示的替代修复方法确实有效。这样解释的原因是，消息并不是指调用者指定了多少个非关键字参数，而是指目标方法的声明中指定了多少个参数（在这种情况下是`ModelChoiceField`的`__init__`方法）。调用者可以自由地使用关键字语法传递参数，即使它们在方法声明中没有列为关键字参数，Python解释器也会正确地将它们匹配起来。因此，第一个修复方法可以正常工作。
- en: 'Now that we have the home page working again, we can get back to seeing whether
    we are able to create and display our new `QuestionVoteForm`. To do that, click
    on the link to the **Television Trends** survey. The result will be:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们又让首页正常工作了，我们可以继续看看我们是否能够创建和显示我们的新`QuestionVoteForm`。要做到这一点，请点击**电视趋势**调查的链接。结果将是：
- en: '![Understanding and fixing the TypeError](img/7566_07_07.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![理解和修复TypeError](img/7566_07_07.jpg)'
- en: While it is nice not to get a debug page, that's not quite what we are looking
    for. There are a few problems here.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不再出现调试页面很好，但这并不是我们要找的。这里有一些问题。
- en: 'First, the heading for the list of answers is **Answer**, yet we want that
    to be the question text. The value displayed here is the label assigned to the
    `ModelChoiceField`. The default label for any form field is the name of the field,
    capitalized and with a colon following. We did not override that default when
    we declared the `ModelChoiceField` answer, so we see **Answer** displayed. The
    fix is to manually set the `label` attribute for the field. Like the `queryset`
    attribute, the correct value for a particular form instance is only known when
    the form is created, so we do this by adding this line to the form''s `__init__`
    method:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，答案列表的标题是**Answer**，但我们希望它是问题文本。这里显示的值是分配给`ModelChoiceField`的标签。任何表单字段的默认标签都是字段的名称，大写并跟着一个冒号。当我们声明`ModelChoiceField`答案时，我们没有覆盖默认值，所以显示**Answer**。修复方法是手动设置字段的`label`属性。与`queryset`属性一样，特定表单实例的正确值只有在创建表单时才知道，所以我们通过在表单的`__init__`方法中添加这一行来实现这一点：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Second, the list of answers includes an empty first choice, shown as a list
    of dashes. This default behavior is helpful for select drop-down boxes to ensure
    that the user is forced to choose a valid value. However, it is unnecessary when
    using a radio input group since with radio inputs, we do not need to have any
    of the radio buttons initially selected when the form is displayed. Thus, we don't
    need the empty choice. We can get rid of it by specifying `empty_label=None` in
    our `ModelChoiceField` declaration.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，答案列表包括一个空的第一个选择，显示为破折号列表。这种默认行为对于选择下拉框非常有帮助，以确保用户被迫选择一个有效的值。然而，在使用单选输入组时是不必要的，因为对于单选输入，当表单显示时我们不需要任何单选按钮被初始选择。因此，我们不需要空的选择。我们可以通过在`ModelChoiceField`声明中指定`empty_label=None`来摆脱它。
- en: 'Third, all the choices listed are displayed as **Answer object** instead of
    the actual answer text. By default, the value displayed here is whatever is returned
    by the model instance''s `__unicode__` method. Since we have not yet implemented
    a `__unicode__` method for the `Answer` model, we simply get **Answer object**
    displayed. One fix is to implement a `__unicode__` method in `Answer` that returns
    the `answer` field value:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，列出的所有选项都显示为**Answer object**，而不是实际的答案文本。默认情况下，这里显示的值是模型实例的`__unicode__`方法返回的任何内容。由于我们还没有为`Answer`模型实现`__unicode__`方法，所以我们只能看到**Answer
    object**。一个修复方法是在`Answer`中实现一个返回`answer`字段值的`__unicode__`方法：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that if we wanted the `Answer` model's `__unicode__` method to return something
    else, we could accommodate that also. The way to do that would be to subclass
    `ModelChoiceField` and provide an override for the `label_from_instance` method.
    This is the method called to display the value of the choice in the list, and
    the default implementation uses the textual representation of the instance. So,
    we could take that approach if we needed to display something other than the model's
    default textual representation in the choice list, but for our purposes simply
    having the `Answer` model's `__unicode__` method return the answer text will work
    fine.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果我们希望`Answer`模型的`__unicode__`方法返回其他内容，我们也可以适应。要做到这一点，我们可以对`ModelChoiceField`进行子类化，并提供`label_from_instance`方法的覆盖。这是用于在列表中显示选择值的方法，默认实现使用实例的文本表示。因此，如果我们需要在选择列表中显示除模型的默认文本表示之外的其他内容，我们可以采取这种方法，但对于我们的目的，只需让`Answer`模型的`__unicode__`方法返回答案文本即可。
- en: Fourth, the answer choices are displayed as an unordered list, and that list
    is being displayed with bullets, which is a bit ugly. There are various ways of
    fixing this—by either adding a CSS style specification or by changing the way
    the choice list is rendered. However, the bullets are not a functional problem
    and getting rid of them doesn't further our task of learning about the Django
    debug page, so for now we will let them be.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第四，答案选择显示为无序列表，并且该列表显示为带有项目符号，这有点丑陋。有各种方法可以解决这个问题，可以通过添加CSS样式规范或更改选择列表的呈现方式来解决。然而，项目符号并不是一个功能性问题，去掉它们并不能进一步帮助我们了解Django调试页面的任务，所以现在我们将让它们存在。
- en: 'The fixes previously made to the `QuestionVoteForm`, result in code that now
    looks like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 先前对`QuestionVoteForm`所做的修复，导致代码现在看起来像这样：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With that form, and the implementation of a `__unicode__` method in the `Answer`
    model, reloading our survey detail page produces a result that looks better:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个表单，并在Answer模型中实现了`__unicode__`方法，重新加载我们的调查详情页面会产生一个看起来更好的结果：
- en: '![Understanding and fixing the TypeError](img/7566_07_08.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![理解和修复TypeError](img/7566_07_08.jpg)'
- en: We've now got a form that displays reasonably well and are ready to move on
    to the next step in implementing survey voting.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个显示得相当好的表单，并准备继续实施调查投票的下一步。
- en: Handling multiple Survey questions
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理多个调查问题
- en: We have the display of a single question form working, what's left to do? First,
    we need to handle the display of however many questions that are associated with
    a survey, instead of just a single question. Second, we need to handle receiving,
    validating, and processing the results. We'll focus on the first task in this
    section.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经让单个问题表单的显示工作了，还剩下什么要做？首先，我们需要处理与调查相关的任意数量的问题的显示，而不仅仅是一个单独的问题。其次，我们需要处理接收、验证和处理结果。在本节中，我们将专注于第一个任务。
- en: Creating the data for multiple questions
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建多个问题的数据
- en: 'Before writing the code to handle multiple questions, let''s add another question
    to our test survey so that we''ll be able to see the new code work. The upcoming
    examples will display this additional question:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写处理多个问题的代码之前，让我们在我们的测试调查中添加另一个问题，这样我们就能看到新代码的运行情况。接下来的示例将显示这个额外的问题：
- en: '![Creating the data for multiple questions](img/7566_07_09.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![创建多个问题的数据](img/7566_07_09.jpg)'
- en: Coding support for multiple questions
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持多个问题的编码
- en: 'Next, change the view to create a list of `QuestionVoteForms` and pass this
    list in the template context:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，更改视图以创建`QuestionVoteForms`的列表，并将此列表传递到模板上下文中：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here we start with an empty list named `qforms`. Then, we loop through all questions
    in the set associated with the passed `survey` and create a form for each question
    that has more than one answer associated with it. (A `Question` that has fewer
    than two answers is probably a set-up error. Since it's best to avoid presenting
    a general user with a question for which they cannot actually choose an answer,
    we opt here to just leave such questions out of the display for an active `Survey`.)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个名为`qforms`的空列表开始。然后，我们循环遍历与传递的`survey`相关联的所有问题，并为每个具有多个答案的问题创建一个表单。（具有少于两个答案的`Question`可能是设置错误。由于最好避免向一般用户呈现他们实际上无法选择答案的问题，我们选择在活动`Survey`的显示中略过这样的问题。）
- en: Notice that we added passing a `prefix` argument on the form creation, and set
    the value to the position of the current question in the full set of questions
    for the survey. This gives each form instance a unique `prefix` value. The `prefix`
    value, if present in a form, is used when `id` and `name` attributes are generated
    for the HTML form elements. Specifying a unique `prefix` is necessary to ensure
    that the generated HTML is valid when there are multiple forms of the same type
    on a page, as there will be for the case we are implementing here.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在表单创建时添加了传递`prefix`参数，并将值设置为调查的全部问题集中当前问题的位置。这为每个表单实例提供了一个唯一的`prefix`值。如果表单中存在`prefix`值，则在生成HTML表单元素的`id`和`name`属性时将使用它。指定唯一的`prefix`是必要的，以确保在页面上存在相同类型的多个表单时生成的HTML是有效的，就像我们在这里实现的情况一样。
- en: Finally, each `QuestionVoteForm` created is appended to the `qforms` list, and
    at the end of the function the `qforms` list is passed in the context to be rendered
    in the template.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，每个创建的`QuestionVoteForm`都被附加到`qforms`列表中，并且在函数结束时，`qforms`列表被传递到上下文中以在模板中呈现。
- en: 'The last step, then, is to change the template to support displaying multiple
    questions instead of just one. To do this, we might change the `active_survey.html`
    template like so:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最后一步是更改模板以支持显示多个问题而不仅仅是一个。为此，我们可以像这样更改`active_survey.html`模板：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The only change from the previous version is to replace `{{ qvf.as_p }}`, which
    displays a single form, with a `{% for %}` block that loops through the list of
    forms in the `qforms` context variable. Each form is displayed in turn, again
    still using the `as_p` convenience method.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个版本唯一的变化是用循环遍历`qforms`上下文变量中的表单列表的`{% for %}`块替换了显示单个表单的`{{ qvf.as_p }}`。每个表单依次显示，仍然使用`as_p`便利方法。
- en: 'Debug page #2: TemplateSyntaxError at /1/'
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试页面＃2：TemplateSyntaxError at /1/
- en: 'How well does that work? Not so well. If we attempt to reload the page displaying
    the questions for this survey, we will see:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做效果如何？效果不太好。如果我们尝试重新加载显示此调查问题的页面，我们将看到：
- en: '![Debug page #2: TemplateSyntaxError at /1/](img/7566_07_10.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![调试页面＃2：TemplateSyntaxError at /1/](img/7566_07_10.jpg)'
- en: We've made a mistake, and triggered a slightly different debug page. Instead
    of the basic exception information being followed immediately by the traceback
    section, we see a **Template error** section. This section is included for exceptions
    of type `TemplateSyntaxError`, when `TEMPLATE_DEBUG` is `True`. It displays some
    context from the template that caused the exception, and highlights the line identified
    as causing the error. Usually for a `TemplateSyntaxError`, the problem is found
    in the template itself, not the code that is attempting to render the template
    (which will be what is shown in the traceback section), so it is helpful for the
    debug page to prominently display the template contents.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们犯了一个错误，并触发了一个略有不同的调试页面。我们看到一个**模板错误**部分，而不是基本的异常信息后面紧接着回溯部分。对于`TemplateSyntaxError`类型的异常，当`TEMPLATE_DEBUG`为`True`时，将包括此部分。它显示了导致异常的模板的一些上下文，并突出显示了被识别为导致错误的行。通常对于`TemplateSyntaxError`，问题是在模板本身中找到的，而不是尝试呈现模板的代码（这将是回溯部分显示的内容），因此调试页面突出显示模板内容是有帮助的。
- en: Understanding and fixing the TemplateSyntaxError
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解和修复TemplateSyntaxError
- en: In this case, the line identified as causing the error may be somewhat puzzling.
    The `{% endblock content %}` line hasn't changed since the previous, working,
    version of the template; it is certainly not an invalid block tag. Why is the
    template engine now reporting that it is invalid? The answer is that template
    syntax errors, like many syntax errors reported in programming languages, are
    sometimes misleading when they attempt to point out where the error is. The point
    identified as in error is actually where an error was recognized, when in fact
    the error may have occurred somewhat earlier.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，被识别为导致错误的行可能有些令人困惑。`{% endblock content %}`行自上一个工作版本的模板以来并没有改变；它肯定不是一个无效的块标签。为什么模板引擎现在报告它是无效的？答案是，模板语法错误，就像许多编程语言中报告的语法错误一样，有时在试图指出错误位置时会产生误导。被识别为错误的点实际上是在识别错误时，而实际上错误可能发生得更早一些。
- en: This misleading identification often happens when something required is left
    out. The parser continues on processing the input, but eventually reaches something
    not allowed given the current state. At that point, the place where the missing
    bit should have been may be several lines away. That is what has happened here.
    The `{% endblock content %}` is reported as being invalid because it is not allowed,
    given that the template has a still-open `{% for %}` tag.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当漏掉了某些必需的内容时，经常会发生这种误导性的识别。解析器继续处理输入，但最终达到了当前状态下不允许的内容。此时，应该有缺失部分的地方可能相距几行。这就是这里发生的情况。`{%
    endblock content %}`被报告为无效，因为在模板中仍然有一个未关闭的`{% for %}`标签。
- en: 'In making the template changes for supporting multiple questions, we added
    a `{% for %}` tag, but neglected to close it. The Django template language is
    not Python, it does not consider indentation significant. Thus, it does not consider
    the `{% for %}` block terminated by a return to the previous indentation level.
    Rather, we must explicitly close the new `{% for %}` block with an `{% endfor
    %}`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在为支持多个问题进行模板更改时，我们添加了一个`{% for %}`标签，但忽略了关闭它。Django模板语言不是Python，它不认为缩进很重要。因此，它不认为`{%
    for %}`块是通过返回到先前的缩进级别终止的。相反，我们必须使用`{% endfor %}`显式关闭新的`{% for %}`块：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once we make that change, we can reload the page and see that we do now have
    multiple questions displayed on the page:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们做出了这个改变，我们可以重新加载页面，看到我们现在在页面上显示了多个问题：
- en: '![Understanding and fixing the TemplateSyntaxError](img/7566_07_11.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![理解和修复TemplateSyntaxError](img/7566_07_11.jpg)'
- en: With the display of multiple questions working, we can move on to adding the
    code to process submitted responses.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 随着多个问题的显示，我们可以继续添加处理提交的回答的代码。
- en: Recording Survey responses
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录调查回答
- en: We've already got test data we can use to exercise processing survey responses,
    so we do not need to add any data to our development database for the next step.
    Furthermore, nothing needs to be changed in the template to support submitting
    responses. It already includes a submit button in the HTML form, and specifies
    that the form data should be submitted as an HTTP POST when the form is submitted.
    Right now the **Submit** button will work, in that it can be pressed and no error
    will occur, but the only result will be that the page is re-displayed. This is
    because the view code does not attempt to distinguish between a GET and a POST,
    and just treats all requests as though they were GET requests. Thus, it is the
    view code we need to change to add support for handling POST requests as well
    as GET requests.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有测试数据可以用来练习处理调查回答，因此我们不需要为下一步向开发数据库添加任何数据。此外，模板不需要更改以支持提交回答。它已经在HTML表单中包含了一个提交按钮，并指定在提交表单时应将表单数据提交为HTTP
    POST。现在**提交**按钮将起作用，因为它可以被按下而不会出现错误，但唯一的结果是页面被重新显示。这是因为视图代码不尝试区分GET和POST，并且将所有请求都视为GET请求。因此，我们需要更改视图代码以添加对处理POST请求和GET请求的支持。
- en: Coding support for recording Survey responses
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录调查回答的编码支持
- en: 'The view code, then, needs to change to check what method is specified in the
    request. The handling of a GET request should stay the same. If the request is
    a POST, however, then the `QuestionVoteForms` should be constructed using the
    submitted POST data. These can then be validated, and if all of the responses
    are valid (meaning, in this case, that the user selected a choice for each question),
    then the votes can be recorded and an appropriate response sent to the user. If
    there are any validation errors, the constructed forms should be re-displayed
    with error messages. An initial implementation of this is:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，视图代码需要更改以检查请求中指定的方法。处理GET请求的方式应该保持不变。然而，如果请求是POST，那么应该使用提交的POST数据构建`QuestionVoteForms`。然后可以对其进行验证，如果所有的回答都是有效的（在这种情况下，这意味着用户为每个问题选择了一个选项），那么可以记录投票并向用户发送适当的响应。如果有任何验证错误，构建的表单应该重新显示带有错误消息。这方面的初始实现如下：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here we start by setting the local variable `data` to either the `request.POST`
    dictionary, if the request method is `POST`, or `None`. We will use this during
    form construction, and it must be `None` (not an empty dictionary) in order to
    create unbound forms, which are what we need for the initial display when a user
    gets the page.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先将本地变量`data`设置为`request.POST`字典，如果请求方法是`POST`，或者为`None`。我们将在表单构建过程中使用它，并且它必须是`None`（而不是空字典），以便创建未绑定的表单，这是用户在获取页面时所需的。
- en: We then build the list of `qforms` as before. The only difference here is that
    we pass in the `data` argument so that the created forms will be bound to the
    posted data in the case where the request is a POST. Binding the data to the forms
    allows us to later check if the submitted data is valid.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后像以前一样构建`qforms`列表。这里唯一的区别是我们传入`data`参数，以便在请求为POST时将创建的表单绑定到已发布的数据。将数据绑定到表单允许我们稍后检查提交的数据是否有效。
- en: We then have a new block of code to handle the case where the request is a POST.
    We create an empty list to hold the chosen answers and then loop through the forms
    checking if each is valid. If any are not, we immediately break out of the `for`
    loop. This will have the effect of skipping the `else` clause associated with
    the loop (since that is executed only if the list of items in the `for` loop is
    exhausted). Thus, as soon as an invalid form is encountered, this routine will
    skip down to the `return render_to_response` line, which will result in the page
    being re-displayed with error annotations on the invalid forms.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有一段新的代码块来处理请求为POST的情况。我们创建一个空列表来保存选择的答案，然后循环遍历表单，检查每个表单是否有效。如果有任何无效的表单，我们立即跳出`for`循环。这将导致跳过与循环相关联的`else`子句（因为只有在`for`循环中的项目列表耗尽时才执行）。因此，一旦遇到无效的表单，这个程序将跳到`return
    render_to_response`行，这将导致页面重新显示，并在无效的表单上显示错误注释。
- en: But wait—we break out of the `for` loop as soon as the first invalid form is
    found. If there is more than one invalid form, don't we want to display errors
    on all forms, not just the first? The answer is yes, we do, but we do not need
    to explicitly call `is_valid` in the view in order to accomplish that. When the
    form is rendered in the template, if it is bound and has not yet been validated,
    `is_valid` will be called before its values are rendered. Thus, errors in any
    of the forms will be displayed in the template, regardless of whether `is_valid`
    is explicitly called by the view code.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等——一旦找到第一个无效的表单，我们就会跳出`for`循环。如果有多个无效的表单，我们不是想在所有表单上显示错误，而不仅仅是第一个吗？答案是是，但我们不需要在视图中显式调用`is_valid`来实现这一点。当表单在模板中呈现时，如果它被绑定并且尚未经过验证，`is_valid`将在其值呈现之前被调用。因此，无论视图代码是否显式调用`is_valid`，模板中都将显示任何表单中的错误。
- en: If all the forms are valid, the `for` loop will exhaust its list, and the `else`
    clause on the `for` loop will run. Here we want to record the votes and return
    an appropriate response to the user. We've done the first, by incrementing the
    vote count for each chosen answer instance. For the second, though, we've implemented
    a development version that builds a response indicating what the current vote
    values are for all of the questions. This is not what we want general users to
    see, but we can use it as a quick verification that the answer recording code
    is doing what we expect.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有表单都有效，`for`循环将耗尽其列表，并且`for`循环上的`else`子句将运行。在这里，我们想记录投票并向用户返回适当的响应。我们已经完成了第一个，通过增加每个选择答案实例的投票数。但是，对于第二个，我们实现了一个开发版本，该版本构建了一个响应，指示所有问题的当前投票值。这不是我们希望一般用户看到的，但我们可以将其用作快速验证答案记录代码是否符合我们的期望。
- en: 'If we now choose **Drama** and **Hardly any: I already watch too much TV!**
    as answers and submit the form, we see:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在选择**戏剧**和**几乎没有：我已经看了太多电视了！**作为答案并提交表单，我们会看到：
- en: '![Coding support for recording Survey responses](img/7566_07_12.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![为记录调查响应提供编码支持](img/7566_07_12.jpg)'
- en: 'That looks good: there''s no debug page and the vote values are correct for
    what was chosen, so the vote recording code is working. We can now replace the
    development version of the generated response with one appropriate for general
    users.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错：没有调试页面，所选的投票值是正确的，所以投票记录代码正在工作。现在我们可以用适用于一般用户的生成响应的开发版本替换开发版本。
- en: 'Best practice in responding to a successful POST request is to redirect to
    some other page, so that a user pressing the browser''s reload button does not
    result in the posted data being re-submitted and re-processed. To do this, we
    can change the else block to be:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应成功的POST请求时，最佳做法是重定向到其他页面，这样用户按下浏览器的重新加载按钮不会导致已发布的数据被重新提交和重新处理。为此，我们可以将else块更改为：
- en: '[PRE19]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note the imports have been included here only to show what needs to be imported;
    ordinarily these would be placed at the top of the file rather than nested deep
    within a function like this. Instead of building a response noting all of the
    new answer vote values, this code now sends an HTTP redirect. As always, to avoid
    hard-coding URL configuration anywhere outside of the actual `urls.py` files,
    we have used reverse here to generate the URL path corresponding to a new named
    URL pattern, `survey_thanks`. We pass along the survey's primary key value as
    an argument so that the page generated in response can be tailored to reflect
    the survey that was submitted.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里包含了导入，只是为了显示需要导入的内容；通常情况下，这些内容会放在文件顶部，而不是嵌套在函数中。现在，这段代码不再构建一个注释所有新答案投票值的响应，而是发送一个HTTP重定向。为了避免在实际的
    `urls.py` 文件之外的任何地方硬编码URL配置，我们在这里使用了reverse来生成与新命名的URL模式 `survey_thanks` 对应的URL路径。我们传递调查的主键值作为参数，以便生成的页面可以根据提交的调查进行定制。
- en: 'Before that `reverse` call can work, we need to add a new pattern named `survey_thanks`
    to our `survey/urls.py` file. We might add it like so, so that the full `urlpatterns`
    in `survey/urls.py` is:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在`reverse`调用之前，我们需要在`survey/urls.py`文件中添加一个名为`survey_thanks`的新模式。我们可以这样添加，以便`survey/urls.py`中的完整`urlpatterns`是：
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The added `survey_thanks` pattern is much like the `survey_detail` pattern,
    except the associated URL path has the string `thanks` before the segment containing
    the survey's primary key value.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的`survey_thanks`模式与`survey_detail`模式非常相似，只是相关的URL路径在包含调查的主键值的段之前有字符串`thanks`。
- en: 'In addition, we will need to add a `survey_thanks` view function to `survey/views.py`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们需要在 `survey/views.py` 中添加一个 `survey_thanks` 视图函数：
- en: '[PRE21]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This view looks up the specified survey using `get_object_or_404`. If a matching
    survey does not exist, then an `Http404` error will be raised and a page not found
    response will be returned. If the survey is found, then a new template, `survey/thanks.html`
    will be used to render a response. The survey is passed in the context to the
    template allowing a tailored response reflecting the survey that was submitted.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图使用`get_object_or_404`查找指定的调查。如果找不到匹配的调查，那么将引发`Http404`错误，并返回一个未找到页面的响应。如果找到了调查，那么将使用一个新的模板`survey/thanks.html`来渲染响应。调查被传递到模板中，允许根据提交的调查定制响应。
- en: 'Debug page #3: NoReverseMatch at /1/'
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试页面＃3：/1/处的NoReverseMatch
- en: 'Before writing the new template, let''s check to see if redirect works, as
    all it needs is the changes to `survey/urls.py` and the view implementation. What
    happens if we submit a response with the new redirect code in `views.py`? Not
    what we might have hoped:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写新模板之前，让我们检查一下重定向是否有效，因为它只需要对`survey/urls.py`和视图实现进行更改。如果我们在`views.py`中提交了带有新重定向代码的响应，会发生什么？并不是我们所希望的：
- en: '![Debug page #3: NoReverseMatch at /1/](img/7566_07_13.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![调试页面＃3：/1/处的NoReverseMatch](img/7566_07_13.jpg)'
- en: '`NoReverseMatch` exceptions can be among the most frustrating ones to debug.
    Unlike when forward matching fails, the debug page does not provide a list of
    patterns tried and the order in which matching was attempted. This may sometimes
    lead us to think the proper pattern wasn''t even considered. Rest assured, it
    was. The problem is not that the appropriate pattern wasn''t considered, it was
    that it didn''t match.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`NoReverseMatch`异常可能是最令人沮丧的异常之一。与正向匹配失败时不同，调试页面不会提供尝试的模式列表以及匹配尝试的顺序。这有时会让我们认为适当的模式甚至没有被考虑。请放心，它已经被考虑了。问题不是适当的模式没有被考虑，而是它没有匹配。'
- en: Understanding and fixing the NoReverseMatch exception
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解和修复NoReverseMatch异常
- en: 'How do you figure out why a pattern expected to match is not matching? Guessing
    what might be wrong and making changes based on those guesses has a chance of
    working, but is also likely to make things worse. A better approach is to be methodical
    and check things one by one, which usually leads to discovery of the source of
    the problem. The following is a sequence of things to check. We''ll go through
    this sequence and consider how it applies to our pattern where `reverse` is unexpectedly
    failing:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如何找出预期匹配的模式为何不匹配？猜测可能出错的地方并根据这些猜测进行更改有可能奏效，但也很可能会使情况变得更糟。更好的方法是有条不紊地逐一检查事物，通常会导致问题根源的发现。以下是一系列要检查的事物。我们将按顺序进行检查，并考虑它如何适用于我们的模式，其中`reverse`出现意外失败：
- en: '[PRE22]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: First, verify that the name identified in the exception matches the name in
    the URL pattern specification. In this case, the exception cites `survey_thanks`,
    and the URL pattern we expect to match has `name='survey_thanks'` specified, so
    those match.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，验证异常中标识的名称是否与URL模式规范中的名称匹配。在这种情况下，异常引用了`survey_thanks`，而我们期望匹配的URL模式中指定了`name='survey_thanks'`，所以它们是匹配的。
- en: Note that if the URL pattern omits the `name` argument, and the `patterns` call
    it is an argument to specifies a view `prefix`, then the caller of `reverse` must
    also include the view `prefix` when specifying the name to reverse. In this case,
    for example, if we did not specify a name for the `survey_thanks` view, then a
    successful `reverse` call would need to specify `survey.views.survey_thanks` as
    the name to reverse, since `survey.views` is specified as the `patterns prefix`
    in `survey/urls.py`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果URL模式省略了`name`参数，并且`patterns`调用是指定了视图`prefix`的参数，则在指定要反转的名称时，`reverse`的调用者也必须包括视图`prefix`。例如，在这种情况下，如果我们没有为`survey_thanks`视图指定名称，那么成功的`reverse`调用将需要指定`survey.views.survey_thanks`作为要反转的名称，因为在`survey/urls.py`中指定了`survey.views`作为`patterns
    prefix`。
- en: Second, make sure that the number of arguments listed in the exception message
    matches the number of regular expression groups in the URL pattern. In this case,
    there is one argument listed by the exception, `1L`, and one regular expression
    group, `(?P<pk>\d+/)`, so the numbers match.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，确保异常消息中列出的参数数量与URL模式中的正则表达式组数量相匹配。在这种情况下，异常中列出了一个参数`1L`，一个正则表达式组`(?P<pk>\d+/)`，所以数字是匹配的。
- en: Third, if the exception shows keyword arguments were specified, verify that
    the regular expression groups are named. Further, verify that the names of the
    groups match the names of the keyword arguments. In this case, keyword arguments
    were not specified on the `reverse` call, so there is nothing to check for this
    step.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，如果异常显示指定了关键字参数，请验证正则表达式组是否具有名称。此外，请验证组的名称是否与关键字参数的名称匹配。在这种情况下，`reverse`调用没有指定关键字参数，因此在这一步没有什么可检查的。
- en: Note that it is not necessary to ensure non-named groups are used in the URL
    pattern when positional arguments are shown in the exception, because it is possible
    for positional arguments to be matched to named groups in a URL pattern. Thus,
    there is no problem when, as in our case, the URL pattern uses named groups while
    the `reverse` caller specifies positional arguments.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当在异常中显示了位置参数时，不需要确保URL模式中使用了非命名组，因为位置参数可以与URL模式中的命名组匹配。因此，在我们的情况下，URL模式使用了命名组，而`reverse`调用者指定了位置参数时，就没有问题。
- en: Fourth, for each argument, verify that the string representation of the actual
    argument value listed in the exception matches the associated regular expression
    group from the URL pattern. Note that the values shown in the exception are the
    results of calling `repr` on the arguments, thus they may not exactly match the
    string representation of the argument. Here, for example, the exception reports
    the argument value as `1L`, signifying a Python long integer value (the value
    is a long integer because that is what MySQL, the database in use for this example,
    always returns for integer values). The `L` suffix is used to make the type in
    the `repr` clear, but it does not appear in the string representation of the value,
    which is simply `1`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 第四，对于每个参数，验证异常中列出的实际参数值的字符串表示是否与URL模式中关联的正则表达式组匹配。请注意，异常中显示的值是对参数调用`repr`的结果，因此它们可能不完全匹配参数的字符串表示。例如，在这里，异常报告参数值为`1L`，表示Python长整型值（该值是长整型，因为这是本例中使用的数据库MySQL对整数值的返回方式）。后缀`L`用于清晰地表示`repr`中的类型，但它不会出现在值的字符串表示中，它只是简单的`1`。
- en: 'Thus for our example, the string representation of the argument shown in the
    exception message is `1`. Does that match the associated regular expression group
    in the URL pattern? Recall that the group is `(?P<pk>\d+/)`. The enclosing parentheses
    identify the fact that it is a group. The `?P<pk>` assigns the group the name
    `pk`. The remainder, `\d+/`, is then the regular expression we are trying to match
    with `1`. These don''t match. The regular expression is specifying one of more
    digits followed by a slash, yet the actual value we have is a single numeric digit,
    without a trailing slash. We made a typo here and included the slash inside the
    group instead of following it. The correct specification for our new `survey_thanks`
    view is:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于我们的例子，异常消息中显示的参数的字符串表示形式是`1`。这是否与URL模式中关联的正则表达式组匹配？请记住，该组是`(?P<pk>\d+/)`。括号标识了它是一个组。`?P<pk>`为该组分配了名称`pk`。其余部分`\d+/`是我们试图与`1`匹配的正则表达式。这些不匹配。正则表达式指定了一个或多个数字，后跟一个斜杠，然而我们实际拥有的值是一个单个数字，没有尾随斜杠。我们在这里犯了一个错别字，并在组内部包括了斜杠，而不是在其后。我们新的`survey_thanks`视图的正确规范是：
- en: '[PRE23]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It is very easy for typos like this to creep into URL pattern specifications,
    as the pattern specifications tend to be long and full of punctuation characters
    with special meaning. Breaking them down into component pieces and verifying that
    each piece is correct will save you a great deal of hassle. If, however, that
    does not work, and you get to a point where all of the bits look right but still
    you get a `NoReverseMatch` exception, it might be time to tackle the problem from
    the other direction.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的错别字很容易出现在URL模式规范中，因为模式规范往往很长，而且充满了具有特殊含义的标点符号。将它们分解成组件，并验证每个组件是否正确，将为您节省大量麻烦。然而，如果这样做不起作用，当所有部分看起来都正确但仍然出现`NoReverseMatch`异常时，也许是时候从另一个方向解决问题了。
- en: Start with the simplest part of the overall pattern, and verify that `reverse`
    for that works. You might, for example, get rid of all arguments from the reverse
    call and all groups from the URL pattern specification, and verify that you can
    `reverse` the URL by name. Then add back one argument and its associated pattern
    group in the URL specification, and verify if that works. Continue until you hit
    an error. Then change back to trying the simplest version in addition to just
    the argument that caused the error. If that works, then there is some problem
    with combining that argument with the others in the overall pattern, which is
    a clue, so you can start investigating what might cause that.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 从整体模式的最简单部分开始，并验证`reverse`是否有效。例如，您可以从`reverse`调用中删除所有参数以及URL模式规范中的所有组，并验证是否可以按名称`reverse`
    URL。然后添加一个参数及其相关的URL规范中的模式组，并验证是否有效。继续直到出现错误。然后切换回尝试最简单的版本，除了仅导致错误的参数之外。如果有效，则整体模式中将该参数与其他参数组合在一起存在问题，这是一个线索，因此您可以开始调查可能导致该问题的原因。
- en: This approach is a general debugging technique that can be applied whenever
    you encounter a mysterious problem in a complicated set of code. First, back off
    to something very simple that works. Then add things back, one by one, until things
    fail again. You've now identified one piece that is involved in the failure, and
    you can start investigating whether it is that piece alone that is a problem or
    if it works in isolation but only causes a problem when combined with other pieces.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法是一种通用的调试技术，可以在遇到复杂代码集中的神秘问题时应用。首先，退回到非常简单的有效内容。然后逐一添加内容，直到再次失败。现在您已经确定了与失败有关的一个部分，并且可以开始调查它是否是单独的问题，或者它在隔离状态下是否有效，但仅在与其他部分组合时才会出现问题。
- en: 'Debug page #4: TemplateDoesNotExist at /thanks/1/'
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试页面＃4：/thanks/1/处的TemplateDoesNotExist
- en: 'For now, let''s return to our example. Now that we have fixed the `reverse`
    problem, does the redirect to our survey thanks page work? Not quite. If we again
    attempt to submit our survey results, we see:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的例子。现在我们已经解决了`reverse`问题，重定向到我们的调查感谢页面是否有效？还不够。如果我们再次尝试提交我们的调查结果，我们会看到：
- en: '![Debug page #4: TemplateDoesNotExist at /thanks/1/](img/7566_07_14.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![调试页面＃4：/thanks/1/处的TemplateDoesNotExist](img/7566_07_14.jpg)'
- en: 'This one is self-explanatory; in tracking down the `NoReverseMatch` error we
    forgot we still had not gotten around to writing the template for the new view.
    The fix will be easy, but there is something to note about this debug page first:
    the section titled **Template-loader postmortem**. This is another optional section,
    like the **Template error** section included with `TemplateSyntaxError` debug
    pages, that provides additional information helpful for determining the exact
    cause of the error.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个很容易理解；在追踪`NoReverseMatch`错误时，我们忘记了我们还没有写新视图的模板。修复将很容易，但首先需要注意这个调试页面的一个部分：**模板加载程序事后分析**。这是另一个可选部分，就像`TemplateSyntaxError`调试页面中包含的**模板错误**部分一样，它提供了有助于确定错误确切原因的额外信息。
- en: The **Template-loader postmortem** section, specifically, lists all of the template
    loaders that were tried in attempting to locate the template. For each loader,
    it then lists the full file names searched for by that loader, and the outcome.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**模板加载程序事后分析**部分具体列出了尝试定位模板时尝试的所有模板加载程序。对于每个加载程序，它列出了该加载程序搜索的完整文件名，以及结果。'
- en: On this page we can see that the `filesystem` template loader was called first.
    But no files are listed as tried by that loader. The `filesystem` loader is included
    in our `settings.py` file, since it is the first listed in `TEMPLATE_LOADERS`
    in the `settings.py` file generated by `django-admin.py startproject`, and we
    have not changed that setting. It looks in all the directories specified in the
    settings `TEMPLATE_DIRS` value. However, `TEMPLATE_DIRS` is empty by default,
    and we have not changed that setting either, so the `filesystem` loader had no
    place to look in order to try and find `survey/thanks.html`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个页面上，我们可以看到 `filesystem` 模板加载器被首先调用。但是没有任何文件被该加载器尝试加载。`filesystem` 加载器包含在我们的
    `settings.py` 文件中，因为它是由 `django-admin.py startproject` 生成的 `settings.py` 文件中 `TEMPLATE_LOADERS`
    中的第一个加载器，并且我们没有更改该设置。它会在设置 `TEMPLATE_DIRS` 的所有指定目录中查找。然而，默认情况下 `TEMPLATE_DIRS`
    是空的，我们也没有更改该设置，因此 `filesystem` 加载器没有地方可以查找以尝试找到 `survey/thanks.html`。
- en: The second loader tried was the `app_directories` loader. This is the one we
    have been relying on so far to load the templates for our survey application.
    It loads templates from a `templates` directory under each application directory.
    The debug page shows that it attempted to find the `survey/thanks.html` file first
    under the `admin` application's `templates` directory and then under the `survey`
    application's `templates` directory. The result of searching for the specified
    file is placed in parentheses after the file name; in both cases here we see **File
    does not exist**, which is no surprise.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个尝试的加载器是 `app_directories` 加载器。这是我们迄今为止一直依赖的加载器，用于加载我们调查应用程序的模板。它从每个应用程序目录下的
    `templates` 目录加载模板。调试页面显示，它首先尝试在 `admin` 应用程序的 `templates` 目录下找到 `survey/thanks.html`
    文件，然后在 `survey` 应用程序的 `templates` 目录下找到。在文件名后面，显示了搜索指定文件的结果；在这两种情况下，我们都看到了 **文件不存在**，这并不奇怪。
- en: 'Sometimes this message will state **File exists**, which can be a little confusing.
    If the file exists, and the loader could see it exists, why didn''t the loader
    load it? This often occurs when running under a web server such as Apache, and
    the problem is that the web server process does not have the necessary permissions
    to read the file. The fix in that case is to make the file readable by the web
    server process. Dealing with production-time issues such as this will be discussed
    in more detail in [Chapter 11](ch11.html "Chapter 11. When it''s Time to Go Live:
    Moving to Production"), *When it''s Time to Go Live: Moving to Production*.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，这个消息会显示 **文件存在**，这可能有点令人困惑。如果文件存在，加载器也能看到它存在，为什么加载器没有加载它呢？这经常发生在像Apache这样的Web服务器上运行时，问题在于Web服务器进程没有必要的权限来读取文件。在这种情况下的解决方法是让Web服务器进程可以读取文件。处理这种生产时问题将在[第11章](ch11.html
    "第11章。当是时候上线：转向生产")中更详细地讨论，*当是时候上线：转向生产*。
- en: Understanding and fixing TemplateDoesNotExist
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解和修复TemplateDoesNotExist
- en: The fix in our case is simple, and we do not really even need to look closely
    at the error message to know what needs to be done, but note that this section
    gives everything needed in order to track down `TemplateDoesNotExist` errors.
    You will know what loader you are relying on to load the template. If that loader
    is not shown in the **Template-loader postmortem**, then the problem is likely
    an incorrect `TEMPLATE_LOADERS` setting in `settings.py`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，修复很简单，我们甚至不需要仔细查看错误消息就知道需要做什么，但请注意，本节提供了追踪 `TemplateDoesNotExist` 错误所需的一切。您将知道您依赖于哪个加载器来加载模板。如果在
    **Template-loader postmortem** 中没有显示该加载器，那么问题很可能是 `settings.py` 中 `TEMPLATE_LOADERS`
    设置不正确。
- en: If the loader is listed, but does not list attempting to load the expected file,
    then the next step is to figure out why. This step is loader-dependent, since
    each loader has its own rules for where to look for template files. The `app_directories`
    loader, for example, looks under a `templates` directory for each application
    listed in `INSTALLED_APPS`. Thus ensuring the application is in `INSTALLED_APPS`
    and has a `templates` directory would be two things to check when it is the `app_directories`
    loader that isn't searching for the file as expected.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果加载器被列出，但没有列出尝试加载预期文件，则下一步是弄清楚原因。这一步取决于加载器，因为每个加载器都有自己的规则来查找模板文件。例如，`app_directories`
    加载器会在 `INSTALLED_APPS` 中列出的每个应用程序的 `templates` 目录下查找。因此，确保应用程序在 `INSTALLED_APPS`
    中，并且有一个 `templates` 目录，是在 `app_directories` 加载器没有按预期搜索文件时要检查的两件事情。
- en: If the loader is listed and the expected file is listed as attempted, then the
    problem is hinted at by whatever is listed as the status for the file by the loader.
    **File does not exist** is a clear status with an easy fix. If **File does not
    exist** appears unexpectedly, double and triple check the filename. Cutting-and-pasting
    from the debug page into a command prompt and attempting to display the file may
    be useful here, as it may help clarify what is different about the name of the
    file the loader is trying to load compared to the name of the file that actually
    exists. Other status messages, such as **File exists**, may not be as direct but
    still hint at the nature of the problem and point towards a direction to look
    in order to fix the problem.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果加载器被列出，并且预期的文件被列为尝试加载，那么加载器列出的文件状态所暗示的问题。**文件不存在**是一个明确的状态，有一个简单的解决方法。如果 **文件不存在**
    出现得出乎意料，那么请仔细检查文件名。从调试页面复制并粘贴到命令提示符中，尝试显示文件可能会有所帮助，因为它可能有助于澄清加载器尝试加载的文件名与实际存在的文件名之间的差异。其他状态消息，比如
    **文件存在**，可能不那么直接，但仍然暗示了问题的性质，并指向了解决问题的方向。
- en: 'For our example case, the fix is simple: create the `survey/thanks.html` template
    file we forgot to create earlier. This template returns a basic page with a message
    thanking the user for participating in the survey:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例案例，修复很简单：创建我们之前忘记创建的 `survey/thanks.html` 模板文件。这个模板返回一个基本页面，其中包含一条感谢用户参与调查的消息：
- en: '[PRE24]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With this template in place under the `survey/templates` directory, we are
    now able to submit a survey without error. Instead we see:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在`survey/templates`目录下放置了这个模板后，我们现在可以提交一个调查而不会出错。相反，我们看到：
- en: '![Understanding and fixing TemplateDoesNotExist](img/7566_07_15.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![理解和修复TemplateDoesNotExist](img/7566_07_15.jpg)'
- en: Good! Are we now done with displaying a survey and processing results? Not quite.
    We have not yet tested to see what happens if an invalid survey response is submitted.
    We will try that next.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 好！我们现在是否已经完成了显示调查和处理结果？还没有。我们还没有测试提交无效的调查响应会发生什么。接下来我们将尝试。
- en: Handling invalid Survey submissions
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理无效的调查提交
- en: We've already coded the view that handles survey submission to re-display the
    page with errors instead of processing the results, if any errors are found in
    the submitted forms. On the display side, since we are using the `as_p` convenience
    method for displaying the form, it will take care of displaying any errors in
    the forms. So, we should have no code or template changes to make in order to
    see what happens when an invalid survey is submitted.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了处理调查提交的视图，以便在提交的表单中发现任何错误时，重新显示页面并显示错误，而不是处理结果。在显示方面，由于我们使用了`as_p`方便的方法来显示表单，它将负责显示表单中的任何错误。因此，我们不需要进行任何代码或模板更改，就可以看到当提交无效的调查时会发生什么。
- en: 'What would make a survey submission invalid? The only likely error case for
    our `QuestionVoteForm` is if no answer is chosen. What happens, then, if we attempt
    to submit a survey with missing answers? If we try it, we see that the result
    is not ideal:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 什么情况下会使调查提交无效？对于我们的`QuestionVoteForm`来说，唯一可能的错误情况是没有选择答案。那么，如果我们尝试提交一个缺少答案的调查，会发生什么？如果我们尝试，我们会发现结果并不理想：
- en: '![Handling invalid Survey submissions](img/7566_07_16.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![处理无效的调查提交](img/7566_07_16.jpg)'
- en: There are at least two problems here. First, the placement of the error messages,
    above the survey questions, is confusing. It is hard to know what the first error
    message on the page is referring to, and the second error looks like it is associated
    with the first question. It would be better to move the error messages closer
    to where the selection is actually made, such as between the question and answer
    choice list.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这里至少有两个问题。首先，错误消息的放置位置在调查问题上方，这很令人困惑。很难知道页面上的第一个错误消息指的是什么，第二个错误看起来像是与第一个问题相关联的。最好将错误消息移到实际进行选择的地方附近，例如在问题和答案选择列表之间。
- en: Second, the text of the error message is not very good for this particular form.
    Technically the list of answer choices is a single form field, but to a general
    user the word **field** in reference to a list of choices sounds odd. We will
    correct both of these errors next.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，错误消息的文本对于这个特定的表单来说并不是很好。从技术上讲，答案选择列表是一个单一的表单字段，但对于一般用户来说，将**字段**用于选择列表的引用听起来很奇怪。接下来我们将纠正这两个错误。
- en: Coding custom error message and placement
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写自定义错误消息和放置
- en: 'Changing the error message is easy, since Django provides a hook for this.
    To override the value of the error message issued when a required field is not
    supplied, we can specify the message we would like as the value for the `required`
    key in an `error_messages` dictionary we pass as an argument in the field declaration.
    Thus, this new definition for the `answer` field in `QuestionVoteForm` will change
    the error message to `Please select an answer below`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 更改错误消息很容易，因为Django提供了一个钩子。为了覆盖当未提供必填字段时发出的错误消息的值，我们可以在字段声明中作为参数传递的`error_messages`字典中，指定`required`键的值作为我们想要的消息。因此，`QuestionVoteForm`中`answer`字段的新定义将把错误消息更改为`请在下面选择一个答案`：
- en: '[PRE25]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Changing the placement of the error message requires changing the template.
    Instead of using the `as_p` convenience method, we will try displaying the label
    for the answer field, errors for the answer field, and then the answer field itself,
    which displays the choices. The `{% for %}` block that displays the survey forms
    in the `survey/active_survey.html` template then becomes:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 更改错误消息的放置位置需要更改模板。我们将尝试显示答案字段的标签、答案字段的错误以及显示选择的答案字段，而不是使用`as_p`方便的方法。然后在`survey/active_survey.html`模板中显示调查表单的`{%
    for %}`块变为：
- en: '[PRE26]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'How does that work? Better than before. If we try submitting invalid forms
    now, we see:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做有什么效果？比以前好。如果我们现在尝试提交无效的表单，我们会看到：
- en: '![Coding custom error message and placement](img/7566_07_17.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![编写自定义错误消息和放置](img/7566_07_17.jpg)'
- en: While the error message itself is improved, and the placement is better, the
    exact form of the display is not ideal. By default, the errors are shown as an
    HTML unordered list. We could use CSS styling to remove the bullet that is appearing
    (as we will eventually do for the list of choices), but Django also provides an
    easy way to implement custom error display, so we could try that instead.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然错误消息本身得到了改进，放置位置也更好了，但显示的确切形式并不理想。默认情况下，错误显示为HTML无序列表。我们可以使用CSS样式来去除出现的项目符号（就像我们最终会对选择列表做的那样），但Django也提供了一种实现自定义错误显示的简单方法，因此我们可以尝试使用它。
- en: 'To override the error message display, we can specify an alternate `error_class`
    attribute for `QuestionVoteForm`, and in that class, implement a `__unicode__`
    method that returns the error messages with our desired formatting. An initial
    implementation of this change to `QuestionVoteForm` and the new class might be:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了覆盖错误消息的显示，我们可以为`QuestionVoteForm`指定一个替代的`error_class`属性，并在该类中实现一个`__unicode__`方法，以返回我们期望的格式的错误消息。对`QuestionVoteForm`和新类进行这一更改的初始实现可能是：
- en: '[PRE27]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The only change to `QuestionVoteForm` is the addition of setting its `error_class`
    attribute to `PlainErrorList` in its `__init__` method. The `PlainErrorList` class
    is based on the `django.form.util.ErrorList` class and simply overrides the `__unicode__`
    method to return the errors as a string with no special HTML formatting. The implementation
    here makes use of the fact that the base `ErrorList` class inherits from `list`,
    so iterating over the instance itself returns the individual errors in turn. These
    are then joined together with spaces in between, and the whole string is returned.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对`QuestionVoteForm`的唯一更改是在其`__init__`方法中将其`error_class`属性设置为`PlainErrorList`。`PlainErrorList`类基于`django.form.util.ErrorList`类，并简单地重写`__unicode__`方法，以字符串形式返回错误，而不进行特殊的HTML格式化。这里的实现利用了基本的`ErrorList`类继承自`list`，因此对实例本身进行迭代会依次返回各个错误。然后这些错误用空格连接在一起，并返回整个字符串。
- en: Note that we're only expecting there to ever be one error here, but just in
    case we are wrong in that assumption, it is safest to code for multiple errors
    existing. Although our assumption may never be wrong in this case, it's possible
    we might decide to re-use this custom error class in other situations where the
    single possible error expectation doesn't hold. If we code to our assumption and
    simply return the first error in the list, this may result in confusing error
    displays in some situations where there are multiple errors, since we will have
    prevented reporting all but the first error. If and when we get to that point,
    we may also find that formatting a list of errors with just spaces intervening
    is not a good presentation, but we can deal with that later. First, we'd like
    to simply verify that our customization of the error list display is used.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们只希望这里只会有一个错误，但以防万一我们对这个假设是错误的，最安全的做法是编写多个错误存在的代码。尽管在这种情况下我们的假设可能永远不会错，但可能我们会决定在其他情况下重用这个自定义错误类，而单个可能的错误预期不成立。如果我们根据我们的假设编写代码，并简单地返回列表中的第一个错误，这可能会导致在某些情况下出现混乱的错误显示，因为我们将阻止报告除第一个错误之外的所有错误。如果我们到达那一点，我们可能还会发现，仅用空格分隔的错误列表格式不是一个好的展示方式，但我们可以稍后处理。首先，我们只想简单验证我们对错误列表显示的自定义是否被使用。
- en: 'Debug page #5: Another TemplateSyntaxError'
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试页面＃5：另一个TemplateSyntaxError
- en: 'What happens if we try submitting an invalid survey now that we have our custom
    error class specified? An attempt to submit an invalid survey now returns:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们指定了自定义错误类，如果我们尝试提交一个无效的调查会发生什么？现在尝试提交一个无效的调查会返回：
- en: '![Debug page #5: Another TemplateSyntaxError](img/7566_07_18.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![调试页面＃5：另一个TemplateSyntaxError](img/7566_07_18.jpg)'
- en: Oops, we have made another error. The exception value displayed on the second
    line makes it pretty clear that we've mistyped `self` as `sefl`, and since the
    code changes we just made only affected five lines in total, we don't have far
    to look in order to find the typo. But let's take a closer look at this page,
    since it looks a little different than the other `TemplateSyntaxError` we encountered.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，我们又犯了一个错误。第二行显示的异常值非常清楚地表明我们将`self`误输入为`sefl`，由于我们刚刚做的代码更改总共只影响了五行，所以我们不需要花太多时间来找到这个拼写错误。但让我们仔细看看这个页面，因为它看起来与我们遇到的其他`TemplateSyntaxError`有些不同。
- en: 'What is different about this page compared to the other `TemplateSyntaxError`?
    Actually, there is nothing structurally different; it contains all the same sections
    with the same contents. The notable difference is that the exception value is
    not a single line, but is rather a multi-line message containing an **Original
    Traceback**. What is that? If we take a look at the traceback section of the debug
    page, we see it is rather long, repetitive, and uninformative. The end portion,
    which is usually the most interesting part of a traceback, is:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这一页与其他`TemplateSyntaxError`相比有什么不同？实际上，在结构上并没有什么不同；它包含了所有相同的部分和相同的内容。显著的区别在于异常值不是单行的，而是一个包含**原始回溯**的多行消息。那是什么？如果我们看一下调试页面的回溯部分，我们会发现它相当长、重复且无信息。通常最有趣的部分是结尾部分，它是：
- en: '![Debug page #5: Another TemplateSyntaxError](img/7566_07_19.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![调试页面＃5：另一个TemplateSyntaxError](img/7566_07_19.jpg)'
- en: Every line of code cited in that traceback is Django code, not our application
    code. Yet, we can be pretty sure the problem here was not caused by the Django
    template processing code, but rather by the change we just made to `QuestionVoteForm`.
    What's going on?
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个回溯中引用的每一行代码都是Django代码，而不是我们的应用程序代码。然而，我们可以非常确定这里的问题不是由Django模板处理代码引起的，而是由我们刚刚对`QuestionVoteForm`进行的更改引起的。发生了什么？
- en: What has happened here is that an exception was raised during the rendering
    of a template. Exceptions during rendering are caught and turned into `TemplateSyntaxErrors`.
    The bulk of the stack trace for the exception will likely not be interesting or
    helpful in terms of solving the problem. What will be more informative is the
    stack trace from the original exception, before it was caught and turned into
    a `TemplateSyntaxError`. This stack trace is made available as the **Original
    Traceback** portion of the exception value for the `TemplateSyntaxError` which
    is ultimately raised.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的是在渲染模板时引发了一个异常。渲染期间的异常会被捕获并转换为`TemplateSyntaxErrors`。异常的大部分堆栈跟踪可能不会对解决问题有趣或有帮助。更有信息的是原始异常的堆栈跟踪，在被捕获并转换为`TemplateSyntaxError`之前。这个堆栈跟踪作为最终引发的`TemplateSyntaxError`的异常值的**原始回溯**部分提供。
- en: A nice aspect of this behavior is that the significant part of what is likely
    a very long traceback is highlighted at the top of the debug page. An unfortunate
    aspect is that the significant part of the traceback is no longer available in
    the traceback section itself, thus the special features of the traceback section
    of the debug page are not available for it. It is not possible to expand the context
    around the lines identified in the original traceback, nor to see the local variables
    at each level of the original traceback. These limitations will not cause any
    difficulty in solving this particular problem, but can be annoying for more obscure
    errors.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为的一个好处是，很可能是非常长的回溯的重要部分在调试页面的顶部被突出显示。一个不幸的方面是，回溯的重要部分在回溯部分本身不再可用，因此调试页面的回溯部分的特殊功能对其不可用。不可能扩展原始回溯中标识的行周围的上下文，也无法看到原始回溯每个级别的局部变量。这些限制不会导致解决这个特定问题时出现任何困难，但对于更晦涩的错误可能会很烦人。
- en: Note
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that Python 2.6 introduced a change to the base `Exception` class that
    causes the **Original Traceback** information mentioned here to be omitted in
    the display of the `TemplateSyntaxError` exception value. Thus, if you are using
    Python 2.6 and Django 1.1.1, you will not see the **Original Traceback** included
    on the debug page. This will likely be corrected in newer versions of Django,
    since losing the information in the **Original Traceback** makes it quite hard
    to debug the error. The fix for this problem may also address some of the annoyances
    previously noted, related to `TemplateSyntaxErrors` wrapping other exceptions.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Python 2.6对基本的`Exception`类进行了更改，导致在显示`TemplateSyntaxError`异常值时省略了此处提到的**原始回溯**信息。因此，如果您使用的是Python
    2.6和Django 1.1.1，您将看不到调试页面上包括**原始回溯**。这可能会在Django的新版本中得到纠正，因为丢失**原始回溯**中的信息会使调试错误变得非常困难。这个问题的解决方案也可能解决先前提到的一些烦人的问题，与`TemplateSyntaxErrors`包装其他异常有关。
- en: Fixing the second TemplateSyntaxError
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修复第二个TemplateSyntaxError
- en: 'Fixing this second `TemplateSyntaxError` is straightforward: simply correct
    the `sefl` typo on the line noted in the original traceback. When we do that and
    again try to submit an invalid survey, we see in response:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 修复这个第二个`TemplateSyntaxError`很简单：只需在原始回溯中指出的行上纠正`sefl`拼写错误。当我们这样做并再次尝试提交无效的调查时，我们会看到响应：
- en: '![Fixing the second TemplateSyntaxError](img/7566_07_20.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![修复第二个TemplateSyntaxError](img/7566_07_20.jpg)'
- en: That is not a debug page, so that is good. Furthermore, the error messages are
    no longer appearing as HTML unordered lists, which was our goal for this change,
    so that is good. Their exact placement may not quite be exactly what we want,
    and we may want to add some CSS styling so that they stand out more prominently,
    but for now they will do.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 那不是一个调试页面，所以很好。此外，错误消息不再显示为HTML无序列表，这是我们对此更改的目标，所以很好。它们的确切位置可能不完全是我们想要的，我们可能希望添加一些CSS样式，使它们更加突出，但现在它们会做到这一点。
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'We have now completed the implementation of survey voting, and the in-depth
    coverage of Django debug pages. In this chapter, we:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了调查投票的实施，并对Django调试页面进行了深入的覆盖。在本章中，我们：
- en: Set out to replace the placeholder view and template for display of an active
    Survey with a real implementation
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 着手用真正的实现替换活动调查的占位符视图和模板以进行显示
- en: Made some typical mistakes during implementation, which led to us being presented
    with five different Django debug pages
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实施过程中犯了一些典型的错误，导致我们看到了五个不同的Django调试页面。
- en: On encountering the first debug page, learned about all of the different sections
    of debug pages and what information is included in each
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在遇到第一个调试页面时，了解了调试页面的所有不同部分以及每个部分包含的信息
- en: For each debug page encountered, used the information presented to locate and
    correct the coding error
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个遇到的调试页面，使用呈现的信息来定位和纠正编码错误
- en: In the next chapter, we will proceed to learn techniques for gathering debug
    information even when the code is not causing a debug page to be displayed.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续学习即使代码没有导致调试页面显示也能收集调试信息的技术。
