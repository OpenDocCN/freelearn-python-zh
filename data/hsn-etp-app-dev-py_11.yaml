- en: Taking the Microservices Approach
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采用微服务方法
- en: So far in this book, we have learned about how to develop an enterprise-grade
    application and how to mature our processes so that the application we deliver
    meets our standards of quality and provides a robust and resilient experience
    to its users. In this chapter, we will take a look at a new paradigm for developing
    applications, where the application is not a single product but rather a combination
    of multiple products interacting with each other to provide a unified experience.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，我们已经了解了如何开发企业级应用程序以及如何成熟我们的流程，以便我们交付的应用程序符合我们的质量标准，并为其用户提供强大而有韧性的体验。在本章中，我们将看看一种新的应用程序开发范式，其中应用程序不是一个单一的产品，而是多个产品相互交互，以提供统一的体验。
- en: Over recent years, development scenarios have changed rapidly. Application development
    has moved from developing large monoliths to developing smaller services, all
    of which interact with each other to provide the desired result to the user. This
    change has come to meet the demand for faster shipping of projects in order to
    increase the ability to add new features and improve the scalability of the application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，开发场景发生了快速变化。应用程序开发已经从开发大型单体转变为开发小型服务，所有这些服务相互交互，为用户提供所需的结果。这种变化是为了满足更快地发布项目的需求，以增加添加新功能和提高应用程序可扩展性的能力。
- en: Over the course of this chapter, we will take a look at this new paradigm of
    application development where teams have become smaller and the ability to ship
    new features inside an application at an ever-reducing cost has become the new
    standard. This paradigm, known as the microservices development approach, has
    radically changed the way in which application development cycles work, and has
    also led to the current trend toward techniques related to DevOps, continuous
    integration, and deployments.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看看这种新的应用程序开发范式，团队变得更小，能够以越来越低的成本在应用程序中发布新功能已经成为新的标准。这种被称为微服务开发方法的范式彻底改变了应用程序开发周期的工作方式，并且还导致了与DevOps、持续集成和部署相关的技术的当前趋势。
- en: 'As you progress through this chapter, you will learn about the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 随着本章的进行，您将了解以下内容：
- en: Moving toward the microservices development approach
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 朝着微服务开发方法迈进
- en: API-driven communication between services
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务之间基于API的通信
- en: Building robust microservices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建健壮的微服务
- en: Handling user-server interaction in microservices
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理微服务中的用户-服务器交互
- en: Asynchronous communication between microservices
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务之间的异步通信
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code listings in this book can be found under `chapter11` directory at [https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python.](https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的代码清单可以在[https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python](https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python)的`chapter11`目录下找到。
- en: 'The code samples can be cloned by running the following command:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过运行以下命令克隆代码示例：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The steps to set up and run the code have been included inside the `README.md`
    file inside the directory to give a deeper context about the code samples.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 设置和运行代码的步骤已包含在`README.md`文件中，以便更深入地了解代码示例。
- en: The shift toward microservices
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向微服务开发方法转变
- en: Over the last few years, developers have been trying to experiment with new
    ways in which they can develop applications. The aim of this is to reduce the
    time of development life cycles, increasing the ability to ship projects faster
    into production, increasing the decoupling between the components so that they
    can be developed independently, and improving the parallelism of the teams working
    on the development of the application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年里，开发人员一直在尝试用新的方式来开发应用程序。其目的是缩短开发生命周期，增加更快地将项目投入生产的能力，增加组件之间的解耦，使它们可以独立开发，并提高团队并行开发应用程序的能力。
- en: With this came the development technique of using microservices, which helped
    in solving the aforementioned use cases. In this approach, the application is
    not a single large repository of code where all the components are placed together,
    and where a single change to any of the components requires the deployment of
    the whole application again. First, let's look at how the microservices model
    differs from the monolithic model and then see what advantages there are in following
    the microservices approach.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 随之而来的是使用微服务的开发技术，这有助于解决上述的用例。在这种方法中，应用程序不是一个单一的大型代码库，所有组件都放在一起，对任何组件的单一更改都需要再次部署整个应用程序。首先，让我们看看微服务模型与单体模型的不同之处，然后看看遵循微服务方法有哪些优势。
- en: Monolithic development model versus microservices
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单体开发模型与微服务
- en: We are all accustomed to building an application where a single code base consists
    of all the functional components of an application, closely tied together to achieve
    a certain desired result. These applications follow a rigorous development approach
    where the functioning and architecture of the application is first thought of
    during the initial requirement-gathering and design phases, and then the rigorous
    development of the application starts.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都习惯于构建一个应用程序，其中单个代码库包含应用程序的所有功能组件，紧密地联系在一起，以实现特定的期望结果。这些应用程序遵循严格的开发方法，应用程序的功能和架构首先在初始需求收集和设计阶段进行思考，然后应用程序的严格开发开始。
- en: 'It is only after all the components have been developed and thoroughly tested
    that an application enters the production stage, where it is deployed on the infrastructure
    for regular use. This model is shown in the following diagram:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在所有组件都经过开发和彻底测试后，应用程序才进入生产阶段，在那里它被部署在基础设施上供常规使用。这个模型在下图中显示：
- en: This process ...
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程...
- en: Advantages of the microservices architecture
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务架构的优势
- en: 'The microservices architecture solves a lot of problems for us, mostly because
    of the changes in the way in which we develop and deploy the microservices. Let''s
    go through some of the advantages that the microservices architecture brings to
    our development process, as shown in the following list:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构为我们解决了许多问题，主要是因为我们开发和部署微服务的方式发生了变化。让我们来看看微服务架构为我们的开发过程带来的一些优势，如下列表所示：
- en: '**Small teams:** Since a particular microservice usually focuses on doing one
    thing and doing it well, the teams responsible for building that microservice
    can usually be small. A team can own multiple microservices end to end, where
    they are not only responsible for their development but also their deployment
    and management, giving rise to a good DevOps culture.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小团队：**由于一个特定的微服务通常专注于做一件事并且做得很好，负责构建该微服务的团队通常可以很小。一个团队可以全面拥有多个微服务，他们不仅负责开发，还负责部署和管理，从而形成良好的DevOps文化。'
- en: '**Increased independence:** In a microservices architecture, the team responsible
    for the development of one microservice does not need to have complete knowledge
    of how another microservice works internally. The teams only need to take care
    of the API endpoints that have been exposed by the microservice in order to interact
    with it. This avoids the dependence of teams on each other to carry out their
    development activities.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强了独立性：**在微服务架构中，负责开发一个微服务的团队不需要完全了解另一个微服务的内部工作方式。团队只需要关注微服务暴露的API端点，以便与其进行交互。这避免了团队在开展开发活动时对彼此的依赖。'
- en: '**Increased resilience to failures:** In a microservices architecture, the
    failure resilience is quite high because of the fact that a malfunction in one
    microservice won''t affect the whole application, and will rather provide a gradual
    degradation of the service. During this time, a new instance of the failing service
    might be launched, or the failing service can be easily isolated for debugging
    so as to reduce the impact.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强了对故障的韧性：**在微服务架构中，由于一个微服务的故障不会影响整个应用程序，而是会逐渐降低服务的性能，因此故障韧性相当高。在此期间，可能会启动一个新的失败服务实例，或者可以轻松地将失败服务隔离以进行调试，以减少影响。'
- en: '**Increased scalability:** The microservices architecture provides a lot of
    freedom in the scalability of the application. Now, as the load increases, the
    individual microservices can be scaled up independently instead of scaling the
    whole application up. This scaling can happen as horizontal scaling, where more
    instances of a select set of microservices can be launched depending upon the
    load being experienced by the application, or these services can be individually
    scaled up using vertical scaling, where more resources are dedicated to a particular
    service to allow for better handling of the increasing load.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强了可扩展性：**微服务架构为应用程序的可扩展性提供了很大的自由度。现在，随着负载的增加，可以独立地扩展各个微服务，而不是整体扩展应用程序。这种扩展可以以水平扩展的方式进行，根据应用程序所经历的负载，可以启动更多的特定微服务实例，或者可以使用垂直扩展的方式单独扩展这些服务，为特定服务分配更多资源，以便更好地处理不断增加的负载。'
- en: '**Easy integration:** With microservices, the integration between the different
    services is easy, as no knowledge of the internals of the other microservices
    is required. All the integration happens while assuming the other microservices
    to be black boxes.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单集成：**使用微服务，不需要了解其他微服务内部的知识，因此不需要了解其他微服务的内部情况，不需要了解其他微服务的内部情况。所有的集成都是在假设其他微服务是黑匣子的情况下进行的。'
- en: '**Increased reusability:** Once developed, a microservice can be utilized in
    different applications. For example, a microservice that''s responsible for the
    handling of user authentication can be reused in multiple applications, which
    may require user authentication without the replication of the code.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强了可重用性：**一旦开发完成，一个微服务可以在不同的应用程序中被利用。例如，负责用户认证处理的微服务可以在多个应用程序中重复使用，而无需复制代码。'
- en: '**Freedom to roll** **out new features with ease:** With the microservices
    architecture, new features can be rolled out easily. In most cases, a particular
    feature is converted into its own microservice, and the service is then deployed
    in production after proper testing. Once the service is live in production, its
    features are available for use. This differs from the monolithic approach, where
    the whole application needs to be redeployed when a new feature or improvement
    needs to be deployed to production environments.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轻松推出新功能的自由：**使用微服务架构，新功能可以轻松推出。在大多数情况下，特定功能被转换为自己的微服务，然后在经过适当测试后部署到生产环境。一旦服务在生产环境中上线，其功能就可以使用。这与整体式方法不同，整个应用程序需要在新功能或改进需要部署到生产环境时重新部署。'
- en: From this list, we can see a number of benefits that the move toward a microservices
    architecture provides us with. From the choice of the tools to the ease in rolling
    out new features, the microservices architecture makes it lucrative for developers
    to hop into the wagon and quickly start rolling out new microservices.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个列表中，我们可以看到微服务架构向我们提供了许多好处。从工具的选择到快速推出新功能的便利性，微服务架构使开发人员有利可图，并迅速开始推出新的微服务。
- en: But all of these advantages do not come for free. As much as there are advantages,
    there is also the possibility of creating a mess of the infrastructure while working
    on the microservices architecture, which may not only create increased costs.
    However, this may also impact the overall productivity of the team, which may
    end up more focused on firefighting the issues that may arise because of the flawed
    implementation of the architecture rather than focusing on the improvement and
    development of the features that may be essential to the users of the application.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 但所有这些优势并非免费。尽管有优势，但在微服务架构中工作时也有可能创建基础设施的混乱，这不仅会增加成本。然而，这也可能影响团队的整体生产力，他们可能更专注于解决因架构实施不当而可能出现的问题，而不是专注于改进和开发对应用程序用户至关重要的功能。
- en: This is nothing to worry about. We can follow a few simple pieces of advice
    that can help a lot during our journey with the microservices architecture. So,
    let's spend some time understanding these simple tips, which can go a long way
    in helping us make our microservices journey smooth.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是什么大问题。我们可以遵循一些简单的建议，在微服务架构的旅程中会有很大帮助。因此，让我们花些时间了解这些简单的技巧，这些技巧可以帮助我们顺利进行微服务的旅程。
- en: Guidelines for microservice development
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务开发指南
- en: 'The development of microservices is challenging, and getting them right is
    quite hard. Is there something we can do to make this process easier? It turns
    out that there are a couple of guidelines that, if followed, can help a lot in
    getting microservices right. So, let''s take a look at these guidelines, as shown
    in the following list:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的开发是具有挑战性的，而且很难做到完美。有没有什么方法可以让这个过程变得更容易？事实证明，有一些指南，如果遵循，可以在微服务的开发中提供很大帮助。因此，让我们看一下以下列表中所示的这些指南：
- en: '**Design before developing**: When microservices development takes place, they
    are usually supposed to model a particular domain of responsibility. But this
    is also the point where the biggest mistakes occur. Usually, the boundaries of
    a service are not defined. During the later stages, as the domain evolves, the
    microservice also becomes complex so as to handle the increased ...'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发前的设计**：当进行微服务开发时，它们通常应该模拟特定的责任领域。但这也是最常出现最大错误的地方。通常情况下，服务的边界没有定义。在后期阶段，随着领域的发展，微服务也变得复杂，以处理增加的...'
- en: Service discovery in microservices
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务中的服务发现
- en: In traditional models of application development, the services pertaining to
    a particular application are usually deployed in a static manner where their network
    locations do not change automatically. If this is the case, then maintaining a
    configuration file that is updated occasionally to reflect the changed network
    location of the services is absolutely fine.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序开发的传统模型中，通常会以静态方式部署特定应用程序的服务，它们的网络位置不会自动更改。如果是这种情况，那么偶尔更新配置文件以反映服务的更改网络位置是完全可以的。
- en: But in modern microservice-based applications—where the number of services may
    go up and down based on a number of factors, such as load balancing, upscaling,
    the launch of new features, and so on—maintaining a configuration file turns out
    to be a bit hard. In addition, most cloud environments these days do not offer
    static network deployments for these services, meaning that the network location
    for the services may keep on changing, adding more trouble to the maintenance
    of the configuration file.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 但在现代基于微服务的应用程序中，服务的数量可能会根据多种因素而上下波动，例如负载平衡、扩展、新功能的推出等，因此维护配置文件会变得有些困难。此外，如今大多数云环境都不提供这些服务的静态网络部署，这意味着服务的网络位置可能会不断变化，增加了维护配置文件的麻烦。
- en: To tackle these kinds of scenarios, we need to have something that is more dynamic
    and can adapt to the changing environment. Enter the concept of service discovery.
    Service discovery allows for the dynamic resolution of the network endpoints of
    a required service and removes the need for a manually updated configuration file.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些情况，我们需要有一些更加动态的东西，可以适应不断变化的环境。这就是服务发现的概念。服务发现允许动态解析所需服务的网络端点，并消除了手动更新配置文件的需要。
- en: 'The service discovery usually comes in the following two flavors:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 服务发现通常有以下两种方式：
- en: Client-side service discovery
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端服务发现
- en: Server-side service discovery
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端服务发现
- en: But before we cover these two approaches, we need to understand one more important
    component of the service discovery system. Let's take a look at what this important
    component is and how it facilitates the service discovery process.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 但在讨论这两种方法之前，我们需要了解服务发现系统的另一个重要组件。让我们看看这个重要组件是什么，以及它如何促进服务发现过程。
- en: Client-side service discovery
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端服务发现
- en: 'With the client-side service discovery method, the individual services need
    to be aware of the service registry. For example, in this model, if **Service
    Instance A** wants to make a request to **Service Instance C**, then the process
    of making this request will be as shown in the following diagram:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用客户端服务发现方法，各个服务需要知道服务注册表。例如，在这种模型中，如果**服务实例A**想要向**服务实例C**发出请求，那么进行此请求的过程如下图所示：
- en: '![](Images/87d24590-eb4f-4df1-822c-da856ddefd76.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/87d24590-eb4f-4df1-822c-da856ddefd76.png)'
- en: 'The flow of the request is explained as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 请求的流程如下所示：
- en: '**Service Instance A** queries the service registry for the network address
    of **Service Instance C**.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务实例A**查询服务注册表以获取**服务实例C**的网络地址。'
- en: The **Service Registry** checks its database for the network address of **Service Instance
    C** and returns it to **Service Instance A**. In case **Service Instance C** is
    a load balanced service ...
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务注册表**检查其数据库以获取**服务实例C**的网络地址，并将其返回给**服务实例A**。如果**服务实例C**是负载平衡服务...'
- en: Server-side service discovery
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端服务发现
- en: 'With the server-side service discovery pattern, the ability to resolve the
    network address of the services is not present inside the individual clients—rather,
    this logic is moved into the load balancer. Inside a server-side service discovery
    pattern, a request flow looks like the following diagram:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用服务器端服务发现模式，解析服务的网络地址的能力不在个体客户端内部——相反，这个逻辑被移动到负载均衡器中。在服务器端服务发现模式中，请求流程如下图所示：
- en: '![](Images/2af7c994-b611-4963-8c6d-50a842bfaac0.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2af7c994-b611-4963-8c6d-50a842bfaac0.png)'
- en: 'This diagram shows the following process:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表显示了以下过程：
- en: The **Client** makes a request for an API endpoint
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**客户端**发出对API端点的请求'
- en: The **Load Balancer** intercepts the request and queries the **Service Registry**
    to resolve the network address for the appropriate service
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**负载均衡器**拦截请求并查询**服务注册表**以解析适当服务的网络地址'
- en: The **Load Balancer** then sends the request to the appropriate network service
    to handle the request
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**负载均衡器**然后将请求发送到适当的网络服务来处理请求'
- en: The advantage of this pattern comes in the form of a reduction of code duplication
    by the removal of service discovery logic from the clients and better load balancing
    because the service registry is not taking up the load of the load-balancing algorithms.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的优势在于通过从客户端中删除服务发现逻辑来减少代码重复，并且由于服务注册表不负担负载均衡算法的负载，因此负载均衡更好。
- en: Now that we know how service discovery happens inside a microservices architecture,
    let's focus our efforts on understanding another interesting concept inside microservices.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了微服务架构中服务发现是如何发生的，让我们把重点放在理解微服务中另一个有趣的概念上。
- en: Imagine that you are building an application that is supposed to handle multiple
    devices and the functionality provided to every device differs based on certain
    aspects such as mobile devices will not have feature for allowing to send a direct
    message to other users. In this case, every device will require a different API
    endpoint that it can call to access its specific set of services. However, making
    the clients aware of every single API endpoint can become an issue during the
    maintenance phases of the application, or when some of the APIs change. To handle
    these kinds of scenarios, we need to have something that can act as an intermediate
    layer for our communication.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在构建一个应用程序，该应用程序应该处理多个设备，并且每个设备提供的功能根据某些方面而有所不同，比如移动设备将不具备向其他用户发送直接消息的功能。在这种情况下，每个设备都需要一个不同的API端点，以便调用其特定的服务集。然而，在应用程序的维护阶段或某些API发生变化时，让客户端了解每个单独的API端点可能会成为一个问题。为了处理这种情况，我们需要有一些可以作为我们通信的中间层的东西。
- en: Fortunately, inside the microservices architecture, we have something to help
    us with this problem. Let's take a look at what we have at our disposal.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在微服务架构中，我们有一些东西可以帮助我们解决这个问题。让我们看看我们可以利用什么。
- en: Service-level agreements in microservices
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务中的服务级别协议
- en: During the development of any production-grade application based upon microservices
    architecture, the services might depend a lot upon the availability of the other
    services deployed in production. For example, a service providing functionality
    to the administration panel for the application might require the availability
    of the user authentication service to allow for administrator logins and privilege
    management. In case the user management service goes down, there can be severe
    consequences in the stability of the operations provided by the application.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于微服务架构的任何生产级应用程序的开发过程中，服务可能会在很大程度上依赖于生产环境中部署的其他服务的可用性。例如，为应用程序的管理面板提供功能的服务可能需要用户认证服务的可用性，以允许管理员登录和权限管理。如果用户管理服务出现故障，应用程序提供的操作的稳定性可能会受到严重影响。
- en: To guarantee these kinds of requirements, we need to have SLAs that act as contracts
    between the teams delivering particular microservices. These ...
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保证这些要求，我们需要有作为团队之间特定微服务交付的合同的SLA。这...
- en: Building your first microservices application
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建你的第一个微服务应用程序
- en: We are now ready to build our first application using the microservices architecture.
    During the development of this application, we will get to see how we can utilize
    the knowledge that we have gained so far to roll out a working application.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备使用微服务架构构建我们的第一个应用程序。在开发这个应用程序的过程中，我们将看到如何利用我们迄今为止所获得的知识来推出一个可工作的应用程序。
- en: 'Now, regarding our example, to keep this application simple and provide an
    easy understanding of how the microservices architecture works, we will build
    a simple to-do-list-creation application: Let''s take a look at how this application
    will look, as stipulated in the following list:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关于我们的例子，为了保持这个应用程序简单，并且提供对微服务架构工作原理的简单理解，我们将构建一个简单的待办事项创建应用程序：让我们看看这个应用程序将会是什么样子，如下列表所规定的：
- en: The application will consist of two microservices—namely the to-do manager service
    and the user authentication service
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该应用程序将由两个微服务组成——即待办事项管理服务和用户认证服务
- en: The services will be developed in Python
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些服务将使用Python开发
- en: For the purpose of this exercise, the services will utilize their own SQLite
    databases
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了这个练习，服务将利用它们自己的SQLite数据库
- en: The to-do service will depend upon the user service to gather any kind of information
    related to the user operations, including user authentication, profile fetching,
    and so on
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 待办事项服务将依赖用户服务来收集与用户操作相关的任何信息，包括用户认证、配置获取等
- en: The services will communicate through the use of RESTful APIs, each providing
    a JSON-encoded response
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务将通过使用RESTful API进行通信，每个服务提供JSON编码的响应
- en: With the basic requirements specified, it's now time for us to start writing
    our microservices.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 具体要求已经指定，现在是时候开始编写我们的微服务了。
- en: The user microservice
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户微服务
- en: 'The user microservice is responsible for handling anything related to user
    profile management. The service facilitates the following functionalities:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 用户微服务负责处理与用户配置文件管理相关的任何事务。该服务提供以下功能：
- en: Registration of new users
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册新用户
- en: Management of user profiles
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户配置文件管理
- en: Authentication of existing users
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有用户的身份验证
- en: Generating unique authentication tokens for the user to log in with
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为用户生成唯一的身份验证令牌以登录
- en: Providing user authentication functionality to other services
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为其他服务提供用户认证功能
- en: 'For this service to operate, we need to have the following two database models:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使该服务运行，我们需要以下两个数据库模型：
- en: '**User database model:** The user database model is responsible for the management
    of the user records, such as their username, hashed passwords, and so on.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户数据库模型：** 用户数据库模型负责管理用户记录，如他们的用户名、哈希密码等。'
- en: '**Token database model:** The token database model is responsible for storing
    information about the tokens that has been generated ...'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**令牌数据库模型：** 令牌数据库模型负责存储已生成的令牌的信息...'
- en: The to-do manager service
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 待办事项管理器服务
- en: The to-do manager service is the service that will help our users manage their
    `todo` items. This service provides the functionality for the user to create a
    new list and add items to the list. For this, the only requirement is that the
    user should be authenticated.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 待办事项管理器服务是帮助用户管理其`todo`项目的服务。该服务提供了用户创建新列表并向列表添加项目的功能。为此，唯一的要求是用户应该经过身份验证。
- en: To work correctly, the service will require the presence of a list database
    model, which will be used to store the information about the user-created `todo`
    list and an items model, which will contain the list of items for a particular
    `todo` list.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确工作，服务将需要存在一个列表数据库模型，用于存储用户创建的`todo`列表的信息，以及一个项目模型，其中将包含特定`todo`列表的项目列表。
- en: 'The following snippet of code implements these models:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段实现了这些模型：
- en: '[PRE1]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once these models have been developed, the next thing we have to do is implement
    the APIs.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦开发了这些模型，我们需要做的下一件事就是实现API。
- en: 'For the to-do manager service, the following APIs will be in place, providing
    the interaction endpoints for the service:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于待办事项管理器服务，将设置以下API，为服务提供交互端点：
- en: '`/list/new`: This API endpoint takes in the name of the list to be created
    and creates a new list.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/list/new`：此API端点接受要创建的列表的名称并创建新列表。'
- en: '`/list/add_item`: This API endpoint takes in the list of the items that need
    to be added to the list and the name of the list in which the items are supposed
    to be added. Once validated, the items are added to the list.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/list/add_item`：此API端点接受需要添加到列表中的项目列表以及应将项目添加到的列表的名称。一旦验证通过，项目将被添加到列表中。'
- en: '`/list/view`: This API endpoint takes the name of the list for which the contents
    need to be displayed and displays the content of the list.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/list/view`：此API端点接受需要显示内容的列表的名称，并显示列表的内容。'
- en: 'The following snippet of code shows the endpoint implementations for the service:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了服务的端点实现：
- en: '[PRE2]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With the preceding code in place, we are now ready with our to-do manager service,
    which will help us create and manage our to-do lists through the use of RESTful
    APIs.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有了上述代码，我们现在已经准备好使用我们的待办事项管理器服务，它将通过RESTful API帮助我们创建和管理待办事项列表。
- en: 'But before we get the to-do manager service to execute, we need to remember
    one important thing. The service is dependent upon the user service to perform
    any kind of user authentication and to fetch information about the user profile.
    For this to happen, our to-do manager needs to know where the user service is
    running so that it can interact with the user service. For this example, we achieve
    this by setting up a configuration key for the user service endpoint inside the
    to-do manager service configuration file. The following snippet shows the contents
    of the to-do manager service configuration file:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们执行待办事项管理器服务之前，我们需要记住一件重要的事情。该服务依赖于用户服务来执行任何类型的用户认证并获取有关用户配置文件的信息。为了实现这一点，我们的待办事项管理器需要知道用户服务在哪里运行，以便可以与用户服务进行交互。在这个例子中，我们通过在待办事项管理器服务配置文件中设置用户服务端点的配置键来实现这一点。以下代码片段显示了待办事项管理器服务配置文件的内容：
- en: '[PRE3]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To get the to-do manager service running, the following command needs to be
    executed from inside the `todo_service` directory, inside the repository:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要使待办事项管理器服务运行，需要从存储库的`todo_service`目录内执行以下命令：
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once the command executes successfully, the to-do manager service will be available
    at `http://localhost:5001/`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦命令成功执行，待办事项管理器服务将在`http://localhost:5001/`上可用。
- en: 'Once the service is up and running, we can utilize its API to manage our inventory.
    For example, if we wanted to create a new to-do list, all we need to do is send
    an HTTP POST request to the `http://localhost:5001/list/new` API endpoint, passing
    the following keys as JSON formatted inputs:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务启动运行，我们可以利用其API来管理我们的清单。例如，如果我们想要创建一个新的待办事项列表，我们只需要向`http://localhost:5001/list/new`
    API端点发送HTTP POST请求，传递以下键作为JSON格式的输入：
- en: '`auth_token`**:** This is the authentication token the user receives after
    successfully logging in with the user service using the `http://localhost:5000/auth/login`
    API endpoint'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auth_token`**：** 这是用户在使用`http://localhost:5000/auth/login` API端点成功登录用户服务后收到的身份验证令牌'
- en: '`list_name`**:** This is the name of the new list that is to be created'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list_name`**：** 这是要创建的新列表的名称'
- en: Once the API endpoint call is made, the to-do manager service first makes an
    attempt to validate the `auth` token provided in the API call by interacting with
    the user service. If the `auth` token is validated, the to-do manager service
    then receives a user ID that is used to identify the user. With this complete,
    the to-do manager service creates an entry for the new to-do list inside its database
    against the user ID that has been retrieved.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦API端点调用完成，待办事项管理器服务首先尝试通过与用户服务交互来验证API调用中提供的“auth”令牌。如果“auth”令牌验证通过，待办事项管理器服务将接收一个用于识别用户的用户ID。完成这一步后，待办事项管理器服务会在其数据库中为新的待办事项列表创建一个条目，并针对检索到的用户ID。
- en: This was a simple workflow of the to-do manager service.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是待办事项管理器服务的简单工作流程。
- en: Now that we understand how we can build a simple microservice, we can now focus
    on some interesting topics regarding the microservices architecture. Did you notice
    how we informed our to-do manager service of the presence of the user service?
    We utilized a configuration key to achieve this. Using the configuration key is
    by no means a bad option when all you have is two or three services that, no matter
    what happens, will always run on the same endpoints. However, this approach breaks
    down badly when the microservices number even moderately more than two or three
    services, which may run anywhere on the infrastructure.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了如何构建一个简单的微服务，我们现在可以专注于有关微服务架构的一些有趣的主题。你是否注意到我们如何告知待办事项管理器服务用户服务的存在？我们利用了配置密钥来实现这一点。当你只有两个或三个服务，无论发生什么，它们总是在相同的端点上运行时，使用配置密钥绝不是一个坏选择。然而，当微服务的数量甚至比两个或三个服务稍微多一点时，这种方法会严重崩溃，因为它们可能在基础设施的任何地方运行。
- en: To add on to these troubles, the problem intensifies even further if new services
    are being brought into production frequently to add new features to the application.
    At this point, we will need something better that should not only provide an easy
    way to identify the new services, but also automatically resolve their endpoints.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，如果新服务频繁投入生产以为应用程序添加新功能，问题会进一步加剧。在这一点上，我们需要更好的解决方案，不仅应提供一种简单的方式来识别新服务，还应自动解析它们的端点。
- en: Service registry inside microservices
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务内的服务注册表
- en: Say there is a magic show that is going to take place inside an auditorium.
    This show is open to everyone, and anyone can come to the auditorium to attend
    it. At the gate of the auditorium, there is a registration desk where you need
    to register before you can enter the auditorium. As soon as the audience members
    start coming, they first go to the registration desk, provide their information—such
    as their names, addresses, and so on—and are then given a ticket to enter the
    auditorium.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一场魔术表演将在礼堂内举行。这场表演对所有人开放，任何人都可以来礼堂参加。在礼堂的门口，有一个登记处，你需要在进入礼堂之前先登记。当观众开始到来时，他们首先去登记处，提供他们的信息，比如他们的姓名、地址等，然后被给予一张入场券。
- en: The service registry is something like this. It is a special kind of database
    that keeps a record of which services are running on an infrastructure and where
    they are located. Whenever a new service comes up, it registers ...
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 服务注册表就像这样。它是一种特殊类型的数据库，记录了基础设施上运行的服务以及它们的位置。每当新服务启动时，它都会注册...
- en: API gateways in microservices
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务中的API网关
- en: When building a microservices architecture, we have a lot of choices, and we
    are mostly free to choose a technology stack that is best suited for implementing
    a microservice. Along with this, we always have an option to render different
    features for different devices by rolling out a different microservice that is
    specific to them. But when we do this, we also add complexity to the client, which
    now has to handle all these different scenarios.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建微服务架构时，我们有很多选择，大多数情况下可以自由选择最适合实现微服务的技术栈。除此之外，我们始终可以通过推出针对特定设备的不同微服务来为不同设备提供不同的功能。但是当我们这样做时，我们也给客户端增加了复杂性，现在客户端必须处理所有这些不同的情况。
- en: 'So, let''s first take a look at the challenges we may face on the client side,
    as shown in the following diagram:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们首先看一下客户端可能面临的挑战，如下图所示：
- en: '![](Images/5a3e46ee-c709-497a-9ada-9dc57c1ad77c.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/5a3e46ee-c709-497a-9ada-9dc57c1ad77c.png)'
- en: 'The preceding diagram shows the challenges that we face, as shown in the following
    list:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表显示了我们面临的挑战，如下列表所示：
- en: '**Handling different APIs:** When every device has a specific microservice
    that provides the set of features that it requires, the client for that device
    needs to know about the API endpoints related to that specific service. This adds
    complexity because now the team that is responsible for handling the development
    of the clients needs to be aware of the microservice-specific endpoints that may
    slow down the process of client development.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理不同的API：** 当每个设备都有一个特定的微服务，为其提供所需的功能集时，该设备的客户端需要了解与该特定服务相关的API端点。这增加了复杂性，因为现在负责处理客户端开发的团队需要了解可能会减慢客户端开发过程的微服务特定端点。'
- en: '**Changing API endpoints:** Over a period of time, we may modify how a specific
    API endpoint inside a microservice works. This will require us to update all the
    clients that utilize the service provided by the microservice in order to reflect
    these changes. This is a cumbersome process, and could also introduce bugs or
    break existing functionality.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更改API端点：** 随着时间的推移，我们可能会修改微服务内特定API端点的工作方式。这将要求我们更新所有利用微服务提供的服务的客户端，以反映这些更改。这是一个繁琐的过程，也可能引入错误或破坏现有功能。'
- en: '**Poor protocol support:** With the microservices architecture, we have the
    power to control the technology stack we use to build a microservice. Sometimes,
    a microservice may be powered by a protocol that is usually not supported on other
    platforms or has poor implementation on them. For example, most of the platforms
    on which the client runs may not support something like AMQP, which will make
    the development of the client a hard job, because now the developers have to build
    the logic to handle AMQP protocol inside every client. This kind of requirement
    may not only be challenging, but may also be impossible to complete if the platform
    has no support for handling the excess load of the processing required.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协议支持不足：**使用微服务架构，我们有权控制用于构建微服务的技术栈。有时，微服务可能由通常不受其他平台支持或在其他平台上实现不佳的协议驱动。例如，客户端运行的大多数平台可能不支持像AMQP这样的东西，这将使得客户端的开发变得困难，因为现在开发人员必须在每个客户端内构建处理AMQP协议的逻辑。这种要求不仅可能具有挑战性，而且如果平台无法处理所需的过多处理负载，可能也无法完成。'
- en: '**Security:** If we need to embed the details of the individual network locations
    of the microservices powering every client, we may also open up security vulnerabilities
    in our infrastructure if even one of these microservices is not configured properly
    for security.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性：**如果我们需要嵌入每个客户端支持的微服务的个别网络位置的细节，我们可能会在基础设施中打开安全漏洞，即使其中一个微服务未正确配置安全性。'
- en: These are only a few of the challenges that we may face during the development
    of microservice applications. But can we do something to overcome them?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是在开发微服务应用程序过程中可能面临的一些挑战。但我们能做些什么来克服它们呢？
- en: The answer to this question lies with the use of API gateways.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的答案在于使用API网关。
- en: An **API gateway** can be seen as an intermediary between the client and application
    communication, handling the routing of the client requests and the translation
    of those requests from the protocol that is supported by the client to the protocol
    that is supported by the backend microservice. It does all of this without making
    the client worry about where the microservice may be running.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**API网关**可以被视为客户端和应用程序通信之间的中介，处理客户端请求的路由以及将这些请求从客户端支持的协议转换为后端微服务支持的协议。它可以在不让客户端担心微服务可能运行的位置的情况下完成所有这些操作。'
- en: 'In a microservices-architecture-based application utilizing API gateways, the
    flow of a request from the client to the application may be described as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用API网关的基于微服务架构的应用程序中，从客户端到应用程序的请求流程可以描述如下：
- en: The client has a common set of endpoints that it knows about to access a certain
    set of functionalities.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端有一组共同的端点，用于访问一定的功能集。
- en: The client sends a request to the API endpoint, along with any data that needs
    to be passed for the request to be completed.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端向API端点发送请求，以及需要传递的任何数据，以便完成请求。
- en: The API gateway intercepts the request made to the API endpoint by the client.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API网关拦截客户端对API端点的请求。
- en: The API gateway determines the client type and the capabilities that are supported
    by the client.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API网关确定客户端类型和客户端支持的功能。
- en: The API gateway then determines the individual microservices that need to be
    called for the request to complete.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后API网关确定需要调用哪些个别微服务来完成请求。
- en: The API gateway then forwards the requests to the specific microservices running
    in the backend. In case the protocol accepted by the microservice is different
    from the one in which the client made the request, the API gateway translates
    the request from the client protocol to the one supported by the microservice
    and then forwards the request.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后API网关将请求转发到后端运行的特定微服务。如果微服务接受的协议与客户端发出请求的协议不同，API网关会将请求从客户端协议转换为微服务支持的协议，然后转发请求。
- en: Once the microservices have finished generating the response, the API gateway
    collects the response and sends a collective response back to the requesting client.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦微服务完成生成响应，API网关收集响应并将集体响应发送回请求的客户端。
- en: 'This kind of process has several advantages; let''s take a look at a few of
    them:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这种过程有几个优点；让我们来看看其中的一些：
- en: '**Simple clients:** With the API gateways in place, the clients need not be
    aware of the individual microservices that they might need to call. The clients
    here make a call to a common endpoint for a particular functionality, and the
    API gateway is then responsible for figuring out which service needs to be called
    to complete the request. This greatly reduces the complexity of the clients being
    developed and makes their maintenance easy.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单客户端：**有了API网关，客户端无需知道它们可能需要调用的各个微服务。这里的客户端对特定功能调用一个共同的端点，然后API网关负责确定需要调用哪个服务来完成请求。这大大减少了正在开发的客户端的复杂性，并使其维护变得容易。'
- en: '**Ease of changing API endpoints:** When there is a change in an implementation
    of a particular API in the backend microservice, the API gateway can handle the
    compatibility for the older clients that have not been updated. This can be done
    by making the API gateway either return a degraded response or automatically update
    the request it has received to the newer API compatibility layer, if this is possible.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更改API端点的便利性：**当后端微服务的特定API实现发生变化时，API网关可以处理未更新的旧客户端的兼容性。这可以通过使API网关返回降级响应或自动更新其接收到的请求以适应新的API兼容层来实现，如果可能的话。'
- en: '**Simpler protocol support:** With the API gateway in place to handle any kind
    of conversion of the protocol that might be required by a microservice, the client
    does not need to worry about how to handle the protocols that it cannot support,
    greatly reducing the complexity and the issues that may arise by introducing the
    support for protocol that are not supported by the platform.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更简单的协议支持：**有了API网关来处理微服务可能需要的任何协议转换，客户端就不需要担心如何处理它无法支持的协议，大大减少了引入不受平台支持的协议支持可能带来的复杂性和问题。'
- en: '**Improved security:** With the API gateway, the clients need not be aware
    of the individual network locations of where a particular microservice is running.
    All they need to know is where the API gateway is listening to the requests to
    make a successful API call. Once the call has been made, the API gateway is then
    responsible for determining where the individual microservices serving that API
    are running and then forwarding the request to them.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**改进的安全性：**通过API网关，客户端不需要知道特定微服务运行的个别网络位置。他们只需要知道API网关监听请求的位置，以便成功调用API。一旦调用完成，API网关负责确定提供该API的各个微服务的运行位置，然后将请求转发给它们。'
- en: '**Improved failure handling:** An API gateway can also prove to be of help
    if a particular backend service is experiencing a failure. In this case, if the
    backend microservice was a non-essential microservice, the API gateway can return
    a degraded response back to the client, whereas if there was a failure in an essential
    backend service, the API gateway can immediately return an error response without
    letting the requests queue up, increasing the load on the servers.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**改进的故障处理：**如果特定的后端服务出现故障，API网关也可以提供帮助。在这种情况下，如果后端微服务是非关键微服务，API网关可以向客户端返回降级响应，而如果关键后端服务出现故障，API网关可以立即返回错误响应，而不让请求排队，增加服务器的负载。'
- en: As we can see, the benefits of using an API gateway are enormous and greatly
    simplify the development of the clients in the microservices application. Also,
    by utilizing an API gateway, interservice communication can be easily established.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，使用API网关的好处是巨大的，并且极大地简化了微服务应用程序中客户端的开发。此外，通过利用API网关，可以轻松建立服务之间的通信。
- en: To have the services communicate with each other, all they have to do is make
    the call to the appropriate endpoint that the API gateway is aware of, and from
    there the API gateway is responsible for determining the appropriate microservice
    and its network address to complete the request that has been made to it.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使服务相互通信，它们只需调用API网关知道的适当端点，然后API网关负责确定适当的微服务及其网络地址，以完成对其发出的请求。
- en: 'The preceding approach is really good, but there is a drawback: everything
    here is serialized and synchronous in nature. A call is made and then the calling
    client/service waits until a response is generated back. If the load on the services
    is high, these responses may take a long time to arrive, which may either cause
    a large number of requests to queue up on the infrastructure, increasing the load
    even further on the infrastructure, or it may cause a lot of requests to time
    out. This can greatly reduce the throughput of the application, and may even take
    the whole infrastructure down if the number of queued requests becomes really
    large.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法确实很好，但有一个缺点：这里的一切都是串行和同步的。发出调用，然后调用客户端/服务等待直到生成响应。如果服务的负载很高，这些响应可能需要很长时间才能到达，这可能会导致大量请求在基础设施上排队，进一步增加基础设施的负载，或者可能导致大量请求超时。这可能会大大降低应用程序的吞吐量，甚至可能使整个基础设施崩溃，如果排队请求的数量变得非常大。
- en: Is there an asynchronous method of communication between these services through
    which they can interact with each other, without making API calls again and again?
    Let's take a look at one such method.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 是否有一种服务之间可以相互交互的异步通信方法，而不需要一遍又一遍地进行API调用？让我们看看这样一种方法。
- en: Asynchronous communication in microservices
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务中的异步通信
- en: Inside a microservices architecture, every service does one job and does it
    well. To achieve any meaningful response for a business application, these services
    need to communicate with each other. All of this communication happens over the
    network.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，每个服务都有一个明确的职责，并且做得很好。为了实现业务应用的任何有意义的响应，这些服务需要相互通信。所有这些通信都发生在网络上。
- en: Here, a service makes a request to another service and then waits for the response
    to come back. But there is a catch. What if the other service takes a long time
    to process the request, or the service is down? What happens then?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一个服务向另一个服务发出请求，然后等待响应返回。但有一个问题。如果另一个服务花费很长时间来处理请求，或者服务宕机了呢？那时会发生什么？
- en: Most of the time, the request will time out. But if this service was a critical
    service, then the number of requests that might be arriving at it may be huge
    and can keep on getting queued up. If the service is slow, this will ...
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，请求会超时。但如果这个服务是一个关键服务，那么可能会到达它的请求数量可能会很大，并且可能会不断排队。如果服务很慢，这将...
- en: Message queues for microservices communication
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息队列用于微服务通信
- en: 'Message queues are a fairly old mechanism for establishing communication between
    a lot of different components inside an application. This old method is even good
    for our current use cases of the microservices architecture. But before we take
    a dive into how we can use message queues for making microservice communication
    asynchronous, let''s first take a look at some of the jargon that is used when
    dealing with this method of communication:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 消息队列是一种相当古老的机制，用于在应用程序内的许多不同组件之间建立通信。这种古老的方法甚至适用于我们当前的微服务架构用例。但在我们深入研究如何使用消息队列使微服务通信异步之前，让我们首先看一下在处理这种通信方法时使用的一些行话：
- en: '**Message:** A message is a kind of package that a particular service generates
    to communicate about what it wants to achieve to another service.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息：**消息是特定服务生成的一种包，用于与另一个服务交流其想要实现的目标。'
- en: '**Queue:** A queue is a kind of topic under which a particular message may
    come. For any practical application there could be a number of queues, each representing
    a specific topic of communication.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**队列：**队列是一种主题，特定消息可能会出现在其中。对于任何实际应用程序，可能会有许多队列，每个队列表示特定的通信主题。'
- en: '**Producer:** A producer is a service that generates a message and sends it
    to a specific topic.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产者：**生产者是生成消息并将其发送到特定主题的服务。'
- en: '**Consumer:** A consumer is a service that listens to a specific topic and
    processes any messages that may come to it.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消费者：**消费者是监听特定主题并处理可能到达的任何消息的服务。'
- en: '**Router:** A router is a component inside the message queues that is responsible
    for routing the messages for a particular topic to the appropriate queue.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由器：**路由器是消息队列内的一个组件，负责将特定主题的消息路由到适当的队列。'
- en: Now that we know the jargon, we can move on to look at how message queues can
    help us in establishing communication between the microservices.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了行话，我们可以继续看看消息队列如何帮助我们建立微服务之间的通信。
- en: When the microservices utilize something like a message queue, they interact
    over asynchronous protocols. For example, AMQP is one of the more famous protocols
    for asynchronous communication.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当微服务利用诸如消息队列之类的东西时，它们会使用异步协议进行交互。例如，AMQP是更著名的异步通信协议之一。
- en: 'With asynchronous communication, the communication between microservices will
    take place as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过异步通信，微服务之间的通信将如下进行：
- en: A message broker is set up, which will provide the functionality for the management
    of the message queues and the routing of the messages to the appropriate queue.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立一个消息代理，它将提供消息队列的管理功能，并将消息路由到适当的队列。
- en: A new service comes up and registers the topic it wants to listen to or send
    the messages to. The message broker creates an appropriate queue for the topic
    and adds the requesting service as either a consumer or a producer for that queue.
    This process also continues for other services.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新服务启动并注册它想要监听或发送消息的主题。消息代理为该主题创建适当的队列，并将请求服务添加为该队列的消费者或生产者。这个过程也会继续进行其他服务。
- en: Now, a service that wants to achieve a particular goal sends a message to the
    topic, let's say *Topic Authenticate*.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，一个想要实现特定目标的服务将消息发送到主题，比如*Topic Authenticate*。
- en: A consumer listening to *Topic Authenticate* is notified about a new message
    and consumes it.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监听*Topic Authenticate*的消费者收到有关新消息的通知并将其消耗掉。
- en: The consumer processes the message it has consumed and puts a response back
    on another topic, *Topic Auth_Response*.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消费者处理它已经消费的消息，并将响应放回另一个主题*Topic Auth_Response*。
- en: The producer of the original message is the consumer for *Topic Auth_Response*,
    and is notified about a new message.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原始消息的生产者是*Topic Auth_Response*的消费者，并收到有关新消息的通知。
- en: The original requesting client then reads this message and completes the request–response
    cycle.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原始请求客户端然后读取此消息并完成请求-响应循环。
- en: Now, we know what communication inside a microservices architecture that is
    powered by asynchronous message queues looks like. But is there any other benefit
    to this method other than asynchronous communication?
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道了由异步消息队列驱动的微服务架构内部的通信是什么样子。但是除了异步通信之外，这种方法还有其他好处吗？
- en: 'It turns out that there are a number of benefits that we may see from such
    a communication pattern. The following list shows some of the benefits that we
    may experience:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，我们可能会从这种通信模式中看到许多好处。以下列表显示了我们可能会体验到的一些好处：
- en: '**Better distribution of requests:** Since there could be a number of consumers
    that may be listening to a particular topic, the messages can be processed in
    parallel, and load balancing can be automatically taken care of by the equal distribution
    of messages among the consumers.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的请求分发：**由于可能有许多消费者可能会监听特定主题，因此消息可以并行处理，并且负载平衡可以通过在消费者之间平均分配消息来自动处理。'
- en: '**Better error resilience:** In the case where a particular microservice goes
    down, the messages that need to be processed by that microservice can be queued
    up inside the message queue for a certain time, and can then be processed by the
    service once it comes up, reducing possible data loss.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的错误韧性：**在特定微服务宕机的情况下，需要由该微服务处理的消息可以在消息队列内排队一段时间，然后在服务恢复后进行处理，从而减少可能的数据丢失。'
- en: '**Reduction in duplicate responses:** Since a message is delivered only once
    to a single consumer and is dequeued as soon as it is consumed, there is a very
    small chance that there could be duplicate responses for a single request.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少重复响应：**由于消息只传递一次给单个消费者，并且在被消费后立即出列，因此很少有可能为单个请求产生重复响应。'
- en: '**Increased tolerance:** During a time when the different microservices inside
    an infrastructure are experiencing high loads, the message queue system provides
    an asynchronous request–response cycle, thereby reducing the chance of request
    queue-ups.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增加的容忍度：**在基础设施内部的不同微服务经历高负载时，消息队列系统提供了异步请求-响应循环，从而减少了请求排队的机会。'
- en: With this, we now have an idea of how we can establish asynchronous communication
    between the microservices and make our infrastructure evolve over time without
    having to worry about how to handle the addition of new API endpoints for interservice
    communication.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在知道了如何在微服务之间建立异步通信，并且使我们的基础设施随着时间的推移而发展，而不必担心如何处理新增的API端点以进行服务间通信。
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took a look at how we can work with the microservices architecture
    and how it differs from the traditional monolithic way of developing enterprise
    applications. We then took a look at the advantages that come as we move toward
    the microservice development approach and learned about the guidelines that we
    can follow to make our journey toward microservices smoother.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了一下如何使用微服务架构以及它与传统的单片式企业应用程序开发方式有何不同。然后，我们看了一下向微服务开发方式转变的优势，并了解了我们可以遵循的指南，使我们朝着微服务更顺利地前进。
- en: Once we had an idea about the basics of microservices, we went on to take a
    look at how SLAs guarantee us a certain desired set of functionalities between
    the services and how they act as a contract so as to support a smooth service
    by the application. We then moved on to a hands-on exercise by writing a simple
    to-do list management application utilizing ...
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们了解了微服务的基础知识，我们继续看了一下SLA如何保证我们在服务之间获得一定的期望功能集，并且它们作为合同来支持应用程序的顺畅服务。然后，我们进行了一个实践练习，编写了一个简单的待办事项管理应用程序...
- en: Questions
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How does a service-oriented architecture differ from a microservice architecture?
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务导向架构与微服务架构有何不同？
- en: How can we ensure high uptime for microservice-based applications?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何确保基于微服务的应用程序的高可用性？
- en: What kind of guarantees are provided by a SLA?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SLA提供了什么样的保证？
- en: Can we make API gateways communicate directly with the service registry?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以让API网关直接与服务注册表通信吗？
- en: What are the tools that we can use to implement asynchronous communication between
    microservices?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用哪些工具来实现微服务之间的异步通信？
- en: Further reading
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Want to learn more about microservices? Take a look at *Practical Microservices* by
    *Umesh Ram Sharma* from *Packt Publishing*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于微服务的知识吗？看看*Packt Publishing*的*Umesh Ram Sharma*的*Practical Microservices*。
