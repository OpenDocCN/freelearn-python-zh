- en: Chapter 1. Introducing Modular Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。介绍模块化编程
- en: Modular programming is an essential tool for the modern developer. Gone are
    the days when you could just throw something together and hope that it works.
    To build robust systems that last, you need to understand how to organize your
    programs so that they can grow and evolve over time. *Spaghetti coding* is not
    an option. Modular programming techniques, and in particular the use of Python
    modules and packages, will give you the tools you need to succeed as a professional
    in the fast changing programming landscape.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化编程是现代开发人员的必备工具。过去那种随便拼凑然后希望它能工作的日子已经一去不复返。要构建持久的健壮系统，您需要了解如何组织程序，使其能够随着时间的推移而增长和发展。*意大利面编程*不是一个选择。模块化编程技术，特别是使用Python模块和包，将为您提供成功的工具，使您能够成为快速变化的编程领域的专业人士。
- en: 'In this chapter, we will:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将：
- en: Look at the fundamental aspects of modular programming
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看模块化编程的基本方面
- en: See how Python modules and packages can be used to organize your code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看Python模块和包如何被用来组织您的代码
- en: Discover what happens when modular programming techniques are not used
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解当不使用模块化编程技术时会发生什么
- en: Learn how modular programming helps you stay on top of the development process
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解模块化编程如何帮助您掌握开发过程
- en: Take a look at the Python standard library as an example of modular programming
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以Python标准库为例，看看模块化编程是如何使用的
- en: Create a simple program, built using modular techniques, to see how it works
    in practice
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的程序，使用模块化技术构建，以了解它在实践中是如何工作的
- en: Let's get started by learning about modules and how they work.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始学习模块和它们的工作原理。
- en: Introducing Python modules
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Python模块
- en: 'For most beginner programmers, their first Python program is some version of
    the famous *Hello World* program. This program would look something like this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数初学者程序员来说，他们的第一个Python程序是著名的*Hello World*程序的某个版本。这个程序可能看起来像这样：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This one-line program would be saved in a file on disk, typically named something
    like `hello.py`, and it would be executed by typing the following command into
    a terminal or command-line window:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个一行程序将保存在磁盘上的一个文件中，通常命名为`hello.py`，并且通过在终端或命令行窗口中输入以下命令来执行：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The Python interpreter would then dutifully print out the message you have
    asked it to:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后Python解释器将忠实地打印出您要求它打印的消息：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This `hello.py` file is called a **Python source file**. When you are first
    starting out, putting all your program code into a single source file is a great
    way of organizing your program. You can define functions and classes, and put
    instructions at the bottom which start your program when you run it using the
    Python interpreter. Storing your program code inside a Python source file saves
    you from having to retype it each time you want to tell the Python interpreter
    what to do.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`hello.py`文件被称为**Python源文件**。当您刚开始时，将所有程序代码放入单个源文件是组织程序的好方法。您可以定义函数和类，并在底部放置指令，当您使用Python解释器运行程序时，它会启动您的程序。将程序代码存储在Python源文件中可以避免每次想要告诉Python解释器该做什么时都需要重新输入它。
- en: As your programs get more complicated, however, you'll find that it becomes
    harder and harder to keep track of all the various functions and classes that
    you define. You'll forget where you put a particular piece of code and find it
    increasingly difficult to remember how all the various pieces fit together.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着您的程序变得更加复杂，您会发现越来越难以跟踪您定义的所有各种函数和类。您会忘记放置特定代码的位置，并且发现越来越难记住所有各种部分是如何组合在一起的。
- en: 'Modular programming is a way of organizing programs as they become more complicated.
    You can create a Python **module**, a source file that contains Python source
    code to do something useful, and then **import** this module into your program
    so that you can use it. For example, your program might need to keep track of
    various statistics about events that take place while the program is running.
    At the end, you might want to know how many events of each type have occurred.
    To achieve this, you might create a Python source file named `stats.py` which
    contains the following Python code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化编程是一种组织程序的方式，随着程序变得更加复杂。您可以创建一个Python **模块**，一个包含Python源代码以执行某些有用功能的源文件，然后将此模块**导入**到您的程序中，以便您可以使用它。例如，您的程序可能需要跟踪程序运行时发生的各种事件的各种统计信息。最后，您可能想知道每种类型的事件发生了多少次。为了实现这一点，您可以创建一个名为`stats.py`的Python源文件，其中包含以下Python代码：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `stats.py` Python source file defines a module named `stats`—as you can
    see, the name of the module is simply the name of the source file without the
    `.py` suffix. Your main program can make use of this module by importing it and
    then calling the various functions that you have defined as they are needed. The
    following frivolous example shows how you might use the `stats` module to collect
    and display statistics about events:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`stats.py` Python源文件定义了一个名为`stats`的模块—正如您所看到的，模块的名称只是源文件的名称，不包括`.py`后缀。您的主程序可以通过导入它并在需要时调用您定义的各种函数来使用这个模块。以下是一个无聊的例子，展示了如何使用`stats`模块来收集和显示有关事件的统计信息：'
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We''re not interested in recording meals and snacks, of course—this is just
    an example—but the important thing to notice here is how the `stats` module gets
    imported, and then how the various functions you defined within the `stats.py`
    file get used. For example, consider the following line of code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们对记录餐点不感兴趣—这只是一个例子—但这里需要注意的重要事情是`stats`模块如何被导入，以及`stats.py`文件中定义的各种函数如何被使用。例如，考虑以下代码行：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Because the `event_occurred()` function is defined within the `stats` module,
    you need to include the name of the module whenever you refer to this function.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`event_occurred()`函数是在`stats`模块中定义的，所以每当您引用这个函数时，都需要包括模块的名称。
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are ways in which you can import modules so you don't need to include
    the name of the module each time. We'll take a look at this in [Chapter 3](ch03.html
    "Chapter 3. Using Modules and Packages"), *Using Modules and Packages*, when we
    look at namespaces and how the `import` command works in more detail.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以导入模块，这样你就不需要每次都包含模块的名称。我们将在[第3章](ch03.html "第3章。使用模块和包") *使用模块和包* 中看到这一点，当我们更详细地了解命名空间和`import`命令的工作方式时。
- en: As you can see, the `import` statement is used to load a module, and any time
    you see the module name followed by a period, you can tell that the program is
    referring to something (for example, a function or class) that is defined within
    that module.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`import`语句用于加载一个模块，每当您看到模块名称后跟着一个句点，您就可以知道程序正在引用该模块中定义的某个东西（例如函数或类）。
- en: Introducing Python packages
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Python包
- en: In the same way that Python modules allow you to organize your functions and
    classes into separate Python source files, Python **packages** allow you to group
    multiple modules together.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Python模块允许您将函数和类组织到单独的Python源文件中一样，Python **包**允许您将多个模块组合在一起。
- en: 'A Python package is a directory with certain characteristics. For example,
    consider the following directory of Python source files:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Python包是具有特定特征的目录。例如，考虑以下Python源文件目录：
- en: '![Introducing Python packages](graphics/B05012_1_01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![介绍Python包](graphics/B05012_1_01.jpg)'
- en: 'This Python package, called `animals`, contains five Python modules: `cat`,
    `cow`, `dog`, `horse`, and `sheep`. There is also a special file with the rather
    unusual name `__init__.py`. This file is called a **package initialization file**;
    the presence of this file tells the Python system that this directory contains
    a package. The package initialization file can also be used to initialize the
    package (hence the name) and can also be used to make importing the package easier.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Python包叫做`animals`，包含五个Python模块：`cat`、`cow`、`dog`、`horse`和`sheep`。还有一个名为`__init__.py`的特殊文件。这个文件被称为**包初始化文件**；这个文件的存在告诉Python系统这个目录包含一个包。包初始化文件还可以用于初始化包（因此得名），也可以用于使导入包变得更容易。
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Starting with Python version 3.3, packages don't always need to include an initialization
    file. However, packages without an initialization file (called **namespace packages**)
    are still quite uncommon and are only used in very specific circumstances. To
    keep things simple, we will be using regular packages (with the `__init__.py`
    file) throughout this book.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从Python 3.3版本开始，包不总是需要包含初始化文件。然而，没有初始化文件的包（称为**命名空间包**）仍然相当罕见，只在非常特定的情况下使用。为了保持简单，我们将在本书中始终使用常规包（带有`__init__.py`文件）。
- en: 'Just like we used the module name when calling a function within a module,
    we use the package name when referring to a module within a package. For example,
    consider the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在调用模块内的函数时使用模块名称一样，当引用包内的模块时，我们使用包名称。例如，考虑以下代码：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, the `speak()` function is defined within the `cow.py` module,
    which itself is part of the `animals` package.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`speak()`函数是在`cow.py`模块中定义的，它本身是`animals`包的一部分。
- en: Packages are a great way of organizing more complicated Python programs. You
    can use them to group related modules together, and you can even define packages
    inside packages (called *nested packages*) to keep your program super-organized.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 包是组织更复杂的Python程序的一种很好的方式。您可以使用它们将相关的模块分组在一起，甚至可以在包内定义包（称为*嵌套包*）以保持程序的超级组织。
- en: Note that the `import` statement (and the related `from...import` statement)
    can be used in a variety of ways to load packages and modules into your program.
    We have only scratched the surface here, showing you what modules and packages
    look like in Python so that you can recognize them when you see them in a program.
    We will be looking at the way modules and packages can be defined and imported
    in much more depth in [Chapter 3](ch03.html "Chapter 3. Using Modules and Packages"),
    *Using Modules and Packages*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`import`语句（以及相关的`from...import`语句）可以以各种方式用于加载包和模块到您的程序中。我们在这里只是浅尝辄止，向您展示了Python中模块和包的样子，以便您在程序中看到它们时能够识别出来。我们将在[第3章](ch03.html
    "第3章。使用模块和包") *使用模块和包* 中更深入地研究模块和包的定义和导入方式。
- en: Tip
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: The code bundle for the book is also hosted on GitHub at [https://github.com/PacktPublishing/Modular-Programming-with-Python](https://github.com/PacktPublishing/Modular-Programming-with-Python).
    We also have other code bundles from our rich catalog of books and videos available
    at [https://github.com/PacktPublishing/](https://github.com/PacktPublishing/).
    Check them out!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的代码包也托管在GitHub上，网址为[https://github.com/PacktPublishing/Modular-Programming-with-Python](https://github.com/PacktPublishing/Modular-Programming-with-Python)。我们还有来自丰富书籍和视频目录的其他代码包，可在[https://github.com/PacktPublishing/](https://github.com/PacktPublishing/)上找到。快去看看吧！
- en: Using modules and packages to organize a program
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模块和包来组织程序
- en: 'Modules and packages aren''t just there to spread your Python code across multiple
    source files and directories—they allow you to *organize* your code to reflect
    the logical structure of what your program is trying to do. For example, imagine
    that you have been asked to create a web application to store and report on university
    examination results. Thinking about the business requirements that you have been
    given, you come up with the following overall structure for your application:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 模块和包不仅仅是用来将Python代码分布在多个源文件和目录中的，它们还允许您*组织*您的代码以反映程序试图做什么的逻辑结构。例如，想象一下，您被要求创建一个Web应用程序来存储和报告大学考试成绩。考虑到您得到的业务需求，您为应用程序提出了以下整体结构：
- en: '![Using modules and packages to organize a program](graphics/B05012_1_02.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![使用模块和包来组织程序](graphics/B05012_1_02.jpg)'
- en: 'The program is broken into two main parts: a **web interface**, which interacts
    with the user (and with other computer programs via an API), and a **backend**,
    which handles the internal logic of storing information in a database, generating
    reports, and e-mailing results to students. As you can see, the web interface
    itself has been broken down into four parts:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序分为两个主要部分：一个**网络界面**，用于与用户交互（以及通过API与其他计算机程序交互），以及一个**后端**，用于处理将信息存储在数据库中的内部逻辑、生成报告和向学生发送电子邮件的逻辑。正如您所看到的，网络界面本身已被分解为四个部分：
- en: A user authentication section, which handles user sign-up, sign-in, and sign-out
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用户认证部分，处理用户注册、登录和退出
- en: A web interface to view and enter exam results
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于查看和输入考试结果的网络界面
- en: A web interface to generate reports
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于生成报告的网络界面
- en: An API, which allows other systems to retrieve exam results on request
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个API，允许其他系统根据请求检索考试结果
- en: 'As you consider each logical component of your application (that is, each of
    the boxes in the preceding illustration), you are also starting to think about
    the functionality that each component will provide. As you do this, you are already
    thinking in modular terms. Indeed, each of the logical components of your application
    can be directly implemented as a Python module or package. For example, you might
    choose to break your program into two main packages named `web` and `backend`,
    where:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑应用程序的每个逻辑组件（即上图中的每个框）时，您也开始考虑每个组件将提供的功能。在这样做时，您已经在模块化方面进行思考。实际上，应用程序的每个逻辑组件都可以直接实现为Python模块或包。例如，您可以选择将程序分为两个主要包，命名为“web”和“backend”，其中：
- en: The `web` package has modules named `authentication`, `results`, `reports`,
    and `api`
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “web”包中有名为“authentication”、“results”、“reports”和“api”的模块
- en: The `backend` package has modules named `database`, `reportgenerator`, and `emailer`
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “backend”包中有名为“database”、“reportgenerator”和“emailer”的模块
- en: As you can see, each shaded box in the preceding illustration becomes a Python
    module, and each of the groupings of boxes becomes a Python package.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，上图中的每个阴影框都成为了一个Python模块，每个框的分组都成为了一个Python包。
- en: Once you have decided on the collection of packages and modules that you want
    to define, you can start to implement each component by writing the appropriate
    set of functions within each module. For example, the `backend.database` module
    might have a function named `get_students_results()`, which returns a single student's
    exam results for a given subject and year.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您决定要定义的包和模块集合，您就可以开始通过在每个模块中编写适当的函数集来实现每个组件。例如，“backend.database”模块可能有一个名为“get_students_results()”的函数，它返回给定科目和年份的单个学生的考试结果。
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In a real web application, your modular structure may actually be somewhat different.
    This is because you typically create a web application using a web application
    framework such as Django, which imposes its own structure on your program. However,
    in this example we are keeping the modular structure as simple as possible to
    show how business functionality translates directly into packages and modules.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际的Web应用程序中，您的模块化结构可能实际上会有所不同。这是因为您通常使用诸如Django之类的Web应用程序框架来创建Web应用程序，该框架会对您的程序施加自己的结构。但是，在这个例子中，我们将模块化结构保持得尽可能简单，以展示业务功能如何直接转化为包和模块。
- en: Obviously, this example is fictitious, but it shows how you can think about
    a complex program in modular terms, breaking it down into individual components
    and then using Python modules and packages to implement each of these components
    in turn.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这个例子是虚构的，但它展示了您如何以模块化的方式思考复杂的程序，将其分解为单独的组件，然后依次使用Python模块和包来实现这些组件中的每一个。
- en: Why use modular programming techniques?
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么要使用模块化编程技术？
- en: One of the great things about using modular design techniques, as opposed to
    just leaping in and writing code, is that they force you to think about the way
    your program should be structured and let you define a structure that will grow
    as your program evolves. Your program will be robust, easy to understand, easy
    to restructure as the scope of the program expands, and easy for others to work
    with too.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模块化设计技术的一大好处是，它们迫使您考虑程序应该如何结构化，并允许您定义一个随着程序发展而增长的结构。您的程序将是健壮的，易于理解，易于在程序范围扩大时重新构造，也易于其他人一起使用。
- en: 'Woodworkers have a motto that equally applies to modular programming: there''s
    a place for everything, and everything should be in its place. This is one of
    the hallmarks of high quality code, just as it''s a hallmark of a well-organized
    woodworker''s workshop.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 木匠有一句座右铭同样适用于模块化编程：每样东西都有其位置，每样东西都应该在其位置上。这是高质量代码的标志之一，就像是一个组织良好的木匠车间的标志一样。
- en: 'To see why modular programming is such an important skill, imagine what would
    happen if you didn''t apply modular techniques when writing a program. If you
    put all your Python code into a single source file, didn''t try to logically arrange
    your functions and classes, and just randomly added new code to the end of the
    file, you would end up with a terrible mess of incomprehensible code. The following
    is an example of a program written without any sort of modular organization:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解为什么模块化编程是如此重要的技能，请想象一下，如果在编写程序时没有应用模块化技术会发生什么。如果您将所有的Python代码放入单个源文件中，不尝试逻辑地排列您的函数和类，并且只是随机地将新代码添加到文件的末尾，您最终会得到一堆难以理解的糟糕代码。以下是一个没有任何模块化组织的程序的示例：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This program is intended to prompt the user for a number of data points and
    count how often each data point occurs. It does work, and the function and variable
    names do help to explain what each part of the program does—but it is still a
    mess. Just looking at the source code, it is hard to figure out what this program
    does. Functions were just added to the end of the file as the author decided to
    implement them, and even for a relatively small program, it is difficult to keep
    track of the various pieces. Imagine trying to debug or maintain a program like
    this if it was 10,000 lines long!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序旨在提示用户输入多个数据点并计算每个数据点出现的次数。它确实有效，并且函数和变量名称确实有助于解释程序的每个部分的功能——但它仍然是一团糟。仅仅看源代码，就很难弄清楚这个程序做什么。函数只是在文件的末尾添加，因为作者决定实现它们，即使对于一个相对较小的程序，也很难跟踪各个部分。想象一下，如果一个有1万行代码的程序像这样，试图调试或维护它会有多困难！
- en: 'This program is an example of *spaghetti coding*—programming where everything
    is jumbled together and there is no overall organization to the source code. Unfortunately,
    spaghetti coding is often combined with other programming habits that make a program
    even harder to understand. Some of the more common problems include:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序是*意大利面编程*的一个例子——编程中所有东西都混在一起，源代码没有整体组织。不幸的是，意大利面编程经常与其他使程序更难理解的编程习惯结合在一起。一些更常见的问题包括：
- en: Poorly chosen variable and function names that don't hint at what each variable
    or function is for. A typical example of this is a program that uses variable
    names such as `a`, `b`, `c`, and `d`.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择不当的变量和函数名称，不能暗示每个变量或函数的用途。一个典型的例子是一个程序使用诸如`a`、`b`、`c`和`d`这样的变量名。
- en: A complete lack of any documentation explaining what the code is supposed to
    do.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全没有任何解释代码应该做什么的文档。
- en: Functions that have unexpected side effects. For example, imagine if the `print_results()`
    function in our example program modified the `results` array as it was being printed.
    If you wanted to print the results twice or use the results after they had been
    printed, your program would fail in a most mysterious way.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有意外副作用的函数。例如，想象一下，如果我们示例程序中的`print_results()`函数在打印时修改了`results`数组。如果你想要两次打印结果或在打印后使用结果，你的程序将以一种最神秘的方式失败。
- en: While modular programming won't cure all these ills, the fact that it forces
    you to think about the logical organization of your program will help you to avoid
    them. Organizing your code into logical pieces will help you structure your program
    so that you know where each part belongs. Thinking about the packages and modules,
    and what each module contains, will encourage you to choose clear and appropriate
    names for the various parts of your program. Using modules and packages also makes
    it natural to include **docstrings** to explain the functionality of each part
    of your program as you go along. Finally, using a logical structure encourages
    each part of your program to perform one particular task, reducing the likelihood
    of side effects creeping into your code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然模块化编程不能治愈所有这些问题，但它迫使你考虑程序的逻辑组织，这将帮助你避免它们。将代码组织成逻辑片段将有助于你构建程序，以便你知道每个部分应该放在哪里。考虑包和模块，以及每个模块包含什么，将鼓励你为程序的各个部分选择清晰和适当的名称。使用模块和包还使得在编写过程中自然地包含**文档字符串**来解释程序的每个部分的功能。最后，使用逻辑结构鼓励程序的每个部分执行一个特定的任务，减少了代码中副作用的可能性。
- en: Of course, like any programming technique, modular programming can be abused,
    but if it is used well it will vastly improve the quality of the programs you
    write.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，像任何编程技术一样，模块化编程也可能被滥用，但如果使用得当，它将大大提高你编写的程序的质量。
- en: Programming as a process
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作为一个过程的编程
- en: 'Imagine that you are writing a program to calculate the price of overseas purchases.
    Your company is based in England, and you need to calculate the local price of
    something purchased in US dollars. Someone else has already written a Python module
    which downloads the exchange rate, so your program starts out looking something
    like the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在编写一个计算海外购买价格的程序。你的公司位于英格兰，你需要计算以美元购买的物品的当地价格。其他人已经编写了一个Python模块，用于下载汇率，所以你的程序开始看起来像下面这样：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'So far so good. Your program is included in your company''s online ordering
    system and the code goes into production. However, two months later, your company
    starts ordering products not just from the US, but from China, Germany, and Australia
    as well. You scramble to update your program to support these alternative currencies,
    and write something like the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切都很好。你的程序包含在公司的在线订购系统中，代码投入生产。然而，两个月后，你的公司开始不仅从美国订购产品，还从中国、德国和澳大利亚订购产品。你匆忙更新你的程序以支持这些替代货币，并写下了以下内容：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Once again, this program goes into production. Six months later, another 14
    countries are added, and the project manager also decides to add a new feature,
    where the user can see how the price of a product has changed over time. As the
    programmer responsible for this code, you now have to add support for those 14
    countries, and also add support for historical exchange rates going back in time.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序再次投入生产。六个月后，又添加了另外14个国家，并且项目经理还决定添加一个新功能，用户可以看到产品价格随时间的变化。作为负责这段代码的程序员，你现在必须为这14个国家添加支持，并且还要添加支持历史汇率的功能。
- en: This is a contrived example, of course, but it does show how programs typically
    evolve. Program code isn't something you write once and then leave forever. Your
    program is constantly changing and evolving in response to new requirements, newly
    discovered bugs, and unexpected consequences. Sometimes, a change that seems simple
    can be anything but. For example, consider the poor programmer who wrote the `get_exchange_rate()`
    function in our previous example. This function now has to support not only the
    current exchange rate for any given pair of currencies, it also has to return
    historical exchange rates going back to any desired point in time. If this function
    is obtaining its information from a source that doesn't support historical exchange
    rates, then the whole function may need to be rewritten from scratch to support
    an alternative data source.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是一个刻意构造的例子，但它确实展示了程序通常是如何演变的。程序代码不是您写一次然后永远留下的东西。您的程序在不断地变化和发展，以响应新的需求、新发现的错误和意想不到的后果。有时，一个看似简单的变更可能并非如此。例如，考虑一下在我们之前的例子中编写`get_exchange_rate()`函数的可怜程序员。这个函数现在不仅需要支持任意货币对的当前汇率，还需要返回到任意所需时间点的历史汇率。如果这个函数是从一个不支持历史汇率的来源获取信息，那么整个函数可能需要从头开始重写以支持替代数据来源。
- en: Sometimes, programmers and IT managers try to suppress change, for example by
    writing detailed specifications and then implementing one part of the program
    at a time (the so-called *waterfall* method of programming). But change is an
    integral part of programming, and trying to suppress it is like trying to stop
    the wind from blowing—it's much better to just accept that your program *will*
    change, and learn how to manage the process as well as you can.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，程序员和IT经理试图抑制变更，例如通过编写详细的规范，然后逐步实现程序的一部分（所谓的*瀑布*编程方法）。但变更是编程的一个组成部分，试图抑制它就像试图阻止风吹一样——最好的办法是接受您的程序*将*发生变更，并学会尽可能好地管理这个过程。
- en: 'Modular techniques are an excellent way of managing change in your programs.
    For example, as your program grows and evolves, you may find that a particular
    change requires the addition of a new module to your program:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化技术是管理程序变更的一种绝佳方式。例如，随着程序的增长和发展，您可能会发现某个变更需要向程序添加一个新模块：
- en: '![Programming as a process](graphics/B05012_1_03.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![编程作为一个过程](graphics/B05012_1_03.jpg)'
- en: You can then import and use that module in the other parts of your program that
    need to use this new functionality.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以在程序的其他部分导入和使用该模块，以便使用这个新功能。
- en: 'Alternatively, you might find that a new feature only requires you to change
    the contents of a module:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可能会发现一个新功能只需要您更改一个模块的内容：
- en: '![Programming as a process](graphics/B05012_1_04.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![编程作为一个过程](graphics/B05012_1_04.jpg)'
- en: This is one of the major benefits of modular programming—since the details of
    how a particular feature is implemented is inside a module, you can often change
    the internals of a module without affecting any other parts of your program. The
    rest of your program continues to import and use the module as it did before—only
    the internal implementation of the module has changed.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是模块化编程的主要好处之一——因为特定功能的实现细节在一个模块内部，您通常可以改变模块的内部实现而不影响程序的其他部分。您的程序的其余部分继续像以前一样导入和使用模块——只有模块的内部实现发生了变化。
- en: 'Finally, you might find that you need to **refactor** your program. This is
    where you have to change the modular organization of your code to improve the
    way the program works:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可能会发现需要**重构**您的程序。这是您必须改变代码的模块化组织以改进程序运行方式的地方：
- en: '![Programming as a process](graphics/B05012_1_05.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![编程作为一个过程](graphics/B05012_1_05.jpg)'
- en: Refactoring may involve moving code between modules as well as creating new
    modules, removing old ones, and changing the way modules work. In essence, refactoring
    is the process of *rethinking* the program so that it works better.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 重构可能涉及将代码从一个模块移动到另一个模块，以及创建新模块、删除旧模块和更改模块的工作方式。实质上，重构是重新思考程序，使其运行得更好的过程。
- en: In all of these changes, the use of modules and packages help you to manage
    the changes you make. Because the various modules and packages each perform a
    well-defined task, you know exactly which parts of your program need to be changed,
    and you can limit the effects of your changes to only the affected modules and
    the parts of the system that use them.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些变更中，使用模块和包可以帮助您管理所做的变更。因为各个模块和包都执行着明确定义的任务，您确切地知道程序的哪些部分需要被改变，并且可以将变更的影响限制在受影响的模块和使用它们的系统部分之内。
- en: Modular programming won't make change go away, but it will help you to deal
    with change—and the ongoing process of programming—in the best possible way.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化编程不会让变更消失，但它将帮助您处理变更——以及编程的持续过程——以最佳方式。
- en: The Python Standard Library
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python标准库
- en: 'One of the buzzwords used to describe Python is that it is a *batteries included*
    language, that is, it comes with a rich collection of built-in modules and packages
    called the **Python Standard Library**. If you''ve written any non-trivial Python
    program, you''ve almost certainly used modules from the Python Standard Library
    to do so. To get an idea of how vast the Python Standard Library is, here are
    a few example modules from this library:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 用来描述Python的一个流行词是它是一种“电池包含”的语言，也就是说，它带有丰富的内置模块和包的集合，称为**Python标准库**。如果您编写了任何非平凡的Python程序，几乎肯定会使用Python标准库中的模块。要了解Python标准库有多么庞大，以下是该库中的一些示例模块：
- en: '| Module | Description |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 模块 | 描述 |'
- en: '| --- | --- |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `datetime` | Defines classes to store and perform calculations using date
    and time values |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `datetime` | 定义用于存储和计算日期和时间值的类 |'
- en: '| `tempfile` | Defines a range of functions to work with temporary files and
    directories |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `tempfile` | 定义一系列函数来处理临时文件和目录 |'
- en: '| `csv` | Supports reading and writing of CSV format files |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `csv` | 支持读写CSV格式文件 |'
- en: '| `hashlib` | Implements cryptographically secure hashes |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '`hashlib` | 实现了密码安全哈希 |'
- en: '| `logging` | Allows you to write log messages and manage log files |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '`logging` | 允许你编写日志消息和管理日志文件 |'
- en: '| `threading` | Supports multi-threaded programming |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '`threading` | 支持多线程编程 |'
- en: '| `html` | A collection of modules (that is, a package) used to parse and generate
    HTML documents |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '`html` | 一组用于解析和生成 HTML 文档的模块（即包） |'
- en: '| `unittest` | A framework for creating and running unit tests |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '`unittest` | 用于创建和运行单元测试的框架 |'
- en: '| `urllib` | A collection of modules to read data from URLs |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '`urllib` | 一组用于从 URL 读取数据的模块 |'
- en: These are just a few of the over 300 modules available in the Python Standard
    Library. As you can see, there is a vast range of functionality provided, and
    all of this is built in to every Python distribution.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是 Python 标准库中可用的 300 多个模块中的一小部分。正如你所看到的，提供了广泛的功能，所有这些都内置在每个 Python 发行版中。
- en: Because of the huge range of functionality provided, the Python Standard Library
    is an excellent example of modular programming. For example, the `math` standard
    library module provides a range of mathematical functions that make it easier
    to work with integer and floating-point numbers. If you look through the documentation
    for this module ([http://docs.python.org/3/library/math.html](http://docs.python.org/3/library/math.html)),
    you will find a large collection of functions and constants, all defined within
    the `math` module, that perform almost any mathematical operation you could imagine.
    In this example, the various functions and constants are all defined within a
    single module, making it easy to refer to them when you need to.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于提供的功能范围非常广泛，Python 标准库是模块化编程的一个很好的例子。例如，`math` 标准库模块提供了一系列数学函数，使得更容易处理整数和浮点数。如果你查看这个模块的文档（[http://docs.python.org/3/library/math.html](http://docs.python.org/3/library/math.html)），你会发现一个大量的函数和常量，都在
    `math` 模块中定义，执行几乎任何你能想象到的数学运算。在这个例子中，各种函数和常量都在一个单独的模块中定义，这样在需要时很容易引用它们。
- en: 'In contrast, the `xmlrpc` package allows you to make and respond to remote
    procedure calls that use the XML protocol to send and receive data. The `xmlrpc`
    package is made up of two modules: `xmlrpc.server` and `xmlrpc.client`, where
    the `server` module allows you to create an XML-RPC server, and the `client` module
    includes code to access and use an XML-RPC server. This is an example of where
    a hierarchy of modules is used to logically group related functionality together
    (in this case, within the `xmlrpc` package), while using sub-modules to separate
    out the particular parts of the package.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`xmlrpc` 包允许你进行使用 XML 协议发送和接收数据的远程过程调用。`xmlrpc` 包由两个模块组成：`xmlrpc.server`
    和 `xmlrpc.client`，其中 `server` 模块允许你创建 XML-RPC 服务器，而 `client` 模块包括访问和使用 XML-RPC
    服务器的代码。这是一个使用模块层次结构来逻辑地将相关功能组合在一起的例子（在这种情况下，在 `xmlrpc` 包中），同时使用子模块来分离包的特定部分。
- en: If you haven't already done so, it is worth spending some time to review the
    documentation for the Python Standard Library. This can be found at [https://docs.python.org/3/library/](https://docs.python.org/3/library/).
    It is worth studying this documentation to see how Python has organized such a
    vast collection of features into modules and packages.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，值得花一些时间查看 Python 标准库的文档。可以在 [https://docs.python.org/3/library/](https://docs.python.org/3/library/)
    找到。值得研究这些文档，看看 Python 是如何将如此庞大的功能集合组织成模块和包的。
- en: The Python Standard Library is not perfect, but it has been improved over time,
    and the library as it is today makes a great example of modular programming techniques
    applied to a comprehensive library, covering a wide range of features and functions.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Python 标准库并不完美，但随着时间的推移得到了改进，如今的库是模块化编程技术应用到了一个全面的库中，涵盖了广泛的功能和函数的一个很好的例子。
- en: Creating your first module
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你的第一个模块
- en: Now that we've seen what modules are and how they can be used, let's implement
    our first real Python module. While this module is simple, you may find it a useful
    addition to the programs you write.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经看到了模块是什么以及它们如何被使用，让我们实现我们的第一个真正的 Python 模块。虽然这个模块很简单，但你可能会发现它是你编写的程序的一个有用的补充。
- en: Caching
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存
- en: 'In computer programming, a **cache** is a way of storing previously calculated
    results so that they can be retrieved more quickly. For example, imagine that
    your program had to calculate shipping costs based on three parameters:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机编程中，**缓存**是一种存储先前计算结果的方式，以便可以更快地检索它们。例如，想象一下，你的程序必须根据三个参数计算运费：
- en: The weight of the ordered item
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已订购商品的重量
- en: The dimensions of the ordered item
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已订购商品的尺寸
- en: The customer's location
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户的位置
- en: Calculating the shipping cost based on the customer's location might be quite
    involved. For example, you may have a fixed charge for deliveries within your
    city but charge a premium for out-of-town orders based on how far away the customer
    is. You may even need to send a query to a freight company's API to see how much
    it will charge to ship the given item.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 根据客户的位置计算运费可能会非常复杂。例如，你可能对本市内的送货收取固定费用，但对于外地订单，根据客户的距离收取溢价。你甚至可能需要向货运公司的 API
    发送查询，看看运送给定物品会收取多少费用。
- en: 'Since the process of calculating the shipping cost can be quite complex and
    time consuming, it makes sense to use a cache to store the previously calculated
    results. This allows you to use the previously calculated results rather than
    having to recalculate the shipping cost each time. To do this, you would need
    to structure your `calc_shipping_cost()` function to look something like the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于计算运费的过程可能非常复杂和耗时，使用缓存来存储先前计算的结果是有意义的。这允许你使用先前计算的结果，而不是每次都重新计算运费。为此，你需要将你的
    `calc_shipping_cost()` 函数结构化为以下内容：
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, we take the supplied parameters (in this case, the weight, dimensions,
    and the customer's location) and check whether there is already an entry in the
    cache for those parameters. If so, we retrieve the previously-calculated shipping
    cost from the cache. Otherwise, we go through the possibly time-consuming process
    of calculating the shipping cost, storing this in the cache using the supplied
    parameters, and then returning the shipping cost back to the caller.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们接受提供的参数（在这种情况下是重量、尺寸和客户位置），并检查是否已经有一个缓存条目与这些参数匹配。如果是，我们从缓存中检索先前计算的运费。否则，我们将经历可能耗时的过程来计算运费，使用提供的参数将其存储在缓存中，然后将运费返回给调用者。
- en: 'Notice how the `cache` variable in the preceding pseudo code looks very much
    like a Python dictionary—you can store entries in the dictionary based on a given
    key and then retrieve the entry using this key. There is, however, a crucial difference
    between a dictionary and a cache: a cache typically has a *limit* on the number
    of entries that it can contain, while the dictionary has no such limit. This means
    that a dictionary will continue to grow forever, possibly taking up all the computer''s
    memory if the program runs for a long time, while a cache will never take too
    much memory, as the number of entries is limited.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面伪代码中的`cache`变量看起来非常像Python字典——你可以根据给定的键在字典中存储条目，然后使用该键检索条目。然而，字典和缓存之间有一个关键区别：缓存通常对其包含的条目数量有一个*限制*，而字典没有这样的限制。这意味着字典将继续无限增长，可能会占用计算机的所有内存，而缓存永远不会占用太多内存，因为条目数量是有限的。
- en: 'Once the cache reaches its maximum size, an existing entry has to be removed
    each time a new entry is added so that the cache doesn''t continue to grow:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦缓存达到最大尺寸，每次添加新条目时都必须删除一个现有条目，以防缓存继续增长：
- en: '![Caching](graphics/B05012_1_06.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![缓存](graphics/B05012_1_06.jpg)'
- en: While there are various ways of choosing the entry to remove, the most common
    way is to remove the least recently used entry, that is, the entry that hasn't
    been used for the longest period of time.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有各种各样的选择要删除的条目的方法，但最常见的方法是删除最近未使用的条目，也就是最长时间未使用的条目。
- en: Caches are very commonly used in computer programs. In fact, even if you haven't
    yet used a cache in the programs you write, you've almost certainly encountered
    them before. Has someone ever suggested that you *clear your browser's cache*
    to solve a problem with your web browser? Yes, web browsers use a cache to hold
    previously downloaded images and web pages so that they don't have to be retrieved
    again, and clearing the contents of the browser cache is a common way of fixing
    a misbehaving web browser.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存在计算机程序中非常常见。事实上，即使你在编写程序时还没有使用缓存，你几乎肯定以前遇到过它们。有人曾经建议你*清除浏览器缓存*来解决浏览器问题吗？是的，浏览器使用缓存来保存先前下载的图像和网页，这样它们就不必再次检索，清除浏览器缓存的内容是修复浏览器问题的常见方法。
- en: Writing a cache module
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写一个缓存模块
- en: 'Let''s now write our own Python module to implement a cache. Before we write
    it, let''s think about the functionality that our cache module will require:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写自己的Python模块来实现一个缓存。在写之前，让我们考虑一下我们的缓存模块将需要的功能：
- en: We're going to limit the size of our cache to 100 entries.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将限制我们的缓存大小为100个条目。
- en: We will need an `init()` function to initialize the cache.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将需要一个`init()`函数来初始化缓存。
- en: We will have a `set(key, value)` function to store an entry in the cache.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将有一个`set(key, value)`函数来在缓存中存储一个条目。
- en: A `get(key)` function will retrieve an entry from the cache. If there is no
    entry for that key, this function should return `None`.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get(key)`函数将从缓存中检索条目。如果没有该键的条目，此函数应返回`None`。'
- en: We'll also need a `contains(key)` function to check whether a given entry is
    in the cache.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还需要一个`contains(key)`函数来检查给定的条目是否在缓存中。
- en: Finally, we'll implement a `size()` function which returns the number of entries
    in the cache.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将实现一个`size()`函数，它返回缓存中的条目数。
- en: Note
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are deliberately keeping the implementation of this module quite simple.
    A real cache would make use of a `Cache` class to allow you to use multiple caches
    at once. It would also allow the size of the cache to be configured as necessary.
    To keep things simple, however, we will implement these functions directly within
    a module, as we want to concentrate on modular programming rather than combining
    it with object-oriented programming and other techniques.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意保持这个模块的实现相当简单。一个真正的缓存会使用`Cache`类来允许您同时使用多个缓存。它还将允许根据需要配置缓存的大小。然而，为了保持简单，我们将直接在一个模块中实现这些函数，因为我们想专注于模块化编程，而不是将其与面向对象编程和其他技术结合在一起。
- en: 'Go ahead and create a new Python source file named `cache.py`. This file will
    hold the Python source code for our new module. At the top of this module, enter
    the following Python code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 继续创建一个名为`cache.py`的新Python源文件。这个文件将保存我们新模块的Python源代码。在这个模块的顶部，输入以下Python代码：
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We will be using the `datetime` Standard Library module to calculate the least
    recently used entry in the cache. The second statement, defining `MAX_CACHE_SIZE`,
    sets the maximum size for our cache.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`datetime`标准库模块来计算缓存中最近未使用的条目。第二个语句定义了`MAX_CACHE_SIZE`，设置了我们缓存的最大尺寸。
- en: Tip
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that we are following the standard Python convention of defining constants
    using uppercase letters. This makes them easier to see in your source code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们遵循了使用大写字母定义常量的标准Python约定。这样可以使它们在源代码中更容易看到。
- en: 'We now want to implement the `init()` function for our cache. To do this, add
    the following to the end of your module:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要为我们的缓存实现`init()`函数。为此，在模块的末尾添加以下内容：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, we have created a new function named `init()`. The first statement
    in this function, `global _cache`, defines a new variable named `_cache`. The
    `global` statement makes this variable available as a *module-level global variable*,
    that is, this variable can be shared by all parts of the `cache.py` module.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们创建了一个名为`init()`的新函数。这个函数的第一条语句`global _cache`定义了一个名为`_cache`的新变量。`global`语句使得这个变量作为*模块级全局变量*可用，也就是说，这个变量可以被`cache.py`模块的所有部分共享。
- en: Notice the underscore character at the start of the variable name. In Python,
    a leading underscore is a convention indicating that a name is private. In other
    words, the `_cache` global is intended to be used as an internal part of the `cache.py`
    module—the underscore tells you that you shouldn't need to use this variable outside
    of the `cache.py` module itself.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意变量名开头的下划线字符。在Python中，前导下划线是指示名称为私有的约定。换句话说，`_cache`全局变量旨在作为`cache.py`模块的内部部分使用——下划线告诉你，你不应该在`cache.py`模块之外使用这个变量。
- en: The second statement in the `init()` function sets the `_cache` global to an
    empty dictionary. Notice that we've added a comment explaining how the dictionary
    will be used; it's good practice to add notes like this to your code so others
    (and you, when you look at this code after a long time working on something else)
    can easily see what this variable is used for.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`init()`函数中的第二条语句将`_cache`全局设置为空字典。注意我们添加了一个解释说明字典将如何被使用的注释；向你的代码中添加这样的注释是一个好习惯，这样其他人（以及你，在长时间处理其他事情后再看这段代码时）可以轻松地看到这个变量的用途。'
- en: In summary, calling the `init()` function has the effect of creating a private
    `_cache` variable within the module and setting it to an empty dictionary. Let's
    now write the `set()` function, which will use this variable to store an entry
    in the cache.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，调用`init()`函数的效果是在模块内创建一个私有的`_cache`变量，并将其设置为空字典。现在让我们编写`set()`函数，它将使用这个变量来存储缓存条目。
- en: 'Add the following to the end of your module:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到模块的末尾：
- en: '[PRE13]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Once again, the `set()` function starts with a `global _cache` statement. This
    makes the `_cache` module-level global variable available for the function to
    use.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一次又一次，`set()`函数以`global _cache`语句开始。这使得`_cache`模块级全局变量可供函数使用。
- en: The `if` statement checks to see whether the cache is going to exceed the maximum
    allowed size. If so, we call a new function, named `_remove_oldest_entry()`, to
    remove the oldest entry from the cache. Notice how this function name also starts
    with an underscore—once again, this indicates that this function is private and
    should only be used by code within the module itself.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句检查缓存是否将超过允许的最大大小。如果是，我们调用一个名为`_remove_oldest_entry()`的新函数，从缓存中删除最旧的条目。注意这个函数名也以下划线开头——再次说明这个函数是私有的，只应该被模块内部的代码使用。'
- en: Finally, we store the entry in the `_cache` dictionary. Notice that we store
    the current date and time as well as the value in the cache; this will let us
    know when the cache entry was last used, which is important when we have to remove
    the oldest entry.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将条目存储在`_cache`字典中。注意我们存储了当前日期和时间以及缓存中的值；这将让我们知道缓存条目上次被使用的时间，这在我们必须删除最旧的条目时很重要。
- en: 'Let''s now implement the `get()` function. Add the following to the end of
    your module:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在实现`get()`函数。将以下内容添加到模块的末尾：
- en: '[PRE14]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You should be able to figure out what this code does. The only interesting part
    to note is that we update the date and time for the cache entry before returning
    the associated value. This lets us know when the cache entry was last used.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够弄清楚这段代码的作用。唯一有趣的部分是在返回相关值之前更新缓存条目的日期和时间。这样我们就知道缓存条目上次被使用的时间。
- en: 'With these functions implemented, the remaining two functions should also be
    easy to understand. Add the following to the end of your module:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些函数的实现，剩下的两个函数也应该很容易理解。将以下内容添加到模块的末尾：
- en: '[PRE15]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There shouldn't be any surprises here.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里不应该有任何意外。
- en: 'There''s only one more function left to implement: our private `_remove_oldest_entry()`
    function. Add the following to the end of your module:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 只剩下一个函数需要实现：我们的私有`_remove_oldest_entry()`函数。将以下内容添加到模块的末尾：
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This completes the implementation of our `cache.py` module itself, with the
    five main functions we described earlier, as well as one private function and
    one private global variable which are used internally to help implement our public
    functions.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们`cache.py`模块本身的实现，包括我们之前描述的五个主要函数，以及一个私有函数和一个私有全局变量，它们在内部用于帮助实现我们的公共函数。
- en: Using the cache
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用缓存
- en: 'Let''s now write a simple test program to use this `cache` module and verify
    that it''s working properly. Create a new Python source file, which we''ll call
    `test_cache.py`, and add the following to this file:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写一个简单的测试程序来使用这个`cache`模块，并验证它是否正常工作。创建一个新的Python源文件，我们将其称为`test_cache.py`，并将以下内容添加到该文件中：
- en: '[PRE17]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This program starts by importing three modules: two from the Python Standard
    Library, and the `cache` module we have just written. We then define a utility
    function named `random_string()`, which generates a string of random letters of
    a given length. After this, we initialize the cache by calling `cache.init()`
    and then generate 1,000 random entries to add to the cache. After adding each
    cache entry, we print out the number of entries we have added as well as the current
    cache size.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序首先导入了三个模块：两个来自Python标准库，以及我们刚刚编写的`cache`模块。然后我们定义了一个名为`random_string()`的实用函数，它生成给定长度的随机字母字符串。之后，我们通过调用`cache.init()`来初始化缓存，然后生成1,000个随机条目添加到缓存中。在添加每个缓存条目后，我们打印出我们添加的条目数以及当前的缓存大小。
- en: 'If you run this program, you can see that it''s working as expected:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个程序，你会发现它按预期工作：
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The cache continues to grow until it reaches 100 entries, at which point the
    oldest entry is removed to make room for a new one. This ensures that the cache
    stays the same size, no matter how many new entries are added.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存会不断增长，直到达到100个条目，此时最旧的条目将被移除以为新条目腾出空间。这确保了缓存保持相同的大小，无论添加了多少新条目。
- en: While there is a lot more we could do with our `cache.py` module, this is enough
    to demonstrate how to create a useful Python module and then use it within another
    program. Of course, you aren't just limited to importing modules within a main
    program—modules can import other modules as well.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以在`cache.py`模块中做更多的事情，但这已足以演示如何创建一个有用的Python模块，然后在另一个程序中使用它。当然，你不仅仅局限于在主程序中导入模块，模块也可以相互导入。
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we introduced the concept of Python modules and saw how Python
    modules are simply Python source files, which are imported and used by another
    source file. We then took a look at Python packages and saw that these are collections
    of modules identified by a package initialization file named `__init__.py`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Python模块的概念，看到Python模块只是Python源文件，可以被另一个源文件导入和使用。然后我们看了Python包，发现这些是由一个名为`__init__.py`的包初始化文件标识的模块集合。
- en: We explored how modules and packages can be used to organize your program's
    source code and why the use of these modular techniques is so important for the
    development of large systems. We also explored what spaghetti code looks like
    and discovered some of the other pitfalls that can occur if you don't modularize
    your programs.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了模块和包如何用于组织程序的源代码，以及为什么使用这些模块化技术对于大型系统的开发非常重要。我们还探讨了意大利面条式代码的样子，发现如果不对程序进行模块化，可能会出现一些其他陷阱。
- en: Next, we looked at programming as a process of constant change and evolution
    and how modular programming can help deal with a changing codebase in the best
    possible way. We then learned that the Python Standard Library is an excellent
    example of a large collection of modules and packages, and finished by creating
    our own simple Python module that demonstrates effective modular programming techniques.
    In implementing this module, we learned how a module can use leading underscores
    in variable and function names to mark them as *private* to the module, while
    making the remaining functions and other definitions available for other parts
    of the system to use.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编程视为不断变化和发展的过程，以及模块化编程如何帮助以最佳方式处理不断变化的代码库。然后我们了解到Python标准库是大量模块和包的绝佳示例，并通过创建自己的简单Python模块来展示有效的模块化编程技术。在实现这个模块时，我们学会了模块如何使用前导下划线来标记变量和函数名称为模块的*私有*，同时使其余函数和其他定义可供系统的其他部分使用。
- en: In the next chapter, we will apply modular techniques to the development of
    a more sophisticated program consisting of several modules working together to
    solve a more complex programming problem.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将应用模块化技术来开发一个更复杂的程序，由几个模块共同解决一个更复杂的编程问题。
