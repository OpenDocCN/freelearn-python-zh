- en: Chapter 8. Adding External File Servers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。添加外部文件服务器
- en: 'Salt Master normally keeps its resources locally on the machine that hosts
    it. This involves, among other things, files that are served to Minions. The file
    server loader allows you to use an external resource to store those files, and
    treat them as if they are local to the Master. In this chapter, we''ll discuss:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Salt主服务器通常将其资源存储在托管它的机器上。这包括其他许多事情，比如为从服务器提供文件。文件服务器加载器允许你使用外部资源来存储这些文件，并将它们视为主服务器本地的文件。在本章中，我们将讨论：
- en: Understanding how Salt uses files
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Salt如何使用文件
- en: Abstracting external sources to deliver files to Salt
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象外部源以向Salt提供文件
- en: Using Salt's cache system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Salt的缓存系统
- en: Troubleshooting external file servers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障排除外部文件服务器
- en: How Salt uses files
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Salt如何使用文件
- en: There are two ways that Salt's built-in file server uses files when communicating
    with Minions. They can be served whole and intact, or they can be processed by
    a templating engine, using a renderer module as discussed in [Chapter 5](part0033_split_000.html#VF2I1-d9976ffc65994572ad672a3ef48f1135
    "Chapter 5. Rendering Data"), *Rendering Data*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Salt内置的文件服务器在与从服务器通信时使用文件有两种方式。它们可以完整地提供服务，或者可以通过模板引擎进行处理，使用第5章中讨论的渲染模块，即*渲染数据*。
- en: 'In either case, these files are stored in one or more sets of directories,
    as configured with the `file_roots` directive in the master configuration file.
    These directories are grouped by environment. When Salt is looking for a file,
    it will search through the directories in the order in which they are listed.
    The default environment, `base`, normally uses `/srv/salt/` to store files. Such
    a configuration would look like:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，这些文件都存储在一个或多个目录集中，这些目录是通过主配置文件中的`file_roots`指令配置的。这些目录按环境分组。当Salt寻找文件时，它将按照列出的顺序搜索这些目录。默认环境`base`通常使用`/srv/salt/`来存储文件。这样的配置看起来可能像：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'What many users don''t realize is that the `file_roots` directive is actually
    a configuration option that is specific to a file server module called `roots`.
    This module, along with all other file server modules, is configured using the
    `fileserver_backend` directive:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 许多用户没有意识到，`file_roots`指令实际上是一个特定于名为`roots`的文件服务器模块的配置选项。这个模块，以及所有其他文件服务器模块，都是通过`fileserver_backend`指令进行配置的：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is where you configure any other file server modules to be used within
    Salt. Once again, modules are configured in the order in which they are to be
    used. When the Master requests a file for a Minion, Salt will check with each
    of these modules until it finds a match. When it does, it will stop looking, and
    serve the file that it has found. That means that if you have the following configuration:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你配置Salt中使用的任何其他文件服务器模块的地方。再次强调，模块的配置顺序与它们的使用顺序一致。当主服务器请求一个文件给从服务器时，Salt会检查这些模块中的每一个，直到找到匹配项。找到后，它将停止搜索，并服务找到的文件。这意味着如果你有以下配置：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: And Salt finds the requested file inside of Git, it will ignore any files that
    would otherwise be found on the local filesystem.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Salt在Git中找到请求的文件，它将忽略在本地文件系统中找到的任何文件。
- en: Mimicking a filesystem
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟文件系统
- en: If you have ever written a FUSE filesystem before, you will recognize some of
    the functions used inside a Salt file server module. Many of the operations used
    to request a file from an operating system are very similar to the files used
    by Salt to request a file. When it comes down to it, a Salt file server module
    is effectively a virtual filesystem, but with an API designed specifically for
    Salt, rather than for an operating system.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前编写过FUSE文件系统，你会在Salt文件服务器模块内部识别到一些函数。许多用于从操作系统请求文件的操作与Salt请求文件时使用的文件非常相似。归根结底，Salt文件服务器模块实际上是一个虚拟文件系统，但它的API是专门为Salt设计的，而不是为操作系统设计的。
- en: As you do development with file server modules, you may also notice another
    trend. While the data that is used may be stored in a remote location, it may
    be costly in terms of resources to repeatedly retrieve those files. Because of
    this, a number of file server modules will retrieve files from that remote location
    and then cache them locally on the Master, only updating them as necessary.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用文件服务器模块进行开发时，你可能会注意到另一个趋势。虽然使用的数据可能存储在远程位置，但反复检索这些文件可能会在资源上造成成本。因此，许多文件服务器模块将从远程位置检索文件，并在主服务器上本地缓存它们，仅在必要时更新。
- en: In this respect, when you are writing a file server module, you are often only
    implementing a means of retrieving and caching files, and serving them from the
    cache. This is not always the best thing to do; a truly dynamic file server based
    purely on database queries might perform best by always performing a lookup. You
    need to decide from the beginning what the most appropriate strategy is.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这方面，当你编写文件服务器模块时，你通常只是在实现检索和缓存文件以及从缓存中提供文件的手段。这并不总是最好的做法；一个完全基于数据库查询的真正动态文件服务器可能通过始终执行查找来表现最佳。你需要从一开始就决定最合适的策略。
- en: Looking at each function
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看每个函数
- en: The file server that we will be writing will be based on SFTP. Because SFTP
    calls can be expensive to make, we will use a caching implementation that relies
    on a popular Python library called Paramiko to retrieve files. For simplicity,
    we will only allow one SFTP server to be configured, but if you find yourself
    using this module, you may want to consider allowing multiple endpoints to be
    configured.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要编写的文件服务器将基于SFTP。由于SFTP调用可能很昂贵，我们将使用一个依赖于流行的Python库Paramiko的缓存实现来检索文件。为了简单起见，我们只允许配置一个SFTP服务器，但如果你发现自己在使用这个模块，你可能想要考虑允许配置多个端点。
- en: Setting up our module
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置我们的模块
- en: 'Before we go over the functions that are used, we start setting up the module
    itself. We will implement a few functions that provide objects that we will use
    throughout the rest of our module:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们介绍使用的函数之前，我们开始设置模块本身。我们将实现一些提供我们将在整个模块中使用的对象的函数：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There's quite a bit going on already! Fortunately, you should recognize most
    of this by now, so this part should go by quickly.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 已经有很多内容了！幸运的是，你现在应该已经认识到了大部分内容，所以这部分应该会很快过去。
- en: We've included a docstring that's a bit longer than usual, but which explains
    how to configure Salt to use our module. We will see these parameters used when
    we get to the `__virtual__()` function.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包含了一个比平常更长的文档字符串，它解释了如何配置Salt使用我们的模块。当我们到达`__virtual__()`函数时，我们将看到这些参数的使用。
- en: Next, we set up our imports. The usage of most of these will be covered as we
    go through individual functions, but there are a couple that we have wrapped in
    `try/except` blocks. The first of these is `fcntl`, which is a Unix system call
    that handles file descriptors. This library is useful for locking files in Unix
    and Linux, but does not exist in Windows. However, the rest of our module is usable
    in Windows, so we set a flag now that can be used later, when we need to lock
    files.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置我们的导入。大多数这些导入的使用将在我们通过单个函数进行时进行说明，但有两个我们将其包裹在`try/except`块中。第一个是`fcntl`，这是一个Unix系统调用，用于处理文件描述符。这个库在Unix和Linux中用于锁定文件，但在Windows中不存在。然而，我们模块的其余部分在Windows中是可用的，所以我们现在设置一个标志，稍后当我们需要锁定文件时可以使用。
- en: The second import is Paramiko. This is one of the most popular connection libraries
    available for SSH and SFTP in Python, and simple to use for our purposes. If it
    has not been installed, then we can return `False` in the `__virtual__()` function.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个导入是Paramiko。这是Python中用于SSH和SFTP的最受欢迎的连接库之一，对于我们的目的来说简单易用。如果没有安装，我们可以在`__virtual__()`函数中返回`False`。
- en: We've added `__virtualname__`, even though it's not strictly necessary, just
    so that we have a central and easy-to-find place to name our module. We will use
    this variable in the `__virtual__()` function. We've also added a little logging,
    which we'll make use of.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了`__virtualname__`，尽管它不是严格必要的，只是为了有一个中央且易于找到的地方来命名我们的模块。我们将在`__virtual__()`函数中使用这个变量。我们还添加了一些日志记录，我们将利用它们。
- en: Before even loading the `__virtual__()` function, we've defined two variables
    to be used for connecting to the SFTP server. We'll assign a connection to them
    inside `__virtual__()`, and it will be used throughout the rest of the module.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载`__virtual__()`函数之前，我们已经定义了两个变量，用于连接到SFTP服务器。我们将在`__virtual__()`内部将连接分配给它们，并且它们将在整个模块中使用。
- en: Finally, we have our `__virtual__()` function. First, we check to see if our
    module has even been configured for use. If not, there's no point in going any
    further. We also check to make sure Paramiko is installed. Then we make sure a
    root directory has been specified for the SFTP server. It's not evident now, but
    this directory will be required elsewhere. If it's not there, then we're not even
    going to bother trying to connect to the server.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有我们的 `__virtual__()` 函数。首先，我们检查这个模块是否已经被配置用于使用。如果没有，就没有继续下去的必要了。我们还检查确保
    Paramiko 已经安装。然后我们确保已经指定了 SFTP 服务器的根目录。现在可能还不明显，但这个目录在其他地方也将是必需的。如果它不存在，那么我们甚至不会尝试去连接服务器。
- en: If it is defined, then we can go ahead and try to make our connection. Paramiko
    will raise `AuthenticationException` if the rest of our parameters have been incorrectly
    defined, and in that case of course, we will consider this module unavailable
    and return `False`. But if all of those stars line up, then we're ready for business!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它已被定义，那么我们可以继续尝试建立连接。如果我们的其他参数定义不正确，Paramiko 将会抛出 `AuthenticationException`。在这种情况下，当然我们会认为这个模块不可用，并返回
    `False`。但如果所有这些条件都满足，那么我们就准备好开始工作了！
- en: Let's go over the functions that we should find inside any given file server
    module. In each section, we will implement and explain that function.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下在任何文件服务器模块中应该找到的函数。在每个部分，我们将实现并解释那个函数。
- en: envs()
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: envs()
- en: 'We start off by reporting which environments have been configured for this
    file server. At the very least, the `base` environment should be supported and
    reported, but it''s best to offer a mechanism to support other environments as
    well. Because we''re effectively abstracting a file management mechanism, it''s
    often easiest to just do this by separating environments into directories:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先报告哪些环境已经为这个文件服务器配置。至少，`base` 环境应该被支持并报告，但最好提供一个机制来支持其他环境。因为我们实际上是在抽象文件管理机制，所以通常最简单的方法就是通过将环境分离到目录中来实现：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This function needs to return a list. Because we've separated out environments
    into their own directories, all that we need to do for our module is return a
    list of directories at the root directory that we've configured.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数需要返回一个列表。因为我们已经将环境分离到它们自己的目录中，所以我们的模块只需要返回我们配置的根目录下的目录列表。
- en: This function is tricky to test, because there's no direct interface for it
    in any Salt modules. However, it can be tested once the next two functions are
    in place.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数很难测试，因为在任何 Salt 模块中都没有直接接口。然而，一旦下两个函数就位，就可以对其进行测试。
- en: file_list() and dir_list()
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: file_list() 和 dir_list()
- en: 'These two functions are pretty self-explanatory; they connect to the remote
    endpoint and return a list of all files and directories for that environment:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数相当直观；它们连接到远程端点，并返回该环境下的所有文件和目录列表：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'What is needed by these two functions is exactly the same, except for whether
    or not to include files. Because recursion is usually needed anyway, we''ve added
    a recursive function called `_recur_path()` that can report either just directories
    or both files and directories. You may notice the check against `entry.st_mode`.
    You may think of a Unix file mode as a set of permissions, which can be changed
    using the `chmod` (**ch**ange **mod**e) command. However, the mode also stores
    which kind of file it is:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数所需的东西完全相同，只是是否包含文件。因为递归通常总是需要的，所以我们添加了一个名为 `_recur_path()` 的递归函数，它可以报告目录或文件和目录。你可能注意到了对
    `entry.st_mode` 的检查。你可能把 Unix 文件模式看作是一组权限，这些权限可以使用 `chmod` （**ch**ange **mod**e）命令来更改。然而，模式还存储了文件类型：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We could use another try/except block to see if we can descend into a directory.
    But it's a little less work to check the mode. If it starts with `04`, then we
    know that it is a directory.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用另一个 try/except 块来检查是否可以进入一个目录。但检查模式会更省事。如果它以 `04` 开头，那么我们知道它是一个目录。
- en: 'Each of these functions requires a `load` argument. If you were to look inside,
    you would find a dictionary that looks like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数都需要一个 `load` 参数。如果你查看内部，你会找到一个看起来像这样的字典：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `cmd` field stores what kind of command was used. `prefix` will contain
    the directory path, inside the environment, which contains any requested files,
    and `saltenv` tells you the name of the requested environment itself. You will
    see this argument throughout the module, but it looks largely the same.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmd` 字段存储了使用了哪种命令。`prefix` 将包含包含任何请求文件的目录路径，在环境中，`saltenv` 告诉你请求的环境本身的名称。你将在整个模块中看到这个参数，但它的外观大致相同。'
- en: 'Let''s go ahead and look at a couple of Salt commands:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看几个 Salt 命令：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Keep in mind that `--local` will tell `salt-call` to pretend that it is its
    own Master. In that case, it will look to the `minion` configuration file for
    the connection parameters.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`--local` 将告诉 `salt-call` 假装它是它自己的 Master。在这种情况下，它将查找 `minion` 配置文件以获取连接参数。
- en: find_file()
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: find_file()
- en: 'Like `file_list()` and `dir_list()`, this function checks a requested path.
    It then reports whether or not the specified file exists:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `file_list()` 和 `dir_list()` 类似，此功能检查请求的路径。然后报告指定的文件是否存在：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You may have noticed that no SFTP calls are being made in this function. That's
    because we're using a caching file server, and all that we need to check for right
    now is to see if the file has been cached. If it has, then Salt will just serve
    the file from the cache.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到在此函数中没有进行任何 SFTP 调用。这是因为我们正在使用缓存文件服务器，我们现在需要检查的是文件是否已被缓存。如果是，那么 Salt
    将直接从缓存中提供文件。
- en: If you are writing a file server module that does not keep a local cache, then
    this function should check the remote endpoint to ensure that the file exists.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在编写一个不保留本地缓存的文件服务器模块，那么此功能应该检查远程端点以确保文件存在。
- en: Speaking of the cache, one of the more important lines in this function is the
    one that defines the `full` variable. This sets up the directory structure that
    is to be used for this caching file server. It makes use of `salt.syspaths` to
    determine the correct directory for your platform; normally, this will be `/var/cache/salt/`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 说到缓存，此函数中更重要的一行是定义 `full` 变量的那一行。这设置了用于此缓存文件服务器的目录结构。它使用 `salt.syspaths` 确定您平台上的正确目录；通常，这将是在
    `/var/cache/salt/`。
- en: Note that a `load` is not passed into this function, but `saltenv` that would
    normally be in the `load` is. Previous versions of Salt passed in `saltenv` as
    just `env`, and the `**kwargs` functions as a catch-all to keep Python from choking
    on old implementations.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此函数中没有传递 `load`，但 `saltenv`（通常在 `load` 中）被传递。Salt 的早期版本将 `saltenv` 传递为 `env`，并将
    `**kwargs` 函数作为通配符来防止 Python 在旧实现上崩溃。
- en: Once again, there is no way to test this function directly. It will be used
    by the `update()` function later on in this section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，无法直接测试此功能。它将在本节后面的 `update()` 函数中使用。
- en: serve_file()
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: serve_file()
- en: 'Once a file has been found using `find_file()`, its data is passed to this
    function in order to return the actual file contents:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `find_file()` 找到文件后，其数据将传递给此函数以返回实际的文件内容：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This function is used directly by Salt's own internal file server, which splits
    files into chunks before delivering them to Minions. If the `gzip` flag is set
    to `True` in the master configuration file, then each of these chunks will be
    individually compressed.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能直接由 Salt 的内部文件服务器使用，在将文件分块传递给 Minions 之前将文件分割成块。如果在主配置文件中将 `gzip` 标志设置为 `True`，则每个这些块都将单独压缩。
- en: Since, in our case, this function is serving files from the cache, you can probably
    get away with using this function as it is printed here, except for the line that
    defines the `full` variable. If you are not using a caching file server, then
    you will need to have a way to access and deliver each chunk of a file, as requested.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在我们的情况下，此功能是从缓存中提供文件，因此你可能会使用这里打印的此功能，除了定义 `full` 变量的那一行。如果你没有使用缓存文件服务器，那么你需要有访问和提供文件每个块的方法，正如请求的那样。
- en: 'You can test this function using the `cp.get_file` function. This function
    requires both a filename to download, and a full path to save the file locally:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `cp.get_file` 函数测试此功能。此功能需要下载的文件名和保存文件到本地的完整路径：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: update()
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: update()
- en: 'At regular intervals, Salt will request that an external file server perform
    maintenance on itself. This function will compare the local file cache (if it
    is being used) with the remote endpoint, and update Salt with new information:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在固定的时间间隔内，Salt 将要求外部文件服务器对其进行维护。此功能将比较本地文件缓存（如果正在使用）与远程端点，并使用新信息更新 Salt：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Whew! This is a long one! First, we define the cache directory, and if it is
    not there, then we create it. This is important for caching file servers. Then
    we ask Salt to clean up old entries, using the built-in `salt.fileserver.reap_fileserver_cache_dir()`
    function. This passes in a reference to `find_file()` to help with the work.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 呼呼！这是一个很长的函数！首先，我们定义缓存目录，如果它不存在，则创建它。这对于缓存文件服务器来说很重要。然后我们要求Salt使用内置的`salt.fileserver.reap_fileserver_cache_dir()`函数清理旧条目。这传递了`find_file()`的引用以帮助工作。
- en: The next section walks through the remaining files to check their timestamps.
    Files will only be downloaded if they either have not yet been downloaded, or
    if there is a more recent copy on the remote SFTP server.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将介绍剩余的文件，以检查它们的最后修改时间戳。只有在文件尚未下载，或者远程SFTP服务器上有更新的副本时，才会下载文件。
- en: Finally, we loop through each environment to see which files have changed, and
    download them if necessary. Any directories that don't exist in the local cache
    will be created. And whether we create a file or a directory, we make sure to
    update its timestamp so that the cache matches what's on the server.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们遍历每个环境，查看哪些文件已更改，并在必要时下载它们。如果本地缓存中不存在任何目录，则会创建它们。无论我们创建文件还是目录，我们都会确保更新其时间戳，以便缓存与服务器上的内容相匹配。
- en: 'This function will be run periodically by the Salt Master, but you can force
    it to run by manually deleting a file from the local cache, and then requesting
    a copy:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将由Salt Master定期运行，但您可以通过手动从本地缓存中删除文件并请求副本来强制它运行：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: file_hash()
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: file_hash()
- en: 'One of the ways that Salt knows that a file has been changed is by keeping
    track of the file''s hash signature. If a hash changes, then Salt will know that
    it is time to serve a new copy of the file from the cache:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Salt知道文件已被更改的一种方式是跟踪文件的哈希签名。如果哈希值发生变化，那么Salt将知道是时候从缓存中提供文件的新副本了：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is the longest function in our example, but thankfully it also needs the
    least amount of modification, for a caching file server. As with the other examples
    in this book, you can download a copy of this module from Packt Publishing's website.
    Once you have it downloaded, you will likely only need to change the value of
    `cache_path`. However, we will go through this function briefly anyway.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们示例中最长的函数，但幸运的是，它也需要最少的修改，对于一个缓存文件服务器来说。正如本书中的其他示例一样，您可以从Packt Publishing的网站上下载此模块的副本。一旦下载完成，您可能只需要更改`cache_path`的值。然而，我们仍然会简要地介绍这个函数。
- en: 'After setting up a few basics, including the path of the file being hashed,
    check for the existence of said path, and define where in the cache to keep a
    copy of the hash. In our case, we''ve set up another directory structure inside
    the cache, mirroring the original, but with `.hash.<hash_type>` appended to the
    filename. Resulting files will have names like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置了一些基本设置，包括正在散列的文件的路径，检查该路径是否存在，并定义在缓存中保存哈希副本的位置之后。在我们的例子中，我们在缓存中设置了一个额外的目录结构，与原始结构相似，但文件名后附加了`.hash.<hash_type>`。生成的文件将具有如下名称：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The next section checks to see if the hash file has been created, and if so,
    whether or not the timestamp matches the local copy. If the timestamp on the existing
    hash file is too old, then a new hash will be generated.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将检查哈希文件是否已创建，以及是否与本地副本的时间戳匹配。如果现有哈希文件的时间戳太旧，则将生成新的哈希值。
- en: If we get past all of that, then we know it's time to generate a new hash. After
    determining the hash type to use and setting up a directory to put it in, we get
    to the section that actually writes the hash to disk. Remember the check for `fcntl`
    at the beginning of the module? On a busy Salt Master, it's possible that multiple
    attempts may be made simultaneously to work on the same file. With `fcntl` in
    place, we can lock that file before writing to it, to avoid corruption.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过了所有这些，那么我们就知道是时候生成新的哈希值了。在确定要使用的哈希类型并设置存放它的目录之后，我们到达了实际将哈希写入磁盘的部分。还记得模块开头对`fcntl`的检查吗？在繁忙的Salt
    Master上，可能同时尝试对同一文件进行多次操作。有了`fcntl`，我们可以在写入之前锁定该文件，以避免损坏。
- en: The final module
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终模块
- en: 'With all of our functions in place, the final module will look like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有函数就绪后，最终的模块将看起来像这样：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Troubleshooting file servers
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件服务器故障排除
- en: File server modules can be tricky to troubleshoot, because so many of the pieces
    need to be in place before others are usable. But there are some tricks that you
    can keep in mind.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 文件服务器模块可能难以调试，因为许多组件需要就位，其他组件才能使用。但有一些技巧你可以记住。
- en: Start small
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从小开始
- en: I've tried to present the functions that are necessary, in the order that is
    easiest for writing and troubleshooting. While `envs()` cannot be called directly,
    it is easy to write, and can be debugged while working on `file_list()` and `dir_list()`.
    And those two functions are easy to troubleshoot using the `cp.list_master` and
    `cp.list_master_dirs` functions, respectively.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经尝试以编写和调试最容易的顺序呈现必要的功能。虽然不能直接调用`envs()`，但它很容易编写，可以在处理`file_list()`和`dir_list()`时进行调试。而且，可以使用`cp.list_master`和`cp.list_master_dirs`函数分别轻松调试这两个功能。
- en: Test on a Minion
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Minion上测试
- en: While file server modules are designed to be used on the Master, it is possible
    to test them on a Minion. Be sure to define all of the appropriate configurations
    in the `minion` configuration file instead of the `master` file. Use `salt-call
    --local` to issue commands, and regularly wipe both the local cache (in `/var/salt/cache/`)
    and any files that were downloaded using `cp.get_file`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然文件服务器模块是为在主服务器上使用而设计的，但它们也可以在Minion上进行测试。确保在`minion`配置文件中而不是在`master`文件中定义所有适当的配置。使用`salt-call
    --local`来发布命令，并定期清除本地缓存（在`/var/salt/cache/`中）以及使用`cp.get_file`下载的任何文件。
- en: Summary
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: File server modules can be used to present resources on an external endpoint
    as if they were files sitting on the Master. The default file server module, called
    `roots`, does in fact use local files on the Master. Many file server modules
    cache files locally on the Master, to avoid making too many calls to the external
    source, but this is not always appropriate.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 文件服务器模块可以用来在外部端点呈现资源，就像它们是位于主服务器上的文件一样。默认的文件服务器模块，名为`roots`，实际上确实使用了主服务器上的本地文件。许多文件服务器模块在主服务器上本地缓存文件，以避免对外部源进行过多的调用，但这并不总是合适的。
- en: There are a number of functions inside a file server module, which work in concert
    to present a file-server-like interface. Some of these functions cannot be tested
    directly, but they can still be tested in tandem with other functions that do
    have a direct external interface.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 文件服务器模块内部有许多功能，它们协同工作以呈现类似文件服务器的接口。其中一些功能不能直接测试，但它们仍然可以与其他具有直接外部接口的功能一起测试。
- en: Despite all of the functions involved, file server modules are relatively easy
    to write. In the next chapter, we'll talk about cloud modules, which have even
    more required functions, but which are even easier to write.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管涉及许多功能，但文件服务器模块相对容易编写。在下一章中，我们将讨论云模块，它们有更多的必需功能，但编写起来却更加容易。
