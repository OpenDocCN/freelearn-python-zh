- en: Chapter 9. The Iterator Pattern
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。迭代器模式
- en: 'We''ve discussed how many of Python''s built-ins and idioms that seem, at first
    blush, to be non-object-oriented are actually providing access to major objects
    under the hood. In this chapter, we''ll discuss how the `for` loop that seems
    so structured is actually a lightweight wrapper around a set of object-oriented
    principles. We''ll also see a variety of extensions to this syntax that automatically
    create even more types of object. We will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了许多Python内置和习惯用法，乍一看似乎不是面向对象的，实际上在底层提供了对主要对象的访问。在本章中，我们将讨论`for`循环，看起来如此结构化，实际上是一组面向对象原则的轻量级包装。我们还将看到一系列扩展到这个语法的类型。我们将涵盖：
- en: What design patterns are
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是设计模式
- en: The iterator protocol—one of the most powerful design patterns
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器协议——最强大的设计模式之一
- en: List, set, and dictionary comprehensions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表、集合和字典的理解
- en: Generators and coroutines
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器和协程
- en: Design patterns in brief
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简要介绍设计模式
- en: When engineers and architects decide to build a bridge, or a tower, or a building,
    they follow certain principles to ensure structural integrity. There are various
    possible designs for bridges (suspension or cantilever, for example), but if the
    engineer doesn't use one of the standard designs, and doesn't have a brilliant
    new design, it is likely the bridge he/she designs will collapse.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当工程师和建筑师决定建造桥梁、塔楼或建筑物时，他们遵循某些原则以确保结构完整性。桥梁有各种可能的设计（例如悬索桥或悬臂桥），但如果工程师不使用标准设计之一，并且没有一个新的杰出设计，那么他/她设计的桥梁可能会倒塌。
- en: Design patterns are an attempt to bring this same formal definition for correctly
    designed structures to software engineering. There are many different design patterns
    to solve different general problems. People who create design patterns first identify
    a common problem faced by developers in a wide variety of situations. They then
    suggest what might be considered the ideal solution for that problem, in terms
    of object-oriented design.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式试图将正确设计的结构的正式定义引入软件工程。有许多不同的设计模式来解决不同的通用问题。创建设计模式的人首先确定开发人员在各种情况下面临的常见问题。然后，他们建议可能被认为是该问题的理想解决方案，从面向对象设计的角度来看。
- en: Knowing a design pattern and choosing to use it in our software does not, however,
    guarantee that we are creating a "correct" solution. In 1907, the Québec Bridge
    (to this day, the longest cantilever bridge in the world) collapsed before construction
    was completed, because the engineers who designed it grossly underestimated the
    weight of the steel used to construct it. Similarly, in software development,
    we may incorrectly choose or apply a design pattern, and create software that
    "collapses" under normal operating situations or when stressed beyond its original
    design limits.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 了解设计模式并选择在我们的软件中使用它并不保证我们正在创建一个“正确”的解决方案。1907年，魁北克大桥（至今仍是世界上最长的悬臂桥）在建造完成之前倒塌，因为设计它的工程师严重低估了用于建造的钢材重量。同样，在软件开发中，我们可能错误地选择或应用设计模式，并创建在正常操作情况下或在超出其原始设计限制时“倒塌”的软件。
- en: Any one design pattern proposes a set of objects interacting in a specific way
    to solve a general problem. The job of the programmer is to recognize when they
    are facing a specific version of that problem, and to adapt the general design
    in their solution.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 任何一个设计模式都提出了一组以特定方式相互作用的对象，以解决一个通用问题。程序员的工作是识别何时面临特定版本的问题，并在解决方案中调整通用设计。
- en: In this chapter, we'll be covering the iterator design pattern. This pattern
    is so powerful and pervasive that the Python developers have provided multiple
    syntaxes to access the object-oriented principles underlying the pattern. We will
    be covering other design patterns in the next two chapters. Some of them have
    language support and some don't, but none of them is as intrinsically a part of
    the Python coder's daily life as the iterator pattern.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍迭代器设计模式。这种模式是如此强大和普遍，以至于Python开发人员提供了多种语法来访问该模式的基础面向对象原则。我们将在接下来的两章中介绍其他设计模式。其中一些具有语言支持，一些没有，但没有一个像迭代器模式一样成为Python程序员日常生活的固有部分。
- en: Iterators
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器
- en: 'In typical design pattern parlance, an iterator is an object with a `next()`
    method and a `done()` method; the latter returns `True` if there are no items
    left in the sequence. In a programming language without built-in support for iterators,
    the iterator would be looped over like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的设计模式术语中，迭代器是一个具有`next()`方法和`done()`方法的对象；后者在序列中没有剩余项目时返回`True`。在没有迭代器的内置支持的编程语言中，迭代器将被循环遍历，如下所示：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In Python, iteration is a special feature, so the method gets a special name,
    `__next__`. This method can be accessed using the `next(iterator)` built-in. Rather
    than a `done` method, the iterator protocol raises `StopIteration` to notify the
    loop that it has completed. Finally, we have the much more readable `for item
    in iterator` syntax to actually access items in an iterator instead of messing
    around with a `while` loop. Let's look at these in more detail.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，迭代是一个特殊的特性，所以该方法得到了一个特殊的名称`__next__`。可以使用内置的`next(iterator)`来访问这个方法。迭代器协议不是使用`done`方法，而是引发`StopIteration`来通知循环已经完成。最后，我们有更加可读的`for
    item in iterator`语法来实际访问迭代器中的项目，而不是使用`while`循环。让我们更详细地看一下这些。
- en: The iterator protocol
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器协议
- en: The abstract base class `Iterator`, in the `collections.abc` module, defines
    the iterator protocol in Python. As mentioned, it must have a `__next__` method
    that the `for` loop (and other features that support iteration) can call to get
    a new element from the sequence. In addition, every iterator must also fulfill
    the `Iterable` interface. Any class that provides an `__iter__` method is iterable;
    that method must return an `Iterator` instance that will cover all the elements
    in that class. Since an iterator is already looping over elements, its `__iter__`
    function traditionally returns itself.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象基类`Iterator`，在`collections.abc`模块中，定义了Python中的迭代器协议。正如前面提到的，它必须有一个`__next__`方法，`for`循环（和其他支持迭代的功能）可以调用它来从序列中获取一个新的元素。此外，每个迭代器还必须满足`Iterable`接口。任何提供`__iter__`方法的类都是可迭代的；该方法必须返回一个`Iterator`实例，该实例将覆盖该类中的所有元素。由于迭代器已经在元素上循环，因此它的`__iter__`函数传统上返回它自己。
- en: 'This might sound a bit confusing, so have a look at the following example,
    but note that this is a very verbose way to solve this problem. It clearly explains
    iteration and the two protocols in question, but we''ll be looking at several
    more readable ways to get this effect later in this chapter:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来有点混乱，所以看一下以下的例子，但请注意，这是解决这个问题的一种非常冗长的方式。它清楚地解释了迭代和所讨论的两个协议，但在本章的后面，我们将看到几种更可读的方法来实现这种效果：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This example defines an `CapitalIterable` class whose job is to loop over each
    of the words in a string and output them with the first letter capitalized. Most
    of the work of that iterable is passed to the `CapitalIterator` implementation.
    The canonical way to interact with this iterator is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子定义了一个`CapitalIterable`类，其工作是循环遍历字符串中的每个单词，并输出它们的首字母大写。这个可迭代对象的大部分工作都交给了`CapitalIterator`实现。与这个迭代器互动的规范方式如下：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This example first constructs an iterable and retrieves an iterator from it.
    The distinction may need explanation; the iterable is an object with elements
    that can be looped over. Normally, these elements can be looped over multiple
    times, maybe even at the same time or in overlapping code. The iterator, on the
    other hand, represents a specific location in that iterable; some of the items
    have been consumed and some have not. Two different iterators might be at different
    places in the list of words, but any one iterator can mark only one place.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子首先构造了一个可迭代对象，并从中检索了一个迭代器。这种区别可能需要解释；可迭代对象是一个具有可以循环遍历的元素的对象。通常，这些元素可以被多次循环遍历，甚至可能在同一时间或重叠的代码中。另一方面，迭代器代表可迭代对象中的特定位置；一些项目已被消耗，一些项目尚未被消耗。两个不同的迭代器可能在单词列表中的不同位置，但任何一个迭代器只能标记一个位置。
- en: Each time `next()` is called on the iterator, it returns another token from
    the iterable, in order. Eventually, the iterator will be exhausted (won't have
    any more elements to return), in which case `Stopiteration` is raised, and we
    break out of the loop.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 每次在迭代器上调用`next()`时，它会按顺序从可迭代对象中返回另一个标记。最终，迭代器将被耗尽（不再有任何元素返回），在这种情况下会引发`Stopiteration`，然后我们跳出循环。
- en: 'Of course, we already know a much simpler syntax for constructing an iterator
    from an iterable:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们已经知道了一个更简单的语法来从可迭代对象中构造一个迭代器：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, the `for` statement, in spite of not looking terribly object-oriented,
    is actually a shortcut to some obviously object-oriented design principles. Keep
    this in mind as we discuss comprehensions, as they, too, appear to be the polar
    opposite of an object-oriented tool. Yet, they use the exact same iteration protocol
    as `for` loops and are just another kind of shortcut.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`for`语句，尽管看起来并不是非常面向对象，实际上是一种显然面向对象设计原则的快捷方式。在我们讨论理解时，请记住这一点，因为它们似乎是面向对象工具的完全相反。然而，它们使用与`for`循环完全相同的迭代协议，只是另一种快捷方式。
- en: Comprehensions
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解
- en: Comprehensions are simple, but powerful, syntaxes that allow us to transform
    or filter an iterable object in as little as one line of code. The resultant object
    can be a perfectly normal list, set, or dictionary, or it can be a generator expression
    that can be efficiently consumed in one go.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 理解是简单但强大的语法，允许我们在一行代码中转换或过滤可迭代对象。结果对象可以是一个完全正常的列表、集合或字典，也可以是一个生成器表达式，可以在一次性中高效地消耗。
- en: List comprehensions
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表理解
- en: List comprehensions are one of the most powerful tools in Python, so people
    tend to think of them as advanced. They're not. Indeed, I've taken the liberty
    of littering previous examples with comprehensions and assuming you'd understand
    them. While it's true that advanced programmers use comprehensions a lot, it's
    not because they're advanced, it's because they're trivial, and handle some of
    the most common operations in software development.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 列表理解是Python中最强大的工具之一，所以人们倾向于认为它们是高级的。它们不是。事实上，我已经在以前的例子中使用了理解，并假设你会理解它们。虽然高级程序员确实经常使用理解，但并不是因为它们很高级，而是因为它们很琐碎，并处理软件开发中最常见的一些操作。
- en: 'Let''s have a look at one of those common operations; namely, converting a
    list of items into a list of related items. Specifically, let''s assume we just
    read a list of strings from a file, and now we want to convert it to a list of
    integers. We know every item in the list is an integer, and we want to do some
    activity (say, calculate an average) on those numbers. Here''s one simple way
    to approach it:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看其中一个常见的操作；即将一组项目转换为相关项目的列表。具体来说，假设我们刚刚从文件中读取了一个字符串列表，现在我们想将其转换为一个整数列表。我们知道列表中的每个项目都是整数，并且我们想对这些数字进行一些操作（比如计算平均值）。以下是一种简单的方法来解决这个问题：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This works fine and it''s only three lines of code. If you aren''t used to
    comprehensions, you may not even think it looks ugly! Now, look at the same code
    using a list comprehension:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子运行良好，只有三行代码。如果你不习惯理解，你可能甚至不会觉得它看起来很丑！现在，看看使用列表理解的相同代码：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We're down to one line and, importantly for performance, we've dropped an `append`
    method call for each item in the list. Overall, it's pretty easy to tell what's
    going on, even if you're not used to comprehension syntax.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只剩下一行，而且，对于性能来说，我们已经删除了列表中每个项目的`append`方法调用。总的来说，很容易看出发生了什么，即使你不习惯理解推导语法。
- en: The square brackets indicate, as always, that we're creating a list. Inside
    this list is a `for` loop that iterates over each item in the input sequence.
    The only thing that may be confusing is what's happening between the list's opening
    brace and the start of the `for` loop. Whatever happens here is applied to *each*
    of the items in the input list. The item in question is referenced by the `num`
    variable from the loop. So, it's converting each individual element to an `int`
    data type.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号表示，我们正在创建一个列表。在这个列表中是一个`for`循环，它遍历输入序列中的每个项目。唯一可能令人困惑的是列表的左大括号和`for`循环开始之间发生了什么。这里发生的事情应用于输入列表中的*每个*项目。所讨论的项目由循环中的`num`变量引用。因此，它将每个单独的元素转换为`int`数据类型。
- en: That's all there is to a basic list comprehension. They are not so advanced
    after all. Comprehensions are highly optimized C code; list comprehensions are
    far faster than `for` loops when looping over a huge number of items. If readability
    alone isn't a convincing reason to use them as much as possible, speed should
    be.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是基本列表推导的全部内容。它们并不那么高级。推导是高度优化的C代码；当循环遍历大量项目时，列表推导比`for`循环要快得多。如果仅凭可读性不足以说服你尽可能多地使用它们，速度应该是一个令人信服的理由。
- en: 'Converting one list of items into a related list isn''t the only thing we can
    do with a list comprehension. We can also choose to exclude certain values by
    adding an `if` statement inside the comprehension. Have a look:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个项目列表转换为相关列表并不是列表推导唯一能做的事情。我们还可以选择通过在推导中添加`if`语句来排除某些值。看一下：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: I shortened the name of the variable from `num` to `n` and the result variable
    to `output_ints` so it would still fit on one line. Other than this, all that's
    different between this example and the previous one is the `if len(n) < 3` part.
    This extra code excludes any strings with more than two characters. The `if` statement
    is applied before the `int` function, so it's testing the length of a string.
    Since our input strings are all integers at heart, it excludes any number over
    99\. Now that is all there is to list comprehensions! We use them to map input
    values to output values, applying a filter along the way to include or exclude
    any values that meet a specific condition.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我将变量的名称从`num`缩短为`n`，将结果变量缩短为`output_ints`，这样它仍然可以放在一行上。除此之外，这个例子和前一个例子之间的唯一不同是`if
    len(n) < 3`部分。这个额外的代码排除了任何长度超过两个字符的字符串。`if`语句应用于`int`函数之前，因此它测试字符串的长度。由于我们的输入字符串本质上都是整数，它排除了任何大于99的数字。现在列表推导就是这样了！我们用它们将输入值映射到输出值，同时应用过滤器来包括或排除满足特定条件的任何值。
- en: 'Any iterable can be the input to a list comprehension; anything we can wrap
    in a `for` loop can also be placed inside a comprehension. For example, text files
    are iterable; each call to `__next__` on the file''s iterator will return one
    line of the file. We could load a tab delimited file where the first line is a
    header row into a dictionary using the `zip` function:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 任何可迭代对象都可以成为列表推导的输入；我们可以将任何可以放在`for`循环中的东西也放在推导中。例如，文本文件是可迭代的；文件的迭代器上的每次调用`__next__`将返回文件的一行。我们可以使用`zip`函数将制表符分隔的文件加载到字典中，其中第一行是标题行：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This time, I've added some whitespace to make it somewhat more readable (list
    comprehensions don't *have* to fit on one line). This example creates a list of
    dictionaries from the zipped header and split lines for each line in the file.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我添加了一些空格，使其更易读一些（列表推导不一定要放在一行上）。这个例子从文件的标题和分割行创建了一个字典列表。
- en: Er, what? Don't worry if that code or explanation doesn't make sense; it's a
    bit confusing. One list comprehension is doing a pile of work here, and the code
    is hard to understand, read, and ultimately, maintain. This example shows that
    list comprehensions aren't always the best solution; most programmers would agree
    that a `for` loop would be more readable than this version.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，什么？如果那段代码或解释没有意义，不要担心；有点令人困惑。一个列表推导在这里做了大量的工作，代码很难理解、阅读，最终也难以维护。这个例子表明列表推导并不总是最好的解决方案；大多数程序员都会同意，`for`循环比这个版本更可读。
- en: Tip
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Remember: the tools we are provided with should not be abused! Always pick
    the right tool for the job, which is always to write maintainable code.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：我们提供的工具不应该被滥用！始终选择合适的工具，即编写可维护的代码。
- en: Set and dictionary comprehensions
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合和字典推导
- en: Comprehensions aren't restricted to lists. We can use a similar syntax with
    braces to create sets and dictionaries as well. Let's start with sets. One way
    to create a set is to wrap a list comprehension in the `set()` constructor, which
    converts it to a set. But why waste memory on an intermediate list that gets discarded,
    when we can create a set directly?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 推导不仅限于列表。我们也可以使用类似的语法用大括号创建集合和字典。让我们从集合开始。创建集合的一种方法是将列表推导包装在`set()`构造函数中，将其转换为集合。但是，为什么要浪费内存在一个被丢弃的中间列表上，当我们可以直接创建一个集合呢？
- en: 'Here''s an example that uses a named tuple to model author/title/genre triads,
    and then retrieves a set of all the authors that write in a specific genre:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子，它使用命名元组来模拟作者/标题/流派三元组，然后检索写作特定流派的所有作者的集合：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The highlighted set comprehension sure is short in comparison to the demo-data
    setup! If we were to use a list comprehension, of course, Terry Pratchett would
    have been listed twice.. As it is, the nature of sets removes the duplicates,
    and we end up with:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 与演示数据设置相比，突出显示的集合推导确实很短！如果我们使用列表推导，特里·普拉切特当然会被列出两次。因为集合的性质消除了重复项，我们最终得到：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can introduce a colon to create a dictionary comprehension. This converts
    a sequence into a dictionary using *key: value* pairs. For example, it may be
    useful to quickly look up the author or genre in a dictionary if we know the title.
    We can use a dictionary comprehension to map titles to book objects:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以引入冒号来创建字典理解。这将使用*键:值*对将序列转换为字典。例如，如果我们知道标题，可能会很有用快速查找字典中的作者或流派。我们可以使用字典理解将标题映射到书籍对象：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, we have a dictionary, and can look up books by title using the normal syntax.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了一个字典，可以使用正常的语法按标题查找书籍。
- en: In summary, comprehensions are not advanced Python, nor are they "non-object-oriented"
    tools that should be avoided. They are simply a more concise and optimized syntax
    for creating a list, set, or dictionary from an existing sequence.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，理解不是高级Python，也不是应该避免使用的“非面向对象”工具。它们只是一种更简洁和优化的语法，用于从现有序列创建列表、集合或字典。
- en: Generator expressions
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器表达式
- en: Sometimes we want to process a new sequence without placing a new list, set,
    or dictionary into system memory. If we're just looping over items one at a time,
    and don't actually care about having a final container object created, creating
    that container is a waste of memory. When processing one item at a time, we only
    need the current object stored in memory at any one moment. But when we create
    a container, all the objects have to be stored in that container before we start
    processing them.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们希望处理一个新的序列，而不将新的列表、集合或字典放入系统内存中。如果我们只是逐个循环遍历项目，并且实际上并不关心是否创建最终的容器对象，那么创建该容器就是对内存的浪费。在逐个处理项目时，我们只需要当前对象在任一时刻存储在内存中。但是当我们创建一个容器时，所有对象都必须在开始处理它们之前存储在该容器中。
- en: 'For example, consider a program that processes log files. A very simple log
    might contain information in this format:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个处理日志文件的程序。一个非常简单的日志文件可能包含以下格式的信息：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Log files for popular web servers, databases, or e-mail servers can contain
    many gigabytes of data (I recently had to clean nearly 2 terabytes of logs off
    a misbehaving system). If we want to process each line in the log, we can't use
    a list comprehension; it would create a list containing every line in the file.
    This probably wouldn't fit in RAM and could bring the computer to its knees, depending
    on the operating system.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 流行的网络服务器、数据库或电子邮件服务器的日志文件可能包含大量的数据（我最近不得不清理近2TB的日志文件）。如果我们想处理日志中的每一行，我们不能使用列表理解；它会创建一个包含文件中每一行的列表。这可能不适合在RAM中，并且可能会使计算机陷入困境，这取决于操作系统。
- en: If we used a `for` loop on the log file, we could process one line at a time
    before reading the next one into memory. Wouldn't be nice if we could use comprehension
    syntax to get the same effect?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在日志文件上使用`for`循环，我们可以在将下一行读入内存之前一次处理一行。如果我们能使用理解语法来达到相同的效果，那不是很好吗？
- en: This is where generator expressions come in. They use the same syntax as comprehensions,
    but they don't create a final container object. To create a generator expression,
    wrap the comprehension in `()` instead of `[]` or `{}`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是生成器表达式的用武之地。它们使用与理解相同的语法，但它们不创建最终的容器对象。要创建生成器表达式，将理解包装在`()`中，而不是`[]`或`{}`。
- en: 'The following code parses a log file in the previously presented format, and
    outputs a new log file that contains only the `WARNING` lines:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码解析了以前呈现格式的日志文件，并输出了一个只包含`WARNING`行的新日志文件：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This program takes the two filenames on the command line, uses a generator
    expression to filter out the warnings (in this case, it uses the `if` syntax,
    and leaves the line unmodified), and then outputs the warnings to another file.
    If we run it on our sample file, the output looks like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序在命令行上接受两个文件名，使用生成器表达式来过滤警告（在这种情况下，它使用`if`语法，并且保持行不变），然后将警告输出到另一个文件。如果我们在示例文件上运行它，输出如下：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Of course, with such a short input file, we could have safely used a list comprehension,
    but if the file is millions of lines long, the generator expression will have
    a huge impact on both memory and speed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对于这样一个短的输入文件，我们可以安全地使用列表理解，但是如果文件有数百万行，生成器表达式将对内存和速度产生巨大影响。
- en: Generator expressions are frequently most useful inside function calls. For
    example, we can call `sum`, `min`, or `max`, on a generator expression instead
    of a list, since these functions process one object at a time. We're only interested
    in the result, not any intermediate container.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式在函数调用内部经常最有用。例如，我们可以对生成器表达式调用`sum`、`min`或`max`，而不是列表，因为这些函数一次处理一个对象。我们只对结果感兴趣，而不关心任何中间容器。
- en: In general, a generator expression should be used whenever possible. If we don't
    actually need a list, set, or dictionary, but simply need to filter or convert
    items in a sequence, a generator expression will be most efficient. If we need
    to know the length of a list, or sort the result, remove duplicates, or create
    a dictionary, we'll have to use the comprehension syntax.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，应尽可能使用生成器表达式。如果我们实际上不需要列表、集合或字典，而只需要过滤或转换序列中的项目，生成器表达式将是最有效的。如果我们需要知道列表的长度，或对结果进行排序、去除重复项或创建字典，我们将不得不使用理解语法。
- en: Generators
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器
- en: Generator expressions are actually a sort of comprehension too; they compress
    the more advanced (this time it really is more advanced!) generator syntax into
    one line. The greater generator syntax looks even less object-oriented than anything
    we've seen, but we'll discover that once again, it is a simple syntax shortcut
    to create a kind of object.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式实际上也是一种理解；它将更高级（这次确实更高级！）的生成器语法压缩成一行。更高级的生成器语法看起来甚至不那么面向对象，但我们将发现，它再次是一种简单的语法快捷方式，用于创建一种对象。
- en: 'Let''s take the log file example a little further. If we want to delete the
    `WARNING` column from our output file (since it''s redundant: this file contains
    only warnings), we have several options, at various levels of readability. We
    can do it with a generator expression:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步看一下日志文件的例子。如果我们想要从输出文件中删除`WARNING`列（因为它是多余的：这个文件只包含警告），我们有几种选择，不同的可读性级别。我们可以使用生成器表达式来实现：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'That''s perfectly readable, though I wouldn''t want to make the expression
    much more complicated than that. We could also do it with a normal `for` loop:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完全可读的，尽管我不想使表达式比那更复杂。我们也可以使用普通的`for`循环来实现：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'That''s maintainable, but so many levels of indent in so few lines is kind
    of ugly. More alarmingly, if we wanted to do something different with the lines,
    rather than just printing them out, we''d have to duplicate the looping and conditional
    code, too. Now let''s consider a truly object-oriented solution, without any shortcuts:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可维护的，但在如此少的行数中有这么多级别的缩进有点丑陋。更令人担忧的是，如果我们想对这些行做一些不同的事情，而不仅仅是打印它们，我们也必须复制循环和条件代码。现在让我们考虑一个真正面向对象的解决方案，没有任何捷径：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'No doubt about it: that is so ugly and difficult to read that you may not even
    be able to tell what''s going on. We created an object that takes a file object
    as input, and provides a `__next__` method like any iterator.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问：这是如此丑陋和难以阅读，以至于你甚至可能无法理解发生了什么。我们创建了一个以文件对象为输入的对象，并提供了一个像任何迭代器一样的`__next__`方法。
- en: This `__next__` method reads lines from the file, discarding them if they are
    not `WARNING` lines. When it encounters a `WARNING` line, it returns it. Then
    the `for` loop will call `__next__` again to process the next `WARNING` line.
    When we run out of lines, we raise `StopIteration` to tell the loop we're finished
    iterating. It's pretty ugly compared to the other examples, but it's also powerful;
    now that we have a class in our hands, we can do whatever we want with it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`__next__`方法从文件中读取行，如果它们不是`WARNING`行，则将它们丢弃。当它遇到`WARNING`行时，它会返回它。然后`for`循环将再次调用`__next__`来处理下一个`WARNING`行。当我们用尽行时，我们引发`StopIteration`来告诉循环我们已经完成迭代。与其他例子相比，这看起来相当丑陋，但也很强大；既然我们手头有一个类，我们可以随心所欲地使用它。
- en: 'With that background behind us, we finally get to see generators in action.
    This next example does *exactly* the same thing as the previous one: it creates
    an object with a `__next__` method that raises `StopIteration` when it''s out
    of inputs:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个背景，我们终于可以看到生成器的实际应用了。下一个例子与前一个例子*完全*相同：它创建了一个带有`__next__`方法的对象，当输入用尽时会引发`StopIteration`。
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: OK, that's pretty readable, maybe... at least it's short. But what on earth
    is going on here, it makes no sense whatsoever. And what is `yield`, anyway?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这看起来相当可读，也许...至少很简短。但这到底是怎么回事，一点道理也没有。`yield`又是什么？
- en: In fact, `yield` is the key to generators. When Python sees `yield` in a function,
    it takes that function and wraps it up in an object not unlike the one in our
    previous example. Think of the `yield` statement as similar to the `return` statement;
    it exits the function and returns a line. Unlike `return`, however, when the function
    is called again (via `next()`), it will start where it left off―on the line after
    the `yield` statement―instead of at the beginning of the function. In this example,
    there is no line "after" the `yield` statement, so it jumps to the next iteration
    of the `for` loop. Since the `yield` statement is inside an `if` statement, it
    only yields lines that contain `WARNING`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`yield`是生成器的关键。当Python在函数中看到`yield`时，它会将该函数包装成一个对象，类似于我们前面例子中的对象。将`yield`语句视为类似于`return`语句；它退出函数并返回一行。然而，当函数再次被调用（通过`next()`）时，它将从上次离开的地方开始——在`yield`语句之后的行——而不是从函数的开头开始。在这个例子中，`yield`语句之后没有行，所以它跳到`for`循环的下一个迭代。由于`yield`语句在`if`语句内，它只会产生包含`WARNING`的行。
- en: 'While it looks like this is just a function looping over the lines, it is actually
    creating a special type of object, a generator object:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来像是一个函数在循环处理行，但实际上它创建了一种特殊类型的对象，即生成器对象：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: I passed an empty list into the function to act as an iterator. All the function
    does is create and return a generator object. That object has `__iter__` and `__next__`
    methods on it, just like the one we created in the previous example. Whenever
    `__next__` is called, the generator runs the function until it finds a `yield`
    statement. It then returns the value from `yield`, and the next time `__next__`
    is called, it picks up where it left off.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我将一个空列表传递给函数，作为迭代器。函数所做的就是创建并返回一个生成器对象。该对象上有`__iter__`和`__next__`方法，就像我们在前面的例子中创建的那样。每当调用`__next__`时，生成器运行函数，直到找到一个`yield`语句。然后返回`yield`的值，下次调用`__next__`时，它将从上次离开的地方继续。
- en: This use of generators isn't that advanced, but if you don't realize the function
    is creating an object, it can seem like magic. This example was quite simple,
    but you can get really powerful effects by making multiple calls to `yield` in
    a single function; the generator will simply pick up at the most recent `yield`
    and continue to the next one.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种生成器的使用并不是很高级，但如果你没有意识到函数正在创建一个对象，它可能看起来像魔术。这个例子很简单，但通过在单个函数中多次调用`yield`，你可以获得非常强大的效果；生成器将简单地从最近的`yield`开始，并继续到下一个`yield`。
- en: Yield items from another iterable
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从另一个可迭代对象中产生值
- en: Often, when we build a generator function, we end up in a situation where we
    want to yield data from another iterable object, possibly a list comprehension
    or generator expression we constructed inside the generator, or perhaps some external
    items that were passed into the function. This has always been possible by looping
    over the iterable and individually yielding each item. However, in Python version
    3.3, the Python developers introduced a new syntax to make this a little more
    elegant.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们构建一个生成器函数时，我们最终会处于这样一种情况：我们希望从另一个可迭代对象中产生数据，可能是我们在生成器内部构造的列表推导或生成器表达式，或者是一些外部传递到函数中的项目。以前一直可以通过循环遍历可迭代对象并逐个产生每个项目来实现这一点。然而，在Python
    3.3版本中，Python开发人员引入了一种新的语法，使这一点更加优雅。
- en: Let's adapt the generator example a bit so that instead of accepting a sequence
    of lines, it accepts a filename. This would normally be frowned upon as it ties
    the object to a particular paradigm. When possible we should operate on iterators
    as input; this way the same function could be used regardless of whether the log
    lines came from a file, memory, or a web-based log aggregator. So the following
    example is contrived for pedagogical reasons.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微调整一下生成器示例，使其不再接受一系列行，而是接受一个文件名。这通常会被认为是不好的，因为它将对象与特定的范例联系在一起。在可能的情况下，我们应该操作输入的迭代器；这样，相同的函数可以在日志行来自文件、内存或基于网络的日志聚合器的情况下使用。因此，以下示例是为了教学目的而人为构造的。
- en: 'This version of the code illustrates that your generator can do some basic
    setup before yielding information from another iterable (in this case, a generator
    expression):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的代码说明了你的生成器可以在从另一个可迭代对象（在本例中是生成器表达式）产生信息之前做一些基本的设置：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This code combines the `for` loop from the previous example into a generator
    expression. Notice how I put the three clauses of the generator expression (the
    transformation, the loop, and the filter) on separate lines to make them more
    readable. Notice also that this transformation didn't help enough; the previous
    example with a `for` loop was more readable.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将前面示例中的`for`循环合并到了一个生成器表达式中。请注意，我将生成器表达式的三个子句（转换、循环和过滤）放在不同的行上，以使它们更易读。还要注意，这种转换并没有帮助太多；前面的`for`循环示例更易读。
- en: 'So let''s consider an example that is more readable than its alternative. It
    can be useful to construct a generator that yields data from multiple other generators.
    The `itertools.chain` function, for example, yields data from iterables in sequence
    until they have all been exhausted. This can be implemented far too easily using
    the `yield from` syntax, so let''s consider a classic computer science problem:
    walking a general tree.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们考虑一个比其替代方案更易读的示例。构建一个生成器，从多个其他生成器中产生数据，这是有用的。例如，`itertools.chain`函数按顺序从可迭代对象中产生数据，直到它们全部耗尽。这可以使用`yield
    from`语法实现得太容易了，因此让我们考虑一个经典的计算机科学问题：遍历一棵通用树。
- en: 'A common implementation of the general tree data structure is a computer''s
    filesystem. Let''s model a few folders and files in a Unix filesystem so we can
    use `yield from` to walk them effectively:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通用树数据结构的常见实现是计算机的文件系统。让我们模拟Unix文件系统中的一些文件夹和文件，以便我们可以使用`yield from`有效地遍历它们：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This setup code looks like a lot of work, but in a real filesystem, it would
    be even more involved. We''d have to read data from the hard drive and structure
    it into the tree. Once in memory, however, the code that outputs every file in
    the filesystem is quite elegant:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置代码看起来很费力，但在一个真实的文件系统中，它会更加复杂。我们需要从硬盘中读取数据，并将其结构化成树。然而，一旦在内存中，输出文件系统中的每个文件的代码就非常优雅。
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If this code encounters a directory, it recursively asks `walk()` to generate
    a list of all files subordinate to each of its children, and then yields all that
    data plus its own filename. In the simple case that it has encountered a normal
    file, it just yields that name.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这段代码遇到一个目录，它会递归地要求`walk()`生成其每个子目录下所有文件的列表，然后产生所有这些数据以及自己的文件名。在它遇到一个普通文件的简单情况下，它只会产生那个文件名。
- en: As an aside, solving the preceding problem without using a generator is tricky
    enough that this problem is a common interview question. If you answer it as shown
    like this, be prepared for your interviewer to be both impressed and somewhat
    irritated that you answered it so easily. They will likely demand that you explain
    exactly what is going on. Of course, armed with the principles you've leaned in
    this chapter, you won't have any problem.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，解决前面的问题而不使用生成器是非常棘手的，以至于这个问题是一个常见的面试问题。如果你像这样回答，准备好让你的面试官既印象深刻又有些恼火，因为你回答得太容易了。他们可能会要求你解释到底发生了什么。当然，有了你在本章学到的原则，你不会有任何问题。
- en: 'The `yield from` syntax is a useful shortcut when writing chained generators,
    but it is more commonly used for a different purpose: piping data through coroutines.
    We''ll see many examples of this in [Chapter 13](ch13.html "Chapter 13. Concurrency"),
    *Concurrency*, but for now, let''s discover what a coroutine is.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield from`语法在编写链式生成器时是一个有用的快捷方式，但它更常用于不同的目的：通过协程传输数据。我们将在[第13章](ch13.html
    "Chapter 13. Concurrency")中看到许多这样的例子，但现在，让我们先了解一下协程是什么。'
- en: Coroutines
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协程
- en: Coroutines are extremely powerful constructs that are often confused with generators.
    Many authors inappropriately describe coroutines as "generators with a bit of
    extra syntax." This is an easy mistake to make, as, way back in Python 2.5, when
    coroutines were introduced, they were presented as "we added a `send` method to
    the generator syntax." This is further complicated by the fact that when you create
    a coroutine in Python, the object returned is a generator. The difference is actually
    a lot more nuanced and will make more sense after you've seen a few examples.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 协程是非常强大的构造，经常被误解为生成器。许多作者不恰当地将协程描述为“带有一些额外语法的生成器”。这是一个容易犯的错误，因为在Python 2.5时引入协程时，它们被介绍为“我们在生成器语法中添加了一个`send`方法”。这更加复杂的是，当你在Python中创建一个协程时，返回的对象是一个生成器。实际上，区别要微妙得多，在你看到一些例子之后会更有意义。
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While coroutines in Python are currently tightly coupled to the generator syntax,
    they are only superficially related to the iterator protocol we have been discussing.
    The upcoming (as this is published) Python 3.5 release makes coroutines a truly
    standalone object and will provide a new syntax to work with them.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Python中的协程目前与生成器语法紧密耦合，但它们与我们讨论过的迭代器协议只是表面上相关。即将发布的Python 3.5版本将使协程成为一个真正独立的对象，并提供一种新的语法来处理它们。
- en: The other thing to bear in mind is that coroutines are pretty hard to understand.
    They are not used all that often in the wild, and you could likely skip this section
    and happily develop in Python for years without missing or even encountering them.
    There are a couple libraries that use coroutines extensively (mostly for concurrent
    or asynchronous programming), but they are normally written such that you can
    use coroutines without actually understanding how they work! So if you get lost
    in this section, don't despair.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件需要记住的事情是，协程很难理解。它们在实际中并不经常使用，你可能会在Python中开发多年而不会错过或甚至遇到它们。有一些库广泛使用协程（主要用于并发或异步编程），但它们通常是这样编写的，以便你可以在不实际理解它们如何工作的情况下使用协程！所以如果你在这一节迷失了方向，不要绝望。
- en: 'But you won''t get lost, having studied the following examples. Here''s one
    of the simplest possible coroutines; it allows us to keep a running tally that
    can be increased by arbitrary values:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 但是你不会迷失方向，因为已经学习了以下示例。这是最简单的协程之一；它允许我们保持一个可以通过任意值增加的累加值：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This code looks like black magic that couldn''t possibly work, so we''ll see
    it working before going into a line-by-line description. This simple object could
    be used by a scoring application for a baseball team. Separate tallies could be
    kept for each team, and their score could be incremented by the number of runs
    accumulated at the end of every half-inning. Look at this interactive session:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来像不可能工作的黑魔法，所以我们将在逐行描述之前看到它的工作原理。这个简单的对象可以被棒球队的记分应用程序使用。可以为每个团队保留单独的计分，并且他们的得分可以在每个半局结束时递增。看看这个交互式会话：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: First we construct two `tally` objects, one for each team. Yes, they look like
    functions, but as with the generator objects in the previous section, the fact
    that there is a `yield` statement inside the function tells Python to put a great
    deal of effort into turning the simple function into an object.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们构造两个`tally`对象，一个用于每个团队。是的，它们看起来像函数，但与上一节中的生成器对象一样，函数内部有`yield`语句告诉Python要花大量精力将简单函数转换为对象。
- en: We then call `next()` on each of the coroutine objects. This does the same thing
    as calling next on any generator, which is to say, it executes each line of code
    until it encounters a `yield` statement, returns the value at that point, and
    then *pauses* until the next `next()` call.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们对每个协程对象调用`next()`。这与对任何生成器调用`next`的操作相同，也就是说，它执行代码的每一行，直到遇到`yield`语句，返回该点的值，然后*暂停*直到下一个`next()`调用。
- en: 'So far, then, there''s nothing new. But look back at the `yield` statement
    in our coroutine:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，没有什么新鲜的。但是回顾一下我们协程中的`yield`语句：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Unlike with generators, this yield function looks like it's supposed to return
    a value and assign it to a variable. This is, in fact, exactly what's happening.
    The coroutine is still paused at the `yield` statement and waiting to be activated
    again by another call to `next()`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 与生成器不同，这个yield函数看起来应该返回一个值并将其分配给一个变量。事实上，这正是发生的事情。协程仍然在`yield`语句处暂停，等待通过另一个`next()`调用再次激活。
- en: Or rather, as you see in the interactive session, a call to a method called
    `send()`. The `send()` method does *exactly* the same thing as `next()` except
    that in addition to advancing the generator to the next `yield` statement. It
    also allows you to pass in a value from outside the generator. This value is assigned
    to the left side of the `yield` statement.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，正如你在交互式会话中看到的那样，调用一个名为`send()`的方法。`send()`方法与`next()`完全相同，只是除了将生成器推进到下一个`yield`语句外，它还允许你从生成器外部传入一个值。这个值被分配给`yield`语句的左侧。
- en: 'The thing that is really confusing for many people is the order in which this
    happens:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多人来说，真正令人困惑的是这发生的顺序：
- en: '`yield` occurs and the generator pauses'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yield`发生，生成器暂停'
- en: '`send()` occurs from outside the function and the generator wakes up'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`send()`来自函数外部，生成器被唤醒'
- en: The value sent in is assigned to the left side of the `yield` statement
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送的值被分配给`yield`语句的左侧
- en: The generator continues processing until it encounters another `yield` statement
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器继续处理，直到遇到另一个`yield`语句
- en: 'So, in this particular example, after we construct the coroutine and advance
    it to the `yield` statement with a call to `next()`, each successive call to `send()`
    passes a value into the coroutine, which adds this value to its score, goes back
    to the top of the `while` loop, and keeps processing until it hits the `yield`
    statement. The `yield` statement returns a value, and this value becomes the return
    value of the most recent call to `send`. Don''t miss that: the `send()` method
    does not just submit a value to the generator, it also returns the value from
    the upcoming `yield` statement, just like `next()`. This is how we define the
    difference between a generator and a coroutine: a generator only produces values,
    while a coroutine can also consume them.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个特定的示例中，我们构造了协程并通过调用`next()`将其推进到`yield`语句，然后每次调用`send()`都会将一个值传递给协程，协程将这个值加到其分数中，然后返回到`while`循环的顶部，并继续处理直到达到`yield`语句。`yield`语句返回一个值，这个值成为最近一次`send`调用的返回值。不要错过：`send()`方法不仅仅提交一个值给生成器，它还返回即将到来的`yield`语句的值，就像`next()`一样。这就是我们定义生成器和协程之间的区别的方式：生成器只产生值，而协程也可以消耗值。
- en: Note
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The behavior and syntax of `next(i)`, `i.__next__()`, and `i.send(value)` are
    rather unintuitive and frustrating. The first is a normal function, the second
    is a special method, and the last is a normal method. But all three do the same
    thing: advance the generator until it yields a value and pause. Further, the `next()`
    function and associated method can be replicated by calling `i.send(None)`. There
    is value to having two different method names here, since it helps the reader
    of our code easily see whether they are interacting with a coroutine or a generator.
    I just find the fact that in one case it''s a function call and in the other it''s
    a normal method somewhat irritating.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`next(i)`，`i.__next__()`和`i.send(value)`的行为和语法相当不直观和令人沮丧。第一个是普通函数，第二个是特殊方法，最后一个是普通方法。但是这三个都是做同样的事情：推进生成器直到产生一个值并暂停。此外，`next()`函数和相关方法可以通过调用`i.send(None)`来复制。在这里有两个不同的方法名称是有价值的，因为它有助于我们的代码读者轻松地看到他们是在与协程还是生成器进行交互。我只是觉得在某些情况下，它是一个函数调用，而在另一种情况下，它是一个普通方法，有点令人恼火。'
- en: Back to log parsing
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回到日志解析
- en: Of course, the previous example could easily have been coded using a couple
    integer variables and calling `x += increment` on them. Let's look at a second
    example where coroutines actually save us some code. This example is a somewhat
    simplified (for pedagogical reasons) version of a problem I had to solve in my
    real job. The fact that it logically follows from the earlier discussions about
    processing a log file is completely serendipitous; those examples were written
    for the first edition of this book, whereas this problem came up four years later!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，前面的示例也可以很容易地使用几个整数变量和在它们上调用`x += increment`来编写。让我们看一个第二个示例，其中协程实际上为我们节省了一些代码。这个例子是我在真实工作中不得不解决的问题的一个简化版本（出于教学目的）。它从先前关于处理日志文件的讨论中逻辑上延伸出来，这完全是偶然的；那些示例是为本书的第一版编写的，而这个问题是四年后出现的！
- en: 'The Linux kernel log contains lines that look somewhat, but not quite completely,
    unlike this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核日志包含看起来有些类似但又不完全相同的行：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There are a whole bunch of interspersed kernel log messages, some of which pertain
    to hard disks. The hard disk messages might be interspersed with other messages,
    but they occur in a predictable format and order, in which a specific drive with
    a known serial number is associated with a bus identifier (such as `0:0:0:0`),
    and a block device identifier (such as `sda`) is associated with that bus. Finally,
    if the drive has a corrupt filesystem, it might fail with an XFS error.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多交错的内核日志消息，其中一些与硬盘有关。硬盘消息可能与其他消息交错，但它们以可预测的格式和顺序出现，其中具有已知序列号的特定驱动器与总线标识符（如`0:0:0:0`）相关联，并且与该总线相关联的块设备标识符（如`sda`）。最后，如果驱动器的文件系统损坏，它可能会出现XFS错误。
- en: Now, given the preceding log file, the problem we need to solve is how to obtain
    the serial number of any drives that have XFS errors on them. This serial number
    might later be used by a data center technician to identify and replace the drive.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑到前面的日志文件，我们需要解决的问题是如何获取任何存在XFS错误的驱动器的序列号。稍后，数据中心技术人员可能会使用这个序列号来识别并更换驱动器。
- en: We know we can identify the individual lines using regular expressions, but
    we'll have to change the regular expressions as we loop through the lines, since
    we'll be looking for different things depending on what we found previously. The
    other difficult bit is that if we find an error string, the information about
    which bus contains that string, and what serial number is attached to the drive
    on that bus has already been processed. This can easily be solved by iterating
    through the lines of the file in reverse order.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道可以使用正则表达式识别各行，但是我们必须在循环遍历行时更改正则表达式，因为根据之前找到的内容，我们将寻找不同的内容。另一个困难的地方是，如果我们找到错误字符串，关于包含该字符串的总线以及附加到该总线上的驱动器的序列号的信息已经被处理。通过以相反的顺序迭代文件的行，这个问题很容易解决。
- en: 'Before you look at this example, be warned—the amount of code required for
    a coroutine-based solution is scarily small:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看此示例之前，请注意 - 基于协程的解决方案所需的代码量非常少，令人不安：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code neatly divides the job into two separate tasks. The first task is
    to loop over all the lines and spit out any lines that match a given regular expression.
    The second task is to interact with the first task and give it guidance as to
    what regular expression it is supposed to be searching for at any given time.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将工作分为两个独立的任务。第一个任务是循环遍历所有行，并输出与给定正则表达式匹配的任何行。第二个任务是与第一个任务进行交互，并指导它在任何给定时间搜索什么正则表达式。
- en: Look at the `match_regex` coroutine first. Remember, it doesn't execute any
    code when it is constructed; rather, it just creates a coroutine object. Once
    constructed, someone outside the coroutine will eventually call `next()` to start
    the code running, at which point it stores the state of two variables, `filename`
    and `regex`. It then reads all the lines in the file and iterates over them in
    reverse. Each line is compared to the regular expression that was passed in until
    it finds a match. When the match is found, the coroutine yields the first group
    from the regular expression and waits.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先看一下`match_regex`协程。记住，它在构造时不执行任何代码；相反，它只是创建一个协程对象。一旦构造完成，协程外部的某人最终会调用`next()`来启动代码运行，此时它会存储两个变量`filename`和`regex`的状态。然后它读取文件中的所有行并以相反的顺序对它们进行迭代。将传入的每一行与正则表达式进行比较，直到找到匹配项。当找到匹配项时，协程会产生正则表达式的第一个组并等待。
- en: At some point in the future, other code will send in a new regular expression
    to search for. Note that the coroutine never cares what regular expression it
    is trying to match; it's just looping over lines and comparing them to a regular
    expression. It's somebody else's responsibility to decide what regular expression
    to supply.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在将来的某个时候，其他代码将发送一个新的正则表达式进行搜索。请注意，协程从不关心它试图匹配什么正则表达式；它只是循环遍历行并将它们与正则表达式进行比较。决定提供什么正则表达式是其他人的责任。
- en: In this case, that somebody else is the `get_serials` generator. It doesn't
    care about the lines in the file, in fact it isn't even aware of them. The first
    thing it does is create a `matcher` object from the `match_regex` coroutine constructor,
    giving it a default regular expression to search for. It advances the coroutine
    to its first `yield` and stores the value it returns. It then goes into a loop
    that instructs the matcher object to search for a bus ID based on the stored device
    ID, and then a serial number based on that bus ID.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，那个“别人”是`get_serials`生成器。它不关心文件中的行，事实上它甚至不知道它们。它做的第一件事是从`match_regex`协程构造函数创建一个`matcher`对象，并给它一个默认的正则表达式来搜索。它将协程推进到它的第一个`yield`并存储它返回的值。然后它进入一个循环，指示匹配器对象根据存储的设备ID搜索总线ID，然后根据该总线ID搜索序列号。
- en: It idly yields that serial number to the outside `for` loop before instructing
    the matcher to find another device ID and repeat the cycle.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在向外部的`for`循环中空闲地产生该序列号，然后指示匹配器查找另一个设备ID并重复循环。
- en: Basically, the coroutine's (`match_regex`, as it uses the `regex = yield` syntax)
    job is to search for the next important line in the file, while the generator's
    (`get_serial`, which uses the `yield` syntax without assignment) job is to decide
    which line is important. The generator has information about this particular problem,
    such as what order lines will appear in the file. The coroutine, on the other
    hand, could be plugged into any problem that required searching a file for given
    regular expressions.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，协程（`match_regex`，因为它使用`regex = yield`语法）的工作是在文件中搜索下一个重要的行，而生成器（`get_serial`，它使用没有赋值的`yield`语法）的工作是决定哪一行是重要的。生成器有关于这个特定问题的信息，比如文件中行的顺序。另一方面，协程可以插入到任何需要搜索文件以获取给定正则表达式的问题中。
- en: Closing coroutines and throwing exceptions
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关闭协程和抛出异常
- en: Normal generators signal their exit from inside by raising `StopIteration`.
    If we chain multiple generators together (for example, by iterating over one generator
    from inside another), the `StopIteration` exception will be propagated outward.
    Eventually, it will hit a `for` loop that will see the exception and know that
    it's time to exit the loop.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 普通生成器通过引发`StopIteration`来从内部信号退出。如果我们将多个生成器链接在一起（例如通过在另一个生成器内部迭代一个生成器），`StopIteration`异常将被传播到外部。最终，它将触发一个`for`循环，看到异常并知道是时候退出循环了。
- en: Coroutines don't normally follow the iteration mechanism; rather than pulling
    data through one until an exception is encountered, data is usually pushed into
    it (using `send`). The entity doing the pushing is normally the one in charge
    of telling the coroutine when it's finished; it does this by calling the `close()`
    method on the coroutine in question.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 协程通常不遵循迭代机制；而不是通过一个直到遇到异常的数据，通常是将数据推送到其中（使用`send`）。通常是负责推送的实体告诉协程何时完成；它通过在相关协程上调用`close()`方法来实现这一点。
- en: When called, the `close()` method will raise a `GeneratorExit` exception at
    the point the coroutine was waiting for a value to be sent in. It is normally
    good policy for coroutines to wrap their `yield` statements in a `try`...`finally`
    block so that any cleanup tasks (such as closing associated files or sockets)
    can be performed.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`close()`方法时，将在协程等待发送值的点引发一个`GeneratorExit`异常。通常，协程应该将它们的`yield`语句包装在`try`...`finally`块中，以便执行任何清理任务（例如关闭关联的文件或套接字）。
- en: If we need to raise an exception inside a coroutine, we can use the `throw()`
    method in a similar way. It accepts an exception type with optional `value` and
    `traceback` arguments. The latter is useful when we encounter an exception in
    one coroutine and want to cause an exception to occur in an adjacent coroutine
    while maintaining the traceback.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要在协程内部引发异常，我们可以类似地使用`throw()`方法。它接受一个异常类型，可选的`value`和`traceback`参数。当我们在一个协程中遇到异常并希望在相邻的协程中引发异常时，后者是非常有用的，同时保持回溯。
- en: Both of these features are vital if you're building robust coroutine-based libraries,
    but we are unlikely to encounter them in our day-to-day coding lives.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在构建健壮的基于协程的库，这两个功能都是至关重要的，但在日常编码生活中，我们不太可能遇到它们。
- en: The relationship between coroutines, generators, and functions
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协程、生成器和函数之间的关系
- en: We've seen coroutines in action, so now let's go back to that discussion of
    how they are related to generators. In Python, as is so often the case, the distinction
    is quite blurry. In fact, all coroutines are generator objects, and authors often
    use the two terms interchangeably. Sometimes, they describe coroutines as a subset
    of generators (only generators that return values from yield are considered coroutines).
    This is technically true in Python, as we've seen in the previous sections.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到协程的运行情况，现在让我们回到讨论它们与生成器的关系。在Python中，就像往常一样，这个区别是相当模糊的。事实上，所有的协程都是生成器对象，作者经常交替使用这两个术语。有时，他们将协程描述为生成器的一个子集（只有从`yield`返回值的生成器被认为是协程）。在Python中，这在技术上是正确的，正如我们在前面的部分中所看到的。
- en: However, in the greater sphere of theoretical computer science, coroutines are
    considered the more general principles, and generators are a specific type of
    coroutine. Further, normal functions are yet another distinct subset of coroutines.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在更广泛的理论计算机科学领域，协程被认为是更一般的原则，生成器是协程的一种特定类型。此外，普通函数是协程的另一个独特子集。
- en: A coroutine is a routine that can have data passed in at one or more points
    and get it out at one or more points. In Python, the point where data is passed
    in and out is the `yield` statement.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 协程是一个可以在一个或多个点传入数据并在一个或多个点获取数据的例程。在Python中，数据传入和传出的点是`yield`语句。
- en: A function, or subroutine, is the simplest type of coroutine. You can pass data
    in at one point, and get data out at one other point when the function returns.
    While a function can have multiple `return` statements, only one of them can be
    called for any given invocation of the function.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，或子例程，是最简单的协程类型。你可以在一个点传入数据，并在函数返回时在另一个点获取数据。虽然函数可以有多个`return`语句，但对于任何给定的函数调用，只能调用其中一个。
- en: Finally, a generator is a type of coroutine that can have data passed in at
    one point, but can pass data out at multiple points. In Python, the data would
    be passed out at a `yield` statement, but you can't pass data back in. If you
    called `send`, the data would be silently discarded.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，生成器是一种协程类型，可以在一个点传入数据，但可以在多个点传出数据。在Python中，数据将在`yield`语句处传出，但你不能将数据传回。如果你调用了`send`，数据将被悄悄丢弃。
- en: So in theory, generators are types of coroutines, functions are types of coroutines,
    and there are coroutines that are neither functions nor generators. That's simple
    enough, eh? So why does it feel more complicated in Python?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 所以理论上，生成器是协程的一种类型，函数是协程的一种类型，还有一些既不是函数也不是生成器的协程。够简单吧？那为什么在Python中感觉更复杂呢？
- en: In Python, generators and coroutines are both constructed using a syntax that
    looks like we are constructing a function. But the resulting object is not a function
    at all; it's a totally different kind of object. Functions are, of course, also
    objects. But they have a different interface; functions are callable and return
    values, generators have data pulled out using `next()`, and coroutines have data
    pushed in using `send`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，生成器和协程都是使用看起来像是构造函数的语法构造的。但是生成的对象根本不是函数；它是一种完全不同类型的对象。函数当然也是对象。但它们有不同的接口；函数是可调用的并返回值，生成器使用`next()`提取数据，协程使用`send`推送数据。
- en: Case study
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: 'One of the fields in which Python is the most popular these days is data science.
    Let''s implement a basic machine learning algorithm! Machine learning is a huge
    topic, but the general idea is to make predictions or classifications about future
    data by using knowledge gained from past data. Uses of such algorithms abound,
    and data scientists are finding new ways to apply machine learning every day.
    Some important machine learning applications include computer vision (such as
    image classification or facial recognition), product recommendation, identifying
    spam, and speech recognition. We''ll look at a simpler problem: given an RGB color
    definition, what name would humans identify that color as?'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Python目前最流行的领域之一是数据科学。让我们实现一个基本的机器学习算法！机器学习是一个庞大的主题，但总体思想是利用从过去数据中获得的知识对未来数据进行预测或分类。这些算法的用途很广泛，数据科学家们每天都在找到新的应用机器学习的方法。一些重要的机器学习应用包括计算机视觉（如图像分类或人脸识别）、产品推荐、识别垃圾邮件和语音识别。我们将研究一个更简单的问题：给定一个RGB颜色定义，人们会将该颜色识别为什么名称？
- en: 'There are more than 16 million colors in the standard RGB color space, and
    humans have come up with names for only a fraction of them. While there are thousands
    of names (some quite ridiculous; just go to any car dealership or makeup store),
    let''s build a classifier that attempts to divide the RGB space into the basic
    colors:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准RGB颜色空间中有超过1600万种颜色，人类只为其中的一小部分制定了名称。虽然有成千上万的名称（有些相当荒谬；只需去任何汽车经销商或化妆品商店），让我们构建一个试图将RGB空间划分为基本颜色的分类器：
- en: Red
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红色
- en: Purple
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紫色
- en: Blue
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝色
- en: Green
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绿色
- en: Yellow
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黄色
- en: Orange
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 橙色
- en: Grey
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灰色
- en: White
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 白色
- en: Pink
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粉色
- en: The first thing we need is a dataset to train our algorithm on. In a production
    system, you might scrape a *list of colors* website or survey thousands of people.
    Instead, I created a simple application that renders a random color and asks the
    user to select one of the preceding nine options to classify it. This application
    is included with the example code for this chapter in the `kivy_color_classifier`
    directory, but we won't be going into the details of this code as its only purpose
    here is to generate sample data.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的第一件事是一个数据集来训练我们的算法。在生产系统中，你可能会从*颜色列表*网站上获取数据，或者对成千上万的人进行调查。相反，我创建了一个简单的应用程序，它会渲染一个随机颜色，并要求用户选择前述九个选项中的一个来对其进行分类。这个应用程序包含在本章的示例代码中的`kivy_color_classifier`目录中，但我们不会详细介绍这段代码，因为它在这里的唯一目的是生成样本数据。
- en: Note
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: Kivy has an incredibly well-engineered object-oriented API that you may want
    to explore on your own time. If you would like to develop graphical programs that
    run on many systems, from your laptop to your cell phone, you might want to check
    out my book, *Creating Apps In Kivy*, *O'Reilly*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Kivy有一个非常精心设计的面向对象的API，你可能想自己探索一下。如果你想开发可以在许多系统上运行的图形程序，从你的笔记本电脑到你的手机，你可能想看看我的书《在Kivy中创建应用》，*O'Reilly*。
- en: 'For the purposes of this case study, the important thing about that application
    is the output, which is a **comma-separated value** (**CSV**) file that contains
    four values per row: the red, green, and blue values (represented as a floating-point
    number between zero and one), and one of the preceding nine names that the user
    assigned to that color. The dataset looks something like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个案例研究中，该应用程序的重要之处在于输出，这是一个包含每行四个值的**逗号分隔值**（**CSV**）文件：红色、绿色和蓝色值（表示为0到1之间的浮点数），以及用户为该颜色分配的前述九个名称中的一个。数据集看起来像这样：
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: I made 200 datapoints (a very few of them untrue) before I got bored and decided
    it was time to start machine learning on this dataset. These datapoints are shipped
    with the examples for this chapter if you would like to use my data (nobody's
    ever told me I'm color-blind, so it should be somewhat reasonable).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在我感到无聊并决定开始对这个数据集进行机器学习之前，我制作了200个数据点（其中很少有不真实的数据）。如果你想使用我的数据（没有人告诉我我是色盲，所以应该是相当合理的），这些数据点已经包含在本章的示例中。
- en: We'll be implementing one of the simpler machine-learning algorithms, referred
    to as k-nearest neighbor. This algorithm relies on some kind of "distance" calculation
    between points in the dataset (in our case, we can use a three-dimensional version
    of the Pythagorean theorem). Given a new datapoint, it finds a certain number
    (referred to as k, as in k-nearest neighbors) of datapoints that are closest to
    it when measured by that distance calculation. Then it combines those datapoints
    in some way (an average might work for linear calculations; for our classification
    problem, we'll use the mode), and returns the result.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个较简单的机器学习算法，称为k最近邻算法。该算法依赖于数据集中点之间的某种“距离”计算（在我们的情况下，我们可以使用三维版本的毕达哥拉斯定理）。给定一个新的数据点，它找到一定数量（称为k，如k最近邻）的数据点，这些数据点在通过该距离计算时最接近它。然后以某种方式组合这些数据点（对于线性计算，平均值可能有效；对于我们的分类问题，我们将使用众数），并返回结果。
- en: We won't go into too much detail about what the algorithm does; rather, we'll
    focus on some of the ways we can apply the iterator pattern or iterator protocol
    to this problem.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会过多地讨论算法的具体内容；相反，我们将专注于如何将迭代器模式或迭代器协议应用于这个问题。
- en: 'Let''s now write a program that performs the following steps in order:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个程序，按顺序执行以下步骤：
- en: Load the sample data from the file and construct a model from it.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从文件中加载样本数据并构建模型。
- en: Generate 100 random colors.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成100种随机颜色。
- en: Classify each color and output it to a file in the same format as the input.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对每种颜色进行分类，并将其输出到与输入相同格式的文件中。
- en: Once we have this second CSV file, another Kivy program can load the file and
    render each color, asking a human user to confirm or deny the accuracy of the
    prediction, thus informing us of how accurate our algorithm and initial data set
    are.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦有了这个第二个CSV文件，另一个Kivy程序可以加载文件并渲染每种颜色，要求人类用户确认或否认预测的准确性，从而告诉我们我们的算法和初始数据集的准确性如何。
- en: 'The first step is a fairly simple generator that loads CSV data and converts
    it into a format that is amenable to our needs:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是一个相当简单的生成器，它加载CSV数据并将其转换为符合我们需求的格式：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We haven't seen the `csv.reader` function before. It returns an iterator over
    the lines in the file. Each value returned by the iterator is a list of strings.
    In our case, we could have just split on commas and been fine, but `csv.reader`
    also takes care of managing quotation marks and various other nuances of the comma-separated
    value format.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以前没有见过`csv.reader`函数。它返回文件中行的迭代器。迭代器返回的每个值都是一个字符串列表。在我们的情况下，我们可以只是按逗号分割就可以了，但`csv.reader`还负责处理引号和逗号分隔值格式的各种其他细微差别。
- en: We then loop over these lines and convert them to a tuple of color and name,
    where the color is a tuple of three floating value integers. This tuple is constructed
    using a generator expression. There might be more readable ways to construct this
    tuple; do you think the code brevity and the speed of a generator expression is
    worth the obfuscation? Instead of returning a list of color tuples, it yields
    them one at a time, thus constructing a generator object.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们循环遍历这些行，并将它们转换为颜色和名称的元组，其中颜色是由三个浮点值整数组成的元组。这个元组是使用生成器表达式构造的。可能有更易读的方法来构造这个元组；你认为生成器表达式的代码简洁和速度是否值得混淆？它不是返回一个颜色元组的列表，而是逐个产生它们，从而构造一个生成器对象。
- en: 'Now, we need a hundred random colors. There are so many ways this can be done:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一百种随机颜色。有很多方法可以做到这一点：
- en: 'A list comprehension with a nested generator expression: `[tuple(random() for
    r in range(3)) for r in range(100)]`'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用嵌套生成器表达式的列表推导：`[tuple(random() for r in range(3)) for r in range(100)]`
- en: A basic generator function
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个基本的生成器函数
- en: A class that implements the `__iter__` and `__next__` protocols
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个实现`__iter__`和`__next__`协议的类
- en: Push the data through a pipeline of coroutines
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据通过一系列协程
- en: Even just a basic `for` loop
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 甚至只是一个基本的`for`循环
- en: 'The generator version seems to be most readable, so let''s add that function
    to our program:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器版本似乎是最易读的，所以让我们将该函数添加到我们的程序中：
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice how we parameterize the number of colors to generate. We can now reuse
    this function for other color-generating tasks in the future.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们对要生成的颜色数量进行了参数化。现在我们可以在将来的其他生成颜色任务中重用这个函数。
- en: 'Now, before we do the classification step, we need a function to calculate
    the "distance" between two colors. Since it''s possible to think of colors as
    being three dimensional (red, green, and blue could map to *x*, *y*, and *z* axes,
    for example), let''s use a little basic math:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在进行分类步骤之前，我们需要一个函数来计算两种颜色之间的“距离”。由于可以将颜色看作是三维的（例如，红色、绿色和蓝色可以映射到*x*、*y*和*z*轴），让我们使用一些基本的数学：
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This is a pretty basic-looking function; it doesn't look like it's even using
    the iterator protocol. There's no `yield` function, no comprehensions. However,
    there is a `for` loop, and that call to the `zip` function is doing some real
    iteration as well (remember that `zip` yields tuples containing one element from
    each input iterator).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个看起来非常基本的函数；它似乎甚至没有使用迭代器协议。没有`yield`函数，也没有推导。然而，有一个`for`循环，而且`zip`函数的调用也在进行一些真正的迭代（记住`zip`会产生包含每个输入迭代器中一个元素的元组）。
- en: 'Note, however, that this function is going to be called a lot of times inside
    our k-nearest neighbors algorithm. If our code ran too slow and we were able to
    identify this function as a bottleneck, we might want to replace it with a less
    readable, but more optimized, generator expression:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要注意的是，这个函数将在我们的k最近邻算法中被调用很多次。如果我们的代码运行得太慢，并且我们能够确定这个函数是瓶颈，我们可能希望用一个不太易读但更优化的生成器表达式来替换它：
- en: '[PRE31]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: However, I strongly recommend not making such optimizations until you have proven
    that the readable version is too slow.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我强烈建议在证明可读版本太慢之前不要进行这样的优化。
- en: 'Now that we have some plumbing in place, let''s do the actual k-nearest neighbor
    implementation. This seems like a good place to use a coroutine. Here it is with
    some test code to ensure it''s yielding sensible values:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一些管道，让我们来实际做k最近邻实现。这似乎是使用协程的好地方。下面是一些测试代码，以确保它产生合理的值：
- en: '[PRE32]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The coroutine accepts two arguments, the list of colors to be used as a model,
    and the number of neighbors to query. It converts the model to a list because
    it's going to be iterated over multiple times. In the body of the coroutine, it
    accepts a tuple of RGB color values using the `yield` syntax. Then it combines
    a call to `sorted` with an odd generator expression. See if you can figure out
    what that generator expression is doing.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 该协程接受两个参数，要用作模型的颜色列表和要查询的邻居数。它将模型转换为列表，因为它将被多次迭代。在协程的主体中，它使用`yield`语法接受一个RGB颜色值的元组。然后它将`sorted`调用与一个奇怪的生成器表达式结合在一起。看看你是否能弄清楚那个生成器表达式在做什么。
- en: 'It returns a tuple of `(distance, color_data)` for each color in the model.
    Remember, the model itself contains tuples of `(color, name)`, where `color` is
    a tuple of three RGB values. Therefore, the generator is returning an iterator
    over a weird data structure that looks like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 它为模型中的每种颜色返回一个`(distance, color_data)`元组。请记住，模型本身包含`(color, name)`的元组，其中`color`是三个RGB值的元组。因此，该生成器返回一个奇怪数据结构的迭代器，看起来像这样：
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `sorted` call then sorts the results by their first element, which is distance.
    This is a complicated piece of code and isn't object-oriented at all. You may
    want to break it down into a normal `for` loop to ensure you understand what the
    generator expression is doing. It might also be a good exercise to imagine how
    this code would look if you were to pass a key argument into the sorted function
    instead of constructing a tuple.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`sorted`调用按照它们的第一个元素（距离）对结果进行排序。这是一段复杂的代码，根本不是面向对象的。您可能希望将其分解为一个普通的`for`循环，以确保您理解生成器表达式的工作原理。如果您将一个键参数传递给`sorted`函数而不是构造一个元组，想象一下这段代码会是什么样子也是一个很好的练习。
- en: The `yield` statement is a bit less complicated; it pulls the second value from
    each of the first k `(distance, color_data)` tuples. In more concrete terms, it
    yields the `((r, g, b), color_name)` tuple for the k values with the lowest distance.
    Or, if you prefer more abstract terms, it yields the target's k-nearest neighbors
    in the given model.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield`语句稍微复杂一些；它从前k个`(distance, color_data)`元组中提取第二个值。更具体地说，它为距离最近的k个值产生了`((r,
    g, b), color_name)`元组。或者，如果您更喜欢更抽象的术语，它为给定模型中目标的k个最近邻产生了值。'
- en: The remaining code is just boilerplate to test this method; it constructs the
    model and a color generator, primes the coroutine, and prints the results in a
    `for` loop.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的代码只是测试这种方法的样板；它构造了模型和颜色生成器，启动了协程，并在`for`循环中打印结果。
- en: 'The two remaining tasks are to choose a color based on the nearest neighbors,
    and to output the results to a CSV file. Let''s make two more coroutines to take
    care of these tasks. Let''s do the output first because it can be tested independently:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的两个任务是根据最近邻选择颜色，并将结果输出到CSV文件。让我们创建两个协程来处理这些任务。我们先做输出，因为它可以独立测试：
- en: '[PRE34]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This coroutine maintains an open file as state and writes lines of code to it
    as they are sent in using `send()`. The test code ensures the coroutine is working
    correctly, so now we can connect the two coroutines with a third one.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 该协程将一个打开的文件作为状态，并在使用`send()`发送的情况下将代码行写入其中。测试代码确保协程正常工作，所以现在我们可以用第三个协程连接这两个协程了。
- en: 'The second coroutine uses a bit of an odd trick:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个协程使用了一个有点奇怪的技巧：
- en: '[PRE35]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This coroutine accepts, *as its argument*, an existing coroutine. In this case,
    it's an instance of `nearest_neighbors`. This code basically proxies all the values
    sent into it through that `nearest_neighbors` instance. Then it does some processing
    on the result to get the most common color out of the values that were returned.
    In this case, it would probably make just as much sense to adapt the original
    coroutine to return a name, since it isn't being used for anything else. However,
    there are many cases where it is useful to pass coroutines around; this is how
    we do it.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这个协程接受一个现有的协程作为参数。在这种情况下，它是`nearest_neighbors`的一个实例。这段代码基本上通过`nearest_neighbors`实例代理所有发送到它的值。然后它对结果进行一些处理，以获取返回的值中最常见的颜色。在这种情况下，也许将原始协程调整为返回一个名称会更有意义，因为它没有被用于其他任何事情。然而，有许多情况下传递协程是有用的；这就是我们的做法。
- en: 'Now all we have to do is connect these various coroutines and pipelines together,
    and kick off the process with a single function call:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们所要做的就是将这些不同的协程和管道连接在一起，并通过一个单一的函数调用启动整个过程：
- en: '[PRE36]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: So, this function, unlike almost every other function we've defined, is a perfectly
    normal function without any `yield` statements. It doesn't get turned into a coroutine
    or generator object. It does, however, construct a generator and three coroutines.
    Notice how the `get_neighbors` coroutine is passed into the constructor for `name_colors`?
    Pay attention to how all three coroutines are advanced to their first `yield`
    statements by calls to `next`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，与我们定义的几乎所有其他函数不同，这个函数是一个完全正常的函数，没有任何`yield`语句。它不会被转换为协程或生成器对象。但是，它确实构造了一个生成器和三个协程。请注意，`get_neighbors`协程是如何传递给`name_colors`构造函数的。注意所有三个协程是如何通过调用`next`推进到它们的第一个`yield`语句的。
- en: Once all the pipes are created, we use a `for` loop to send each of the generated
    colors into the `get_color_name` coroutine, and then we pipe each of the values
    yielded by that coroutine to the output coroutine, which writes it to a file.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有管道都创建好了，我们就使用`for`循环将生成的每种颜色发送到`get_color_name`协程中，然后将该协程产生的每个值传送到输出协程，将其写入文件。
- en: And that's it! I created a second Kivy app that loads the resulting CSV file
    and presents the colors to the user. The user can select either *Yes* or *No*
    depending on whether they think the choice made by the machine-learning algorithm
    matches the choice they would have made. This is not scientifically accurate (it's
    ripe for observation bias), but it's good enough for playing around. Using my
    eyes, it succeeded about 84 percent of the time, which is better than my grade
    12 average. Not bad for our first ever machine learning experience, eh?
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我创建了第二个Kivy应用程序，加载了生成的CSV文件，并将颜色呈现给用户。用户可以根据他们认为机器学习算法的选择是否与他们的选择相匹配来选择*是*或*否*。这并不科学准确（容易出现观察偏差），但对于玩耍来说已经足够了。用我的眼睛看，它成功率约为84%，比我12年级的平均成绩要好。对于我们第一次的机器学习经历来说，这已经不错了，对吧？
- en: You might be wondering, "what does this have to do with object-oriented programming?
    There isn't even one class in this code!". In some ways, you'd be right; neither
    coroutines nor generators are commonly considered object-oriented. However, the
    functions that create them return objects; in fact, you could think of those functions
    as constructors. The constructed object has appropriate `send()` and `__next__()`
    methods. Basically, the coroutine/generator syntax is a syntax shortcut for a
    particular kind of object that would be quite verbose to create without it.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，“这与面向对象编程有什么关系？这段代码中甚至没有一个类！”在某些方面，你是对的；协程和生成器通常不被认为是面向对象的。然而，创建它们的函数会返回对象；实际上，你可以将这些函数看作构造函数。构造的对象具有适当的`send()`和`__next__()`方法。基本上，协程/生成器语法是一种特定类型的对象的语法快捷方式，如果没有它，创建这种对象会非常冗长。
- en: This case study has been an exercise in bottom-up design. We created various
    low-level objects that did specific tasks and hooked them all together at the
    end. I find this to be a common practice when developing with coroutines. The
    alternative, top-down design sometimes results in more monolithic pieces of code
    instead of unique individual pieces. In general, we want to find a happy medium
    between methods that are too large and methods that are too small and it's hard
    to see how they fit together. This is true, of course, regardless of whether the
    iterator protocol is being used as we did here.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这个案例研究是一个自下而上设计的练习。我们创建了各种低级对象，执行特定的任务，并在最后将它们全部连接在一起。我发现这在开发协程时是一个常见的做法。另一种选择，自上而下的设计有时会导致更多的代码块而不是独特的个体。总的来说，我们希望在太大和太小的方法之间找到一个合适的平衡，以及它们如何组合在一起。当然，这是真的，无论是否像我们在这里做的那样使用迭代器协议。
- en: Exercises
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: If you don't use comprehensions in your daily coding very often, the first thing
    you should do is search through some existing code and find some `for` loops.
    See if any of them can be trivially converted to a generator expression or a list,
    set, or dictionary comprehension.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在日常编码中很少使用推导，那么你应该做的第一件事是搜索一些现有的代码，找到一些`for`循环。看看它们中是否有任何可以轻松转换为生成器表达式或列表、集合或字典推导的。
- en: Test the claim that list comprehensions are faster than `for` loops. This can
    be done with the built-in `timeit` module. Use the help documentation for the
    `timeit.timeit` function to find out how to use it. Basically, write two functions
    that do the same thing, one using a list comprehension, and one using a `for`
    loop. Pass each function into `timeit.timeit`, and compare the results. If you're
    feeling adventurous, compare generators and generator expressions as well. Testing
    code using `timeit` can become addictive, so bear in mind that code does not need
    to be hyperfast unless it's being executed an immense number of times, such as
    on a huge input list or file.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 测试列表推导是否比`for`循环更快的说法。这可以通过内置的`timeit`模块来实现。使用`timeit.timeit`函数的帮助文档来了解如何使用它。基本上，编写两个做同样事情的函数，一个使用列表推导，一个使用`for`循环。将每个函数传递给`timeit.timeit`，并比较结果。如果你感到有冒险精神，也可以比较生成器和生成器表达式。使用`timeit`测试代码可能会让人上瘾，所以请记住，除非代码被执行了大量次数，比如在一个巨大的输入列表或文件上，否则代码不需要非常快。
- en: Play around with generator functions. Start with basic iterators that require
    multiple values (mathematical sequences are canonical examples; the Fibonacci
    sequence is overused if you can't think of anything better). Try some more advanced
    generators that do things like take multiple input lists and somehow yield values
    that merge them. Generators can also be used on files; can you write a simple
    generator that shows those lines that are identical in two files?
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 玩转生成器函数。从需要多个值的基本迭代器开始（数学序列是典型的例子；如果你想不出更好的例子，斐波那契数列就太过于使用了）。尝试一些更高级的生成器，比如接受多个输入列表并以某种方式产生合并值的生成器。生成器也可以用在文件上；你能写一个简单的生成器来显示两个文件中相同的行吗？
- en: Coroutines abuse the iterator protocol but don't actually fulfill the iterator
    pattern. Can you build a non-coroutine version of the code that gets a serial
    number from a log file? Take an object-oriented approach so that you can store
    an additional state on a class. You'll learn a lot about coroutines if you can
    create an object that is a drop-in replacement for the existing coroutine.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 协程滥用迭代器协议，但实际上并不满足迭代器模式。你能否构建一个从日志文件中获取序列号的非协程版本的代码？采用面向对象的方法，这样你就可以在一个类上存储额外的状态。如果你能创建一个可以替换现有协程的对象，你将学到很多关于协程的知识。
- en: See if you can abstract the coroutines used in the case study so that the k-nearest-neighbor
    algorithm can be used on a variety of datasets. You'll likely want to construct
    a coroutine that accepts other coroutines or functions that do the distance and
    recombination calculations as parameters, and then calls into those functions
    to find the actual nearest neighbors.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否能将案例研究中使用的协程抽象出来，以便可以在各种数据集上使用k最近邻算法。你可能希望构建一个接受其他协程或执行距离和重组计算的函数作为参数的协程，并调用这些函数来找到实际的最近邻。
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned that design patterns are useful abstractions that
    provide "best practice" solutions for common programming problems. We covered
    our first design pattern, the iterator, as well as numerous ways that Python uses
    and abuses this pattern for its own nefarious purposes. The original iterator
    pattern is extremely object-oriented, but it is also rather ugly and verbose to
    code around. However, Python's built-in syntax abstracts the ugliness away, leaving
    us with a clean interface to these object-oriented constructs.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到设计模式是有用的抽象，为常见的编程问题提供了“最佳实践”解决方案。我们介绍了我们的第一个设计模式，迭代器，以及Python使用和滥用这种模式的多种方式。原始的迭代器模式非常面向对象，但在代码编写时也相当丑陋和冗长。然而，Python的内置语法将丑陋的部分抽象出来，为我们留下了一个清晰的接口来使用这些面向对象的构造。
- en: Comprehensions and generator expressions can combine container construction
    with iteration in a single line. Generator objects can be constructed using the
    `yield` syntax. Coroutines look like generators on the outside but serve a much
    different purpose.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 理解和生成器表达式可以在一行中将容器构造与迭代结合起来。生成器对象可以使用`yield`语法来构造。协程看起来像生成器，但用途完全不同。
- en: We'll cover several more design patterns in the next two chapters.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两章中，我们将介绍更多的设计模式。
