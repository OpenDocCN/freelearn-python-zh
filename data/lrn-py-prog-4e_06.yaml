- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: OOP, Decorators, and Iterators
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OOP、装饰器和迭代器
- en: ”La classe non è acqua.” (“Class will out.”)
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “La classe non è acqua.”（“类胜于水。”）
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Italian saying
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ——意大利谚语
- en: '**Object-oriented programming (OOP)** is such a vast topic that entire books
    have been written about it. In this chapter, we face the challenge of finding
    the balance between breadth and depth. There are simply too many things to discuss,
    and plenty of them would take more than this whole chapter if we described them
    in depth. Therefore, we will try to give you what we think is a good panoramic
    view of the fundamentals, plus a few things that may come in handy in the next
    chapters. Python’s official documentation will help to fill the gaps.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象编程（OOP**）是一个如此广泛的话题，以至于关于它的整本书都已经被写出来了。在本章中，我们面临着在广度和深度之间找到平衡的挑战。要讨论的事情实在太多了，如果深入描述，其中许多内容将需要超过整个章节的篇幅。因此，我们将尝试为您提供我们认为的良好全景式的基本概念，以及一些可能在下一章中派上用场的知识点。Python的官方文档将帮助填补这些空白。'
- en: 'In this chapter, we are going to cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Decorators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器
- en: OOP with Python
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python进行OOP
- en: Iterators
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器
- en: Decorators
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器
- en: In *Chapter 5* , *Comprehensions and Generators* , we measured the execution
    time of various expressions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第5章*，*理解与生成器*中，我们测量了各种表达式的执行时间。
- en: If you recall, we had to capture the start time and subtract it from the current
    time after execution to calculate the elapsed time. We also printed it on the
    console after each measurement. That was impractical.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得，我们不得不捕获开始时间，并在执行后从当前时间中减去它来计算经过的时间。我们还必须在每次测量后在控制台上打印它。这很不实用。
- en: 'Every time we find ourselves repeating things, an alarm bell should go off.
    Can we put that code in a function and avoid repetition? Most of the time, the
    answer is, *yes* , so let us look at an example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们发现自己重复某些事情时，应该响起一个警钟。我们能否将那段代码放入函数中，避免重复？大多数时候，答案是*是的*，所以让我们看看一个例子：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding code, we defined two functions, `f()` and `g()` , which do
    nothing but sleep (for 0.3 and 0.5 seconds, respectively). We used the `sleep()`
    function to suspend the execution for the desired amount of time. Notice how the
    time measure is pretty accurate. Now, how do we avoid repeating that code and
    those calculations? One first potential approach could be the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了两个函数，`f()`和`g()`，它们什么也不做，只是休眠（分别休眠0.3秒和0.5秒）。我们使用`sleep()`函数来暂停执行所需的时间。注意时间测量的准确性。现在，我们如何避免重复那段代码和那些计算呢？一个潜在的第一种方法可能是以下这样：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Much better. The whole timing mechanism has been encapsulated in a function,
    so we do not repeat code. We print the function name dynamically and the code
    is straightforward. What if we needed to pass any arguments to the function we
    measure? This code would get just a bit more complex. Let us see an example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 好多了。整个计时机制都被封装在一个函数中，所以我们不需要重复代码。我们动态地打印函数名，代码也很直接。如果我们需要将任何参数传递给我们要测量的函数呢？这段代码将变得稍微复杂一些。让我们看看一个例子：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, `f()` expects to be fed `sleep_time` (with a default value of 0.1), so
    we do not need `g()` anymore. We also had to change the `measure()` function so
    that it now accepts a function, any variable positional arguments, and any variable
    keyword arguments. This way, whatever we call `measure()` with, we redirect those
    arguments to the call to `func()` that we do inside.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`f()`期望传入`sleep_time`（默认值为0.1），因此我们不再需要`g()`。我们还不得不修改`measure()`函数，使其现在可以接受一个函数、任何可变位置参数和任何可变关键字参数。这样，无论我们用什么调用`measure()`，我们都会将这些参数重定向到我们内部调用的`func()`。
- en: 'This is good, but we can improve it a little. Let us say that we somehow want
    to have that timing behavior built into the `f()` function, enabling us to just
    call it and have that measure taken. Here is how we could do it:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但我们还可以稍作改进。假设我们想要以某种方式将那种计时行为内置到`f()`函数中，使我们只需调用它就能进行测量。下面是我们可以这样做的示例：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code is not so straightforward. Let us see what happens here.
    The magic is in the *decoration point* . We reassign `f()` with whatever is returned
    by `measure()` when we call it with `f()` as an argument. Within `measure()` ,
    we define another function, `wrapper()` , and then we return it. So the net effect
    is that after the decoration point, when we call `f()` , we are actually calling
    `wrapper()` (you can witness this in the last line of code). Since the `wrapper()`
    inside calls `func()` , which in this case is a reference to `f()` , we close
    the loop.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码并不那么简单明了。让我们看看这里发生了什么。魔法在于*装饰点*。当我们用`f()`作为参数调用`measure()`时，我们将`f()`重新赋值为`measure()`返回的任何内容。在`measure()`内部，我们定义了另一个函数`wrapper()`，然后返回它。因此，最终的效果是，在装饰点之后，当我们调用`f()`时，实际上是在调用`wrapper()`（你可以在代码的最后一行看到这一点）。由于`wrapper()`内部调用的是`func()`，在这个例子中是`f()`的引用，所以我们闭合了循环。
- en: The `wrapper()` function is, not surprisingly, a wrapper. It takes variable
    positional and keyword arguments and calls `f()` with them. It also does the time
    measurement calculation around the call.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`wrapper()`函数，不出所料，是一个包装器。它接受可变的位置参数和关键字参数，并使用这些参数调用`f()`。它还在调用周围进行时间测量计算。'
- en: This technique is called **decoration** , and `measure()` is, effectively, a
    **decorator** . This paradigm became so popular and widely used that, in version
    2.4, Python added a special syntax for it. You can read the specifics in PEP 318
    ( [https://peps.python.org/pep-0318/](https://peps.python.org/pep-0318/) ). In
    Python 3.0, we saw PEP 3129 ( [https://peps.python.org/pep-3129/](https://peps.python.org/pep-3129/)
    ) defining class decorators. Finally, in Python 3.9, the decorator syntax was
    slightly amended to relax some grammar restrictions; this change was brought about
    in PEP 614 ( [https://peps.python.org/pep-0614/](https://peps.python.org/pep-0614/)
    ).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术被称为**装饰**，而`measure()`实际上是一个**装饰器**。这种范式变得如此流行和广泛使用，以至于在Python 2.4版本中，Python为其添加了特殊的语法。你可以在PEP
    318（[https://peps.python.org/pep-0318/](https://peps.python.org/pep-0318/)）中阅读具体细节。在Python
    3.0中，我们看到了PEP 3129（[https://peps.python.org/pep-3129/](https://peps.python.org/pep-3129/)），它定义了类装饰器。最后，在Python
    3.9中，装饰器语法略有修改，以放宽一些语法限制；这一变化是在PEP 614（[https://peps.python.org/pep-0614/](https://peps.python.org/pep-0614/)）中实现的。
- en: 'Let us now explore three cases: one decorator, two decorators, and one decorator
    that takes arguments. First, the single decorator case:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探讨三种情况：一个装饰器、两个装饰器和接受参数的一个装饰器。首先，单个装饰器的情况：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Instead of manually reassigning the function to what was returned by the decorator,
    we prepend the definition of the function with the special syntax, `@decorator_name`
    .
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是手动将函数重新赋值为装饰器返回的内容，而是在函数定义前加上特殊的语法`@decorator_name`。
- en: 'We can apply multiple decorators to the same function in the following way:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式将多个装饰器应用于同一个函数：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When applying multiple decorators, it is important to pay attention to the order.
    In the preceding example, `func()` is decorated with `deco2()` first, and the
    result is decorated with `deco1()` . A good rule of thumb is *the closer the decorator
    is to the function, the sooner it is applied* .
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用多个装饰器时，注意顺序很重要。在先前的例子中，`func()`首先被`deco2()`装饰，然后结果被`deco1()`装饰。一个很好的经验法则是*装饰器离函数越近，应用得越早*。
- en: 'Before we give you another example, let us fix the issue with the function
    name. Take a look at the highlighted section in the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们给你另一个例子之前，让我们先解决函数名的问题。看看下面代码中高亮的部分：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We don’t want to lose the original function’s name and docstring when we decorate
    it. But because `f` , the decorated function, is reassigned to `wrapper` , its
    original attributes are lost, replaced with those of `wrapper()` . There is an
    easy fix for that from the `functools` module. We will fix the issue and rewrite
    the code to use the `@` operator:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望在装饰函数时丢失原始函数的名称和文档字符串。但是，因为被装饰的函数`f`被重新赋值为`wrapper`，它的原始属性丢失了，被`wrapper()`的属性所取代。`functools`模块中有一个简单的解决方案。我们将修复这个问题，并重写代码以使用`@`操作符：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: All looks good. As you can see, all we need to do is to tell Python that `wrapper`
    actually wraps `func()` (by means of the `wraps()` function in the highlighted
    portion of the code above), and you can see that the original name and docstring
    are maintained.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一切看起来都很正常。正如你所看到的，我们只需要告诉Python`wrapper`实际上包装了`func()`（通过上面代码高亮部分的`wraps()`函数），你可以看到原始的名称和文档字符串都得到了保留。
- en: 'For the full list of function attributes that are reassigned by `func()` ,
    please check the official documentation for the `functools.update_wrapper()` function
    here: [https://docs.python.org/3/library/functools.html?#functools.update_wrapper](https://docs.python.org/3/library/functools.html?#functools.update_wrapper)
    .'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`func()`重新分配的函数属性的全列表，请查看`functools.update_wrapper()`函数的官方文档，链接如下：[https://docs.python.org/3/library/functools.html?#functools.update_wrapper](https://docs.python.org/3/library/functools.html?#functools.update_wrapper)。
- en: 'Let us see another example. We want a decorator that prints an error message
    when the result of a function is greater than a certain threshold. We will also
    take this opportunity to show you how to apply two decorators at once:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看另一个例子。我们想要一个装饰器，当函数的结果大于某个特定阈值时，它会打印出一个错误信息。我们也将借此机会向你展示如何同时应用两个装饰器：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We had to enhance the `measure()` decorator so that its `wrapper()` now returns
    the result of the call to `func()` . The `max_result()` decorator does that as
    well, but before returning, it checks that `result` is not greater than `100`
    , which is the maximum allowed.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须增强`measure()`装饰器，使其`wrapper()`现在返回对`func()`的调用结果。`max_result()`装饰器也这样做，但在返回之前，它会检查`result`是否不大于允许的最大值`100`。
- en: 'We decorated `cube()` with both of them. First, `max_result()` is applied,
    and then `measure()` . Running this code yields this result:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用这两个装饰器都装饰了`cube()`。首先应用`max_result()`，然后是`measure()`。运行这段代码得到以下结果：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For your convenience, we have separated the results of the two calls with a
    blank line. In the first call, the result is 8, which passes the threshold check.
    The running time is measured and printed. Finally, we print the result ( `8` ).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我们用空行分隔了两次调用的结果。在第一次调用中，结果是8，通过了阈值检查。测量并打印出运行时间。最后，我们打印出结果（`8`）。
- en: On the second call, the result is 125, so the error message is printed and the
    result returned; then it is the turn of `measure()` , which prints the running
    time again, and finally, we print the result ( `125` ).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次调用时，结果是125，因此打印出错误信息并返回结果；然后轮到`measure()`，它再次打印运行时间，最后我们打印出结果（`125`）。
- en: Had we decorated the `cube()` function with the same two decorators but in a
    different order, the order of the printed messages would also have been different.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用相同的两个装饰器但以不同的顺序装饰`cube()`函数，打印出的消息顺序也会不同。
- en: A decorator factory
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器工厂
- en: 'Some decorators can take arguments. This technique is generally used to produce
    another decorator (in which case, the object could be called a **decorator factory**
    ). Let us look at the syntax, and then we will see an example of it:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一些装饰器可以接受参数。这种技术通常用于生成另一个装饰器（在这种情况下，该对象可以被称为**装饰器工厂**）。让我们看看其语法，然后我们将看到一个例子：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, this case is a bit different. First, `decoarg()` is called with
    the given arguments, and then its return value (the actual decorator) is called
    with `func()` .
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个情况有点不同。首先，`decoarg()`用给定的参数被调用，然后它的返回值（实际的装饰器）用`func()`被调用。
- en: 'Let us improve on the example now. We are going back to a single decorator:
    `max_result()` . We want to make it so that we can decorate different functions
    with different thresholds, as we do not want to have to write one decorator for
    each threshold. Therefore, let us amend `max_result()` so that it allows us to
    decorate functions by specifying the threshold dynamically:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在改进一下例子。我们将回到一个单独的装饰器：`max_result()`。我们希望让它能够用不同的阈值装饰不同的函数，因为我们不希望为每个阈值都写一个装饰器。因此，让我们修改`max_result()`，使其能够通过动态指定阈值来装饰函数：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code shows you how to write a decorator factory. If you recall,
    decorating a function with a decorator that takes arguments is the same as writing
    `func = decorator(argA, argB)(func)` , so when we decorate `cube()` with `max_result(75)`
    , we are doing `cube = max_result(75)(cube)` .
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码展示了如何编写一个装饰器工厂。如果你还记得，使用带参数的装饰器装饰一个函数与编写`func = decorator(argA, argB)(func)`是相同的，所以当我们用`max_result(75)`装饰`cube()`时，我们实际上是在做`cube
    = max_result(75)(cube)`。
- en: Let us go through what happens, step by step. When we call `max_result(75)`
    , we enter its body. A `decorator()` function is defined inside the `max_result(75)`
    function, which takes a function as its only argument. Inside that function, we
    find the usual decoration pattern. We define `wrapper()` , inside of which we
    check the result of the original function’s call. The beauty of this approach
    is that from the innermost level, we can still refer to both `func()` and `threshold`
    , which allows us to set the threshold dynamically.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地看看发生了什么。当我们调用`max_result(75)`时，我们进入其主体。在`max_result(75)`函数内部定义了一个`decorator()`函数，它只接受一个函数作为其唯一参数。在该函数内部，我们找到了常见的装饰模式。我们定义了`wrapper()`，在其中我们检查原始函数调用的结果。这种方法的优点是从最内层开始，我们仍然可以引用`func()`和`threshold`，这使我们能够动态地设置阈值。
- en: The `wrapper()` function returns `result` , `decorator()` returns `wrapper()`
    , and `max_result()` returns `decorator()` . This means that the `cube = max_result(75)(cube)`
    instruction actually becomes `cube = decorator(cube)` . However, it’s not just
    any `decorator()` but one for which `threshold` has a value of `75` . This is
    achieved by a mechanism called **closure** .
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`wrapper()`函数返回`result`，`decorator()`返回`wrapper()`，`max_result()`返回`decorator()`。这意味着`cube
    = max_result(75)(cube)`指令实际上变成了`cube = decorator(cube)`。然而，这不仅仅是一个`decorator()`，而是一个`threshold`值为`75`的`decorator()`。这是通过称为**闭包**的机制实现的。'
- en: Dynamically created functions that are returned by other functions are called
    **closures** . Their main feature is that they have full access to the variables
    and names defined in the local namespace at the time of their creation, even though
    the enclosing in which they were defined has returned and finished executing.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由其他函数返回并动态创建的函数被称为**闭包**。它们的主要特征是，它们在创建时可以完全访问局部命名空间中定义的变量和名称，即使定义它们的封装已经返回并完成执行。
- en: 'Running the last example produces the following result:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 运行最后一个示例会产生以下结果：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code allows us to use the `max_result()` decorator with different
    thresholds, like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码允许我们使用具有不同阈值的`max_result()`装饰器，如下所示：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that every decoration uses a different `threshold` value.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个装饰器都使用不同的`threshold`值。
- en: Decorators are very popular in Python. They are used quite often, and they make
    code simpler and more elegant.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器在Python中非常流行。它们被频繁使用，并且使代码更加简洁和优雅。
- en: OOP
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OOP
- en: 'Now that the basics of the decoration pattern have been covered, it is time
    to explore OOP. We will use the definition from *Kindler, E.; Krivy, I. (2011).
    Object-oriented simulation of systems with sophisticated control (International
    Journal of General Systems)* , and adapt it to Python:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了装饰模式的基础，是时候探索面向对象编程了。我们将使用来自*Kindler, E.; Krivy, I. (2011). Object-oriented
    simulation of systems with sophisticated control (International Journal of General
    Systems)*的定义，并将其应用于Python：
- en: '**Object-oriented programming** ( **OOP** ) is a programming paradigm based
    on the concept of “objects,” which are data structures that contain data, in the
    form of attributes, and code, in the form of functions known as methods. A distinguishing
    feature of objects is that an object’s method can access and often modify the
    data attributes of the object with which they are associated (objects have a notion
    of “self”). In OO programming, computer programs are designed by making them out
    of objects that interact with one another.'
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**面向对象编程**（**OOP**）是一种基于“对象”概念的编程范式，其中对象是包含数据的数据结构，以属性的形式存在，以及以方法的形式存在的代码。对象的一个显著特点是，对象的方法可以访问并经常修改与之关联的对象的数据属性（对象具有“自我”的概念）。在面向对象编程中，计算机程序是通过构建相互交互的对象来设计的。'
- en: Python has full support for this paradigm. Actually, as we have already said,
    *everything in Python is an object* , so this shows that OOP is not just supported
    by Python but is also a core feature of the language.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Python完全支持这种范式。实际上，正如我们之前所说的，*Python中的一切都是对象*，这表明面向对象编程（OOP）不仅被Python支持，而且是该语言的核心特性。
- en: The two main players in OOP are **objects** and **classes** . Classes are used
    to create objects, and we say that objects are **instances** of classes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程中的两个主要角色是**对象**和**类**。类用于创建对象，我们说对象是类的**实例**。
- en: 'If you struggle to understand the difference between objects and classes, think
    of it like this. When you hear the word “pen,” you know exactly what the type
    (or class) of object that the word represents is. However, if we say “this pen,”
    then we’re not referring to a class of objects but, rather, to an “instance” of
    that class: a real object.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你难以理解对象和类之间的区别，可以这样想。当你听到“笔”这个词时，你知道这个词所代表的对象类型（或类）是什么。然而，如果我们说“这支笔”，那么我们不是指一个对象类，而是指那个类的“实例”：一个真实对象。
- en: When objects are created from a class, they inherit the class attributes and
    methods. They represent concrete items in the program’s domain.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当从类创建对象时，它们继承了类属性和方法。它们代表程序域中的具体项目。
- en: The simplest Python class
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最简单的 Python 类
- en: 'We will start with the simplest class you could ever write in Python:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从你可以在 Python 中编写的最简单的类开始：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let us run the preceding code and explain it line by line:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行前面的代码并逐行解释：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `Simplest` class we defined has only the `pass` instruction in its body,
    which means it doesn’t have any custom attributes or methods. We will print its
    type ( `__main__` is the name of the scope in which top-level code executes),
    and we are aware that, in the highlighted comment, we wrote *object* instead of
    *class* . As you can see by the result of that `print` statement, *classes are
    in fact objects themselves* . To be precise, they are instances of `type` . Explaining
    this concept would lead us to a talk about **metaclasses** and **metaprogramming**
    , advanced concepts that require a solid grasp of the fundamentals to be understood
    and are beyond the scope of this chapter. As usual, we mentioned it to leave a
    pointer for you, for when you are ready to explore more deeply.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的 `Simplest` 类在其主体中只有 `pass` 指令，这意味着它没有自定义属性或方法。我们将打印其类型（`__main__` 是顶层代码执行的命名空间名称），并且我们知道，在突出显示的注释中，我们写了
    *object* 而不是 *class* 。正如你通过那个 `print` 语句的结果所看到的，*类实际上也是对象本身*。为了更精确，它们是 `type`
    的实例。解释这个概念会引导我们进入关于 **元类** 和 **元编程** 的讨论，这些是高级概念，需要牢固掌握基础知识才能理解，并且超出了本章的范围。像往常一样，我们提到它是为了给你留下一个线索，以便当你准备好更深入地探索时。
- en: 'Let us go back to the example: we created `simp` , an instance of the `Simplest`
    class. You can see that the syntax to create an instance is the same as the syntax
    for calling a function. Next, we print what type `simp` belongs to, and we verify
    that `simp` is, in fact, an instance of `Simplest` . We will show you a better
    way of doing this later on in the chapter.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到例子：我们创建了 `simp` ，它是 `Simplest` 类的一个实例。你可以看到创建实例的语法与调用函数的语法相同。接下来，我们打印 `simp`
    属于的类型，并验证 `simp` 确实是 `Simplest` 的一个实例。我们将在本章后面部分展示更好的方法来做这件事。
- en: 'So far, it has all been very simple. However, what happens when we write `class
    ClassName(): pass` ? Well, what Python does is to create a class object and assign
    it a name. This is very similar to what happens when we declare a function using
    `def` .'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '到目前为止，一切都很简单。然而，当我们编写 `class ClassName(): pass` 时会发生什么呢？嗯，Python 做的是创建一个类对象并给它一个名称。这和声明函数时使用
    `def` 的行为非常相似。'
- en: Class and object namespaces
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类和对象命名空间
- en: After a class object has been created (which usually happens when the module
    is first imported), it represents a namespace. We can call that class to create
    its instances. Each instance inherits the class attributes and methods and is
    given its own namespace. We already know that in order to walk a namespace, all
    we need to do is to use the dot ( `.` ) operator.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建类对象之后（这通常发生在模块首次导入时），它代表一个命名空间。我们可以调用该类来创建其实例。每个实例都继承类属性和方法，并拥有自己的命名空间。我们已经知道，为了遍历命名空间，我们只需要使用点（`.`）操作符。
- en: 'Let us look at another example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个例子：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding example, we defined a **class attribute** called `species`
    . Any name defined in the body of a class becomes an attribute that belongs to
    that class. In the code, we also defined `Person.alive` , which is another class
    attribute. You can see that there is no restriction on accessing that attribute
    from the class. You can see that `man` , which is an instance of `Person` , inherits
    both of them, reflecting them instantly when they change.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们定义了一个名为 `species` 的**类属性**。在类的主体中定义的任何名称都成为属于该类的属性。在代码中，我们还定义了 `Person.alive`
    ，这是另一个类属性。你可以看到，从类中访问该属性没有任何限制。你可以看到 `man` ，它是 `Person` 的一个实例，继承了这两个属性，当它们改变时立即反映出来。
- en: 'The `man` instance also has two attributes that belong to its own namespace
    and are, therefore, called **instance attributes** : `name` and `surname` .'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`man` 实例也有两个属于其自己命名空间的属性，因此被称为**实例属性**：`name` 和 `surname`。'
- en: '**Class attributes** are shared among all instances, while **instance attributes**
    are not; therefore, you should use class attributes to provide the states and
    behaviors to be shared by all instances, and use instance attributes for data
    that will be specific to each individual object.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**类属性**在所有实例之间共享，而**实例属性**则不是；因此，你应该使用类属性来提供所有实例共享的状态和行为，并使用实例属性来为每个单独的对象提供特定数据。'
- en: Attribute shadowing
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性遮蔽
- en: 'When you search for an attribute on an object and cannot find it, Python extends
    the search to the attributes on the object’s class (and keeps searching until
    the attribute is either found or the end of the inheritance chain is reached—more
    on inheritance later). This leads to an interesting shadowing behavior. Let us
    look at an example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在对象上搜索属性而找不到它时，Python 会将搜索扩展到对象上的属性（并且会继续搜索，直到找到属性或继承链的末尾——关于继承的更多信息稍后介绍）。这导致了一个有趣的遮蔽行为。让我们看一个例子：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding code is interesting. We defined a class called `Point` with two
    class attributes, `x` and `y` . When we create an instance of `Point` , `p` ,
    you can see that we can access both `x` and `y` from the `p` namespace ( `p.x`
    and `p.y` ). What happens when we do that is that Python doesn’t find any `x`
    or `y` attributes on the instance, and therefore, it searches the class and finds
    them there.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码很有趣。我们定义了一个名为 `Point` 的类，它有两个类属性，`x` 和 `y`。当我们创建 `Point` 的一个实例 `p` 时，你可以看到我们可以从
    `p` 命名空间中访问 `x` 和 `y`（`p.x` 和 `p.y`）。当我们这样做时，Python 在实例上找不到任何 `x` 或 `y` 属性，因此它搜索类并找到它们。
- en: Then, we give `p` its own `x` attribute by assigning `p.x = 12` . This behavior
    may appear a bit weird at first, but if you think about it, it is exactly the
    same as what happens in a function that declares `x = 12` when there is a global
    `x = 10` outside (see the section about scopes in *Chapter 4* , *Functions, the
    Building Blocks of Code* , for a refresher). We know that `x = 12` won’t affect
    the global one, and for class and instance attributes, it is exactly the same.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过分配 `p.x = 12` 给 `p` 它自己的 `x` 属性。这种行为一开始可能看起来有点奇怪，但如果你仔细想想，这与在全局 `x =
    10` 外部声明 `x = 12` 的函数中发生的情况完全相同（有关作用域的更多信息，请参阅 *第4章*，*函数，代码的构建块*，以进行复习）。我们知道 `x
    = 12` 不会影响全局的 `x`，对于类和实例属性来说，情况也是一样的。
- en: After assigning `p.x = 12` , when we print it, the search does not need to reach
    the class attributes because `x` is found on the instance, so we get `12` printed
    out. We also print `Point.x` , which refers to `x` in the class namespace, to
    show that it is still 10.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在分配 `p.x = 12` 之后，当我们打印它时，搜索不需要达到类属性，因为 `x` 已经在实例上找到了，所以我们打印出 `12`。我们还打印了 `Point.x`，它指的是类命名空间中的
    `x`，以表明它仍然是 `10`。
- en: Then, we delete `x` from the namespace of `p` , which means that, on the next
    line, when we print it again, Python will have to search for it in the class because
    it is no longer found on the instance.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从 `p` 的命名空间中删除 `x`，这意味着在下一条语句中再次打印它时，Python 将不得不在类中搜索它，因为它不再在实例上找到了。
- en: The last three lines show you that assigning attributes to an instance doesn’t
    mean that they will be found in the class. Instances get whatever is in the class,
    but the opposite is not true.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后三行显示，将属性分配给实例并不意味着它们会在类中找到。实例获得类中的任何内容，但反之则不然。
- en: What do you think about putting the `x` and `y` coordinates as class attributes?
    Do you think it was a good idea? What if we created another instance of `Point`
    ? Would that help to show why instance attributes are needed?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为将 `x` 和 `y` 坐标作为类属性怎么样？你认为这是一个好主意吗？如果我们创建了 `Point` 的另一个实例，这会帮助我们展示为什么需要实例属性吗？
- en: The self argument
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`self` 参数'
- en: 'From within a class method, we can refer to an instance by means of a special
    argument, called `self` by convention. `self` is always the first attribute of
    an instance method. Let us examine this behavior, together with how we can share
    not just attributes but also methods with all instances:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在类方法内部，我们可以通过一个特殊的参数来引用一个实例，这个参数传统上被称为 `self`。`self` 总是实例方法的第一个属性。让我们检查这种行为，以及我们如何不仅共享属性，还共享方法给所有实例：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note how the `area()` method is used by `sq` . The two calls, `Square.area(sq)`
    and `sq.area()` , are equivalent, and they teach us how the mechanism works. Either
    you pass the instance to the method call ( `Square.area(sq)` ), which within the
    method will take the name `self` , or you can use a more comfortable syntax, `sq.area()`
    , and Python will translate that for you behind the scenes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `area()` 方法是如何被 `sq` 使用的。这两个调用，`Square.area(sq)` 和 `sq.area()`，是等价的，并且它们教会我们机制是如何工作的。你可以将实例传递给方法调用（`Square.area(sq)`），在方法内部将名称
    `self`，或者你可以使用更舒适的语法，`sq.area()`，Python 会为你幕后转换。
- en: 'Let us look at a better example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看更好的例子：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding code shows us that nothing prevents us from using arguments when
    declaring methods. We can use the exact same syntax as we used with the function,
    but we need to remember that the first argument will always be the instance that
    the method will be bound to. We don’t need to necessarily call it `self` , but
    it is the convention, and this is one of the few cases where it is very important
    to abide by it.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码显示，我们可以在声明方法时使用参数，没有任何阻止。我们可以使用与函数完全相同的语法，但我们需要记住，第一个参数将始终是方法将要绑定到的实例。我们不必一定称它为
    `self`，但这是一个约定，这也是我们必须遵守的少数几个重要案例之一。
- en: Initializing an instance
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化实例
- en: 'Have you noticed how, before calling `p1.final_price()` in the code above,
    we had to assign `net_price` to `p1` ? There is a better way to do it. In other
    languages, this would be called a **constructor** , but in Python, it is not.
    It is actually an **initializer** , since it works on an already created instance,
    and therefore, it is called `__init__()` . It is a **magic method** , which is
    run right after the object is created. Python objects also have a `__new__()`
    method, which is the actual constructor. However, in practice, it is not so common
    to have to override it; that is a technique that is mostly used when writing metaclasses.
    Let us now see an example of how to initialize objects in Python:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，在上面的代码中在调用 `p1.final_price()` 之前，我们必须将 `net_price` 赋值给 `p1`？有更好的方法来做这件事。在其他语言中，这会被称为**构造函数**，但在
    Python 中并不是这样。它实际上是一个**初始化器**，因为它作用于已经创建的实例，因此被称为 `__init__()`。它是一个**魔法方法**，在对象创建后立即运行。Python
    对象还有一个 `__new__()` 方法，它是实际的构造函数。然而，在实践中，通常不需要重写它；这是一种主要用于编写元类的技术。现在让我们看看如何在 Python
    中初始化对象的例子：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Things are finally starting to take shape. When an object is created, the `__init__()`
    method is run for us automatically. In this case, we wrote it so that when we
    create a `Rectangle` object (by calling the class name like a function), we pass
    arguments to the creation call, like we would on any regular function call. The
    way we pass parameters follows the signature of the `__init__()` method, and therefore,
    in the two creation statements, `10` and `4` will be `side_a` and `side_b` for
    `r1` , while `7` and `3` will be `side_a` and `side_b` for `r2` . You can see
    that the call to `area()` from `r1` and `r2` reflects that they have different
    instance arguments. Setting up objects in this way is more convenient.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 事情终于开始成形。当一个对象被创建时，`__init__()` 方法会自动为我们运行。在这种情况下，我们这样写，当我们创建一个 `Rectangle`
    对象（通过像函数一样调用类名），我们向创建调用传递参数，就像在任何常规函数调用中一样。我们传递参数的方式遵循 `__init__()` 方法的签名，因此，在两个创建语句中，`10`
    和 `4` 将是 `r1` 的 `side_a` 和 `side_b`，而 `7` 和 `3` 将是 `r2` 的 `side_a` 和 `side_b`。你可以看到，从
    `r1` 和 `r2` 调用 `area()` 反映出它们有不同的实例参数。以这种方式设置对象更方便。
- en: OOP is about code reuse
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）是关于代码复用
- en: 'By now, it should be clear: *OOP is all about code reuse* . We define a class,
    we create instances, and those instances can use the methods that are defined
    in the class. They will behave differently according to how the instances have
    been set up by the initializer.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，应该已经很清楚：*面向对象编程（OOP）的全部都是关于代码复用*。我们定义一个类，创建实例，这些实例可以使用在类中定义的方法。它们的行为将根据实例是如何通过初始化器设置的而有所不同。
- en: Inheritance and composition
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 继承和组合
- en: 'However, this is just half of the story; OOP is more than just this. We have
    two main design constructs to use: inheritance and composition.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这仅仅是一半的故事；面向对象编程不仅仅是这个。我们有两种主要的设计结构可以使用：继承和组合。
- en: '**Inheritance** means that two objects are related by means of an **Is-A**
    type of relationship. On the other hand, **composition** means that two objects
    are related by means of a **Has-A** relationship. Let us explain with an example,
    where we declare classes for engine types:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**继承**意味着两个对象通过**是**（Is-A）类型的关系相关联。另一方面，**组合**意味着两个对象通过**有**（Has-A）关系相关联。让我们用一个例子来解释，其中我们声明了不同类型的引擎类：'
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, we want to declare some car types that will use those engines:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们想要声明一些将使用这些引擎的汽车类型：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Running the above prints the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码会打印以下内容：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding example shows you both the **Is-A** and **Has-A** types of relationships.
    First of all, let us consider `Engine` . It is a simple class with two methods,
    `start()` and `stop()` . We then define `ElectricEngine` and `V8Engine` , which
    both inherit from it. You can see this from their definition, which includes `Engine`
    within brackets after the name.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例展示了**是**（Is-A）和**有**（Has-A）类型的关系。首先，让我们考虑`Engine`。它是一个简单的类，有两个方法，`start()`和`stop()`。然后我们定义`ElectricEngine`和`V8Engine`，它们都从它继承。你可以从它们的定义中看到这一点，定义中在名称后面括号内包含了`Engine`。
- en: This means that both `ElectricEngine` and `V8Engine` inherit attributes and
    methods from the `Engine` class, which is said to be their **base class** (or
    **parent class** ).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`ElectricEngine`和`V8Engine`都从`Engine`类继承属性和方法，这个类被称为它们的**基类**（或**父类**）。
- en: The same happens with cars. `Car` is a base class for both `RaceCar` and `CityCar`
    . `RaceCar` is also the base class of `F1Car` . Another way of saying this is
    that `F1Car` inherits from `RaceCar` , which inherits from `Car` . Therefore,
    `F1Car` *Is-A* `RaceCar` , and `RaceCar` *Is-A* `Car` . Because of the transitive
    property, we can say that `F1Car` *Is-A* `Car` as well. `CityCar` , too, *Is-A*
    `Car` .
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于汽车来说，情况也是一样。`Car`是`RaceCar`和`CityCar`的基类。`RaceCar`也是`F1Car`的基类。另一种说法是，`F1Car`从`RaceCar`继承，而`RaceCar`从`Car`继承。因此，`F1Car`是`RaceCar`的**子类**，而`RaceCar`是`Car`的**子类**。由于传递性质，我们也可以说`F1Car`是`Car`的**子类**。同样，`CityCar`也是`Car`的**子类**。
- en: 'When we define `class A(B): pass` , we say that `A` is the *child* of `B` ,
    and `B` is the *parent* of `A` . The *parent* and *base* classes are synonyms,
    and so are *child of* and *derived from* . Also, we say that a class *inherits*
    from another class, or that it *extends* it.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们定义`class A(B): pass`时，我们说`A`是`B`的**子类**，而`B`是`A`的**父类**。**父类**和**基类**是同义词，**子类**和**派生类**也是同义词。我们还说一个类**继承**自另一个类，或者**扩展**它。'
- en: This is the inheritance mechanism.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是继承机制。
- en: Let us now go back to the code. Each class has a class attribute, `engine_cls`
    , which is a reference to the engine class that we want to assign to each type
    of car. `Car` has a generic `Engine` , the two race cars have a V8 engine, and
    the city car has an electric one.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到代码。每个类都有一个类属性`engine_cls`，它是对我们想要分配给每种汽车类型的引擎类的引用。`Car`有一个通用的`Engine`，两辆赛车有一个V8引擎，而城市车有一个电动引擎。
- en: When a car is created in the initializer method, `__init__()` , we create an
    instance of whatever engine class is assigned to the car and set it as the `engine`
    instance attribute.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当在初始化方法`__init__()`中创建汽车时，我们创建一个引擎类的实例并将其设置为`engine`实例属性。
- en: It makes sense to have `engine_cls` shared among all class instances because
    it is quite likely that all instances of the same car class will have the same
    kind of engine. On the other hand, it would not be good to have a single engine
    (an instance of any `Engine` class) as a class attribute because that would mean
    sharing one engine among all car instances, which is incorrect.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有类实例之间共享`engine_cls`是有意义的，因为所有同一类汽车实例很可能拥有相同类型的引擎。另一方面，将单个引擎（任何`Engine`类的实例）作为类属性是不好的，因为这意味着所有汽车实例共享一个引擎，这是不正确的。
- en: The type of relationship between a car and its engine is a *Has-A* type. A car
    *Has-A* engine. This is called **composition** and reflects the fact that objects
    can be composed of many other objects. A car *Has-A* engine, gears, wheels, a
    frame, doors, seats, and so on.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 汽车与其引擎之间的关系是**有**（Has-A）类型。汽车**有**一个引擎。这被称为**组合**，反映了对象可以由许多其他对象组成的事实。汽车**有**引擎、变速箱、车轮、底盘、车门、座椅等等。
- en: When using OOP, it is important to describe objects in this way so that we can
    properly structure our code.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用面向对象编程（OOP）时，以这种方式描述对象非常重要，这样我们才能正确地组织我们的代码。
- en: Notice that we had to avoid having dots in the `class_inheritance.py` script
    name, as dots in module names make imports difficult. Most modules in the source
    code of the book are meant to be run as standalone scripts, so we chose to add
    dots to enhance readability when possible, but in general, you want to avoid dots
    in your module names.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不得不避免在`class_inheritance.py`脚本名称中使用点，因为模块名称中的点会使导入变得困难。本书的源代码中的大多数模块都旨在作为独立脚本运行，因此我们选择在可能的情况下添加点以增强可读性，但通常，你想要避免在模块名称中使用点。
- en: 'Before we leave this paragraph, let us verify the correctness of what we stated
    above with another example:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开这个段落之前，让我们用另一个示例来验证我们上面所说的内容是否正确：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, `car` is just an instance of `Car` , while `racecar` is an instance
    of `RaceCar` (and by extension of `Car` ), and `f1car` is an instance of `F1Car`
    (and of both `RaceCar` and `Car` , by extension). Similarly, a *banana* is an
    instance of *Banana* . But, also, it is a *Fruit* . Also, it is *Food* , right?
    Same concept. To check whether an object is an instance of a class, use the `isinstance()`
    function. It is recommended over sheer type comparison ( `type(object) is Class`
    ).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`car`只是`Car`的一个实例，而`racecar`是`RaceCar`（以及通过扩展`Car`）的一个实例，`f1car`是`F1Car`（以及通过扩展`RaceCar`和`Car`）的一个实例。同样，一个*香蕉*是*Banana*的一个实例。但是，它也是一个*水果*。同样，它也是*食物*，对吧？同一个概念。要检查一个对象是否是某个类的实例，请使用`isinstance()`函数。它比单纯的类型比较（`type(object)
    is Class`）更推荐。
- en: Notice that we have left out the prints you get when instantiating the cars.
    We saw them in the previous example.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们省略了实例化汽车时得到的打印输出。我们在前面的示例中看到了它们。
- en: 'Let us also check inheritance. Same setup, but different logic in the `for`
    loops:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也检查一下继承。同样的设置，但在`for`循环中有不同的逻辑：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Interestingly, we learn that *a class is a subclass of itself* . Check the output
    of the preceding example to see that it matches the explanation we provided.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我们了解到*一个类是其自身的子类*。检查前面示例的输出，看看它是否与我们提供的解释相符。
- en: Note that, by convention, class names are written using *CapWords* , which means
    *ThisWayIsCorrect* , as opposed to functions and methods, which are written in
    snake case, like *this_way_is_correct* . Also, if you want to use a name in your
    code that clashes with a Python-reserved keyword or a built-in function or class,
    the convention is to add a trailing underscore to the name. In the first *for
    loop* example, we loop through the class names using `for class_ in ...` because
    `class` is a reserved word. You can refresh your knowledge about conventions by
    reading PEP 8.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，按照惯例，类名使用*CapWords*编写，即*ThisWayIsCorrect*，而函数和方法则使用snake case，如*this_way_is_correct*。此外，如果你想在代码中使用一个与Python保留关键字或内置函数或类冲突的名称，惯例是在名称后添加一个尾随下划线。在第一个*for循环*示例中，我们使用`for
    class_ in ...`遍历类名，因为`class`是一个保留字。你可以通过阅读PEP 8来刷新你对约定的了解。
- en: 'To help illustrate the difference between *Is-A* and *Has-A* , look at the
    following diagram:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助说明*Is-A*和*Has-A*之间的区别，请看以下图表：
- en: '![img](img/B30992_06_01.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B30992_06_01.png)'
- en: 'Figure 6.1: Is-A versus Has-A relationships'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：Is-A与Has-A关系
- en: Accessing a base class
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问基类
- en: 'We have already seen class declarations, such as `class ClassA: pass` and `class
    ClassB(BaseClassName): pass` . When we don’t specify a base class explicitly,
    Python will set the built-in **object** class as the base class. Ultimately, all
    classes derive from `object` . Please remember that, if you do not specify a base
    class, brackets are optional and, in practice, are never used.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '我们已经看到了类声明，例如`class ClassA: pass`和`class ClassB(BaseClassName): pass`。当我们没有明确指定基类时，Python会将内置的**object**类作为基类。最终，所有类都从`object`派生。请记住，如果你没有指定基类，括号是可选的，并且在实践中从不使用。'
- en: 'Therefore, writing `class A: pass` or `class A(): pass` or `class A(object):
    pass` are all equivalent. The `object` class is a special class in that it hosts
    the methods that are common to all Python classes, and it does not allow you to
    set any attributes on it.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，编写`class A: pass`或`class A(): pass`或`class A(object): pass`都是等效的。`object`类是一个特殊的类，因为它包含了所有Python类共有的方法，并且不允许你设置任何属性。'
- en: 'Let us see how we can access a base class from within a class:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何在类内部访问基类：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Take a look at the preceding code. Three of the input parameters for `Book`
    are duplicated in `Ebook` . This is bad practice because we now have two sets
    of instructions that are doing the same thing. Moreover, any change in the signature
    of `Book.__init__()` will not be reflected in `Ebook` . Normally, we want changes
    in a base class to be reflected in its children. Let us see one way to fix this
    issue:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下前面的代码。`Book` 的三个输入参数在 `Ebook` 中重复。这是不好的做法，因为我们现在有两套做同样事情的指令。此外，`Book.__init__()`
    签名的任何更改都不会反映在 `Ebook` 中。通常，我们希望基类中的更改反映在其子类中。让我们看看一种修复这个问题的方法：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Much better. We have removed that code duplication. In this example, we tell
    Python to call the `__init__()` method of the `Book` class; we feed `self` to
    that call, making sure that we bind it to the present instance.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 更好了。我们已经去除了代码重复。在这个例子中，我们告诉 Python 调用 `Book` 类的 `__init__()` 方法；我们将 `self` 传递给这个调用，确保我们将其绑定到当前实例。
- en: If we modify the logic within the `__init__()` method of `Book` , we do not
    need to touch `Ebook` ; the change will transfer automatically.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们修改 `Book` 类的 `__init__()` 方法中的逻辑，我们不需要触及 `Ebook`；这个更改将自动传递。
- en: 'This approach is good, but it still suffers from a minor issue. Say that we
    change the name of `Book` to `Liber` , which is the Latin word for “book.” We
    would then have to change the `__init__()` method of `Ebook` to reflect that change.
    This can be avoided by using `super` :'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法很好，但它仍然存在一个小问题。比如说，我们将 `Book` 的名字改为 `Liber`，这是“书”的拉丁语。那么我们就必须更改 `Ebook`
    的 `__init__()` 方法以反映这个更改。这可以通过使用 `super` 来避免：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`super()` is a function that returns a proxy object that delegates method calls
    to a parent or sibling class.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`super()` 是一个函数，它返回一个代理对象，该对象将方法调用委托给父类或兄弟类。'
- en: Two classes are siblings if they share the same parents.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个类有相同的父类，它们就是兄弟类。
- en: In this case, `super()` will delegate the call to `Book.__init__()` , and the
    beauty of this approach is that now we are free to change `Book` to `Liber` without
    having to touch the logic in the `__init__()` method of `Ebook` at all.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`super()` 将委托调用到 `Book.__init__()`，这种方法的优点是现在我们可以自由地将 `Book` 改为 `Liber`，而无需触及
    `Ebook` 的 `__init__()` 方法中的任何逻辑。
- en: Now that we know how to access a base class from its child, let us explore Python’s
    multiple inheritance.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何从子类访问基类，让我们探索 Python 的多重继承。
- en: Multiple inheritance
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多重继承
- en: 'In Python, we are allowed to define classes that inherit from more than one
    base class. This is called **multiple inheritance** . When a class has more than
    one base class, attribute search can follow more than one path. Take a look at
    the following diagram:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，我们可以定义从多个基类继承的类。这被称为 **多重继承**。当一个类有多个基类时，属性搜索可以遵循多条路径。看看下面的图示：
- en: '![img](img/B30992_06_02.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B30992_06_02.png)'
- en: 'Figure 6.2: A class inheritance diagram'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2：类继承图
- en: 'As you can see, `Shape` and `Plotter` act as base classes for all the others.
    `Polygon` inherits directly from them, `RegularPolygon` inherits from `Polygon`
    , and both `RegularHexagon` and `Square` inherit from `RegularPolygon` . Note
    also that `Shape` and `Plotter` implicitly inherit from `object` , so from `Polygon`
    up to `object` , we have what is known as a **diamond.** In simpler terms, we
    have more than one path to reach a base class. We will see why this matters in
    a few moments. Let us translate the diagram into code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`Shape` 和 `Plotter` 作为所有其他类的基类。`Polygon` 直接从它们继承，`RegularPolygon` 从 `Polygon`
    继承，而 `RegularHexagon` 和 `Square` 都从 `RegularPolygon` 继承。还要注意，`Shape` 和 `Plotter`
    隐式地从 `object` 继承，所以从 `Polygon` 到 `object`，我们有一个所谓的 **菱形**。用更简单的话说，我们有超过一条路径可以到达基类。我们将在几分钟后看到这为什么很重要。让我们将这个图示转换成代码：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Take a look at the preceding code: the `Shape` class has one attribute, `geometric_type`
    , and two methods, `area()` and `get_geometric_type()` . It is quite common to
    use base classes (such as `Shape` , in our example) to define an **interface**
    , a set of methods for which children must provide an implementation. There are
    different and better ways to do this, but we want to keep this example as simple
    as possible for the time being.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下前面的代码：`Shape` 类有一个属性 `geometric_type` 和两个方法，`area()` 和 `get_geometric_type()`。使用基类（例如我们的例子中的
    `Shape`）来定义一个 **接口**，即一组子类必须提供实现的函数，这是相当常见的。但是，我们目前想要使这个例子尽可能简单。
- en: We also have the `Plotter` class, which adds the `plot()` method, thereby providing
    plotting capabilities for any class that inherits from it. Of course, the `plot()`
    implementation is just a dummy `print()` in this example. The first interesting
    class is `Polygon` , which inherits from both `Shape` and `Plotter` .
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个`Plotter`类，它添加了`plot()`方法，从而为继承自它的任何类提供了绘图能力。当然，在这个例子中，`plot()`的实现只是一个简单的`print()`。第一个有趣的类是`Polygon`，它从`Shape`和`Plotter`类继承。
- en: There are many types of polygons, one of which is the regular one, which is
    both equiangular (all angles are equal) and equilateral (all sides are equal),
    so we create the `RegularPolygon` class that inherits from `Polygon` . For a regular
    polygon, where all sides are equal, we can implement a simple `__init__()` method,
    which just takes the length of the side. We create the `RegularHexagon` and `Square`
    classes, which both inherit from `RegularPolygon` .
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 多边形有很多种类型，其中之一是正多边形，它既等角（所有角度相等）又等边（所有边相等），因此我们创建了从`Polygon`类继承的`RegularPolygon`类。对于所有边都相等的正多边形，我们可以实现一个简单的`__init__()`方法，它只接受边的长度。我们创建了从`RegularPolygon`继承的`RegularHexagon`和`Square`类。
- en: This structure is quite long, but hopefully, it gives you an idea of how to
    specialize the classification of your objects.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构相当长，但希望它能给你一个如何专门化你的对象分类的想法。
- en: Now, please take a look at the last eight lines of code. Note that when we call
    the `area()` method on `hexagon` and `square` , we get the correct area for both.
    This is because they both provide the correct implementation logic for it. Also,
    we can call `get_geometric_type()` on both of them, even though it is not defined
    in their classes, and Python goes all the way up to `Shape` to find an implementation
    for it. Note that, even though the implementation is provided in the `Shape` class,
    the `self.geometric_type()` used for the return value is correctly taken from
    the caller instance.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请看一下最后八行代码。注意，当我们对`hexagon`和`square`调用`area()`方法时，我们得到了两者的正确面积。这是因为它们都提供了正确的实现逻辑。此外，我们还可以在它们两个上调用`get_geometric_type()`，即使它没有定义在它们的类中，Python也会一直向上到`Shape`类来寻找它的实现。注意，尽管实现是在`Shape`类中提供的，但用于返回值的`self.geometric_type()`是正确地从调用实例中获取的。
- en: The `plot()` method calls are also interesting and show you how you can enrich
    your objects with capabilities they would not otherwise have. This technique is
    very popular in web frameworks such as Django, which provides special classes
    called **mixins** , whose capabilities you can just use out of the box. All you
    need is to define the desired mixin as one of the base classes for your class.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`plot()`方法的调用也很有趣，展示了你如何通过这种技术丰富你的对象，使其具有它们原本不具备的能力。这种技术在像Django这样的Web框架中非常流行，Django提供了称为**混入**（mixins）的特殊类，你可以直接使用这些类的功能。你所需要做的就是将所需的混入类作为你类的一个基类来定义。'
- en: Multiple inheritance is powerful, but at the same time, it can get a bit messy,
    so we need to make sure we understand what happens when we use it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 多重继承功能强大，但同时也可能变得有些混乱，因此我们需要确保我们理解在使用它时会发生什么。
- en: Method resolution order
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法解析顺序
- en: By now, we know that when we ask for `someobject.attribute` and `attribute`
    is not found on that object, Python starts searching in the class that `someobject`
    was created from. If it is not there either, Python searches up the inheritance
    chain until either `attribute` is found or the `object` class is reached. This
    is quite simple to understand if the inheritance chain is only made of single-inheritance
    steps, which means that classes have only one parent, all the way up to `object`
    . However, when multiple inheritance is involved, there are cases when it is not
    straightforward to predict which class will be searched next if an attribute is
    not found.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道当我们请求`someobject.attribute`且`attribute`没有在对象上找到时，Python会从`someobject`创建的类中开始搜索。如果那里也没有，Python会沿着继承链向上搜索，直到找到`attribute`或到达`object`类。如果继承链只由单继承步骤组成，这意味着类只有一个父类，一直向上到`object`，那么这很容易理解。然而，当涉及多重继承时，如果找不到属性，预测下一个将被搜索的类可能并不直接。
- en: 'Python provides a way to always know the order in which classes are searched
    on attribute lookup: the **method resolution order** ( **MRO** ).'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了一种方法，可以始终知道在属性查找时类被搜索的顺序：**方法解析顺序**（**MRO**）。
- en: The MRO is the order in which base classes are searched for a member during
    lookup. Since version 2.3, Python uses an algorithm called **C3** , which guarantees
    monotonicity.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: MRO 是在查找成员时搜索基类的顺序。自 2.3 版本以来，Python 使用一个称为 **C3** 的算法，它保证了单调性。
- en: 'Let us see the MRO for the `Square` class from the previous example:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看上一个例子中 `Square` 类的 MRO：
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: To get to the MRO of a class, we can go from the instance to its `__class__`
    attribute, and from that to its `__mro__` attribute. Alternatively, we could have
    used `Square.__mro__` , or `Square.mro()` directly, but if you need to access
    the MRO from an instance, you will have to derive its class dynamically.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取一个类的 MRO，我们可以从实例到其 `__class__` 属性，然后到其 `__mro__` 属性。或者，我们也可以使用 `Square.__mro__`，或者直接使用
    `Square.mro()`，但如果你需要从一个实例访问 MRO，你将不得不动态地推导出其类。
- en: 'Note that the only point of doubt is the branching after `Polygon` , where
    the inheritance chain creates two paths: one leads to `Shape` and the other to
    `Plotter` . We know by scanning the MRO for the `Square` class that `Shape` is
    searched before `Plotter` .'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，唯一有疑问的地方是在 `Polygon` 之后的部分，继承链创建了两个路径：一条通向 `Shape`，另一条通向 `Plotter`。通过扫描 `Square`
    类的 MRO，我们知道 `Shape` 在 `Plotter` 之前被搜索。
- en: 'Why is this important? Well, consider the following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这为什么很重要呢？好吧，考虑以下代码：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Both `B` and `C` inherit from `A` , and `D` inherits from both `B` and `C` .
    This means that the lookup for the `label` attribute can reach the top ( `A` )
    through either `B` or `C` . Depending on which is reached first, we get a different
    result.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`B` 和 `C` 都继承自 `A`，而 `D` 则继承自 `B` 和 `C`。这意味着在查找 `label` 属性时，可以通过 `B` 或 `C`
    达到顶层（`A`）。根据首先到达的是哪一个，我们得到不同的结果。'
- en: 'In this preceding example, we get `''b''` , which is what we were expecting,
    since `B` is the leftmost among the base classes of `D` . But what happens if
    we remove the `label` attribute from `B` ? This would be a confusing situation:
    will the algorithm go all the way up to `A` or will it get to `C` first? Let us
    find out:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个先前的例子中，我们得到 `'b'`，这是我们预期的，因为 `B` 是 `D` 的基类中最左侧的。但是，如果我们从 `B` 中移除 `label`
    属性会发生什么呢？这将是一个令人困惑的情况：算法会一直向上到 `A`，还是会首先到达 `C`？让我们找出答案：
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: So we learn that the MRO is `D->B->C->A->object` , which means that when we
    ask for `d.label` , we get `'c'` .
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们了解到 MRO 是 `D->B->C->A->object`，这意味着当我们请求 `d.label` 时，我们得到 `'c'`。
- en: In day-to-day programming, it is not common to have to deal with the MRO, but
    we felt it was important to at least mention it in this paragraph so that, should
    you get entangled in a complex mixins structure, you will be able to find your
    way out of it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常编程中，通常不需要处理 MRO，但我们认为至少在这个段落中提到它很重要，这样，如果你陷入复杂的混入结构中，你将能够找到出路。
- en: Class and static methods
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类和静态方法
- en: 'So far, we have written classes with attributes in the form of data and instance
    methods, but there are two other types of methods that we can find in a class
    definition: **static methods** and **class methods** .'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们编写的类具有数据形式的属性和实例方法，但在类定义中我们还可以找到两种其他类型的方法：**静态方法**和**类方法**。
- en: Static methods
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态方法
- en: 'When you create a class object, Python assigns a name to it. That name acts
    as a namespace, and sometimes, it makes sense to group functionalities under it.
    Static methods are perfect for this use case. Unlike instance methods, they do
    not need to be passed an instance when called. Let us look at an example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个类对象时，Python 会给它分配一个名称。这个名称充当命名空间，有时，将功能分组在其下是有意义的。静态方法非常适合这种用途。与实例方法不同，在调用时它们不需要传递实例。让我们来看一个例子：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The preceding code is quite interesting. First, we learn that static methods
    are created by simply applying the `staticmethod` decorator to them. You can see
    that they don’t require any extra arguments, so apart from the decoration, they
    just look like functions.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码非常有趣。首先，我们了解到静态方法是通过简单地应用 `staticmethod` 装饰器来创建的。你可以看到它们不需要任何额外的参数，所以除了装饰之外，它们看起来就像函数一样。
- en: We have a class, `StringUtil` , that acts as a container for functions. Another
    approach would be to have a separate module with functions inside. It is really
    a matter of style, most of the time.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为 `StringUtil` 的类，它充当函数的容器。另一种方法是在单独的模块中包含函数。这实际上是一个风格问题，大多数情况下都是如此。
- en: The logic inside `is_palindrome()` should be straightforward for you by now,
    but just in case, let us go through it. First, we remove all characters from `s`
    that are neither letters nor numbers. We use the `join()` method of a string object
    to do this. By calling `join()` on an empty string, the result is that all elements
    in the iterable you pass to `join()` will be concatenated together. We feed `join()`
    a generator expression that produces all alphanumeric characters in `s` in order.
    This is a normal procedure when analyzing palindromes.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，`is_palindrome()` 中的逻辑应该对您来说已经很直观了，但以防万一，让我们过一遍。首先，我们从 `s` 中移除所有既不是字母也不是数字的字符。我们使用字符串对象的
    `join()` 方法来做这件事。通过在空字符串上调用 `join()`，结果是所有传递给 `join()` 的可迭代元素将被连接在一起。我们向 `join()`
    提供一个生成器表达式，该表达式按顺序生成 `s` 中的所有字母数字字符。这是分析回文时的正常程序。
- en: If `case_insensitive` is `True` , we lowercase `s` . Finally, we proceed to
    check whether `s` is a palindrome. To do this, we compare the first and last characters,
    then the second and the second to last, and so on. If, at any point, we find a
    difference, it means the string isn’t a palindrome, and therefore, we can return
    `False` . On the other hand, if we exit the `for` loop normally, it means no differences
    were found, and we can, therefore, say the string is a palindrome.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `case_insensitive` 是 `True`，我们将 `s` 转换为小写。最后，我们继续检查 `s` 是否是回文。为此，我们比较第一个和最后一个字符，然后是第二个和倒数第二个，以此类推。如果在任何时刻我们发现差异，这意味着字符串不是回文，因此我们可以返回
    `False`。另一方面，如果我们正常退出 `for` 循环，这意味着没有找到差异，因此我们可以断定字符串是回文。
- en: Notice that this code works correctly regardless of the length of the string—that
    is, if the length is odd or even. The measure `len(s) // 2` reaches half of `s`
    , and if `s` is an odd number of characters long, the middle one won’t be checked
    (for instance, in *RaDaR* , *D* is not checked), but we don’t care, as it would
    be compared to itself.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这段代码无论字符串长度是奇数还是偶数都能正确工作。度量 `len(s) // 2` 达到 `s` 的一半，如果 `s` 的长度是奇数个字符，中间的那个字符不会被检查（例如，在
    *RaDaR* 中，*D* 不会被检查），但我们并不在意，因为它会与自身比较。
- en: 'The `get_unique_words()` method is much simpler: it just returns a set to which
    we feed a list with the words from a sentence. The `set` class removes any duplication
    for us, so we don’t need to do anything else.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_unique_words()` 方法要简单得多：它只是返回一个集合，我们将包含句子中单词的列表喂给这个集合。`set` 类会为我们移除任何重复项，所以我们不需要做任何事情。'
- en: The `StringUtil` class provides us with a container namespace for methods that
    are meant to work on strings. Another example could have been a `MathUtil` class
    with some static methods to work on numbers.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringUtil` 类为我们提供了一个容器命名空间，用于存放旨在处理字符串的方法。另一个例子可能是一个 `MathUtil` 类，其中包含一些用于处理数字的静态方法。'
- en: Class methods
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类方法
- en: 'Class methods are slightly different from static methods in that, like instance
    methods, they also receive a special first argument. In their case, it is the
    class object itself, rather than the instance. A very common use case for class
    methods is to provide factory capability to a class, which means having alternative
    ways to create instances of the class. Let us see an example:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法与静态方法略有不同，因为它们像实例方法一样也接收一个特殊的第一个参数。在这种情况下，它是类对象本身，而不是实例。类方法的一个非常常见的用例是为类提供工厂能力，这意味着有其他方式可以创建类的实例。让我们看一个例子：
- en: '[PRE34]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding code, we show you how to use a class method to create a factory
    for the `Point` class. In this case, we want to create a `Point` instance by passing
    both coordinates (regular creation `p = Point(3, 7)` ), but we also want to be
    able to create an instance by passing a tuple ( `Point.from_tuple()` ) or another
    instance ( `Point.from_point()` ).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们向您展示了如何使用类方法为 `Point` 类创建一个工厂。在这种情况下，我们希望通过传递两个坐标（常规创建 `p = Point(3,
    7)`）来创建一个 `Point` 实例，但我们还希望能够通过传递一个元组（`Point.from_tuple()`）或另一个实例（`Point.from_point()`）来创建一个实例。
- en: Within each class method, the `cls` argument refers to the `Point` class. As
    with the instance method, which takes `self` as the first argument, the class
    method takes a `cls` argument. Both `self` and `cls` are named after a convention
    that you are not forced to follow but are strongly encouraged to respect. This
    is something that no professional Python coder would change; it is so strong a
    convention that plenty of tools, such as parsers, linters, and the like, rely
    on it.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个类方法中，`cls` 参数指的是 `Point` 类。与实例方法一样，实例方法以 `self` 作为第一个参数，类方法也接受一个 `cls` 参数。`self`
    和 `cls` 都是按照一种约定来命名的，虽然你不强制遵守，但强烈建议你尊重这种约定。这是任何专业的 Python 程序员都不会改变的事情；这是一个如此强烈的约定，以至于许多工具，如解析器、linters
    等，都依赖于它。
- en: Class and static methods play well together. Static methods are particularly
    useful for breaking up the logic of a class method to improve its layout.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法和静态方法可以很好地协同工作。静态方法特别有用，可以将类方法的逻辑拆分，以改善其布局。
- en: 'Let us see an example by refactoring the `StringUtil` class:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过重构 `StringUtil` 类来举一个例子：
- en: '[PRE35]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Compare this code with the previous version. First of all, note that even though
    `is_palindrome()` is now a class method, we call it in the same way we called
    it when it was a static one. The reason why we changed it to a class method is
    that after factoring out some of its logic (to `_strip_string()` and `_is_palindrome()`
    ), we need to get a reference to those methods, and if we have no `cls` in our
    method, the only option would be to call them by using the name of the class itself,
    like so: `StringUtil._strip_string()` and `StringUtil._is_palindrome()` .'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码与上一个版本进行比较。首先，请注意，尽管 `is_palindrome()` 现在是一个类方法，但我们调用它的方式与它是静态方法时相同。我们将其更改为类方法的原因是，在将其逻辑分解（到
    `_strip_string()` 和 `_is_palindrome()`）之后，我们需要获取对这些方法的引用，如果没有 `cls` 在我们的方法中，唯一的选择就是通过使用类本身的名称来调用它们，如下所示：`StringUtil._strip_string()`
    和 `StringUtil._is_palindrome()`。
- en: However, this is not good practice because we would hardcode the class name
    in the `is_palindrome()` method, thereby putting ourselves in the position of
    having to modify it whenever we want to change the class name. Using `cls` means
    it will act as the class name, which means our code won’t need any modifications
    should the class name change.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是一个好的做法，因为我们会在 `is_palindrome()` 方法中硬编码类名，从而让我们处于每次想要更改类名时都必须修改它的位置。使用
    `cls` 意味着它将作为类名，这意味着如果类名更改，我们的代码就不需要任何修改。
- en: Notice how the new logic reads much better than the previous version. Moreover,
    notice that, by naming the *factored-out* methods with a leading underscore, we
    hint that those methods are not supposed to be called from outside the class,
    but this will be the subject of the next paragraph.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到新的逻辑比上一个版本读起来要好得多。此外，注意通过在分解出的方法名称前加上一个前导下划线，我们暗示这些方法不应该从类外部调用，但这将是下一段的主题。
- en: Private methods and name mangling
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 私有方法和名称改写
- en: If you have any background in languages like Java, C#, or C++, then you know
    that they allow the programmer to assign a privacy status to attributes (both
    data and methods). Each language has its own slightly different flavor for this,
    but the gist is that public attributes are accessible from any point in the code,
    while private ones are accessible only within the scope they are defined in.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉像 Java、C# 或 C++ 这样的语言，那么你知道它们允许程序员为属性（数据和方法）分配隐私状态。每种语言都有自己略微不同的风味，但大意是公共属性可以从代码的任何位置访问，而私有属性只能在定义它们的范围内访问。
- en: In Python, there is no such thing. Everything is public; therefore, we rely
    on conventions and, for privacy, on a mechanism called **name mangling** .
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，没有这种东西。一切都是公开的；因此，我们依赖于约定，并且为了隐私，依赖于一种称为 **名称改写** 的机制。
- en: 'The convention is as follows: if an attribute’s name has no leading underscores,
    it is considered public. This means you can access it and modify it freely. When
    the name has one leading underscore, the attribute is considered private, which
    means it is intended to be used internally, and you should not modify it or call
    it from the outside. A very common use case for private attributes is helper methods
    that are supposed to be used by public ones (possibly in call chains in conjunction
    with other methods). Another use case is internal data, such as scaling factors,
    or any other data that we would ideally put in a constant, a variable that, once
    defined, cannot change. However, Python has no concept of constants.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是惯例：如果一个属性的名称没有前导下划线，它被认为是公共的。这意味着你可以自由地访问和修改它。当名称有一个前导下划线时，属性被认为是私有的，这意味着它打算内部使用，你不应该从外部修改或调用它。私有属性的一个非常常见的用例是辅助方法，这些方法应该由公共方法使用（可能在调用链中与其他方法一起使用）。另一个用例是内部数据，例如缩放因子，或者我们理想中会放入常量、一旦定义就不能更改的变量中的任何其他数据。然而，Python
    没有常量的概念。
- en: We know some programmers who don’t feel at ease with this aspect of Python.
    In our experience, we have never encountered situations in which we had bugs because
    Python lacks private attributes. It is a matter of discipline, best practices,
    and following conventions.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认识一些程序员对 Python 的这个方面感到不舒服。根据我们的经验，我们从未遇到过因为 Python 缺乏私有属性而导致错误的情况。这是一个纪律、最佳实践和遵循惯例的问题。
- en: The amount of freedom Python offers to a developer is the reason why, sometimes,
    it is referred to as a *language for adults* . And of course, there are pros and
    cons to every design choice. At the end of the day, some people prefer languages
    that allow more power and might require a bit more responsibility, while others
    prefer languages that are more constrictive. To each their own; it’s not a matter
    of right or wrong.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Python 给开发者提供的自由度是它有时被称为“成人语言”的原因。当然，每个设计选择都有其利弊。最终，有些人更喜欢允许更多权力且可能需要更多责任的语言，而有些人更喜欢更具约束性的语言。各取所需；这不是对错的问题。
- en: 'That said, the call for privacy actually makes sense because, without it, you
    risk introducing bugs into your code for real. Let us show you what we mean:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，对隐私的调用实际上是有意义的，因为没有它，你可能会真的把错误引入到你的代码中。让我们展示一下我们的意思：
- en: '[PRE36]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding code, we have an attribute called `_factor` , and let us pretend
    it is so important that it shouldn’t be modified at runtime after the instance
    is created because `op1()` depends on it to function correctly. We’ve named it
    with a leading underscore, but the issue here is that the call `obj.op2(42)` modifies
    it, and this is then reflected in subsequent calls to `op1()` .
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有一个名为 `_factor` 的属性，让我们假设它非常重要，以至于实例创建后不应该在运行时修改，因为 `op1()` 函数依赖于它来正确运行。我们用前导下划线命名了它，但问题在于调用
    `obj.op2(42)` 修改了它，这随后反映在后续对 `op1()` 的调用中。
- en: 'We can fix this undesired behavior by adding a second leading underscore:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加第二个前导下划线来修复这种不希望的行为：
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, it is working as desired. Python is kind of magic, and in this case, what
    is happening is that the name-mangling mechanism has kicked in.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，它按预期工作。Python 算是一种魔法，在这种情况下，正在发生的是名称混淆机制已经启动。
- en: Name mangling means that any attribute name that has at least two leading underscores
    and at most one trailing underscore, such as `__my_attr` , is replaced with a
    name that includes an underscore and the class name before the actual name, such
    as `_ClassName__my_attr` .
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 名称混淆意味着任何至少有两个前导下划线和最多一个后缀下划线的属性名称，例如 `__my_attr`，会被替换为一个包含下划线和类名（在真实名称之前）的名称，例如
    `_ClassName__my_attr` 。
- en: 'This means that when you inherit from a class, the mangling mechanism gives
    your private attribute two different names in the base and child classes so that
    name collision is avoided. Every class and instance object stores references to
    their attributes in a special attribute, called `__dict__` . Let us inspect `obj.__dict__`
    to see name mangling in action:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当你从类继承时，名称混淆机制会在基类和子类中为你的私有属性提供两个不同的名称，以避免名称冲突。每个类和实例对象都在一个特殊属性中存储对其属性的引用，这个属性称为
    `__dict__`。让我们检查 `obj.__dict__` 以查看名称混淆的实际操作：
- en: '[PRE38]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This is the `_factor` attribute that we find in the problematic version of
    this example, but look at the one that uses `__factor` :'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在有问题的示例版本中找到的 `_factor` 属性，但看看使用 `__factor` 的那个：
- en: '[PRE39]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`obj` has two attributes now, `_A__factor` (mangled within the `A` class) and
    `_B__factor` (mangled within the `B` class). This is the mechanism that ensures
    that when you execute `obj.__factor = 42` , `__factor` in `A` isn’t changed because
    you’re actually touching `_B__factor` , which has no effect on `_A__factor` .'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`obj`现在有两个属性，`_A__factor`（在`A`类中混淆）和`_B__factor`（在`B`类中混淆）。这是确保当你执行`obj.__factor
    = 42`时，`A`中的`__factor`不会改变，因为你实际上接触的是`_B__factor`，这对`_A__factor`没有影响。'
- en: If you are designing a library with classes that are meant to be used and extended
    by other developers, you will need to keep this in mind in order to avoid the
    unintentional overriding of your attributes. Bugs like these can be subtle and
    hard to spot.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在设计一个旨在被其他开发者使用和扩展的库，你需要记住这一点，以避免无意中覆盖你的属性。这样的错误可能很微妙，难以发现。
- en: The property decorator
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性装饰器
- en: Another thing that would be a crime not to mention is the **property** decorator.
    Imagine that you have an `age` attribute in a `Person` class and, at some point,
    you want to make sure that when you change its value, you also check that `age`
    is within a proper range, such as [18, 99]. You could write accessor methods,
    such as `get_age()` and `set_age()` (also called **getters** and **setters** ),
    and put the logic there. `get_age()` will most likely just return `age` , while
    `set_age()` will set its value after checking its validity. The problem is that
    you may already have some code accessing the `age` attribute directly, which means
    you’re now ready for some refactoring. Languages like Java overcome this problem
    by using the accessor pattern basically by default. Many Java **Integrated Development
    Environments** ( **IDEs** ) autocomplete an attribute declaration by writing getter
    and setter accessor method stubs for you on the fly.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个不容忽视的问题是**属性**装饰器。想象一下，你有一个`Person`类中的`age`属性，在某个时刻，你想要确保当你更改其值时，你也检查`age`是否在适当的范围内，例如[18,
    99]。你可以编写访问器方法，如`get_age()`和`set_age()`（也称为**获取器**和**设置器**），并将逻辑放在那里。`get_age()`很可能会只返回`age`，而`set_age()`在检查其有效性后设置其值。问题是，你可能已经有一些代码直接访问`age`属性，这意味着你现在需要准备一些重构。像Java这样的语言通过默认使用访问器模式来克服这个问题。许多Java**集成开发环境**（**IDE**）会自动完成属性声明，并为你即时编写获取器和设置器访问方法占位符。
- en: But we are not learning Java. Python achieves the same result with the `property`
    decorator. When you decorate a method with `property` , you can use the name of
    the method as if it were a data attribute. Because of this, it is always best
    to refrain from putting logic that would take a while to complete in such methods
    because, by accessing them as attributes, we do not expect to wait.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们不是在学习Java。Python使用`property`装饰器实现了相同的结果。当你用`property`装饰一个方法时，你可以使用方法的名称，就像它是一个数据属性一样。正因为如此，最好避免在这样方法中放置需要花费很长时间才能完成的逻辑，因为，通过将它们作为属性访问，我们并不期望等待。
- en: 'Let us look at an example:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子：
- en: '[PRE40]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `Person` class may be the first version we write. Then, we realize we need
    to put the range logic in place, so with another language, we would have to rewrite
    `Person` as the `PersonWithAccessors` class and refactor the code that uses `Person.age`
    . In Python, we rewrite `Person` as `PersonPythonic` (you normally wouldn’t change
    the name, of course; this is just for the sake of illustration). In `PersonPythonic`
    the age is stored in a *private* `_age` variable, and we define property getters
    and setters using the decoration shown, which allows us to keep using the `person`
    instances as before. A **getter** is a method that is called when we access an
    attribute for reading. On the other hand, a **setter** is a method that is called
    when we access an attribute to write it.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person`类可能是我们最初写的版本。然后，我们意识到我们需要放置范围逻辑，因此，在另一种语言中，我们不得不将`Person`重写为`PersonWithAccessors`类，并重构使用`Person.age`的代码。在Python中，我们将`Person`重写为`PersonPythonic`（当然，你通常不会更改名称；这只是为了说明）。在`PersonPythonic`中，年龄存储在一个**私有**的`_age`变量中，我们使用显示的装饰器定义属性获取器和设置器，这使得我们能够像以前一样继续使用`person`实例。**获取器**是在我们访问属性进行读取时调用的方法。另一方面，**设置器**是在我们访问属性以写入它时调用的方法。'
- en: Unlike languages that use the getter/setter paradigm, Python allows us to start
    writing simple code and refactor later, only when we need it; there is no need
    to pollute the code with accessor methods only because they may be helpful in
    the future.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用获取器/设置器范式的语言不同，Python允许我们开始编写简单的代码，并在需要时进行重构，没有必要仅仅因为它们可能在将来有帮助而污染代码。
- en: The `property` decorator also allows read-only data (by not writing the setter
    counterpart) and for special actions when the attribute is deleted. Please refer
    to the official documentation to dig deeper.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`property` 装饰器还允许只读数据（通过不编写设置器对应部分）以及在删除属性时执行特殊操作。请参阅官方文档以深入了解。'
- en: The cached_property decorator
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`cached_property` 装饰器'
- en: One convenient use of properties is when we need to run some code to set up
    the object we want to use. For example, let us say we needed to connect to a database
    (or to an API).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的一个方便用途是在我们需要运行一些代码来设置我们想要使用的对象时。例如，让我们假设我们需要连接到数据库（或 API）。
- en: 'In both cases, we might have to set up a client object that knows how to talk
    to the database (or the API). It is quite common to use a property, in these cases,
    so that we can hide away the complexity of having to set the client up, and simply
    use it. Let us show you a simple example:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们可能需要设置一个知道如何与数据库（或 API）通信的客户端对象。在这些情况下，使用属性是很常见的，这样我们就可以隐藏设置客户端的复杂性，并简单地使用它。让我们给你一个简单的例子：
- en: '[PRE41]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding example, we have a dummy `Client` class, which prints the string
    `"Setting up the client…"` every time we create a new instance. It also has a
    pretend `query()` method that prints a string as well. We then have a class, `Manager`
    , which has a `client` property that creates a new instance of `Client` every
    time it is called (for example, by a call to `perform_query()` ).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们有一个虚拟的 `Client` 类，每次我们创建一个新的实例时，它都会打印出字符串 `"Setting up the client…"`。它还有一个模拟的
    `query()` 方法，也会打印出一个字符串。然后我们有一个名为 `Manager` 的类，它有一个 `client` 属性，每次被调用时（例如，通过调用
    `perform_query()`）都会创建一个新的 `Client` 实例。
- en: 'If we were to run this code, we would notice that every time we call `perform_query()`
    on the manager, we see the string `"Setting up the client…"` being printed. When
    creating a client is expensive, this code would be wasting resources, so it might
    be better to cache that client, like this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行此代码，我们会注意到每次我们在管理器上调用 `perform_query()` 时，都会看到打印出字符串 `"Setting up the
    client…"`。当创建客户端很昂贵时，这段代码会浪费资源，所以可能最好缓存那个客户端，如下所示：
- en: '[PRE42]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `ManualCacheManager` class is a bit smarter: the `client` property first
    checks if the attribute `_client` exists on the instance, by calling the built-in
    `hasattr()` function. If not, it assigns `_client` to a new instance of `Client`
    . Finally, it simply returns it. Repeatedly accessing the `client` property on
    this class will only create one instance of `Client` , the first time. From the
    second call on, `_client` is simply returned with no creation of new instances.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`ManualCacheManager` 类稍微聪明一点：`client` 属性首先通过调用内置的 `hasattr()` 函数检查实例上是否存在属性
    `_client`。如果不存在，它将 `_client` 分配给一个新的 `Client` 实例。最后，它简单地返回它。反复访问此类上的 `client`
    属性将只会创建一个 `Client` 实例，第一次调用时。从第二次调用开始，`_client` 将直接返回，而不会创建新的实例。'
- en: 'This is such a common need that, in Python 3.8, the `functools` module added
    the `cached_property` decorator. The beauty of using that, instead of our manual
    solution, is that if we need to refresh the client, we can simply delete the `client`
    property, and the next time we call it, it will recreate a brand new `Client`
    for us. Let us see an example:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个如此常见的需求，以至于在 Python 3.8 中，`functools` 模块添加了 `cached_property` 装饰器。使用它的美在于，与我们的手动解决方案相比，如果我们需要刷新客户端，我们可以简单地删除
    `client` 属性，下次调用它时，它将为我们重新创建一个全新的 `Client`。让我们看一个例子：
- en: '[PRE43]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Running this code gives the following result:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将得到以下结果：
- en: '[PRE44]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As you can see, it is only after we manually delete the `manager.client` attribute
    that we get a new one, when we invoke `manager.perform_query()` again.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，只有在我们手动删除 `manager.client` 属性后，当我们再次调用 `manager.perform_query()` 时，我们才会得到一个新的。
- en: Python 3.9 introduced a `cache` decorator, which can be used in conjunction
    with the `property` decorator, to cover scenarios for which `cached_property`
    is not suitable. As always, we encourage you to read up on all the details in
    the official Python documentation and experiment.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.9 引入了 `cache` 装饰器，它可以与 `property` 装饰器一起使用，以覆盖 `cached_property` 不适用的场景。一如既往，我们鼓励您阅读官方
    Python 文档中的所有详细信息并进行实验。
- en: Operator overloading
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运算符重载
- en: Python’s approach to **operator overloading** is brilliant. To overload an operator
    means giving it a meaning according to the context in which it is used. For example,
    the `+` operator means addition when we deal with numbers but concatenation when
    we deal with sequences.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Python 对 **运算符重载** 的处理方式非常出色。重载一个运算符意味着根据其使用的上下文给它赋予一个意义。例如，当我们处理数字时，`+` 运算符表示加法，但当我们处理序列时，它表示连接。
- en: When using operators, Python calls special methods behind the scenes. For example,
    the `a[k]` call on a dictionary roughly translates to `type(a).__getitem__(a,
    k)` . We can override these special methods for our purposes.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用运算符时，Python 在幕后调用特殊方法。例如，对字典的 `a[k]` 调用大致等同于 `type(a).__getitem__(a, k)`。我们可以为我们的目的覆盖这些特殊方法。
- en: 'As an example, let us create a class that stores a string and evaluates to
    `True` if `''42''` is part of that string, and `False` otherwise. Also, let us
    give the class a length property that corresponds to the length of the stored
    string:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们创建一个类，它存储一个字符串，如果该字符串包含 `'42'`，则评估为 `True`，否则为 `False`。此外，让我们给这个类一个长度属性，它与存储的字符串的长度相对应：
- en: '[PRE45]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: For the complete list of magic methods that you can override to provide your
    custom implementation of operators for your classes, please refer to the Python
    data model in the official documentation.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 有关您可以覆盖以提供您为类自定义运算符实现的完整方法列表，请参阅官方文档中的 Python 数据模型。
- en: Polymorphism—a brief overview
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态——简要概述
- en: The word **polymorphism** comes from the Greek *polys* (many, much) and *morphē*
    (form, shape), and its meaning is the provision of a single interface for entities
    of different types.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**多态**来自希腊语 *polys*（许多，多）和 *morphē*（形式，形状），其含义是为不同类型的实体提供单一接口。
- en: In our car example, we call `engine.start()` , regardless of what kind of engine
    it is. As long as it exposes the start method, we can call it. That’s polymorphism
    in action.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的汽车示例中，我们调用 `engine.start()`，无论它是哪种类型的引擎。只要它公开了启动方法，我们就可以调用它。这就是多态的实际应用。
- en: In other languages, such as Java, in order to give a function the ability to
    accept different types and call a method on them, those types need to be coded
    in such a way that they share an interface. In this way, the compiler knows that
    the method will be available regardless of the type of the object the function
    is fed (as long as it extends the specific interface, of course).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他语言中，例如 Java，为了使一个函数能够接受不同类型并在它们上调用方法，这些类型需要以这种方式编码，以便它们共享一个接口。这样，编译器就知道，无论函数传入的对象类型如何，该方法都将可用（当然，前提是它扩展了特定的接口）。
- en: In Python, things are different. Polymorphism is implicit, and nothing prevents
    you from calling a method of an object; therefore, technically, there is no need
    to implement interfaces or other patterns.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，情况不同。多态是隐式的，而且没有任何东西阻止您调用一个对象的方法；因此，从技术上讲，不需要实现接口或其他模式。
- en: There is a special kind of polymorphism called **ad hoc polymorphism** , which
    is what we saw in the last section on operator overloading. This is the ability
    of an operator to change shape according to the type of data it is applied to.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种特殊的多态称为**临时多态**，这是我们上一节在运算符重载中看到的。这是运算符根据应用到的数据类型改变形状的能力。
- en: Polymorphism also allows Python programmers to simply use the interface (methods
    and properties) exposed from an object, rather than having to check which class
    it was instantiated from. This allows the code to be more compact and feel more
    natural.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 多态还允许 Python 程序员简单地使用从对象中暴露的接口（方法和属性），而不是必须检查它是从哪个类实例化的。这使得代码更加紧凑，感觉更加自然。
- en: We cannot spend too much time on polymorphism, but we encourage you to check
    it out by yourself; it will expand your understanding of OOP.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能在多态上花费太多时间，但我们鼓励您自己检查它；这将扩展您对面向对象编程（OOP）的理解。
- en: Data classes
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据类
- en: 'Before we leave the OOP realm, there is one last thing we want to mention:
    **data classes** . Introduced in Python 3.7 by PEP 557 ( [https://peps.python.org/pep-0557/](https://peps.python.org/pep-0557/)
    ), they can be described as *mutable named tuples with defaults* . You can brush
    up on named tuples in *Chapter 2* , *Built-In Data Types* . Let us dive straight
    into an example:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开面向对象编程领域之前，我们还想提到最后一件事：**数据类**。由 PEP 557（[https://peps.python.org/pep-0557/](https://peps.python.org/pep-0557/)）在
    Python 3.7 中引入，它们可以被描述为*可变的命名元组，具有默认值*。您可以在*第 2 章*，*内置数据类型*中复习命名元组。让我们直接进入一个示例：
- en: '[PRE46]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the previous code, we created a class to represent a physical body, with
    one method that allows us to calculate its kinetic energy (using the formula *E*
    [k] *=½mv* ² ). Notice that `name` is supposed to be a string, while `mass` and
    `speed` are both floats, and both are given a default value. It is also interesting
    that we didn’t have to write any `__init__()` method; it is done for us by the
    `dataclass` decorator, along with methods for comparison and to produce the string
    representation of the object (implicitly called on the last line by `print` ).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们创建了一个类来表示一个物理体，其中有一个方法允许我们计算其动能（使用公式 *E* [k] *=½mv* ²）。请注意，`name`应该是一个字符串，而`mass`和`speed`都是浮点数，并且都指定了默认值。还有一点很有趣，我们不需要编写任何`__init__()`方法；这是由`dataclass`装饰器为我们完成的，包括比较方法和生成对象字符串表示的方法（在最后一行通过`print`隐式调用）。
- en: Another thing to notice is how `name` , `mass` , and `speed` are defined. This
    technique is called **type hinting** and will be the subject of *Chapter 12* ,
    *Introduction to Type Hinting* .
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要注意的是如何定义`name`、`mass`和`speed`。这种技术被称为**类型提示**，将在第12章*类型提示简介*中详细介绍。
- en: You can read all the specifications in PEP 557 if you are curious, but for now,
    just remember that data classes might offer a nicer, slightly more powerful alternative
    to named tuples, if you need it.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对PEP 557中的所有规范感兴趣，可以阅读，但就目前而言，只需记住，如果需要，数据类可能提供比命名元组更优雅、功能略强的替代方案。
- en: Writing a custom iterator
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自定义迭代器
- en: 'Now, we have all the tools to appreciate how we can write our own custom iterator.
    Let us first define what iterable and iterator mean:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经拥有了所有工具来欣赏我们如何编写自己的自定义迭代器。让我们首先定义可迭代和迭代器意味着什么：
- en: '**Iterable** : An object is said to be iterable if it can return its members
    one at a time. Lists, tuples, strings, and dictionaries are all iterables. Custom
    objects that define either of the `__iter__()` or `__getitem__()` methods are
    also iterables.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可迭代**：如果一个对象可以一次返回其成员，则称该对象为可迭代。列表、元组、字符串和字典都是可迭代的。定义了`__iter__()`或`__getitem__()`方法的自定义对象也是可迭代的。'
- en: '**Iterator** : An object is said to be an iterator if it represents a stream
    of data. A custom iterator is required to provide an implementation for the `__iter__()`
    method that returns the object itself, as well as an implementation for the `__next__()`
    method that returns the next item of the data stream until the stream is exhausted,
    at which point all successive calls to `__next__()` simply raise a `StopIteration`
    exception. Built-in functions, such as `iter()` and `next()` , are mapped to call
    the `__iter__()` and `__next__()` methods on an object, behind the scenes.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迭代器**：如果一个对象代表数据流，则称该对象为迭代器。需要自定义迭代器来提供`__iter__()`方法的实现，该方法返回对象本身，以及提供`__next__()`方法的实现，该方法返回数据流的下一个项目，直到流耗尽，此时所有后续对`__next__()`的调用将简单地引发`StopIteration`异常。内置函数，如`iter()`和`next()`，在幕后映射到调用对象的`__iter__()`和`__next__()`方法。'
- en: Exceptions will be the subject of *Chapter 7* , *Exceptions and Context Managers*
    . They can represent errors during code execution but are also used to regulate
    the flow of execution, and Python relies on them for mechanisms such as the iteration
    protocol.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 异常将是第7章*异常和上下文管理器*的主题。它们可以表示代码执行期间的错误，但也用于控制执行流程，Python依赖于它们来实现迭代协议等机制。
- en: 'Let us write an iterator that returns all the odd characters from a string
    first, and then the even ones:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个迭代器，首先返回字符串中的所有奇数字符，然后是偶数字符：
- en: '[PRE47]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: So, we provide an implementation for `__iter__()` that returns the object itself,
    and one for `__next__()` . Let us go through it. What needs to happen is the return
    of `_data[0]` , `_data[2]` , `_data[4]` , `...` , `_data[1]` , `_data[3]` , `_data[5]`
    , and so on until we have returned every item in the data. To do that, we prepare
    a list of indexes, such as [0, 2, 4, 6, ..., 1, 3, 5, ...], and while there is
    at least one element in the list, we pop the first one out and return the corresponding
    element from the data list, thereby achieving our goal. When `indexes` is empty,
    we raise `StopIteration` , as required by the iterator protocol.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们提供了一个`__iter__()`的实现，它返回对象本身，以及一个`__next__()`的实现。让我们来分析一下。需要发生的事情是返回`_data[0]`、`_data[2]`、`_data[4]`、`...`、`_data[1]`、`_data[3]`、`_data[5]`、等等，直到我们返回数据中的每个项目。为此，我们准备了一个索引列表，例如[0,
    2, 4, 6, ..., 1, 3, 5, ...]，当列表中至少有一个元素时，我们取出第一个元素并从数据列表中返回相应的元素，从而实现我们的目标。当`indexes`为空时，我们根据迭代器协议的要求引发`StopIteration`异常。
- en: There are other ways to achieve the same result, so go ahead and try to code
    a different one yourself. Make sure that the end result works for all edge cases,
    empty sequences, and sequences of lengths of 1, 2, and so on.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他方法可以达到相同的结果，所以请尝试自己编写不同的代码。确保最终结果适用于所有边缘情况、空序列以及长度为1、2等的序列。
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at decorators, discovered their purpose, and covered
    a few examples, using one or more at the same time. We also saw decorators that
    take arguments, which are usually used as decorator factories.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了装饰器，发现了它们的目的，并介绍了一些示例，使用一个或多个装饰器同时进行。我们还看到了接受参数的装饰器，这些装饰器通常用作装饰器工厂。
- en: We have scratched the surface of OOP in Python. We covered all the basics, so
    you should now be able to understand the code that will come in future chapters.
    We talked about all kinds of methods and attributes that you can write in a class;
    we explored inheritance versus composition, method overriding, properties, operator
    overloading, and polymorphism.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经触及了Python中面向对象编程（OOP）的表面。我们涵盖了所有基础知识，因此你现在应该能够理解未来章节中的代码。我们讨论了在类中可以编写的各种方法和属性；我们探讨了继承与组合、方法重写、属性、运算符重载和多态。
- en: Finally, we very briefly touched on iterators, which should enrich your understanding
    of generators.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们非常简要地提到了迭代器，这应该会丰富你对生成器的理解。
- en: In the next chapter, we are going to learn about exceptions and context managers.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将学习异常和上下文管理器。
- en: Join our community on Discord
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的Discord空间，与作者和其他读者进行讨论：
- en: '[https://discord.com/invite/uaKmaz7FEC](Chapter_6.xhtml)'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.com/invite/uaKmaz7FEC](Chapter_6.xhtml)'
- en: '![img](img/QR_Code119001106417026468.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/QR_Code119001106417026468.png)'
