- en: Building for Large-Scale Database Operations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建大规模数据库操作
- en: In the area of enterprise software development, developers have always built
    applications that deal with large amounts of data. In the early days of computing,
    systems used to span rooms bigger than the ones we currently live in, and data
    was stored in a flat file format, whereas today, systems have shrunk so much that
    in the same sized room that used to store a single system, we can now have thousands
    of systems running, each coordinating with the others, providing us with machines
    that can crunch data at the speed of light. Over time, the way data is stored
    has also evolved from using flat files to sophisticated database management systems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业软件开发领域，开发人员一直在构建处理大量数据的应用程序。在计算机的早期，系统通常跨越比我们目前居住的房间还要大的空间，数据存储在平面文件格式中，而今天，系统已经缩小到以前存放单个系统的相同大小的房间中，我们现在可以运行成千上万个系统，每个系统都与其他系统协调，为我们提供可以以光速处理数据的机器。随着时间的推移，数据存储的方式也从使用平面文件发展到了复杂的数据库管理系统。
- en: With enterprises growing in size and their ever-expanding operations due to
    emerging fields, the amount data that needs to be processed by enterprise applications
    is also growing, and this makes it important to understand how to build our applications
    to deal with large-scale database-related operations. Though building for large-scale
    database operations can never be a one-approach-fits-all solution, we'll cover
    some points that are common to building applications that can scale easily to
    handle the increase in data, the requirements of schema modification, increasing
    application complexity, and so on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着企业规模的增长和由新兴领域带来的不断扩大的业务，企业应用程序需要处理的数据量也在增长，这使得了解如何构建我们的应用程序以处理大规模数据库相关操作变得重要。虽然构建大规模数据库操作永远不可能是一种适合所有情况的解决方案，但我们将涵盖一些常见的构建应用程序的要点，这些应用程序可以轻松扩展以处理数据增加、模式修改的要求、应用程序复杂性的增加等。
- en: Although there are multiple types of databases, such as SQL, NoSQL, and Graph,
    that can be used to store application data, depending what kind of application
    is required by the enterprise, this chapter focuses on the use of relational database
    management systems using SQL, due to their vast popularity and their ability to
    handle a large amount of use cases.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有多种类型的数据库，如SQL、NoSQL和图形数据库，可以用来存储应用程序数据，取决于企业所需的应用程序类型，本章重点关注使用SQL的关系数据库管理系统，因为它们非常流行，并且能够处理大量的用例。
- en: 'By the end of this chapter, you will have learned about the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将学到以下内容：
- en: Using **Object Relational Mappers** (**ORMs**) and the benefits they provide
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**对象关系映射器**（**ORMs**）及其提供的好处
- en: Structuring database models for efficiency and ease of modification
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了提高效率和便于修改，构建数据库模型
- en: Focusing on maintaining database consistency
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专注于维护数据库一致性
- en: The differences between eager loading and lazy loading
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 急切加载和延迟加载之间的区别
- en: Taking advantage of caching to speed up queries
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用缓存加速查询
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code listings in this book can be found under `chapter03` directory at [https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python.](https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的代码清单可以在[https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python](https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python)的`chapter03`目录下找到
- en: 'The code samples can be cloned by running the following command:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过运行以下命令克隆代码示例：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The code samples provided in this chapter require you to have the following
    system packages installed and configured on their systems:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供的代码示例需要您在系统上安装和配置以下系统包：
- en: '`python-devel`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`python-devel`'
- en: PostgreSQL
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL
- en: Python – `virtualenv`
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python - `virtualenv`
- en: Beyond these three packages, you will also require the `sqlalchemy` package,
    which provides the ORM we will be using throughout the chapter, and `psycopg2`,
    which provides `postgres` database bindings to allow `sqlalchemy ...`
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这三个包，您还需要`sqlalchemy`包，它提供了我们在整个章节中将使用的ORM，以及`psycopg2`，它提供了`postgres`数据库绑定，以允许`sqlalchemy
    ...`
- en: Database and object relational mappers
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库和对象关系映射器
- en: As we discussed in the previous chapters, Python provides us with a lot of object-oriented
    capabilities, and allows us to map our use cases in terms of classes and objects.
    Now, when we can map our problem set into a class and its objects, why shouldn't
    we also map our database tables as objects, where a particular class represents
    a table, and its objects represent the rows in the table. Going down this route
    helps us to maintain not only the consistency of how we write our code, but also
    how we model our problem.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前几章中讨论的，Python为我们提供了许多面向对象的能力，并允许我们以类和对象的术语来映射我们的用例。现在，当我们可以将我们的问题集映射到一个类及其对象时，为什么我们不应该将我们的数据库表也映射为对象，其中一个特定的类代表一个表，它的对象代表表中的行。沿着这条路走，不仅有助于我们维护我们编写代码的一致性，还有助于我们建模我们的问题。
- en: The frameworks that provide the functionality through which we can map our databases
    to objects are known as ORMs and they help us to visualize our database as a set
    of classes and objects.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了通过它们可以将我们的数据库映射到对象的功能的框架被称为ORMs，它们帮助我们将我们的数据库可视化为一组类和对象。
- en: In the Python landscape, it is quite common to see ORMs. For example, a popular
    Python web framework, Django, provides its own ORM solution. Then, there is SQLAlchemy,
    which provides a fully-fledged ORM solution and database toolkit supporting a
    wide variety of relational databases.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python领域中，看到ORMs是非常常见的。例如，流行的Python Web框架Django提供了自己的ORM解决方案。然后，还有SQLAlchemy，它提供了一个完整的ORM解决方案和支持各种关系数据库的数据库工具包。
- en: 'But to convince developers to use ORM frameworks, there should be better advantages
    than merely saying that they are able to map your database into classes and objects,
    and provide you with an object-oriented interface to access the database. Let''s
    take a look at a few of the advantages the use of ORMs brings to the table:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，要说服开发人员使用ORM框架，应该有比仅仅说它们能够将数据库映射到类和对象，并为您提供面向对象的接口来访问数据库更好的优势。让我们看看ORM的使用带来了哪些优势：
- en: '**Abstraction from the vendor-specific SQL**: The relational database space
    is full of choices, with several companies marketing their products. Each of these
    products can have differences in how to achieve a certain functionality through
    the use of SQL. Sometimes, some of the databases may implement some SQL keywords
    that are not yet supported in other databases. For developers, this can become
    a problem if they need to support multiple databases with a disjointed set of
    functionality. Since ORMs already know how to deal with these differences in databases,
    they help the developer alleviate the problem of supporting multiple databases.
    Most of the time, when using an ORM, all the developer has to do is modify a database
    connection Uniform Resource Identifier (**URI**) and they are ready to work with
    a new database in their application.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象出特定供应商的SQL**：关系数据库领域充满了选择，有几家公司在推广他们的产品。这些产品中的每一个都可以在如何通过使用SQL实现某个功能上有所不同。有时，一些数据库可能实现了一些尚未在其他数据库中支持的SQL关键字。对于开发人员来说，如果他们需要支持具有不连贯功能集的多个数据库，这可能会成为一个问题。由于ORM已经知道如何处理这些数据库的差异，它们帮助开发人员减轻了支持多个数据库的问题。大多数情况下，使用ORM时，开发人员所需要做的就是修改数据库连接的统一资源标识符（URI），然后他们就可以准备在应用程序中使用新的数据库了。'
- en: '**Reduces the need for repetitive SQL**: When writing an application, there
    are quite a lot of places where the data needs to be retrieved from the same tables
    using similar queries. This will cause a lot of repetitive SQL being written in
    a lot of places, not only giving rise to quite a lot of poorly formatted code,
    but also opening doors for errors to creep in due to an improperly constructed
    SQL query (humans are quite vulnerable to losing their focus when doing repetitive
    work, so won''t this apply to developers also?). ORM solutions help by reducing
    the need for writing SQL to achieve the same results, by providing abstractions
    over SQL commands and generating SQL on the fly, based on how we call the different
    methods.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少重复SQL的需求**：在编写应用程序时，有很多地方需要使用类似的查询从相同的表中检索数据。这将导致很多重复的SQL代码被写入很多地方，不仅导致很多格式不佳的代码，还会因为SQL查询构造不当而导致错误的出现（人类在做重复工作时很容易失去注意力，开发人员也会这样吗？）。ORM解决方案通过提供对SQL命令的抽象和根据我们调用不同方法动态生成SQL来减少编写SQL以实现相同结果的需求。'
- en: '**Increased application maintainability**: Since ORMs allow you to define a
    database model once and reuse it throughout the application by instantiating the
    classes, it allows you to make changes in one place, which are then reflected
    across the whole application. This makes the task of maintaining the application
    a bit less tiresome, (at least the parts related to the handling of the database).'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增加应用程序的可维护性**：由于ORM允许您一次定义数据库模型并通过实例化类在整个应用程序中重用它，它允许您在一个地方进行更改，然后在整个应用程序中反映出来。这使得维护应用程序的任务变得稍微不那么繁琐（至少与处理数据库相关的部分）。'
- en: '**Increased productivity**: This in itself is not a feature but a side effect
    of the points mentioned previously. With the use of ORM solutions, developers
    are now a bit more relaxed about always thinking about SQL queries, or trying
    to follow a particular design pattern. They can now just focus on how to best
    architect their applications. This significantly improves developers'' productivity,
    and allows them to get more done and improve the utilization of their time.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高生产力**：这本身不是一个特性，而是前面提到的点的副作用。使用ORM解决方案，开发人员现在不再那么担心始终考虑SQL查询，或者试图遵循特定的设计模式。他们现在可以专注于如何最好地设计他们的应用程序。这显著提高了开发人员的生产力，并允许他们完成更多工作并提高时间的利用率。'
- en: In this chapter, we will focus on how we can utilize ORMs to best develop our
    enterprise applications so that they can easily interact with databases and handle
    large-scale database operations efficiently. For the sake of keeping the chapter
    simple, we will stick with the use of SQLAlchemy, which markets itself as an SQL
    toolkit, and an ORM solution for Python, and provides a lot of bindings for different
    frameworks in the Python landscape. It is being used by some quite large-scale
    projects, such as OpenStack, the Fedora Project, and Reddit.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将专注于如何利用ORM来最好地开发我们的企业应用程序，以便它们可以轻松地与数据库交互并高效地处理大规模的数据库操作。为了保持本章简单，我们将坚持使用SQLAlchemy，它将自己作为一个SQL工具包，并为Python提供了一个ORM解决方案，并为Python领域中的不同框架提供了许多绑定。它被一些相当大规模的项目使用，如OpenStack，Fedora项目和Reddit。
- en: Setting up SQLAlchemy
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置SQLAlchemy
- en: Before we dive into how to create optimal database models for your application
    to promote efficient large-scale database operations, we will first need to set
    up our ORM solution. Since we are going to use SQLAlchemy here, let's see how
    we can set it up in our development environment.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究如何为应用程序创建最佳的数据库模型以促进高效的大规模数据库操作之前，我们首先需要设置我们的ORM解决方案。由于我们将在这里使用SQLAlchemy，让我们看看如何在开发环境中设置它。
- en: 'For SQLAlchemy to work, you should have a database management system setup,
    either on your system or a remote machine, that you can connect to. A container
    with an exposed port will also get the work done for us. To keep the examples
    simple, we assume the reader is using PostgreSQL as their database solution here,
    and is knowledgeable about how the PostgreSQL setup works. Now, let''s see how
    we can set up SQLAlchemy:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使SQLAlchemy工作，你应该有一个数据库管理系统设置，可以是在你的系统上或远程机器上，你可以连接到它。一个暴露端口的容器也可以为我们完成工作。为了保持示例简单，我们假设读者在这里使用PostgreSQL作为他们的数据库解决方案，并且了解PostgreSQL设置的工作原理。现在，让我们看看如何设置SQLAlchemy：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Building optimal database models
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建最佳数据库模型
- en: The first step to achieve any efficient access to your database is to build
    an optimal model for your database. If a model is not optimal, the rest of the
    techniques to speed up access to the database will make very little difference.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 实现对数据库的任何有效访问的第一步是为数据库构建一个最佳模型。如果一个模型不是最佳的，那么加速对数据库的访问的其他技术将几乎没有什么区别。
- en: But before we dive into how we can build an optimal model for the database,
    let's first see how we can actually build any model for our database using SQLAlchemy.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们深入研究如何为数据库构建最佳模型之前，让我们首先看看如何实际使用SQLAlchemy为我们的数据库构建任何模型。
- en: 'For this example, let''s imagine we want to build a model to represent a user
    in our BugZot application. In our BugZot application, a user will be required
    to provide the following fields:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设我们想要构建一个模型来代表我们的BugZot应用程序中的用户。在我们的BugZot应用程序中，用户将需要提供以下字段：
- en: First name and last name
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名字和姓氏
- en: Username
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户名
- en: Email address
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子邮件地址
- en: Password
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码
- en: Additionally, our BugZot application also needs to maintain some more information
    about the user, such as their membership level in the system, the privileges the
    user is entitled to, whether the user account is active or not, and the activation
    key that is sent to the user to activate their account.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们的BugZot应用程序还需要维护有关用户的一些其他信息，例如他们在系统中的会员级别，用户有权利的特权，用户帐户是否处于活动状态，以及发送给用户激活他们帐户的激活密钥。
- en: 'Now, let''s see what happens if we try to model our user table with these requirements
    using SQLAlchemy. The following code depicts how we build a user model in SQLAlchemy:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如果我们尝试使用SQLAlchemy来满足这些要求建立用户表会发生什么。以下代码描述了我们如何在SQLAlchemy中构建用户模型：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This example shows how we can build a model using SQLAlchemy. Now, let's take
    a look at what we did in the code sample.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了我们如何使用SQLAlchemy构建模型。现在，让我们看看我们在代码示例中做了什么。
- en: In the starting part of the code sample, we first imported the `declarative_base`
    method that is responsible for providing the base class for our models.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码示例的开始部分，我们首先导入了`declarative_base`方法，该方法负责为我们的模型提供基类。
- en: The `Base = declarative_base()` line assigns the base model to our base variable.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`Base = declarative_base()`行将基本模型分配给我们的基本变量。'
- en: The next thing we did was to include the different datatypes from SQLAlchemy
    that we will be using in our definition of the model.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们做的事情是包括来自SQLAlchemy的不同数据类型，这些数据类型将在我们的模型定义中使用。
- en: The final import imports the Python `datetime` library that we will be using
    in our database model.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的导入导入了我们将在数据库模型中使用的Python `datetime`库。
- en: Now, without considering how our code will populate the different fields of
    the database model, let's take a look at how we designed our user model.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，不考虑我们的代码将如何填充数据库模型的不同字段，让我们看看我们是如何设计我们的用户模型的。
- en: The first step of designing the model was to define a class user that acts as
    our model class. This class derives from the base model that we initialized earlier
    in our code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模型的第一步是定义一个作为我们模型类的用户类。这个类派生自我们在代码中之前初始化的基本模型。
- en: The `__tablename__ = 'users'` line defines the name that should be given to
    the table when this database model is realized inside the database.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`__tablename__ = ''users''`行定义了当这个数据库模型在数据库中实现时应该给表的名称。'
- en: Following on from there, we start to define the columns our table will consist
    of. To define the column, we use a `key=value` type approach, where the key defines
    the name of the column, and the value defines the attributes of the column.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们开始定义表将包含的列。为了定义列，我们使用`key=value`的方式，其中key定义了列的名称，value定义了列的属性。
- en: 'For example, to define the column id, which should be of integer type and should
    act as a primary key for table users, we define it like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要定义id列，它应该是整数类型，并且应该作为用户表的主键，我们这样定义：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can now see how simple it is. We did not have to write any SQL to define
    our column. Similarly, it is quite easy to enforce that a particular field should
    have a unique value and cannot have null as a value by just passing `unique=True`
    and `nullable=False` parameters to the column constructor, as can be taken as
    an example from the following line:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看到它是多么简单。我们不需要编写任何SQL来定义我们的列。同样，通过只传递`unique=True`和`nullable=False`参数给列构造函数，就可以很容易地强制一个特定字段应该具有唯一值，并且不能有null值，可以从以下行作为例子：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After we have defined all the columns, we provide the definition for the `__repr__`
    method. The `__repr__` method is a magic method that is called by the internal
    `repr()` Python method to provide the representation of the object, such as when
    a user issues `print(userobj)`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义了所有的列之后，我们提供了`__repr__`方法的定义。`__repr__`方法是一个魔术方法，它由内部的`repr()`Python方法调用，以提供对象的表示，比如当用户发出`print(userobj)`时。
- en: This completes our definition of our user model using SQLAlchemy. It was simple,
    wasn't it? We did not have to write any SQL; we just quickly added the columns
    to a class and left everything else for SQLAlchemy to deal with. Now, while all
    of this was quite fun and easy to achieve, we made some mistakes, which doesn't
    seem to have caused any harm now, but will prove to be costly as our application
    scales up. Let's take a look at these mistakes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了我们使用SQLAlchemy定义用户模型的定义。很简单，不是吗？我们不需要编写任何SQL；我们只需快速地将列添加到一个类中，然后让SQLAlchemy处理其他所有事情。现在，虽然所有这些都很有趣且容易实现，但我们犯了一些错误，现在似乎没有造成任何伤害，但随着我们的应用规模扩大，这些错误将会变得代价高昂。让我们来看看这些错误。
- en: Issues with our model definition
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们模型定义的问题
- en: 'While SQLAlchemy provided us with a lot of abstraction to easily define our
    user model, it also makes it easy for us to make some mistakes, which can prove
    to be costly once the application use scales up and the enterprise grows. Let''s
    take a look at some of the mistakes that we have made while defining this model:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SQLAlchemy为我们提供了很多抽象来轻松定义用户模型，但它也让我们很容易犯一些错误，一旦应用规模扩大并且企业增长，这些错误就会变得代价高昂。让我们来看看我们在定义这个模型时犯了一些错误：
- en: '**Vulnerability to changes**: The current definition of our user model makes
    it very hard to make changes to the model once the application scales up. Let''s
    take the example of the organization deciding to provide users with more permissions
    on a bug report. In terms of SQL, to achieve the effect, we will need to write
    a query that will traverse through all the records and has `user_role` as the
    user ...'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易受变化影响**：我们当前的用户模型定义使得一旦应用规模扩大，对模型进行更改变得非常困难。让我们举个例子，假设组织决定在错误报告上为用户提供更多权限。在SQL方面，为了实现这个效果，我们需要编写一个查询，遍历所有记录并具有`user_role`作为用户...'
- en: Optimizing our models
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化我们的模型
- en: 'Before we discuss how to build optimal models, we first need to understand
    the characteristics that need to be present in an optimal model. Let''s take a
    look at the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论如何构建最佳模型之前，我们首先需要了解最佳模型应具备的特征。让我们来看看以下内容：
- en: '**Easy to adapt**: An optimal model should be easy to adapt according to the
    changing needs of the application as its user base grows. This means changing
    a particular model should not require changes all across the application, and
    should be high in cohesion.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于调整**：一个优化的模型应该根据应用程序不断增长的需求变化而容易调整。这意味着更改特定模型不应该需要在整个应用程序中进行更改，并且应该具有高内聚性。'
- en: '**Maximizes the throughput on a host**: Every host has a different architecture,
    and a data model should be able to exploit the underlying host resources in a
    manner that maximizes its throughput. This can be made possible by using the correct
    data storage engine for a particular architecture and use case, or running the
    database across a cluster of machines to increase the parallel execution capabilities.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大化主机吞吐量**：每个主机都有不同的架构，数据模型应该能够利用底层主机资源，以最大化吞吐量。这可以通过使用特定架构和用例的正确数据存储引擎，或者在一组机器上运行数据库以增加并行执行能力来实现。'
- en: '**Efficient storage**: A database model should also be considerate of the storage
    it may use as the data being stored inside it grows. This can be done by carefully
    choosing data types. For example, just to represent a column that can have only
    two values, true or false, an integer type would be overkill, wasting a lot of
    disk space, as the number of records in the database grows. A nominal data type
    for such a column could be Boolean, which doesn''t takes that much space internally.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高效存储**：数据库模型还应考虑到随着存储在其中的数据增长，可能使用的存储空间。这可以通过仔细选择数据类型来实现。例如，仅表示一个只能有两个值（true或false）的列，使用整数类型会浪费大量磁盘空间，随着数据库中记录的数量增加。对于这样的列，名义数据类型可以是布尔型，它在内部不占用太多空间。'
- en: '**Easy to tune**: An efficient model will carefully index the columns that
    can speed up the processing of queries against a particular table. This results
    in an improved response time for the database, and having happy users who don''t
    get frustrated because your application takes up to 20 minutes to return 10,000
    records from the database.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于调整**：一个高效的模型将谨慎地为可以加速对特定表的查询处理的列建立索引。这将导致数据库的响应时间得到改善，并且用户不会因为应用程序从数据库返回10,000条记录需要长达20分钟而感到沮丧。'
- en: To achieve these goals, we now need to simplify our models, and use the concept
    of relationships that relational databases provide. Let's now start re-factoring
    our user model to make it a bit more optimal.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这些目标，我们现在需要简化我们的模型，并使用关系数据库提供的关系概念。现在让我们开始重构我们的用户模型，使其更加优化。
- en: To achieve this, first we need to break it down from one large model to multiple
    small models, which live independently in our code base and don't have everything
    coupled so hard. Let's get started.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，首先我们需要将一个大模型分解为多个小模型，在我们的代码库中独立存在，并且不要将所有东西耦合得太紧。让我们开始吧。
- en: 'The first thing that we will move out of the model is how we deal with roles
    and permissions. Since roles and their permissions are not something that will
    differ too much from user to user (for sure not every user will have a unique
    role, and not every role can have a varying set of permissions), we can move these
    fields to a different model, known as permissions. The following code illustrates
    this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要移出模型的第一件事是如何处理角色和权限。由于角色及其权限不会在用户之间有太大的差异（肯定不是每个用户都会有一个唯一的角色，也不是每个角色都可以有不同的权限集），我们可以将这些字段移动到另一个模型，称为权限。以下代码说明了这一点：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, we have the roles decoupled from the user model. This makes it easy for
    us to make a modification to the provided roles without causing much of an issue.
    These modifications may include renaming a role or changing the permissions for
    an existing role. All we do is make a modification in a single place and it can
    be reflected for all the users that have the same role. Let's see how we can do
    this with the help of relations in **Relational Database Management System** (**RDBMS**)
    in our user model.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经将角色与用户模型解耦。这使我们可以轻松地对提供的角色进行修改，而不会引起太多问题。这些修改可能包括重命名角色或更改现有角色的权限。我们只需要在一个地方进行修改，就可以反映到所有具有相同角色的用户身上。让我们看看如何在我们的用户模型中利用**关系数据库管理系统**（**RDBMS**）中的关系来做到这一点。
- en: 'The following code example shows how to achieve the relation between the role
    model and the user model:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例显示了如何实现角色模型和用户模型之间的关系：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this code example, we modified the `user_role` to be an integer, and stored
    a value that is present in the `roles` model. Any attempt to insert a value into
    this field that is not present in the roles model will raise an SQL exception
    that the operation is not permitted.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，我们将`user_role`修改为整数，并存储在`roles`模型中存在的值。任何尝试向这个字段插入不在roles模型中的值的操作都会引发SQL异常，表示不允许该操作。
- en: 'Now, continuing with the same example, let''s think about the `activation_key`
    column of the user model. We might not need an activation key once the user has
    activated their account. This provides us with an opportunity to perform one more
    optimization in our user model. We can move this activation key out of the user
    model and store it in a separate model. Once the user has successfully activated
    their account, the record can be safely deleted without the risk of the user model
    being modified. So, let''s develop the model for the activation key. The following
    code sample illustrates what we want to do:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，继续使用同一个例子，让我们考虑用户模型的`activation_key`列。一旦用户激活了他们的账户，我们可能就不再需要激活密钥。这为我们提供了在用户模型中进行一次优化的机会。我们可以将这个激活密钥从用户模型中移出，并存储在一个单独的模型中。一旦用户成功激活了他们的账户，记录就可以被安全地删除，而不会有用户模型被修改的风险。因此，让我们开发激活密钥的模型。以下代码示例说明了我们想要做的事情：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, we implemented the `ActivationKey` model. Since every activation
    key belongs to a unique user, we need to store which user has which activation
    key. We achieve this by introducing a foreign key to the user model's `id` field.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们实现了`ActivationKey`模型。由于每个激活密钥都属于唯一的用户，我们需要存储哪个用户拥有哪个激活密钥。我们通过向用户模型的`id`字段引入外键来实现这一点。
- en: Now, we can safely remove the `activation_key` column from our user model without
    causing any trouble.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以安全地从用户模型中移除`activation_key`列，而不会引起任何麻烦。
- en: Taking advantage of indexes
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用索引
- en: Indexes are something that can provide a huge amount of performance advantages
    if done on fields that are good candidates for being indexed. But indexes can
    also prove to be of no use or can even harm database performance if the columns
    that are being indexed are not selected with care. For example, indexing every
    single column inside a table may not prove to be of any advantage and will unnecessarily
    eat up disk space, while also making database operations slow.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 索引是一种可以在适合建立索引的字段上提供大量性能优势的东西。但是，如果被索引的列没有经过慎重选择，索引也可能毫无用处，甚至会损害数据库的性能。例如，在表中索引每一列可能不会带来任何优势，而且会不必要地占用磁盘空间，同时使数据库操作变慢。
- en: So, before jumping into how to index a particular field using the ORM we have
    taken up as an example here, let's first clarify what exactly an index is in this
    context of databases, (without diving too deeply into how exactly they work),
    which data structure ...
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们以一个例子来介绍的ORM中如何对特定字段建立索引之前，让我们首先澄清在数据库上下文中索引到底是什么（不深入探讨它们的工作原理），这个数据结构...
- en: Maintaining database consistency
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持数据库一致性
- en: Databases usually have a lot of operations happening in parallel throughout
    the life of an application after it has been deployed. These operations can be
    as simple as retrieval of information from the database, or can be operations
    that modify the state of the database by inserting new records, updating existing
    ones, or deleting others. Most of the databases that are currently being used
    in production by large organizations have been built with quite a lot of resilience,
    in terms of dealing with errors and crashes that can happen in the environment
    to disturb the normal functioning of a database. These methods prevent the corruption
    of data and downtime.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库通常在应用程序部署后的整个生命周期中并行进行大量操作。这些操作可以是从数据库中检索信息，也可以是修改数据库状态的操作，比如插入新记录、更新现有记录或删除其他记录。目前大型组织生产中使用的大多数数据库都具有相当多的弹性，可以处理环境中可能发生的错误和崩溃，以防止数据损坏和停机。
- en: But this does not relieve the application developer completely of the fact that
    they still need to be careful about maintaining the consistency of the data inside
    the database. Let's try to understand this situation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不能完全解除应用程序开发人员对数据库内数据一致性的关注。让我们试着理解这种情况。
- en: In an enterprise-grade application, there will be a number of database queries
    running in parallel at any given point in time. These queries arise from the use
    of applications from a number of users or internal application maintenance jobs.
    One major fact or in this is that, not all of the queries can be successfully
    executed. This could be due to several reasons, such as data in the query not
    conforming to the schema, an incorrect data type being provided for a column value,
    and violations of constraints. When this happens, the database engine just blocks
    the query from executing and returns an error for the query. This is absolutely
    fine as our incorrect query didn't make any incorrect changes to the database.
    But the situation gets tricky when this query is part of a larger set of operations
    creating a new resource in the database. Now we need to make sure that the changes
    made by other queries before the failed query are reverted.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业级应用程序中，任何给定时间点都会有许多数据库查询并行运行。这些查询来自于许多用户使用的应用程序或内部应用程序维护作业。其中一个主要的事实是，并非所有的查询都能成功执行。这可能是由于多种原因，比如查询中的数据不符合模式，为列值提供了不正确的数据类型，以及违反约束。当这种情况发生时，数据库引擎会阻止查询执行并返回查询错误。这是完全可以接受的，因为我们不正确的查询没有对数据库进行任何不正确的更改。但是当这个查询是一系列操作的一部分，用于在数据库中创建一个新资源时，情况就变得棘手了。现在我们需要确保在失败的查询之前由其他查询所做的更改被恢复。
- en: This kind of behavior can still be fixed with some hard work by the developer
    of the application by tracking the SQL queries and reverting their changes manually
    when things go bananas in between.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为仍然可以通过应用程序的开发人员通过跟踪SQL查询并在事情变得混乱时手动恢复它们的更改来解决。
- en: But what if the database engine crashes due to an error in between, while one
    of the queries was executing. Now we are in a situation where we cannot predict
    the state of the database, and dealing with these kinds of situations can become
    really tiresome, and can be a task that halts the operations of the whole organization
    for a long time until database consistency is validated. So, what we can do? Is
    there some way through which we can prevent these types of issues from arising?
    The answer is a big yes. Let's take a look.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果数据库引擎由于执行查询时发生错误而崩溃。现在我们处于一个无法预测数据库状态的情况下，处理这种情况可能会变得非常繁琐，并且可能会成为一个长时间阻碍整个组织运营的任务，直到数据库一致性得到验证。那么，我们能做些什么？有没有办法可以防止这些问题的出现？答案是肯定的。让我们来看看。
- en: Utilizing transactions to maintain consistency
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用事务来维护一致性
- en: A transaction in a relational database provides us with the power to solve the
    issues that we have just discussed. In terms of a relational database, a transaction
    can be considered an envelope consisting of multiple database queries that are
    either executed as one task or are completely reverted if any of them fails. We
    can also consider a transaction an atomic unit in terms of database's operations,
    where even a single failure will revert the whole transaction. But, isn't this
    exactly what we require to solve the issue with our database consistency?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 关系数据库中的事务为我们提供了解决刚才讨论的问题的能力。在关系数据库方面，事务可以被认为是由多个数据库查询组成的信封，这些查询要么作为一个任务执行，要么在任何一个失败时完全恢复。我们还可以将事务视为数据库操作的原子单位，在这里，即使一个失败也会恢复整个事务。但是，这难道不正是我们需要解决数据库一致性问题的吗？
- en: Now, let's take a look at how our ORM solution can help us to implement transactional
    support.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的ORM解决方案如何帮助我们实现事务支持。
- en: To understand this, let's take an example. Our BugZot ...
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这一点，让我们举个例子。我们的BugZot...
- en: Understanding lazy loading versus eager loading
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解延迟加载与急切加载
- en: When we make a query to load the data from a database, there is a huge possibility
    that this operation might define the response time of the applications we build.
    This happens mainly when there is a lot of data that needs to be loaded and the
    application waits on the database to return all those rows and columns back to
    it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查询从数据库加载数据时，这个操作可能会定义我们构建的应用程序的响应时间。这主要发生在需要加载大量数据并且应用程序等待数据库将所有这些行和列返回给它时。
- en: Such operations may take some time, ranging from a few milliseconds to more
    than 10 seconds, depending on how much data is being queried from the database.
    The question here is, can we optimize this to improve the response times of our
    application?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的操作可能需要一些时间，从几毫秒到超过10秒，这取决于从数据库查询多少数据。这里的问题是，我们能否优化这一点以改善我们应用程序的响应时间？
- en: The answer to this lies in the use of SQL relationships and ORM layer loading
    techniques. While relationships can help us to define how the two models relate
    to each other, loading techniques define how relationships are retrieved by the
    ORM. When a lot of data needs to be loaded, this can prove to be of great help,
    by not only providing a mechanism through which we can defer the loading of data
    of the relationships until they are required, but by also saving quite a lot in
    terms of memory footprint of the application. So, let's take a look at these techniques.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的答案在于使用SQL关系和ORM层加载技术。虽然关系可以帮助我们定义两个模型之间的关系，加载技术定义了ORM如何检索关系。当需要加载大量数据时，这可以证明是非常有帮助的，不仅提供了一个机制，通过这个机制我们可以推迟加载关系数据直到需要它们，而且还可以在应用程序的内存占用方面节省相当多的空间。所以，让我们来看看这些技术。
- en: Using relationships
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用关系
- en: 'With relational database management systems in picture, we can now define how
    two models relate to each other. The databases support the modeling of different
    kinds of relationships between the two models, such as:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有了关系数据库管理系统的支持，我们现在可以定义两个模型之间的关系。数据库支持对两个模型之间不同类型的关系进行建模，例如：
- en: '**One to One Relationships**: These are the kind of relationships where a record
    from one model relates to only one record from another model. For example, a user
    in our user model has only one activation key mapped to it from our ActivationKey
    model. This is a one to one relationship.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一对一关系**：这是一种关系，其中一个模型的记录只与另一个模型的一个记录相关联。例如，我们的用户模型中的用户只有一个激活密钥与我们的ActivationKey模型相关联。这是一种一对一关系。'
- en: '**One to Many Relationships**: These are the kind of relationships where a
    record from one model maps to multiple records from another model. For example,
    if we have a model named Bug, describing the bug entries, then we can say, a user
    ...'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一对多关系**：这是一种关系，其中一个模型的记录映射到另一个模型的多个记录。例如，如果我们有一个描述bug条目的Bug模型，那么我们可以说，一个用户…'
- en: Lazy loading
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟加载
- en: A lot of ORM layers, as well as SQLAlchemy, try to make the effort to delay
    the loading of data for as long as possible. Usually, data is loaded only when
    the object is actually accessed by the application. This technique of delaying
    the loading of data until there is an attempt to access that data is known as
    lazy loading.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 许多ORM层以及SQLAlchemy都试图尽可能地延迟数据加载。通常情况下，只有在应用程序实际访问对象时才会加载数据。这种延迟加载数据直到尝试访问数据的技术被称为延迟加载。
- en: This technique is really helpful for reducing the response times of an application,
    since the entire data is not loaded in one go but is instead loaded on demand.
    This optimization comes at the expense of running a few more SQL queries, which
    will retrieve the actual data as the request is made. But is there some way we
    can have explicit control over this technique?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术对于减少应用程序的响应时间非常有帮助，因为整个数据不是一次性加载的，而是按需加载的。这种优化是以运行更多的SQL查询为代价的，这些查询将在请求时检索实际数据。但是有没有一种方法可以明确控制这种技术呢？
- en: The answer to this will differ for every ORM solution, but quite a lot of them
    actually allow you to enable or disable lazy loading behavior. So, how do we control
    this in SQLAlchemy?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个ORM解决方案，答案都会有所不同，但其中很多实际上允许您启用或禁用延迟加载行为。那么，在SQLAlchemy中如何控制这一点呢？
- en: 'Taking a look at the user model modification we made in the previous section,
    we can explicitly tell SQLAlchemy to lazy load the data from our role model by
    adding an extra attribute in our role field, as can be seen in the following snippet:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下我们在上一节中对用户模型的修改，我们可以通过在我们的角色字段中添加一个额外的属性来明确告诉SQLAlchemy从我们的角色模型中延迟加载数据，如下面的片段所示：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This extra `lazy_load` attribute defines the technique SQLAlchemy uses to load
    the data from our role model. The following example shows the flow of a request
    during a lazy load:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个额外的`lazy_load`属性定义了SQLAlchemy用来从我们的角色模型加载数据的技术。下面的例子展示了在延迟加载期间请求的流程：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we can see from this example, SQLAlchemy dosen't make an attempt to load
    the data of the role model until and unless we try to access it. As soon as we
    try accessing the data from the role model, SQLAlchemy makes a `SELECT` query
    to the database, fetches the results in the object, and returns the populated
    object, which we can use now.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中可以看出，SQLAlchemy在我们尝试访问角色模型的数据之前并不尝试加载角色模型的数据。一旦我们尝试访问角色模型的数据，SQLAlchemy就会向数据库发出`SELECT`查询，获取结果并返回填充的对象，然后我们现在可以使用它。
- en: In contrast to the technique of loading data on demand, we can also ask SQLAlchemy
    to load all the data as soon as the first request is made. This can save us waiting
    those few extra milliseconds that the application will wait until the ORM layer
    fetches the data on demand from the database.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与按需加载数据的技术相反，我们也可以要求SQLAlchemy在第一次请求时加载所有数据。这可以节省我们等待应用程序等待ORM层按需从数据库获取数据的几毫秒时间。
- en: This technique is called **eager loading**, as we will explain in the upcoming
    section.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术被称为**急切加载**，我们将在接下来的部分中解释。
- en: Eager loading
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 急切加载
- en: There are situations when we want the data of the object we want to be loaded
    along with the relationships our object maps to. This is a valid use case, such
    as when the developer is sure they will be accessing the data of the relationship,
    no matter the situation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们希望加载我们想要的对象的数据以及我们的对象映射到的关系的数据。这是一个有效的用例，比如当开发人员确信他们将访问关系的数据时，无论情况如何。
- en: In these kinds of use cases, there is no point wasting time while the ORM layers
    load the relationships on demand. This technique of loading the object data along
    with the data of the associated objects to which our main object is related is
    known as eager loading.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些用例中，没有必要浪费时间，而ORM层会按需加载关系。这种加载对象数据以及与我们的主对象相关的关联对象的数据的技术被称为急切加载。
- en: SQLAlchemy provides an easy way to achieve this behavior. Remember the `lazy_load`
    attribute we specified in the previous section? Yes, that's all you need to switch
    from lazy load behavior to eager load ...
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy提供了一种简单的方法来实现这种行为。还记得我们在上一节中指定的`lazy_load`属性吗？是的，这就是你需要从延迟加载行为切换到急切加载的全部内容…
- en: Optimizing data loading
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化数据加载
- en: One of the boosts that we can give to our application's performance is by optimizing
    the way it loads data from the database. This is not something that is complex
    to implement, and ORM solutions make it much simpler to get all of this up and
    running.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为应用程序的性能提供的一种提升是优化它从数据库加载数据的方式。这并不是一件复杂的事情，ORM解决方案使得这一切变得更加简单。
- en: 'Optimizing data loading just has a few rules. So, let''s take a look at what
    these are, and how they can prove to be advantageous:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 优化数据加载只有几条规则。因此，让我们看看这些规则是什么，以及它们如何能够证明有利：
- en: '**Defer the loading of data that can be skipped**: When we know that we won''t
    require all the data that we are fetching from the database, we can safely defer
    the loading of that data by utilizing the lazy loading technique. For example,
    if we wanted to send a mail to all those users of our BugZot application who have
    more then 10 bugs pending against them and who are not an administrator, we could
    just defer the loading of the role''s relationship.  Considering a big database
    with a lot of users, this can help to significantly reduce the response time of
    the application, as well as its overall memory footprint, at the expense of a
    few extra queries, which might be a desirable trade-off to make.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**推迟加载可以跳过的数据**：当我们知道我们不需要从数据库中获取的所有数据时，我们可以安全地推迟加载该数据，利用延迟加载技术。例如，如果我们想要向我们的BugZot应用程序的所有用户发送邮件，这些用户有超过10个未解决的bug，并且不是管理员，我们可以推迟加载角色的关系。考虑到一个有很多用户的大型数据库，这可以帮助显著减少应用程序的响应时间，以及整体内存占用，而只需付出一些额外的查询，这可能是一个可取的权衡。'
- en: '**Load data early if it is going to be used**: In complete contrast to the
    first point, if we know that the application will use data, no matter the situation,
    then it makes complete sense to load it in one shot rather than emitting extra
    queries to load data on demand. For example, if we wanted to promote all the administrators
    to super administrators, we know we will be accessing the role field of all the
    users. Then, it doesn''t makes sense to make the application lazy load the roles
    field. We can simply ask the application to eager load the required data so that
    the application doesn''t wait for the data to get loaded on demand. This type
    of optimization comes at the cost of increased memory usage and slow initial response
    times, but provides the advantage of fast execution, once all the data has been
    loaded.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如果数据将被使用，则尽早加载**：与第一点完全相反，如果我们知道应用程序将使用数据，无论情况如何，那么一次性加载它而不是发出额外的查询来按需加载数据是完全有道理的。例如，如果我们想要将所有管理员提升为超级管理员，我们知道我们将访问所有用户的角色字段。那么，让应用程序懒加载角色字段就没有意义。我们可以简单地要求应用程序急切地加载所需的数据，以便应用程序不必等待数据按需加载。这种优化会增加内存使用量和初始响应时间，但一旦所有数据加载完毕，就会提供快速执行的优势。'
- en: '**Do not load data that won''t be required**: There are times when some of
    the relationships an object maps to are not required at all during processing.
    In these kinds of situations, we can save a lot of memory and time by simply not
    loading those relationship objects at all. This can be fairly easily achieved
    in SQLAlchemy by simply setting `lazy_load=''noload''`. One example of such a
    use case is where loading of the relation is not required when all we want to
    do is to update the `last_active` time of the user in the database. In this case,
    we know that we are not required to validate anything related to the role of the
    user, and hence we can skip the loading of the role altogether.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不加载不需要的数据**：有时对象映射的一些关系在处理过程中根本不需要。在这种情况下，我们可以通过简单地设置`lazy_load=''noload''`来节省大量内存和时间，从而根本不加载这些关系对象。在SQLAlchemy中可以很容易地实现这一点。一个这样的用例是当我们只想要更新数据库中用户的`last_active`时间时，不需要加载关系。在这种情况下，我们知道我们不需要验证与用户角色相关的任何内容，因此我们可以完全跳过加载角色。'
- en: Achieving these effects clearly cannot be done if the loading technique is embedded
    in the model definition altogether. So, SQLAlchemy does provide another way to
    achieve these effects through the use of different methods, named, aptly, based
    on the technique they use to load the data from the database, for example, `lazyload()`
    for lazy loading, `joinedload()` for joined eager loading, `subqueryload()` for
    subquery eager loading, and `noload()` for no loading, which we will explain in
    later chapters, including how they can be used in a real application.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果加载技术完全嵌入在模型定义中，显然无法实现这些效果。因此，SQLAlchemy确实提供了另一种通过使用不同方法来实现这些效果的方式，这些方法根据它们从数据库加载数据的技术命名，例如，`lazyload()`用于延迟加载，`joinedload()`用于连接急切加载，`subqueryload()`用于子查询急切加载，`noload()`用于不加载，我们将在后面的章节中解释它们，包括它们如何在实际应用程序中使用。
- en: Now that we're familiar with loading techniques and how we can use them to our
    advantage, now let's take a look at one of the final topics of this chapter, where
    we will see how we can utilize caching to speed up our application response times,
    as well as saving the effort of querying our database again and again, which will
    indeed help us during times when the application is performing a lot of data-intensive
    operations.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们熟悉了加载技术以及如何利用它们的优势，现在让我们来看看本章的最后一个主题之一，我们将看到如何利用缓存来加快应用程序的响应时间，以及节省一遍又一遍地查询数据库的工作，这在应用程序执行大量数据密集型操作时确实会帮助我们。
- en: Utilizing caching
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用缓存
- en: In most enterprise applications, data that has been accessed once is used again
    and again. This could be in different requests, or could be because the requests
    are operating on the same set of data.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数企业应用程序中，一旦访问过的数据就会被再次使用。这可能是在不同的请求中，也可能是因为请求正在操作相同的数据集。
- en: In these kinds of scenarios, it would be a huge waste of resources if we tried
    to access the same data again and again from the database, causing the application
    to make a lot of queries to the database, resulting in high database loads and
    poor response times.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，如果我们试图一遍又一遍地从数据库中再次访问相同的数据，这将是一种巨大的资源浪费，导致应用程序向数据库发出大量查询，导致数据库负载高，响应时间差。
- en: The ORM layers we use provide some degree of caching to already accessed data,
    but still, most of the control resides in the hands of the application developer,
    who can use his wisdom to make the application performant by analyzing which data
    will be used again and again, ...
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的ORM层提供了一定程度的缓存以访问过的数据，但是，大部分控制权仍然掌握在应用程序开发人员手中，他可以通过分析哪些数据将一遍又一遍地使用来使应用程序性能良好。
- en: Caching at the database level
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在数据库级别进行缓存
- en: Databases are quite a complex piece of software. Not only do they store our
    data efficiently, they provide us with mechanisms to retrieve that data with the
    same efficiency as well. This involves quite a lot of complex logic going on behind
    the scenes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库是相当复杂的软件。它们不仅能够高效地存储我们的数据，还能够以同样的效率提供检索数据的机制。这背后涉及了许多复杂的逻辑。
- en: One of the advantages of using an ORM is the caching the database can perform
    at the query level. Since databases are supposed to return data in the fastest
    manner possible, database systems usually cache queries that are performed again
    and again. This caching happens at the query parsing level so that some time can
    be saved by not parsing the same query again and again when it is done on the
    database.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ORM的优势之一是数据库可以在查询级别执行缓存。由于数据库应该以最快的方式返回数据，数据库系统通常会缓存反复执行的查询。这种缓存发生在查询解析级别，因此当在数据库上执行相同的查询时，可以通过不再解析相同的查询来节省一些时间。
- en: This kind of caching boosts response times since quite a lot of effort is saved
    parsing queries.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这种缓存可以提高响应时间，因为保存了大量解析查询的工作。
- en: Caching at the block level
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 块级缓存
- en: Now, let's take a look at the kind of caching we can use at the application
    level, which can prove to be a major help.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下我们可以在应用程序级别使用的缓存类型，这可能会提供重要帮助。
- en: 'To understand the concept of caching at the application block level, let''s
    take a look at the following simple code snippet:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解应用程序块级缓存的概念，让我们看一下以下简单的代码片段：
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'From what we can assume, this could have done a query once and then retrieved
    the data from the database, and then will have used it again and again to compare
    it with the name variable. But let''s take a look at the output of the preceding
    code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们可以假设的情况来看，这可能已经查询了一次，然后从数据库中检索了数据，然后将一遍又一遍地使用它来与名称变量进行比较。但让我们来看一下前面代码的输出：
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using user-level caching
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用用户级缓存
- en: User-level caching is another level of caching that can prove to be of quite
    a lot of use. Imagine querying the personal details of the user from the database
    every time the user moves from one page to another. This would not only be inefficient,
    but would also penalize during high-load situations, when the response times of
    the database could be so high that a request could just time out and the user
    would not be able to log in to the application until the overall load reduced.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 用户级缓存是另一种可以证明非常有用的缓存级别。想象一下，每次用户从一个页面移动到另一个页面时都从数据库查询用户的个人详细信息。这不仅效率低下，而且在高负载情况下会受到惩罚，当数据库的响应时间非常高时，请求可能会超时，用户将无法登录到应用程序，直到整体负载减少。
- en: So, is there anything that can help here?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，有什么可以在这里帮助的吗？
- en: The answer to this is user-level caching. When we know that some data is specific
    to the user and is not critical to security, we can simply load it once from the
    database and save it on the user side. This can be achieved by implementing cookies
    or creating temporary files on the client side. These cookies or temporary files
    store non-confidential data about the user, such as user ID or username, or other
    non-important data, such as the name of the user.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是用户级缓存。当我们知道某些数据是特定于用户且对安全性不重要时，我们可以简单地从数据库中加载一次并将其保存在用户端。这可以通过实现cookie或在客户端创建临时文件来实现。这些cookie或临时文件存储有关用户的非机密数据，例如用户ID或用户名，或其他不重要的数据，例如用户的姓名。
- en: Whenever the application wants to load this data, instead of going to the database
    directly, it first checks whether the user has this data available at their end.
    If the data is found, then the data is loaded from there. If the data is not found
    on the user side, the request is made to the database, and the data is loaded
    from there, before being finally cached on the client side.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 每当应用程序想要加载这些数据时，它首先检查用户是否在其端有这些数据可用。如果找到数据，则从那里加载数据。如果在用户端找不到数据，则向数据库发出请求，然后从那里加载数据，最后在客户端缓存。
- en: This kind of technique helps a lot when trying to reduce the impact of data
    loading that is specific to users and does not need to be refreshed from the database
    frequently.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术在试图减少特定于用户的数据加载的影响时非常有帮助，并且不需要经常从数据库刷新。
- en: There are much more sophisticated techniques for caching data by using key-value
    caching mechanisms, as we will see in later chapters, such as implementing in-memory
    caches using tools such as memcached, which can prove to be of great help when
    dealing with huge amounts of data. However, this is beyond the scope of this book,
    due to the complexity of the topics involved, which can span several hundreds
    of pages.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用键值缓存机制，还有更复杂的缓存数据的技术，我们将在后面的章节中看到，比如使用诸如memcached之类的工具来实现内存缓存，这在处理大量数据时可能会非常有帮助。然而，由于涉及的主题复杂性可能涵盖数百页，这超出了本书的范围。
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about how to build database models that can help
    us make our application performant when dealing with data on a large scale. We
    saw how optimizing a model can be the first stage of optimization, and how it
    can help us make our application more maintenance-friendly, by reducing coupling
    across database models. We then moved on to cover how indexes can be useful for
    making accessing data inside the database faster, by indexing columns that are
    more frequently accessed.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何构建数据库模型，以帮助我们在处理大规模数据时使应用程序性能更高。我们看到优化模型可以是优化的第一阶段，它可以帮助我们使应用程序更易于维护，通过减少数据库模型之间的耦合。然后，我们继续讨论索引如何有助于通过对更频繁访问的列进行索引来加快访问数据库内部数据。
- en: We later covered one of the important aspects of maintaining the consistency
    of the database, through the use of transactions.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 后来，我们讨论了通过使用事务来维护数据库一致性的重要方面之一。
- en: The final part of the chapter covered data loading techniques, such as lazy
    loading, eager loading, and no loading, ...
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后部分涵盖了数据加载技术，如延迟加载、急切加载和无加载，…
- en: Questions
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the benefit of normalizing database tables?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库表规范化的好处是什么？
- en: What is the difference between lazy loading through `select` versus lazy loading
    through `joined`?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`select`和通过`joined`进行延迟加载有什么区别？
- en: How can we maintain the integrity of data while running database update queries?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行数据库更新查询时，我们如何保持数据的完整性？
- en: What are the different levels of caching data from a database?
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数据库缓存数据的不同级别是什么？
