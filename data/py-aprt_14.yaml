- en: Chapter 9 – Files and resource management
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9章-文件和资源管理
- en: Reading and writing files is a key part of what many real-world programs do.
    The notion of a *file*, however, is somewhat abstract. In some cases a file might
    mean collection of bytes on a hard disk; in others cases it might mean, for example,
    an HTTP resource on a remote system. These two entities share some behavior. For
    example, you can read a sequence of bytes from each. At the same time, they’re
    not identical. You can, for example, generally write bytes back to a local file
    while you can’t do that with HTTP resources.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 读写文件是许多现实世界程序的关键部分。然而，*文件*的概念有点抽象。在某些情况下，文件可能意味着硬盘上的一系列字节；在其他情况下，它可能意味着例如远程系统上的HTTP资源。这两个实体共享一些行为。例如，您可以从每个实体中读取一系列字节。同时，它们并不相同。例如，您通常可以将字节写回本地文件，而无法对HTTP资源进行这样的操作。
- en: In this chapter we’ll look at Python’s basic support for working with files.
    Since dealing with local files is both common and important, we’ll focus primarily
    on working with them. Be aware, though, that Python and its ecosystem of libraries
    provides similar *file-like* APIs for many other kinds of entities, including
    URI-based resources, databases, and many other sources of data. This use of a
    common API is very convenient and makes it easy to write code that can work against
    a wide range of data sources without change.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看一下Python对文件的基本支持。由于处理本地文件既常见又重要，我们将主要关注与它们一起工作。但请注意，Python及其库生态系统为许多其他类型的实体提供了类似*文件*的API，包括基于URI的资源、数据库和许多其他数据源。这种使用通用API非常方便，使得可以编写可以在各种数据源上工作而无需更改的代码变得容易。
- en: Also in this chapter we’ll look at *context managers*, one of Python’s primary
    means for managing resources. Context managers allow you to write code that is
    robust and predictable in the face of exceptions, ensuring that resources such
    as files are properly closed and accounted for when errors occur.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还将看一下*上下文管理器*，这是Python管理资源的主要手段之一。上下文管理器允许您编写在发生异常时健壮且可预测的代码，确保资源（如文件）在发生错误时被正确关闭和处理。
- en: Files
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件
- en: 'To open a local file in Python we call the built-in `open()` function. This
    takes a number of arguments, but the most commonly used are:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Python中打开本地文件，我们调用内置的`open()`函数。这需要一些参数，但最常用的是：
- en: '`file`: the path to the file. *This is required*.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file`：文件的路径。*这是必需的*。'
- en: '`mode`: read, write, append and binary or text. This is optional, but we recommend
    always specifying it for clarity. Explicit is better than implicit.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mode`：读取、写入、追加和二进制或文本。这是可选的，但我们建议始终明确指定以便清晰。显式优于隐式。'
- en: '`encoding`: If the file contains encoded text data, which encoding to use.
    It’s often a good idea to specify this. If you don’t specify it, Python will choose
    a default encoding for you.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`encoding`：如果文件包含编码的文本数据，要使用哪种编码。通常最好指定这一点。如果不指定，Python将为您选择默认编码。'
- en: Binary and text modes
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 二进制和文本模式
- en: At the filesytem level, of course, files contain only a series of bytes. Python,
    however, distinguishes between files opened in binary and text modes, even when
    the underlying operating system doesn’t. When you open a file in binary mode,
    you are instructing Python to use the data in the file without any decoding; binary
    mode file reflects the raw data in the file.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件系统级别，当然，文件只包含一系列字节。然而，Python区分以二进制和文本模式打开的文件，即使底层操作系统没有这样做。当您以二进制模式打开文件时，您正在指示Python使用文件中的数据而不进行任何解码；二进制模式文件反映了文件中的原始数据。
- en: A file opened in text mode, on the other hand, treats its contents as if it
    contains text strings of the `str` type. When you get data from a text mode file,
    Python first decodes the raw bytes using either a platform-dependent encoding
    or, if provided, the `encoding` argument to `open()` .
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，以文本模式打开的文件将其内容视为包含`str`类型的文本字符串。当您从文本模式文件中获取数据时，Python首先使用平台相关的编码或者`open()`的`encoding`参数对原始字节进行解码。
- en: By default, text mode files also engage support for Python’s *universal newlines*.
    This causes translation between a single portable newline character in our program
    strings (`'\n'`) and a platform dependent newline representation in the raw bytes
    stored in the file system (for example carriage-return-newline (`'\r\n'`) on Windows).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，文本模式文件还支持Python的*通用换行符*。这会导致我们程序字符串中的单个可移植换行符(`'\n'`)与文件系统中存储的原始字节中的平台相关换行表示（例如Windows上的回车换行(`'\r\n'`)）之间的转换。
- en: The importance of encoding
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编码的重要性
- en: Getting the encoding right is *crucial* for correctly interpreting the contents
    of a text file, so we want to labor the point a bit. Python ^([24](chap21.xhtml#fn-detecting-encoding))
    can’t reliably determine the encoding of a text file, so it doesn’t try. Yet without
    knowing the encoding of a file, Python can’t properly manipulate the data in the
    file. That’s why it’s critical that you tell Python which encoding to use.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正确编码对于正确解释文本文件的内容至关重要，因此我们希望重点强调一下。Python^([24](chap21.xhtml#fn-detecting-encoding))无法可靠地确定文本文件的编码，因此不会尝试。然而，如果不知道文件的编码，Python就无法正确操作文件中的数据。这就是为什么告诉Python要使用哪种编码非常重要。
- en: 'If you don’t specify an encoding Python will use the default from `sys.getdefaultencoding()`.
    In our case, the default encoding is `''utf-8''`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不指定编码，Python将使用`sys.getdefaultencoding()`中的默认编码。在我们的情况下，默认编码是`'utf-8'`：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Always remember, though, that there’s no guarantee that the default encoding
    on your system is the same as the default encoding on another system with which
    you wish to exchange files. It’s better for all concerned to make a conscious
    decision about the text-to-bytes encoding by specifying it in your calls to `open()`.
    You can get a list of supported text encodings in the [Python documentation](https://docs.python.org/3/library/codecs.html#standard-encodings).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住，您的系统上的默认编码与您希望交换文件的另一个系统上的默认编码可能不同。最好是为了所有相关方都明确决定文本到字节的编码，通过在对`open()`的调用中指定它。您可以在[Python文档](https://docs.python.org/3/library/codecs.html#standard-encodings)中获取支持的文本编码列表。
- en: Opening a file for writing
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 打开文件进行写入
- en: 'Let’s start working with files by opening a file in *write* mode. We’ll be
    explicit about using the UTF-8 encoding, because we have no way of knowing what
    your default encoding is. We’ll also use keyword arguments to make things clearer
    still:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以*写入*模式打开文件来开始处理文件。我们将明确使用UTF-8编码，因为我们无法知道您的默认编码是什么。我们还将使用关键字参数使事情更加清晰：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first argument is the filename. The `mode` argument is a string containing
    letters with different meanings. In this case ‘w’ means *write* and ‘t’ means
    *text*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是文件名。`mode`参数是一个包含不同含义字母的字符串。在这种情况下，‘w’表示*写入*，‘t’表示*文本*。
- en: 'All mode strings should consist of one of *read*, *write* or *append* mode.
    This table lists the mode codes along with their meanings:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所有模式字符串应该由*读取*、*写入*或*追加*模式中的一个组成。此表列出了模式代码以及它们的含义：
- en: '| Code | Meaning |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 意义 |'
- en: '| --- | --- |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `r` | Open file for reading. The stream is positioned at the |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `r` | 以读取模式打开文件。流定位在 |'
- en: '|   | beginning of the file. This is the default. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '|   | 文件的开头。这是默认设置。 |'
- en: '| `r+` | Open for reading and writing. The stream is positioned at the |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `r+` | 用于读取和写入。流定位在 |'
- en: '|   | beginning of the file. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '|   | 文件的开头。 |'
- en: '| `w` | Truncate file to zero length or create file for writing. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `w` | 截断文件至零长度或创建文件以进行写入。 |'
- en: '|   | The stream is positioned at the beginning of the file. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '|   | 流定位在文件的开头。 |'
- en: '| `w+` | Open for reading and writing. The file is created if it does not |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `w+` | 用于读取和写入。如果文件不存在，则创建 |'
- en: '|   | exist, otherwise it is truncated. The stream is positioned at |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '|   | 存在，则截断。流定位在 |'
- en: '|   | the beginning of the file. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '|   | 文件的开头。 |'
- en: '| `a` | Open for writing. The file is created if it does not exist. The |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `a` | 用于写入。如果文件不存在，则创建 |'
- en: '|   | stream is positioned at the end of the file. Subsequent writes |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '|   | 流定位在文件的末尾。后续写入 |'
- en: '|   | to the file will always end up at the then current end of file, |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '|   | 文件的写入将始终结束在文件的当前末尾 |'
- en: '|   | irrespective of any intervening seeks or similar. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '|   | 无论有任何寻址或类似。 |'
- en: '| `a+` | Open for reading and writing. The file is created if it does not |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `a+` | 用于读取和写入。如果文件不存在，则创建文件 |'
- en: '|   | exist. The stream is positioned at the end of the file. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '|   | 存在。流定位在文件的末尾。 |'
- en: '|   | Subsequent writes to the file will always end up at the then |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '|   | 对文件的后续写入将始终结束在文件的当前末尾 |'
- en: '|   | current end of file, irrespective of any intervening seeks or |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '|   | 无论有任何寻址或 |'
- en: '|   | similar. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '|   | 类似。 |'
- en: 'One of the preceding should be combined with a selector from the next table
    for specifying *text* or *binary* mode:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的内容之一应与下表中的选择器结合使用，以指定*文本*或*二进制*模式：
- en: '| Code | Meaning |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 意义 |'
- en: '| --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `t` | File contents interpreted as encoded text strings. The bytes in |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `t` | 文件内容被解释为编码文本字符串。从文件中接受和返回 |'
- en: '|   | the file will be encoded and decoded according the to the |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '|   | 文件将根据指定的文本编码进行编码和解码，并进行通用换行符转换 |'
- en: '|   | specified text encoding, and universal newline translation will |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|   | 指定的文本编码，并且通用换行符转换将 |'
- en: '|   | be in effect (unless explicitly disabled). All methods which write |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '|   | 生效（除非明确禁用）。所有写入方法 |'
- en: '|   | and read data from the file accept and return `str` objects. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '|   | `str`对象。 |'
- en: '|   | *This is the default*. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '|   | *这是默认设置*。 |'
- en: '| `b` | File contents are treated as raw bytes. All methods which write |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `b` | 文件内容被视为原始字节。所有写入方法 |'
- en: '|   | and read data from the file accept and return `bytes` objects. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '|   | 从文件中接受和返回`bytes`对象。 |'
- en: Examples of typical mode strings might be `'wb'` for “write binary” or `'at'`
    for “append text”. Although both parts of the mode code support defaults, we recommend
    being explicit for the sake of readability.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 典型模式字符串的示例可能是`'wb'`表示“写入二进制”，或者`'at'`表示“追加文本”。虽然模式代码的两部分都支持默认设置，但为了可读性起见，我们建议明确指定。
- en: The exact type of the object returned by `open()` depends on how the file was
    opened. This is dynamic typing in action! For most purposes, however, the actual
    type returned by `open()` is unimportant. It is sufficient to know that the returned
    object is a *file-like object*, and as such we can expect it to support certain
    attributes and methods.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`open()`返回的对象的确切类型取决于文件的打开方式。这就是动态类型的作用！然而，对于大多数目的来说，`open()`返回的实际类型并不重要。知道返回的对象是*类似文件的对象*就足够了，因此我们可以期望它支持某些属性和方法。'
- en: Writing to files
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向文件写入
- en: We’ve shown previously how we can request `help()` for modules and methods and
    types, but in fact we can request help on instances too. This makes sense when
    you remember that *everything* is an object.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经展示了如何请求模块、方法和类型的`help()`，但实际上我们也可以请求实例的帮助。当你记住*一切*都是对象时，这是有意义的。
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Browsing through the help, we can see that `f` supports a method `write()`.
    Quit the help with ‘q’ and continue at the REPL.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览帮助文档，我们可以看到`f`支持`write()`方法。使用‘q’退出帮助，并在REPL中继续。
- en: 'Now let’s write some text to our file useing the `write()` method:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用`write()`方法向文件写入一些文本：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The call to `write()` returns the number of codepoints or characters written
    to the file. Let’s add a few more lines:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对`write()`的调用返回写入文件的代码点或字符数。让我们再添加几行：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You’ll notice that we’re explicitly including newlines in the text we write
    to the file. It’s the callers responsibility to provide newline characters where
    they are needed; Python does not provide a `writeline()` method.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们在写入文件时明确包括换行符。调用者有责任在需要时提供换行符；Python不提供`writeline()`方法。
- en: Closing files
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 关闭文件
- en: 'When we’ve finished writing, we should remember to close the file by calling
    the `close()` method:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成写入后，应该记得通过调用`close()`方法关闭文件：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that it’s only after we close the file that we can be certain that the
    data we’ve written becomes visible to external processes. Closing files is important!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，只有在关闭文件后，我们才能确保我们写入的数据对外部进程可见。关闭文件很重要！
- en: Also remember that you can no longer read from or write to a file after closing
    it. Attempts to do so will result in an exception.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，关闭文件后就不能再从文件中读取或写入。这样做会导致异常。
- en: The file outside of Python
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Python之外的文件
- en: 'If you now exit the REPL, and look in your filesystem you can see that you
    have indeed created a file. On Unix use the `ls` command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在退出REPL，并查看你的文件系统，你会看到你确实创建了一个文件。在Unix上使用`ls`命令：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You should see the `wasteland.txt` file with 78 bytes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到`wasteland.txt`文件大小为78字节。
- en: 'On Windows use `dir`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上使用`dir`：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this case you should see `wasteland.txt` with 79 bytes because Python’s universal
    newline behavior for files has translated the line ending to your platform’s native
    endings.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你应该看到`wasteland.txt`大小为79字节，因为Python对文件的通用换行行为已经将行尾转换为你平台的本地行尾。
- en: The number returned by the `write()` method is the number of codepoints (or
    characters) in the string passed to `write()`, *not* the number of bytes written
    to the file after encoding and universal newline translation. In general, when
    working with text files, you cannot sum the quantities returned by `write()` to
    determine the length of the file in bytes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`write()`方法返回的数字是传递给`write()`的字符串中的码点（或字符）的数量，而不是编码和通用换行符转换后写入文件的字节数。通常情况下，在处理文本文件时，你不能通过`write()`返回的数量之和来确定文件的字节长度。'
- en: Reading files
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 读取文件
- en: 'To read the file back we use `open()` again, but this time we pass `''rt''`,
    for *read-text*, as the mode:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取文件，我们再次使用`open()`，但这次我们以`'rt'`作为模式，表示*读取文本*：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we know how many bytes to read, or if we want to read the whole file, we
    can use `read()`. Looking back through our REPL we can see that the first write
    was 32 characters long, so let’s read that back with a call to the `read()` method:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道要读取多少字节，或者想要读取整个文件，我们可以使用`read()`。回顾我们的REPL，我们可以看到第一次写入是32个字符长，所以让我们用`read()`方法读取回来：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In text mode, the `read()` method accepts the number of *characters* to read
    from the file, not the number of bytes. The call returns the text and advances
    the file pointer to the end of what was read. Because we opened the file in text
    mode, the return type is `str`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本模式下，`read()`方法接受要从文件中读取的*字符*数，而不是字节数。调用返回文本并将文件指针移动到所读取内容的末尾。因为我们以文本模式打开文件，返回类型是`str`。
- en: 'To read *all* the remaining data in the file we can call `read()` without an
    argument:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取文件中*所有*剩余的数据，我们可以调用`read()`而不带参数：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This gives us parts of two lines in one string — note the newline character
    in the middle.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们一个字符串中的两行部分 —— 注意中间的换行符。
- en: 'At the end of the file, further calls to `read()` return an empty string:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件末尾，进一步调用`read()`会返回一个空字符串：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Normally when we have finished reading a file we would `close()` it. For the
    purposes of this exercise, though, we’ll keep the file open and use `seek()` with
    an argument of zero to move the file pointer back to the start of the file:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，当我们完成读取文件时，会使用`close()`关闭文件。不过，为了本练习的目的，我们将保持文件处于打开状态，并使用参数为零的`seek()`将文件指针移回文件的开头：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The return value of `seek()` is the new file pointer position.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`seek()`的返回值是新的文件指针位置。'
- en: Readline line by line
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 逐行读取
- en: 'Using `read()` for text is quite awkward, and thankfully Python provides better
    tools for reading text files line by line. The first of these is `readline()`
    function:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文本使用`read()`相当麻烦，幸运的是Python提供了更好的工具来逐行读取文本文件。其中第一个就是`readline()`函数：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Each call to `readline()` returns a single line of text. The returned lines
    are terminated by a single newline character, if there is one present in the file.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`readline()`都会返回一行文本。如果文件中存在换行符，返回的行将以单个换行符结尾。
- en: The last line here does not terminate with a newline because there is no newline
    sequence at the end of the file. You shouldn’t *rely* on the string returned by
    `readline()` being terminated by a newline. And remember that the universal newline
    support will have translated whatever the platform native newline sequence into
    `'\n'`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的最后一行没有以换行符结尾，因为文件末尾没有换行序列。你不应该*依赖*于`readline()`返回的字符串以换行符结尾。还要记住，通用换行符支持会将平台本地的换行序列转换为`'\n'`。
- en: 'Once we reach the end of the file further calls to `readline()` return an empty
    string:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们到达文件末尾，进一步调用`readline()`会返回一个空字符串：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Reading multiple lines at once
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 一次读取多行
- en: 'Let’s rewind our file pointer again and read our file in a different way:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次将文件指针倒回并以不同的方式读取文件：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Sometimes when we know we want to read every line in the file — and if we’re
    sure we have enough memory to do so — we can read all lines from the file into
    a list with the `readlines()` method:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当我们知道我们想要读取文件中的每一行时 —— 并且如果我们确信有足够的内存来这样做 —— 我们可以使用`readlines()`方法将文件中的所有行读入列表中：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is particularly useful if parsing the file involves hopping backwards and
    forwards between lines; it’s much easier to do this with a list of lines than
    with a file stream of characters.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果解析文件涉及在行之间来回跳转，这将特别有用；使用行列表比使用字符流更容易。
- en: 'This time, we’ll close the file before moving on:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，在继续之前我们会关闭文件：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Appending to files
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 追加到文件
- en: 'Sometimes we would like to append to an existing file, and we can do that by
    using the mode `''a''`. In with this mode, the file is opened for writing and
    the file pointer is moved to the end of any existing data. In this example we
    combine `''a''` with `''t''` to be explicit about using text mode:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们希望追加到现有文件中，我们可以通过使用模式`'a'`来实现。在这种模式下，文件被打开以进行写入，并且文件指针被移动到任何现有数据的末尾。在这个例子中，我们将`'a'`与`'t'`结合在一起，以明确使用文本模式：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Although there is no `writeline()` method in Python, there is a `writelines()`
    method which writes an iterable series of strings to the stream. If you want line
    endings on your strings *you must provide them yourself*. This may seem odd at
    first, but it preserves symmetry with `readlines()` whilst also giving us the
    flexibility for using `writelines()` to write any iterable series of strings to
    a file:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Python中没有`writeline()`方法，但有一个`writelines()`方法，它可以将可迭代的字符串系列写入流。如果您希望在字符串上有行结束符*，则必须自己提供。这乍一看可能有点奇怪，但它保持了与`readlines()`的对称性，同时也为我们使用`writelines()`将任何可迭代的字符串系列写入文件提供了灵活性：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice that only three lines are completed here — we say *completed* because
    the file we’re appending to did not itself end with a newline.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里只完成了三行——我们说*完成*，因为我们追加的文件本身没有以换行符结束。
- en: File objects as iterators
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 文件对象作为迭代器
- en: The culmination of these increasingly sophisticated text file reading tools
    is the fact that file objects support the *iterator* protocol. When you iterate
    over a file, each iteration yields the next line in the file. This means that
    they can be used in for-loops and any other place where an iterator can be used.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这些越来越复杂的文本文件读取工具的顶点在于文件对象支持*迭代器*协议。当您在文件上进行迭代时，每次迭代都会产生文件中的下一行。这意味着它们可以在for循环和任何其他可以使用迭代器的地方使用。
- en: 'At this point, we’ll take the opportunity to create a Python module file `files.py`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们有机会创建一个Python模块文件`files.py`：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can call this directly from the system command line, passing the name of
    our text file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接从系统命令行调用它，传递我们的文本文件的名称：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You’ll notice that there are empty lines between each line of the poem. This
    occurs because each line in the file is terminated by a new line, and then `print()`
    adds its own.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到诗歌的每一行之间都有空行。这是因为文件中的每一行都以换行符结尾，然后`print()`添加了自己的换行符。
- en: To fix that, we could use the `strip()` method to remove the whitespace from
    the end of each line prior to printing. Instead we’ll use the `write()` method
    of the `stdout` stream. This is *exactly* the same `write()` method we used to
    write to the file earlier — and can be used because the `stdout` stream is itself
    a file-like object.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以使用`strip()`方法在打印之前删除每行末尾的空白。相反，我们将使用`stdout`流的`write()`方法。这与我们之前用来写入文件的`write()`方法*完全*相同，因为`stdout`流本身就是一个类似文件的对象，所以可以使用它。
- en: 'We get hold of a reference to the `stdout` stream from the `sys` module:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`sys`模块中获得了对`stdout`流的引用：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If we re-run our program we get:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新运行我们的程序，我们会得到：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, alas, it’s time to move on from one of the most important poems of the
    twentieth century and get to grips with something *almost* as exciting, context
    managers.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，不幸的是，是时候离开二十世纪最重要的诗歌之一，开始着手处理*几乎*同样令人兴奋的东西，上下文管理器。
- en: Context managers
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上下文管理器
- en: 'For the next set of examples we’re going to need a data file containing some
    numbers. Using the code in `recaman.py` below, we’ll write a sequence of numbers
    called [Recaman’s sequence](http://mathworld.wolfram.com/RecamansSequence.html)
    to a text file, with one number per line:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于接下来的一组示例，我们将需要一个包含一些数字的数据文件。使用下面的`recaman.py`中的代码，我们将一个名为[Recaman序列](http://mathworld.wolfram.com/RecamansSequence.html)的数字序列写入文本文件，每行一个数字：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Recaman’s sequence itself isn’t important to this exercise; we just needed a
    way of generating numeric data. As such, we won’t be explaining the `sequence()`
    generator. Feel free to experiment though.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Recaman序列本身对这个练习并不重要；我们只需要一种生成数字数据的方法。因此，我们不会解释`sequence()`生成器。不过，随意进行实验。
- en: The module contains a generator for yielding the Recaman numbers and a function
    which writes the start of the sequence to file using the `writelines()` method.
    A generator expression is used to convert each number to a string and add a newline.
    `itertools.islice()` is used to truncate the otherwise infinite sequence.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块包含一个用于产生Recaman数的生成器，以及一个使用`writelines()`方法将序列的开头写入文件的函数。生成器表达式用于将每个数字转换为字符串并添加换行符。`itertools.islice()`用于截断否则无限的序列。
- en: 'We’ll write the first 1000 Recaman numbers to a file by executing the module,
    passing the filename and series length as command line arguments:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行模块，将文件名和序列长度作为命令行参数传递，我们将前1000个Recaman数写入文件：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now let’s make a complementary module `series.py` which reads this data file
    back in:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个补充模块`series.py`，它可以重新读取这个数据文件：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We read one line at a time from the open file, strip the newline with a call
    to the `strip()` string method, and convert it to an integer. If we run it from
    the command line, everything should work as expected:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从打开的文件中一次读取一行，使用`strip()`字符串方法去除换行符，并将其转换为整数。如果我们从命令行运行它，一切都应该如预期般工作：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now let’s deliberately create an exceptional situation. Open `recaman.dat`
    in a text editor and replace one of the numbers with something that isn’t an stringified
    integer:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们故意制造一个异常情况。在文本编辑器中打开`recaman.dat`，并用不是字符串化整数的内容替换其中一个数字：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Save the file, and re-run `series.py`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件，然后重新运行`series.py`：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `int()` constructor raises a `ValueError` when passed our new, invalid line.
    The exception is unhandled, and so the program terminates with stack trace.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当传递我们的新的无效行时，`int()`构造函数会引发`ValueError`。异常未处理，因此程序以堆栈跟踪终止。
- en: Managing resources with `finally`
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用`finally`管理资源
- en: One problem here is that our `f.close()` call was never executed.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个问题是我们的`f.close()`调用从未执行过。
- en: 'To fix that, we can insert a `try` .. `finally` block:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以插入一个`try`..`finally`块：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now the file will always be closed, even in the presence of exceptions. Making
    this change opens up the opportunity for another refactoring: we can replace the
    for-loop with a list comprehension and return this list directly:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在文件将始终关闭，即使存在异常。进行这种更改开启了另一种重构的机会：我们可以用列表推导来替换for循环，并直接返回这个列表：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Even in this situation `close()` will still be called; the `finally` block is
    called no matter how the `try` block is exited.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这种情况下，`close()`仍然会被调用；无论`try`块如何退出，`finally`块都会被调用。
- en: with-blocks
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: with-blocks
- en: 'Up to now our examples have all followed a pattern: `open()` a file, work with
    the file, `close()` the file. The `close()` is important because it informs the
    underlying operating system that you’re done working with the file. If you don’t
    close a file when you’re done with it, it’s possible to lose data. There may be
    pending writes buffered up which might not get written completely. Furthermore,
    if you’re opening lots of files, your system may run out of resources. Since we
    always want to pair every `open()` with a `close()`, we would like a mechanism
    that enforces the relationship even if we forget.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的例子都遵循一个模式：`open()`一个文件，处理文件，`close()`文件。`close()`很重要，因为它通知底层操作系统你已经完成了对文件的操作。如果你在完成文件操作后不关闭文件，可能会丢失数据。可能会有待写入的缓冲区，可能不会完全写入。此外，如果你打开了很多文件，你的系统可能会耗尽资源。由于我们总是希望每个`open()`都与一个`close()`配对，我们希望有一个机制，即使我们忘记了，也能强制执行这种关系。
- en: 'This need for resource clean up is common enough that Python implements a specific
    control flow structure called *with-blocks* to support it. With-blocks can be
    used with any object that supports the *context-manager* protocol, which includes
    the file-objects returned by `open()`. Exploiting the fact the the file object
    is a context-manager, our `read_series()` function can become:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这种资源清理的需求是很常见的，Python实现了一个特定的控制流结构，称为*with-blocks*来支持它。with-blocks可以与支持*上下文管理器*协议的任何对象一起使用，这包括`open()`返回的文件对象。利用文件对象是上下文管理器的事实，我们的`read_series()`函数可以变成：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We no longer need to call `close()` explicitly because the `with` construct
    will call it for us when execution exits the block, no matter how we exit the
    block.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要显式调用`close()`，因为`with`结构将在执行退出块时为我们调用它，无论我们如何退出块。
- en: 'Now we can go back and modify our Recaman series writing program to use a with-block,
    too, again removing the need for the explicit `close()`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以回去修改我们的Recaman系列写作程序，也使用一个with-block，再次消除了显式的`close()`的需要：
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '* * *'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Moment of zen
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 禅的时刻
- en: '![](images/m09----zen-beautiful-is-better-than-ugly.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](images/m09----zen-beautiful-is-better-than-ugly.png)'
- en: 'The with-block syntax looks like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: with-block的语法如下：
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This is so-called *syntactic sugar* for a much more complex arrangement of
    `try...except` and `try...finally` blocks:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为*语法糖*，用于更复杂的`try...except`和`try...finally`块的安排：
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ^([25](chap21.xhtml#fn-see-pep-343))
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ^([25](chap21.xhtml#fn-see-pep-343))
- en: Which do you prefer?
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你更喜欢哪个？
- en: Few of us would want our code to look this convoluted, but this is how it would
    need to look without the `with` statement. Sugar may not be good for your health,
    but it can be very healthy for your code!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们中很少有人希望我们的代码看起来如此复杂，但这就是没有`with`语句的情况下它需要看起来的样子。糖可能对你的健康不好，但对你的代码可能非常有益！
- en: '* * *'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Binary files
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二进制文件
- en: So far we’ve looked at text files, where we deal with the file contents as Unicode
    strings. There are many cases, however, where files contain data that is not encoded
    text. In these situations we need to be able to work with the exact bytes that
    are present in the file, without any intermediate encoding or decoding. This is
    what *binary mode* is for.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看过文本文件，其中我们将文件内容处理为Unicode字符串。然而，有许多情况下，文件包含的数据并不是编码文本。在这些情况下，我们需要能够直接处理文件中存在的确切字节，而不需要任何中间编码或解码。这就是*二进制模式*的用途。
- en: The BMP file format
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: BMP文件格式
- en: 'To demonstrate handling of binary files, we need an interesting binary data
    format. BMP is an image file format that contains Device Independent Bitmaps.
    It’s simple enough that we can make a BMP file writer from scratch. ^([26](chap21.xhtml#fn-bmp-details))
    Place the following code in a module called `bmp.py`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示处理二进制文件，我们需要一个有趣的二进制数据格式。BMP是一种包含设备无关位图的图像文件格式。它足够简单，我们可以从头开始制作一个BMP文件写入器。^([26](chap21.xhtml#fn-bmp-details))将以下代码放入一个名为`bmp.py`的模块中：
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This may look complex, but as you’ll see it’s relatively straightforward.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很复杂，但你会发现它相对简单。
- en: 'For simplicity’s sake, we have decided to deal only with 8-bit grayscale images.
    These have the nice property that they are one byte per pixel. The `write_grayscale()`
    function accepts two arguments: the filename and a collection of pixel values.
    As the docstring points out, this collection should be a sequence of sequences
    of integers. For example, a list of lists of `int` objects will do just fine.
    Furthermore:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们决定只处理8位灰度图像。这些图像有一个很好的特性，即每个像素一个字节。`write_grayscale()`函数接受两个参数：文件名和像素值的集合。正如文档字符串所指出的那样，这个集合应该是整数序列的序列。例如，一个`int`对象的列表列表就可以了。此外：
- en: Each `int` must be a pixel value from 0 to 255
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个`int`必须是从0到255的像素值
- en: Each inner list is a row of pixels from left to right
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个内部列表都是从左到右的像素行
- en: The outer list is a list of pixel rows, from top to bottom.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部列表是从上到下的像素行的列表。
- en: The first thing we do is figure out the size of the image by counting the number
    of rows (line 19) to give the height and the number of items in the zeroth row
    to get the width (line 20). We assume, but don’t check, that all rows have the
    same length (in production code that’s a check we would want to make).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是通过计算行数（第19行）来确定图像的大小，以给出高度，并计算零行中的项目数来获得宽度（第20行）。我们假设，但不检查，所有行的长度都相同（在生产代码中，这是我们想要进行检查的）。
- en: Next , we `open()` (line 22) the file for *write in binary* mode using the `'wb'`
    mode string. We don’t specify an encoding - that makes no sense for raw binary
    files.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`'wb'`模式字符串在*二进制写入*模式下`open()`（第22行）文件。我们不指定编码 - 这对于原始二进制文件没有意义。
- en: Inside the with-block we start writing what is called the ‘BMP Header’ which
    begins the BMP format.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在with块内，我们开始编写所谓的“BMP头”，这是BMP格式的开始。
- en: The header must start with a so-called “magic” byte sequence `b'BM'` to identify
    it as a BMP file. We use the `write()` method (line 24), and, because the file
    was opened in binary mode, we must pass a `bytes` object.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 头部必须以所谓的“魔术”字节序列`b'BM'`开头，以识别它为BMP文件。我们使用`write()`方法（第24行），因为文件是以二进制模式打开的，所以我们必须传递一个`bytes`对象。
- en: 'The next four bytes should hold a 32-bit integer containing the file size,
    a value that we don’t yet know. We could have computed it in advance, but instead
    we’ll take a different approach: we’ll write a placeholder value then return to
    this point later to fill in the details. To be able to come back to this point
    we use the `tell()` method of the file object (line 28); this gives us the file
    poiner’s offset from the beginning of the file. We’ll store this offset in a variable
    which will act as a sort of bookmark. We write four zero-bytes as the placeholder
    (line 29), using escaping syntax to specify the zeros.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的四个字节应该包含一个32位整数，其中包含文件大小，这是我们目前还不知道的值。我们本可以提前计算它，但我们将采取不同的方法：我们将写入一个占位符值，然后返回到这一点以填写细节。为了能够回到这一点，我们使用文件对象的`tell()`方法（第28行）；这给了我们文件指针从文件开头的偏移量。我们将把这个偏移量存储在一个变量中，它将充当一种书签。我们写入四个零字节作为占位符（第29行），使用转义语法来指定这些零。
- en: The next two pairs of bytes are unused, so we just write zero bytes to them
    too (lines 32 and 33).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两对字节是未使用的，所以我们也将零字节写入它们（第32和33行）。
- en: The next four bytes are for another 32-bit integer which should contain the
    offset in bytes from the beginning of the file to the start of the pixel data.
    We don’t know that value yet either, so we’ll store another bookmark using `tell()`
    (line 37) and write another four byte placeholder (line 38); we’ll return here
    shortly when we know more.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的四个字节是另一个32位整数，应该包含从文件开头到像素数据开始的偏移量（以字节为单位）。我们也不知道这个值，所以我们将使用`tell()`（第37行）存储另一个书签，并写入另外四个字节的占位符（第38行）；当我们知道更多信息时，我们将很快返回到这里。
- en: The next section is called the ‘Image Header’. The first thing we have to do
    is write the length of the image header as a 32-bit integer (line 41). In our
    case the header will always be 40 bytes long. We just hardwire that in hexadecimal.
    Notice that the BMP format is little-endian - the least significant byte is written
    first.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分称为“图像头”。我们首先要做的是将图像头的长度写入一个32位整数（第41行）。在我们的情况下，头部总是40个字节长。我们只需将其硬编码为十六进制。注意BMP格式是小端序的
    - 最不重要的字节先写入。
- en: The next four bytes are the image width as a little-endian 32-bit integer. We
    call a module scope implementation detail function here called `_int32_to_bytes()`
    which converts an `int` object into a `bytes` object containing exactly four bytes
    (line 42). We then use the same function again to deal with the image height (line
    43).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的四个字节是图像宽度，作为小端序的32位整数。我们在这里调用一个模块范围的实现细节函数，名为`_int32_to_bytes()`，它将一个`int`对象转换为一个包含恰好四个字节的`bytes`对象（第42行）。然后我们再次使用相同的函数来处理图像高度（第43行）。
- en: The remainder of the header is essentially fixed for 8-bit grayscale images
    and the details aren’t important here, except to note that the whole header does
    in fact total 40 bytes (line 45).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 头部的其余部分对于8位灰度图像基本上是固定的，这里的细节并不重要，除了要注意整个头部实际上总共是40个字节（第45行）。
- en: Each pixel in an 8-bit BMP image is an index into a color table with 256 entries.
    Each entry is a four-byte BGR color. For grayscale images we need to write 256
    4-byte gray values on a linear scale (line 54). This snippet is fertile ground
    for experimentation, and an natural enhancement to this function would be to be
    able to supply this palette separately as an optional function argument.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 8位BMP图像中的每个像素都是颜色表中256个条目的索引。每个条目都是一个四字节的BGR颜色。对于灰度图像，我们需要按线性比例写入256个4字节的灰度值（第54行）。这段代码是实验的肥沃土壤，这个函数的一个自然增强功能将是能够单独提供这个调色板作为可选的函数参数。
- en: At last, we’re ready to write the pixel data, but before we do we make a note
    of the current file pointer offset using `tell()` (line 59) as this was one of
    the locations we need to go back and fill in later.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们准备写入像素数据，但在这之前，我们要使用`tell()`（第59行）方法记录当前文件指针的偏移量，因为这是我们需要稍后返回并填写的位置之一。
- en: Writing the pixel data itself is straightforward enough. We use the `reversed()`
    built-in function (line 60) to flip the order of the rows; BMP images are written
    bottom to top. For each row we pass the iterable series of integers to the `bytes()`
    constructor (line 61). If any of the integers are out of the range 0–255, the
    constructor will raise a `ValueError`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 写入像素数据本身是相当简单的。我们使用内置函数`reversed()`（第60行）来翻转行的顺序；BMP图像是从底部向顶部写入的。对于每一行，我们将整数的可迭代系列传递给`bytes()`构造函数（第61行）。如果任何整数超出了0-255的范围，构造函数将引发`ValueError`。
- en: Each row of pixel data in a BMP file must be a multiple of four bytes long,
    irrespective of image width. To do this (line 63), we take the row length modulus
    four, to give a number between zero and three inclusive, which is the the number
    of bytes over the *previous* four-byte boundary the end of our row falls. To get
    the number of padding bytes required to take us up to the *next* four byte boundary
    we subtract this modulus value from four to give a value of 4 to 1 inclusive.
    However, we never want to pad with four bytes, only with one, two or three, so
    we must take modulus four again, to convert the four byte padding to zero byte
    padding.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: BMP文件中的每一行像素数据必须是四个字节的整数倍长，与图像宽度无关。为了做到这一点（第63行），我们取行长度模四，得到一个介于零和三之间的数字，这是我们行末尾距离*前一个*四字节边界的字节数。为了得到填充字节数，使我们达到*下一个*四字节边界，我们从四中减去这个模数值，得到一个介于4到1之间的值。然而，我们永远不希望用四个字节填充，只用一、二或三个，所以我们必须再次取模四，将四字节填充转换为零字节填充。
- en: This value is used with the repetition operator applied to a single zero-byte
    to produce a bytes object containing zero, one, two or three bytes. We write this
    to the file, to terminate each row (line 65).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值与重复操作符应用于单个零字节一起使用，以产生一个包含零、一个、两个或三个字节的字节对象。我们将这些写入文件，以终止每一行（第65行）。
- en: After the pixel data we are at the end of the file. We undertook to record this
    offset value earlier, so we record the current position using `tell()` (line 68)
    into an end-of-file bookmark variable.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在像素数据之后，我们已经到达了文件的末尾。我们之前承诺记录了这个偏移值，所以我们使用`tell()`（第68行）将当前位置记录到一个文件末尾书签变量中。
- en: Now we can return and fulfil our promises by replacing the placeholder offsets
    we recorded with the real thing. First, the file length. To do this we `seek()`
    (line 71) back to the `size_bookmark` we remembered back near the beginning of
    the file and `write()` (line 72) the size stored in `eof_bookmark` as a little-endian
    32-bit integer using our `_int32_to_bytes()` function.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以回来实现我们的承诺，通过用我们记录的真实偏移量替换占位符。首先是文件长度。为此，我们`seek()`（第71行）回到我们在文件开头附近记住的`size_bookmark`，并使用我们的`_int32_to_bytes()`函数将存储在`eof_bookmark`中的大小作为小端32位整数`write()`（第72行）。
- en: Finally, we `seek()` (line 75) to the pixel data offset placeholder bookmarked
    by `pixel_offset_bookmark` and write the 32-bit integer stored in `pixel_data_bookmark`
    (line 76).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们`seek()`（第75行）到由`pixel_offset_bookmark`标记的像素数据偏移量的位置，并将存储在`pixel_data_bookmark`中的32位整数（第76行）写入。
- en: As we exit the with-block we can rest assured that the context manager will
    close the file and commit any buffered writes to the file system.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们退出with块时，我们可以放心，上下文管理器将关闭文件并将任何缓冲写入文件系统。
- en: Bitwise operators
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 位运算符
- en: 'Dealing with binary files often requires pulling apart or assembling data at
    the byte level. This is exactly what our `_int32_to_bytes()` function is doing.
    We’ll take a quick look at it because it shows some features of Python we haven’t
    seen before:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 处理二进制文件通常需要在字节级别拆分或组装数据。这正是我们的`_int32_to_bytes()`函数在做的事情。我们将快速查看它，因为它展示了一些我们以前没有见过的Python特性：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The function uses the `>>` (*bitwise-shift*) and `&` (*bitwise-and*) operators
    to extract individual bytes from the integer value. Note that bitwise-and uses
    the ampersand symbol to distinguish it from *logical-and* which is the spelled
    out word “and”. The `>>` operator shifts the binary representation of the integer
    right by the specified number of bits. The routine shifts the integer argument
    one, two, and three bytes to the right before extracting the least significant
    byte with `&` after each shift. The four resulting integers are used to construct
    a tuple which is then passed to the `bytes()` constructor to produce a four byte
    sequence.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数使用`>>`（*位移*）和`&`（*按位与*）运算符从整数值中提取单个字节。请注意，按位与使用和符号来区分它与*逻辑与*，后者是拼写出来的单词“and”。`>>`运算符将整数的二进制表示向右移动指定的位数。该例程在每次移位后使用`&`提取最低有效字节。得到的四个整数用于构造一个元组，然后传递给`bytes()`构造函数以产生一个四字节序列。
- en: Writing a BMP file
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 写一个BMP文件
- en: 'In order to generate a BMP image file, we’re going to need some pixel data.
    We’ve included a simple module `fractal.py` which produces pixel values for the
    iconic [Mandelbrot set fractal](https://en.wikipedia.org/wiki/Mandelbrot_set).
    We’re not going to explain the fractal generation code in detail, still less the
    math behind it. But the code is simple enough, and it doesn’t rely on any Python
    features we haven’t encountered previously:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成一个BMP图像文件，我们需要一些像素数据。我们包含了一个简单的模块`fractal.py`，它为标志性的[Mandelbrot集合分形](https://en.wikipedia.org/wiki/Mandelbrot_set)生成像素值。我们不打算详细解释分形生成代码，更不用说背后的数学。但这段代码足够简单，而且不依赖于我们以前遇到的任何Python特性：
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The key takeaway is that the `mandelbrot()` function uses nested list comprehensions
    to produce a list of lists of integers in the range 0–255\. This list of lists
    represents an image of the fractal. The integer value for each point is produced
    by the `mandel()` function.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是`mandelbrot()`函数使用嵌套的列表推导来生成一个范围在0-255的整数列表的列表。这个列表代表了分形的图像。每个点的整数值是由`mandel()`函数产生的。
- en: Generating fractal images
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 生成分形图像
- en: 'Let’s fire up a REPL and use the `fractal` and `bmp` modules together. First
    we use the `mandelbrot()` function to product an image of 448 by 256 pixels. You’ll
    get best results using images with an aspect ratio of 7:4:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动一个REPL，并将`fractal`和`bmp`模块一起使用。首先，我们使用`mandelbrot()`函数生成一个448x256像素的图像。使用长宽比为7:4的图像会获得最佳结果：
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This call to `mandelbrot()` may take a second or so — our fractal generator
    is simple rather than efficient!
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对`mandelbrot()`的调用可能需要一秒左右 - 我们的分形生成器简单而不是高效！
- en: 'We can take a look at the returned data structure:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看返回的数据结构：
- en: '[PRE40]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It’s a list of lists of integers, just as we were promised. Let’s write those
    pixel values to a BMP file:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个整数列表的列表，就像我们所承诺的那样。让我们把这些像素值写入一个BMP文件：
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Find the file and open it in an image viewer, for example by opening it in your
    web browser.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 找到文件并在图像查看器中打开它，例如通过在Web浏览器中打开它。
- en: '![](images/m09----mandel.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](images/m09----mandel.png)'
- en: Reading binary files
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 读取二进制文件
- en: 'Now that we’re producing beautiful Mandelbrot images, we should see about reading
    those BMPs back with Python. We’re not going to write a full-blown BMP reader,
    although that would be an interesting exercise. We’ll just make a simple function
    to determine the image dimension in pixels from a BMP file. We’ll add the code
    into `bmp.py`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在生成美丽的Mandelbrot图像，我们应该尝试用Python读取这些BMP文件。我们不打算编写一个完整的BMP阅读器，尽管那将是一个有趣的练习。我们只是制作一个简单的函数来确定BMP文件中的像素维度。我们将把代码添加到`bmp.py`中：
- en: '[PRE42]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Of course, we use a with-statement to manage the file, so we don’t have to worry
    about it being properly closed. Inside the with-block we perform a simple validation
    check by looking for the two first magic bytes that we expect in a BMP file. If
    they’re not present, we raise a `ValueError` which will, of course, cause the
    context manager to close the file.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们使用with语句来管理文件，所以我们不必担心它是否被正确关闭。在with块内，我们通过查找我们在BMP文件中期望的前两个魔术字节来执行简单的验证检查。如果不存在，我们会引发`ValueError`，这当然会导致上下文管理器关闭文件。
- en: Looking back at our BMP writer, we can determine that the image dimensions are
    stored exactly 18 bytes from the beginning of the file. We `seek()` to that location
    and use the `read()` method to read two chunks of four bytes each for the two
    32-bit integers which represent the dimensions. Because we opened the file in
    binary mode, `read()` returns a `bytes` object. We pass each of these two `bytes`
    objects to another implementation detail function called `_bytes_to_int32()` which
    assembles them back into an integer. The two integers, representing image width
    and height, are returned as a tuple.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下我们的BMP写入器，我们可以确定图像尺寸恰好存储在文件开头的18个字节处。我们`seek()`到该位置，并使用`read()`方法读取两个四字节的块，分别代表尺寸的两个32位整数。因为我们以二进制模式打开文件，`read()`返回一个`bytes`对象。我们将这两个`bytes`对象传递给另一个实现细节函数`_bytes_to_int32()`，它将它们重新组装成一个整数。这两个整数，代表图像的宽度和高度，作为一个元组返回。
- en: 'The `_bytes_to_int32()` function uses `<<` (*bitwise left-shift*) and `|` (*bitwise-or*),
    together with indexing of the `bytes` object, to reassemble the integer. Note
    that indexing into a `bytes` object returns an integer:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`_bytes_to_int32（）`函数使用`<<`（*按位左移*）和`|`（*按位或*），以及对`bytes`对象的索引，来重新组装整数。请注意，对`bytes`对象进行索引返回一个整数：'
- en: '[PRE43]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If we use our new reader code, we can see that it does indeed read the correct
    values:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用我们的新的读取器代码，我们可以看到它确实读取了正确的值：
- en: '[PRE44]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: File-like objects
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类似文件的对象
- en: There is a notion in Python of “file-like objects”. This isn’t as formal as
    a specific protocol^([27](chap21.xhtml#fn-like-sequence-protocol)), but, thanks
    to the polymorphism afforded by duck-typing, it works well in practice.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Python中有一个“类似文件的对象”的概念。这并不像特定的协议^([27](chap21.xhtml#fn-like-sequence-protocol))那样正式，但由于鸭子类型所提供的多态性，在实践中它运作良好。
- en: 'The reason it’s not closely specified is that different types of data streams
    and devices have many different capabilities, expectations, and behaviors. So
    in fact defining a set of protocols to model them would be quite complex, and
    it wouldn’t actually gain us much in practice, other than a smug sense of theoretical
    achievement. This is where the EAFP ^([28](chap21.xhtml#fn-EAFP)) philosophy comes
    into its own: if you want to perform `seek()` on a file-like object without knowing
    in advance that it supports random access, go ahead and try (literally!). Just
    be prepared to fail if the `seek()` method doesn’t exist, or if it *does* exist
    but doesn’t behave as you expect.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以没有严格规定它，是因为不同类型的数据流和设备具有许多不同的功能、期望和行为。因此，实际上定义一组模拟它们的协议将是相当复杂的，而且实际上并没有太多的实际意义，除了一种理论成就感。这就是EAFP^([28](chap21.xhtml#fn-EAFP))哲学的优势所在：如果你想在类似文件的对象上执行`seek()`，而事先不知道它是否支持随机访问，那就试试看（字面上！）。只是要做好准备，如果`seek()`方法不存在，或者*存在*但行为不符合你的期望，那么就会失败。
- en: You might say “If it looks like a file and reads like a file, then it is a file”.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会说“如果它看起来像一个文件，读起来像一个文件，那么它就是一个文件”。
- en: You’ve already seen file-like objects!
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 你已经看到了类似文件的对象！
- en: We’ve actually seen file-like objects in action already; the objects returned
    to us when we open files in text and binary mode are actually of different types,
    although both with definite file-like behavior. There are other types in the Python
    standard library which implement file-like behavior, and in fact we saw one of
    them in action back at the beginning of the book, when we used `urlopen()` to
    retrieve data from a URL on the Internet.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了类似文件的对象的实际应用；当我们以文本和二进制模式打开文件时，返回给我们的对象实际上是不同类型的，尽管都具有明确定义的类似文件的行为。Python标准库中还有其他类型实现了类似文件的行为，实际上我们在书的开头就看到了其中一个，当时我们使用`urlopen()`从互联网上的URL检索数据。
- en: Using file-like objects
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用类似文件的对象
- en: 'Let’s exploit this polymorphism across file-like objects by writing a function
    to count the number of words per line in a file and return that information as
    a list:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过编写一个函数来利用类似文件的对象的多态性，来统计文件中每行的单词数，并将该信息作为列表返回：
- en: '[PRE45]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now we’ll open a regular text file containing the fragment of T.S. Eliot’s
    masterpiece we created earlier, and pass it to our new function:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将打开一个包含我们之前创建的T.S.艾略特杰作片段的常规文本文件，并将其传递给我们的新函数：
- en: '[PRE46]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The actual type of `real_file` is:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`real_file`的实际类型是：'
- en: '[PRE47]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: But you shouldn’t normally concern yourself with this specific type; is an internal
    Python implementation detail. You’re just care that it behaves “like a file”.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 但通常你不应该关心这个具体的类型；这是Python内部的实现细节。你只需要关心它的行为“像一个文件”。
- en: 'We’ll now do the same using a file-like object representing a web resource
    referred to by a URL:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用代表URL引用的Web资源的类似文件对象执行相同的操作：
- en: '[PRE48]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The type of `web_file` is quite different from what we just saw:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`web_file`的类型与我们刚刚看到的类型相当不同：'
- en: '[PRE49]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: However, since they are both file-like objects, our function can work with both.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于它们都是类似文件的对象，我们的函数可以与两者一起使用。
- en: There’s nothing magical about file-like objects; it’s just a convenient and
    fairly informal description for a set of expectations we can place on an object
    which are exploited through duck-typing.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 类似文件的对象并没有什么神奇之处；它只是一个方便且相当非正式的描述，用于描述我们可以对对象提出的一组期望，这些期望是通过鸭子类型来实现的。
- en: Other resources
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他资源
- en: 'The with-statement construct can be used with any type of object which implements
    the context manager protocol. We’re not going to show you how to implement a context-manager
    is this book – for that you’ll need to refer to *The Python Journeyman* – but
    we will show you a simple way to make your own classes usable in a with statement.
    Put this code into the module `fridge.py`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: with语句结构可以与实现上下文管理器协议的任何类型的对象一起使用。我们不会在本书中向您展示如何实现上下文管理器 - 为此，您需要参考*The Python
    Journeyman* - 但我们会向您展示一种简单的方法，使您自己的类可以在with语句中使用。将这段代码放入模块`fridge.py`中：
- en: '[PRE50]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We’ll import `raid()` into the REPL and go on the rampage:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`raid()`导入REPL并开始肆虐：
- en: '[PRE51]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Importantly, we remembered to close the door, so the food will be preserved
    until our next raid. Let’s try another raid for something slightly less healthy:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，我们记得关闭了门，所以食物会保存到我们下次袭击。让我们尝试另一次袭击，找一些稍微不那么健康的东西：
- en: '[PRE52]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This time, we were interrupted by the health warning and didn’t get around
    to closing the door. We can fix that by using a function called [`closing()`](https://docs.python.org/3/library/contextlib.html#contextlib.closing)
    in the Python Standard Library [`contextlib` module](https://docs.python.org/3/library/contextlib.html).
    After importing the function we wrap our `RefrigeratorRaider` constructor call
    in a call to `closing()`. This wraps our object in a context manager that always
    calls the `close()` method on the wrapped object before exiting. We use this object
    to initialise a with-block:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们被健康警告打断，没有来得及关闭门。我们可以通过使用Python标准库中的[`contextlib`模块](https://docs.python.org/3/library/contextlib.html)中的`closing()`函数来解决这个问题。导入函数后，我们将`RefrigeratorRaider`构造函数调用包装在`closing()`的调用中。这样可以将我们的对象包装在一个上下文管理器中，在退出之前始终调用包装对象上的`close()`方法。我们使用这个对象来初始化一个with块：
- en: '[PRE53]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now when we execute a raid:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们执行袭击时：
- en: '[PRE54]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We see that our explicit call to `close()` is unnecessary, so let’s fix that
    up:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到我们对`close()`的显式调用是不必要的，所以让我们来修复一下：
- en: '[PRE55]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: A more sophisticated implementation would check that the door was already closed
    and ignore other requests.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的实现会检查门是否已经关闭，并忽略其他请求。
- en: 'So does it work? Let’s try eating some deep fried pizza once more:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 那么它是否有效呢？让我们再试试吃一些油炸比萨：
- en: '[PRE56]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This time, even though the health warning was triggered, the door was still
    closed for us by the context manager.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，即使触发了健康警告，上下文管理器仍然为我们关闭了门。
- en: Summary
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: Files are opened using the built-in `open()` function which accepts a file mode
    to control read/write/append behaviour and whether the file is to be treated as
    raw binary or encoded text data.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件是使用内置的`open()`函数打开的，该函数接受文件模式来控制读取/写入/追加行为，以及文件是作为原始二进制数据还是编码文本数据进行处理。
- en: For text data you should specify a text encoding.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于文本数据，应指定文本编码。
- en: Text files deal with string objects and perform universal newline translation
    and string encoding.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本文件处理字符串对象，并执行通用换行符转换和字符串编码。
- en: Binary files deal with `bytes` objects with no newline translation or encoding.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制文件处理`bytes`对象，不进行换行符转换或编码。
- en: When writing files, it’s your responsibility to provide newline characters for
    line breaks.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在写文件时，您有责任为换行符提供换行字符。
- en: Files should always be closed after use.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件在使用后应始终关闭。
- en: Files provide various line-oriented methods for reading, and are also iterators
    which yield line by line.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件提供各种面向行的方法进行读取，并且也是迭代器，逐行产生行。
- en: Files are context managers and the with-statement can be used with context managers
    to ensure that clean up operations, such as closing files, are performed.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件是上下文管理器，可以与上下文管理器一起使用，以确保执行清理操作，例如关闭文件。
- en: The notion of file-like objects is loosely defined, but very useful in practice.
    Exercise EAFP to make the most of them.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件样对象的概念定义不严格，但在实践中非常有用。尽量使用EAFP来充分利用它们。
- en: Context managers aren’t restricted to file-like objects. We can use tools in
    the `contextlib` standard library module, such as the `closing()` wrapper to create
    our own context managers.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文管理器不仅限于类似文件的对象。我们可以使用`contextlib`标准库模块中的工具，例如`closing()`包装器来创建我们自己的上下文管理器。
- en: 'Along the we way found that:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 沿途我们发现：
- en: '`help()` can be used on instance objects, not just types.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`help()`可以用于实例对象，而不仅仅是类型。'
- en: Python supports bitwise operators `&`, `|`, `<<` and `>>`.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python支持按位运算符`&`、`|`、`<<`和`>>`。
