- en: Chapter 8. Testing and Deploying an API with Flask
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章：使用 Flask 测试和部署 API
- en: 'In this chapter, we will configure, write, and execute unit tests and learn
    a few things related to deployment. We will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将配置、编写和执行单元测试，并学习一些与部署相关的内容。我们将：
- en: Set up unit tests
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置单元测试
- en: Create a database for testing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为测试创建数据库
- en: Write a first round of unit tests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写第一轮单元测试
- en: Run unit tests and check testing coverage
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行单元测试并检查测试覆盖率
- en: Improve testing coverage
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高测试覆盖率
- en: Understand strategies for deployments and scalability
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解部署和可扩展性的策略
- en: Setting up unit tests
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置单元测试
- en: We will use `nose2` to make it easier to discover and run unit tests. We will
    measure test coverage, and therefore, we will install the necessary package to
    allow us to run coverage with `nose2`. First, we will install the `nose2` and
    `cov-core` packages in our virtual environment. The `cov-core` package will allow
    us to measure test coverage with `nose2`. Then, we will create a new PostgreSQL
    database that we will use for testing. Finally, we will create the configuration
    file for the testing environment.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `nose2` 来简化单元测试的发现和运行。我们将测量测试覆盖率，因此，我们将安装必要的包以允许我们使用 `nose2` 运行覆盖率。首先，我们将在我们的虚拟环境中安装
    `nose2` 和 `cov-core` 包。`cov-core` 包将允许我们使用 `nose2` 测量测试覆盖率。然后，我们将创建一个新的 PostgreSQL
    数据库，我们将用它来进行测试。最后，我们将创建测试环境的配置文件。
- en: 'Make sure you quit the Flask''s development server. Remember that you just
    need to press ***Ctrl*** + ***C*** in the terminal or the Command Prompt window
    in which it is running. We just need to run the following command to install the
    `nose2` package:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您退出 Flask 的开发服务器。请记住，您只需在运行它的终端或命令提示符窗口中按 ***Ctrl*** + ***C*** 即可。我们只需运行以下命令即可安装
    `nose2` 包：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The last lines of the output will indicate that the `django-nose` package has
    been successfully installed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示 `django-nose` 包已成功安装。
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We just need to run the following command to install the `cov-core` package
    that will also install the `coverage` dependency:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需运行以下命令即可安装 `cov-core` 包，该包也将安装 `coverage` 依赖项：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The last lines for the output will indicate that the `django-nose` package
    has been successfully installed:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示 `django-nose` 包已成功安装：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, we will create the PostgreSQL database that we will use as a repository
    for our testing environment. You will have to download and install a PostgreSQL
    database, in case you aren't already running it on the testing environment on
    your computer or in a testing server.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个 PostgreSQL 数据库，我们将将其用作测试环境的存储库。如果您还没有在您的计算机上的测试环境中或在测试服务器上运行 PostgreSQL
    数据库，您将需要下载并安装 PostgreSQL 数据库。
- en: Tip
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember to make sure that the PostgreSQL bin folder is included in the `PATH`
    environmental variable. You should be able to execute the `psql` command-line
    utility from your current Terminal or Command Prompt.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住确保 PostgreSQL 的 bin 文件夹包含在 `PATH` 环境变量中。您应该能够从当前的 Terminal 或 Command Prompt
    执行 `psql` 命令行实用程序。
- en: 'We will use the PostgreSQL command-line tools to create a new database named
    `test_messages`. In case you already have a PostgreSQL database with this name,
    make sure that you use another name in all the commands and configurations. You
    can perform the same task with any PostgreSQL GUI tool. In case you are developing
    on Linux, it is necessary to run the commands as the `postgres` user. Run the
    following command in macOS or Windows to create a new database named `test_messages`.
    Note that the command won''t generate any output:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 PostgreSQL 命令行工具创建一个名为 `test_messages` 的新数据库。如果您已经有一个同名 PostgreSQL 数据库，请确保在所有命令和配置中使用另一个名称。您可以使用任何
    PostgreSQL GUI 工具执行相同的任务。如果您在 Linux 上开发，必须以 `postgres` 用户身份运行命令。在 macOS 或 Windows
    上运行以下命令以创建一个名为 `test_messages` 的新数据库。请注意，该命令不会生成任何输出：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In Linux, run the following command to use the `postgres` user:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，运行以下命令以使用 `postgres` 用户：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we will use the `psql` command-line tool to run some SQL statements to
    grant privileges on the database to a user. In case you are using a different
    server than the development server, you will have to create the user before granting
    privileges. In macOS or Windows, run the following command to launch psql:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用 `psql` 命令行工具运行一些 SQL 语句，以授予数据库对用户的权限。如果您使用的是与开发服务器不同的服务器，您必须在授予权限之前创建用户。在
    macOS 或 Windows 上，运行以下命令以启动 psql：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In Linux, run the following command to use the postgres user
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，运行以下命令以使用 postgres 用户
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, run the following SQL statements and finally enter \q to exit the psql
    command-line tool. Replace user_name with your desired user name to use in the
    new database and password with your chosen password. We will use the user name
    and password in the Flask testing configuration. You don''t need to run the steps
    in case you are already working with a specific user in PostgreSQL and you have
    already granted privileges to the database for the user:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行以下 SQL 语句，最后输入 \q 以退出 psql 命令行工具。将 user_name 替换为你希望在新的数据库中使用的用户名，将 password
    替换为你选择的密码。我们将在 Flask 测试配置中使用用户名和密码。如果你已经在 PostgreSQL 中使用特定用户并且已经为该用户授予了数据库权限，则无需运行以下步骤：
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Create a new `test_config.py` file within the `api` folder. The following lines
    show the code that declares variables that determine the configuration for Flask
    and SQLAlchemy for our testing environment. The `SQL_ALCHEMY_DATABASE_URI` variable
    generates a SQLAlchemy URI for the PostgreSQL database that we will use to run
    all the migrations before starting tests and we will drop all the elements after
    executing all the tests. Make sure you specify the desired test database name
    in the value for `DB_NAME` and that you configure the user, password, host, and
    port based on your PostgreSQL configuration for the testing environment. In case
    you followed the previous steps, use the settings specified in these steps. The
    code file for the sample is included in the `restful_python_chapter_08_01` folder.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `api` 文件夹中创建一个新的 `test_config.py` 文件。以下行显示了声明变量以确定 Flask 和 SQLAlchemy 测试环境配置的代码。`SQL_ALCHEMY_DATABASE_URI`
    变量生成一个用于 PostgreSQL 数据库的 SQLAlchemy URI，我们将使用它来运行所有迁移，并在开始测试之前删除所有元素。确保你指定了 `DB_NAME`
    值中所需的测试数据库名称，并根据你的测试环境 PostgreSQL 配置配置用户、密码、主机和端口。如果你遵循了之前的步骤，请使用这些步骤中指定的设置。示例的代码文件包含在
    `restful_python_chapter_08_01` 文件夹中。
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we did with the similar test file we created for our development environment,
    we will specify the previously created module as an argument to a function that
    will create a Flask app that we will use for testing. This way, we have one module
    that specifies all the values for the different configuration variables for our
    testing environment and another module that creates a *Flask* app for our testing
    environment. It is also possible to create a class hierarchy with one class for
    each environment we want to use. However, in our sample case, it is easier to
    create a new configuration file for our testing environment.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在为开发环境创建的类似测试文件中做的那样，我们将指定之前创建的模块作为函数的参数，该函数将创建一个我们将用于测试的 Flask 应用程序。这样，我们有一个模块指定了测试环境中所有不同配置变量的值，另一个模块为我们的测试环境创建一个
    *Flask* 应用程序。也可以创建一个类层次结构，每个环境都有一个类。然而，在我们的示例中，为测试环境创建一个新的配置文件更容易。
- en: Writing a first round of unit tests
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写第一轮单元测试
- en: 'Now, we will write a first round of unit tests. Specifically, we will write
    unit tests related to the user and message category resources: `UserResource`,
    `UserListResource`, `CategoryResource`, and `CategoryListResource`. Create a new
    `tests` sub-folder within the `api` folder. Then, create a new `test_views.py`
    file within the new `api/tests` sub-folder. Add the following lines, that declare
    many `import` statements and the first methods for the `InitialTests` class. The
    code file for the sample is included in the `restful_python_chapter_08_01` folder:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写第一轮单元测试。具体来说，我们将编写与用户和消息类别资源相关的单元测试：`UserResource`、`UserListResource`、`CategoryResource`
    和 `CategoryListResource`。在 `api` 文件夹中创建一个新的 `tests` 子文件夹。然后，在新的 `api/tests` 子文件夹中创建一个新的
    `test_views.py` 文件。添加以下行，这些行声明了许多 `import` 语句和 `InitialTests` 类的第一个方法。示例的代码文件包含在
    `restful_python_chapter_08_01` 文件夹中：
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `InitialTests` class is a subclass of `unittest.TestCase`. The class overrides
    the `setUp` method that will be executed before each test method runs. The method
    calls the `create_app` function, declared in the `app` module, with `'test_config'`
    as an argument. The function will set up a Flask app with this module as the configuration
    file, and therefore, the app will use the previously created configuration file
    that specifies the desired values for our testing database and environment. Then,
    the code sets the testing attribute for the recently created `app` to `True` in
    order for the exception to propagate to the test client.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`InitialTests` 类是 `unittest.TestCase` 的子类。该类覆盖了在每次测试方法运行之前将执行的 `setUp` 方法。该方法使用
    `''test_config''` 作为参数调用在 `app` 模块中声明的 `create_app` 函数。该函数将使用此模块作为配置文件设置 Flask
    应用程序，因此应用程序将使用之前创建的配置文件，该文件指定了测试数据库和环境所需的值。然后，代码将新创建的 `app` 的测试属性设置为 `True`，以便异常可以传播到测试客户端。'
- en: The next line calls the `self.app.test_client` method to create a test client
    for the previously created Flask application and saves the test client in the
    `test_client` attribute. We will use the test client in our test methods to easily
    compose and send requests to our API. Then, the code saves and pushes the application
    context and creates two attributes with the user name and password we will use
    for our tests. Finally, the method calls the `db.create_all` method to create
    all the necessary tables in our test database configured in the `test_config.py`
    file.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个调用 `self.app.test_client` 方法来为之前创建的 Flask 应用程序创建一个测试客户端，并将测试客户端保存到 `test_client`
    属性中。我们将在测试方法中使用测试客户端来轻松地组合和发送请求到我们的 API。然后，代码保存并推送应用程序上下文，并创建两个属性，包含我们将用于测试的用户名和密码。最后，方法调用
    `db.create_all` 方法来创建在 `test_config.py` 文件中配置的测试数据库中所有必要的表。
- en: The `InitialTests` class overrides the `tearDown` method that will be executed
    after each test method runs. The code removes the SQLAlchemy session, drops all
    the tables that we created in the test database before starting the execution
    of the tests, and pops the application context. This way, after each test finishes
    its execution, the test database will be empty again.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`InitialTests` 类覆盖了在每次测试方法运行之后将执行的 `tearDown` 方法。代码移除 SQLAlchemy 会话，在测试数据库中删除我们在测试执行前创建的所有表，并弹出应用程序上下文。这样，每次测试完成后，测试数据库将再次为空。'
- en: The `get_accept_content_type_headers` method builds and returns a dictionary
    (`dict`) with the values of the `Accept` and `Content-Type` header keys set to
    `'application/json'`. We will call this method in our tests whenever we have to
    build a header to compose our requests without authentication.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_accept_content_type_headers` 方法构建并返回一个字典（`dict`），其中 `Accept` 和 `Content-Type`
    头键的值设置为 `''application/json''`。在我们需要构建头部以组合无需认证的请求时，我们将在测试中调用此方法。'
- en: The `get_authentication_headers` method calls the previously explained `get_accept_content_type_headers`
    method to generate the header key-value pairs without authentication. Then, the
    code adds the necessary value to the `Authorization` key with the appropriate
    encoding to provide the user name and password received in the `username` and
    `password` arguments. The last line returns the generated dictionary that includes
    authentication information. We will call this method in our tests whenever we
    have to build a header to compose our requests with authentication. We will use
    the user name and password we stored in attributes the `setUp` method.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_authentication_headers` 方法调用之前解释过的 `get_accept_content_type_headers` 方法来生成无需认证的头部键值对。然后，代码将必要的值添加到
    `Authorization` 键中，使用适当的编码来提供在 `username` 和 `password` 参数中接收的用户名和密码。最后一行返回包含认证信息的生成字典。在我们需要构建头部以添加认证来组合请求时，我们将在测试中调用此方法。我们将使用在
    `setUp` 方法中存储的用户名和密码。'
- en: Open the previously created `test_views.py` file within the new `api/tests`
    sub-folder. Add the following lines that declare many methods for the `InitialTests`
    class. The code file for the sample is included in the `restful_python_chapter_08_01`
    folder.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 打开之前创建的 `test_views.py` 文件，位于新的 `api/tests` 子文件夹中。添加以下行，这些行声明了 `InitialTests`
    类的多个方法。示例代码文件包含在 `restful_python_chapter_08_01` 文件夹中。
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `test_request_without_authentication` method tests whether we have been
    rejected access to a resource that requires authentication when we don't provide
    an appropriate authentication header with the request. The method uses the test
    client to compose and send an HTTP `GET` request to the URL generated for the
    `'api.messagelistresource'` resource to retrieve the list of messages. We need
    an authenticated request to retrieve the list of messages. However, the code calls
    the `get_authentication_headers` method to set the value for the headers argument
    in the call to `self.test_client.get`, and therefore, the code generates a request
    without authentication. Finally, the method uses `assertTrue` to check that the
    `status_code` for the response is HTTP 401 Unauthorized (`status.HTTP_401_UNAUTHORIZED`).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_request_without_authentication` 方法测试当我们不提供适当的身份验证头时，我们是否被拒绝访问需要身份验证的资源。该方法使用测试客户端来组合并发送一个
    HTTP `GET` 请求到为 `''api.messagelistresource''` 资源生成的 URL，以检索消息列表。我们需要一个经过身份验证的请求来检索消息列表。然而，代码调用
    `get_authentication_headers` 方法来设置调用 `self.test_client.get` 时的 headers 参数的值，因此代码生成了一个没有身份验证的请求。最后，该方法使用
    `assertTrue` 来检查响应的 `status_code` 是否为 HTTP 401 未授权 (`status.HTTP_401_UNAUTHORIZED`)。'
- en: The `create_user` method uses the test client to compose and send an HTTP `POST`
    request to the URL generated for the `'api.userlistresource'` resource to create
    a new user with the name and password received as arguments. We don't need an
    authenticated request to create a new user, and therefore, the code calls the
    previously explained `get_accept_content_type_headers` method to set the value
    for the headers argument in the call to `self.test_client.post`. Finally, the
    code returns the response from the `POST` request. Whenever we have to create
    an authenticated request, we will call the `create_user` method to create a new
    user.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_user` 方法使用测试客户端来组合并发送一个 HTTP `POST` 请求到为 `''api.userlistresource''`
    资源生成的 URL，以创建一个名为和密码作为参数的新用户。我们不需要经过身份验证的请求来创建一个新用户，因此代码调用之前解释过的 `get_accept_content_type_headers`
    方法来设置调用 `self.test_client.post` 时的 headers 参数的值。最后，代码返回 `POST` 请求的响应。每次我们需要创建一个经过身份验证的请求时，我们将调用
    `create_user` 方法来创建一个新用户。'
- en: The `create_category` method uses the test client to compose and send an HTTP
    `POST` request to the URL generated for the `'api.categorylistresource'` resource
    to create a new `Category` with the name received as an argument. We need an authenticated
    request to create a new `Category`, and therefore, the code calls the previously
    explained `get_authentication_headers` method to set the value for the headers
    argument in the call to `self.test_client.post`. The user name and password are
    set to `self.test_user_name` and `self.test_user_password`. Finally, the code
    returns the response from the `POST` request. Whenever we have to create a category,
    we will call the `create_category` method after the appropriate user that authenticates
    the request has been created.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_category` 方法使用测试客户端来组合并发送一个 HTTP `POST` 请求到为 `''api.categorylistresource''`
    资源生成的 URL，以创建一个名为参数接收的新 `Category`。我们需要一个经过身份验证的请求来创建一个新的 `Category`，因此代码调用之前解释过的
    `get_authentication_headers` 方法来设置调用 `self.test_client.post` 时的 headers 参数的值。用户名和密码设置为
    `self.test_user_name` 和 `self.test_user_password`。最后，代码返回 `POST` 请求的响应。每次我们需要创建一个类别时，我们将在创建请求身份验证的适当用户之后调用
    `create_category` 方法。'
- en: 'The `test_create_and_retrieve_category` method tests whether we can create
    a new `Category` and then retrieve it. The method calls the previously explained
    `create_user` method to create a new user and then use it to authenticate the
    HTTP `POST` request generated in the `create_game_category` method. Then, the
    code composes and sends an HTTP `GET` method to retrieve the recently created
    Category with the URL received in the response of the previous HTTP `POST` request.
    The method uses `assertEqual` to check for the following expected results:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_create_and_retrieve_category` 方法测试我们是否可以创建一个新的 `Category` 并然后检索它。该方法调用之前解释过的
    `create_user` 方法来创建一个新用户，然后使用它来身份验证 `create_game_category` 方法生成的 HTTP `POST` 请求。然后，代码组合并发送一个
    HTTP `GET` 方法来检索之前 `POST` 请求响应中接收到的 URL 中的最近创建的 Category。该方法使用 `assertEqual` 来检查以下预期的结果：'
- en: The `status_code` for the HTTP `POST` response is HTTP 201 Created (`status.HTTP_201_CREATED`)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP `POST` 响应的 `status_code` 是 HTTP 201 已创建 (`status.HTTP_201_CREATED`)
- en: The total number of `Category` objects retrieved from the database is `1`
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数据库中检索到的 `Category` 对象总数是 `1`
- en: The `status_code` for the HTTP `GET` response is HTTP 200 OK (`status.HTTP_200_OK`)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP `GET` 响应的 `status_code` 是 HTTP 200 OK (`status.HTTP_200_OK`)
- en: The value for the `name` key in the HTTP `GET` response is equal to the name
    specified for the new category
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP `GET` 响应中 `name` 键的值等于为新类别指定的名称
- en: Open the previously created `test_views.py` file within the new `api/tests`
    sub-folder. Add the following lines that declare many methods for the `InitialTests`
    class. The code file for the sample is included in the `restful_python_chapter_08_01`
    folder.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在新创建的 `api/tests` 子文件夹中打开之前创建的 `test_views.py` 文件。添加以下行，这些行声明了 `InitialTests`
    类的许多方法。示例代码文件包含在 `restful_python_chapter_08_01` 文件夹中。
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The class declares the following methods whose name start with the `test_`
    prefix:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 该类声明了以下以 `test_` 前缀开头的方法：
- en: '`test_create_duplicated_ category`: Tests whether the unique constraints don''t
    make it possible for us to create two categories with the same name or not. The
    second time we compose and send an HTTP `POST` request with a duplicate category
    name, we must receive an HTTP 400 Bad Request status code (`status.HTTP_400_BAD_REQUEST`)
    and the total number of `Category` objects retrieved from the database must be
    `1`.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_create_duplicated_category`：测试唯一约束是否使我们无法创建具有相同名称的两个类别。当我们第二次组合并发送具有重复类别名称的
    HTTP `POST` 请求时，我们必须收到 HTTP 400 Bad Request 状态代码 (`status.HTTP_400_BAD_REQUEST`)，并且从数据库检索到的
    `Category` 对象总数必须是 `1`。'
- en: '`test_retrieve_categories_list`: Tests whether we can retrieve the categories
    list or not. First, the method creates two categories and then it makes sure that
    the retrieved list includes the two created categories.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_retrieve_categories_list`：测试我们是否可以检索类别列表。首先，该方法创建两个类别，然后确保检索到的列表包括这两个创建的类别。'
- en: '`test_update_game_category`: Tests whether we can update a single field for
    a category, specifically, its name field. The code makes sure that the name has
    been updated.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_update_game_category`：测试我们是否可以更新类别的单个字段，特别是其名称字段。代码确保名称已被更新。'
- en: Tip
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that each test that requires a specific condition in the database must
    execute all the necessary code for the database to be in this specific condition.
    For example, in order to update an existing category, first we must create a new
    category and then we can update it. Each test method will be executed without
    data from the previously executed test methods in the database, that is, each
    test will run with a database cleaned of data from previous tests.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个需要在数据库中满足特定条件的测试都必须执行所有必要的代码，以确保数据库处于这种特定状态。例如，为了更新现有类别，我们首先必须创建一个新的类别，然后才能更新它。每个测试方法将在数据库中不包含之前执行测试方法的数据的情况下执行，也就是说，每个测试将在清理了之前测试数据的数据库上运行。
- en: Running unit tests with nose2 and checking testing coverage
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 nose2 运行单元测试并检查测试覆盖率
- en: Now, run the following command to create all the necessary tables in our test
    database and use the `nose2` test running to execute all the tests we created.
    The test runner will execute all the methods for our `InitialTests` class that
    start with the `test_` prefix and will display the results.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行以下命令以在我们的测试数据库中创建所有必要的表，并使用 `nose2` 测试运行器执行我们创建的所有测试。测试运行器将执行 `InitialTests`
    类中以 `test_` 前缀开头的方法，并将显示结果。
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The tests won't make changes to the database we have been using when working
    on the API. Remember that we configured the `test_messages` database as our test
    database.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 测试不会更改我们在处理 API 时使用的数据库。请记住，我们已将 `test_messages` 数据库配置为我们的测试数据库。
- en: 'Remove the `api.py` file we created in the previous chapter from the `api`
    folder because we don''t want the tests coverage to take into account this file.
    Go to the `api` folder and run the following command within the same virtual environment
    that we have been using. We will use the `-v` option to instruct `nose2` to print
    test case names and statuses. The `--with-coverage` option turns on test coverage
    reporting generation:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一章创建的 `api.py` 文件从 `api` 文件夹中删除，因为我们不希望测试覆盖率考虑此文件。转到 `api` 文件夹，并在我们一直在使用的同一虚拟环境中运行以下命令。我们将使用
    `-v` 选项指示 `nose2` 打印测试用例名称和状态。`--with-coverage` 选项开启测试覆盖率报告生成：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The following lines show the sample output.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了示例输出。
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: By default, `nose2` looks for modules whose names start with the `test` prefix.
    In this case, the only module that matches the criteria is the `test_views` module.
    In the modules that match the criteria, `nose2` loads tests from all the subclasses
    of `unittest.TestCase` and the functions whose names start with the `test` prefix.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`nose2`会查找名称以`test`前缀开始的模块。在这种情况下，唯一符合标准的模块是`test_views`模块。在符合标准的模块中，`nose2`从`unittest.TestCase`的所有子类以及以`test`前缀开头名称的函数中加载测试。
- en: The output provides details indicating that the test runner discovered and executed
    five tests and all of them passed. The output displays the method name and the
    class name for each method in the `InitialTests` class that started with the `test_`
    prefix and represented a test to be executed.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 输出提供了详细信息，表明测试运行器发现了并执行了五个测试，并且所有测试都通过了。输出显示了`InitialTests`类中以`test_`前缀开始的每个方法的名称和类名，这些方法代表要执行的测试。
- en: 'The test code coverage measurement report provided by the `coverage` package
    uses the code analysis tools and the tracing hooks included in the Python standard
    library to determine which lines of code are executable and have been executed.
    The report provides a table with the following columns:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`coverage`包提供的测试代码覆盖率测量报告使用Python标准库中包含的代码分析工具和跟踪钩子来确定哪些代码行是可执行的并且已经执行。报告提供了一个包含以下列的表格：'
- en: '`Name`: The Python module name.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Name`：Python模块名称。'
- en: '`Stmts`: The count of executable statements for the Python module.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stmts`：Python模块的执行语句计数。'
- en: '`Miss`: The number of executable statements missed, that is, the ones that
    weren''t executed.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Miss`：未执行的执行语句的数量，即那些未执行的语句。'
- en: '`Cover`: The coverage of executable statements expressed as a percentage.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cover`：以百分比表示的可执行语句覆盖率。'
- en: We definitely have a very low coverage for `views.py` and `helpers.py` based
    on the measurements shown in the report. In fact, we just wrote a few tests related
    to categories and users, and therefore, it makes sense that the coverage is really
    low for the views. We didn't create tests related to messages.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 根据报告中显示的测量结果，我们确实对`views.py`和`helpers.py`的覆盖率非常低。实际上，我们只编写了一些与类别和用户相关的测试，因此对于视图的覆盖率真的很低是有道理的。我们没有创建与消息相关的测试。
- en: 'We can run the `coverage` command with the `-m` command-line option to display
    the line numbers of the missing statements in a new `Missing` column:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用带有`-m`命令行选项的`coverage`命令来显示新`Missing`列中缺失语句的行号：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The command will use the information from the last execution and will display
    the missing statements. The next lines show a sample output that corresponds to
    the previous execution of the unit tests:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将使用上次执行的信息，并显示缺失的语句。下面的几行显示了与之前单元测试执行相对应的示例输出：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, run the following command to get annotated HTML listings detailing missed
    lines:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行以下命令以获取详细说明缺失行的注释HTML列表：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Open the `index.html` HTML file generated in the `htmlcov` folder with your
    Web browser. The following picture shows an example report that coverage generated
    in HTML format:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您的Web浏览器打开在`htmlcov`文件夹中生成的`index.html` HTML文件。以下图片显示了以HTML格式生成的示例报告：
- en: '![Running unit tests with nose2 and checking testing coverage](img/image_08_001.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![使用nose2运行单元测试并检查测试覆盖率](img/image_08_001.jpg)'
- en: 'Click or tap `views.py` and the Web browser will render a Web page that displays
    the statements that were run, the missing ones and the excluded, with different
    colors. We can click or tap on the **run**, **missing** and **excluded** buttons
    to show or hide the background color that represents the status for each line
    of code. By default, the missing lines of code will be displayed with a pink background.
    Thus, we must write unit tests that target these lines of code to improve our
    test coverage:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 点击或轻触`views.py`，Web浏览器将渲染一个显示已运行语句、缺失语句和排除语句的Web页面，这些语句以不同的颜色显示。我们可以点击或轻触**运行**、**缺失**和**排除**按钮来显示或隐藏代表每行代码状态的背景颜色。默认情况下，缺失的代码行将以粉红色背景显示。因此，我们必须编写针对这些代码行的单元测试来提高我们的测试覆盖率：
- en: '![Running unit tests with nose2 and checking testing coverage](img/image_08_002.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![使用nose2运行单元测试并检查测试覆盖率](img/image_08_002.jpg)'
- en: Improving testing coverage
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高测试覆盖率
- en: 'Now, we will write additional unit tests to improve the testing coverage. Specifically,
    we will write unit tests related to messages and users. Open the existing `api/tests/test_views.py`
    file and insert the following lines after the last line, within the `InitialTests`
    class. We need a new `import` statement and we will declare the new `PlayerTests`
    class. The code file for the sample is included in the `restful_python_chapter_08_02`
    folder:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写额外的单元测试以改进测试覆盖率。具体来说，我们将编写与消息和用户相关的单元测试。打开现有的 `api/tests/test_views.py`
    文件，在 `InitialTests` 类的最后一条语句之后插入以下行。我们需要一个新的 `import` 语句，并将声明新的 `PlayerTests`
    类。示例代码文件包含在 `restful_python_chapter_08_02` 文件夹中：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding code adds many methods to the `InitialTests` class. The `create_message`
    method receives the desired `message`, `duration`, and `category` (category name)
    for the new message as arguments. The method builds the URL and the data dictionary
    to compose and send an HTTP `POST` method, create a new message, and return the
    response generated by this request. Many test methods will call the `create_message`
    method to create a message and then compose and send other HTTP requests to the
    API.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码向 `InitialTests` 类添加了许多方法。`create_message` 方法接收新消息所需的 `message`、`duration`
    和 `category`（类别名称）作为参数。该方法构建 URL 和数据字典以组成并发送 HTTP `POST` 方法，创建新消息，并返回此请求生成的响应。许多测试方法将调用
    `create_message` 方法来创建消息，然后向 API 组成并发送其他 HTTP 请求。
- en: 'The class declares the following methods whose names start with the `test_`
    prefix:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 该类声明了以下方法，其名称以 `test_` 前缀开头：
- en: '`test_create_and_retrieve_message`: Tests whether we can create a new `Message`
    and then retrieve it.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_create_and_retrieve_message`：测试我们是否可以创建一个新的 `Message` 并检索它。'
- en: '`test_create_duplicated_message`: Tests whether the unique constraints don''t
    make it possible for us to create two messages with the same message. The second
    time we compose and send an HTTP `POST` request with a duplicate message, we must
    receive an `HTTP 400 Bad Request` status code (`status.HTTP_400_BAD_REQUEST`)
    and the total number of `Message` objects retrieved from the database must be
    `1`.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_create_duplicated_message`：测试唯一约束是否使我们无法创建具有相同消息的两个消息。当我们第二次使用重复的消息组成并发送
    HTTP `POST` 请求时，我们必须收到 `HTTP 400 Bad Request` 状态代码（`status.HTTP_400_BAD_REQUEST`），并且从数据库检索到的
    `Message` 对象的总数必须是 `1`。'
- en: 'Open the existing `api/tests/test_views.py` file and insert the following lines
    after the last line, within the `InitialTests` class. The code file for the sample
    is included in the `restful_python_chapter_08_02` folder:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 打开现有的 `api/tests/test_views.py` 文件，在 `InitialTests` 类的最后一条语句之后插入以下行。示例代码文件包含在
    `restful_python_chapter_08_02` 文件夹中：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The previous code added a `test_retrieve_messages_list` method to the `InitialTests`
    class. This method tests whether we can retrieve the paginated messages list.
    First, the method creates two messages and then it makes sure that the retrieved
    list includes the two created messages in the first page. In addition, the method
    makes sure that the second page doesn't include any message and that the value
    for the previous page includes the URL for the first page.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码向 `InitialTests` 类添加了 `test_retrieve_messages_list` 方法。该方法测试我们是否可以检索分页的消息列表。首先，该方法创建两条消息，然后确保检索到的列表包含第一页中的两条创建的消息。此外，该方法确保第二页不包含任何消息，并且上一页的值包含第一页的
    URL。
- en: 'Open the existing `api/tests/test_views.py` file and insert the following lines
    after the last line, within the `InitialTests` class. The code file for the sample
    is included in the `restful_python_chapter_08_02` folder:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 打开现有的 `api/tests/test_views.py` 文件，在 `InitialTests` 类的最后一条语句之后插入以下行。示例代码文件包含在
    `restful_python_chapter_08_02` 文件夹中：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The previous code added the following two methods to the `InitialTests` class-`test_update_message`-tests
    whether we can update more than one fields for a message, specifically, the values
    for the `printed_times` and `printed_once` fields. The code makes sure that both
    fields have been updated.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之前的代码向 `InitialTests` 类添加了以下两个方法：`test_update_message` - 测试我们是否可以更新一条消息的多个字段，具体来说，是
    `printed_times` 和 `printed_once` 字段的值。代码确保这两个字段都已更新。
- en: '`test_create_and_retrieve_user`: Tests whether we can create a new `User` and
    then retrieve it.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_create_and_retrieve_user`：测试我们是否可以创建一个新的 `User` 并检索它。'
- en: We just coded a few tests related to messages and one test related to users
    in order to improve test coverage and notice the impact on the test coverage report.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仅编写了一些与消息相关的测试和与用户相关的一个测试，以改进测试覆盖率并注意对测试覆盖率报告的影响。
- en: 'Now, run the following command within the same virtual environment we have
    been using:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在同一个虚拟环境中运行以下命令：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following lines show the sample output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了示例输出：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The output provided details indicating that the test runner executed `10` tests
    and all of them passed. The test code coverage measurement report provided by
    the `coverage` package increased the `Cover` percentage of the `views.py` module
    from `47%` in the previous run to `68%`. In addition, the percentage of the `helpers.py`
    module increased from `22%` to `96%` because we wrote tests that used pagination.
    The new additional tests we wrote executed additional code in different modules,
    and therefore, there is an impact in the coverage report.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 输出提供了详细信息，表明测试运行器执行了`10`个测试，并且所有测试都通过了。由`coverage`包提供的测试代码覆盖率测量报告将`views.py`模块的`Cover`百分比从上一次运行的`47%`提高到`68%`。此外，由于我们编写了使用分页的测试，`helpers.py`模块的百分比从`22%`增加到`96%`。因此，我们编写的新附加测试在多个模块中执行了额外的代码，因此覆盖率报告有所影响。
- en: Tip
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We just created a few unit tests to understand how we can code them. However,
    of course, it would be necessary to write more tests to provide an appropriate
    coverage of all the featured and execution scenarios included in the API.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一些单元测试来了解我们如何编写它们。然而，当然，编写更多的测试以提供对API中包含的所有功能和执行场景的适当覆盖是必要的。
- en: Understanding strategies for deployments and scalability
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解部署和可扩展性的策略
- en: Flask is a lightweight microframework for the Web. However, as happens with
    Django, one of the biggest drawbacks related to Flask and Flask-RESTful is that
    each HTTP request is blocking. Thus, whenever the Flask server receives an HTTP
    request, it doesn't start working on any other HTTP requests in the incoming queue
    until the server sends the response for the first HTTP request it received.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Flask是一个用于Web的轻量级微框架。然而，正如Django所发生的那样，与Flask和Flask-RESTful相关的一个最大的缺点是每个HTTP请求都是阻塞的。因此，每当Flask服务器收到一个HTTP请求时，它不会开始处理队列中的任何其他HTTP请求，直到服务器为它收到的第一个HTTP请求发送响应。
- en: We used Flask to develop a RESTful Web Service. They key advantage of these
    kind of Web Services is that they are stateless, that is, they shouldn't keep
    a client state on any server. Our API is a good example of a stateless RESTful
    Web Service with Flask and Flask RESTful. Thus, we can make the API run on as
    many servers as necessary to achieve our scalability goals. Obviously, we must
    take into account that we can easily transform the database server in our scalability
    bottleneck.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Flask开发了一个RESTful Web服务。这类Web服务的关键优势是它们是无状态的，也就是说，它们不应该在任何服务器上保持客户端状态。我们的API是使用Flask和Flask
    RESTful的一个很好的无状态RESTful Web服务的例子。因此，我们可以让API在尽可能多的服务器上运行，以实现我们的可扩展性目标。显然，我们必须考虑到我们很容易将数据库服务器变成我们的可扩展性瓶颈。
- en: Tip
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Nowadays, we have a huge number of cloud-based alternatives to deploy a RESTful
    Web Service that uses Flask and Flask-RESTful and make it extremely scalable.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有许多基于云的替代方案来部署使用Flask和Flask-RESTful的RESTful Web服务，并使其具有极高的可扩展性。
- en: We always have to make sure that we profile the API and the database before
    we deploy the first version of our API. It is very important to make sure that
    the generated queries run properly on the underlying database and that the most
    popular queries do not end up in sequential scans. It is usually necessary to
    add the appropriate indexes to the tables in the database.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署我们API的第一个版本之前，我们总是必须确保我们分析了API和数据库。确保生成的查询在底层数据库上正确运行，以及最常用的查询不会最终导致顺序扫描，这一点非常重要。通常需要在数据库中的表上添加适当的索引。
- en: 'We have been using basic HTTP authentication. We can improve it with a token-based
    authentication. We must make sure that the API runs under HTTPS in production
    environments. In addition, we must make sure that we change the following line
    in the `api/config.py` file:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在使用基本的HTTP身份验证。我们可以通过基于令牌的身份验证来改进它。我们必须确保API在生产环境中运行在HTTPS下。此外，我们必须确保我们在`api/config.py`文件中更改以下行：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We must always turn off debug mode in production, and therefore, we must replace
    the previous line with the following one:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在生产环境中始终关闭调试模式，因此我们必须将前面的行替换为以下一行：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Tip
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is convenient to use a different configuration file for production. However,
    another approach that is becoming extremely popular, especially for cloud-native
    applications, is to store configuration in the environment. If we want to deploy
    cloud-native RESTful Web Services and follow the guidelines established in the
    twelve-factor App, we should store config in the environment.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同的配置文件进行生产是非常方便的。然而，另一种方法正变得越来越流行，尤其是在云原生应用程序中，那就是将配置存储在环境中。如果我们想部署云原生 RESTful
    Web 服务并遵循十二因素应用程序中建立的指南，我们应该将配置存储在环境中。
- en: Each platform includes detailed instructions to deploy our application. All
    of them will require us to generate the `requirements.txt` file that lists the
    application dependencies together with their versions. This way, the platforms
    will be able to install all the necessary dependencies listed in the file.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 每个平台都包含了详细的部署我们的应用程序的说明。所有这些都需要我们生成一个 `requirements.txt` 文件，其中列出了应用程序及其版本的依赖项。这样，平台就能够安装文件中列出的所有必要依赖项。
- en: Run the following `pip freeze` to generate the `requirements.txt` file.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下 `pip freeze` 命令以生成 `requirements.txt` 文件。
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following lines show the contents of a sample generated `requirements.txt`
    file. However, bear in mind that many packages increase their version number quickly
    and you might see different versions in your configuration:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了生成的示例 `requirements.txt` 文件的内容。然而，请注意，许多包的版本号更新很快，你可能会在配置中看到不同的版本：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Test your knowledge
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: 'By default, `nose2` looks for modules whose names start with the following
    prefix:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，`nose2` 会查找以下前缀开头的模块：
- en: '`test`'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`test`'
- en: '`run`'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`run`'
- en: '`unittest`'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`unittest`'
- en: 'By default, `nose2` loads tests from all the subclasses of the following class:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，`nose2` 从以下类的所有子类中加载测试。
- en: '`unittest.Test`'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`unittest.Test`'
- en: '`unittest.TestCase`'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`unittest.TestCase`'
- en: '`unittest.RunTest`'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`unittest.RunTest`'
- en: 'The `setUp` method in a subclass of `unittest.TestCase`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`unittest.TestCase` 子类中的 `setUp` 方法：'
- en: Is executed before each test method runs.
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个测试方法运行之前执行。
- en: Is executed only once before all the tests start their execution.
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有测试开始执行之前只执行一次。
- en: Is executed only once after all the tests finish their execution.
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅在所有测试执行完毕后执行一次。
- en: 'The `tearDown` method in a subclass of `unittest.TestCase`:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`unittest.TestCase` 子类中的 `tearDown` 方法：'
- en: Is executed after each test method runs.
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个测试方法运行之后执行。
- en: Is executed before each test method runs.
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个测试方法运行之前执行。
- en: Is executed after a test method only when it fails.
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅在测试方法失败后执行。
- en: 'If we declare a `get_accept_content_type_headers` method within a subclass
    of `unittest.TestCase`, by default, `nose2`:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们在 `unittest.TestCase` 的子类中声明一个 `get_accept_content_type_headers` 方法，默认情况下，`nose2`：
- en: Will load this method as a test.
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此方法作为测试加载。
- en: Will load this method as the `setUp` method for each test.
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此方法作为每个测试的 `setUp` 方法加载。
- en: Won't load this method as a test.
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不会将此方法作为测试加载。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we set up a testing environment. We installed nose2 to make
    it easy to discover and execute unit tests, and we created a new database to be
    used for testing. We wrote a first round of unit tests, measured test coverage,
    and then we wrote additional unit tests to improve test coverage. Finally, we
    understood many considerations for deployment and scalability.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们设置了测试环境。我们安装了 nose2 以便于发现和执行单元测试，并创建了一个新的数据库用于测试。我们编写了一轮单元测试，测量了测试覆盖率，然后编写了额外的单元测试以提高测试覆盖率。最后，我们了解了关于部署和可扩展性的许多考虑因素。
- en: Now that we have built a complex API with Flask combined with Flask RESTful,
    and we tested it, we will move to another popular Python Web framework, Tornado,
    which is what we are going to discuss in the next chapter.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用 Flask 结合 Flask RESTful 构建了一个复杂的 API，并且对其进行了测试，接下来我们将转向另一个流行的 Python
    Web 框架，Tornado，这也是我们将在下一章中讨论的内容。
