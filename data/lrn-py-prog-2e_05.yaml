- en: Saving Time and Memory
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节省时间和内存
- en: '"It''s not the daily increase but daily decrease. Hack away at the unessential."–
    Bruce Lee'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “不是每天增加，而是每天减少。砍掉不必要的部分。”- 李小龙
- en: I love this quote from Bruce Lee. He was such a wise man! Especially, the second
    part, <q class="calibre30">"*hack away at the unessential"*</q>, is to me what
    makes a computer program elegant. After all, if there is a better way of doing
    things so that we don't waste time or memory, why not?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢李小龙的这句话。他是一个很聪明的人！特别是第二部分，“*砍掉不必要的部分*”，对我来说是使计算机程序优雅的原因。毕竟，如果有更好的方法来做事情，这样我们就不会浪费时间或内存，为什么不呢？
- en: 'Sometimes, there are valid reasons for not pushing our code up to the maximum
    limit: for example, sometimes to achieve a negligible improvement, we have to
    sacrifice on readability or maintainability. Does it make any sense to have a
    web page served in 1 second with unreadable, complicated code, when we can serve
    it in 1.05 seconds with readable, clean code? No, it makes no sense.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，不将我们的代码推向最大限度是有合理的原因的：例如，有时为了实现微不足道的改进，我们必须牺牲可读性或可维护性。当我们可以用可读性强、清晰的代码在1.05秒内提供网页，而不是用难以理解、复杂的代码在1秒内提供网页时，这是没有意义的。
- en: On the other hand, sometimes it's perfectly reasonable to try to shave off a
    millisecond from a function, especially when the function is meant to be called
    thousands of times. Every millisecond you save there means one second saved per
    thousands of calls, and this could be meaningful for your application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，有时候从一个函数中削减一毫秒是完全合理的，特别是当这个函数被调用数千次时。你在那里节省的每一毫秒意味着每一千次调用节省一秒，这对你的应用可能是有意义的。
- en: In light of these considerations, the focus of this chapter will not be to give
    you the tools to push your code to the absolute limits of performance and optimization
    "no matter what," but rather, to enable you to write efficient, elegant code that
    reads well, runs fast, and doesn't waste resources in an obvious way.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这些考虑，本章的重点不是为你提供将代码推向性能和优化的绝对极限的工具，“不管怎样”，而是使你能够编写高效、优雅的代码，读起来流畅，运行快速，并且不会明显浪费资源。
- en: 'In this chapter, we are going to cover the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: The map, zip, and filter functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: map、zip和filter函数
- en: Comprehensions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推导式
- en: Generators
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器
- en: 'I will perform several measurements and comparisons, and cautiously draw some
    conclusions. Please do keep in mind that on a different box with a different setup
    or a different operating system, results may vary. Take a look at this code:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我将进行几项测量和比较，并谨慎得出一些结论。请记住，在一个不同的盒子上，使用不同的设置或不同的操作系统，结果可能会有所不同。看看这段代码：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Both functions return the square of `n`, but which is faster? From a simple
    benchmark I ran on them, it looks like the second is slightly faster. If you think
    about it, it makes sense: calculating the power of a number involves multiplication
    and therefore, whatever algorithm you may use to perform the power operation,
    it''s not likely to beat a simple multiplication such as the one in `square2`.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数都返回`n`的平方，但哪个更快？从我对它们进行的简单基准测试来看，第二个似乎稍微更快。如果你仔细想想，这是有道理的：计算一个数字的幂涉及乘法，因此，无论你使用什么算法来执行幂运算，它都不太可能击败`square2`中的简单乘法。
- en: Do we care about this result? In most cases, no. If you're coding an e-commerce
    website, chances are you won't ever even need to raise a number to the second
    power, and if you do, it's likely to be a sporadic operation. You don't need to
    concern yourself with saving a fraction of a microsecond on a function you call
    a few times.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在乎这个结果吗？在大多数情况下，不在乎。如果你正在编写一个电子商务网站，很可能你甚至不需要将一个数字提高到二次方，如果你需要，这可能是一个零星的操作。你不需要担心在你调用几次的函数上节省一小部分微秒。
- en: So, when does optimization become important? One very common case is when you
    have to deal with huge collections of data. If you're applying the same function
    on a million `customer` objects, then you want your function to be tuned up to
    its best. Gaining 1/10 of a second on a function called one million times saves
    you 100,000 seconds, which is about 27.7 hours. That's not the same, right? So,
    let's focus on collections, and let's see which tools Python gives you to handle
    them with efficiency and grace.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，优化什么时候变得重要呢？一个非常常见的情况是当你必须处理大量的数据集时。如果你在一百万个“客户”对象上应用相同的函数，那么你希望你的函数调整到最佳状态。在一个被调用一百万次的函数上节省1/10秒，可以节省你100,000秒，大约27.7小时。这不一样，对吧？所以，让我们专注于集合，让我们看看Python给你提供了哪些工具来高效优雅地处理它们。
- en: Many of the concepts we will see in this chapter are based on those of the iterator
    and iterable. Simply put, the ability for an object to return its next element
    when asked, and to raise a `StopIteration` exception when exhausted. We'll see
    how to code a custom iterator and iterable objects in [Chapter 6](part0163.html#4REBM0-2ddb708647cc4530a187c2c6c0e9acfe),
    *OOP, Decorators, and Iterators*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中看到的许多概念都是基于迭代器和可迭代对象的概念。简单地说，当要求一个对象返回其下一个元素时，以及在耗尽时引发`StopIteration`异常的能力。我们将看到如何在[第6章](part0163.html#4REBM0-2ddb708647cc4530a187c2c6c0e9acfe)中编写自定义迭代器和可迭代对象，*面向对象编程、装饰器和迭代器*。
- en: 'Due to the nature of the objects we''re going to explore in this chapter, I
    was often forced to wrap the code in a `list` constructor. This is because passing
    an iterator/generator to `list(...)` exhausts it and puts all the generated items
    in a newly created list, which I can easily print to show you its content. This
    technique hinders readability, so let me introduce an alias for list:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在本章中探讨的对象的性质，我经常被迫将代码包装在`list`构造函数中。这是因为将迭代器/生成器传递给`list(...)`会耗尽它，并将所有生成的项目放入一个新创建的列表中，我可以轻松地打印出来显示它的内容。这种技术会影响可读性，所以让我介绍一个`list`的别名：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Of the three sections I have highlighted, the first one is the call we need
    to do in order to show what would be generated by `range(7)`, the second one is
    the moment when I create the alias to list (I chose the hopefully unobtrusive
    underscore), and the third one is the equivalent call, when I use the alias instead
    of list.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经突出显示的三个部分中，第一个是我们需要执行的调用，以便显示`range(7)`生成的内容，第二个是我创建别名到`list`的时刻（我选择了希望不引人注目的下划线），第三个是等效的调用，当我使用别名而不是`list`时。
- en: Hopefully readability will benefit from this, and please keep in mind that I
    will assume this alias to have been defined for all the code in this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这样做可以提高可读性，请记住，我将假设这个别名已经在本章的所有代码中定义了。
- en: The map, zip, and filter functions
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: map、zip和filter函数
- en: 'We''ll start by reviewing `map`, `filter`, and `zip`, which are the main built-in
    functions one can employ when handling collections, and then we''ll learn how
    to achieve the same results using two very important constructs: **comprehensions**
    and **generators**. Fasten your seatbelt!'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从回顾`map`、`filter`和`zip`开始，这些是处理集合时可以使用的主要内置函数，然后我们将学习如何使用两个非常重要的构造来实现相同的结果：**推导**和**生成器**。系好安全带！
- en: map
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地图
- en: 'According to the official Python documentation:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 根据官方Python文档：
- en: map(function, iterable, ...) returns an iterator that applies function to every
    item of iterable, yielding the results. If additional iterable arguments are passed,
    function must take that many arguments and is applied to the items from all iterables
    in parallel. With multiple iterables, the iterator stops when the shortest iterable
    is exhausted.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: map(function, iterable, ...)返回一个迭代器，它将函数应用于可迭代对象的每个项目，产生结果。如果传递了额外的可迭代参数，函数必须接受相同数量的参数，并且会并行应用于所有可迭代对象的项目。对于多个可迭代对象，当最短的可迭代对象耗尽时，迭代器会停止。
- en: 'We will explain the concept of yielding later on in the chapter. For now, let''s
    translate this into code—we''ll use a `lambda` function that takes a variable
    number of positional arguments, and just returns them as a tuple:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面解释yielding的概念。现在，让我们将其翻译成代码——我们将使用一个接受可变数量的位置参数的`lambda`函数，并将它们返回为一个元组：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, you can see why we have to wrap calls in `list(...)`
    (or its alias, `_`, in this case). Without it, I get the string representation
    of a `map` object, which is not really useful in this context, is it?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你可以看到为什么我们必须用`list(...)`（或者在这种情况下使用它的别名`_`）来包装调用。没有它，我会得到一个`map`对象的字符串表示，这在这种情况下并不真正有用，是吗？
- en: You can also notice how the elements of each iterable are applied to the function;
    at first, the first element of each iterable, then the second one of each iterable,
    and so on. Notice also that `map` stops when the shortest of the iterables we
    called it with is exhausted. This is actually a very nice behavior; it doesn't
    force us to level off all the iterables to a common length, and it doesn't break
    if they aren't all the same length.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以注意到每个可迭代对象的元素是如何应用于函数的；首先是每个可迭代对象的第一个元素，然后是每个可迭代对象的第二个元素，依此类推。还要注意，`map`在我们调用它的可迭代对象中最短的一个耗尽时停止。这实际上是一种非常好的行为；它不强迫我们将所有可迭代对象平齐到一个公共长度，并且如果它们的长度不相同时也不会中断。
- en: '`map` is very useful when you have to apply the same function to one or more
    collections of objects. As a more interesting example, let''s see the **decorate-sort-undecorate**
    idiom (also known as **Schwartzian transform**). It''s a technique that was extremely
    popular when Python sorting wasn''t providing *key-functions*, and therefore is
    less used today, but it''s a cool trick that still comes in handy once in a while.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当你必须将相同的函数应用于一个或多个对象集合时，`map`非常有用。作为一个更有趣的例子，让我们看看**装饰-排序-解除装饰**惯用法（也称为**Schwartzian
    transform**）。这是一种在Python排序没有提供*key-functions*时非常流行的技术，因此今天使用较少，但偶尔还是会派上用场的一个很酷的技巧。
- en: 'Let''s see a variation of it in the next example: we want to sort in descending
    order by the sum of credits accumulated by students, so to have the best student
    at position 0\. We write a function to produce a decorated object, we sort, and
    then we undecorate. Each student has credits in three (possibly different) subjects.
    In this context, to decorate an object means to transform it, either adding extra
    data to it, or putting it into another object, in a way that allows us to be able
    to sort the original objects the way we want. This technique has nothing to do
    with Python decorators, which we will explore later on in the book.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一个例子中看一个变体：我们想按照学生所累积的学分总和降序排序，以便将最好的学生放在位置0。我们编写一个函数来生成一个装饰对象，然后进行排序，然后进行undecorate。每个学生在三个（可能不同的）科目中都有学分。在这种情况下，装饰对象意味着以一种允许我们按照我们想要的方式对原始对象进行排序的方式来转换它，无论是向其添加额外数据，还是将其放入另一个对象中。这种技术与Python装饰器无关，我们将在本书后面探讨。
- en: 'After the sorting, we revert the decorated objects to get the original ones
    from them. This is called to undecorate:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在排序之后，我们将装饰的对象恢复为它们的原始对象。这被称为undecorate：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s start by understanding what each student object is. In fact, let''s
    print the first one:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先了解每个学生对象是什么。实际上，让我们打印第一个：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can see that it''s a dictionary with two keys: `id` and `credits`. The
    value of `credits` is also a dictionary in which there are three subject/grade
    key/value pairs. As I''m sure you recall from our visit in the data structures
    world, calling `dict.values()` returns an object similar to `iterable`, with only
    the values. Therefore, `sum(student[''credits''].values())` for the first student
    is equivalent to `sum((9, 6, 7))`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到它是一个具有两个键的字典：`id`和`credits`。`credits`的值也是一个字典，在其中有三个科目/成绩键/值对。正如你在数据结构世界中所记得的，调用`dict.values()`会返回一个类似于`iterable`的对象，只有值。因此，第一个学生的`sum(student['credits'].values())`等同于`sum((9,
    6, 7))`。
- en: 'Let''s print the result of calling decorate with the first student:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打印调用decorate与第一个学生的结果：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If we decorate all the students like this, we can sort them on their total amount
    of credits by just sorting the list of tuples. In order to apply the decoration
    to each item in students, we call `map(decorate, students)`. Then we sort the
    result, and then we undecorate in a similar fashion. If you have gone through
    the previous chapters correctly, understanding this code shouldn't be too hard.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对所有学生都这样装饰，我们可以通过仅对元组列表进行排序来按学分总额对它们进行排序。为了将装饰应用到students中的每个项目，我们调用`map(decorate,
    students)`。然后我们对结果进行排序，然后以类似的方式进行解除装饰。如果你已经正确地阅读了之前的章节，理解这段代码不应该太难。
- en: 'Printing students after running the whole code yields:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 运行整个代码后打印学生：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: And you can see, by the order of the student objects, that they have indeed
    been sorted by the sum of their credits.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，根据学生对象的顺序，它们确实已经按照他们的学分总和进行了排序。
- en: For more on the *decorate-sort-undecorate* idiom, there's a very nice introduction
    in the sorting how-to section of the official Python documentation ([https://docs.python.org/3.7/howto/sorting.html#the-old-way-using-decorate-sort-undecorate](https://docs.python.org/3.7/howto/sorting.html#the-old-way-using-decorate-sort-undecorate)).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有关*装饰-排序-解除装饰*习惯用法的更多信息，请参阅官方Python文档的排序指南部分（[https://docs.python.org/3.7/howto/sorting.html#the-old-way-using-decorate-sort-undecorate](https://docs.python.org/3.7/howto/sorting.html#the-old-way-using-decorate-sort-undecorate)）。
- en: 'One thing to notice about the sorting part: what if two or more students share
    the same total sum? The sorting algorithm would then proceed to sort the tuples
    by comparing the `student` objects with each other. This doesn''t make any sense,
    and in more complex cases, could lead to unpredictable results, or even errors.
    If you want to be sure to avoid this issue, one simple solution is to create a
    three-tuple instead of a two-tuple, having the sum of credits in the first position,
    the position of the `student` object in the `students` list in the second one,
    and the `student` object itself in the third one. This way, if the sum of credits
    is the same, the tuples will be sorted against the position, which will always
    be different and therefore enough to resolve the sorting between any pair of tuples.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 关于排序部分要注意的一件事是：如果两个或更多的学生总分相同怎么办？排序算法将继续通过比较`student`对象来对元组进行排序。这没有任何意义，在更复杂的情况下，可能会导致不可预测的结果，甚至错误。如果你想确保避免这个问题，一个简单的解决方案是创建一个三元组而不是两元组，将学分总和放在第一个位置，`students`列表中`student`对象的位置放在第二个位置，`student`对象本身放在第三个位置。这样，如果学分总和相同，元组将根据位置进行排序，位置总是不同的，因此足以解决任何一对元组之间的排序问题。
- en: zip
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: zip
- en: We've already covered `zip` in the previous chapters, so let's just define it
    properly and then I want to show you how you could combine it with `map`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在之前的章节中介绍了`zip`，所以让我们正确定义它，然后我想向你展示如何将它与`map`结合起来使用。
- en: 'According to the Python documentation:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Python文档：
- en: zip(*iterables) returns an iterator of tuples, where the i-th tuple contains
    the i-th element from each of the argument sequences or iterables. The iterator
    stops when the shortest input iterable is exhausted. With a single iterable argument,
    it returns an iterator of 1-tuples. With no arguments, it returns an empty iterator.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: zip(*iterables)返回一个元组的迭代器，其中第i个元组包含来自每个参数序列或可迭代对象的第i个元素。当最短的输入可迭代对象耗尽时，迭代器停止。使用单个可迭代对象参数时，它返回一个1元组的迭代器。没有参数时，它返回一个空的迭代器。
- en: 'Let''s see an example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we're zipping together the average and the grade for
    the last exam, for each student. Notice how easy it is to reproduce `zip` using
    `map` (last two instructions of the example). Here as well, to visualize results
    we have to use our `_` alias.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们将每个学生的平均值和最后一次考试的成绩进行了`zip`。注意使用`map`来复制`zip`是多么容易（示例的最后两条指令）。同样，在可视化结果时，我们必须使用我们的`_`别名。
- en: 'A simple example on the combined use of `map` and `zip` could be a way of calculating
    the element-wise maximum amongst sequences, that is, the maximum of the first
    element of each sequence, then the maximum of the second one, and so on:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`和`zip`的结合使用的一个简单例子可能是计算序列中每个元素的最大值，即每个序列的第一个元素的最大值，然后是第二个元素的最大值，依此类推：'
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice how easy it is to calculate the max values of three sequences. `zip`
    is not strictly needed of course, we could just use `map`. Sometimes it's hard,
    when showing a simple example, to grasp why using a technique might be good or
    bad. We forget that we aren't always in control of the source code, we might have
    to use a third-party library, which we can't change the way we want. Having different
    ways to work with data is therefore really helpful.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意计算三个序列的最大值是多么容易。当然，严格来说并不一定需要`zip`，我们可以使用`map`。有时候在展示一个简单的例子时，很难理解为什么使用某种技术可能是好的或坏的。我们忘记了我们并不总是能控制源代码，我们可能必须使用第三方库，而我们无法按照自己的意愿进行更改。因此，有不同的方法来处理数据真的很有帮助。
- en: filter
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 筛选
- en: 'According to the Python documentation:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Python文档：
- en: filter(function, iterable) construct an iterator from those elements of iterable
    for which function returns True. iterable may be either a sequence, a container
    which supports iteration, or an iterator. If function is None, the identity function
    is assumed, that is, all elements of iterable that are false are removed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: filter(function, iterable)从可迭代对象中构建一个迭代器，其中包含函数返回True的那些元素。可迭代对象可以是序列、支持迭代的容器，或者是迭代器。如果函数为None，则假定为恒等函数，即删除可迭代对象中所有为假的元素。
- en: 'Let''s see a very quick example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个非常快速的例子：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, notice how the second call to `filter` is equivalent
    to the first one. If we pass a function that takes one argument and returns the
    argument itself, only those arguments that are `True` will make the function return
    `True`, therefore this behavior is exactly the same as passing `None`. It's often
    a very good exercise to mimic some of the built-in Python behaviors. When you
    succeed, you can say you fully understand how Python behaves in a specific situation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，注意第二次调用`filter`等同于第一次调用。如果我们传递一个接受一个参数并返回参数本身的函数，只有那些为`True`的参数才会使函数返回`True`，因此这种行为与传递`None`完全相同。模仿一些内置的Python行为通常是一个很好的练习。当你成功时，你可以说你完全理解了Python在特定情况下的行为。
- en: 'Armed with `map`, `zip`, and `filter` (and several other functions from the
    Python standard library) we can massage sequences very effectively. But those
    functions are not the only way to do it. So let''s see one of the nicest features
    of Python: comprehensions.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`map`，`zip`和`filter`（以及Python标准库中的其他几个函数），我们可以非常有效地处理序列。但这些函数并不是唯一的方法。所以让我们看看Python最好的特性之一：推导。
- en: Comprehensions
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推导
- en: Comprehensions are a concise notation, both perform some operation for a collection
    of elements, and/or select a subset of them that meet some condition. They are
    borrowed from the functional programming language Haskell ([https://www.haskell.org/](https://www.haskell.org/)),
    and contribute to giving Python a functional flavor, together with iterators and
    generators.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 推导是一种简洁的表示法，既对一组元素执行某些操作，又/或选择满足某些条件的子集。它们借鉴自函数式编程语言Haskell（[https://www.haskell.org/](https://www.haskell.org/)），并且与迭代器和生成器一起为Python增添了函数式风味。
- en: 'Python offers you different types of comprehensions: `list`, `dict`, and `set`.
    We''ll concentrate on the first one for now, and then it will be easy to explain
    the other two.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Python为您提供不同类型的推导：`list`，`dict`和`set`。我们现在将集中在第一个上，然后解释另外两个将会很容易。
- en: 'Let''s start with a very simple example. I want to calculate a list with the
    squares of the first 10 natural numbers. How would you do it? There are a couple
    of equivalent ways:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个非常简单的例子开始。我想计算一个包含前10个自然数的平方的列表。你会怎么做？有几种等效的方法：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding example should be nothing new for you. Let''s see how to achieve
    the same result using a `list` comprehension:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子对你来说应该不是什么新鲜事。让我们看看如何使用`list`推导来实现相同的结果：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As simple as that. Isn''t it elegant? Basically we have put a `for` loop within
    square brackets. Let''s now filter out the odd squares. I''ll show you how to
    do it with `map` and `filter` first, and then using a `list` comprehension again:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这么简单。是不是很优雅？基本上我们在方括号内放了一个`for`循环。现在让我们过滤掉奇数平方。我将首先向你展示如何使用`map`和`filter`，然后再次使用`list`推导：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'I think that now the difference in readability is evident. The `list` comprehension
    reads much better. It''s almost English: give me all squares (`n ** 2`) for `n`
    between `0` and `9` if `n` is even.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为现在可读性的差异是明显的。列表推导读起来好多了。它几乎是英语：如果n是偶数，给我所有0到9之间的n的平方（n ** 2）。
- en: 'According to the Python documentation:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Python文档：
- en: A list comprehension consists of brackets containing an expression followed
    by a for clause, then zero or more for or if clauses. The result will be a new
    list resulting from evaluating the expression in the context of the for and if
    clauses which follow it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导由包含表达式的括号组成，后面跟着一个for子句，然后是零个或多个for或if子句。结果将是一个新列表，由在for和if子句的上下文中评估表达式得出。
- en: Nested comprehensions
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套推导
- en: 'Let''s see an example of nested loops. It''s very common when dealing with
    algorithms to have to iterate on a sequence using two placeholders. The first
    one runs through the whole sequence, left to right. The second one as well, but
    it starts from the first one, instead of 0\. The concept is that of testing all
    pairs without duplication. Let''s see the classical `for` loop equivalent:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个嵌套循环的例子。在处理算法时，经常需要使用两个占位符对序列进行迭代是很常见的。第一个占位符从左到右遍历整个序列。第二个也是如此，但它从第一个开始，而不是从0开始。这个概念是为了测试所有对而不重复。让我们看看经典的`for`循环等价：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you print pairs at the end, you get:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在最后打印出对，你会得到：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'All the tuples with the same letter are those where `b` is at the same position
    as `a`. Now, let''s see how we can translate this in a `list` comprehension:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 所有具有相同字母的元组都是`b`与`a`处于相同位置的元组。现在，让我们看看如何将其转换为`list`推导：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This version is just two lines long and achieves the same result. Notice that
    in this particular case, because the `for` loop over `b` has a dependency on `a`,
    it must follow the `for` loop over `a` in the comprehension. If you swap them
    around, you'll get a name error.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本只有两行长，但实现了相同的结果。请注意，在这种特殊情况下，因为`for`循环在`b`上有一个对`a`的依赖，所以它必须在推导中跟在`a`上的`for`循环之后。如果你交换它们，你会得到一个名称错误。
- en: Filtering a comprehension
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤推导
- en: 'We can apply filtering to a comprehension. Let''s do it first with `filter`.
    Let''s find all Pythagorean triples whose short sides are numbers smaller than
    10\. We obviously don''t want to test a combination twice, and therefore we''ll
    use a trick similar to the one we saw in the previous example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对推导应用过滤。让我们首先用`filter`来做。让我们找出所有勾股数的短边小于10的三元组。显然，我们不想测试两次组合，因此我们将使用与我们在上一个例子中看到的类似的技巧：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A **Pythagorean triple** is a triple (*a*, *b*, *c*) of integer numbers satisfying the
    equation *a² + b² = c²*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 勾股数是满足整数方程a² + b² = c²的整数三元组（a，b，c）。
- en: In the preceding code, we generated a list of *three-tuples*, `triples`. Each
    tuple contains two integer numbers (the legs), and the hypotenuse of the Pythagorean
    triangle whose legs are the first two numbers in the tuple. For example, when
    `a` is `3` and `b` is `4`, the tuple will be `(3, 4, 5.0)`, and when `a` is `5`
    and `b` is `7`, the tuple will be `(5, 7, 8.602325267042627)`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们生成了一个*三元组*列表`triples`。每个元组包含两个整数（腿）和勾股定理三角形的斜边，其腿是元组中的前两个数字。例如，当`a`为`3`，`b`为`4`时，元组将是`(3,
    4, 5.0)`，当`a`为`5`，`b`为`7`时，元组将是`(5, 7, 8.602325267042627)`。
- en: After having all the `triples` done, we need to filter out all those that don't
    have a hypotenuse that is an integer number. In order to do this, we filter based
    on `float_number.is_integer()` being `True`. This means that of the two example
    tuples I showed you before, the one with `5.0` hypotenuse will be retained, while
    the one with the `8.602325267042627` hypotenuse will be discarded.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有`triples`之后，我们需要过滤掉所有没有整数斜边的三元组。为了做到这一点，我们基于`float_number.is_integer()`为`True`进行过滤。这意味着在我之前向您展示的两个示例元组中，具有`5.0`斜边的元组将被保留，而具有`8.602325267042627`斜边的元组将被丢弃。
- en: 'This is good, but I don''t like that the triple has two integer numbers and
    a float. They are supposed to be all integers, so let''s use `map` to fix this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但我不喜欢三元组有两个整数和一个浮点数。它们应该都是整数，所以让我们使用`map`来修复这个问题：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Notice the step we added. We take each element in `triples` and we slice it,
    taking only the first two elements in it. Then, we concatenate the slice with
    a one-tuple, in which we put the integer version of that float number that we
    didn''t like. Seems like a lot of work, right? Indeed it is. Let''s see how to
    do all this with a `list` comprehension:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们添加的步骤。我们取`triples`中的每个元素，并对其进行切片，仅取其中的前两个元素。然后，我们将切片与一个一元组连接起来，在其中放入我们不喜欢的那个浮点数的整数版本。看起来像是很多工作，对吧？确实是。让我们看看如何使用`list`推导来完成所有这些工作：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: I know. It's much better, isn't it? It's clean, readable, shorter. In other
    words, it's elegant.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道。这样会好得多，不是吗？它干净、可读、更短。换句话说，它是优雅的。
- en: I'm going quite fast here, as anticipated in the *Summary* of [Chapter 4](part0108.html#36VSO0-2ddb708647cc4530a187c2c6c0e9acfe), *Functions,
    the Building Blocks of Code*. Are you playing with this code? If not, I suggest
    you do. It's very important that you play around, break things, change things,
    see what happens. Make sure you have a clear understanding of what is going on.
    You want to become a ninja, right?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里走得很快，就像在[第4章](part0108.html#36VSO0-2ddb708647cc4530a187c2c6c0e9acfe)的*摘要*中预期的那样，*函数，代码的构建块*。您在玩这个代码吗？如果没有，我建议您这样做。非常重要的是，您要玩耍，打破事物，改变事物，看看会发生什么。确保您清楚地了解发生了什么。您想成为一个忍者，对吧？
- en: dict comprehensions
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: dict推导
- en: 'Dictionary and `set` comprehensions work exactly like the list ones, only there
    is a little difference in the syntax. The following example will suffice to explain
    everything you need to know:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 字典和`set`推导的工作方式与列表推导完全相同，只是语法上有一点不同。以下示例足以解释您需要了解的所有内容：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you print `lettermap`, you will see the following (I omitted the middle
    results, you get the gist):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果打印`lettermap`，您将看到以下内容（我省略了中间结果，您会明白的）：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'What happens in the preceding code is that we''re feeding the `dict` constructor
    with a comprehension (technically, a generator expression, we''ll see it in a
    bit). We tell the `dict` constructor to make *key*/*value* pairs from each tuple
    in the comprehension. We enumerate the sequence of all lowercase ASCII letters,
    starting from `1`, using `enumerate`. Piece of cake. There is also another way
    to do the same thing, which is closer to the other dictionary syntax:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中发生的是，我们正在用推导（技术上是生成器表达式，我们稍后会看到）向`dict`构造函数提供数据。我们告诉`dict`构造函数从推导中的每个元组中制作*键*/*值*对。我们使用`enumerate`列举所有小写ASCII字母的序列，从`1`开始。小菜一碟。还有另一种做同样事情的方法，更接近其他字典语法：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'It does exactly the same thing, with a slightly different syntax that highlights
    a bit more of the *key: value* part.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 它确实做了完全相同的事情，只是语法略有不同，更突出了*键：值*部分。
- en: 'Dictionaries do not allow duplication in the keys, as shown in the following
    example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 字典不允许键中有重复，如下例所示：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We create a dictionary with keys, the letters in the `''Hello''` string, and
    values of the same letters, but with the case swapped. Notice there is only one
    `''l'': ''L''` pair. The constructor doesn''t complain, it simply reassigns duplicates
    to the latest value. Let''s make this clearer with another example; let''s assign
    to each key its position in the string:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '我们创建一个字典，其中键是`''Hello''`字符串中的字母，值是相同的字母，但大小写不同。请注意只有一个`''l'': ''L''`对。构造函数不会抱怨，它只是将重复的键重新分配给最新的值。让我们通过另一个例子来更清楚地说明这一点；让我们为每个键分配其在字符串中的位置：'
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Notice the value associated with the letter `''l'': 3`. The `''l'': 2` pair
    isn''t there; it has been overridden by `''l'': 3`.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意与字母`''l''`关联的值：`3`。`''l'': 2`对不在那里；它已被`''l'': 3`覆盖。'
- en: set comprehensions
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: set推导
- en: 'The `set` comprehensions are very similar to list and dictionary ones. Python
    allows both the `set()` constructor to be used, or the explicit `{}` syntax. Let''s
    see one quick example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`set`推导非常类似于列表和字典推导。Python允许使用`set()`构造函数，或显式的`{}`语法。让我们看一个快速的例子：'
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice how for `set` comprehensions, as for dictionaries, duplication is not
    allowed and therefore the resulting set has only four letters. Also, notice that
    the expressions assigned to `letters1` and `letters2` produce equivalent sets.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于`set`推导和字典推导，不允许重复，因此生成的集合只有四个字母。还要注意，分配给`letters1`和`letters2`的表达式产生了等效的集合。
- en: The syntax used to create `letters2` is very similar to the one we can use to
    create a dictionary comprehension. You can spot the difference only by the fact
    that dictionaries require keys and values, separated by columns, while sets don't.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 用于创建`letters2`的语法与用于创建字典推导的语法非常相似。您只能通过字典需要使用冒号分隔的键和值来区分它们，而集合则不需要。
- en: Generators
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器
- en: '**Generators** are very powerful tool that Python gifts us with. They are based
    on the concepts of *iteration*, as we said before, and they allow for coding patterns
    that combine elegance with efficiency.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**生成器**是Python赋予我们的非常强大的工具。它们基于*迭代*的概念，正如我们之前所说的，它们允许结合优雅和高效的编码模式。'
- en: 'Generators are of two types:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器有两种类型：
- en: '**Generator functions**: These are very similar to regular functions, but instead
    of returning results through return statements, they use yield, which allows them
    to suspend and resume their state between each call'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成器函数**：这些与常规函数非常相似，但是它们不是通过返回语句返回结果，而是使用yield，这使它们能够在每次调用之间暂停和恢复它们的状态。'
- en: '**Generator expressions**: These are very similar to the `list` comprehensions
    we''ve seen in this chapter, but instead of returning a list they return an object
    that produces results one by one'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成器表达式**：这些与我们在本章中看到的`list`推导非常相似，但是它们不是返回一个列表，而是返回一个逐个产生结果的对象。'
- en: Generator functions
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器函数
- en: Generator functions behave like regular functions in all respects, except for
    one difference. Instead of collecting results and returning them at once, they
    are automatically turned into iterators that yield results one at a time when
    you call `next` on them. Generator functions are automatically turned into their
    own iterators by Python.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数在所有方面都像常规函数一样，只有一个区别。它们不是一次性收集结果并返回它们，而是在每次调用`next`时自动转换为产生结果的迭代器。
- en: This is all very theoretical so, let's make it clear why such a mechanism is
    so powerful, and then let's see an example.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都是非常理论的，所以让我们清楚地说明为什么这样的机制是如此强大，然后让我们看一个例子。
- en: Say I asked you to count out loud from 1 to 1,000,000\. You start, and at some
    point I ask you to stop. After some time, I ask you to resume. At this point,
    what is the minimum information you need to be able to resume correctly? Well,
    you need to remember the last number you called. If I stopped you after 31,415,
    you will just go on with 31,416, and so on.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我让你大声数数从1数到1,000,000。你开始了，然后在某个时候我让你停下来。过了一段时间，我让你继续。在这一点上，你需要记住能够正确恢复的最小信息是什么？嗯，你需要记住你最后一个叫的数字。如果我在31,415后停止了你，你就会继续31,416，依此类推。
- en: The point is, you don't need to remember all the numbers you said before 31,415,
    nor do you need them to be written down somewhere. Well, you may not know it,
    but you're behaving like a generator already!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 重点是，你不需要记住31,415之前说的所有数字，也不需要它们被写在某个地方。嗯，你可能不知道，但你已经像一个生成器一样行为了！
- en: 'Take a good look at the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看一下以下代码：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The result of the two `print` statements will be the same: `[0, 1, 4, 9, 16,
    25, 36, 49, 64, 81]`. But there is a huge difference between the two functions.
    `get_squares` is a classic function that collects all the squares of numbers in
    [0, *n*) in a list, and returns it. On the other hand, `get_squares_gen` is a
    generator, and behaves very differently. Each time the interpreter reaches the
    `yield` line, its execution is suspended. The only reason those `print` statements
    return the same result is because we fed `get_squares_gen` to the `list` constructor,
    which exhausts the generator completely by asking the next element until a `StopIteration`
    is raised. Let''s see this in detail:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`print`语句的结果将是相同的：`[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]`。但是这两个函数之间有很大的区别。`get_squares`是一个经典函数，它收集[0，*n*)范围内所有数字的平方，并将其返回为列表。另一方面，`get_squares_gen`是一个生成器，行为非常不同。每当解释器到达`yield`行时，它的执行就会被暂停。这些`print`语句返回相同结果的唯一原因是因为我们将`get_squares_gen`传递给`list`构造函数，它通过请求下一个元素直到引发`StopIteration`来完全耗尽生成器。让我们详细看一下：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding code, each time we call `next` on the generator object, we
    either start it (first `next`) or make it resume from the last suspension point
    (any other `next`).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，每次我们在生成器对象上调用`next`时，要么启动它（第一个`next`），要么使它从上次暂停的地方恢复（任何其他`next`）。
- en: The first time we call `next` on it, we get `0`, which is the square of `0`,
    then `1`, then `4`, then `9`, and since the `for` loop stops after that (`n` is
    `4`), then the generator naturally ends. A classic function would at that point
    just return `None`, but in order to comply with the iteration protocol, a generator
    will instead raise a `StopIteration` exception.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次在它上面调用`next`时，我们得到`0`，这是`0`的平方，然后是`1`，然后是`4`，然后是`9`，由于`for`循环在那之后停止了（`n`是`4`），然后生成器自然结束了。经典函数在那一点上只会返回`None`，但为了符合迭代协议，生成器将会引发`StopIteration`异常。
- en: This explains how a `for` loop works. When you call `for k in range(n)`, what
    happens under the hood is that the `for` loop gets an iterator out of `range(n)`
    and starts calling `next` on it, until `StopIteration` is raised, which tells
    the `for` loop that the iteration has reached its end.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这解释了`for`循环的工作原理。当你调用`for k in range(n)`时，在幕后发生的是`for`循环从`range(n)`中获取一个迭代器，并开始在其上调用`next`，直到引发`StopIteration`，这告诉`for`循环迭代已经结束。
- en: Having this behavior built into every iteration aspect of Python makes generators
    even more powerful because once we write them, we'll be able to plug them into
    whatever iteration mechanism we want.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Python的每个迭代方面内置了这种行为，这使得生成器更加强大，因为一旦我们编写它们，我们就能够将它们插入到我们想要的任何迭代机制中。
- en: 'At this point, you''re probably asking yourself why you would want to use a
    generator instead of a regular function. Well, the title of this chapter should
    suggest the answer. I''ll talk about performances later, so for now let''s concentrate
    on another aspect: sometimes generators allow you to do something that wouldn''t
    be possible with a simple list. For example, say you want to analyze all permutations
    of a sequence. If the sequence has a length of *N*, then the number of its permutations
    is *N!*. This means that if the sequence is 10 elements long, the number of permutations
    is 3,628,800\. But a sequence of 20 elements would have 2,432,902,008,176,640,000
    permutations. They grow factorially.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你可能会问自己为什么要使用生成器而不是普通函数。好吧，本章的标题应该暗示了答案。稍后我会谈论性能，所以现在让我们集中在另一个方面：有时生成器允许你做一些用简单列表无法做到的事情。例如，假设你想分析一个序列的所有排列。如果序列的长度为*N*，那么它的排列数就是*N!*。这意味着如果序列长度为10个元素，排列数就是3,628,800。但是20个元素的序列将有2,432,902,008,176,640,000个排列。它们呈阶乘增长。
- en: Now imagine you have a classic function that is attempting to calculate all
    permutations, put them in a list, and return it to you. With 10 elements, it would
    require probably a few dozen seconds, but for 20 elements there is simply no way
    that it can be done.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，你有一个经典函数，它试图计算所有的排列，把它们放在一个列表中，并返回给你。对于10个元素，可能需要几十秒，但对于20个元素，根本不可能完成。
- en: On the other hand, a generator function will be able to start the computation
    and give you back the first permutation, then the second, and so on. Of course
    you won't have the time to parse them all, there are too many, but at least you'll
    be able to work with some of them.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，一个生成器函数将能够开始计算并返回第一个排列，然后是第二个，依此类推。当然你没有时间解析它们所有，因为太多了，但至少你能够处理其中的一些。
- en: Remember when we were talking about the `break` statement in `for` loops? When
    we found a number dividing a *candidate prime* we were breaking the loop, and
    there was no need to go on.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们在谈论`for`循环中的`break`语句吗？当我们找到一个能整除*候选素数*的数时，我们就打破了循环，没有必要继续下去了。
- en: 'Sometimes it''s exactly the same, only the amount of data you have to iterate
    over is so huge that you cannot keep it all in memory in a list. In this case,
    generators are invaluable: they make possible what wouldn''t be possible otherwise.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有时情况完全相同，只是你需要迭代的数据量太大，无法将其全部保存在列表中。在这种情况下，生成器是非常宝贵的：它们使得原本不可能的事情成为可能。
- en: So, in order to save memory (and time), use generator functions whenever possible.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了节省内存（和时间），尽可能使用生成器函数。
- en: 'It''s also worth noting that you can use the return statement in a generator
    function. It will produce a `StopIteration` exception to be raised, effectively
    ending the iteration. This is extremely important. If a `return` statement were
    actually to make the function return something, it would break the iteration protocol.
    Python''s consistency prevents this, and allows us great ease when coding. Let''s
    see a quick example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，你可以在生成器函数中使用return语句。它将产生一个`StopIteration`异常被引发，有效地结束迭代。这是非常重要的。如果`return`语句实际上使函数返回了什么东西，它将打破迭代协议。Python的一致性防止了这种情况，并且在编码时为我们提供了极大的便利。让我们看一个快速的例子：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The preceding code yields all terms of the geometric progression, *a*, *aq*,
    *aq²*, *aq³*, .... When the progression produces a term that is greater than `100000`,
    the generator stops (with a `return` statement). Running the code produces the
    following result:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码产生了等比级数的所有项，*a*，*aq*，*aq²*，*aq³*，.... 当级数产生一个大于`100000`的项时，生成器就会停止（使用`return`语句）。
    运行代码会产生以下结果：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The next term would have been `156250`, which is too big.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个项本来会是`156250`，这太大了。
- en: Speaking about `StopIteration`, as of Python 3.5, the way that exceptions are
    handled in generators has changed. To understand the implications of the change
    is probably asking too much of you at this point, so just know that you can read
    all about it in PEP 479 ([https://legacy.python.org/dev/peps/pep-0479/](https://legacy.python.org/dev/peps/pep-0479/)).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 说到`StopIteration`，从Python 3.5开始，生成器中异常处理的方式已经发生了变化。在这一点上理解这种变化的影响可能要求你付出太多，所以只需知道你可以在PEP
    479中阅读有关它的所有内容即可（[https://legacy.python.org/dev/peps/pep-0479/](https://legacy.python.org/dev/peps/pep-0479/)）。
- en: Going beyond next
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超越next
- en: At the beginning of this chapter, I told you that generator objects are based
    on the iteration protocol. We'll see in [Chapter 6](part0163.html#4REBM0-2ddb708647cc4530a187c2c6c0e9acfe), *OOP,
    Decorators, and Iterators* a complete example of how to write a custom iterator/iterable
    object. For now, I just want you to understand how `next()` works.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我告诉过你生成器对象是基于迭代协议的。我们将在[第6章](part0163.html#4REBM0-2ddb708647cc4530a187c2c6c0e9acfe)中看到一个完整的例子，说明如何编写自定义的迭代器/可迭代对象。现在，我只是希望你理解`next()`是如何工作的。
- en: What happens when you call `next(generator)` is that you're calling the `generator.__next__()`
    method. Remember, a **method** is just a function that belongs to an object, and
    objects in Python can have special methods. `__next__()` is just one of these
    and its purpose is to return the next element of the iteration, or to raise `StopIteration`
    when the iteration is over and there are no more elements to return.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用`next(generator)`时，你调用了`generator.__next__()`方法。记住，**方法**只是属于对象的函数，而Python中的对象可以有特殊的方法。`__next__()`只是其中之一，它的目的是返回迭代的下一个元素，或者在迭代结束时引发`StopIteration`，并且没有更多的元素可以返回。
- en: If you recall, in Python, an object's special methods are also called **magic
    methods**, or **dunder** (from "double underscore") **methods**.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，在Python中，对象的特殊方法也被称为**魔术方法**，或者**dunder**（来自“双下划线”）**方法**。
- en: 'When we write a generator function, Python automatically transforms it into
    an object that is very similar to an iterator, and when we call `next(generator)`,
    that call is transformed in `generator.__next__()`. Let''s revisit the previous
    example about generating squares:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写一个生成器函数时，Python会自动将其转换为一个与迭代器非常相似的对象，当我们调用`next(generator)`时，该调用会转换为`generator.__next__()`。让我们重新讨论一下关于生成平方数的先前示例：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The result is exactly as the previous example, only this time instead of using
    the `next(squares)` proxy call, we're directly calling `squares.__next__()`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与前面的示例完全相同，只是这次我们直接调用`squares.__next__()`，而不是使用`next(squares)`代理调用。
- en: 'Generator objects have also three other methods that allow us to control their
    behavior: `send`, `throw`, and `close`. `send` allows us to communicate a value
    back to the generator object, while `throw` and `close`, respectively, allow us
    to raise an exception within the generator and close it. Their use is quite advanced
    and I won''t be covering them here in detail, but I want to spend a few words
    on `send`, with a simple example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器对象还有另外三种方法，允许我们控制它们的行为：`send`，`throw`和`close`。`send`允许我们向生成器对象发送一个值，而`throw`和`close`分别允许我们在生成器内部引发异常并关闭它。它们的使用非常高级，我不会在这里详细介绍它们，但我想在`send`上花几句话，举个简单的例子：
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding iterator creates a generator object that will run forever. You
    can keep calling it, and it will never stop. Alternatively, you can put it in
    a `for` loop, for example, `for n in counter(): ...`, and it will go on forever
    as well. But what if you wanted to stop it at some point? One solution is to use
    a variable to control the `while` loop. Something such as this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '前面的迭代器创建了一个将永远运行的生成器对象。您可以不断调用它，它永远不会停止。或者，您可以将其放入`for`循环中，例如，`for n in counter():
    ...`，它也将永远运行。但是，如果您想在某个时刻停止它怎么办？一种解决方案是使用变量来控制`while`循环。例如：'
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This will do it. We start with `stop = False`, and until we change it to `True`,
    the generator will just keep going, like before. The moment we change stop to
    `True` though, the `while` loop will exit, and the next call will raise a `StopIteration`
    exception. This trick works, but I don''t like it. We depend on an external variable,
    and this can lead to issues: what if another function changes that `stop`? Moreover,
    the code is scattered. In a nutshell, this isn''t good enough.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就可以了。我们从`stop = False`开始，直到我们将其更改为`True`，生成器将像以前一样继续运行。然而，一旦我们将`stop`更改为`True`，`while`循环将退出，并且下一次调用将引发`StopIteration`异常。这个技巧有效，但我不喜欢它。我们依赖于一个外部变量，这可能会导致问题：如果另一个函数改变了`stop`会怎么样？此外，代码是分散的。简而言之，这还不够好。
- en: 'We can make it better by using `generator.send()`. When we call `generator.send()`,
    the value that we feed to `send` will be passed in to the generator, execution
    is resumed, and we can fetch it via the `yield` expression. This is all very complicated
    when explained with words, so let''s see an example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`generator.send()`来改进它。当我们调用`generator.send()`时，我们向`send`提供的值将被传递给生成器，执行将恢复，我们可以通过`yield`表达式获取它。用文字解释这一切都很复杂，所以让我们看一个例子：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Execution of the preceding code produces the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述代码会产生以下结果：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: I think it's worth going through this code line by line, like if we were executing
    it, to see whether we can understand what's going on.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为逐行阅读这段代码是值得的，就好像我们在执行它一样，看看我们是否能理解发生了什么。
- en: We start the generator execution with a call to `next` (`#C`). Within the generator,
    `n` is set to the same value as `start`. The `while` loop is entered, execution
    stops (`#A`) and `n` (`0`) is yielded back to the caller. `0` is printed on the
    console.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用`next`(`#C`)开始生成器执行。在生成器中，`n`被设置为与`start`相同的值。进入`while`循环，执行停止（`#A`），`n`（`0`）被返回给调用者。`0`被打印在控制台上。
- en: We then call `send` (`#D`), execution resumes, and `result` is set to `'Wow!'`
    (still `#A`), then its type and value are printed on the console (`#B`). `result`
    is not `'Q'`, therefore `n` is incremented by `1` and execution goes back to the
    `while` condition, which, being `True`, evaluates to `True` (that wasn't hard
    to guess, right?). Another loop cycle begins, execution stops again (`#A`), and
    `n` (`1`) is yielded back to the caller. `1` is printed on the console.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用`send`(`#D`)，执行恢复，`result`被设置为`'Wow!'`（仍然是`#A`），然后它的类型和值被打印在控制台上（`#B`）。`result`不是`'Q'`，因此`n`增加了`1`，执行返回到`while`条件，这时，`True`被评估为`True`（这不难猜到，对吧？）。另一个循环开始，执行再次停止（`#A`），`n`（`1`）被返回给调用者。`1`被打印在控制台上。
- en: At this point, we call `next` (`#E`), execution is resumed again (`#A`), and
    because we are not sending anything to the generator explicitly, Python behaves
    exactly like functions that are not using the `return` statement; the `yield n`
    expression (`#A`) returns `None`. `result` therefore is set to `None`, and its
    type and value are yet again printed on the console (`#B`). Execution continues,
    `result` is not `'Q'` so `n` is incremented by `1`, and we start another loop
    again. Execution stops again (`#A`) and `n` (`2`) is yielded back to the caller.
    `2` is printed on the console.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们调用`next`(`#E`)，执行再次恢复（`#A`），因为我们没有明确向生成器发送任何内容，Python的行为与不使用`return`语句的函数完全相同；`yield
    n`表达式（`#A`）返回`None`。因此，`result`被设置为`None`，其类型和值再次被打印在控制台上（`#B`）。执行继续，`result`不是`'Q'`，所以`n`增加了`1`，我们再次开始另一个循环。执行再次停止（`#A`），`n`（`2`）被返回给调用者。`2`被打印在控制台上。
- en: 'And now for the grand finale: we call `send` again (`#F`), but this time we
    pass in `''Q''`, therefore when execution is resumed, `result` is set to `''Q''`
    (`#A`). Its type and value are printed on the console (`#B`), and then finally
    the `if` clause evaluates to `True` and the `while` loop is stopped by the `break`
    statement. The generator naturally terminates, which means a `StopIteration` exception
    is raised. You can see the print of its traceback on the last few lines printed
    on the console.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在到了大结局：我们再次调用`send`（`#F`），但这次我们传入了`'Q'`，因此当执行恢复时，`result`被设置为`'Q'`（`#A`）。它的类型和值被打印在控制台上（`#B`），最后`if`子句评估为`True`，`while`循环被`break`语句停止。生成器自然终止，这意味着会引发`StopIteration`异常。您可以在控制台上看到它的回溯打印在最后几行上。
- en: This is not at all simple to understand at first, so if it's not clear to you,
    don't be discouraged. You can keep reading on and then you can come back to this
    example after some time.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这一开始并不容易理解，所以如果对您来说不清楚，不要气馁。您可以继续阅读，然后过一段时间再回到这个例子。
- en: Using `send` allows for interesting patterns, and it's worth noting that `send`
    can also be used to start the execution of a generator (provided you call it with `None`).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`send`允许有趣的模式，值得注意的是`send`也可以用于启动生成器的执行（只要您用`None`调用它）。
- en: The yield from expression
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`yield from`表达式'
- en: 'Another interesting construct is the `yield from` expression. This expression
    allows you to yield values from a sub iterator. Its use allows for quite advanced
    patterns, so let''s just see a very quick example of it:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的构造是`yield from`表达式。这个表达式允许您从子迭代器中产生值。它的使用允许相当高级的模式，所以让我们快速看一个非常快速的例子：
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The previous code prints the numbers `4`, `9`, `16` on the console (on separate
    lines). By now, I expect you to be able to understand it by yourself, but let''s
    quickly recap what happens. The `for` loop outside the function gets an iterator
    from `print_squares(2, 5)` and calls `next` on it until iteration is over. Every
    time the generator is called, execution is suspended (and later resumed) on `yield
    n ** 2`, which returns the square of the current `n`. Let''s see how we can transform
    this code benefiting from the `yield from` expression:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码在控制台上打印出数字`4`，`9`，`16`（分别在不同的行上）。到现在为止，我希望您能够自己理解它，但让我们快速回顾一下发生了什么。函数外部的`for`循环从`print_squares(2,
    5)`获取一个迭代器，并在其上调用`next`，直到迭代结束。每次调用生成器时，执行都会被暂停（稍后恢复）在`yield n ** 2`上，它返回当前`n`的平方。让我们看看如何利用`yield
    from`表达式改变这段代码：
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This code produces the same result, but as you can see `yield from` is actually
    running a sub iterator, `(n ** 2 ...)`. The `yield from` expression returns to
    the caller each value the sub iterator is producing. It's shorter and it reads
    better.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码产生了相同的结果，但是您可以看到`yield from`实际上正在运行一个子迭代器`(n ** 2 ...)`。`yield from`表达式将子迭代器产生的每个值返回给调用者。它更短，阅读起来更好。
- en: Generator expressions
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器表达式
- en: Let's now talk about the other techniques to generate values one at a time.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们谈谈其他一次生成值的技术。
- en: The syntax is exactly the same as `list` comprehensions, only, instead of wrapping
    the comprehension with square brackets, you wrap it with round brackets. That
    is called a **generator expression**.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 语法与`list`推导完全相同，只是，不是用方括号包装推导，而是用圆括号包装。这就是所谓的**生成器表达式**。
- en: 'In general, generator expressions behave like equivalent `list` comprehensions,
    but there is one very important thing to remember: generators allow for one iteration
    only, then they will be exhausted. Let''s see an example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，生成器表达式的行为类似于等效的`list`推导，但有一件非常重要的事情要记住：生成器只允许一次迭代，然后它们将被耗尽。让我们看一个例子：
- en: '[PRE36]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Look at the line in which the generator expression is created and assigned the
    name `cubes_gen`. You can see it's a generator object. In order to see its elements,
    we can use a `for` loop, a manual set of calls to `next`, or simply, feed it to
    a `list` constructor, which is what I did (remember I'm using `_` as an alias).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 看看生成器表达式被创建并分配名称`cubes_gen`的行。您可以看到它是一个生成器对象。为了看到它的元素，我们可以使用`for`循环，手动调用`next`，或者简单地将其传递给`list`构造函数，这就是我所做的（记住我使用`_`作为别名）。
- en: Notice how, once the generator has been exhausted, there is no way to recover
    the same elements from it again. We need to recreate it if we want to use it from
    scratch again.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一旦生成器被耗尽，就没有办法再次从中恢复相同的元素。如果我们想要再次从头开始使用它，我们需要重新创建它。
- en: 'In the next few examples, let''s see how to reproduce `map` and `filter` using
    generator expressions:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '在接下来的几个例子中，让我们看看如何使用生成器表达式复制`map`和`filter`： '
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the previous example, `s1` and `s2` are exactly the same: they are the sum
    of `adder(0, 1), adder(1, 2), adder(2, 3)`, and so on, which translates to `sum(1,
    3, 5, ...)`. The syntax is different, though I find the generator expression to
    be much more readable:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`s1`和`s2`完全相同：它们是`adder(0, 1), adder(1, 2), adder(2, 3)`的和，依此类推，这对应于`sum(1,
    3, 5, ...)`。尽管语法不同，但我发现生成器表达式更易读：
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the previous example, `odd_cubes1` and `odd_cubes2` are the same: they generate
    a sequence of odd cubes. Yet again, I prefer the generator syntax. This should
    be evident when things get a little more complicated:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`odd_cubes1`和`odd_cubes2`是相同的：它们生成奇数立方体的序列。当事情变得有点复杂时，我再次更喜欢生成器语法。这应该在事情变得有点复杂时显而易见：
- en: '[PRE39]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding code creates two generators, `cubes1` and `cubes2`. They are exactly
    the same, and return two-tuples (*n, n³*) when `n` is a multiple of `3` or `5`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码创建了两个生成器，`cubes1`和`cubes2`。它们完全相同，当`n`是`3`或`5`的倍数时返回两个元组（*n，n³*）。
- en: 'If you print the list (`cubes1`), you get: `[(0, 0), (3, 27), (5, 125), (6,
    216), (9, 729), (10, 1000), (12, 1728), (15, 3375), (18, 5832)]`.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果打印列表（`cubes1`），您会得到：`[(0, 0), (3, 27), (5, 125), (6, 216), (9, 729), (10,
    1000), (12, 1728), (15, 3375), (18, 5832)]`。
- en: See how much better the generator expression reads? It may be debatable when
    things are very simple, but as soon as you start nesting functions a bit, like
    we did in this example, the superiority of the generator syntax is evident. It's
    shorter, simpler, and more elegant.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 看看生成器表达式读起来好多了？当事情非常简单时，这可能是值得商榷的，但是一旦你开始嵌套函数一点，就像我们在这个例子中所做的那样，生成器语法的优越性就显而易见了。它更短，更简单，更优雅。
- en: 'Now, let me ask you a question—what is the difference between the following
    lines of code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我问你一个问题——以下代码的区别是什么：
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Strictly speaking, they all produce the same sum. The expressions to get `s2`
    and `s3` are exactly the same because the brackets in `s2` are redundant. They
    are both generator expressions inside the `sum` function. The expression to get
    `s1` is different though. Inside `sum`, we find a `list` comprehension. This means
    that in order to calculate `s1`, the `sum` function has to call `next` on a list
    a million times.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，它们都产生相同的总和。获取`s2`和`s3`的表达式完全相同，因为`s2`中的括号是多余的。它们都是`sum`函数中的生成器表达式。然而，获取`s1`的表达式是不同的。在`sum`中，我们找到了一个`list`理解。这意味着为了计算`s1`，`sum`函数必须在列表上调用一百万次`next`。
- en: Do you see where we're losing time and memory? Before `sum` can start calling
    `next` on that list, the list needs to have been created, which is a waste of
    time and space. It's much better for `sum` to call `next` on a simple generator
    expression. There is no need to have all the numbers from `range(10**6)` stored
    in a list.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到我们在浪费时间和内存吗？在`sum`可以开始在列表上调用`next`之前，列表需要被创建，这是一种浪费时间和空间。对于`sum`来说，在一个简单的生成器表达式上调用`next`要好得多。没有必要将`range(10**6)`中的所有数字存储在列表中。
- en: 'So, *watch out for extra parentheses when you write your expressions*: sometimes
    it''s easy to skip over these details, which makes our code very different. If
    you don''t believe me, check out the following code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*在编写表达式时要注意额外的括号*：有时很容易忽略这些细节，这使得我们的代码非常不同。如果你不相信我，看看下面的代码：
- en: '[PRE41]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Try running the preceding example. If I run the first line on my old Linux
    box with 8 GB RAM, this is what I get:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行前面的例子。如果我在我的旧Linux框上运行第一行，内存为8GB，这就是我得到的：
- en: '[PRE42]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'On the other hand, if I comment out the first line, and uncomment the second
    one, this is the result:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我注释掉第一行，并取消注释第二行，这就是结果：
- en: '[PRE43]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Sweet generator expressions. The difference between the two lines is that in
    the first one, a list with the squares of the first hundred million numbers must
    be made before being able to sum them up. That list is huge, and we ran out of
    memory (at least, my box did, if yours doesn't try a bigger number), therefore
    Python kills the process for us. Sad face.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 甜蜜的生成器表达式。两行之间的区别在于，在第一行中，必须先制作一个前一亿个数字的平方的列表，然后才能将它们相加。那个列表很大，我们的内存用完了（至少，我的内存用完了，如果你的内存没有用完，试试更大的数字），因此Python为我们终止了进程。悲伤的脸。
- en: But when we remove the square brackets, we don't have a list any more. The `sum`
    function receives `0`, `1`, `4`, `9`, and so on until the last one, and sums them
    up. No problems, happy face.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当我们去掉方括号时，我们不再有一个列表。`sum`函数接收`0`，`1`，`4`，`9`，直到最后一个，然后将它们相加。没有问题，开心脸。
- en: Some performance considerations
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些性能考虑
- en: So, we've seen that we have many different ways to achieve the same result.
    We can use any combination of `map`, `zip`, and `filter`, or choose to go with
    a comprehension, or maybe choose to use a generator, either function or expression.
    We may even decide to go with `for` loops; when the logic to apply to each running
    parameter isn't simple, they may be the best option.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经看到了实现相同结果的许多不同方法。我们可以使用`map`，`zip`和`filter`的任何组合，或者选择使用理解，或者可能选择使用生成器，无论是函数还是表达式。我们甚至可以决定使用`for`循环；当要应用于每个运行参数的逻辑不简单时，它们可能是最佳选择。
- en: 'Other than readability concerns though, let''s talk about performance. When
    it comes to performance, usually there are two factors that play a major role:
    **space** and **time**.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可读性问题之外，让我们谈谈性能。在性能方面，通常有两个因素起着重要作用：**空间**和**时间**。
- en: Space means the size of the memory that a data structure is going to take up.
    The best way to choose is to ask yourself if you really need a list (or tuple)
    or if a simple generator function would work as well. If the answer is yes, go
    with the generator, it'll save a lot of space. The same goes for functions; if
    you don't actually need them to return a list or tuple, then you can transform
    them into generator functions as well.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 空间意味着数据结构要占用的内存大小。选择的最佳方法是问自己是否真的需要一个列表（或元组），或者一个简单的生成器函数是否同样有效。如果答案是肯定的，那就选择生成器，它会节省很多空间。对于函数也是一样；如果你实际上不需要它们返回一个列表或元组，那么你也可以将它们转换为生成器函数。
- en: Sometimes, you will have to use lists (or tuples), for example there are algorithms
    that scan sequences using multiple pointers or maybe they run over the sequence
    more than once. A generator function (or expression) can be iterated over only
    once and then it's exhausted, so in these situations, it wouldn't be the right
    choice.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你将不得不使用列表（或元组），例如有一些算法使用多个指针扫描序列，或者可能多次运行序列。生成器函数（或表达式）只能迭代一次，然后就用完了，所以在这些情况下，它不是正确的选择。
- en: Time is a bit harder than space because it depends on more variables and therefore
    it isn't possible to state that *X is faster than Y* with absolute certainty for
    all cases. However, based on tests run on Python today, we can say that on average, `map`
    exhibits performances similar to `list` comprehensions and generator expressions,
    while `for` loops are consistently slower.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 时间比空间更难，因为它取决于更多的变量，因此不可能绝对肯定地说*X比Y更快*对于所有情况。然而，基于今天在Python上运行的测试，我们可以说，平均而言，`map`表现出与`list`理解和生成器表达式类似的性能，而`for`循环一直较慢。
- en: In order to appreciate the reasoning behind these statements fully, we need
    to understand how Python works, and this is a bit outside the scope of this book,
    as it's too technical in detail. Let's just say that `map` and `list` comprehensions
    run at C-language speed within the interpreter, while a Python `for` loop is run
    as Python bytecode within the Python Virtual Machine, which is often much slower.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分理解这些陈述背后的推理，我们需要了解Python的工作原理，这有点超出了本书的范围，因为它在技术细节上太复杂。让我们只说`map`和`list`理解在解释器内以C语言速度运行，而Python
    `for`循环作为Python虚拟机内的Python字节码运行，通常要慢得多。
- en: There are several different implementations of Python. The original one, and
    still the most common one, is CPython ([https://github.com/python/cpython](https://github.com/python/cpython)),
    which is written in C. C is one of the most powerful and popular programming languages
    still used today.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Python有几种不同的实现。最初的，也是最常见的一个是CPython ([https://github.com/python/cpython](https://github.com/python/cpython))，它是用C语言编写的。C语言是今天仍然使用的最强大和流行的编程语言之一。
- en: 'How about we do a small exercise and try to find out whether the claims I made
    are accurate? I will write a small piece of code that collects the results of
    `divmod(a, b)` for a certain set of integer pairs, `(a, b)`. I will use the `time`
    function from the `time` module to calculate the elapsed time of the operations
    that I will perform:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来做一个小练习，试着找出我所说的是否准确？我将编写一小段代码，收集`divmod(a, b)`的结果，对于一定的整数对`(a, b)`。我将使用`time`模块中的`time`函数来计算我将执行的操作的经过时间：
- en: '[PRE44]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As you can see, we''re creating three lists: `floop`, `compr`, and `gener`.
    Running the code produces the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们创建了三个列表：`floop`、`compr`和`gener`。运行代码会产生以下结果：
- en: '[PRE45]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `list` comprehension runs in ~67% of the time taken by the `for` loop. That's
    impressive. The generator expression came quite close to that, with a good ~77%.
    The reason the generator expression is slower is that we need to feed it to the
    `list()` constructor, and this has a little bit more overhead compared to a sheer
    `list` comprehension. If I didn't have to retain the results of those calculations,
    a generator would probably have been a more suitable option.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`list`理解运行时间约为`for`循环时间的67%。这令人印象深刻。生成器表达式接近这个时间，约为`for`循环时间的77%。生成器表达式较慢的原因是我们需要将其提供给`list()`构造函数，这与纯粹的`list`理解相比有更多的开销。如果我不必保留这些计算的结果，生成器可能是更合适的选择。'
- en: An interesting result is to notice that, within the body of the `for` loop,
    we're appending data to a list. This implies that Python does the work, behind
    the scenes, of resizing it every now and then, allocating space for items to be
    appended. I guessed that creating a list of zeros, and simply filling it with
    the results, might have sped up the `for` loop, but I was wrong. Check it for
    yourself, you just need `mx * (mx - 1) // 2` elements to be preallocated.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，在`for`循环的主体中，我们正在向列表中添加数据。这意味着Python在幕后做着工作，不时地调整大小，为要添加的项目分配空间。我猜想创建一个零列表，并简单地用结果填充它，可能会加快`for`循环的速度，但我错了。你自己检查一下，你只需要预分配`mx
    * (mx - 1) // 2`个元素。
- en: 'Let''s see a similar example that compares a `for` loop and a `map` call:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个类似的例子，比较一下`for`循环和`map`调用：
- en: '[PRE46]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This code is conceptually very similar to the previous example. The only thing
    that has changed is that we''re applying the `abs` function instead of the `divmod`
    one, and we have only one loop instead of two nested ones. Execution gives the
    following result:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在概念上与前面的例子非常相似。唯一改变的是我们应用了`abs`函数而不是`divmod`，并且我们只有一个循环而不是两个嵌套的循环。执行后得到以下结果：
- en: '[PRE47]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And `map` wins the race: ~62% of the `list` comprehension and ~30% of the `for`
    loop. Take these results with a pinch of salt, as things might be different according
    to various factors, such as OS and Python version. But in general, I think it''s
    safe to say that these results are good enough for having an idea when it comes
    to coding for performance.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 而`map`赢得了比赛：约为`list`理解时间的62%，`for`循环时间的30%。这些结果可能会有所不同，因为各种因素，如操作系统和Python版本。但总的来说，我认为这些结果足够好，可以让我们对编写性能代码有一个概念。
- en: Apart from the case-by-case little differences though, it's quite clear that
    the `for` loop option is the slowest one, so let's see why we still want to use
    it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有一些个案的小差异，很明显`for`循环选项是最慢的，所以让我们看看为什么我们仍然想要使用它。
- en: Don't overdo comprehensions and generators
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要过度使用理解和生成器
- en: We've seen how powerful `list` comprehensions and generator expressions can
    be. And they are, don't get me wrong, but the feeling that I have when I deal
    with them is that their complexity grows exponentially. The more you try to do
    within a single comprehension or a generator expression, the harder it becomes
    to read, understand, and therefore maintain or change.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了`list`理解和生成器表达式有多么强大。它们确实如此，不要误会我的意思，但当我处理它们时的感觉是，它们的复杂性呈指数增长。你尝试在一个单一的理解或生成器表达式中做的越多，它就越难以阅读、理解，因此也就越难以维护或更改。
- en: 'If you check the Zen of Python again, there are a few lines that I think are
    worth keeping in mind when dealing with optimized code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次查看Python之禅，有几行我认为值得在处理优化代码时牢记：
- en: '[PRE48]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Comprehensions and generator expressions are more implicit than explicit, can
    be quite difficult to read and understand, and they can be hard to explain. Sometimes
    you have to break them apart using the inside-out technique, to understand what's
    going on.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 理解和生成器表达式比较隐式而不是显式，可能相当难以阅读和理解，也很难解释。有时你必须使用由内而外的技术来分解它们，以理解发生了什么。
- en: To give you an example, let's talk a bit more about Pythagorean triples. Just
    to remind you, a Pythagorean triple is a tuple of positive integers (*a*, *b*,
    *c*) such that *a² + b² = c²*.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，让我们再谈谈毕达哥拉斯三元组。只是提醒一下，毕达哥拉斯三元组是一组正整数元组(*a*, *b*, *c*)，使得*a² + b² = c²*。
- en: We saw how to calculate them in the *Filtering a comprehension* section, but
    we did it in a very inefficient way because we were scanning all pairs of numbers
    below a certain threshold, calculating the hypotenuse, and filtering out those
    that were not producing a triple.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*过滤理解*部分看到了如何计算它们，但我们以一种非常低效的方式进行了，因为我们正在扫描所有低于某个阈值的数字对，计算斜边，并过滤掉那些没有产生三元组的数字对。
- en: A better way to get a list of Pythagorean triples is to generate them directly.
    There are many different formulas you can use to do this, we'll use the **Euclidean
    formula**.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 获得勾股数三元组的更好方法是直接生成它们。有许多不同的公式可以用来做到这一点，我们将使用**欧几里得公式**。
- en: 'This formula says that any triple (*a*, *b*, *c*), where *a = m² - n²*, *b
    = 2mn*, *c = m² + n²*, with *m* and *n* positive integers such that *m > n*, is
    a Pythagorean triple. For example, when *m = 2* and *n = 1*, we find the smallest
    triple: (*3*, *4*, *5*).'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这个公式表明，任何三元组(*a*，*b*，*c*)，其中*a = m² - n²*，*b = 2mn*，*c = m² + n²*，*m*和*n*是正整数，满足*m
    > n*，都是勾股数三元组。例如，当*m = 2*，*n = 1*时，我们找到了最小的三元组：(*3*，*4*，*5*)。
- en: 'There is one catch though: consider the triple (*6*, *8*, *10*) that is just
    like (*3*, *4*, *5*) with all the numbers multiplied by *2*. This triple is definitely
    Pythagorean, since *6² + 8² = 10²* , but we can derive it from (*3*, *4*, *5*)
    simply by multiplying each of its elements by *2*. Same goes for (*9*, *12*, *15*),
    (*12*, *16*, *20*), and in general for all the triples that we can write as (*3k*,
    *4k*, *5k*), with k being a positive integer greater than *1*.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个问题：考虑一下三元组(*6*，*8*，*10*)，它就像(*3*，*4*，*5*)一样，只是所有数字都乘以*2*。这个三元组肯定是勾股数三元组，因为*6²
    + 8² = 10²*，但我们可以通过简单地将其每个元素乘以*2*来从(*3*，*4*，*5*)派生出它。对于所有可以写成(*3k*，*4k*，*5k*)的三元组，其中*k*是大于*1*的正整数，情况也是如此。
- en: 'A triple that cannot be obtained by multiplying the elements of another one
    by some factor, *k*, is called **primitive**. Another way of stating this is:
    if the three elements of a triple are **coprime**, then the triple is primitive.
    Two numbers are coprime when they don''t share any prime factor amongst their
    divisors, that is, their **greatest common divisor** (**GCD**) is *1*. For example,
    3 and 5 are coprime, while 3 and 6 are not, because they are both divisible by
    3.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 不能通过将另一个三元组的元素乘以某个因子*k*获得的三元组称为**原始**。另一种陈述这一点的方式是：如果三元组的三个元素是**互质**的，那么这个三元组就是原始的。当两个数在它们的除数中没有共享任何质因数时，它们就是互质的，也就是说，它们的**最大公约数**（**GCD**）是*1*。例如，3和5是互质的，而3和6不是，因为它们都可以被3整除。
- en: 'So, the Euclidean formula tells us that if *m* and *n* are coprime, and *m
    - n* is odd, the triple they generate is *primitive*. In the following example,
    we will write a generator expression to calculate all the primitive Pythagorean
    triples whose hypotenuse (*c*) is less than or equal to some integer, *N*. This
    means we want all triples for which *m² + n² ≤ N*. When *n* is *1*, the formula
    looks like this: *m² ≤ N - 1*, which means we can approximate the calculation
    with an upper bound of *m ≤ N^(1/2)*.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，欧几里得公式告诉我们，如果*m*和*n*是互质的，并且*m - n*是奇数，那么它们生成的三元组是原始的。在下面的例子中，我们将编写一个生成器表达式，计算所有原始的勾股数三元组，其斜边(*c*)小于或等于某个整数*N*。这意味着我们希望所有满足*m²
    + n² ≤ N*的三元组。当*n*为*1*时，公式如下：*m² ≤ N - 1*，这意味着我们可以用*m ≤ N^(1/2)*的上限来近似计算。
- en: 'So, to recap: *m* must be greater than *n*, they must also be coprime, and
    their difference *m - n* must be odd. Moreover, in order to avoid useless calculations,
    we''ll put the upper bound for *m* at *floor(sqrt(N)) + 1*.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结一下：*m*必须大于*n*，它们也必须互质，它们的差异*m - n*必须是奇数。此外，为了避免无用的计算，我们将*m*的上限设定为*floor(sqrt(N))
    + 1*。
- en: The `floor` function for a real number, *x*, gives the maximum integer, *n*,
    such that *n < x*, for example, *floor(3.8) = 3*, *floor(13.1) = 13*. Taking *floor(sqrt(N))
    + 1* means taking the integer part of the square root of *N* and adding a minimal
    margin just to make sure we don't miss any numbers.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 实数*x*的`floor`函数给出最大整数*n*，使得*n < x*，例如，*floor(3.8) = 3*，*floor(13.1) = 13*。取*floor(sqrt(N))
    + 1*意味着取*N*的平方根的整数部分，并添加一个最小的边距，以确保我们不会错过任何数字。
- en: 'Let''s put all of this into code, step by step. Let''s start by writing a simple
    `gcd` function that uses **Euclid''s algorithm**:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地将所有这些放入代码中。让我们首先编写一个使用**欧几里得算法**的简单`gcd`函数：
- en: '[PRE49]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The explanation of Euclid''s algorithm is available on the web, so I won''t
    spend any time here talking about it; we need to focus on the generator expression.
    The next step is to use the knowledge we gathered before to generate a list of
    primitive Pythagorean triples:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 欧几里得算法的解释可以在网上找到，所以我不会在这里花时间谈论它；我们需要专注于生成器表达式。下一步是利用之前收集的知识来生成一个原始勾股数三元组的列表：
- en: '[PRE50]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: There you go. It's not easy to read, so let's go through it line by line. At
    `#3`, we start a generator expression that is creating triples. You can see from
    `#4` and `#5` that we're looping on `m` in *[1, M]* with *M* being the integer
    part of *sqrt(N)*, plus *1*. On the other hand, `n` loops within *[1, m)*, to
    respect the *m > n* rule. It's worth noting how I calculated *sqrt(N)*, that is,
    `N**.5`, which is just another way to do it that I wanted to show you.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是了。它不容易阅读，所以让我们逐行进行解释。在`#3`处，我们开始一个生成器表达式，用于创建三元组。从`#4`和`#5`可以看出，我们在*[1，M]*中循环*m*，其中*M*是*sqrt(N)*的整数部分，再加上*1*。另一方面，*n*在*[1，m)*中循环，以遵守*m
    > n*的规则。值得注意的是我如何计算*sqrt(N)*，即`N**.5`，这只是另一种我想向你展示的方法。
- en: 'At `#6`, you can see the filtering conditions to make the triples primitive:
    `(m - n) % 2` evaluates to `True` when `(m - n)` is odd, and `gcd(m, n) == 1`
    means `m` and `n` are coprime. With these in place, we know the triples will be
    primitive. This takes care of the innermost generator expression. The outermost
    one starts at `#2`, and finishes at `#7`. We take the triples (*a*, *b*, *c*)
    in (...innermost generator...) such that `c <= N`.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在`＃6`，您可以看到使三元组原始的过滤条件：当`(m - n)`为奇数时，`(m - n)％2`的值为`True`，而`gcd(m, n) == 1`表示`m`和`n`是互质的。有了这些条件，我们知道三元组将是原始的。这照顾了最内层的生成器表达式。最外层的生成器表达式从`＃2`开始，结束于`＃7`。我们取(*a*,
    *b*, *c*)在(...最内层生成器...)中，使得`c <= N`。
- en: Finally, at `#1` we apply sorting, to present the list in order. At `#7`, after
    the outermost generator expression is closed, you can see that we specify the
    sorting key to be the sum *a + b + c*. This is just my personal preference, there
    is no mathematical reason behind it.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`＃1`我们应用排序，以按顺序呈现列表。在最外层生成器表达式关闭后的`＃7`处，您可以看到我们指定排序键为和的总和*a + b + c*。这只是我的个人偏好，没有数学原因。
- en: So, what do you think? Was it straightforward to read? I don't think so. And
    believe me, this is still a simple example; I have seen much worse in my career.
    This kind of code is difficult to understand, debug, and modify. It shouldn't
    find a place in a professional environment.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你觉得呢？阅读起来简单吗？我不这么认为。相信我，这仍然是一个简单的例子；在我的职业生涯中，我见过更糟糕的情况。这种代码难以理解、调试和修改。它不应该出现在专业环境中。
- en: 'So, let''s see if we can rewrite this code into something more readable:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们看看是否可以将这段代码重写成更易读的形式：
- en: '[PRE51]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is so much better. Let's go through it, line by line. You'll see how much
    easier it is to understand.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这好多了。让我们逐行看一下。你会看到它有多容易理解。
- en: 'We start looping at `#1` and `#2`, in exactly the same way we were looping
    in the previous example. On line `#3`, we have the filtering for primitive triples.
    On line `#4`, we deviate a bit from what we were doing before: we calculate `c`,
    and on line `#5`, we filter on `c` being less than or equal to `N`. Only when
    `c` satisfies that condition, we do calculate `a` and `b`, and yield the resulting
    tuple. It''s always good to delay all calculations for as much as possible so
    that we don''t waste time and CPU. On the last line, we apply sorting with the
    same key we were using in the generator expression example.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`＃1`和`＃2`开始循环，方式与之前的示例中的循环方式完全相同。在第`＃3`行，我们对原始三元组进行了过滤。在第`＃4`行，我们有了一点偏离之前的做法：我们计算了`c`，在第`＃5`行，我们对`c`小于或等于`N`进行了过滤。只有当`c`满足这个条件时，我们才计算`a`和`b`，并产生结果的元组。尽可能延迟所有计算总是很好的，这样我们就不会浪费时间和CPU。在最后一行，我们使用了与生成器表达式示例中相同的键进行排序。
- en: I hope you agree, this example is easier to understand. And I promise you, if
    you have to modify the code one day, you'll find that modifying this one is easy,
    while to modify the other version will take much longer (and it will be more error-prone).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你同意，这个例子更容易理解。我向你保证，如果有一天你不得不修改这段代码，你会发现修改这个代码很容易，而修改另一个版本将需要更长的时间（而且容易出错）。
- en: 'If you print the results of both examples (they are the same), you will get
    this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果打印两个示例的结果（它们是相同的），你会得到这个：
- en: '[PRE52]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The moral of the story is, try and use comprehensions and generator expressions
    as much as you can, but if the code starts to be complicated to modify or to read,
    you may want to refactor it into something more readable. Your colleagues will
    thank you.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 故事的寓意是，尽量使用理解和生成器表达式，但如果代码开始变得复杂，难以修改或阅读，你可能需要将其重构为更易读的形式。你的同事会感谢你。
- en: Name localization
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 名称本地化
- en: 'Now that we are familiar with all types of comprehensions and generator expression,
    let''s talk about name localization within them. Python 3.* localizes loop variables
    in all four forms of comprehensions: `list`, `dict`, `set`, and generator expressions.
    This behavior is therefore different from that of the `for` loop. Let''s see a
    simple example to show all the cases:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们熟悉了所有类型的理解和生成器表达式，让我们谈谈它们内部的名称本地化。Python 3.*在所有四种理解形式中都将循环变量本地化：`list`、`dict`、`set`和生成器表达式。这种行为与`for`循环的行为不同。让我们看一个简单的例子来展示所有情况：
- en: '[PRE53]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the preceding code, we declare a global name, `A = 100`, and then we exercise
    the four comprehensions: `list`, generator expression, dictionary, and `set`.
    None of them alter the global name, `A`. Conversely, you can see at the end that
    the `for` loop modifies it. The last print statement prints `4`.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明了一个全局名称`A = 100`，然后我们使用了四种理解方式：`list`、生成器表达式、字典和`set`。它们都没有改变全局名称`A`。相反，您可以在最后看到`for`循环修改了它。最后的打印语句打印出`4`。
- en: 'Let''s see what happens if `A` wasn''t there:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果没有`A`会发生什么：
- en: '[PRE54]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The preceding code would work the same with any of the four types of comprehensions.
    After we run the first line, `A` is not defined in the global namespace. Once
    again, the `for` loop behaves differently:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码可以使用任何四种理解方式来完成相同的工作。运行第一行后，`A`在全局命名空间中未定义。再次，`for`循环的行为不同：
- en: '[PRE55]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The preceding code shows that after a `for` loop, if the loop variable wasn''t
    defined before it, we can find it in the global frame. To make sure of it, let''s
    take a peek at it by calling the `globals()` built-in function:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码表明，在`for`循环之后，如果循环变量在之前没有定义，我们可以在全局框架中找到它。为了确保这一点，让我们调用`globals()`内置函数来一探究竟：
- en: '[PRE56]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Together with a lot of other boilerplate stuff that I have omitted, we can
    spot `''A'': 4`.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '除了我省略的大量样板之外，我们可以发现`''A'': 4`。'
- en: Generation behavior in built-ins
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置生成行为
- en: Among the built-in types, the generation behavior is now quite common. This
    is a major difference between Python 2 and Python 3\. A lot of functions, such
    as `map`, `zip`, and `filter`, have been transformed so that they return objects
    that behave like iterables. The idea behind this change is that if you need to
    make a list of those results, you can always wrap the call in a `list()` class,
    and you're done. On the other hand, if you just need to iterate and want to keep
    the impact on memory as light as possible, you can use those functions safely.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在内置类型中，生成行为现在非常普遍。这是Python 2和Python 3之间的一个重大区别。许多函数，如`map`、`zip`和`filter`，都已经改变，以便它们返回像可迭代对象一样的对象。这种改变背后的想法是，如果你需要制作这些结果的列表，你可以总是将调用包装在`list()`类中，然后你就完成了。另一方面，如果你只需要迭代，并希望尽可能减少对内存的影响，你可以安全地使用这些函数。
- en: Another notable example is the `range` function. In Python 2 it returns a list,
    and there is another function called `xrange` that returns an object that you
    can iterate on, which generates the numbers on the fly. In Python 3 this function
    has gone, and `range` now behaves like it.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个显著的例子是`range`函数。在Python 2中，它返回一个列表，还有另一个叫做`xrange`的函数，它返回一个你可以迭代的对象，它会动态生成数字。在Python
    3中，这个函数已经消失了，`range`现在的行为就像它。
- en: But this concept, in general, is now quite widespread. You can find it in the
    `open()` function, which is used to operate on file objects (we'll see it in [Chapter
    7](part0187.html#5IAP60-2ddb708647cc4530a187c2c6c0e9acfe), *Files and Data Persistence*),
    but also in `enumerate`, in the dictionary `keys`, `values`, and `items` methods,
    and several other places.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这个概念，总的来说，现在是相当普遍的。你可以在`open()`函数中找到它，这个函数用于操作文件对象（我们将在[第7章](part0187.html#5IAP60-2ddb708647cc4530a187c2c6c0e9acfe)中看到它，*文件和数据持久性*），但也可以在`enumerate`、字典`keys`、`values`和`items`方法以及其他一些地方找到它。
- en: 'It all makes sense: Python''s aim is to try to reduce the memory footprint
    by avoiding wasting space wherever possible, especially in those functions and
    methods that are used extensively in most situations.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都是有道理的：Python的目标是尽可能减少内存占用，尽量避免浪费空间，特别是在大多数情况下广泛使用的那些函数和方法中。
- en: Do you remember at the beginning of this chapter? I said that it makes more
    sense to optimize the performances of code that has to deal with a lot of objects,
    rather than shaving off a few milliseconds from a function that we call twice
    a day.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得本章开头吗？我说过，优化那些必须处理大量对象的代码的性能比每天调用两次的函数节省几毫秒更有意义。
- en: One last example
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后一个例子
- en: Before we finish this chapter, I'll show you a simple problem that I used to
    submit to candidates for a Python developer role in a company I used to work for.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章之前，我会向你展示一个我曾经在一家我曾经工作过的公司提交给Python开发人员角色的一个简单问题。
- en: 'The problem is the following: given the sequence `0 1 1 2 3 5 8 13 21 ...`,
    write a function that would return the terms of this sequence up to some limit, `N`.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是：给定序列`0 1 1 2 3 5 8 13 21 ...`，编写一个函数，它将返回这个序列的项直到某个限制`N`。
- en: If you haven't recognized it, that is the Fibonacci sequence, which is defined
    as *F(0) = 0*, *F(1) = 1* and, for any *n > 1*, *F(n) = F(n-1) + F(n-2)*. This
    sequence is excellent to test knowledge about recursion, memoization techniques,
    and other technical details, but in this case, it was a good opportunity to check
    whether the candidate knew about generators.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有意识到，那就是斐波那契数列，它被定义为*F(0) = 0*，*F(1) = 1*，对于任何*n > 1*，*F(n) = F(n-1) + F(n-2)*。这个序列非常适合测试关于递归、记忆化技术和其他技术细节的知识，但在这种情况下，这是一个检查候选人是否了解生成器的好机会。
- en: 'Let''s start from a rudimentary version of a function, and then improve on
    it:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个基本版本的函数开始，然后对其进行改进：
- en: '[PRE57]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'From the top: we set up the `result` list to a starting value of `[0]`. Then
    we start the iteration from the next element (`next_n`), which is `1`. While the
    next element is not greater than `N`, we keep appending it to the list and calculating
    the next. We calculate the next element by taking a slice of the last two elements
    in the `result` list and passing it to the `sum` function. Add some `print` statements
    here and there if this is not clear to you, but by now I would expect it not to
    be an issue.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 从头开始：我们将`result`列表设置为起始值`[0]`。然后我们从下一个元素（`next_n`）开始迭代，即`1`。只要下一个元素不大于`N`，我们就不断将它附加到列表中并计算下一个。我们通过取`result`列表中最后两个元素的切片并将其传递给`sum`函数来计算下一个元素。如果这对你来说不清楚，可以在这里和那里添加一些`print`语句，但到现在我希望这不会成为一个问题。
- en: When the condition of the `while` loop evaluates to `False`, we exit the loop
    and return `result`. You can see the result of those `print` statements in the
    comments next to each of them.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当`while`循环的条件评估为`False`时，我们退出循环并返回`result`。你可以在每个`print`语句旁边的注释中看到这些`print`语句的结果。
- en: 'At this point, I would ask the candidate the following question: *What if I
    just wanted to iterate over those numbers?* A good candidate would then change
    the code to what you''ll find here (an excellent candidate would have started
    with it!):'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我会问候选人以下问题：*如果我只想迭代这些数字怎么办？* 一个好的候选人会改变代码，你会在这里找到（一个优秀的候选人会从这里开始！）：
- en: '[PRE58]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This is actually one of the solutions I was given. I don''t know why I kept
    it, but I''m glad I did so I can show it to you. Now, the `fibonacci` function
    is a *generator function*. First we yield `0`, then if `N` is `0`, we return (this
    will cause a `StopIteration` exception to be raised). If that''s not the case,
    we start iterating, yielding `b` at every loop cycle, and then updating `a` and
    `b`. All we need in order to be able to produce the next element of the sequence
    is the past two: `a` and `b`, respectively.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是我得到的解决方案之一。我不知道为什么我保存了它，但我很高兴我这样做了，这样我就可以向你展示它。现在，`fibonacci`函数是一个*生成器函数*。首先我们产生`0`，然后如果`N`是`0`，我们返回（这将导致引发`StopIteration`异常）。如果不是这种情况，我们开始迭代，每个循环周期产生`b`，然后更新`a`和`b`。为了能够产生序列的下一个元素，我们只需要过去的两个：`a`和`b`。
- en: 'This code is much better, has a lighter memory footprint and all we have to
    do to get a list of Fibonacci numbers is to wrap the call with `list()`, as usual.
    But what about elegance? I can''t leave it like that, can I? Let''s try the following:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码好多了，内存占用更少，我们只需要用`list()`将调用包装起来，就像往常一样，就可以得到一个斐波那契数列。但是优雅呢？我不能就这样把它留下吧？让我们试试下面的方法：
- en: '[PRE59]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Much better. The whole body of the function is four lines, five if you count
    the docstring. Notice how, in this case, using tuple assignment (`a, b = 0, 1`
    and `a, b = b, a + b`) helps in making the code shorter, and more readable.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 好多了。这个函数的整个主体只有四行，如果算上文档字符串的话就是五行。请注意，在这种情况下，使用元组赋值（`a, b = 0, 1`和`a, b = b,
    a + b`）有助于使代码更短、更易读。
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the concept of iteration and generation a bit more
    deeply. We looked at the `map`, `zip`, and `filter` functions in detail, and learned
    how to use them as an alternative to a regular `for` loop approach.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们更深入地探讨了迭代和生成的概念。我们详细研究了`map`、`zip`和`filter`函数，并学会了如何将它们作为常规`for`循环方法的替代方法。
- en: Then we covered the concept of comprehensions, for lists, dictionaries, and
    sets. We explored their syntax and how to use them as an alternative to both the
    classic `for` loop approach and also to the use of the `map`, `zip`, and `filter`
    functions.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们讨论了列表、字典和集合的理解概念。我们探讨了它们的语法以及如何将它们作为传统的`for`循环方法和`map`、`zip`和`filter`函数的替代方法来使用。
- en: 'Finally, we talked about the concept of generation, in two forms: generator
    functions and expressions. We learned how to save time and space by using generation
    techniques and saw how they can make possible what wouldn''t normally be if we
    used a conventional approach based on lists.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了生成的概念，有两种形式：生成器函数和表达式。我们学会了如何通过使用生成技术来节省时间和空间，并看到它们如何使得通常情况下无法实现的事情成为可能。
- en: We talked about performance, and saw that `for` loops are last in terms of speed,
    but they provide the best readability and flexibility to change. On the other
    hand, functions such as `map` and `filter`, and `list` comprehensions, can be
    much faster.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们谈到了性能，并看到`for`循环在速度上是最慢的，但它们提供了最佳的可读性和灵活性。另一方面，诸如`map`和`filter`以及`list`推导这样的函数可能会快得多。
- en: The complexity of the code written using these techniques grows exponentially
    so, in order to favor readability and ease of maintainability, we still need to
    use the classic `for` loop approach at times. Another difference is in the name
    localization, where the `for` loop behaves differently from all other types of
    comprehensions.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些技术编写的代码复杂度呈指数级增长，因此，为了更有利于可读性和易维护性，我们仍然需要有时使用传统的`for`循环方法。另一个区别在于名称本地化，其中`for`循环的行为与所有其他类型的推导不同。
- en: The next chapter will be all about objects and classes. It is structurally similar
    to this one, in that we won't explore many different subjects, just a few of them,
    but we'll try to dive into them a little bit more deeply.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将全面讨论对象和类。它在结构上与本章类似，我们不会探讨许多不同的主题，只是其中的一些，但我们会尝试更深入地探讨它们。
- en: Make sure you understand the concepts of this chapter before moving on to the
    next one. We're building a wall brick by brick, and if the foundation is not solid,
    we won't get very far.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续下一章之前，请确保您理解了本章的概念。我们正在一砖一瓦地建造一堵墙，如果基础不牢固，我们将走不远。
