- en: <st c="0">8</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">8</st>
- en: <st c="2">Building Workflows with Flask</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Flask构建工作流
- en: <st c="31">Workflows are sequences or groups of repetitive tasks, activities,
    or small processes that require a complete start-to-end execution to satisfy a
    particular business process.</st> <st c="207">Each task is equivalent to routinary
    transactions such as sending emails, running scripts or terminal commands, data
    transformation and serialization, database transactions, and other highly computational
    operations.</st> <st c="424">These tasks can be simple sequence, parallel, and</st>
    <st c="474">complex types.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流是一系列或一组重复的任务、活动或小流程，需要从头到尾的完整执行以满足特定的业务流程。<st c="31">每个任务相当于日常交易，如发送电子邮件、运行脚本或终端命令、数据转换和序列化、数据库事务以及其他高度计算操作。</st>
    <st c="207">这些任务可以是简单的顺序、并行和</st> <st c="424">复杂类型。</st>
- en: <st c="488">Several tools and platforms can provide best practices, rules, and
    technical specifications to build workflows for industry, enterprise, and scientific
    problems.</st> <st c="651">However, most of these solutions require Java more
    than Python as their core language.</st> <st c="738">Now, the main goal of this
    chapter is to prove that Python, particularly the Flask framework, can simulate
    workflows that utilize</st> **<st c="868">Business Process Modeling Notation</st>**
    <st c="902">(</st>**<st c="904">BPMN</st>**<st c="908">) and also</st> **<st c="920">non-BPMN</st>**
    <st c="928">workflows using popular and modern platforms such as</st> *<st c="982">Zeebe/Camunda</st>*<st
    c="995">,</st> *<st c="997">Airflow 2.0</st>*<st c="1008">, and</st> *<st c="1014">Temporal</st>*<st
    c="1022">. Moreover, the chapter will also showcase the use of</st> *<st c="1076">Celery
    tasks</st>* <st c="1088">in building custom workflows for</st> <st c="1122">Flask
    applications.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 几种工具和平台可以提供最佳实践、规则和技术规范，以构建针对行业、企业和科学问题的流程。<st c="488">然而，大多数这些解决方案的核心语言是Java而不是Python。</st>
    <st c="651">现在，本章的主要目标是证明Python，尤其是Flask框架，可以模拟使用</st> **<st c="868">业务流程建模符号</st>**
    <st c="902">(</st>**<st c="904">BPMN</st>**<st c="908">)和</st> **<st c="920">非BPMN</st>**
    <st c="928">工作流，使用流行的现代平台，如</st> *<st c="982">Zeebe/Camunda</st>*<st c="995">、</st>
    *<st c="997">Airflow 2.0</st>*<st c="1008">和</st> *<st c="1014">Temporal</st>*<st
    c="1022">。此外，本章还将展示如何使用</st> *<st c="1076">Celery任务</st>* <st c="1088">为</st>
    <st c="1122">Flask应用程序</st>构建自定义工作流。
- en: <st c="1141">This chapter will cover the following topics that will discuss
    the different mechanisms and procedures in implementing workflow activities with
    the</st> <st c="1290">Flask framework:</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题，讨论使用Flask框架实现工作流活动时的不同机制和程序：<st c="1141">This chapter will cover the
    following topics that will discuss the different mechanisms and procedures in
    implementing workflow activities with the</st> <st c="1290">Flask framework:</st>
- en: <st c="1306">Building workflows with</st> <st c="1331">Celery tasks</st>
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Celery任务构建工作流
- en: <st c="1343">Creating BPMN and non-BPMN workflows</st> <st c="1381">with SpiffWorkflow</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SpiffWorkflow创建BPMN和非BPMN工作流
- en: <st c="1399">Building service tasks with the</st> <st c="1432">Zeebe/Camunda
    platforms</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Zeebe/Camunda平台构建服务任务
- en: <st c="1455">Using Airflow 2.x in orchestrating</st> <st c="1491">API endpoints</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Airflow 2.x编排API端点
- en: <st c="1504">Implementing workflows</st> <st c="1528">using Temporal.io</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Temporal.io实现工作流
- en: <st c="1545">Technical requirements</st>
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: <st c="1568">This chapter aims to implement</st> *<st c="1600">Doctor’s Appointment
    Management Software</st>* <st c="1640">that uses workflows to implement its business
    processes.</st> <st c="1698">It has the following five different Flask projects,
    showcasing the varying workflow solutions to build the</st> <st c="1805">Flask
    application:</st>
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在实现使用工作流实现其业务流程的<st c="1568">“医生预约管理软件”</st> *<st c="1600">Doctor’s Appointment
    Management Software</st>* <st c="1640">。它具有以下五个不同的Flask项目，展示了构建</st> <st c="1805">Flask应用程序</st>的不同工作流解决方案：
- en: '`<st c="1823">ch08-celery-redis</st>`<st c="1841">, which focuses on designing
    dynamic workflows with</st> <st c="1893">Celery tasks.</st>'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="1823">ch08-celery-redis</st>`<st c="1841">，该应用专注于使用</st> <st c="1893">Celery任务</st>设计动态工作流。'
- en: '`<st c="1906">ch08-spiff-web</st>`<st c="1921">, which implements a web application
    for the appointment system using the</st> <st c="1995">SpiffWorkflow library.</st>'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="1906">ch08-spiff-web</st>`<st c="1921">，该应用实现了使用</st> <st c="1995">SpiffWorkflow库</st>的预约系统。'
- en: '`<st c="2017">ch08-temporal</st>`<st c="2031">, which uses the Temporal platform
    to build</st> <st c="2075">distributed architecture.</st>'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="2017">ch08-temporal</st>`<st c="2031">，它使用Temporal平台构建</st> <st c="2075">分布式架构。</st>'
- en: '`<st c="2100">ch08-zeebe</st>`<st c="2111">, which utilizes the Zeebe/Camunda
    platform for</st> <st c="2159">BPMN workflows.</st>'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="2100">ch08-zeebe</st>`<st c="2111">，它利用Zeebe/Camunda平台进行</st> <st c="2159">BPMN工作流。</st>'
- en: '`<st c="2174">ch08-airflow</st>`<st c="2187">, which integrates with the Airflow
    2.x workflow engine to manage</st> <st c="2253">API services.</st>'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="2174">ch08-airflow</st>`<st c="2187">，它集成了Airflow 2.x工作流引擎来管理</st>
    <st c="2253">API服务。</st>'
- en: <st c="2266">Although with different workflow solutions, each of these projects
    targets the practical and optimal process performance for the</st> *<st c="2396">user’s
    login transactions</st>*<st c="2421">,</st> *<st c="2423">appointment processes</st>*<st
    c="2444">,</st> *<st c="2446">doctor engagement</st>*<st c="2463">,</st> *<st
    c="2465">billing processes</st>*<st c="2482">, and</st> *<st c="2488">releasing
    transactions</st>*<st c="2510">. All database transactions are relational and
    use PostgreSQL as their database.</st> <st c="2591">All these projects, on the
    other hand, are available</st> <st c="2644">at</st> [<st c="2647">https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch08</st>](https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch08)<st
    c="2728">.</st>
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2266">尽管不同的工作流解决方案，但每个这些项目都针对用户登录交易</st> *<st c="2396">、预约流程</st>*<st
    c="2421">、</st> *<st c="2423">医生互动</st>*<st c="2444">、</st> *<st c="2446">计费流程</st>*<st
    c="2463">、</st> *<st c="2465">释放交易</st>*<st c="2482">以及</st> *<st c="2488">释放交易</st>*<st
    c="2510">的实际和最优流程性能。所有数据库事务都是关系型的，并使用PostgreSQL作为其数据库。</st> <st c="2591">另一方面，所有这些项目都可在</st>
    <st c="2644">以下链接</st> [<st c="2647">https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch08</st>](https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch08)<st
    c="2728">找到。</st>
- en: <st c="2729">Building workflows with Celery tasks</st>
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2729">使用Celery任务构建工作流</st>
- en: <st c="2766">Utilizing</st> **<st c="2777">Celery</st>** <st c="2783">as a task
    queue manager and</st> **<st c="2812">Redis</st>** <st c="2817">as its broker
    was part of our</st> [*<st c="2848">Chapter 5</st>*](B19383_05.xhtml#_idTextAnchor111)
    <st c="2857">content.</st> <st c="2867">The chapter explicitly discussed all setups
    and installations to build Flask-Celery-Redis integration.</st> <st c="2970">It
    also</st> <st c="2977">expounded on how Celery can run background processes asynchronously
    outside the context of Flask’s request-response transaction.</st> <st c="3107">Additionally,
    this chapter will show us another feature of Celery that can solve business</st>
    <st c="3197">process optimization.</st>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2766">利用</st> **<st c="2777">Celery</st>** <st c="2783">作为任务队列管理器，并</st>
    **<st c="2812">Redis</st>** <st c="2817">作为其代理，这是我们</st> [*<st c="2848">第5章</st>*](B19383_05.xhtml#_idTextAnchor111)
    <st c="2857">内容的一部分。</st> <st c="2867">该章节明确讨论了所有设置和安装以构建Flask-Celery-Redis集成。</st>
    <st c="2970">它还</st> <st c="2977">阐述了Celery如何在Flask的请求-响应事务之外异步运行后台进程。</st> <st
    c="3107">此外，本章还将展示Celery的另一个功能，可以解决业务</st> <st c="3197">流程优化。</st>
- en: <st c="3218">Celery has a mechanism to build dynamic workflows, types of workflows
    that run outside the bounds of some schema definitions and rules from start to
    end of workflow activities.</st> <st c="3396">Its first requirement is</st> <st
    c="3420">to wrap all tasks</st> <st c="3439">in</st> *<st c="3442">signatures</st>*<st
    c="3452">.</st>
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3218">Celery有一个机制来构建动态工作流，这种工作流类型在从工作流活动开始到结束的过程中，运行在某个模式定义和规则之外。</st>
    <st c="3396">它的第一个要求是</st> <st c="3420">将所有任务</st> <st c="3439">封装在</st> *<st
    c="3442">签名</st>*<st c="3452">中。</st>
- en: <st c="3453">Creating task signatures</st>
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="3453">创建任务签名</st>
- en: <st c="3478">In a typical scenario, calling Celery tasks requires invoking directly
    its</st> `<st c="3554">delay()</st>` <st c="3561">method to run the underlying
    process the standard way or</st> `<st c="3619">apply_async()</st>` <st c="3632">to
    run it asynchronously.</st> <st c="3659">But to manage</st> <st c="3672">Celery
    tasks to build custom dynamic workflows, individual tasks must invoke the</st>
    `<st c="3754">signature()</st>` <st c="3765">or</st> `<st c="3769">s()</st>` <st
    c="3772">method first.</st> <st c="3787">This allows passing the Celery task invocation
    to workflow operations, linking a Celery task to another task as callbacks after
    its successful execution, and also helps manage its inputs, arguments, and execution
    options.</st> <st c="4009">A signature is like a wrapper to a task ready to be
    passed as an argument to Celery’s</st> <st c="4095">workflow operations.</st>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3478">在典型场景中，调用Celery任务需要直接调用其</st> `<st c="3554">delay()</st>` <st c="3561">方法以标准方式运行底层过程，或者</st>
    `<st c="3619">apply_async()</st>` <st c="3632">以异步运行。</st> <st c="3659">但为了管理</st>
    <st c="3672">Celery任务以构建自定义动态工作流，单个任务必须首先调用</st> `<st c="3754">signature()</st>`
    <st c="3765">或</st> `<st c="3769">s()</st>` <st c="3772">方法。</st> <st c="3787">这允许将Celery任务调用传递给工作流操作，在任务成功执行后将其链接到另一个任务作为回调，并有助于管理其输入、参数和执行选项。</st>
    <st c="4009">签名就像是一个准备传递给Celery工作流操作的任务的包装器。</st>
- en: <st c="4115">The following</st> `<st c="4130">add_login_task_wrapper()</st>`
    <st c="4154">task, for instance, can be wrapped inside a signature just by calling
    its</st> `<st c="4229">signature()</st>` <st c="4240">or</st> `<st c="4244">s()</st>`
    <st c="4247">method:</st>
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4115">以下</st> `<st c="4130">add_login_task_wrapper()</st>` <st c="4154">任务，例如，可以通过调用其</st>
    `<st c="4229">signature()</st>` <st c="4240">或</st> `<st c="4244">s()</st>` <st
    c="4247">方法</st>来包裹在一个签名中：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'add_login_task_wrapper.signature(<st c="4936">s()</st> equivalent with a typical
    parameter list containing the arguments, as in the following snippet:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 'add_login_task_wrapper.signature(<st c="4936">s()</st> equivalent with a typical
    parameter list containing the arguments, as in the following snippet:'
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="6964">from modules.login.services.workflow_tasks import add_user_login_task_wrapper,
    add_user_profile_task_wrapper, show_complete_login_task_wrapper</st>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6964">从模块.login.services.workflow_tasks导入add_user_login_task_wrapper,
    add_user_profile_task_wrapper, show_complete_login_task_wrapper</st>
- en: '<st c="7107">@login_bp.post(''/login/user/add'')</st> async def add_user_workflow():'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="7107">@login_bp.post(''/login/user/add'')</st> async def add_user_workflow():'
- en: user_json = request.get_json()
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: user_json = request.get_json()
- en: user_str = dumps(user_json) <st c="7232">task = chain(add_user_login_task_wrapper.s(user_str),</st>
    <st c="7285">add_user_profile_task_wrapper.s(),</st> <st c="7320">show_complete_login_task_wrapper.s())()</st><st
    c="7360">result = task.get()</st> records = loads(result)
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: user_str = dumps(user_json) <st c="7232">task = chain(add_user_login_task_wrapper.s(user_str),</st>
    <st c="7285">add_user_profile_task_wrapper.s(),</st> <st c="7320">show_complete_login_task_wrapper.s())()</st><st
    c="7360">result = task.get()</st> records = loads(result)
- en: return jsonify(profile=records), 201
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return jsonify(profile=records), 201
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '@shared_task(ignore_result=False) <st c="8567">def add_user_login_task_wrapper(details):</st>
    async def add_user_task(<st c="8633">details</st>):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '@shared_task(ignore_result=False) <st c="8567">def add_user_login_task_wrapper(details):</st>
    async def add_user_task(<st c="8633">details</st>):'
- en: 'try:'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'try:'
- en: 'async with db_session() as sess:'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'async with db_session() as sess:'
- en: 'async with sess.begin():'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'async with sess.begin():'
- en: repo = LoginRepository(sess) <st c="8737">details_dict = loads(details)</st>
    … … … … … …
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: repo = LoginRepository(sess) <st c="8737">details_dict = loads(details)</st>
    … … … … … …
- en: login = Login(**user_dict)
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: login = Login(**user_dict)
- en: result = await repo.insert_login(login)
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: result = await repo.insert_login(login)
- en: 'if result:'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if result:'
- en: profile_details = dumps(details_dict)
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: profile_details = dumps(details_dict)
- en: return profile_details
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return profile_details
- en: 'else:'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'else:'
- en: return ""
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return ""
- en: 'except Exception as e:'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'except Exception as e:'
- en: print(e)
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: print(e)
- en: return ""
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return ""
- en: 'return <st c="9014">details</st> parameter is the complete JSON details passed
    from the endpoint function to the <st c="9102">s()</st> method so that the task
    will retrieve only the *<st c="9153">login credentials</st>* for the *<st c="9179">INSERT</st>*
    login transaction. Now, the task will return the remaining details, the user profile
    information, as input to the next task in the sequence, <st c="9327">add_user_profile_task_wrapper()</st>.
    The following code shows the presence of a local parameter in the <st c="9426">add_user_profile_task_wrapper()</st>
    task that will receive the result of the previous task:'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'return <st c="9014">details</st> parameter is the complete JSON details passed
    from the endpoint function to the <st c="9102">s()</st> method so that the task
    will retrieve only the *<st c="9153">login credentials</st>* for the *<st c="9179">INSERT</st>*
    login transaction. Now, the task will return the remaining details, the user profile
    information, as input to the next task in the sequence, <st c="9327">add_user_profile_task_wrapper()</st>.
    The following code shows the presence of a local parameter in the <st c="9426">add_user_profile_task_wrapper()</st>
    task that will receive the result of the previous task:'
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="12243">from modules.admin.services.reports_tasks import generate_csv_admin_task_wrapper,</st>
    <st c="12325">generate_csv_doctor_task_wrapper,</st> <st c="12359">generate_csv_patient_task_wrapper</st>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12243">从 modules.admin.services.reports_tasks 导入 generate_csv_admin_task_wrapper,</st>
    <st c="12325">generate_csv_doctor_task_wrapper,</st> <st c="12359">generate_csv_patient_task_wrapper</st>
- en: '<st c="12393">@admin_bp.get(''/admin/reports/create'')</st> async def create_reports():'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="12393">@admin_bp.get(''/admin/reports/create'')</st> async def create_reports():'
- en: admin_csv_filename = os.getcwd() + "/files/dams_admin.csv"
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: admin_csv_filename = os.getcwd() + "/files/dams_admin.csv"
- en: patient_csv_filename = os.getcwd() + "/files/dams_patient.csv"
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: patient_csv_filename = os.getcwd() + "/files/dams_patient.csv"
- en: doctor_csv_filename = os.getcwd() + "/files/dams_doc.csv" <st c="12641">workflow
    = group(</st><st c="12658">generate_csv_admin_task_wrapper.s(admin_csv_filename),</st>
    <st c="12713">generate_csv_doctor_task_wrapper.s(</st><st c="12749">doctor_csv_filename),</st>
    <st c="12771">generate_csv_patient_task_wrapper.s(</st><st c="12808">patient_csv_filename))()</st><st
    c="12833">workflow.get()</st> return jsonify(message="done backup"), 201
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: doctor_csv_filename = os.getcwd() + "/files/dams_doc.csv" <st c="12641">workflow
    = group(</st><st c="12658">generate_csv_admin_task_wrapper.s(admin_csv_filename),</st>
    <st c="12713">generate_csv_doctor_task_wrapper.s(</st><st c="12749">doctor_csv_filename),</st>
    <st c="12771">generate_csv_patient_task_wrapper.s(</st><st c="12808">patient_csv_filename))()</st><st
    c="12833">workflow.get()</st> return jsonify(message="done backup"), 201
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="13811">from modules.admin.services.doctor_stats_tasks import count_patients_doctor_task_wrapper,
    count_request_doctor_task_wrapper, create_doctor_stats_task_wrapper</st>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13811">从 modules.admin.services.doctor_stats_tasks 导入 count_patients_doctor_task_wrapper,
    count_request_doctor_task_wrapper, create_doctor_stats_task_wrapper</st>
- en: '<st c="13969">@admin_bp.get(''/admin/doc/stats'')</st> async def derive_doctor_stats():'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="13969">@admin_bp.get(''/admin/doc/stats'')</st> async def derive_doctor_stats():'
- en: docid = request.args.get("docid") <st c="14071">workflow =</st> <st c="14081">chord((count_patients_doctor_task_wrapper.s(docid),
    count_request_doctor_task_wrapper.s(docid)), create_doctor_stats_task_wrapper.s(docid))()</st><st
    c="14223">result = workflow.get()</st> return jsonify(message=result), 201
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: docid = request.args.get("docid") <st c="14071">workflow =</st> <st c="14081">chord((count_patients_doctor_task_wrapper.s(docid),
    count_request_doctor_task_wrapper.s(docid)), create_doctor_stats_task_wrapper.s(docid))()</st><st
    c="14223">result = workflow.get()</st> return jsonify(message=result), 201
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: pip install spiffworkflow
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: pip install spiffworkflow
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: pip install lxml
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: pip install lxml
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: pip install celery
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: pip install celery
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: from SpiffWorkflow.bpmn.workflow import BpmnWorkflow
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 从 SpiffWorkflow.bpmn.workflow 导入 BpmnWorkflow
- en: from SpiffWorkflow.camunda.parser.CamundaParser import CamundaParser
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从 SpiffWorkflow.camunda.parser.CamundaParser 导入 CamundaParser
- en: from SpiffWorkflow.bpmn.specs.defaults import ScriptTask
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 从 SpiffWorkflow.bpmn.specs.defaults 导入 ScriptTask
- en: from SpiffWorkflow.camunda.specs.user_task import UserTask
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 从 SpiffWorkflow.camunda.specs.user_task 导入 UserTask
- en: from SpiffWorkflow.task import Task, TaskState
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 从 SpiffWorkflow.task 导入 Task, TaskState
- en: from SpiffWorkflow.util.deep_merge import DeepMerge <st c="23145">parser = CamundaParser()</st>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从 SpiffWorkflow.util.deep_merge 导入 DeepMerge <st c="23145">parser = CamundaParser()</st>
- en: <st c="23169">filepath = os.path.join("bpmn/dams_appointment.bpmn")</st>
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23169">filepath = os.path.join("bpmn/dams_appointment.bpmn")</st>
- en: <st c="23223">parser.add_bpmn_file(filepath)</st>
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23223">parser.add_bpmn_file(filepath)</st>
- en: '<st c="23304">add_bpmn_file()</st> function of the API will load the BPMN file,
    while the <st c="23375">get_spec()</st> function will parse the document starting
    with the process definition ID call. Now, *<st c="23470">Figure 8</st>**<st c="23478">.5</st>*
    shows a snapshot of the BPMN file with the process definition ID:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23304">add_bpmn_file()</st> 函数的 API 将加载 BPMN 文件，而 <st c="23375">get_spec()</st>
    函数将解析从进程定义 ID 调用开始的文档。现在，*<st c="23470">图 8</st>**<st c="23478">.5</st>* 展示了带有进程定义
    ID 的 BPMN 文件快照：
- en: '![Figure 8.5 – A snapshot of a BPMN file containing the process definition
    ID](img/B19383_08_005.jpg)'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图8.5 – 包含流程定义ID的BPMN文件快照](img/B19383_08_005.jpg)'
- en: <st c="24570">Figure 8.5 – A snapshot of a BPMN file containing the process
    definition ID</st>
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="24570">图8.5 – 包含流程定义ID的BPMN文件快照</st>
- en: <st c="24645">After activating SpiffWorkflow with its parser, the next step
    is to build web flows through the view functions.</st> <st c="24758">The</st>
    <st c="24761">view implementations will be a series of page redirections that
    will gather all the necessary form data values for the</st> *<st c="24881">user
    tasks</st>* <st c="24891">of the BPMN workflow.</st> <st c="24914">The following</st>
    `<st c="24928">choose_specialization()</st>` <st c="24951">view will be the first
    web form to start since it will simulate the</st> **<st c="25020">Doctor’s Specialization</st>**
    **<st c="25044">Form</st>** <st c="25048">task:</st>
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="24645">在激活SpiffWorkflow及其解析器后，下一步是通过视图函数构建网页流程。</st> <st c="24758">视图实现将是一系列页面重定向，这将收集BPMN工作流程的*<st
    c="24881">用户任务</st>* <st c="24891">所需的所有必要表单数据值。</st> <st c="24914">以下</st> `<st
    c="24928">choose_specialization()</st>` <st c="24951">视图将是第一个网页表单，因为它将模拟**<st
    c="25020">医生的专长</st>** **<st c="25044">表单</st>** <st c="25048">任务：</st>
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '@doc_bp.route("/doctor/select", methods = ["GET", "POST"])'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '@doc_bp.route("/doctor/select", methods = ["GET", "POST"])'
- en: 'async def select_doctor():'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 'async def select_doctor():'
- en: 'if request.method == "GET":'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if request.method == "GET":'
- en: return render_template("doc_doctors_form.html")
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return render_template("doc_doctors_form.html")
- en: session['docid'] = request.form['docid']
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: session['docid'] = request.form['docid']
- en: return redirect(url_for("doc_bp.reserve_schedule") )
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return redirect(url_for("doc_bp.reserve_schedule") )
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: <st c="26144">@doc_bp.route("/doctor/schedule",</st><st c="26178">methods =
    ["GET", "POST"])</st>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26144">@doc_bp.route("/doctor/schedule",</st><st c="26178">methods =
    ["GET", "POST"])</st>
- en: '<st c="26205">async def reserve_schedule():</st> if request.method == "GET":
    <st c="26264">return render_template("doc_schedule_form.html"), 201</st> session[''appt_date'']
    = request.form[''appt_date'']'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="26205">async def reserve_schedule():</st> if request.method == "GET":
    <st c="26264">return render_template("doc_schedule_form.html"), 201</st> session[''appt_date'']
    = request.form[''appt_date'']'
- en: 'session[''appt_time''] = request.form[''appt_time''] <st c="26505">provide_patient_details()</st>,
    will trigger the workflow execution besides its goal to extract the patient information
    required for the appointment scheduling and consolidate it with the other details
    from the previous views. The following is the code for the <st c="26761">provide_patient_details()</st>
    view:'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: session['appt_time'] = request.form['appt_time'] <st c="26505">provide_patient_details()</st>,
    将触发工作流程执行，除了其提取预约安排所需的患者信息并与其他之前的视图中的其他详情合并的目标之外。以下是为`<st c="26761">provide_patient_details()</st>`视图的代码：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*<st c="28271">Session handling</st>* <st c="28288">provides the</st> `<st
    c="28302">provide_patient_details()</st>` <st c="28327">view with the ability
    to gather all appointment details from the previous web views.</st> <st c="28413">As
    depicted in the given code, all session data, including</st> <st c="28471">the
    patient details from its form, are placed in its</st> `<st c="28525">form_data</st>`
    <st c="28534">dictionary.</st> <st c="28547">Utilizing the session is a workaround
    because it is not feasible to fuse the workflow loops required by the SpiffWorkflow
    library and the web flows.</st> <st c="28696">The last redirected page must initiate
    the workflow with the</st> `<st c="28757">BpmnWorkflow</st>` <st c="28769">class.</st>
    <st c="28777">But what is the difference between the</st> `<st c="28816">CamundaParser</st>`
    <st c="28829">and</st> `<st c="28834">BpmnWorkflow</st>` <st c="28846">API classes?</st>
    <st c="28860">We answer this question in the</st> <st c="28891">next section.</st>'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*<st c="28271">会话处理</st>* <st c="28288">提供了</st> `<st c="28302">provide_patient_details()</st>`
    <st c="28327">视图，具有从之前的网页视图收集所有预约详情的能力。</st> <st c="28413">如给定代码所示，所有会话数据，包括</st>
    <st c="28471">其表单中的患者详情，都被放置在其</st> `<st c="28525">form_data</st>` <st c="28534">字典中。</st>
    <st c="28547">利用会话是一个解决方案，因为将SpiffWorkflow库所需的流程循环与网页流程融合是不可行的。</st> <st c="28696">最后一个重定向的页面必须使用</st>
    `<st c="28757">BpmnWorkflow</st>` <st c="28769">类</st> <st c="28777">启动工作流程。</st>
    <st c="28777">但</st> `<st c="28816">CamundaParser</st>` <st c="28829">和</st> `<st
    c="28834">BpmnWorkflow</st>` <st c="28846">API类</st> <st c="28860">之间有什么区别？</st>
    <st c="28891">我们将在下一节回答这个问题。</st>'
- en: <st c="28904">Distinguishing between workflow specifications and instances</st>
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="28904">区分工作流程规范和实例</st>
- en: <st c="28965">There are two categories of components in SpiffWorkflow:</st>
    *<st c="29023">specification</st>* <st c="29036">and</st> *<st c="29041">instance</st>*
    <st c="29049">objects.</st> `<st c="29059">CamundaParser</st>`<st c="29072">,
    through</st> <st c="29082">its</st> `<st c="29086">get_spec()</st>` <st c="29096">method,
    returns a</st> `<st c="29115">WorkflowSpec</st>` <st c="29127">instance object,
    a specification or model object that defines the BPMN workflow.</st> <st c="29209">On
    the other hand,</st> `<st c="29228">BpmnWorkflow</st>` <st c="29240">creates a</st>
    `<st c="29251">Workflow</st>` <st c="29259">instance object, which tracks and
    returns actual workflow activities.</st> <st c="29330">However,</st> `<st c="29339">BpmnWorkflow</st>`
    <st c="29351">requires the workflow specification object as its constructor parameter</st>
    <st c="29424">before instantiation.</st>
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="28965">SpiffWorkflow中包含两种组件类别：</st> *<st c="29023">规范</st>* <st c="29036">和</st>
    *<st c="29041">实例</st>* <st c="29049">对象。</st> `<st c="29059">CamundaParser</st>`<st
    c="29072">通过</st> <st c="29082">其</st> `<st c="29086">get_spec()</st>` <st c="29096">方法，返回一个</st>
    `<st c="29115">WorkflowSpec</st>` <st c="29127">实例对象，这是一个定义BPMN工作流的规范或模型对象。</st>
    <st c="29209">另一方面，</st> `<st c="29228">BpmnWorkflow</st>` <st c="29240">创建一个</st>
    `<st c="29251">Workflow</st>` <st c="29259">实例对象，该对象跟踪并返回实际的工作流活动。</st> <st c="29330">然而，</st>
    `<st c="29339">BpmnWorkflow</st>` <st c="29351">在实例化之前需要将工作流规范对象作为其构造函数参数</st>
    <st c="29424">。</st>
- en: <st c="29445">The workflow instance will provide all sequence flows from the
    start until the stop event and the tasks with their corresponding state.</st>
    <st c="29582">All the states, such as</st> `<st c="29606">READY</st>`<st c="29611">,</st>
    `<st c="29613">CANCELLED</st>`<st c="29622">,</st> `<st c="29624">COMPLETED</st>`<st
    c="29633">, and</st> `<st c="29639">FUTURE</st>`<st c="29645">, are indicated
    in the</st> `<st c="29668">TaskState</st>` <st c="29677">API coupled with hook
    methods found in the</st> `<st c="29721">Task</st>` <st c="29725">instance object.</st>
    <st c="29743">But how does SpiffWorkflow determine a BPMN task?</st> <st c="29793">We
    will see that in the</st> <st c="29817">next section.</st>
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="29445">工作流实例将提供从开始事件到停止事件的全部序列流以及相应的任务状态。</st> <st c="29582">所有状态，例如</st>
    `<st c="29606">READY</st>`<st c="29611">，</st> `<st c="29613">CANCELLED</st>`<st
    c="29622">，</st> `<st c="29624">COMPLETED</st>`<st c="29633">，和</st> `<st c="29639">FUTURE</st>`<st
    c="29645">，都在</st> `<st c="29668">TaskState</st>` <st c="29677">API中指示，该API与在</st>
    `<st c="29721">Task</st>` <st c="29725">实例对象中找到的钩子方法相关联。</st> <st c="29743">但是，SpiffWorkflow如何确定BPMN任务呢？</st>
    <st c="29793">我们将在下一节中看到。</st>
- en: <st c="29830">Identifying between task specifications and instances</st>
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="29830">区分任务规范和实例</st>
- en: <st c="29884">As with the workflow, each SpiffWorkflow task has a specification
    object called</st> `<st c="29965">TaskSpec</st>`<st c="29973">, which provides
    details such as the</st> *<st c="30010">name of the task definition</st>* <st
    c="30037">and</st> *<st c="30042">task type</st>*<st c="30051">, such as</st>
    `<st c="30061">UserTask</st>` <st c="30069">or</st> `<st c="30073">ScriptTask</st>`<st
    c="30083">. On the other hand, the task instance object is named</st> `<st c="30138">Task</st>`<st
    c="30142">. The workflow instance</st> <st c="30165">object provides</st> `<st
    c="30182">get_tasks()</st>` <st c="30193">overrides that give all tasks based
    on a specific state or</st> `<st c="30253">TaskSpec</st>` <st c="30261">instance.</st>
    <st c="30272">Moreover, it has</st> `<st c="30289">get_task_from_id()</st>` <st
    c="30307">to extract the</st> `<st c="30323">Task</st>` <st c="30327">instance
    object based on</st> *<st c="30353">task ID</st>*<st c="30360">,</st> `<st c="30362">get_task_spec_from_name()</st>`
    <st c="30387">to retrieve the</st> `<st c="30404">TaskSpec</st>` <st c="30412">name
    based on its indicated BPMN name, and</st> `<st c="30456">get_tasks_from_spec_name()</st>`
    <st c="30482">to retrieve all tasks based on a</st> `<st c="30516">TaskSpec</st>`
    <st c="30524">definition name.</st>
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="29884">与工作流一样，每个SpiffWorkflow任务都有一个名为</st> `<st c="29965">TaskSpec</st>`<st
    c="29973">的规范对象，它提供有关任务定义的名称和任务类型等详细信息，例如</st> *<st c="30010">任务定义的名称</st>* <st
    c="30037">和</st> *<st c="30042">任务类型</st>*<st c="30051">，如</st> `<st c="30061">UserTask</st>`
    <st c="30069">或</st> `<st c="30073">ScriptTask</st>`<st c="30083">。另一方面，任务实例对象被命名为</st>
    `<st c="30138">Task</st>`<st c="30142">。工作流实例</st> <st c="30165">对象提供</st> `<st
    c="30182">get_tasks()</st>` <st c="30193">重载，根据特定状态或</st> `<st c="30253">TaskSpec</st>`
    <st c="30261">实例返回所有任务。</st> <st c="30272">此外，它还有</st> `<st c="30289">get_task_from_id()</st>`
    <st c="30307">，根据</st> *<st c="30353">任务ID</st>*<st c="30360">提取</st> `<st c="30323">Task</st>`
    <st c="30327">实例对象，</st> `<st c="30362">get_task_spec_from_name()</st>` <st c="30387">根据其指示的BPMN名称检索</st>
    `<st c="30404">TaskSpec</st>` <st c="30412">名称，以及</st> `<st c="30456">get_tasks_from_spec_name()</st>`
    <st c="30482">根据</st> `<st c="30516">TaskSpec</st>` <st c="30524">定义名称检索所有任务。</st>
- en: <st c="30541">To traverse and track every</st> `<st c="30570">UserTask</st>`<st
    c="30578">,</st> `<st c="30580">ManualTask</st>`<st c="30590">, or</st> `<st c="30595">Gateway</st>`
    <st c="30602">task and their trailing</st> `<st c="30627">ScriptTask</st>` <st
    c="30637">task(s) based on the BPMN diagram starting from</st> `<st c="30686">StartEvent</st>`<st
    c="30696">, invoke the</st> `<st c="30709">do_engine_steps()</st>` <st c="30726">of
    the workflow instance.</st> <st c="30753">A loop must call the</st> `<st c="30774">do_engine_steps()</st>`
    <st c="30791">method to track every activity in the workflow, including events
    and</st> `<st c="30861">ScriptTask</st>` <st c="30871">tasks until it reaches</st>
    `<st c="30895">EndEvent</st>`<st c="30903">. Thus,</st> `<st c="30911">provide_patient_details()</st>`
    <st c="30936">has a</st> `<st c="30943">while</st>` <st c="30948">loop in the</st>
    `<st c="30961">POST</st>` <st c="30965">transaction to traverse the workflow and
    execute every</st> `<st c="31021">Task</st>` <st c="31025">object with the</st>
    `<st c="31042">run_task_from_id()</st>` <st c="31060">method of the</st> <st c="31075">workflow
    instance.</st>
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="30541">为了遍历和跟踪每个</st> `<st c="30570">UserTask</st>`<st c="30578">、</st>
    `<st c="30580">ManualTask</st>`<st c="30590">或</st> `<st c="30595">Gateway</st>`
    <st c="30602">任务及其后续的</st> `<st c="30627">ScriptTask</st>` <st c="30637">任务（们）</st>，基于从</st>
    `<st c="30686">StartEvent</st>`<st c="30696">开始的 BPMN 图，调用工作流实例的</st> `<st c="30709">do_engine_steps()</st>`
    <st c="30726">方法。</st> <st c="30753">必须调用</st> `<st c="30774">do_engine_steps()</st>`
    <st c="30791">方法来跟踪工作流中的每个活动，包括事件和</st> `<st c="30861">ScriptTask</st>` <st c="30871">任务，直到达到</st>
    `<st c="30895">EndEvent</st>`<st c="30903">。因此，</st> `<st c="30911">provide_patient_details()</st>`
    <st c="30936">在</st> `<st c="30961">POST</st>` <st c="30965">事务中有一个</st> `<st
    c="30943">while</st>` <st c="30948">循环来遍历工作流并执行每个</st> `<st c="31021">Task</st>`
    <st c="31025">对象，使用工作流实例的</st> `<st c="31042">run_task_from_id()</st>` <st c="31060">方法。</st>
- en: <st c="31093">But running tasks, specifically</st> `<st c="31126">UserTask</st>`
    <st c="31134">and</st> `<st c="31139">ScriptTask</st>`<st c="31149">, is not only
    concerned with the fulfillment of the workflow activity but also the passing of
    some</st> <st c="31248">task data.</st>
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="31093">但是运行任务，特别是</st> `<st c="31126">UserTask</st>` <st c="31134">和</st>
    `<st c="31139">ScriptTask</st>`<st c="31149">，不仅涉及工作流活动的完成，还包括一些</st> <st c="31248">任务数据。</st>
- en: <st c="31258">Passing form data to UserTask</st>
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="31258">将表单数据传递给UserTask</st>
- en: '`<st c="31288">UserTask</st>`<st c="31297">’s form fields are among the several
    sources of BPMN workflow data.</st> <st c="31366">The Camunda Modeler allows the
    BPMN</st> <st c="31402">designer to create form variables for each</st> `<st c="31445">UserTask</st>`
    <st c="31453">task.</st> *<st c="31460">Figure 8</st>**<st c="31468">.6</st>*
    <st c="31470">shows the three form fields, namely</st> `<st c="31507">patientid</st>`<st
    c="31516">,</st> `<st c="31518">ticketid</st>`<st c="31526">, and</st> `<st c="31532">priority_level</st>`<st
    c="31546">, of the</st> **<st c="31555">Patient Detail Form</st>** <st c="31574">task
    and the portion of the Camunda Modeler where to add</st> <st c="31632">form variables:</st>'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="31288">UserTask</st>`<st c="31297">的表单字段是 BPMN 工作流数据的几个来源之一。</st> <st
    c="31366">Camunda 模型器允许 BPMN</st> <st c="31402">设计者为每个</st> `<st c="31445">UserTask</st>`
    <st c="31453">任务创建表单变量。</st> *<st c="31460">图 8</st>**<st c="31468">.6</st>* <st
    c="31470">显示了三个表单字段，即</st> `<st c="31507">patientid</st>`<st c="31516">、</st>
    `<st c="31518">ticketid</st>`<st c="31526">和</st> `<st c="31532">priority_level</st>`<st
    c="31546">，的</st> **<st c="31555">患者详细信息表单</st>** <st c="31574">任务以及 Camunda 模型器中添加表单变量的部分：</st>'
- en: '![Figure 8.6 – Adding form fields to UserTask](img/B19383_08_006.jpg)'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 8.6 – 向 UserTask 添加表单字段](img/B19383_08_006.jpg)'
- en: <st c="31777">Figure 8.6 – Adding form fields to UserTask</st>
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="31777">图 8.6 – 向 UserTask 添加表单字段</st>
- en: <st c="31820">The presence of form fields in a custom-generated form requires
    data passing to these form variables through the view function.</st> <st c="31949">Form
    fields without values will yield exceptions that can halt workflow</st> <st c="32021">executions,
    eventually ruining the Flask application.</st> <st c="32075">The</st> `<st c="32079">while</st>`
    <st c="32084">loop in the following code snippet of the</st> `<st c="32127">provide_patient_details()</st>`
    <st c="32152">view calls an</st> `<st c="32167">upload_login_form_data()</st>`
    <st c="32191">custom method that assigns values from the</st> `<st c="32235">form_data</st>`
    <st c="32244">dictionary to each</st> `<st c="32264">UserTask</st>` <st c="32272">form
    variable:</st>
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="31820">自定义生成的表单中存在表单字段需要通过视图函数将这些表单变量传递数据。</st>` `<st c="31949">没有值的表单字段将产生异常，这可能会停止工作流`
    `<st c="32021">执行，最终破坏Flask应用程序。</st>` `<st c="32075">以下代码片段中的`<st c="32079">while</st>`
    `<st c="32084">循环调用` `<st c="32127">provide_patient_details()</st>` `<st c="32152">视图调用一个`
    `<st c="32167">upload_login_form_data()</st>` `<st c="32191">自定义方法，该方法将` `<st
    c="32235">form_data</st>` `<st c="32244">字典中的值分配给每个` `<st c="32264">用户任务</st>`
    `<st c="32272">表单变量：</st>`'
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: <st c="33232">The</st> `<st c="33237">upload_login_form_data()</st>` <st c="33261">method
    determines each form field through its</st> *<st c="33308">ID</st>* <st c="33310">and
    extracts its appropriate</st> <st c="33340">value from the</st> `<st c="33355">form_data</st>`
    <st c="33364">dictionary.</st> <st c="33377">Then, the custom method, shown in
    the following snippet, assigns the value to the form field and uploads the field-value
    pair as</st> *<st c="33506">workflow data</st>* <st c="33519">using the</st> `<st
    c="33530">DeepMerge</st>` <st c="33539">utility class</st> <st c="33554">of SpiffWorkflow:</st>
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="33232">The</st>` `<st c="33237">upload_login_form_data()</st>` `<st
    c="33261">方法通过其` *<st c="33308">ID</st>* `<st c="33310">确定每个表单字段，并从`<st c="33340">form_data</st>`
    `<st c="33355">字典中提取其适当的`<st c="33364">值。</st>` `<st c="33377">然后，自定义方法，如下面的代码片段所示，将值分配给表单字段，并使用`<st
    c="33530">DeepMerge</st>` `<st c="33539">实用类`<st c="33554">将字段值对作为` *<st c="33506">工作流数据</st>`
    `<st c="33519">上传到SpiffWorkflow：</st>`'
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <st c="33779">Technically,</st> `<st c="33793">update_data()</st>` <st c="33806">creates
    a dictionary object containing the field name as the key and its corresponding</st>
    `<st c="33894">form_data</st>` <st c="33903">value.</st>
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 技术上讲，`<st c="33779">update_data()</st>` `<st c="33793">创建一个字典对象，其中字段名称作为键，其对应的`<st
    c="33894">form_data</st>` `<st c="33903">值。</st>`
- en: <st c="33910">But how about</st> `<st c="33925">ScriptTask</st>`<st c="33935">?
    Can it have</st> <st c="33948">form variables, too?</st> <st c="33970">Let’s explore
    that in the</st> <st c="33996">next section.</st>
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但是关于`<st c="33925">ScriptTask</st>` `<st c="33935">？它也能有表单变量吗？` `<st c="33970">让我们在下一节中探讨这个问题。</st>`
- en: <st c="34009">Adding input variables to ScriptTask</st>
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加ScriptTask的输入变量
- en: '`<st c="34046">ScriptTask</st>` <st c="34057">can also have input variables
    but not form fields.</st> <st c="34109">These input variables also need values
    from the view function</st> <st c="34171">because these are essential parts of
    its expressions.</st> <st c="34225">Sometimes,</st> `<st c="34236">ScriptTask</st>`
    <st c="34246">does not need inputs from views because it can extract existing
    workflow data to build its conditional expression.</st> <st c="34362">But for
    sure, it must emit output variable(s) that the succeeding</st> `<st c="34428">Gateway</st>`<st
    c="34435">,</st> `<st c="34437">ScriptTask</st>`<st c="34447">, or</st> `<st c="34452">UserTask</st>`
    <st c="34460">task needs to pursue their execution.</st> *<st c="34499">Figure
    8</st>**<st c="34507">.7</st>* <st c="34509">shows the</st> `<st c="34553">proceed</st>`
    <st c="34560">output variable and how it extracts and uses the profile information
    from the</st> <st c="34639">workflow data:</st>'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="34046">ScriptTask</st>` `<st c="34057">也可以有输入变量，但没有表单字段。</st>` `<st
    c="34109">这些输入变量也需要从视图函数中获取值，因为这些是其表达式的必要部分。</st>` `<st c="34225">有时，`<st c="34236">ScriptTask</st>`
    `<st c="34246">不需要从视图中获取输入，因为它可以提取现有的工作流数据来构建其条件表达式。</st>` `<st c="34362">但肯定的是，它必须发出后续`<st
    c="34428">网关</st>` `<st c="34435">` `<st c="34437">ScriptTask</st>` `<st c="34447">`
    或 `<st c="34452">用户任务</st>` `<st c="34460">任务需要执行的输出变量。</st>` *<st c="34499">图8</st>**
    `<st c="34507">.7</st>` `<st c="34509">显示了`<st c="34553">proceed</st>` `<st c="34560">输出变量以及它是如何从工作流数据中提取和使用配置文件信息的：</st>`'
- en: '![Figure 8.7 – Utilizing variables in ScriptTask](img/B19383_08_007.jpg)'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图8.7 – 在ScriptTask中利用变量](img/B19383_08_007.jpg)'
- en: <st c="34909">Figure 8.7 – Utilizing variables in ScriptTask</st>
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.7 – 在ScriptTask中利用变量
- en: <st c="34955">After running all the tasks and uploading all the values to the
    different variables in the workflow, the result of the</st> <st c="35074">workflow
    must be variables that will decide the result of the view function; in our case,
    the</st> `<st c="35169">provide_patient_details()</st>` <st c="35194">view.</st>
    <st c="35201">Let us now retrieve these results to determine the type of responses
    our views</st> <st c="35280">will render.</st>
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="34955">在运行所有任务并将所有值上传到工作流程中不同变量的后，工作流程的结果必须是决定视图函数结果的变量；在我们的案例中，是</st>
    `<st c="35169">provide_patient_details()</st>` <st c="35194">视图。</st> <st c="35201">现在让我们检索这些结果以确定我们的视图将渲染的响应类型。</st>
- en: <st c="35292">Managing the result of the workflow</st>
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="35292">管理工作流程的结果</st>
- en: <st c="35328">The goal of our workflow through SpiffWorkflow is to determine
    the view page a route function will render.</st> <st c="35436">Together with this
    is the execution of the required backend transactions, such as saving the</st>
    <st c="35529">scheduled appointment into the database, sending notifications to
    the doctors for the newly created appointment, and generating the necessary documents
    for the schedule.</st> <st c="35699">The workflow’s generated data will determine
    the resulting processes of the view.</st> <st c="35781">In our appointment workflow,
    when the generated</st> `<st c="35829">finalize_sched</st>` <st c="35843">variable
    is</st> `<st c="35856">True</st>`<st c="35860">, the view will redirect the user
    to the doctor’s dashboard page.</st> <st c="35926">Otherwise, the user will see
    the first page of the</st> <st c="35977">data-gathering process.</st>
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="35328">通过SpiffWorkflow，我们工作流程的目标是确定路由函数将渲染的视图页面。</st> <st c="35436">与此相关的是执行所需的后端事务，例如将</st>
    <st c="35529">预约计划保存到数据库中，向医生发送新创建的预约通知，以及生成必要的日程安排文档。</st> <st c="35699">工作流程生成数据将决定视图的结果过程。</st>
    <st c="35781">在我们的预约工作流程中，当生成的</st> `<st c="35829">finalize_sched</st>` <st c="35843">变量是</st>
    `<st c="35856">True</st>`<st c="35860">时，视图将重定向用户到医生的仪表板页面。</st> <st c="35926">否则，用户将看到数据收集过程的第一页。</st>
- en: <st c="36000">Let us now explore the capability of SpiffWorkflow to implement</st>
    <st c="36065">non-BPMN workflows.</st>
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="36000">现在让我们探索SpiffWorkflow实现</st> <st c="36065">非BPMN工作流程的能力。</st>
- en: <st c="36084">Implementing a non-BPMN workflow</st>
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="36084">实现非BPMN工作流程</st>
- en: <st c="36117">SpiffWorkflow can implement workflows in JSON or Python configurations.</st>
    <st c="36190">In our</st> `<st c="36197">ch08-spiff-web</st>` <st c="36211">project,
    we have the</st> <st c="36232">following Python class that implements a prototype
    of a payment</st> <st c="36297">process workflow:</st>
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="36117">SpiffWorkflow可以使用JSON或Python配置实现工作流程。</st> <st c="36190">在我们的</st>
    `<st c="36197">ch08-spiff-web</st>` <st c="36211">项目中，我们有一个</st> <st c="36232">以下Python类，它实现了支付</st>
    <st c="36297">流程工作流程的原型：</st>
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '@payment_bp.route("/payment/start", methods = ["GET", "POST"])'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '@payment_bp.route("/payment/start", methods = ["GET", "POST"])'
- en: 'async def start_payment_form():'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 'async def start_payment_form():'
- en: 'if request.method == "GET":'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if request.method == "GET":'
- en: return render_template("payment_form.html"), 201
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return render_template("payment_form.html"), 201
- en: '… … … … … … <st c="39220">Task</st> list will start the workflow:'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: … … … … … … <st c="39220">任务</st> 列表将启动工作流程：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: <st c="39450">This</st> `<st c="39456">Task</st>` <st c="39460">list will load
    all payment data to the workflow and execute the</st> `<st c="39525">tx_patient_pay()</st>`
    <st c="39541">callback method</st> <st c="39557">to process</st> <st c="39569">payment
    transactions:</st>
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="39450">此</st> `<st c="39456">任务</st>` <st c="39460">列表将加载所有支付数据到工作流程中，并执行</st>
    `<st c="39525">tx_patient_pay()</st>` <st c="39541">回调方法</st> <st c="39557">以处理</st>
    <st c="39569">支付交易：</st>
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: <st c="39954">This part of the workflow will execute the</st> `<st c="39998">ExclusiveChoice</st>`
    <st c="40013">event to compare the payment amount paid by the</st> <st c="40062">patient
    against the patient’s</st> <st c="40092">total charges:</st>
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="39954">此部分工作流程将执行</st> `<st c="39998">ExclusiveChoice</st>` <st c="40013">事件，以比较患者支付的金额与患者的</st>
    <st c="40062">总费用：</st>
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: <st c="40324">If the patient fully paid the charges, the following tasks will
    execute the</st> `<st c="40401">tx_patient_release()</st>` <st c="40421">callback
    method to clear and issue release notifications to</st> <st c="40482">the patient:</st>
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="40324">如果患者全额支付了费用，以下任务将执行</st> `<st c="40401">tx_patient_release()</st>`
    <st c="40421">回调方法以清除并发布给患者</st> `<st c="40482">的释放通知：</st>
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: <st c="40766">If the patient has partially paid the charges, the following tasks
    will execute the</st> `<st c="40851">tx_patient_onhold()</st>` <st c="40870">callback
    method:</st>
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="40766">如果患者已部分支付费用，以下任务将执行</st> `<st c="40851">tx_patient_onhold()</st>`
    <st c="40870">回调方法：</st>
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: <st c="41272">The result of the workflow will decide on what page the view will
    redirect the user to, whether the</st> *<st c="41373">releasing</st>* <st c="41382">or</st>
    *<st c="41386">on-hold</st>* <st c="41393">page.</st>
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="41272">工作流程的结果将决定视图将用户重定向到哪个页面，是</st> *<st c="41373">释放</st>* <st c="41382">还是</st>
    *<st c="41386">挂起</st>* <st c="41393">页面。</st>
- en: <st c="41399">Now, SpiffWorkflow will lessen the coding effort in building the
    workflow because it has defined API classes that support both BPMN and non-BPMN
    workflow implementation.</st> <st c="41570">But what if the need is to trigger</st>
    <st c="41604">workflows through API endpoints that SpiffWorkflow can</st> <st
    c="41660">hardly handle?</st>
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="41399">现在，SpiffWorkflow 将减少构建工作流程的编码工作量，因为它已经定义了支持 BPMN 和非 BPMN 工作流程实现的
    API 类。</st> <st c="41570">但如果需要通过 SpiffWorkflow 几乎无法处理的 API 端点触发</st> <st c="41604">工作流程呢？</st>
- en: <st c="41674">The next topic will focus on using a BPMN workflow engine that
    the Camunda platform uses in running tasks through</st> <st c="41789">API endpoints.</st>
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="41674">下一主题将重点介绍使用 Camunda 平台使用的 BPMN 工作流程引擎，通过 API 端点运行任务。</st>
- en: <st c="41803">Building service tasks with the Zeebe/Camunda platforms</st>
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="41803">使用 Zeebe/Camunda 平台构建服务任务</st>
- en: '**<st c="41859">Camunda</st>** <st c="41867">is a popular lightweight workflow
    and decision automation engine with built-in powerful tools, such as the</st>
    *<st c="41975">Camunda Modeler</st>*<st c="41990">,</st> *<st c="41992">Cawemo</st>*<st
    c="41998">, and the</st> *<st c="42008">Zeebe</st>* <st c="42013">broker.</st>
    <st c="42022">But this chapter is not about Camunda</st> <st c="42059">but about
    using Camunda’s</st> *<st c="42086">Zeebe server</st>* <st c="42098">to deploy,
    run, and execute workflow tasks built by the</st> <st c="42155">Flask framework.</st>
    <st c="42172">The goal is to create a Flask client application that will deploy
    and run BPMN workflows designed by the Camunda Modeler using the Zeebe</st> <st
    c="42309">workflow engine.</st>'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**<st c="41859">Camunda</st>** <st c="41867">是一个流行的轻量级工作流程和决策自动化引擎，内置强大的工具，如</st>
    *<st c="41975">Camunda Modeler</st>*<st c="41990">，</st> *<st c="41992">Cawemo</st>*<st
    c="41998">，以及</st> *<st c="42008">Zeebe</st>* <st c="42013">代理。</st> <st c="42022">但本章不是关于
    Camunda</st> <st c="42059">，而是关于使用 Camunda 的</st> *<st c="42086">Zeebe 服务器</st>*
    <st c="42098">来部署、运行和执行由 Flask 框架构建的工作流程任务。</st> <st c="42155">目标是创建一个 Flask 客户端应用程序，该应用程序将使用
    Zeebe 工作流程引擎部署和运行由 Camunda Modeler 设计的 BPMN 工作流程。</st> <st c="42172">目标是创建一个 Flask
    客户端应用程序，该应用程序将使用 Zeebe 工作流程引擎部署和运行由 Camunda Modeler 设计的 BPMN 工作流程。</st>'
- en: <st c="42325">Let us start with the setup and configurations needed to integrate
    Flask with the</st> <st c="42408">Zeebe server.</st>
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="42325">让我们从整合 Flask 与 Zeebe 服务器所需的设置和配置开始。</st>
- en: <st c="42421">Setting up the Zeebe server</st>
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="42421">设置 Zeebe 服务器</st>
- en: <st c="42449">The easiest way to</st> <st c="42468">run the Zeebe server is
    to use Docker to run its</st> `<st c="42518">camunda/zeebe</st>` <st c="42531">image.</st>
    <st c="42539">So, read first the updated</st> *<st c="42566">Docker Subscription
    Service Agreement</st>* <st c="42603">before downloading and installing</st> <st
    c="42638">Docker Desktop, available</st> <st c="42664">from</st> [<st c="42669">https://docs.docker.com/desktop/install/windows-install/</st>](https://docs.docker.com/desktop/install/windows-install/)<st
    c="42725">.</st>
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="42449">运行 Zeebe 服务器的最简单方法是使用 Docker 运行其</st> `<st c="42518">camunda/zeebe</st>`
    <st c="42531">镜像。</st> <st c="42539">因此，在下载和安装</st> *<st c="42566">Docker 订阅服务协议</st>*
    <st c="42603">之前，请先阅读更新后的内容</st> <st c="42638">Docker Desktop，可在</st> <st c="42664">以下链接</st>
    [<st c="42669">https://docs.docker.com/desktop/install/windows-install/</st>](https://docs.docker.com/desktop/install/windows-install/)<st
    c="42725">找到。</st>
- en: <st c="42726">After the installation, start the Docker engine, open a terminal,
    and run the following</st> <st c="42815">Docker command:</st>
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="42726">安装完成后，启动 Docker 引擎，打开终端，并运行以下</st> <st c="42815">Docker 命令：</st>
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: <st c="42933">A</st> *<st c="42936">Docker network</st>*<st c="42950">, as with
    our</st> `<st c="42964">ch08-network</st>`<st c="42976">, is needed to expose
    the ports to the development platform.</st> <st c="43037">Zeebe’s port</st> `<st
    c="43050">26500</st>` <st c="43055">is where the Flask client application will
    communicate to the server’s gateway API.</st> <st c="43140">After using Zeebe,
    run the</st> `<st c="43167">docker stop</st>` <st c="43178">command with</st>
    *<st c="43192">Zeebe’s container ID</st>* <st c="43212">to shut down</st> <st
    c="43226">the broker.</st>
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="42933">一个</st> *<st c="42936">Docker网络</st>*<st c="42950">，就像我们的</st>
    `<st c="42964">ch08-network</st>`<st c="42976">，需要暴露端口到开发平台。</st> <st c="43037">Zeebe的端口</st>
    `<st c="43050">26500</st>` <st c="43055">是Flask客户端应用程序将通信到服务器网关API的地方。</st> <st
    c="43140">使用Zeebe后，使用</st> `<st c="43167">docker stop</st>` <st c="43178">命令与</st>
    *<st c="43192">Zeebe的容器ID</st>* <st c="43212">一起关闭</st> <st c="43226">代理。</st>
- en: <st c="43237">Now, the next step is to install the suitable Python Zeebe client
    for</st> <st c="43308">the application.</st>
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="43237">现在，下一步是为应用程序安装合适的Python Zeebe客户端。</st>
- en: <st c="43324">Installing the pyzeebe library</st>
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="43324">安装pyzeebe库</st>
- en: <st c="43355">Lots of effective and popular Zeebe client libraries</st> <st
    c="43409">are Java-based.</st> <st c="43425">However,</st> `<st c="43434">pyzeebe</st>`
    <st c="43441">is one of the few Python external modules that are simple, easy
    to use, lightweight, and effective in establishing connectivity</st> <st c="43570">to
    the Zeebe server.</st> <st c="43591">It is a</st> *<st c="43599">gRPC</st>*<st
    c="43603">-based client library for Zeebe, typically designed to manage workflows
    that involve</st> <st c="43689">RESTful services.</st>
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="43355">许多有效且流行的Zeebe客户端库</st> <st c="43409">是基于Java的。</st> <st c="43425">然而，</st>
    `<st c="43434">pyzeebe</st>` <st c="43441">是少数几个简单、易于使用、轻量级且在建立与Zeebe服务器连接方面有效的Python外部模块之一。</st>
    <st c="43570">它是一个基于</st> *<st c="43599">gRPC</st>*<st c="43603">的Zeebe客户端库，通常设计用于管理涉及</st>
    <st c="43689">RESTful服务</st>的工作流程。</st>
- en: <st c="43706">Important note</st>
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="43706">重要提示</st>
- en: <st c="43721">gRPC is a flexible and high-performance RPC framework that can
    run in any environment and easily connect to any cluster, with support for access
    authentication, API health checking, load balancing, and open tracing.</st> <st
    c="43938">All Zeebe client libraries use gRPC to communicate with</st> <st c="43994">the
    server.</st>
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="43721">gRPC是一个灵活且高性能的RPC框架，可以在任何环境中运行，并轻松连接到任何集群，支持访问认证、API健康检查、负载均衡和开源跟踪。</st>
    <st c="43938">所有Zeebe客户端库都使用gRPC与</st> <st c="43994">服务器通信。</st>
- en: <st c="44005">Let us now install the</st> `<st c="44029">pyzeebe</st>` <st c="44036">library
    using the</st> `<st c="44055">pip</st>` <st c="44058">command:</st>
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="44005">现在让我们使用</st> `<st c="44029">pip</st>` <st c="44036">命令安装</st>
    `<st c="44029">pyzeebe</st>` <st c="44036">库：</st>
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: <st c="44087">After the installation and</st> <st c="44115">setup, it is time
    to create a BPMN workflow diagram using the</st> <st c="44177">Camunda Modeler.</st>
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="44087">安装和</st> <st c="44115">设置完成后，是时候使用</st> <st c="44177">Camunda
    Modeler</st>创建BPMN工作流程图了。</st>
- en: <st c="44193">Creating a BPMN diagram for pyzeebe</st>
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="44193">为pyzeebe创建BPMN图</st>
- en: '<st c="44229">The</st> `<st c="44234">pyzeebe</st>` <st c="44241">module can</st>
    <st c="44252">load and parse BPMN files used by</st> *<st c="44287">Camunda version
    8.0</st>*<st c="44306">. Since it is a small library, it can only read and execute</st>
    `<st c="44366">ServiceTask</st>` <st c="44377">tasks.</st> *<st c="44385">Figure
    8</st>**<st c="44393">.8</st>* <st c="44395">shows a BPMN diagram with two</st>
    `<st c="44426">ServiceTask</st>` <st c="44437">tasks:  the</st> **<st c="44449">Get
    Diagnostics</st>** <st c="44464">task, which</st> <st c="44476">retrieves all
    patients’ diagnoses, and the</st> **<st c="44520">Get Analysis</st>** <st c="44532">task,
    which returns the doctor’s resolutions or prescriptions to</st> <st c="44598">the
    diagnoses:</st>'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="44229">The</st> `<st c="44234">pyzeebe</st>` <st c="44241">模块可以</st>
    <st c="44252">加载和解析</st> *<st c="44287">Camunda版本8.0</st>*<st c="44306">. 由于它是一个小型库，它只能读取和执行</st>
    `<st c="44366">ServiceTask</st>` <st c="44377">任务。</st> *<st c="44385">图8.8</st>**<st
    c="44393">.8</st>* <st c="44395">显示了一个包含两个</st> `<st c="44426">ServiceTask</st>`
    <st c="44437">任务的BPMN图：</st> **<st c="44449">获取诊断</st>** <st c="44464">任务，该任务</st>
    <st c="44476">检索所有患者的诊断，以及</st> **<st c="44520">获取分析</st>** <st c="44532">任务，该任务将医生的决议或处方返回给</st>
    <st c="44598">诊断：</st>
- en: '![Figure 8.8 – A BPMN diagram with two ServiceTask tasks](img/B19383_08_008.jpg)'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图8.8 – 包含两个ServiceTask任务的BPMN图](img/B19383_08_008.jpg)'
- en: <st c="44706">Figure 8.8 – A BPMN diagram with two ServiceTask tasks</st>
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="44706">图8.8 – 包含两个ServiceTask任务的BPMN图</st>
- en: <st c="44760">The next step is to load and run the final BPMN document using
    the</st> `<st c="44828">pyzeebe</st>` <st c="44835">client library.</st> <st c="44852">Running
    the workflow activities from the BPMN diagram is impossible without a</st> `<st
    c="44930">pyzeebe</st>` *<st c="44937">worker</st>* <st c="44944">and</st> *<st
    c="44949">client</st>*<st c="44955">. But implementation of the worker must</st>
    <st c="44995">come first.</st>
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="44760">下一步是使用</st>` `<st c="44828">pyzeebe</st>` `<st c="44835">客户端库加载和运行最终的BPMN文档。</st>`
    `<st c="44852">没有</st>` `<st c="44930">pyzeebe</st>` `<st c="44937">worker</st>`
    `<st c="44944">和</st>` `<st c="44949">client</st>` `<st c="44955">，无法运行BPMN图中的工作流活动。</st>`
    `<st c="44995">但worker的实现必须</st>` `<st c="44995">首先进行。</st>`'
- en: <st c="45006">Creating a pyzeebe worker</st>
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="45006">创建pyzeebe worker</st>`'
- en: <st c="45032">A</st> `<st c="45035">pyzeebe</st>` <st c="45042">worker or a</st>
    `<st c="45055">ZeebeWorker</st>` <st c="45066">worker is a</st> <st c="45078">typical
    Zeebe worker that handles all</st> `<st c="45117">ServiceTask</st>` <st c="45128">tasks.</st>
    <st c="45136">It runs asynchronously in the background using</st> `<st c="45183">asyncio</st>`<st
    c="45190">.</st> `<st c="45192">pyzeebe</st>`<st c="45199">, as an asynchronous
    library, prefers a</st> `<st c="45239">Flask[async]</st>` <st c="45251">platform
    with</st> `<st c="45266">asyncio</st>` <st c="45273">utilities.</st> <st c="45285">But
    it requires</st> `<st c="45301">grpc.aio.Channel</st>` <st c="45317">as a constructor</st>
    <st c="45335">parameter</st> <st c="45345">before instantiation.</st>
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="45032">A</st>` `<st c="45035">pyzeebe</st>` `<st c="45042">worker或一个</st>`
    `<st c="45055">ZeebeWorker</st>` `<st c="45066">worker是一个</st>` `<st c="45078">典型的Zeebe
    worker，它处理所有</st>` `<st c="45117">ServiceTask</st>` `<st c="45128">任务。</st>` `<st
    c="45136">它使用</st>` `<st c="45183">asyncio</st>` `<st c="45190">异步地在后台运行。</st>`
    `<st c="45192">pyzeebe</st>` `<st c="45199">作为一个异步库，更喜欢具有</st>` `<st c="45239">Flask[async]</st>`
    `<st c="45251">平台和</st>` `<st c="45266">asyncio</st>` `<st c="45273">工具的</st>`
    `<st c="45285">。但它需要</st>` `<st c="45301">grpc.aio.Channel</st>` `<st c="45317">作为构造函数</st>`
    `<st c="45335">参数</st>` `<st c="45345">在实例化之前。</st>`'
- en: <st c="45366">The library provides three methods to create the needed channel,
    namely</st> `<st c="45439">create_insecure_channel()</st>`<st c="45464">,</st>
    `<st c="45466">create_secure_channel()</st>`<st c="45489">, and</st> `<st c="45495">create_camunda_cloud_channel()</st>`<st
    c="45525">. All three instantiate the channel, but w</st> `<st c="45568">create_insecure_channel()</st>`
    <st c="45593">disregards the TLS protocol, and</st> `<st c="45627">create_camunda_cloud_channel()</st>`
    <st c="45657">considers the connection to the Camunda cloud.</st> <st c="45705">Our</st>
    `<st c="45709">ch08-zeebe</st>` <st c="45719">application uses the insecure one
    to instantiate the</st> `<st c="45773">ZeebeWorker</st>` <st c="45784">worker
    and</st> <st c="45795">eventually manage the</st> `<st c="45818">ServiceTask</st>`
    <st c="45829">tasks indicated in our BPMN file.</st> <st c="45864">The following</st>
    `<st c="45878">worker-tasks</st>` <st c="45890">module script shows an independent
    Python application that contains the</st> `<st c="45963">ZeebeWorker</st>` <st
    c="45974">instantiation and its tasks</st> <st c="46003">or jobs:</st>
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="45366">该库提供了三种创建所需通道的方法，即</st>` `<st c="45439">create_insecure_channel()</st>`
    `<st c="45464">，</st>` `<st c="45466">create_secure_channel()</st>` `<st c="45489">，和</st>`
    `<st c="45495">create_camunda_cloud_channel()</st>` `<st c="45525">。所有三种都实例化了通道，但</st>`
    `<st c="45568">create_insecure_channel()</st>` `<st c="45593">忽略了TLS协议，而</st>`
    `<st c="45627">create_camunda_cloud_channel()</st>` `<st c="45657">考虑了与Camunda云的连接。</st>`
    `<st c="45705">我们的</st>` `<st c="45709">ch08-zeebe</st>` `<st c="45719">应用程序使用不安全的通道来实例化</st>`
    `<st c="45773">ZeebeWorker</st>` `<st c="45784">worker，并最终管理我们BPMN文件中指示的</st>`
    `<st c="45818">ServiceTask</st>` `<st c="45829">任务。</st>` `<st c="45864">以下</st>`
    `<st c="45878">worker-tasks</st>` `<st c="45890">模块脚本显示了一个包含</st>` `<st c="45963">ZeebeWorker</st>`
    `<st c="45974">实例化和其任务</st>` `<st c="46003">或作业的独立Python应用程序：</st>`'
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: <st c="46621">@worker.task(task_type="select_diagnosis",</st> <st c="46664">**Zeebe.TASK_DEFAULT_PARAMS)</st>
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="46621">@worker.task(task_type="select_diagnosis",</st>` `<st c="46664">**Zeebe.TASK_DEFAULT_PARAMS)</st>`'
- en: '<st c="46693">async def select_diagnosis(docid, patientid):</st> async with
    db_session() as sess:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="46693">async def select_diagnosis(docid, patientid):</st>` `async with
    db_session() as sess:`'
- en: 'async with sess.begin():'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`async with sess.begin():`'
- en: 'try:'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`try:`'
- en: repo = DiagnosisRepository(sess)
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`repo = DiagnosisRepository(sess)`'
- en: records = await repo. select_diag_doc_patient(docid, patientid)
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`records = await repo.select_diag_doc_patient(docid, patientid)`'
- en: diagnosis_rec = [rec.to_json() for rec in records]
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`diagnosis_rec = [rec.to_json() for rec in records]`'
- en: diagnosis_str = json.dumps(diagnosis_rec, default=json_date_serializer)
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`diagnosis_str = json.dumps(diagnosis_rec, default=json_date_serializer)`'
- en: 'return {"data": diagnosis_str}'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`return {"data": diagnosis_str}`'
- en: 'except Exception as e:'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`except Exception as e:`'
- en: print(e)
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`print(e)`'
- en: 'return {"data": json.dumps([])}'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '返回`{"data": json.dumps([])}`'
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: <st c="47616">@worker.task(task_type="retrieve_analysis", **Zeebe.TASK_DEFAULT_PARAMS)</st>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47616">@worker.task(task_type="retrieve_analysis", **Zeebe.TASK_DEFAULT_PARAMS)</st>
- en: '<st c="47689">async def retrieve_analysis(records):</st> try:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="47689">async def retrieve_analysis(records):</st> try:'
- en: records_diagnosis = json.loads(records)
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: records_diagnosis = json.loads(records)
- en: diagnosis_text = [dt['resolution'] for dt in records_diagnosis]
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: diagnosis_text = [dt['resolution'] for dt in records_diagnosis]
- en: 'return {"result": diagnosis_text}'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '返回 {"result": diagnosis_text}'
- en: 'except Exception as e:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 'except Exception as e:'
- en: print(e)
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打印(e)
- en: 'return {"result": []}'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '返回 {"result": []}'
- en: '[PRE24]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'if __name__ == "__main__": <st c="48821">ZeebeWorker</st> instance has a <st
    c="48848">work()</st> coroutine that must be running asynchronously at the back
    using an independent event, disconnected from Flask operations. Always run the
    module with the Python command, such as <st c="49032">python worker-tasks.py</st>.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 __name__ == "__main__": <st c="48821">ZeebeWorker</st> 实例有一个 <st c="48848">work()</st>
    协程，它必须在后台异步运行，使用独立的事件，与 Flask 操作断开连接。始终使用 Python 命令运行模块，例如 <st c="49032">python
    worker-tasks.py</st>。'
- en: <st c="49055">Let us now implement the</st> `<st c="49081">pyzeebe</st>` <st
    c="49088">client.</st>
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="49055">现在让我们实现</st> `<st c="49081">pyzeebe</st>` <st c="49088">客户端。</st>
- en: <st c="49096">Implementing the pyzeebe client</st>
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="49096">实现 pyzeebe 客户端</st>
- en: <st c="49128">The Flask application needs to</st> <st c="49159">instantiate
    the</st> `<st c="49176">ZeebeClient</st>` <st c="49187">class to connect to Zeebe.</st>
    <st c="49215">As with the</st> `<st c="49227">ZeebeWorker</st>`<st c="49238">,
    it also requires the same</st> `<st c="49266">grpc.aio.Channel</st>` <st c="49282">parameter
    as a constructor parameter before its instantiation.</st> <st c="49346">Since</st>
    `<st c="49352">ZeebeClient</st>` <st c="49363">behaves asynchronously like</st>
    `<st c="49392">ZeebeWorker</st>`<st c="49403">, all its operations must run asynchronously
    in the background as Celery tasks.</st> <st c="49483">But, unlike the worker,</st>
    `<st c="49507">ZeebeClient</st>` <st c="49518">appears in every Blueprint</st>
    <st c="49546">module as part of its Celery service</st> <st c="49582">tasks.</st>
    <st c="49590">The following is the</st> `<st c="49611">diagnosis_tasks</st>` <st
    c="49626">module script of the</st> *<st c="49648">doctor</st>* <st c="49654">Blueprint
    module that instantiates</st> `<st c="49690">ZeebeClient</st>` <st c="49701">with
    the</st> <st c="49711">Celery tasks:</st>
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="49128">Flask 应用需要</st> <st c="49159">实例化</st> `<st c="49176">ZeebeClient</st>`
    <st c="49187">类以连接到 Zeebe。</st> <st c="49215">与</st> `<st c="49227">ZeebeWorker</st>`<st
    c="49238">一样，它也需要在实例化之前将相同的</st> `<st c="49266">grpc.aio.Channel</st>` <st c="49282">参数作为构造函数参数。</st>
    <st c="49346">由于</st> `<st c="49352">ZeebeClient</st>` <st c="49363">的行为类似于</st>
    `<st c="49392">ZeebeWorker</st>`<st c="49403">，所有操作都必须在后台异步作为 Celery 任务运行。</st>
    <st c="49483">但是，与工作进程不同，</st> `<st c="49507">ZeebeClient</st>` <st c="49518">作为其
    Celery 服务任务的一部分出现在每个 Blueprint</st> <st c="49546">模块中。</st> <st c="49590">以下是在
    *<st c="49648">doctor</st>* <st c="49654">Blueprint 模块中实例化</st> `<st c="49690">ZeebeClient</st>`
    <st c="49701">并使用 Celery 任务</st> 的 `<st c="49611">diagnosis_tasks</st>` <st c="49626">模块脚本：</st>
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: <st c="50028">@shared_task(ignore_result=False)</st>
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50028">@shared_task(ignore_result=False)</st>
- en: '<st c="50061">def deploy_zeebe_wf(bpmn_file):</st> async def zeebe_wf(bpmn_file):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="50061">def deploy_zeebe_wf(bpmn_file):</st> async def zeebe_wf(bpmn_file):'
- en: 'try: <st c="50130">await client.deploy_process(bpmn_file)</st> return True'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'try: <st c="50130">await client.deploy_process(bpmn_file)</st> 返回 True'
- en: 'except Exception as e:'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'except Exception as e:'
- en: print(e)
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打印(e)
- en: 'return False <st c="50314">deploy_zeebe_wf()</st> task is the first process
    to run before anything else. The API endpoint calling this will load, parse, and
    deploy the BPMN file with the workflow to the Zeebe server using the asynchronous
    <st c="50521">deploy_process()</st> method of <st c="50548">ZeebeClient</st>.
    The task will throw an exception if the BPMN file has schema problems, is not
    well formed, or is invalid:'
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回 False <st c="50314">deploy_zeebe_wf()</st> 任务是在其他任何操作之前运行的第一个进程。调用此 API 端点的任务将加载、解析并将带有工作流的
    BPMN 文件部署到 Zeebe 服务器，使用 <st c="50521">deploy_process()</st> 方法，这是 <st c="50548">ZeebeClient</st>
    的异步方法。如果 BPMN 文件有模式问题、格式不正确或无效，任务将抛出异常：
- en: '[PRE26]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: <st c="52475">@doc_bp.get("/diagnosis/bpmn/deploy")</st>
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52475">@doc_bp.get("/diagnosis/bpmn/deploy")</st>
- en: '<st c="52513">async def deploy_diagnosis_analysis_bpmn():</st> try:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="52513">async def deploy_diagnosis_analysis_bpmn():</st> try:'
- en: filepath = os.path.join(Zeebe.BPMN_DUMP_PATH, "<st c="52610">dams_diagnosis.bpmn</st>")
    <st c="52634">task = deploy_zeebe_wf.apply_async(args=[filepath])</st><st c="52685">result
    = task.get()</st> return jsonify(data=result), 201
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: filepath = os.path.join(Zeebe.BPMN_DUMP_PATH, "<st c="52610">dams_diagnosis.bpmn</st>")
    <st c="52634">task = deploy_zeebe_wf.apply_async(args=[filepath])</st><st c="52685">result
    = task.get()</st> 返回 jsonify(data=result), 201
- en: 'except Exception as e:'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'except Exception as e:'
- en: print(e)
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打印(e)
- en: return jsonify(data="error"), 500
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return jsonify(data="error"), 500
- en: '[PRE27]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: <st c="52928">@doc_bp.post("/diagnosis/analysis/text")</st>
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="52928">@doc_bp.post("/diagnosis/analysis/text")</st>`'
- en: '<st c="52969">async def extract_analysis_text():</st> try:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="52969">async def extract_analysis_text():</st>` try:'
- en: data = request.get_json()
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: data = request.get_json()
- en: docid = data['docid']
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: docid = data['docid']
- en: patientid = int(data['patientid']) <st c="53093">task = run_zeebe_task.apply_async(args=[docid,</st>
    <st c="53139">patientid])</st><st c="53151">result = task.get()</st> return jsonify(result),
    201
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: patientid = int(data['patientid']) `<st c="53093">task = run_zeebe_task.apply_async(args=[docid,</st>`
    `<st c="53139">patientid])</st>` `<st c="53151">result = task.get()</st>` return
    jsonify(result), 201
- en: 'except Exception as e:'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'except Exception as e:'
- en: print(e)
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: print(e)
- en: return jsonify(data="error"), 500
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return jsonify(data="error"), 500
- en: '[PRE28]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '<st c="55684">airflow</st> module using the <st c="55709">pip</st> command:'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="55684">airflow</st>` module using the `<st c="55709">pip</st>` command:'
- en: '[PRE29]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: <st c="59548">from airflow import DAG</st>
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="59548">from airflow import DAG</st>`'
- en: <st c="59571">from airflow.operators.python import PythonOperator</st>
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="59571">from airflow.operators.python import PythonOperator</st>`'
- en: '<st c="59623">from airflow.providers.http.operators.http import</st> <st c="59673">SimpleHttpOperator</st>
    from datetime import datetime <st c="59723">with DAG(dag_id="report_login_count",</st>
    description="Report the number of login accounts", <st c="59812">start_date=datetime(2023,
    12, 27),</st><st c="59846">schedule_interval="0 12 * * *",</st> ) as <st c="59918">dag_id</st>
    value. Aside from <st c="59943">description</st>, DAG has parameters, such as
    <st c="59984">start_date</st> and <st c="59999">schedule_interval</st>, that work
    like a Cron (time) scheduler for the workflow. The <st c="60079">schedule_interval</st>
    parameter can have the <st c="60120">@hourly</st>, <st c="60129">@daily</st>,
    <st c="60137">@weekly</st>, <st c="60146">@monthly</st>, or <st c="60159">@yearly</st>
    Cron preset options run periodically or a Cron-based expression, such as <st c="60240">*/15
    * * * *</st>, that schedules the workflow to run every *<st c="60295">15 minutes</st>*.
    Setting the parameter to <st c="60332">None</st> will disable the periodic execution,
    requiring a trigger to run the tasks:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="59623">from airflow.providers.http.operators.http import</st>` `<st
    c="59673">SimpleHttpOperator</st>` from datetime import datetime `<st c="59723">with
    DAG(dag_id="report_login_count",</st>` description="Report the number of login
    accounts", `<st c="59812">start_date=datetime(2023, 12, 27),</st>` `<st c="59846">schedule_interval="0
    12 * * *",</st>` ) as `<st c="59918">dag_id</st>` value. Aside from `<st c="59943">description</st>`,
    DAG has parameters, such as `<st c="59984">start_date</st>` and `<st c="59999">schedule_interval</st>`,
    that work like a Cron (time) scheduler for the workflow. The `<st c="60079">schedule_interval</st>`
    parameter can have the `<st c="60120">@hourly</st>`, `<st c="60129">@daily</st>`,
    `<st c="60137">@weekly</st>`, `<st c="60146">@monthly</st>`, or `<st c="60159">@yearly</st>`
    Cron preset options run periodically or a Cron-based expression, such as `<st
    c="60240">*/15 * * * *</st>`, that schedules the workflow to run every `<st c="60295">15
    minutes</st>`. Setting the parameter to `<st c="60332">None</st>` will disable
    the periodic execution, requiring a trigger to run the tasks:'
- en: '[PRE31]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: <st c="60782">An</st> *<st c="60785">Airflow operator</st>* <st c="60801">implements
    a task.</st> <st c="60821">But, there are many types of operators to choose from
    depending on what kind</st> <st c="60898">of task the DAG requires.</st> <st c="60924">Some
    widely used operators in training and workplaces are</st> <st c="60982">the following:</st>
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="60782">An</st>` `<st c="60785">Airflow operator</st>` `<st c="60801">implements
    a task.</st>` `<st c="60821">But, there are many types of operators to choose
    from depending on what kind</st>` `<st c="60898">of task the DAG requires.</st>`
    `<st c="60924">Some widely used operators in training and workplaces are</st>`
    `<st c="60982">the following:</st>`'
- en: '`<st c="60996">EmptyOperator</st>` <st c="61010">– Initiates a</st> <st c="61025">built-in
    execution.</st>'
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="60996">EmptyOperator</st>` `<st c="61010">– Initiates a</st>` `<st
    c="61025">built-in execution.</st>`'
- en: '`<st c="61044">PythonOperator</st>` <st c="61059">– Calls a Python function
    that implements a</st> <st c="61104">business logic.</st>'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="61044">PythonOperator</st>` `<st c="61059">– Calls a Python function
    that implements a</st>` `<st c="61104">business logic.</st>`'
- en: '`<st c="61119">BashOperator</st>` <st c="61132">– Aims to run</st> `<st c="61147">bash</st>`
    <st c="61151">commands.</st>'
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="61119">BashOperator</st>` `<st c="61132">– Aims to run</st>` `<st c="61147">bash</st>`
    `<st c="61151">commands.</st>`'
- en: '`<st c="61161">EmailOperator</st>` <st c="61175">– Sends an email through</st>
    <st c="61201">a protocol.</st>'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="61161">EmailOperator</st>` `<st c="61175">– Sends an email through</st>`
    `<st c="61201">a protocol.</st>`'
- en: '`<st c="61212">SimpleHttpOperator</st>` <st c="61231">– Sends an</st> <st c="61243">HTTP
    request.</st>'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="61212">SimpleHttpOperator</st>` `<st c="61231">– Sends an</st>` `<st
    c="61243">HTTP request.</st>`'
- en: <st c="61256">Other operators may require installing the needed modules.</st>
    <st c="61316">For example, the</st> `<st c="61333">PostgresOperator</st>` <st
    c="61349">operator used for executing PostgreSQL commands requires installing
    the</st> `<st c="61422">apache-airflow[postgres]</st>` <st c="61446">module through
    the</st> `<st c="61466">pip</st>` <st c="61469">command.</st>
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="61256">其他操作可能需要安装所需的模块。</st> <st c="61316">例如，用于执行 PostgreSQL 命令的</st>
    `<st c="61333">PostgresOperator</st>` <st c="61349">操作符需要通过</st> `<st c="61422">apache-airflow[postgres]</st>`
    <st c="61446">模块通过</st> `<st c="61466">pip</st>` <st c="61469">命令安装。</st>
- en: <st c="61478">Each task must have a unique</st> `<st c="61508">task_id</st>`
    <st c="61515">value for Airflow identification.</st> <st c="61550">Our</st> `<st
    c="61554">Task1</st>` <st c="61559">task is a</st> `<st c="61570">SimpleHTTPOperator</st>`
    <st c="61588">operator that sends a</st> `<st c="61611">GET</st>` <st c="61614">request
    to an HTTP</st> `<st c="61634">GET</st>` <st c="61637">API endpoint expected to
    return a JSON resource.</st> <st c="61687">It has an ID named</st> `<st c="61706">list_all_login</st>`
    <st c="61720">and connects to Airflow’s HTTP connection object named</st> `<st
    c="61776">packt_dag</st>`<st c="61785">. All</st> `<st c="61791">SimpleHTTPOperator</st>`
    <st c="61809">needs is a</st> `<st c="61821">Connection</st>` <st c="61831">object,
    which stores the HTTP details of the external server resource that the operation
    will need to establish a connection.</st> <st c="61958">Accessing the</st> `<st
    c="62075">Connection</st>` <st c="62085">object.</st> *<st c="62094">Figure 8</st>**<st
    c="62102">.12</st>* <st c="62105">shows the form that accepts HTTP details of
    the connection and creates</st> <st c="62177">the object:</st>
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="61478">每个任务都必须有一个唯一的</st> `<st c="61508">task_id</st>` <st c="61515">值，以便
    Airflow 识别。</st> <st c="61550">我们的</st> `<st c="61554">Task1</st>` <st c="61559">任务是一个</st>
    `<st c="61570">SimpleHTTPOperator</st>` <st c="61588">操作符，它向一个 HTTP</st> `<st
    c="61611">GET</st>` <st c="61614">请求发送到预期的 JSON 资源返回的 HTTP</st> `<st c="61634">GET</st>`
    <st c="61637">API 端点。</st> <st c="61687">它有一个名为</st> `<st c="61706">list_all_login</st>`
    <st c="61720">的 ID，并连接到名为</st> `<st c="61776">packt_dag</st>`<st c="61785">的 Airflow
    HTTP 连接对象。</st> <st c="61791">SimpleHTTPOperator</st> <st c="61809">所需的是一个</st>
    `<st c="61821">Connection</st>` <st c="61831">对象，该对象存储了操作将需要建立连接的外部服务器资源的 HTTP
    详细信息。</st> <st c="61958">访问</st> `<st c="62075">Connection</st>` <st c="62085">对象。</st>
    *<st c="62094">图 8</st>**<st c="62102">.12</st>* <st c="62105">显示了接受连接的 HTTP 详细信息并创建</st>
    <st c="62177">对象的表单：</st>
- en: '![Figure 8.12 – Creating an HTTP Connection object](img/B19383_08_012.jpg)'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 8.12 – 创建 HTTP 连接对象](img/B19383_08_012.jpg)'
- en: <st c="62503">Figure 8.12 – Creating an HTTP Connection object</st>
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="62503">图 8.12 – 创建 HTTP 连接对象</st>
- en: <st c="62551">Also, a</st> `<st c="62560">SimpleHTTPOperator</st>` <st c="62578">operator
    provides a callback method indicated by its</st> `<st c="62632">response_check</st>`
    <st c="62646">parameter.</st> <st c="62658">The callback method accesses the response
    and other related data and can perform</st> <st c="62738">evaluation and logging
    on the API response.</st> <st c="62783">The following is the implementation of
    the callback method</st> <st c="62842">of</st> `<st c="62845">Task1</st>`<st c="62850">:</st>
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="62551">此外，一个</st> `<st c="62560">SimpleHTTPOperator</st>` <st c="62578">操作符提供了一个由其</st>
    `<st c="62632">response_check</st>` <st c="62646">参数指示的回调方法。</st> <st c="62658">回调方法访问响应和其他相关数据，可以对
    API 响应进行评估和记录。</st> <st c="62738">以下是对</st> `<st c="62845">Task1</st>`<st c="62850">的回调方法的实现：</st>
- en: '[PRE32]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: <st c="63027">On the other hand,</st> `<st c="63047">Task2</st>` <st c="63052">is
    a</st> `<st c="63058">PythonOperator</st>` <st c="63072">operator that runs a
    Python function,</st> `<st c="63111">count_login()</st>`<st c="63124">, for retrieving
    the JSON data from the API executed in</st> `<st c="63180">Task1</st>` <st c="63185">and
    counting the number of records from the JSON resource.</st> <st c="63245">Setting
    its</st> `<st c="63257">provide_context</st>` <st c="63272">parameter to</st>
    `<st c="63286">True</st>` <st c="63290">allows its</st> `<st c="63302">python_callable</st>`
    <st c="63317">method to access the</st> `<st c="63339">taskInstance</st>` <st
    c="63351">object that pulls the API resource from</st> `<st c="63392">Task1</st>`<st
    c="63397">. The</st> `<st c="63403">count_login()</st>` <st c="63416">function
    can also set an</st> `<st c="63442">xcom</st>` <st c="63446">variable, a form
    of workflow data, because the value of</st> `<st c="63503">Task2</st>`<st c="63508">’s</st>
    `<st c="63512">do_xcom_push</st>` <st c="63524">parameter is</st> `<st c="63538">True</st>`<st
    c="63542">. The following snippet is the implementation</st> <st c="63588">of</st>
    `<st c="63591">count_login()</st>`<st c="63604">:</st>
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="63027">On the other hand,</st> `<st c="63047">Task2</st>` <st c="63052">is
    a</st> `<st c="63058">PythonOperator</st>` <st c="63072">operator that runs a
    Python function,</st> `<st c="63111">count_login()</st>`<st c="63124">, for retrieving
    the JSON data from the API executed in</st> `<st c="63180">Task1</st>` <st c="63185">and
    counting the number of records from the JSON resource.</st> <st c="63245">Setting
    its</st> `<st c="63257">provide_context</st>` <st c="63272">parameter to</st>
    `<st c="63286">True</st>` <st c="63290">allows its</st> `<st c="63302">python_callable</st>`
    <st c="63317">method to access the</st> `<st c="63339">taskInstance</st>` <st
    c="63351">object that pulls the API resource from</st> `<st c="63392">Task1</st>`<st
    c="63397">. The</st> `<st c="63403">count_login()</st>` <st c="63416">function
    can also set an</st> `<st c="63442">xcom</st>` <st c="63446">variable, a form
    of workflow data, because the value of</st> `<st c="63503">Task2</st>`<st c="63508">’s</st>
    `<st c="63512">do_xcom_push</st>` <st c="63524">parameter is</st> `<st c="63538">True</st>`<st
    c="63542">. The following snippet is the implementation</st> <st c="63588">of</st>
    `<st c="63591">count_login()</st>`<st c="63604">:</st>
- en: '[PRE33]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '<st c="66486">@login_bp.get("/login/dag/report/login/count")</st> async def
    trigger_report_login_count(): <st c="66574">token = "cGFja3RhZG1pbjpwYWNrdGFkbWlu"</st>
    dag_id = "report_login_count"'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="66486">@login_bp.get("/login/dag/report/login/count")</st> async def
    trigger_report_login_count(): <st c="66574">token = "cGFja3RhZG1pbjpwYWNrdGFkbWlu"</st>
    dag_id = "report_login_count"'
- en: deployment_url = "localhost:8080"
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: deployment_url = "localhost:8080"
- en: 'response = <st c="66688">requests.post(</st><st c="66702">url=f"http://{deployment_url}</st>
    <st c="66732">/api/v1/dags/{dag_id}/dagRuns",</st> headers={ <st c="66775">"Authorization":
    f"Basic {token}",</st> "Content-Type": "application/json",'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'response = <st c="66688">requests.post(</st><st c="66702">url=f"http://{deployment_url}</st>
    <st c="66732">/api/v1/dags/{dag_id}/dagRuns",</st> headers={ <st c="66775">"Authorization":
    f"Basic {token}",</st> "Content-Type": "application/json",'
- en: '"Accept": "*/*",'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"Accept": "*/*",'
- en: '"Connection": "keep-alive",'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"Connection": "keep-alive",'
- en: '"Accept-Encoding": "gzip, deflate, br"'
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"Accept-Encoding": "gzip, deflate, br"'
- en: '}, <st c="66933">data = ''{"dag_run_id": "d08a62c6-ed71-49fc-81a4-47991221aea5"}''</st>
    )'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}, <st c="66933">data = ''{"dag_run_id": "d08a62c6-ed71-49fc-81a4-47991221aea5"}''</st>
    )'
- en: result = response.content.decode(encoding="utf-8")
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: result = response.content.decode(encoding="utf-8")
- en: return jsonify(message=result), 201
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return jsonify(message=result), 201
- en: '[PRE34]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '{'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"conf": {}, <st c="67485">"dag_id": "report_login_count",</st><st c="67516">"dag_run_id":
    "01c04a4b-a3d9-4dc5-b0c3-e4e59e2db554",</st> "data_interval_end": "2023-12-27T12:00:00+00:00",'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"conf": {}, <st c="67485">"dag_id": "report_login_count",</st><st c="67516">"dag_run_id":
    "01c04a4b-a3d9-4dc5-b0c3-e4e59e2db554",</st> "data_interval_end": "2023-12-27T12:00:00+00:00",'
- en: '"data_interval_start": "2023-12-26T12:00:00+00:00",'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"data_interval_start": "2023-12-26T12:00:00+00:00",'
- en: '"end_date": null,'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"end_date": null,'
- en: '"execution_date": "2023-12-27T13:55:44.910773+00:00",'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"execution_date": "2023-12-27T13:55:44.910773+00:00",'
- en: '"external_trigger": true,'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"external_trigger": true,'
- en: '"last_scheduling_decision": null,'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"last_scheduling_decision": null,'
- en: '"logical_date": "2023-12-27T13:55:44.910773+00:00",'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"logical_date": "2023-12-27T13:55:44.910773+00:00",'
- en: '"note": null, <st c="67871">"run_type": "manual",</st> "start_date": null,'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"note": null, <st c="67871">"run_type": "manual",</st> "start_date": null,'
- en: '"state": "queued"'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"state": "queued"'
- en: '}'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE35]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '@login_bp.get("/login/dag/xcom/values")'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '@login_bp.get("/login/dag/xcom/values")'
- en: 'async def extract_xcom_count():'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 'async def extract_xcom_count():'
- en: 'try:'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'try:'
- en: token = "cGFja3RhZG1pbjpwYWNrdGFkbWlu"
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: token = "cGFja3RhZG1pbjpwYWNrdGFkbWlu"
- en: dag_id = "report_login_count"
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: dag_id = "report_login_count"
- en: task_id = "return_report" <st c="68236">dag_run_id = "d08a62c6-ed71-49fc-81a4-47991221aea5"</st>
    deployment_url = "localhost:8080"
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: task_id = "return_report" <st c="68236">dag_run_id = "d08a62c6-ed71-49fc-81a4-47991221aea5"</st>
    deployment_url = "localhost:8080"
- en: 'response = <st c="68333">requests.get(</st><st c="68346">url=f"http://{deployment_url}</st>
    <st c="68376">/api/v1/dags/{dag_id}/dagRuns</st> <st c="68406">/{dag_run_id}/taskInstances/{task_id}</st>
    <st c="68444">/xcomEntries/{''report_msg''}",</st> headers={ <st c="68485">"Authorization":
    f"Basic {token}",</st> … … … … … …'
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'response = <st c="68333">requests.get(</st><st c="68346">url=f"http://{deployment_url}</st>
    <st c="68376">/api/v1/dags/{dag_id}/dagRuns</st> <st c="68406">/{dag_run_id}/taskInstances/{task_id}</st>
    <st c="68444">/xcomEntries/{''report_msg''}",</st> headers={ <st c="68485">"Authorization":
    f"Basic {token}",</st> … … … … … …'
- en: '}'
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: )
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: )
- en: result = response.json()
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: result = response.json()
- en: message = result['value']
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: message = result['value']
- en: return jsonify(message=message)
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回 jsonify(message=message)
- en: 'except Exception as e:'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'except Exception as e:'
- en: print(e)
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打印(e)
- en: return jsonify(message="")
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回 jsonify(message="")
- en: '[PRE36]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '{'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"message": "There are 20 users as of 2023-12-28 00:38:17.592287." }'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"message": "截至 2023-12-28 00:38:17.592287，有 20 个用户。"}'
- en: '[PRE37]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: from temporalio.client import Client
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 从 temporalio.client 导入 Client
- en: from modules import create_app
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 从 modules 导入 create_app
- en: import asyncio
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 asyncio
- en: 'app, celery_app= create_app("../config_dev.toml") <st c="70653">async def connect_temporal(app):</st><st
    c="70685">client = await Client.connect("localhost:7233")</st><st c="70733">app.temporal_client
    = client</st> if __name__ == "__main__": <st c="70790">asyncio.run(connect_temporal(app))</st>
    app.run(debug=True)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 'app, celery_app= create_app("../config_dev.toml") <st c="70653">async def connect_temporal(app):</st><st
    c="70685">client = await Client.connect("localhost:7233")</st><st c="70733">app.temporal_client
    = client</st> 如果 __name__ == "__main__": <st c="70790">asyncio.run(connect_temporal(app))</st>
    app.run(debug=True)'
- en: '[PRE38]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: <st c="71631">from temporalio import activity</st>
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="71631">从 temporalio 导入 activity</st>
- en: '<st c="71663">@activity.defn</st> async def reserve_schedule(appointmentwf:
    AppointmentWf) -> str:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="71663">@activity.defn</st> 异步 def reserve_schedule(appointmentwf: AppointmentWf)
    -> str:'
- en: 'try:'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'try:'
- en: 'async with db_session() as sess:'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '异步使用 db_session() 作为 sess:'
- en: 'async with sess.begin(): <st c="71807">repo = AppointmentRepository(sess)</st>
    … … … … … … … <st c="71855">result = await repo.insert_appt(appt)</st> if result
    == False:'
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '异步使用 sess.begin(): <st c="71807">repo = AppointmentRepository(sess)</st> …
    … … … … … … <st c="71855">result = await repo.insert_appt(appt)</st> 如果 result
    == False:'
- en: '… … … … … … <st c="71925">return "failure"</st> … … … … … … <st c="71953">return
    "success"</st> except Exception as e:'
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '… … … … … … <st c="71925">return "failure"</st> … … … … … … <st c="71953">return
    "success"</st> except Exception as e:'
- en: print(e)
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打印(e)
- en: … … … … … … <st c="72084">@activity.defn</st> annotation, with a workflow data
    class as a local parameter, and returns a non-varying and non-changing value.
    The returned value can be a fixed string, number, or any string with a non-varying
    length. Avoid returning collection or model objects with varying property values.
    Our <st c="72379">reserve_schedule()</st> activity accepts an <st c="72418">AppointmentWf</st>
    object containing appointment details and saves the record of information into
    the database. It returns only either <st c="72548">"successful"</st> or <st c="72564">"failure"</st>.
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: … … … … … … <st c="72084">@activity.defn</st> 注解，使用工作流程数据类作为局部参数，并返回一个不变化的值。返回的值可以是固定字符串、数字或任何长度不变的字符串。避免返回具有可变属性值的集合或模型对象。我们的
    <st c="72379">reserve_schedule()</st> 活动接受一个包含预约详情的 <st c="72418">AppointmentWf</st>
    对象，并将信息记录保存到数据库中。它只返回 <st c="72548">"successful"</st> 或 <st c="72564">"failure"</st>。
- en: <st c="72574">An activity is where access to external services, such as databases,
    emails, or APIs, is permitted by Temporal and</st> <st c="72690">not in the workflow
    implementation.</st> <st c="72726">The following code is a</st> *<st c="72750">Temporal
    workflow</st>* <st c="72768">that runs the</st> `<st c="72782">reserve_schedule()</st>`
    <st c="72800">activity:</st>
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="72574">活动是 Temporal 允许访问外部服务，如数据库、电子邮件或 API 的地方，而不是在工作流程实现中。</st> <st
    c="72690">以下代码是一个</st> *<st c="72750">Temporal 工作流程</st>* <st c="72768">，它运行 <st
    c="72782">reserve_schedule()</st> <st c="72800">活动：</st>
- en: '[PRE39]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '<st c="73904">@workflow.run</st> async def run(self, data: ReqAppointment)
    -> None:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="73904">@workflow.run</st> 异步 def run(self, data: ReqAppointment) ->
    None:'
- en: duration = 12
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 持续时间 = 12
- en: self.appointmentwf.ticketid = data.ticketid
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: self.appointmentwf.ticketid = data.ticketid
- en: self.appointmentwf.patientid = data.patientid
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: self.appointmentwf.patientid = data.patientid
- en: … … … … … … <st c="74085">while self.appointmentwf.status:</st> self.appointmentwf.remarks
    = "Doctor reservation being processed...." <st c="74188">try:</st><st c="74192">await
    workflow.execute_activity(</st><st c="74225">reserve_schedule,</st><st c="74243">self.appointmentwf,</st><st
    c="74263">start_to_close_timeout=timedelta(</st> <st c="74297">seconds=10),</st>
    ) <st c="74313">await asyncio.sleep(duration)</st><st c="74342">except asyncio.CancelledError
    as err:</st> self.appointmentwf.status = False
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: … … … … … … `<st c="74085">while self.appointmentwf.status:</st>` self.appointmentwf.remarks
    = "Doctor reservation being processed...." `<st c="74188">try:</st>` `<st c="74192">await
    workflow.execute_activity(</st>` `<st c="74225">reserve_schedule,</st>` `<st c="74243">self.appointmentwf,</st>`
    `<st c="74263">start_to_close_timeout=timedelta(</st>` `<st c="74297">seconds=10),</st>`
    `<st c="74313">await asyncio.sleep(duration)</st>` `<st c="74342">except asyncio.CancelledError
    as err:</st>` self.appointmentwf.status = False
- en: self.appointmentwf.remarks = "Appointment with doctor done." <st c="74739">ReserveAppointmentWorkflow</st>
    instance, when canceled, will throw a <st c="74804">CancelledError</st> exception
    that will trigger the exception clause that sets <st c="74878">appointmentwf.status</st>
    to <st c="74902">False</st> and executes the <st c="74925">start_to_close()</st>
    activity.
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: self.appointmentwf.remarks = "Appointment with doctor done." `<st c="74739">ReserveAppointmentWorkflow</st>`
    实例，当取消时，将抛出 `<st c="74804">CancelledError</st>` 异常，这将触发设置 `<st c="74878">appointmentwf.status</st>`
    为 `<st c="74902">False</st>` 并执行 `<st c="74925">start_to_close()</st>` 活动的异常处理子句。
- en: <st c="74951">Aside from the loop and the</st> <st c="74979">constructor, a
    workflow implementation can emit</st> `<st c="75028">resultset</st>` <st c="75037">instances
    or information about the workflow.</st> <st c="75083">To carry this out, implement
    an instance method and decorate it with</st> `<st c="75152">@workflow.query</st>`<st
    c="75167">. The following method returns an</st> <st c="75201">appointment record:</st>
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="74951">除了循环和构造函数之外，工作流程实现可以发出</st>` `<st c="74979">constructor, a workflow
    implementation can emit</st>` `<st c="75028">resultset</st>` `<st c="75037">instances
    or information about the workflow.</st>` `<st c="75083">为了执行此操作，实现一个实例方法并用</st>`
    `<st c="75152">@workflow.query</st>` `<st c="75167">.以下方法返回一个</st>` `<st c="75201">appointment
    record:</st>`'
- en: '[PRE40]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: <st c="75298">Unlike in Zeebe/Camunda, where the server executes and manages
    the workflow, the Temporal.io server does not run any workflow instance but the
    worker.</st> <st c="75450">We learn more about workers in the</st> <st c="75485">following
    section.</st>
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="75298">与Zeebe/Camunda不同，在那里服务器执行并管理工作流程，Temporal.io服务器不运行任何工作流程实例，而是工作线程。</st>`
    `<st c="75450">我们将在下一节中了解更多关于工作线程的信息。</st>`'
- en: <st c="75503">Building a worker</st>
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="75503">构建工作线程</st>`'
- en: <st c="75521">A</st> `<st c="75579">Worker</st>` <st c="75585">class from the</st>
    `<st c="75601">temporalio.worker</st>` <st c="75618">module requires the</st>
    `<st c="75639">client</st>` <st c="75645">connection,</st> `<st c="75658">task_queue</st>`<st
    c="75668">,</st> `<st c="75670">workflows</st>`<st c="75679">, and</st> `<st c="75685">activities</st>`
    <st c="75695">as constructor</st> <st c="75711">parameters before its instantiation.</st>
    <st c="75748">Our worker should be outside the</st> <st c="75781">context of Flask,
    so we added the</st> `<st c="75815">workflow_runner</st>` <st c="75830">parameter
    to the parameters.</st> <st c="75860">The following code is our implementation
    of the</st> <st c="75908">Temporal worker:</st>
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="75521">A</st>` `<st c="75579">Worker</st>` `<st c="75585">class from
    the</st>` `<st c="75601">temporalio.worker</st>` `<st c="75618">module requires
    the</st>` `<st c="75639">client</st>` `<st c="75645">connection,</st>` `<st c="75658">task_queue</st>`
    `<st c="75668">,</st>` `<st c="75670">workflows</st>` `<st c="75679">, and</st>`
    `<st c="75685">activities</st>` `<st c="75695">as constructor</st>` `<st c="75711">parameters
    before its instantiation.</st>` `<st c="75748">我们的工作线程应该位于</st>` `<st c="75781">Flask的上下文之外，因此我们在参数中添加了</st>`
    `<st c="75815">workflow_runner</st>` `<st c="75830">参数。</st>` `<st c="75860">以下代码是我们对</st>`
    `<st c="75908">Temporal工作线程的实现：</st>`'
- en: '[PRE41]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '<st c="77849">@admin_bp.route("/appointment/doctor", methods=["POST"])</st>
    async def request_appointment(): <st c="77940">client = get_client()</st> appt_json
    = request.get_json()'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="77849">@admin_bp.route("/appointment/doctor", methods=["POST"])</st>`
    async def request_appointment(): `<st c="77940">client = get_client()</st>` appt_json
    = request.get_json()'
- en: appointment = ReqAppointment(**appt_json) <st c="78035">await client.start_workflow(</st><st
    c="78063">ReserveAppointmentWorkflow.run,</st><st c="78095">appointment,</st><st
    c="78108">id=appointment.ticketid,</st><st c="78133">task_queue=appt_queue_id,</st>
    )
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: appointment = ReqAppointment(**appt_json) `<st c="78035">await client.start_workflow(</st>`
    `<st c="78063">ReserveAppointmentWorkflow.run,</st>` `<st c="78095">appointment,</st>`
    `<st c="78108">id=appointment.ticketid,</st>` `<st c="78133">task_queue=appt_queue_id,</st>`
    )
- en: 'message = jsonify({"message": "Appointment for doctor requested...."})'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'message = jsonify({"message": "Appointment for doctor requested...."})'
- en: response = make_response(message, 201)
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: response = make_response(message, 201)
- en: return response
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return response
- en: '[PRE42]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '<st c="78567">@admin_bp.route("/appointment/details", methods=["GET"])</st>
    async def get_appointment_details():'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="78567">@admin_bp.route("/appointment/details", methods=["GET"])</st>
    async def get_appointment_details():'
- en: client = get_client()
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: client = get_client()
- en: ticketid = request.args.get("ticketid")
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ticketid = request.args.get("ticketid")
- en: print(ticketid)
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: print(ticketid)
- en: handle = <st c="78749">client.get_workflow_handle_for( ReserveAppointmentWorkflow.run,
    ticketid)</st><st c="78822">results = await handle.query(</st> <st c="78852">ReserveAppointmentWorkflow.details)</st>
    message = jsonify({
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: handle = <st c="78749">client.get_workflow_handle_for(ReserveAppointmentWorkflow.run,
    ticketid)</st><st c="78822">results = await handle.query(</st> <st c="78852">ReserveAppointmentWorkflow.details)</st>
    message = jsonify({
- en: '"ticketid": results.ticketid,'
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"ticketid": results.ticketid,'
- en: '"patientid": results.patientid,'
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"patientid": results.patientid,'
- en: '"docid": results.docid,'
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"docid": results.docid,'
- en: '"date_scheduled": results.date_scheduled,'
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"date_scheduled": results.date_scheduled,'
- en: '"time_scheduled": results.time_scheduled,'
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"time_scheduled": results.time_scheduled,'
- en: '}'
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: )
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: )
- en: response = make_response(message, 200)
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: response = make_response(message, 200)
- en: return response
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return response
- en: '[PRE43]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '<st c="79396">@admin_bp.route("/appointment/close", methods=["DELETE"])</st>
    async def end_subscription():'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="79396">@admin_bp.route("/appointment/close", methods=["DELETE"])</st>
    async def end_subscription():'
- en: client = get_client()
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: client = get_client()
- en: 'ticketid = request.args.get("ticketid") <st c="79547">handle = client.get_workflow_handle(ticketid,)</st><st
    c="79593">await handle.cancel()</st> message = jsonify({"message": "Requesting
    cancellation"})'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ticketid = request.args.get("ticketid")
- en: response = make_response(message, 202)
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: response = make_response(message, 202)
- en: return response
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return response
- en: '[PRE44]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
