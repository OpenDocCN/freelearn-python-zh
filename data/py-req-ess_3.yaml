- en: Chapter 3. Authenticating with Requests
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 使用请求进行身份验证
- en: Requests supports diverse kinds of authentication procedures, and it is built
    in such a way that the method of authentication feels like a cakewalk. In this
    chapter, we opt to throw light on various types of authentication procedures that
    are used by various tech giants for accessing the web resources.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Requests 支持多种认证流程，并且其构建方式使得认证方法感觉像轻松的散步。在本章中，我们选择详细探讨各种技术巨头用于访问网络资源的不同类型的认证流程。
- en: 'We will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Basic authentication
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本认证
- en: Digest authentication
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摘要认证
- en: Kerberos authentication
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kerberos认证
- en: OAuth authentication
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth认证
- en: Custom authentication
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义认证
- en: Basic authentication
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本认证
- en: 'Basic authentication is a popular, industry-standard scheme of authentication,
    which is specified in `HTTP 1.0`. This method makes use of a `user-ID` and `password`
    submitted by the user to get authenticated. The submitted `user-ID` and `password`
    are encoded using `Base64` encoding standards and transmitted across HTTP. The
    server gives access to the user only if the `user-ID` and the `password` are valid.
    The following are the advantages of using basic authentication:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 基本认证是一种流行的、行业标准的认证方案，它在`HTTP 1.0`中被指定。这种方法利用用户提交的`用户ID`和`密码`来进行认证。提交的`用户ID`和`密码`使用`Base64`编码标准进行编码，并通过HTTP传输。只有当`用户ID`和`密码`有效时，服务器才会向用户提供访问权限。以下使用基本认证的优点：
- en: The main advantage of using this scheme is that it is supported by most of the
    web browsers and servers. Even though it is simple and straightforward, it does
    have some disadvantages. Though all the credentials are encoded and transferred
    in the requests, they are not encrypted which makes the process insecure. One
    way to overcome this problem is by using SSL support while initiating a secure
    session.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用此方案的主要优势是它被大多数网络浏览器和服务器支持。尽管它简单直接，但它确实存在一些缺点。尽管所有凭证都在请求中编码和传输，但它们并未加密，这使得整个过程不安全。克服这个问题的方法之一是在启动安全会话时使用SSL支持。
- en: Secondly, the credentials persist on the server until the end of the browser
    session, which may lead to the seizure of the resources. And also, this authentication
    process is wide open to **Cross Site Request Forgery** (**CSRF**) attacks, as
    the browser automatically sends the credentials of the user in the subsequent
    requests.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，凭证在服务器上持续存在，直到浏览器会话结束，这可能会导致资源被占用。此外，这个认证过程很容易受到**跨站请求伪造**（**CSRF**）攻击的影响，因为浏览器会自动在后续请求中发送用户的凭证。
- en: 'The basic authentication flow contains two steps:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 基本认证流程包含两个步骤：
- en: If a requested resource needs authentication, the server returns `http 401`
    response containing a `WWW-Authenticate` header.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果请求的资源需要身份验证，服务器将返回包含`WWW-Authenticate`头部的`http 401`响应。
- en: If the user sends another request with the user ID and password in the `Authorization`
    header, the server processes the submitted credentials and gives the access.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户在`Authorization`头中发送带有用户ID和密码的另一个请求，服务器将处理提交的凭据并授予访问权限。
- en: 'You can see this in the following diagram:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下图表中看到这一点：
- en: '![Basic authentication](img/3661_03_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![基本认证](img/3661_03_01.jpg)'
- en: Using basic authentication with Requests
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Requests进行基本身份验证
- en: 'We can use the `requests` module to send a request to undergo basic authentication
    very easily. The process can be seen as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`requests`模块非常容易地发送一个请求进行基本认证。这个过程可以看作如下：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding lines of code, we performed basic authentication by creating
    an `HTTPBasicAuth` object; then we passed it to the `auth` parameter, which will
    be submitted to the server. If the submitted credentials gets authenticated successfully,
    the server returns a `200` (Successful) response, otherwise, it will return a
    `401` (Unauthorized) response.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码行中，我们通过创建一个`HTTPBasicAuth`对象来执行基本认证；然后将其传递给`auth`参数，该参数将被提交到服务器。如果提交的凭据认证成功，服务器将返回一个`200`（成功）响应，否则，它将返回一个`401`（未授权）响应。
- en: Digest authentication
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要认证
- en: Digest authentication is one of the well known HTTP authentication schemes,
    which were introduced to overcome most of the drawbacks of basic authentication.
    This type of authentication makes use of `user-ID` and `password` just like Basic
    authentication, but the major difference comes in the picture, when the credentials
    get transferred to the server.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要认证是众所周知的一种HTTP认证方案，它被引入以克服基本认证的大部分缺点。这种认证方式与基本认证类似，都使用`用户ID`和`密码`，但主要区别在于凭证传输到服务器时的过程。
- en: Digest authentication increases the security of the credentials by going an
    extra mile with the concept of cryptographic encryption. When the user submits
    the password for the sake of authentication, the browser will apply an MD5 hashing
    scheme on it. The crux of the process lies in using nonce values (pseudo-random
    numbers) while encrypting the password which decreases the replay attacks.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要认证通过在加密加密概念上更进一步，增加了凭证的安全性。当用户提交密码以进行身份验证时，浏览器将对其应用MD5散列方案。这个过程的核心在于在加密密码时使用nonce值（伪随机数），这减少了重放攻击。
- en: '![Digest authentication](img/3661_03_02.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![摘要认证](img/3661_03_02.jpg)'
- en: This type of authentication gains more strength, as the password in this encryption
    is not used in the form of plain text. The cracking of the password hashes becomes
    difficult in digest authentication with the use of a nonce, which counters the
    chosen plain text attacks.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这种认证方式变得更加强大，因为在这个加密过程中，密码不是以纯文本形式使用。在摘要认证中使用nonce（一次性随机数），使得密码散列的破解变得困难，从而抵消了选择纯文本攻击。
- en: Even though Digest authentication overcomes most of the drawbacks of Basic authentication,
    it does have some disadvantages. This scheme of authentication is vulnerable to
    man-in-the-middle attacks. It reduces the flexibility of storing the password
    in the password's database, as all the well designed password databases use other
    encryption methods to store them.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 即使摘要认证克服了基本认证的大部分缺点，但它确实存在一些不足。这种认证方案容易受到中间人攻击。它降低了将密码存储在密码数据库中的灵活性，因为所有设计良好的密码数据库都使用其他加密方法来存储密码。
- en: Using Digest authentication with Requests
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Requests库进行摘要认证
- en: 'Using Digest authentication with `requests` is very simple. Let us see how
    it''s done:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`requests`库进行摘要认证非常简单。让我们看看它是如何实现的：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding lines of code, we carried out digest authentication by creating
    an `HTTPDigestAuth` object and setting it to the 'auth' parameter which will be
    submitted to the server. If the submitted credentials gets authenticated successfully,
    the server returns a `200` response, otherwise, it will return a `401` response.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码行中，我们通过创建一个`HTTPDigestAuth`对象并将其设置为'auth'参数，该参数将被提交到服务器，从而执行了摘要认证。如果提交的凭据认证成功，服务器将返回一个`200`响应，否则，它将返回一个`401`响应。
- en: Kerberos authentication
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kerberos认证
- en: Kerberos is a type of Network authentication protocol, which uses a secret key
    cryptography to communicate between the client and the server. It was developed
    at MIT to mitigate many security problems like replay attacks and spying. It makes
    use of *tickets* to provide authentication for the server-side resources. It followed
    the idea of avoiding additional logins (single sign on) and storing the passwords
    at a centralized location.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Kerberos是一种网络身份验证协议，它使用密钥加密技术来在客户端和服务器之间进行通信。它是在麻省理工学院开发的，旨在缓解许多安全问题，如重放攻击和间谍活动。它利用*票据*为服务器端资源提供身份验证。它遵循避免额外登录（单点登录）和将密码存储在集中位置的理念。
- en: In a nutshell, the authentication server, the ticket granting server and the
    host machine act as the leading cast in the process of authentication.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，认证服务器、票据授权服务器和主机机作为认证过程中的主要角色。
- en: '**Authentication Server**: A server-side application which aids in the process
    of authentication by making the use of submitted credentials of a user'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证服务器**：一种服务器端应用程序，通过使用用户提交的凭据来辅助认证过程'
- en: '**Ticket Granting Server**: A logical **key distribution center** (**KDC**)
    which validates the tickets'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**票据授权服务器**：一个验证票据的逻辑**密钥分发中心**（**KDC**）'
- en: '**Host Machine**: A server which accepts the requests and provides the resources'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主机**: 接受请求并提供资源的服务器'
- en: 'You can see this in the following diagram:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下图表中看到这一点：
- en: '![Kerberos authentication](img/B03661_03_03.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![Kerberos认证](img/B03661_03_03.jpg)'
- en: 'Authentication with Kerberos takes place in the following steps:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Kerberos认证过程如下：
- en: When a person logs into his machine with the credentials, a request will be
    sent to **ticket** **granting ticket** (**TGT**).
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当一个人使用凭证登录他的机器时，将发送一个请求到**票据授权票据**（**TGT**）。
- en: If the verification of the user turns out to be true, when checked from the
    user database, a session key and a TGT will be created by the authentication server
    (AS).
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户验证结果为真，从用户数据库中进行检查后，认证服务器（AS）将创建一个会话密钥和一个TGT。
- en: Thus, the obtained TGT and session key will be sent back to the user in the
    form of two messages, in which TGT will be encrypted with the ticket granting
    the server's secret key. The session key will be encrypted with the client secret
    key and it contains a time stamp, life time, TGS name and TGS session key.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，获得的TGT和会话密钥将以两条消息的形式发送回用户，其中TGT将使用授予服务器的密钥的票据进行加密。会话密钥将使用客户端的密钥进行加密，并包含时间戳、有效期、TGS名称和TGS会话密钥。
- en: The user on the other end, after receiving the two messages, uses the client
    secret key that is, the user's password to decrypt the messages of the session
    key. The TGT cannot be decrypted without the TGS secret key.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对端的用户，在收到两条消息后，使用客户端密钥，即用户的密码来解密会话密钥的消息。没有TGS密钥，无法解密TGT。
- en: With the available information of the `session` key and the TGT, the user can
    send a request for accessing the service. The request contains two messages and
    some information at this point. In the two messages, one is an encrypted message,
    containing a user ID and timestamp. The other is a decrypted message, containing
    the HTTP service name and the life time of the ticket. With the above two messages,
    an authenticator and TGT will be sent to the ticket granting server.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用可用的`会话`密钥和TGT，用户可以发送请求以访问服务。请求包含两条消息和一些信息。在这两条消息中，一条是加密消息，包含用户ID和时间戳。另一条是解密消息，包含HTTP服务名称和票据的有效期。通过上述两条消息，认证器和TGT将被发送到票据授权服务器。
- en: The messages and the information (Authenticator and TGT) will be received by
    the TGS, and it will check for the credibility of the HTTP service from the KDC
    database and decrypt both the authenticator and the TGT. Once everything goes
    fine, the TGS tries to verify some important parts like client ID, time stamp,
    lifetime of TGT and authenticator. If the verification turns out to be successful,
    then the TGS generates an encrypted HTTP service ticket, HTTP service name, time
    stamp, information about the ticket validity and the session key of HTTP service.
    All of the preceding ones will be encrypted by the HTTP Service session key and
    will be sent back to the user.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消息和信息（身份验证器和TGT）将由TGS接收，并且它将检查来自KDC数据库的HTTP服务的可信度，并解密身份验证器和TGT。一旦一切顺利，TGS将尝试验证一些重要部分，如客户端ID、时间戳、TGT和身份验证器的有效期。如果验证成功，则TGS生成加密的HTTP服务票据、HTTP服务名称、时间戳、票据有效信息以及HTTP服务的会话密钥。所有这些都将由HTTP服务会话密钥加密，并返回给用户。
- en: Now, the user receives the information and decrypts it with the TGS session
    key that he/she received in the earlier step.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，用户接收信息并使用在早期步骤中收到的TGS会话密钥对其进行解密。
- en: In the next step, to access the HTTP service, the user sends an encrypted HTTP
    service ticket and an authenticator which is encrypted with the HTTP service session
    key to the HTTP service. The HTTP service uses its secret key to decrypt the ticket
    and takes hold of the HTTP service session key. With the acquired HTTP service
    session key, it decrypts the authenticator and verifies the client ID time stamp,
    lifetime of ticket, and so on.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，为了访问HTTP服务，用户将加密的HTTP服务票据和一个用HTTP服务会话密钥加密的验证器发送到HTTP服务。HTTP服务使用其密钥解密票据并掌握HTTP服务会话密钥。通过获取的HTTP服务会话密钥，它解密验证器并验证客户端ID时间戳、票据有效期等。
- en: If the verification turns out to be successful, the HTTP service sends an authenticator
    message with its ID and time stamp to confirm its identity to the user. The user's
    machine verifies the authenticator by making use of HTTP service session key and
    identifies the user as an authenticated one who accesses the HTTP service. From
    then onwards, the HTTP service can be accessed by the user without any bumps,
    until the session key expires.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果验证结果成功，HTTP服务会发送一个包含其ID和时间的认证器消息，以确认其身份给用户。用户的机器通过使用HTTP服务会话密钥来验证认证器，并识别用户为访问HTTP服务的已认证用户。从那时起，用户可以无障碍地访问HTTP服务，直到会话密钥过期。
- en: Kerberos is a secure protocol as the passwords from the user can never be sent
    as plain text. As the process of authentication takes place with the agreement
    of both the client and the server through encryption and decryption, it turns
    out to be a rigid one to break to some extent. The other advantage comes from
    its capability to give server access to the user until the session key expires
    without reentering the password.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Kerberos 是一种安全的协议，因为用户的密码永远不会以明文形式发送。由于认证过程是在客户端和服务器通过加密和解密达成一致的情况下进行的，因此在某种程度上它变得难以破解。另一个优点来自于它能够允许用户在会话密钥过期之前无需重新输入密码即可访问服务器。
- en: 'Kerberos does have some disadvantages:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Kerberos确实存在一些缺点：
- en: The server must be continuously available for the verification of the tickets
    which may result in blocking, if the server goes down.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器必须持续可用以验证门票，如果服务器宕机，可能会导致阻塞。
- en: User's keys are saved on a central server. A breach of this server may compromise
    security for the whole infrastructure.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户密钥保存在中央服务器上。该服务器的安全漏洞可能会危及整个基础设施的安全性。
- en: Kerberos necessitates a heavy infrastructure, which means a simple web server
    is not sufficient.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kerberos需要大量的基础设施，这意味着一个简单的Web服务器是不够的。
- en: The setup and the administration of Kerberos requires specialized skills.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kerberos的设置和管理需要专业的技能。
- en: Using Kerberos authentication with Requests
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Requests与Kerberos认证
- en: Requests takes the support of the `requests-kerberos` library for the purpose
    of authentication. For this reason, we should first install the `requests-kerberos`
    module.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Requests库为了实现认证功能，支持`requests-kerberos`库。因此，我们首先应该安装`requests-kerberos`模块。
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s have a look at the syntax:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看语法：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding lines of code, we carried out Kerberos authentication by creating
    an `HTTPKerberosAuth` object and setting it to the `auth` parameter which will
    be submitted to the server.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码行中，我们通过创建一个`HTTPKerberosAuth`对象并将其设置为`auth`参数，该参数将被提交到服务器，来执行Kerberos身份验证。
- en: OAuth authentication
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth身份验证
- en: OAuth is an open standard authorization protocol, which allows client applications
    a *secure delegated access* to the user accounts on third party services such
    as Google, Twitter, GitHub and so on. In this topic, we are going to introduce
    the two versions:- OAuth 1.0 and OAuth 2.0.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 是一种开放标准的授权协议，它允许客户端应用程序对第三方服务（如 Google、Twitter、GitHub 等）上的用户账户进行**安全的委托访问**。在本主题中，我们将介绍两个版本：-
    OAuth 1.0 和 OAuth 2.0。
- en: OAuth 1.0
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OAuth 1.0
- en: OAuth authentication protocol came up with an idea of mitigating the usage of
    passwords, replacing them with secure handshakes with API calls between the applications.
    This was developed by a small group of web developers who are inspired by OpenID.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth身份验证协议提出了一种减轻密码使用的方法，通过应用程序之间的API调用实现安全的握手来替代密码。这一想法是由一群受OpenID启发的网络开发者所开发的。
- en: Here are the Key terms used in the process of OAuth authentication.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了OAuth认证过程中使用的关键术语。
- en: '**Consumer**: The HTTP Client who can make authenticated requests'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消费者**：能够进行认证请求的 HTTP 客户端'
- en: '**Service Provider**: The HTTP Server, which deals with the requests of OAuth'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务提供商**: 处理OAuth请求的HTTP服务器'
- en: '**User**: A person who has the control over the protected resources on the
    HTTP Server'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户**：拥有对HTTP服务器上受保护资源控制权的人'
- en: '**Consumer Key and Secret**: Identifiers which have the capability to authenticate
    and authorize a request'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消费者密钥和密钥**: 具有认证和授权请求能力的标识符'
- en: '**Request Token and Secret**: Credentials used to gain authorization from the
    user'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求令牌和密钥**：用于从用户那里获取授权的凭证'
- en: '**Access Token and Secret**: Credentials to get access to the protected resources
    of the user'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问令牌和密钥**：获取用户受保护资源所需的凭证'
- en: 'You can see this in the following diagram:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下图表中看到这一点：
- en: '![OAuth 1.0](img/B03661_03_04.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![OAuth 1.0](img/B03661_03_04.jpg)'
- en: Initially, the client application asks the service provider to grant a request
    token. A user can be identified as an approved user by taking the credibility
    of the request token. It also helps in acquiring the access token with which the
    client application can access the service provider's resources.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，客户端应用程序请求服务提供者授予请求令牌。可以通过验证请求令牌的信誉来识别用户为已批准用户。这也有助于获取访问令牌，客户端应用程序可以使用该令牌访问服务提供者的资源。
- en: In the second step, the service provider receives the request and issues request
    token, which will be sent back to the client application. Later, the user gets
    redirected to the service provider's authorization page along with the request
    token received before as an argument.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步，服务提供商接收请求并发放请求令牌，该令牌将被发送回客户端应用程序。随后，用户在之前接收到的请求令牌作为参数的情况下，被重定向到服务提供商的授权页面。
- en: In the next step, the user grants permission to use the consumer application.
    Now, the service provider returns the user back to the client application, where
    the application accepts an authorized request token and gives back an access token.
    Using the access token, the user will gain an access to the application.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，用户授权使用消费者应用程序。现在，服务提供商将用户返回到客户端应用程序，应用程序接受一个授权请求令牌并返回一个访问令牌。使用访问令牌，用户将获得对应用程序的访问权限。
- en: Using OAuth 1.0 authentication with Requests
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Requests进行OAuth 1.0身份验证
- en: The `requests_oauthlib` is a an optional library for `oauth` which is not included
    in the Requests module. For this reason, we should install `requests_oauthlib`
    separately.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`requests_oauthlib` 是一个可选的 `oauth` 库，它不包括在 Requests 模块中。因此，我们应该单独安装 `requests_oauthlib`。'
- en: 'Let us take a look at the syntax:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看语法：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: OAuth 2.0
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OAuth 2.0
- en: OAuth 2.0 is next in line to OAuth 1.0 which has been developed to overcome
    the drawbacks of its predecessor. In modern days, OAuth 2.0 has been used vividly
    in almost all leading web services. Due to its ease of use with more security,
    it has attracted many people. The beauty of OAuth 2.0 comes from its simplicity
    and its capability to provide specific authorization methods for different types
    of application like web, mobile and desktop.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0 是继 OAuth 1.0 之后的下一个版本，它被开发出来以克服其前辈的缺点。在现代，OAuth 2.0 几乎被所有领先的互联网服务广泛使用。由于其使用简便且安全性更高，它吸引了很多人。OAuth
    2.0 的美在于其简洁性以及为不同类型的应用程序（如网页、移动和桌面）提供特定授权方法的能力。
- en: 'Basically, there are four workflows available while using OAuth 2.0, which
    are also called **grant types**. They are:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，在使用OAuth 2.0时，有四种可用的工作流程，这些工作流程也被称为**授权类型**。它们是：
- en: '**Authorization code grant**: This is basically used in web applications for
    the ease of authorization and secure resource delegation.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**授权码授权**：这基本上用于Web应用程序，以简化授权和安全的资源委派。'
- en: '**Implicit grant**: This flow is used to provide OAuth authorization in Mobile
    Applications.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**隐式授权**：此流程用于在移动应用程序中提供OAuth授权。'
- en: '**Resource owner password credentials grant**: This type of grant is used for
    applications using trusted clients.'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**资源所有者密码凭证授权**：此类授权用于使用受信任客户端的应用程序。'
- en: '**Client credentials grant**: This type of grant is used in machine to machine
    authentication. An in-depth explanation about grant types is out of the scope
    of this book.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**客户端凭证授权**：此类授权用于机器之间的身份验证。关于授权类型的深入解释超出了本书的范围。'
- en: OAuth 2.0 came up with capabilities which could overcome the concerns of OAuth
    1.0\. The process of using signatures to verify the credibility of API requests
    has been replaced by the use of SSL in OAuth 2.0\. It came up with the idea of
    supporting different types of flow for different environments ranging from web
    to mobile applications. Also, the concept of refresh tokens has been introduced
    to increase the security.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0 提出了能够克服 OAuth 1.0 关注的问题的功能。使用签名来验证 API 请求可信度的过程在 OAuth 2.0 中已被使用 SSL
    所取代。它提出了支持不同类型流程以适应不同环境的思想，从网页到移动应用程序等。此外，还引入了刷新令牌的概念，以增加安全性。
- en: 'Let us take a look at the usage:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看用法：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Custom authentication
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义认证
- en: Requests also provides the ability to write a new or custom authentication based
    on the user's needs and flexibility. It is equipped with `requests.auth.AuthBase`
    class which is a base class for all the authentication types. This can be achieved
    by implementing the custom authentication in the `__call__()` of `requests.auth.AuthBase`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Requests 还提供了根据用户需求和灵活性编写新或自定义认证的能力。它配备了 `requests.auth.AuthBase` 类，这是所有认证类型的基类。这可以通过在
    `requests.auth.AuthBase` 的 `__call__()` 方法中实现自定义认证来实现。
- en: 'Let us take a look at its syntax:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看它的语法：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Summary
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we gained knowledge of various types of authentication like
    Basic authentication, Digest authentication, Kerberos authentication, OAuth 1.0
    authentication and OAuth 2.0 authentication which are supported by Requests. Later,
    we got an idea of how to use various types of authentications and the flows of
    the process. We also learned to use our own custom authentication and gained the
    knowledge of making different authentications work with Requests and the ways
    to use them with Requests.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了Requests支持的多种认证类型，如基本认证、摘要认证、Kerberos认证、OAuth 1.0认证和OAuth 2.0认证。随后，我们获得了如何使用各种类型认证以及认证流程的概览。我们还学习了如何使用自定义认证，并掌握了不同认证与Requests结合使用的方法以及使用技巧。
- en: In the next chapter, we will be getting to know all about a handy module, `HTTPretty`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解一个实用的模块，`HTTPretty`。
