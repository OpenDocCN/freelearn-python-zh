- en: Chapter 4. Breaking Tight Coupling by using Mock Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：通过使用模拟对象来打破紧密耦合
- en: '*Several times in the previous chapters, we''ve run across cases where we needed
    to go out of our way to make sure that units didn''t contaminate each others''
    tests. Now we''re going to look at a formalization of how to handle those situations—mock
    objects—and also at a specific mock object toolkit called Python Mocker.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*在前面的几个章节中，我们多次遇到需要确保单位不会相互污染测试的情况。现在，我们将探讨如何正式处理这些情况——模拟对象——以及一个特定的模拟对象工具包，即
    Python Mocker。*'
- en: 'In this chapter, we shall:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Examine the ideas of mock objects in general
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查模拟对象的一般概念
- en: Learn how to use Python Mocker
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用 Python Mocker
- en: Learn how to mock the "self" parameter of a method
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何模拟方法中的“self”参数
- en: So let's get on with it!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们开始吧！
- en: Installing Python Mocker
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Python Mocker
- en: For the first time, we're using a tool that isn't included in the standard Python
    distribution. That means that we need to download and install it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次，我们使用了一个不在标准 Python 发行版中的工具。这意味着我们需要下载并安装它。
- en: Time for action – installing Python Mocker
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在是安装 Python Mocker 的时候了
- en: At the time of this writing, Python Mocker's home page is located at [http://labix.org/mocker](http://labix.org/mocker),
    while its downloads are hosted at [https://launchpad.net/mocker/+download](https://launchpad.net/mocker/+download).
    Go ahead and download the newest version, and we'll see about installing it.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在撰写本文时，Python Mocker 的主页位于 [http://labix.org/mocker](http://labix.org/mocker)，而其下载文件托管在
    [https://launchpad.net/mocker/+download](https://launchpad.net/mocker/+download)。请继续下载最新版本，我们将讨论如何安装它。
- en: 'The first thing that needs to be done is to unzip the downloaded file. It''s
    a `.tar.bz2`, which should just work for Unix, Linux, or OSX users. Windows users
    will need a third-party program (7-Zip works well: [http://www.7-zip.org/](http://www.7-zip.org/))
    to uncompress the archive. Store the uncompressed file in some temporary location.'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先需要做的事情是将下载的文件解压。它是一个 `.tar.bz2` 文件，对于 Unix、Linux 或 OSX 用户来说应该可以正常工作。Windows
    用户需要第三方程序（7-Zip 工作得很好：[http://www.7-zip.org/](http://www.7-zip.org/)）来解压存档。将解压后的文件存储在某个临时位置。
- en: Once you have the files unzipped somewhere, go to that location via the command
    line. Now, to do this next step, you either need to be allowed to write files
    into your Python installation's site-packages directory (which you are, if you're
    the one who installed Python in the first place) or you need to be using Python
    version 2.6 or higher.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你将文件解压到某个位置，通过命令行进入该位置。现在，为了进行下一步，你需要允许将文件写入你的 Python 安装目录的 site-packages
    中（如果你是第一个安装 Python 的人，那么你就有这个权限）或者你需要使用 Python 2.6 或更高版本。
- en: If you can write to site-packages, type
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你能够写入 site-packages，请输入
- en: '[PRE0]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you can't write to site-packages, but you're using Python 2.6 or higher,
    type
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你不能写入 site-packages，但你在使用 Python 2.6 或更高版本，请输入
- en: '[PRE1]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Sometimes, a tool called `easy_install` can simplify the installation process
    of Python modules and packages. If you want to give it a try, download and install
    `setuptools` from [http://pypi.python.org/pypi/setuptools](http://pypi.python.org/pypi/setuptools),
    according to the directions on that page, and then run the command `easy_install
    mocker`. Once that command is done, you should be ready to use Nose.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，一个名为 `easy_install` 的工具可以简化 Python 模块和包的安装过程。如果你想尝试，请根据页面上的说明下载并安装 `setuptools`
    从 [http://pypi.python.org/pypi/setuptools](http://pypi.python.org/pypi/setuptools)，然后运行命令
    `easy_install mocker`。一旦这个命令完成，你应该就可以使用 Nose 了。
- en: Once you have successfully run the installer, Python Mocker is ready for use.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你成功运行了安装程序，Python Mocker 就可以使用了。
- en: The idea of a mock object
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟对象的概念
- en: '"Mock" in this sense means "imitation," and that''s exactly what a mock object
    does. Mock objects imitate the real objects that make up your program, without
    actually being those objects or relying on them in any way.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个意义上，“Mock”意味着“模仿”，这正是模拟对象所做的事情。模拟对象模仿构成你程序的真实对象，但实际上并不是这些对象，也不以任何方式依赖它们。
- en: Instead of doing whatever the real object would do, a mock object performs predefined
    simple operations that *look like what the real object should do*. That means
    its methods return appropriate values (which you told it to return) or raise appropriate
    exceptions (which you told it to raise). A mock object is like a mockingbird;
    imitating the calls of other birds without comprehending them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象不会执行真实对象会执行的操作，而是执行预定义的简单操作，这些操作*看起来像是真实对象应该执行的操作*。这意味着它的方法返回适当的值（你告诉它返回的值）或引发适当的异常（你告诉它引发的异常）。模拟对象就像一只模仿鸟；模仿其他鸟的叫声，而不理解它们。
- en: We've already used one mock object in our earlier work when we replaced `time.time`
    with an object (in Python, functions are objects) that returned an increasing
    series of numbers. The mock object was like `time.time`, except that it always
    returned the same series of numbers, no matter when we ran our test or how fast
    the computer was that we ran it on. In other words, it decoupled our test from
    an external variable.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的工作中，我们已经使用了一个模拟对象，当时我们用返回一个递增序列的数字的对象（在Python中，函数是对象）替换了`time.time`。这个模拟对象就像`time.time`一样，除了它总是返回相同的序列，无论我们何时运行测试或运行测试的计算机有多快。换句话说，它将我们的测试与外部变量解耦。
- en: 'That''s what mock objects are all about: decoupling tests from external variables.
    Sometimes those variables are things like the external time or processor speed,
    but usually the variables are the behavior of other units.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是模拟对象的核心：将测试与外部变量解耦。有时这些变量是外部时间或处理器速度等东西，但通常变量是其他单元的行为。
- en: Python Mocker
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python Mocker
- en: The idea is pretty straightforward, but one look at that mock version of `time.time`
    from the previous chapter shows that creating mock objects without using a toolkit
    of some sort can be a dense and annoying process, and can interfere with the readability
    of your tests. This is where Python Mocker (or any of several other mock object
    toolkits, depending on preference) comes in.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法相当直接，但只需看一下上一章中`time.time`的模拟版本，就可以看出，如果不使用某种工具包，创建模拟对象可能是一个复杂且令人烦恼的过程，并且可能会干扰测试的可读性。这就是Python
    Mocker（或根据个人喜好选择的其他几个模拟对象工具包）发挥作用的地方。
- en: Time for action – exploring the basics of Mocker
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——探索Mocker的基础
- en: We'll walk through some of the simplest—and most useful—features of Mocker.
    To do that, we'll write tests that describe a class representing a specific mathematical
    operation (multiplication) which can be applied to the values of arbitrary other
    mathematical operation objects. In other words, we'll work on the guts of a spreadsheet
    program (or something similar).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍Mocker的一些最简单——也是最实用——的功能。为此，我们将编写测试来描述一个代表特定数学运算（乘法）的类，该运算可以应用于任意其他数学运算对象的值。换句话说，我们将处理电子表格程序（或类似的东西）的内部结构。
- en: We're going to use Mocker to create mock objects to stand in place of the real
    operation objects.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用模拟器来创建模拟对象，以替代真实的操作对象。
- en: 'Create up a text file to hold the tests, and add the following at the beginning
    (assuming that all the mathematical operations will be defined in a module called
    `operations`):'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文本文件来保存测试，并在开头添加以下内容（假设所有数学运算都将定义在名为`operations`的模块中）：
- en: '[PRE2]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We''ve decided that every mathematical operation class should have a constructor
    accepting the objects representing the new object''s operands. It should also
    have an evaluate function that accepts a dictionary of variable bindings as its
    parameter and returns a number as the result. We can write the tests for the constructor
    fairly easily, so we do that first (Note that we''ve included some explanation
    in the test file, which is always a good idea):'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们决定每个数学运算类都应该有一个接受代表新对象操作数的对象的构造函数。它还应该有一个接受变量绑定字典作为参数的`evaluate`函数，并返回一个数字作为结果。我们可以很容易地编写构造函数的测试，所以我们首先做这件事（注意，我们在测试文件中包含了一些说明，这总是一个好主意）：
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The tests for the `evaluate` method are somewhat more complicated, because
    there are several things we need to test. This is also where we start seeing the
    real advantages of Mocker:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`evaluate`方法的测试要复杂一些，因为我们需要测试几个方面。这也是我们看到Mocker真正优势的开始：
- en: '[PRE4]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If we run the tests now, we get a list of failed tests. Most of them are due
    to Mocker being unable to import the `operations` module, but the bottom of the
    list should look like this:![Time for action – exploring the basics of Mocker](img/8846_04_01.jpg)
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在运行测试，我们会得到一个失败测试的列表。其中大部分是由于Mocker无法导入`operations`模块造成的，但列表的底部应该看起来像这样：![探索Mocker基础
    - 行动时间](img/8846_04_01.jpg)
- en: 'Finally, we''ll write some code in the `operations` module that passes these
    tests, producing the following:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将在`operations`模块中编写一些通过这些测试的代码，生成以下结果：
- en: '[PRE5]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now when we run the tests, none of them should fail.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们运行测试时，不应该有任何测试失败。
- en: '*What just happened?*'
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The difficulty in writing the tests for something like this comes(as it often
    does) from the need to decouple the multiplication class from all of the other
    mathematical operation classes, so that the results of the multiplication test
    only depend on whether multiplication works correctly.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为类似这样的东西编写测试的难度在于（正如通常所做的那样）需要将乘法类与所有其他数学运算类解耦，以便乘法测试的结果仅取决于乘法是否正确工作。
- en: We addressed this problem by using the Mocker framework for mock objects. The
    way Mocker works is that you first create an object representing the mocking context,
    by doing something such as `mocker = Mocker()`. The mocking context will help
    you create mock objects, and it will store information about how you expect them
    to be used. Additionally, it can help you temporarily replace library objects
    with mocks (like we've previously done with `time.time`) and restore the real
    objects to their places when you're done. We'll see more about doing that in a
    little while.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用Mocker框架为模拟对象解决问题。Mocker的工作方式是，你首先通过做一些像`mocker = Mocker()`这样的操作来创建一个代表模拟上下文的对象。模拟上下文将帮助你创建模拟对象，并存储有关你期望它们如何被使用的相关信息。此外，它可以帮助你暂时用模拟对象替换库对象（就像我们之前用`time.time`所做的那样），并在完成后将真实对象恢复到它们的位置。我们稍后会看到更多关于如何做到这一点的内容。
- en: Once you have a mocking context, you create a mock object by calling its `mock`
    method, and then you demonstrate how you expect the mock objects to be used. The
    mocking context records your demonstration, so later on when you call its `replay`
    method it knows what usage to expect for each object and how it should respond.
    Your tests (which use the mock objects instead of the real objects that they imitate),
    go after the call to `replay`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了模拟上下文，你通过调用它的`mock`方法来创建一个模拟对象，然后你演示你期望如何使用模拟对象。模拟上下文记录你的演示，因此当你稍后调用它的`replay`方法时，它知道每个对象期望的用法以及如何响应。你的测试（使用模拟对象而不是它们所模仿的真实对象），在调用`replay`之后进行。
- en: Finally, after test code has been run, you call the mocking context's `restore`
    method to undo any replacements of library objects, and then `verify` to check
    that the actual usage of the mocks was as expected.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在运行测试代码之后，你调用模拟上下文的`restore`方法来撤销任何库对象的替换，然后调用`verify`来检查模拟的实际使用是否符合预期。
- en: Our first use of Mocker was straightforward. We tested our constructor, which
    is specified to be extremely simple. It's not supposed to do anything with its
    parameters, aside from store them away for later. Did we gain anything at all
    by using Mocker to create mock objects to use as the parameters, when the parameters
    aren't even supposed to do anything? In fact, we did. Since we didn't tell Mocker
    to expect any interactions with the mock objects, it will report nearly any usage
    of the parameters (storing them doesn't count, because storing them isn't actually
    interacting with them) as errors during the `verify` step. When we call `mocker.verify()`,
    Mocker looks back at how the parameters were really used and reports a failure
    if our constructor tried to perform some action on them. It's another way to embed
    our expectations into our tests.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对Mocker的第一个使用很简单。我们测试了我们的构造函数，它被指定为极其简单。它不应该对其参数做任何事情，除了将它们存储起来以备后用。当参数甚至不应该做任何事情时，我们使用Mocker创建模拟对象作为参数使用，我们真的从中获得了任何好处吗？实际上，我们确实获得了。因为我们没有告诉Mocker期望与模拟对象有任何交互，所以在`verify`步骤中，它将几乎任何参数的使用（存储它们不算，因为存储它们实际上并没有与它们交互）报告为错误。当我们调用`mocker.verify()`时，Mocker回顾参数的实际使用情况，如果我们的构造函数试图对它们执行某些操作，它将报告失败。这是将我们的期望嵌入到测试中的另一种方式。
- en: We used Mocker twice more, except in those later uses we told Mocker to expect
    a call to an `evaluate` method on the mock objects (i.e. `p1` and `p2`), and to
    expect an empty dictionary as the parameter to each of the mock objects' `evaluate`
    call. For each call we told it to expect, we also told it that its response should
    be to return a specific floating point number. Not coincidentally, that mimics
    the behavior of an operation object, and we can use the mocks in our tests of
    `multiply.evaluate`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用了Mocker两次，但在那些后续的使用中，我们告诉Mocker期望在模拟对象（即`p1`和`p2`）上调用`evaluate`方法，并且期望每个模拟对象的`evaluate`调用参数为空字典。对于每个我们告诉它期望的调用，我们也告诉它其响应应该是返回一个特定的浮点数。这不是巧合，这模仿了操作对象的行为，我们可以在测试`multiply.evaluate`时使用这些模拟。
- en: If `multiply.evaluate` hadn't called the `evaluate` methods of mock, or if it
    had called one of them more than once, our `mocker.verify` call would have alerted
    us to the problem. This ability to describe not just what should be called but
    how often each thing should be called is a very useful too that makes our descriptions
    of what we expect much more complete. When `multiply.evaluate` calls the `evaluate`
    method of mock, the values that get returned are the ones that we specified, so
    we know exactly what `multiply.evaluate` ought to do. We can test it thoroughly,
    and we can do it without involving any of the other units of our code. Try changing
    how `multiply.evaluate` works and see what `mocker.verify` says about it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`multiply.evaluate`没有调用模拟的`evaluate`方法，或者如果它多次调用了其中的一个，我们的`mocker.verify`调用就会提醒我们问题。这种不仅能够描述应该调用什么，而且能够描述每个东西应该调用多少次的能力是一个非常有用的工具，它使得我们描述期望的内容更加完整。当`multiply.evaluate`调用模拟的`evaluate`方法时，返回的值是我们指定的值，因此我们知道`multiply.evaluate`应该做什么。我们可以彻底测试它，而且我们可以不涉及代码中的任何其他单元。尝试改变`multiply.evaluate`的工作方式，看看`mocker.verify`对此有何说法。
- en: Mocking functions
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟函数
- en: Normal objects (that is to say, objects with methods and attributes created
    by instantiating a class) aren't the only things you can make mocks of. Functions
    are another kind of object that can be mocked, and it turns out to be pretty easy.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正常对象（即通过实例化类创建具有方法和属性的对象）并不是唯一可以模拟的对象。函数是另一种可以模拟的对象，而且实际上做起来相当简单。
- en: During your demonstration, if you want a mock object to represent a function,
    just call it. The mock object will recognize that you want it to behave like a
    function, and it will make a note of what parameters you passed it, so that it
    can compare them against what gets passed to it during the test.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的演示过程中，如果你想用一个模拟对象来表示一个函数，只需调用它。模拟对象会识别出你希望它表现得像一个函数，并且会记录下你传递给它的参数，以便在测试过程中进行比较。
- en: 'For example, the following code creates a mock called `func`, which pretends
    to be a function that, when called once with the parameters `56` and `hello`,
    returns the number `11`. The second part of the example uses the mock in a very
    simple test:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码创建了一个名为`func`的模拟，它假装是一个函数，当用参数`56`和`hello`调用一次时，返回数字`11`。示例的第二部分使用模拟进行了一个非常简单的测试：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Mocking containers
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟容器
- en: Containers are another category of somewhat special objects that can be mocked.
    Like functions, containers can be mocked by simply using a mock object as if it
    were a container during your example.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是另一类特殊对象，也可以进行模拟。就像函数一样，容器可以通过在示例中使用模拟对象作为容器来模拟。
- en: 'Mock objects are able to understand examples that involve the following container
    operations: looking up a member, setting a member, deleting a member, finding
    the length, and getting an iterator over the members. Depending on the version
    of Mocker, membership testing via the `in` operator may also be available.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象能够理解涉及以下容器操作的示例：查找成员、设置成员、删除成员、查找长度以及获取成员的迭代器。根据Mocker的版本，可能也支持通过`in`运算符进行成员资格测试。
- en: In the following example, all of the above capabilities are demonstrated, but
    the `in` tests are disabled for compatibility with versions of Mocker that don't
    support them. Keep in mind that even though, after we call `replay`, the object
    called `container` looks like an actual container, it's not. It's just responding
    to stimuli we told it to expect, in the way we told it to respond. That's why,
    when our test asks for an iterator, it returns `None` instead. That's what we
    told it to do, and that's all it knows.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，展示了上述所有功能，但为了与不支持这些功能的Mocker版本兼容，禁用了`in`测试。请记住，尽管我们在调用`replay`之后，名为`container`的对象看起来像一个实际的容器，但它并不是。它只是在按照我们告诉它的方式响应我们告诉它期待的所有刺激。这就是为什么当我们的测试请求迭代器时，它返回`None`。这正是我们告诉它的，而且这就是它所知道的一切。
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Something to notice in the above example is that during the initial phase, a
    few of the demonstrations (for example, the call to `len`) did not return a `mocker.Mock`
    object, as we might have expected. For some operations, Python enforces that the
    result is of a particular type (for example, container lengths have to be integers),
    which forces Mocker to break its normal pattern. Instead of returning a generic
    mock object, it returns an object of the correct type, although the value of the
    returned object is meaningless. Fortunately, this only applies during the initial
    phase, when you're showing Mocker what to expect, and only in a few cases, so
    it's usually not a big deal. There are times when the returned mock objects are
    needed, though, so it's worth knowing about the exceptions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中需要注意的一点是，在初始阶段，一些演示（例如，调用`len`）并没有返回我们预期的`mocker.Mock`对象。对于某些操作，Python强制要求结果必须是特定类型（例如，容器长度必须是整数），这迫使Mocker打破其常规模式。它不是返回一个通用的mock对象，而是返回正确类型的对象，尽管返回对象的值没有意义。幸运的是，这仅在初始阶段适用，当你向Mocker展示预期内容时，并且仅在少数情况下发生，所以通常不是什么大问题。尽管如此，有时返回的mock对象是必需的，因此了解这些例外情况是值得的。
- en: Parameter matching
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数匹配
- en: 'Sometimes, we would like our mocked functions and methods to accept a whole
    domain of parameters, instead of limiting itself to the accepting objects that
    compare equal to the parameters we specifically told it about. This can be useful
    for any number of reasons: perhaps the mock needs to accept an external variable
    as a parameter (the current time, or available disk space, for example), or maybe
    the mock example will be invoked multiple times (which we''ll discuss soon), or
    maybe the parameters are simply not important to the definition of correct behavior.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望我们的mock函数和方法接受整个参数域，而不是仅限于接受我们特别告知它的参数所比较的对象。这可能有多种原因：也许mock需要接受一个外部变量作为参数（例如当前时间或可用磁盘空间），或者mock示例将被多次调用（我们很快会讨论这一点），或者参数对于正确行为的定义可能并不重要。
- en: We can tell a mock function to accept a domain of parameters by using the `ANY`,
    `ARGS`, `KWARGS`, `IS`, `IN`, `CONTAINS`, and `MATCH` special values, all of which
    are defined in the `mocker` module. These special values are passed to a mock
    object as function call parameters during its demonstration phase (before you
    call `replay`).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`ANY`、`ARGS`、`KWARGS`、`IS`、`IN`、`CONTAINS`和`MATCH`这些特殊值来告诉mock函数接受参数域，这些特殊值都在`mocker`模块中定义。这些特殊值在演示阶段（在你调用`replay`之前）作为函数调用参数传递给mock对象。
- en: ANY
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ANY
- en: Passing `ANY` as a function parameter causes the object to accept any single
    object as its parameter in that position.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 将`ANY`作为函数参数传递会导致对象接受在该位置上的任意单个对象作为其参数。
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ARGS
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ARGS
- en: Passing `ARGS` as a function parameter causes the object to accept any number
    of positional arguments, as if it had been declared with `*args` in its parameter
    list.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将`ARGS`作为函数参数传递会导致对象接受任意数量的位置参数，就像它在参数列表中声明了`*args`一样。
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: KWARGS
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: KWARGS
- en: Passing `KWARGS` as a function parameter causes the object to accept any number
    of keyword arguments, as if it had been declared with `**kwargs` in its parameter
    list.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 将`KWARGS`作为函数参数传递会导致对象接受任意数量的关键字参数，就像它在参数列表中声明了`**kwargs`一样。
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: IS
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IS
- en: Passing `IS(some_object)` is unusual, because instead of being an inexact parameter,
    it's more exact than the default. Mocker will normally accept any parameter that
    is `==` to the value passed during the initial phase, but if you use `IS`, it
    instead checks whether the parameter and `some_object` are in fact the exact same
    object, and only accepts the call if they are.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 传递 `IS(some_object)` 是不寻常的，因为它不是一个不精确的参数，而是比默认值更精确。Mocker 通常接受任何在初始阶段传递的值 `==`
    相等的参数，但如果你使用 `IS`，它将检查参数和 `some_object` 是否确实是同一个对象，并且只有当它们是同一个对象时才接受调用。
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: IN
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IN
- en: Passing `IN(some_container)` causes Mocker to accept any parameter that is contained
    in the container object called `some_container`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 传递 `IN(some_container)` 会导致 Mocker 接受任何包含在名为 `some_container` 的容器对象中的参数。
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: CONTAINS
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CONTAINS
- en: Passing `CONTAINS(some_object)` causes Mocker to accept any parameter for which
    `some_object in parameter` is `True`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 传递 `CONTAINS(some_object)` 会导致 Mocker 接受任何满足 `some_object in parameter` 为 `True`
    的参数。
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: MATCH
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MATCH
- en: Finally, if none of the above lets you describe the conditions under which you
    want Mocker to accept a parameter as matching its expectation, you can pass `MATCH(test_function)`
    . The `test_function` should be a function with one parameter, which will be passed
    the received parameter when the mocked function gets called. If the `test_function`
    returns `True`, the parameter is accepted.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你以上所有方法都无法描述你想要 Mocker 接受参数作为匹配其期望的条件，你可以传递 `MATCH(test_function)`。`test_function`
    应该是一个带有一个参数的函数，当模拟函数被调用时，该参数将被传递给接收到的参数。如果 `test_function` 返回 `True`，则参数被接受。
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Mocking complex expressions
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟复杂表达式
- en: It would be nice to be able to combine the various operations that Mocker's
    mock objects support. Simple attribute accesses, container member accesses and
    method calls make up the majority of object interactions, but they are commonly
    used in combinations, like `container[index].attribute.method()`. We could write
    a demonstration of something equivalent to this out, step-by-step, using the things
    we already know about Mocker's mock objects, but it would be nice to be able to
    just write the example as we expect it to be in the actual code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 能够将 Mocker 模拟对象支持的各项操作结合起来会很好。简单的属性访问、容器成员访问和方法调用构成了大多数对象交互，但它们通常以组合的形式使用，例如
    `container[index].attribute.method()`。我们可以逐步编写一个与这个类似的演示，使用我们已知的关于 Mocker 模拟对象的知识，但能够直接以我们期望的方式在实际代码中编写示例会更好。
- en: Fortunately, we can usually do exactly that. Throughout the previous examples
    in this chapter, you've been seeing expressions that return `<mocker.Mock object
    at ...>`. Those return values are mock objects, just like the ones you create
    by calling `Mocker.mock`, and they can be used in the same ways. That means that
    as long as part of a complex expression returns a mock object during the demonstration,
    you can continue chaining more parts of the complex expression onto it. With something
    like `container[index].attribute.method()`, `container[index]` returns a mock
    object, attribute access on that object returns another mock object, and we call
    a method on that object. The method call also returns a mock object, but we don't
    need to do anything with it in order to correctly demonstrate our expectations.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们通常可以做到这一点。在本章之前的所有示例中，你都看到了返回 `<mocker.Mock object at ...>` 的表达式。这些返回值是模拟对象，就像你通过调用
    `Mocker.mock` 创建的对象一样，它们可以用相同的方式进行使用。这意味着，只要复杂表达式的一部分在演示过程中返回模拟对象，你就可以继续将复杂表达式的更多部分链接到它上面。例如，对于
    `container[index].attribute.method()`，`container[index]` 返回一个模拟对象，对该对象的属性访问返回另一个模拟对象，然后我们调用该对象的方法。方法调用也返回一个模拟对象，但为了正确演示我们的期望，我们不需要对它做任何事情。
- en: Mocker remembers our demonstration of use, no matter how complex it is or how
    deeply we drill down into nested objects. Later after we call `replay`, it checks
    that the usage is as we described it, even for very complicated usage patterns.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Mocker 记录了我们的使用演示，无论它有多复杂，或者我们如何深入嵌套对象。在之后我们调用 `replay` 之后，它会检查使用情况是否符合我们描述的，即使是非常复杂的用法模式。
- en: Have a go hero
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄
- en: Try telling Mocker to expect a function call which returns a string, which is
    then trimmed of whitespace and split on commas, and do it all as a single complex
    expression.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试告诉 Mocker 期望一个返回字符串的函数调用，该字符串随后被去除空白并按逗号分割，并且作为一个单一复杂表达式来完成。
- en: Returning iterators
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回迭代器
- en: 'So far, we''ve been calling `Mocker.result` to tell Mocker that the result
    of evaluating a particular example expression should be some specific value. That''s
    great for simulating most expressions, and it covers the common usage of functions
    and methods as well, but it doesn''t really do the trick for simulating a generator,
    or other function that returns an iterator. To handle that, we call `Mocker.generate`
    instead of `Mocker.result`, like so:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在调用`Mocker.result`来告诉Mocker，评估特定示例表达式的结果应该是某个特定的值。这对于模拟大多数表达式来说很棒，并且也涵盖了函数和方法的一般用法，但它并不能真正模拟生成器或其他返回迭代器的函数。为了处理这种情况，我们调用`Mocker.generate`而不是`Mocker.result`，如下所示：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Raising exceptions
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抛出异常
- en: 'Some expressions raise an exception instead of returning a result, so we need
    to be able to make our mock objects do the same. Fortunately, it''s not difficult:
    you call `Mocker.throw` to tell Mocker that the correct response to an expected
    expression is to raise a particular exception.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一些表达式会抛出异常而不是返回结果，因此我们需要能够使我们的模拟对象做同样的事情。幸运的是，这并不困难：您调用`Mocker.throw`来告诉Mocker，对期望表达式的正确响应是抛出特定的异常。
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Calling functions via a mock
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过模拟调用函数
- en: Sometimes a function that we're mocking has side-effects that are important
    to our tests. Mocker handles these situations by allowing you to specify one or
    more functions that should be called, when a particular expression occurs. These
    functions can either be existing functions that are pulled from somewhere in your
    codebase, or they can be special functions that you've embedded in your test specifically
    to produce the desired side effects.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们模拟的函数有对我们测试很重要的副作用。Mocker通过允许您指定在特定表达式发生时应调用的一个或多个函数来处理这些情况。这些函数可以是来自您代码库某处的现有函数，或者可以是您专门嵌入到测试中以产生所需副作用的特殊函数。
- en: 'There is one restriction on which functions can be called as a result of interacting
    with one of the mock objects of Mocker: such a function must not require any parameters.
    This isn''t as big a restriction as you might think, because you know exactly
    which parameters should be passed to the called functions, and so you can write
    a small wrapper function that just calls the target function with those parameters.
    This is demonstrated in the next example.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在与Mocker的某个模拟对象交互后，可以调用的函数有一个限制：这样的函数不能需要任何参数。这并不像您想象的那么大，因为您知道应该传递给调用函数的确切参数，因此您可以编写一个小的包装函数，只需用这些参数调用目标函数。这将在下一个示例中演示。
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Python `lambda` keyword is a mechanism for wrapping a single expression
    up as a function. When the function gets called, the expression is evaluated,
    and whatever the expression evaluated to is returned from the function. The uses
    of `lambda` are many and varied, but using it to create minor wrappers around
    calls to other functions is a common one.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`lambda`关键字是一种将单个表达式包装成函数的机制。当函数被调用时，表达式将被评估，并且返回表达式评估的结果。`lambda`的使用多种多样，但用它来创建围绕其他函数调用的微小包装器是一种常见的用法。
- en: Calling functions in this way isn't exclusive with having the mocked function
    return a result. In the following example, the mocked function makes two function
    calls and returns the number 5.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式调用函数并不排除模拟函数返回结果。在下面的示例中，模拟函数执行两次函数调用并返回数字5。
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Specifying that an expectation should occur multiple times
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定一个期望应该发生多次
- en: 'As you may have noticed in some of the preceding examples, sometimes telling
    Mocker what to expect can get repetitive. The example of the `IN` parameter matcher
    show this well: We did a lot of repetitive work telling Mocker that we expected
    three calls to the `func` function. That makes the test long (which reduces its
    readability) and it violates the DRY (Don''t Repeat Yourself) principle of programming,
    making it harder to modify the test later on. Besides which, it''s annoying to
    write all those duplicate expectations.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能在一些先前的示例中注意到的那样，有时告诉Mocker预期什么可能会变得重复。`IN`参数匹配器的例子很好地展示了这一点：我们做了很多重复的工作，告诉Mocker我们期望调用`func`函数三次。这使得测试变得很长（这降低了其可读性），并且违反了编程中的DRY（不要重复自己）原则，使得后续修改测试变得更加困难。此外，编写所有那些重复的预期也很烦人。
- en: 'To solve this problem, Mocker allows us to specify the number of times that
    an expectation ought to occur during the execution of the test. We do this by
    calling `Mocker.count` to specify the expected number of repetitions. To see the
    simplest way to do that, let''s re-write the `IN` example, so that we don''t have
    to keep repeating ourselves:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，Mocker允许我们指定在测试执行期间期望发生的次数。我们通过调用`Mocker.count`来指定期望的重复次数。为了看到最简单的方法，让我们重新编写`IN`示例，这样我们就不必反复重复：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice how parameter matching works well with specifying a count, letting us
    compress several different calls to `func` into a single expectation, even though
    they have different parameters. By using these two features in conjunction, the
    expectations of a mock can often be shortened significantly, removing redundant
    information. Keep in mind though, that you don't want to remove important information
    from a test; if it mattered that the first call to `func` had `19` as its parameter,
    or that the calls came in a particular order, compressing the expectation this
    way would lose that information, which would compromise the test.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意参数匹配如何与指定计数很好地工作，让我们可以将几个不同的`func`调用压缩成一个期望，即使它们有不同的参数。通过结合使用这两个特性，模拟的期望通常可以显著缩短，删除冗余信息。但请记住，你不想从测试中删除重要信息；如果第一个调用`func`的参数是`19`很重要，或者调用以特定的顺序到来，以这种方式压缩期望会丢失这些信息，这会损害测试。
- en: In the above example, we specified a precise number of times to expect the call
    to `func` to repeat, but `count` is more flexible than that. By giving it two
    parameters, `count` can be told to expect any number of repetitions between a
    minimum and a maximum number. As long as the actual number of repetitions during
    the test is at least as many as the minimum number, and no more than the maximum
    number, Mocker will accept it as correct usage.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们指定了期望`func`调用重复的确切次数，但`count`比这更灵活。通过提供两个参数，`count`可以被告知期望在最小和最大次数之间的任何次数重复。只要测试期间的实际重复次数至少与最小次数一样多，并且不超过最大次数，Mocker就会接受它作为正确的使用方式。
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Finally, it's possible to specify that an expectation is to be repeated at least
    a certain number of times, but with no maximum number of repetitions. As long
    as the expectation is met at least as many times as specified, Mocker considers
    its usage to have been correct. To do this, we pass `None` as the maximum parameter
    when we call `count`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以指定期望至少重复一定次数，但没有最大重复次数。只要期望至少满足指定的次数，Mocker就会认为其使用是正确的。为此，我们在调用`count`时将`None`作为最大参数传递。
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: That last example uses a couple of esoteric Python features. On the left side
    of the `==` is a "list comprehension," which is a compact way of constructing
    a list as a transformation of another iterable. On the right is list multiplication,
    which creates a new list containing the members of the old list repeated a number
    of times—in this case, the list contains `50` repetitions of the value `5`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个例子使用了几个Python的晦涩特性。在`==`的左侧是一个“列表推导”，这是一种将另一个可迭代对象转换为列表的紧凑方式。在右侧是列表乘法，它创建一个新列表，包含旧列表成员的重复次数——在这种情况下，列表包含`50`次重复的值`5`。
- en: Replacing library objects with mocks
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用模拟替换库对象
- en: 'Several times, we''ve seen a need to replace something outside of our own code
    with a mock object: for example, `time.time` needed to be replaced with something
    that produced predictable results, in order for the tests on our PID controller
    to be meaningful.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 几次，我们都看到了需要用模拟对象替换我们代码之外的东西的需求：例如，需要将`time.time`替换为能够产生可预测结果的东西，以便我们的PID控制器测试有意义。
- en: Mocker provides us with a tool to address this common need, and it's quite simple
    to use. Mocker's mocking contexts contain a method called `replace` which behaves
    pretty much like `mock` from our point of view, but which is able to completely
    replace an existing object with a mock object, no matter what module (or modules)
    it exists in, or when it was imported. Even better, when we call `restore` the
    mock goes away, and original object is returned to its rightful place.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Mocker为我们提供了一个工具来满足这种常见需求，并且使用起来相当简单。Mocker的模拟上下文包含一个名为`replace`的方法，从我们的角度来看，它几乎与`mock`一样，但能够完全用模拟对象替换现有对象，无论它存在于哪个模块（或模块），或者何时导入。更好的是，当我们调用`restore`时，模拟对象消失，原始对象返回到其正确的位置。
- en: This gives us an easy way to isolate our tests even from library code that we
    couldn't normally control, and to do it without leaving any trace after we're
    done.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一种简单的方法，即使是从我们通常无法控制的库代码中，也可以隔离我们的测试，并且在完成后不留任何痕迹。
- en: 'To illustrate `replace`, we''re going to temporarily replace `time.time` with
    a mock. We''ve done this before—in our PID tests—in an ad hoc manner. It made
    our tests ugly and difficult to read. It also only replaced the name `time.time`
    with our mock: if we''d done `from time import time` in our PID code, the replacement
    wouldn''t have caught it unless the replacement was done before we imported PID.
    Mocker will handle such complex replacements correctly, no matter when the imports
    occur or what form they take, with no extra effort on our part.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明`replace`函数，我们将临时将`time.time`替换为一个模拟对象。我们之前已经这样做过——在我们的PID测试中——以一种临时的方式。这使得我们的测试变得丑陋且难以阅读。此外，它只替换了名称`time.time`为我们的模拟对象：如果我们已经在PID代码中执行了`from
    time import time`，除非在导入PID之前进行替换，否则替换不会捕获它。Mocker将正确处理这种复杂的替换，无论导入发生的时间或形式如何，而无需我们额外努力。
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice that we imported `time` before we replace it with a mock, and yet when
    we actually used it, it turned out to be the mock we were using. After the call
    to restore, if we'd called `time` again, it would have been the real time function
    again.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在用模拟对象替换它之前导入了`time`，然而当我们实际使用它时，它竟然是我们使用的模拟对象。在恢复调用之后，如果我们再次调用`time`，它将再次是真实的时间函数。
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Why did we use string formatting on the output from `time`? We did this because
    floating point numbers are imprecise, meaning that the number we entered as 3.12,
    for example, might be represented in the system as 3.1200000000000001 or some
    other value that is very close to, but not precisely, 3.12\. The exact value used
    can vary from system to system, so comparing against a float makes your tests
    less portable. Our string formatting rounded the number to just the relevant digits.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们在`time`的输出上使用字符串格式化？我们这样做是因为浮点数是不精确的，这意味着我们输入的3.12，例如，可能在系统中表示为3.1200000000000001或其他非常接近但不是精确的3.12的值。确切值可能因系统而异，因此比较浮点数会使你的测试更不便携。我们的字符串格式化将数字四舍五入到相关数字。
- en: Pop quiz – Mocker usage
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速问答——Mocker使用
- en: 'Which of the following would you use to check whether a parameter passed to
    a mock was one of a set of allowed parameters: `CONTAINS`, `IN`, `IS`?'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个选项可以用来检查传递给模拟对象的参数是否是一组允许的参数之一：`CONTAINS`、`IN`、`IS`？
- en: When you specify that an expectation can repeat, how do you specify that there
    is no upper limit to how many times it can be repeated?
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你指定一个期望可以重复时，你如何指定没有上限，即它可以重复多少次？
- en: What does `mocker.verify()` do?
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mocker.verify()`函数的作用是什么？'
- en: Have a go hero – mocking datetime
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄——模拟datetime
- en: 'Take a look at the following test code, and fill in the missing Mocker demonstrations
    so that the test passes:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下测试代码，并填写缺失的Mocker演示，以便测试通过：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Mocking self
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟self
- en: When a method of an object is called, it's first parameter is a reference to
    the object that contains the method. We'd like to be able to replace it with a
    mock, because that's the only way to truly separate each method, so that each
    can be tested as an individual unit. If we can't mock `self`, the methods will
    tend to interfere with each other's tests by interacting via their containing
    object.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用一个对象的方法时，它的第一个参数是包含该方法的对象的引用。我们希望能够用模拟对象替换它，因为这是唯一真正分离每个方法的方法，以便每个方法都可以作为一个单独的单元进行测试。如果我们不能模拟`self`，方法将通过它们包含的对象相互交互，从而倾向于干扰彼此的测试。
- en: 'The stumbling block in all this is that the `self` object isn''t passed explicitly
    by the caller when a method gets called: Python already knows which object the
    method is bound to, and fills it in automatically. How can we substitute a mock
    for a parameter that doesn''t come from us?'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些中的难点在于，当调用一个方法时，调用者并没有明确传递`self`对象：Python已经知道哪个对象的方法被绑定，并自动填充它。我们如何替换一个不来自我们的参数的模拟对象？
- en: We can solve this problem by finding the function that we're testing in its
    class and invoking it directly, rather than invoking it as a method bound to an
    object. That way, we can pass all of the parameters, including the first one,
    without the interpreter performing any of its magic.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在测试函数的类中找到我们要测试的函数并直接调用它来解决此问题，而不是将其作为绑定到对象的函数调用。这样，我们可以传递所有参数，包括第一个参数，而解释器不会执行任何魔法。
- en: Time for action – passing a mock object as self
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——传递模拟对象作为self
- en: 'Remember the `testable` class that we used, among other things, to demonstrate
    how it can be difficult to separate methods so we can deal with them as units?
    Although we saw this before in Chapter 3, here it is again:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记得我们使用的 `testable` 类，其中之一是用来演示如何很难将方法分离，以便我们可以将它们作为单元来处理？尽管我们在第三章中已经看到了这一点，但这里再次提到：
- en: '[PRE23]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We''re going to write a unit test for `method3`. Like all unit tests, it needs
    to not involve any code from any other unit, which in this case means that `self.method1`
    and `self.method2` need to be mock objects. The best way to achieve that is to
    have `self` itself be a mock object, so that''s what we''re going to do. The first
    step is to create a mock object that expects the interactions that `method3` ought
    to perform:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将编写一个针对 `method3` 的单元测试。像所有单元测试一样，它需要不涉及任何其他单元的代码，在这种情况下意味着 `self.method1`
    和 `self.method2` 需要是模拟对象。实现这一点最好的方法是将 `self` 本身变成一个模拟对象，所以这就是我们要做的。第一步是创建一个期望
    `method3` 应该执行的交互的模拟对象：
- en: '[PRE24]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`method3` is supposed to call `method1` and `method2`, and the mock we just
    created expects to see calls to `method1` and `method2`. So far, so good, so what''s
    the trick to getting this mock object to be `self` for a call to `method3`? Here''s
    the rest of the test:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`method3` 应该调用 `method1` 和 `method2`，而我们刚刚创建的模拟对象期望看到对 `method1` 和 `method2`
    的调用。到目前为止，一切顺利，那么让这个模拟对象成为 `method3` 调用的 `self` 的技巧是什么呢？以下是测试的其余部分：'
- en: '[PRE25]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*What just happened?*'
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We went to the `testable` class and looked up its `method3` member, which is
    something called an "unbound method object." Once we had an unbound method object,
    we looked inside of it for its `im_func` attribute, which is simply a function,
    without any of the razzmatazz associated with methods. Once we had a normal function
    in hand, it was easy to call it, and pass our mock object as its first parameter.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们去了 `testable` 类，查找它的 `method3` 成员，这是一个被称为“未绑定方法对象”的东西。一旦我们有了未绑定方法对象，我们就查看了它的
    `im_func` 属性，它只是一个函数，没有任何与方法相关联的华丽装饰。一旦我们手头有了普通函数，调用它就很容易了，我们可以将我们的模拟对象作为它的第一个参数传递。
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Python version 3.0 made this easier, by getting rid of unbound method objects
    in favor of just storing the function object directly in the class. This means
    that if you're using Python 3.0 or higher, you can just call `testable.method3(target,
    12)`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.0 版本通过移除未绑定方法对象，直接在类中存储函数对象来简化了这一点。这意味着如果您使用的是 Python 3.0 或更高版本，您可以直接调用
    `testable.method3(target, 12)`。
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We learned a lot in this chapter about mocking, and about the Python Mocker.
    We focused on the assorted features that Mocker provides to help you keep units
    separate from each other.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们关于模拟和 Python Mocker 学到了很多。我们关注了 Mocker 提供的各种功能，以帮助您保持单元之间的分离。
- en: Specifically, we covered what mock objects are, and what they're for, how to
    use Python Mocker to make mocking easier, lots of ways to customize Mocker's behavior
    to suit your needs, and how to substitute a mock object for a method's `self`
    parameter.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们涵盖了什么是模拟对象，它们的作用，如何使用 Python Mocker 使模拟更容易，许多自定义 Mocker 行为以适应您需求的方法，以及如何用一个模拟对象替换方法的
    `self` 参数。
- en: 'By this time, we''ve started to see situations where `doctest`—simple and easy
    though it is—begins getting unwieldy. In the next chapter, we''re going to look
    at Python''s other built-in framework for unit testing: `unittest`.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经开始看到 `doctest`——尽管它简单易用——开始变得难以控制的情况。在下一章中，我们将探讨 Python 的另一个内置单元测试框架：`unittest`。
