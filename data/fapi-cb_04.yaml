- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Authentication and Authorization
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证和授权
- en: In this chapter of our *FastAPI Cookbook*, we will delve into the critical realms
    of authentication and authorization, laying the foundation to secure your web
    applications against unauthorized access.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的*FastAPI食谱集*这一章中，我们将深入研究身份验证和授权的关键领域，为您构建安全网络应用程序免受未经授权访问的基础。
- en: As we navigate through this chapter, you’ll embark on a practical journey to
    implement a comprehensive security model in your FastAPI applications. From the
    basics of user registration and authentication to the integration of sophisticated
    **OAuth2** protocols with **JSON Web Token** (**JWT**) for enhanced security,
    this chapter covers it all.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们浏览本章内容的过程中，您将开始一段实际旅程，在FastAPI应用程序中实施一个全面的安全模型。从用户注册和身份验证的基础到将复杂的**OAuth2**协议与**JSON
    Web Token**（**JWT**）集成以提高安全性，本章涵盖了所有内容。
- en: We will create the essential components of **software as a service** (**SaaS**)
    to help you learn practically how to establish user registration systems, verify
    users, and handle sessions efficiently. We’ll also show you how to apply **role-based
    access control** (**RBAC**) to adjust user permissions and protect API endpoints
    with API key authentication. The incorporation of third-party authentication using
    external login services, such as GitHub, will demonstrate how to leverage existing
    platforms for user authentication, simplifying the login process for your users.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建**软件即服务**（**SaaS**）的基本组件，帮助您学习如何实际建立用户注册系统、验证用户和高效处理会话。我们还将向您展示如何应用**基于角色的访问控制**（**RBAC**）来调整用户权限，并使用API密钥身份验证保护API端点。通过使用GitHub等外部登录服务进行第三方身份验证，将展示如何利用现有平台进行用户身份验证，简化用户的登录过程。
- en: Furthermore, you’ll add an extra layer of security by implementing **multi-factor
    authentication** (**MFA**), ensuring that your application’s security is robust
    against various attack vectors.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您将通过实施**多因素身份验证**（**MFA**）添加一个额外的安全层，确保您的应用程序能够抵御各种攻击向量。
- en: 'In this chapter, we’re going to cover the following recipes:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Setting up user registration
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置用户注册
- en: Working with OAuth2 and JWT for authentication
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 OAuth2 和 JWT 进行身份验证
- en: Setting up RBAC
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 RBAC
- en: Using third-party authentication
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用第三方身份验证
- en: Implementing MFA
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施MFA
- en: Handling API key authentication
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理API密钥身份验证
- en: Handling session cookies and logout functionality
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理会话cookie和注销功能
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To dive into the chapter and follow along with recipes on authentication and
    authorization, ensure your setup includes the following essentials:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解本章并跟随身份验证和授权的食谱，请确保您的设置包括以下基本要素：
- en: '**Python**: Install a Python version higher than 3.9 in your environment.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python**：在您的环境中安装一个高于3.9版本的Python。'
- en: '**FastAPI**: This should be installed with all required dependencies. If you
    didn’t do so during the previous chapters, you can simply do it from your terminal:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FastAPI**：应与所有必需的依赖项一起安装。如果您在前几章中没有这样做，您可以从终端简单地完成它：'
- en: '[PRE0]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code used in the chapter is hosted on GitHub at [https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter04](https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter04).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码托管在GitHub上，地址为[https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter04](https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter04)。
- en: 'Setting up a virtual environment for the project within the project root folder
    is also recommended to manage dependencies efficiently and maintain project isolation.
    Within your virtual environment, you can install all the dependencies at once
    by using the `requirements.txt` file, provided in the GitHub repository in the
    project folder:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目根目录内为项目设置虚拟环境也是推荐的，这样可以高效地管理依赖项并保持项目隔离。在您的虚拟环境中，您可以使用GitHub项目文件夹中提供的`requirements.txt`文件一次性安装所有依赖项：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since the interactive Swagger documentation is limited at the time of writing,
    a basic mastering of **Postman** or any other testing API is beneficial to test
    our API.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于编写时交互式Swagger文档有限，因此掌握**Postman**或其他测试API的基本技能对测试我们的API有益。
- en: Now that we have this ready, we can begin preparing our recipes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个准备，我们可以开始准备我们的食谱。
- en: Setting up user registration
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置用户注册
- en: User registration is the first step in securing your FastAPI application. It
    involves collecting user details and storing them securely. Here’s how you can
    set up a basic user registration system. The recipe will show you how to set up
    a FastAPI application’s registration system.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 用户注册是保护你的 FastAPI 应用程序的第一步。它涉及收集用户详细信息并安全地存储它们。以下是你可以设置基本用户注册系统的方法。配方将向你展示如何设置
    FastAPI 应用的注册系统。
- en: Getting ready
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will start by storing users in an SQL database. Let’s create a project root
    folder called `saas_app`, containing the code base.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在 SQL 数据库中存储用户。让我们创建一个名为 `saas_app` 的项目根文件夹，其中包含代码库。
- en: To store user passwords, we will use an external package to hash plain text
    with the **bcrypt** algorithm. The hashing function transforms a text string into
    a unique and irreversible output, allowing for secure storage of sensitive data
    such as passwords. You can find more details at [https://en.wikipedia.org/wiki/Hash_function](https://en.wikipedia.org/wiki/Hash_function).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储用户密码，我们将使用一个外部包来使用 **bcrypt** 算法散列纯文本。散列函数将文本字符串转换为一个独特且不可逆的输出，允许安全地存储敏感数据，如密码。更多详情请参阅
    [https://en.wikipedia.org/wiki/Hash_function](https://en.wikipedia.org/wiki/Hash_function)。
- en: 'If you haven’t installed packages from `requirements.txt` from the GitHub repository
    of the chapter under the `saas_app` project folder,, you can install the `passlib`
    package with `bycrypt` by running the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有在 `saas_app` 项目文件夹下安装来自 GitHub 仓库的 `requirements.txt` 中的包，你可以通过运行以下命令安装
    `passlib` 包，其中包含 `bcrypt`：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You will also need to install a version of `sqlalchemy` higher than 2.0.0 to
    follow along with the code in the GitHub repository:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要安装一个高于 2.0.0 版本的 `sqlalchemy`，以便跟随 GitHub 仓库中的代码：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Our environment is now ready to implement the user registration in our SaaS.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的环境现在已准备好在我们的 SaaS 中实现用户注册。
- en: How to do it…
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Before starting the implementation, we need to set up the database to store
    our users.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实施之前，我们需要设置数据库以存储我们的用户。
- en: We need to set up a `sqlalchemy` for the application to store user credentials.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要设置一个 `sqlalchemy`，以便应用程序存储用户凭据。
- en: 'You need to do the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做以下事情：
- en: Set up a `User` class to map the users table in the SQL database. The table
    should contain the `id`, `username`, `email`, and `hashed_password` fields.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置一个 `User` 类来映射 SQL 数据库中的用户表。该表应包含 `id`、`username`、`email` 和 `hashed_password`
    字段。
- en: Establish the connection between the application and the database.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立应用程序与数据库之间的连接。
- en: First let's create our project root folder called `saas_app`. Then you can refer
    to the *Setting up SQL databases* recipe in [*Chapter 2*](B21025_02.xhtml#_idTextAnchor052),
    *Working with Data*, or copy the `database.py` and `db_connection.py` modules
    from the GitHub repository under your root folder.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个名为 `saas_app` 的项目根文件夹。然后你可以参考 [*第 2 章*](B21025_02.xhtml#_idTextAnchor052)
    中的 *设置 SQL 数据库* 配方，或者从 GitHub 仓库中复制 `database.py` 和 `db_connection.py` 模块到你的根文件夹下。
- en: With the database session set up, let’s define the function that adds a user.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好数据库会话后，让我们定义一个添加用户的函数。
- en: Let’s make it into a dedicated module called `operations.py`, in which we will
    define all the support functions used by the API endpoints.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其变成一个名为 `operations.py` 的专用模块，在其中我们将定义所有由 API 端点使用的支持函数。
- en: 'The function will use a password context object from the `bcrypt` package to
    hash plain text passwords. We can define it as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将使用来自 `bcrypt` 包的密码上下文对象来散列纯文本密码。我们可以如下定义它：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can then define the `add_user` function, which inserts a new user into the
    database with the hashed password, according to most of data compliance regulations:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个名为 `add_user` 的函数，根据大多数数据合规规定，将带有散列密码的新用户插入数据库中：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`InegrityError` will take into account the attempt to add a username or email
    that already exists.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`IntegrityError` 将考虑尝试添加已存在的用户名或电子邮件的尝试。'
- en: 'We now have to define our endpoint, but first, we need to set up our server
    and initialize the database connection. We can do it in the `main.py` module,
    as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须定义我们的端点，但首先，我们需要设置我们的服务器并初始化数据库连接。我们可以在 `main.py` 模块中这样做，如下所示：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We use the `lifespan` parameter of the `FastAPI` object to instruct the server
    to sync our database class, `User`, with the database when it starts up.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `FastAPI` 对象的 `lifespan` 参数来指示服务器在启动时同步我们的数据库类 `User` 与数据库。
- en: In addition, we can create a separate module, `responses.py`, to keep the response
    classes used for different endpoints. Feel free to create your own or copy the
    one provided in the GitHub repository.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以创建一个单独的模块，`responses.py`，以保存用于不同端点的响应类。请随意创建自己的或复制 GitHub 仓库中提供的那个。
- en: 'We can now write the suitable endpoint to sign up a user in the same `main.py`
    module:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以编写合适的端点来在同一个 `main.py` 模块中注册用户：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We have just implemented a basic mechanism to register and store users in our
    SaaS database.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚实现了一个基本的机制来在我们的 SaaS 数据库中注册和存储用户。
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The endpoint will accept a JSON body containing a username, email, and password.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 该端点将接受一个包含用户名、电子邮件和密码的 JSON 主体。
- en: If the username or email already exists, a `409` response will be returned,
    and user creation will be disallowed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户名或电子邮件已存在，将返回 `409` 响应，并且不允许创建用户。
- en: 'To test this, at the project root level, spin up the server by running the
    following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这个，在项目根目录下，运行以下命令启动服务器：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Then, connect with your browser at `localhost:8000/docs` and check the endpoint
    we just created in the Swagger documentation. Feel free to play around with it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用浏览器连接到 `localhost:8000/docs` 并检查我们在 Swagger 文档中刚刚创建的端点。请随意尝试。
- en: Exercise
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: 'Create proper tests for both the `add_user` function and the `/register/user`
    endpoint, such as the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为 `add_user` 函数和 `/register/user` 端点创建适当的测试，例如以下内容：
- en: '`def test_add_user_into_the_database(session):`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`def test_add_user_into_the_database(session):`'
- en: '`user =` `add_user(…`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`user =` `add_user(…`'
- en: '`# fill in` `the test`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`# fill in` `the test`'
- en: '`def test_endpoint_add_basic_user(client):`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`def test_endpoint_add_basic_user(client):`'
- en: '`response =` `client.post(`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`response =` `client.post(`'
- en: '`"/``register/user",`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`"/``register/user",`'
- en: '`json=`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`json=`'
- en: '`# continue` `the test`'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`# continue` `the test`'
- en: You can arrange the test in any way that works best for you.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以对你最有利的方式安排测试。
- en: You can find a possible way of testing in the `Chapter04/saas_app` folder of
    the book’s GitHub repository.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在书的 GitHub 仓库的 `Chapter04/saas_app` 文件夹中找到一个可能的测试方法。
- en: See also
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'The **bcrypt** library allows you to add several layers of security to your
    hashing functions, such as salt and additional keys. Feel free to have a look
    at the source code on GitHub:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**bcrypt** 库允许你为你的哈希函数添加多层安全性，例如盐和额外的密钥。请随意查看 GitHub 上的源代码：'
- en: '*Bcrypt GitHub* *Repository*: [https://github.com/pyca/bcrypt/](https://github.com/pyca/bcrypt/)'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Bcrypt GitHub 仓库*：[https://github.com/pyca/bcrypt/](https://github.com/pyca/bcrypt/)'
- en: 'Also, you can find some interesting examples of how to use it at the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还可以在以下位置找到一些有趣的示例，说明如何使用它：
- en: '*Hashing Passwords in Python with* *Bcrypt*: [https://www.geeksforgeeks.org/hashing-passwords-in-python-with-bcrypt/](https://www.geeksforgeeks.org/hashing-passwords-in-python-with-bcrypt/)'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Bcrypt 在 Python 中哈希密码*：[https://www.geeksforgeeks.org/hashing-passwords-in-python-with-bcrypt/](https://www.geeksforgeeks.org/hashing-passwords-in-python-with-bcrypt/)'
- en: Working with OAuth2 and JWT for authentication
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OAuth2 和 JWT 进行认证
- en: In this recipe, we’ll integrate OAuth2 with JWTs for secure user authentication
    in your application. This approach improves security by utilizing tokens instead
    of credentials, aligning with modern authentication standards.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将集成 OAuth2 和 JWT 以在应用程序中进行安全的用户认证。这种方法通过利用令牌而不是凭据来提高安全性，符合现代认证标准。
- en: Getting ready
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Since we will use a specific library to manage JWT, ensure you have the necessary
    dependencies installed. If you haven’t installed the packages from `requirements.txt`,
    run the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用特定的库来管理 JWT，请确保你已经安装了必要的依赖项。如果你还没有从 `requirements.txt` 安装包，请运行以下命令：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Also, we will use the users table used in the previous recipe, *Setting up user
    registration*. Make sure to have set it up before starting the recipe.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将使用之前配方中使用的用户表，*设置用户注册*。确保在开始配方之前已经设置好。
- en: How to do it...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We can set up the JWT token integration through the following steps.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下步骤设置 JWT 令牌集成。
- en: 'In a new module called `security.py`, let’s define the authentication function
    for the user:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个名为 `security.py` 的新模块中，让我们定义用户的认证函数：
- en: '[PRE10]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The function can validate the input based on either the username or email.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该函数可以根据用户名或电子邮件验证输入。
- en: Let’s define the functions to create and decode the access token in the same
    module (`create_access_token` and `decode_access_token`).
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在同一个模块（`create_access_token` 和 `decode_access_token`）中定义创建和解码访问令牌的函数。
- en: 'To create the access token, we will need to specify a secret key, the algorithm
    used to generate it, and the expiration time, as follows:'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要创建访问令牌，我们需要指定一个密钥、用于生成它的算法以及过期时间，如下所示：
- en: '[PRE11]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, the `create_access_token_function` is as follows:'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，`create_access_token_function`如下所示：
- en: '[PRE12]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To decode the access token, we can use a support function, `get_user`, that
    returns the `User` object by the username. You can do it on your own in the `operations.py`
    module or take it from the GitHub repository.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要解码访问令牌，我们可以使用一个支持函数`get_user`，该函数通过用户名返回`User`对象。您可以在`operations.py`模块中自行实现，或者从GitHub仓库中获取。
- en: 'The function to decode the token will be as follows:'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解码令牌的函数如下所示：
- en: '[PRE13]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can now proceed to create the endpoint to retrieve the token in the same
    module, `security.py`, with the `APIRouter` class:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以继续在同一模块`security.py`中使用`APIRouter`类创建检索令牌的端点：
- en: '[PRE14]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, we can now create an `OAuth2PasswordBearer` object for the `POST /token`
    endpoint to obtain the access token:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们现在可以为`POST /token`端点创建一个`OAuth2PasswordBearer`对象以获取访问令牌：
- en: '[PRE15]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we can create the `/users/me` endpoint that returns the credentials
    based on the token:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以创建一个返回基于令牌的凭据的`/users/me`端点：
- en: '[PRE16]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, let’s import those endpoints into the FastAPI server in `main.py`. Right
    after defining the FastAPI object, let’s add the router, as follows:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在`main.py`中将这些端点导入到FastAPI服务器中。在定义FastAPI对象后，让我们添加路由器，如下所示：
- en: '[PRE17]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We have just defined the authentication mechanism for our SaaS.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚为我们的SaaS定义了认证机制。
- en: How it works…
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Now, spin up the server by running the following code from the terminal at
    the project root folder level:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从项目根目录的终端运行以下代码来启动服务器：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Go to the Swagger documentation address in your browser (`localhost:8000/docs`)
    and you will see the new endpoints, `POST /token` and `GET /users/me`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中转到Swagger文档地址（`localhost:8000/docs`），您将看到新的端点`POST /token`和`GET /users/me`。
- en: You need the token to call the second endpoint, which you can store in your
    browser automatically by clicking on the lock icon and filling out the form with
    your credentials.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要令牌来调用第二个端点，您可以通过点击锁形图标并填写凭据表单来自动在浏览器中存储它。
- en: You’ve made your SaaS application more secure by using OAuth2 with JWT, which
    help you guard your sensitive endpoints and make sure that only users who are
    logged in can use them. This arrangement gives you a reliable and safe way to
    verify users that works well for modern web applications.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用JWT和OAuth2，您已经使您的SaaS应用程序更加安全，这有助于您保护敏感端点，并确保只有登录用户才能使用它们。这种安排为您提供了可靠且安全的方式来验证用户，这对于现代Web应用程序来说效果很好。
- en: See also
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'You can gain a better understanding of the OAuth2 framework by reading this
    article:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过阅读这篇文章更好地理解OAuth2框架：
- en: '*Introduction to* *OAuth2*: [https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2](https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2)'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*OAuth2简介*: [https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2](https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2)'
- en: 'Also, you can have a look at the protocol definition for JWTs at the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以查看以下JWT协议定义：
- en: '*JWT IETF* *Document*: [https://datatracker.ietf.org/doc/html/rfc7519](https://datatracker.ietf.org/doc/html/rfc7519)'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JWT IETF* *文档*: [https://datatracker.ietf.org/doc/html/rfc7519](https://datatracker.ietf.org/doc/html/rfc7519)'
- en: Setting up RBAC
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置RBAC
- en: RBAC is a method of regulating access to resources based on the roles of individual
    users within an organization. In this recipe, we’ll implement RBAC in a FastAPI
    application to manage user permissions effectively.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 基于组织内个体用户的角色来调节资源访问的RBAC是一种方法。在本食谱中，我们将实现RBAC在FastAPI应用程序中，以有效地管理用户权限。
- en: Getting ready
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Since we will expand our database to accommodate role definitions, make sure
    you have completed the *Setting up user registration* recipe before diving into
    this.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将扩展数据库以容纳角色定义，请确保在深入此之前已经完成了*设置用户注册*食谱。
- en: To set up access control, we first need to define a variety of roles that we
    can allocate to. Let’s follow these steps to do it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置访问控制，我们首先需要定义一系列我们可以分配的角色。让我们按照以下步骤来做。
- en: 'In the `module.py` module, we can define a new class called `Role` and add
    it as a new field of the `User` model that will be stored in the users table:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`module.py`模块中，我们可以定义一个新的类`Role`，并将其作为`User`模型的新字段添加，该字段将存储在用户表中：
- en: '[PRE19]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, in the `operations.py` module, we will modify the `add_user` function
    in `operations.py` to accept a parameter to define the user role; the default
    value will be the basic role:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`operations.py`模块中，我们将修改`operations.py`中的`add_user`函数，以接受一个参数来定义用户角色；默认值将是基本角色：
- en: '[PRE20]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s create a new module called `premium_access.py` and define the endpoint
    through a new router to sign up a premium user, which will look a lot like the
    endpoint to sign up a basic user:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个新的模块`premium_access.py`，并通过一个新的路由器定义端点来注册高级用户，这将非常类似于注册基本用户的端点：
- en: '[PRE21]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let’s add the router to our `app` class in the `main.py` module:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`main.py`模块中的`app`类中添加路由器：
- en: '[PRE22]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We have now all the elements to implement RBAC in our SaaS application.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了在SaaS应用程序中实现RBAC的所有元素。
- en: How to do it...
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Let’s create two endpoints, one accessible for all the users and one reserved
    only for premium user. Let's make the endpoints through the following steps.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建两个端点，一个对所有用户可访问，另一个仅对高级用户保留。让我们通过以下步骤创建端点。
- en: First, let’s create two helper functions, `get_current_user` and `get_premium_user`,
    to retrieve each case and to be used as dependencies for the endpoints, respectively.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建两个辅助函数，`get_current_user`和`get_premium_user`，分别用于检索每个案例，并作为端点的依赖项使用。
- en: 'We can define a separate module, called the `rbac.py` module. Let’s start with
    the imports:'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以定义一个单独的模块，称为`rbac.py`模块。让我们从导入开始：
- en: '[PRE23]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we create the request model that we will use with the endpoints:'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们创建了一个将用于端点的请求模型：
- en: '[PRE24]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we define a support function to retrieve the user based on the token:'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们定义一个支持函数，根据令牌检索用户：
- en: '[PRE25]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can then leverage this function to shortlist premium users only:'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们可以利用这个函数仅筛选出高级用户：
- en: '[PRE26]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, we can use the functions to create the respective endpoints with the router
    in the same module. First, we define a welcome page for all the users:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用这些函数在同一个模块中的路由器来创建相应的端点。首先，我们为所有用户定义一个欢迎页面：
- en: '[PRE27]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, we define the endpoint, allowing only premium users:'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们定义端点，仅允许高级用户访问：
- en: '[PRE28]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let’s add the router we create in `main.py`:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`main.py`中添加我们创建的路由器：
- en: '[PRE29]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We have just implemented two endpoints with permissions based on the use role.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了两个基于使用角色的权限端点。
- en: 'To test our endpoints, start the server from the command line:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试我们的端点，从命令行启动服务器：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Then, from your browser, go to the Swagger page at `http://localhost:8000/docs`,
    and you can see the new endpoints just created.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从您的浏览器中，访问`http://localhost:8000/docs`上的Swagger页面，您可以看到刚刚创建的新端点。
- en: A way to experiment is to create a basic and a premium user and use the corresponding
    endpoints. After you have made the users, you can try using the `GET welcome/all-users`
    and `GET /welcome/premium-user` endpoints with both roles and see that the response
    matches the role’s expectations.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一种实验方法是创建一个基本用户和一个高级用户，并使用相应的端点。在您创建了用户之后，您可以尝试使用`GET welcome/all-users`和`GET
    /welcome/premium-user`端点以及两个角色，并查看响应是否符合角色的预期。
- en: In this recipe, you just made simple endpoints that are available based on the
    user role. You can also play around with making more roles and endpoints.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，您只是创建了基于用户角色的简单端点。您还可以尝试创建更多角色和端点。
- en: There’s more…
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Another way to apply RBAC is to assign a scope to a token. This scope can be
    a string that represents certain permissions. As a result, the role is controlled
    by the token generation system. In FastAPI, you can define scopes within the token.
    You can check out the dedicated documentation page for more information: [https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/](https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 应用RBAC的另一种方式是为令牌分配一个作用域。这个作用域可以是一个表示某些权限的字符串。因此，角色由令牌生成系统控制。在FastAPI中，您可以在令牌内定义作用域。您可以查看专门的文档页面以获取更多信息：[https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/](https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/).
- en: Using third-party authentication
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用第三方身份验证
- en: Incorporating third-party authentication into your FastAPI application allows
    users to log in using their existing social media accounts, such as Google or
    Facebook. This recipe guides you through the process of integrating GitHub third-party
    login, enhancing user experience by simplifying the sign-in process.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 将第三方身份验证集成到您的FastAPI应用程序中允许用户使用他们现有的社交媒体账户登录，例如Google或Facebook。本食谱将指导您通过集成GitHub第三方登录的过程，通过简化登录过程来增强用户体验。
- en: Getting ready
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We’ll focus on integrating GitHub OAuth2 for authentication. GitHub provides
    comprehensive documentation and a well-supported client library that simplifies
    the integration process.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于集成GitHub OAuth2进行认证。GitHub提供了全面的文档和一个支持良好的客户端库，简化了集成过程。
- en: 'You will need the `httpx` package in your environment, so if you haven’t installed
    it with the `requirements.txt`, you can do it by running the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您的环境中需要`httpx`包，所以如果您还没有通过`requirements.txt`安装它，可以通过运行以下命令来完成：
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You will need also a GitHub account set up. If you don’t have one, create one;
    you can find a comprehensive guide on the official documentation at [https://docs.github.com/en/get-started/start-your-journey/creating-an-account-on-github](https://docs.github.com/en/get-started/start-your-journey/creating-an-account-on-github).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要设置一个GitHub账户。如果您还没有，请创建一个；您可以在官方文档中找到全面的指南，网址为[https://docs.github.com/en/get-started/start-your-journey/creating-an-account-on-github](https://docs.github.com/en/get-started/start-your-journey/creating-an-account-on-github)。
- en: 'Then, you need to create an application in your account by following the following
    steps:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要按照以下步骤在您的账户中创建一个应用程序：
- en: From your personal page, click on the profile icon on the top right of the screen,
    the navigate to `SaasFastAPIapp`.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的个人页面，点击屏幕右上角的个人资料图标，然后导航到`SaasFastAPIapp`。
- en: '`http://localhost:8000/home`, which we will create later.'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/home`，这是我们稍后要创建的。'
- en: '`http://localhost:8000/github/auth/token`, which we will define later as well.'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/github/auth/token`，我们稍后也将定义它。'
- en: Click on **Register application** and the app will be created, and you will
    be redirected to a page listing essential data about your OAuth2 app.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**注册应用程序**，应用程序将被创建，并且您将被重定向到一个列出OAuth2应用程序必要数据的页面。
- en: Take note of the client ID and click on the **Generate a new** **client secret**.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意客户端ID，然后点击**生成新的****客户密钥**。
- en: Store the client secret you just created. With the client ID and the client
    secret, we can proceed to implement the third-party authentication by GitHub.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您刚刚创建的客户密钥。有了客户端ID和客户密钥，我们可以继续通过GitHub实现第三方认证。
- en: Now, we have all we need to integrate the GitHub third-party login with our
    application.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经拥有了将GitHub第三方登录集成到我们应用程序所需的一切。
- en: How to do it...
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let’s start by creating a new module called `third_party_login.py` to store
    helper data and functions for the GitHub authentication. Then let's continue as
    follows.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为`third_party_login.py`的新模块开始，用于存储GitHub认证的辅助数据和函数。然后我们继续如下。
- en: 'Within the `third_party_login.py` module, you can define the variables used
    for the authentication:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`third_party_login.py`模块中，您可以定义用于认证的变量：
- en: '[PRE32]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: For `GITHUB_CLIENT_ID` and `GITHUB_CLIENT_SECRET`, use the values of your OAuth
    app.
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于`GITHUB_CLIENT_ID`和`GITHUB_CLIENT_SECRET`，请使用OAuth应用的值。
- en: Warning
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: In a production environment, make sure to not hardcode any username or client
    ID in your code base.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，请确保不要在代码库中硬编码任何用户名或客户端ID。
- en: 'Then, still in the `third_party_login.py` module, let’s define a helper function,
    `resolve_github_token`, that resolves the GitHub token and returns information
    about the user:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，仍然在`third_party_login.py`模块中，让我们定义一个辅助函数`resolve_github_token`，该函数解析GitHub令牌并返回有关用户的信息：
- en: '[PRE33]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In a new module called `github_login.py`, we can start creating the endpoints
    used for the GitHub authentication. Let’s create a new router and the `github_login`
    endpoint that will return the URL used by the frontend to redirect the user to
    the GitHub login page:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个名为`github_login.py`的新模块中，我们可以开始创建用于GitHub认证的端点。让我们创建一个新的路由器和`github_login`端点，该端点将返回前端用于将用户重定向到GitHub登录页面的URL：
- en: '[PRE34]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, let’s add the router to the server in the `main.py` module:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在`main.py`模块中将路由器添加到服务器：
- en: '[PRE35]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Spin up the server with the same command, `uvicorn main:app`, and call the
    endpoint `GET` `/auth/url` we have just created. You will have a similar link
    in the response: [https://github.com/login/oauth/authorize?client_id=your_github_client_id](https://github.com/login/oauth/authorize?client_id=your_github_client_id).'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的命令`uvicorn main:app`启动服务器，并调用我们刚刚创建的端点`GET /auth/url`。您将在响应中看到一个类似的链接：[https://github.com/login/oauth/authorize?client_id=your_github_client_id](https://github.com/login/oauth/authorize?client_id=your_github_client_id)。
- en: This link is used by GitHub for the authentication. The redirection is managed
    by the frontend and is out of the scope of this book.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此链接由GitHub用于认证。重定向由前端管理，不在此书的范围之内。
- en: 'After validating the login, you will be redirected to a `404` page. This is
    because we still haven’t created the callback endpoint in our application. Let’s
    do so in the `github_login.py` module:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证登录后，您将被重定向到一个 `404` 页面。这是因为我们还没有在我们的应用程序中创建回调端点。让我们在 `github_login.py` 模块中这样做：
- en: '[PRE36]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The endpoint we just created returns the actual access token.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们刚刚创建的端点返回实际的访问令牌。
- en: 'If you restart the server and try to validate the GitHub login again with the
    link provded by the `GET` `/auth/url` endpoint, you will receive a response containing
    the token similar to the following:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您重新启动服务器并尝试使用由 `GET` `/auth/url` 端点提供的链接再次验证GitHub登录，您将收到包含类似以下内容的响应：
- en: '[PRE37]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The last piece of the puzzle is to create the home page endpoint that can be
    accessed with the GitHub token and will recognize the user by resolving the token.
    We can define it in the `main.py` module:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一部分是创建一个可以通过GitHub令牌访问的主页端点，并且可以通过解析令牌来识别用户。我们可以在 `main.py` 模块中定义它：
- en: '[PRE38]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You’ve just implemented an endpoint that authenticates with the GitHub third-party
    authenticator.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚实现了一个通过GitHub第三方认证器进行认证的端点。
- en: How it works…
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: First, by using the register endpoint `POST /register/user`, add a user that
    has the same username or email as the GitHub account you are going to test.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过使用注册端点 `POST /register/user`，添加一个具有与您要测试的GitHub账户相同的用户名或电子邮件的用户。
- en: Then, retrieve the token from the GitHub URL provided by the `GET /``auth/url`
    endpoint.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从 `GET /``auth/url` 端点提供的GitHub URL中检索令牌。
- en: You will use a token with your favorite tool to query the `GET /home` endpoint,
    which uses the GitHub token to validate permission.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用您的 favorite 工具中的令牌来查询 `GET /home` 端点，该端点使用GitHub令牌来验证权限。
- en: At the time of writing, we cannot test endpoints requiring external bearer tokens
    with the interactive documentation, so feel free to use your favorite tool to
    query the endpoint by providing the bearer token in the headers authorization.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，我们无法使用交互式文档测试需要外部承载令牌的端点，因此请随意使用您喜欢的工具通过在头部授权中提供承载令牌来查询端点。
- en: 'You can do it with `curl` request from your shell as well, as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用shell中的 `curl` 请求来完成，如下所示：
- en: '[PRE39]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If everything is correctly set up, you will receive the response:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切设置正确，您将收到以下响应：
- en: '[PRE40]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You just implemented and tested authentication by using a third-party application
    such as GitHub. Other providers such as Google or Twitter follow similar procedures,
    with small differences. Feel free to implement them as well.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚使用第三方应用程序（如GitHub）实现了并测试了认证。其他提供者，如Google或Twitter，遵循类似的程序，但有细微差别。您可以自由地实现它们。
- en: See also
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考信息
- en: 'Take a look at the GitHub documentation that provides a guide on how to set
    up OAuth2 authentication:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 查看GitHub文档，它提供了如何设置OAuth2身份验证的指南：
- en: '*GitHub OAuth2* *integration*: [https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps](https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps)'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*GitHub OAuth2* 集成：[https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps](https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps)'
- en: 'You can use third-party authorization login with other providers that allow
    a similar configuration. You can check, for example, Google and Twitter:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用第三方授权登录，这些第三方提供类似配置。例如，您可以检查Google和Twitter：
- en: '*Google OAuth2* *integration*: [https://developers.google.com/identity/protocols/oauth2](https://developers.google.com/identity/protocols/oauth2)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Google OAuth2* 集成：[https://developers.google.com/identity/protocols/oauth2](https://developers.google.com/identity/protocols/oauth2)'
- en: '*Twitter OAuth2* *integration*: [https://developer.twitter.com/en/docs/authentication/oauth-2-0](https://developer.twitter.com/en/docs/authentication/oauth-2-0)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Twitter OAuth2* 集成：[https://developer.twitter.com/en/docs/authentication/oauth-2-0](https://developer.twitter.com/en/docs/authentication/oauth-2-0)'
- en: Implementing MFA
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现多因素认证（MFA）
- en: MFA adds a layer of security by requiring users to provide two or more verification
    factors to gain access to a resource. The recipe guides you through adding MFA
    to your FastAPI application, enhancing security by combining something the user
    knows (their password) with something they have (a device).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 多因素认证（MFA）通过要求用户提供两个或更多验证因素来访问资源，从而增加了一层安全性。本指南将指导您如何在FastAPI应用程序中添加MFA，通过结合用户知道的东西（他们的密码）和他们拥有的东西（设备）来增强安全性。
- en: Getting ready
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For our FastAPI application, we’ll use a **time-based one-time password** (**TOTP**)
    as our MFA method. TOTP provides a six to eight-digit number that’s valid for
    a short period, typically 30 seconds.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的FastAPI应用程序，我们将使用基于时间的**一次性密码**（**TOTP**）作为我们的多因素认证方法。TOTP提供的是一个六到八位的数字，通常有效期为30秒。
- en: 'First, ensure you have the necessary packages installed:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保您已安装必要的软件包：
- en: '[PRE41]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**Pyotp** is a Python library that implements one-time password algorithms,
    including TOTP.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**Pyotp**是一个Python库，实现了包括TOTP在内的一次性密码算法。'
- en: To use the TOTP authentication, we need to modify the user table in our database
    to take into account the TOTP secret used to validate the secret number.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用TOTP认证，我们需要修改我们数据库中的用户表，以考虑用于验证密钥数的TOTP密钥。
- en: 'Let’s modify the `User` class in the `models.py` module by adding the `totp_secret`
    field:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在`models.py`模块中的`User`类中添加`totp_secret`字段来修改它：
- en: '[PRE42]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We are now ready to implement MFA.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好实现多因素认证（MFA）。
- en: How to do it...
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let’s start by creating two helper functions to generate a TOTP secret and TOTP
    URI used by the authenticatorthrough the following steps.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建两个辅助函数来生成认证器使用的TOTP密钥和TOTP URI，步骤如下。
- en: 'We define the functions in a new module called `mfa.py`:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在名为`mfa.py`的新模块中定义了这些函数：
- en: '[PRE43]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The TOTP URI can be a QR code as well in the form of a link.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: TOTP URI也可以是二维码或链接的形式。
- en: We will use the `generate_totp_secret` and `generate_totp_uri` functions to
    create the endpoint to request MFA.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用`generate_totp_secret`和`generate_totp_uri`函数来创建请求多因素认证的端点。
- en: 'The endpoint will return a **TOTP URI** for use by the authenticator. To show
    the mechanism, we will also return the secret number, which in a real-life scenario
    is the number generated by the authenticator:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 端点将返回一个用于认证器的**TOTP URI**。为了展示机制，我们还将返回密钥数，在现实场景中，这是由认证器生成的数字：
- en: '[PRE44]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, we can create the endpoint to validate the secret number:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以创建验证密钥数的端点：
- en: '[PRE45]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As before, you need to include the router in the `FastAPI` object class in `main.py`
    for all the previous endpoints.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，您需要在`main.py`中的`FastAPI`对象类中包含路由器，以用于所有之前的端点。
- en: 'To test it, as usual spin up the server from the terminal by running:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试它，像往常一样，从终端启动服务器，运行以下命令：
- en: '[PRE46]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Make sure you have a user in your database, go to the interactive documentation,
    and call the `/user/enable-mfa` endpoint by authenticating with the user credentials.
    You will get a response with the TOTP URI and a temporary secret number, like
    the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的数据库中有一个用户，转到交互式文档，并通过用户凭据调用`/user/enable-mfa`端点。您将获得包含TOTP URI和临时密钥数的响应，如下所示：
- en: '[PRE47]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Take note of the secret number to use as a parameter of the `/verify-totp`
    endpoint with the username, and you will get this response:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 记下用作`/verify-totp`端点参数的密钥数，您将获得以下响应：
- en: '[PRE48]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You’ve just implemented MFA in your FastAPI application and enhanced security
    by ensuring that even if a user’s password is compromised, an attacker still needs
    access to the user’s second factor (the device running the MFA app) to gain access.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经在FastAPI应用程序中实现了多因素认证，并通过确保即使用户的密码被泄露，攻击者仍然需要访问用户的第二个因素（运行MFA应用程序的设备）才能获得访问权限来增强了安全性。
- en: See also
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Take a look at the Python One-Time Password library in the official documentation:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在官方文档中查看Python One-Time Password库：
- en: '*Python One-Time Password* *library*: [https://pyauth.github.io/pyotp/](https://pyauth.github.io/pyotp/)'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python One-Time Password* *库*：[https://pyauth.github.io/pyotp/](https://pyauth.github.io/pyotp/)'
- en: Handling API key authentication
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理API密钥认证
- en: API key authentication is a simple yet effective way to control access to an
    application. This method involves generating a unique key for each user or service
    that needs access to your API and requiring that key to be included in the request
    headers.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: API密钥认证是一种简单而有效的方法来控制对应用程序的访问。此方法涉及为需要访问您的API的每个用户或服务生成一个唯一的密钥，并要求在请求头中包含该密钥。
- en: API keys can be generated in various ways, depending on the level of security
    needed.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: API密钥可以通过多种方式生成，具体取决于所需的保密级别。
- en: FastAPI doesn’t have built-in support for API key authentication, but you can
    easily implement it using dependencies or middleware. A dependency is more flexible
    for most use cases, so we’ll use that approach.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI没有内置对API密钥认证的支持，但您可以使用依赖项或中间件轻松实现它。对于大多数用例，依赖项更灵活，因此我们将采用这种方法。
- en: This recipe will show you a basic, yet not secure, way to implement it.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将向您展示一种基本但不够安全的方法来实现它。
- en: Getting ready
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will keep working on our application. However, you can apply this recipe
    to a simple application from scratch as well.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续开发我们的应用程序。然而，您也可以将此配方应用于从头开始的一个简单应用程序。
- en: How to do it...
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let’s create an `api_key.py` module to store the logic to handle API keys.
    The package will contain the API list and verification method:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`api_key.py`模块来存储处理API密钥的逻辑。该包将包含API列表和验证方法：
- en: '[PRE49]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the example, the keys are hardcoded into the `VALID_API_KEYS` list. However,
    in real-life production scenarios, the management and validation of the keys are
    usually done by dedicated libraries or even services.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，密钥被硬编码到`VALID_API_KEYS`列表中。然而，在实际的生产场景中，密钥的管理和验证通常由专门的库或服务完成。
- en: 'Let’s create an endpoint that makes use of the API key:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个使用API密钥的端点：
- en: '[PRE50]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now, add the router to the `FastAPI` object class in `main.py`, and then the
    endpoint is ready to be tested.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将路由器添加到`main.py`中的`FastAPI`对象类中，然后端点就准备好测试了。
- en: 'Spin up the server from the command by running the following:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令启动服务器：
- en: '[PRE51]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Go to the interactive documentation at `http://localhost:8000/docs` and test
    the endpoint you just created by providing an API key.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 前往交互式文档`http://localhost:8000/docs`，并通过提供API密钥测试您刚刚创建的端点。
- en: As you see, by adding a simple dependency to the endpoint, you can secure any
    endpoint of your app with an API key.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，通过向端点添加一个简单的依赖项，您可以使用API密钥保护您应用程序的任何端点。
- en: There’s more…
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We have developed a simple module for managing the API of our application.
    In production environment this can be handled by external services often provided
    by the hosting platform. However, If you are going to implement your API management
    system, keep in mind the best practices for API key authentication:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经开发了一个简单的模块来管理我们应用程序的API。在生产环境中，这通常由托管平台提供的外部服务处理。然而，如果您打算实现自己的API管理系统，请记住API密钥认证的最佳实践：
- en: '**Transmission security**: Always use HTTPS to prevent API keys from being
    intercepted during transmission'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传输安全**：始终使用HTTPS以防止API密钥在传输过程中被拦截'
- en: '**Key rotation**: Regularly rotate API keys to minimize the risk of compromise'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密钥轮换**：定期轮换API密钥以最小化密钥泄露的风险'
- en: '**Limit permissions**: Assign minimal permissions required for each API key
    based on the principle of least privilege'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**限制权限**：根据最小权限原则，为每个API密钥分配所需的最低权限'
- en: '**Monitoring and revocation**: Monitor the usage of API keys and have mechanisms
    in place to revoke them if suspicious activity is detected'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控和撤销**：监控API密钥的使用情况，并在检测到可疑活动时建立撤销机制'
- en: Handling session cookies and logout functionality
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理会话cookie和注销功能
- en: Managing user sessions and implementing logout functionality is crucial for
    maintaining security and user experience in web applications. This recipe shows
    how to handle session cookies in FastAPI, from creating cookies upon user login
    to securely terminating sessions upon logout.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 管理用户会话并实现注销功能对于维护Web应用程序的安全性和用户体验至关重要。本配方展示了如何在FastAPI中处理会话cookie，从用户登录时创建cookie到安全地终止注销会话。
- en: Getting ready
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Sessions provide a way to persist user data across requests. When a user logs
    in, the application creates a session on the server side and sends a session identifier
    to the client, usually in a **cookie**. The client sends this identifier back
    with each request, allowing the server to retrieve the user’s session data.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 会话提供了一种在请求之间持久化用户数据的方式。当用户登录时，应用程序在服务器端创建一个会话，并将会话标识符发送到客户端，通常在一个**cookie**中。客户端将此标识符随每个请求发送回服务器，允许服务器检索用户的会话数据。
- en: The recipe will show how to manage cookies for sessions with login and logout
    functionality.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 该配方将展示如何管理具有登录和注销功能的会话的cookie。
- en: How to do it...
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Cookies in FastAPI are easily managed by the `Request` and `Response` object
    classes. Let’s create a login and a logout endpoints to attaches a session cookie
    to the response and ignore it from the request.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI中的cookie可以通过`Request`和`Response`对象类轻松管理。让我们创建一个登录和注销端点，将会话cookie附加到响应中，并从请求中忽略它。
- en: 'Let’s create a dedicated module called `user_session.py` and add the `/``login`
    endpoint:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`user_session.py`的专用模块，并添加`/login`端点：
- en: '[PRE52]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Testing the login endpoint won’t be possible with the Swagger documentation
    because we need to verify that the `fakesession` cookie has been created.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要验证`fakesession` cookie已被创建，因此使用Swagger文档测试登录端点将不可行。
- en: Spin up the server with `uvicorn main:app` and use Postman to create a `Post`
    request to the `/login` endpoint by providing the authentication token for the
    user you want to log in.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`uvicorn main:app`启动服务器，并使用Postman通过提供要登录的用户身份验证令牌来创建对`/login`端点的`Post`请求。
- en: Verify that the response contains the `fakesession` cookie by selecting **Cookies**
    from the drop-down menu of the response section.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从响应部分的下拉菜单中选择**Cookies**，验证响应中是否包含`fakesession` cookie。
- en: 'Accordingly, we can define a logout endpoint that won’t return any session
    cookie in the response:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以定义一个不会在响应中返回任何会话cookie的注销端点：
- en: '[PRE53]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: That’s all you need to manage sessions.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你需要管理会话的所有内容。
- en: To test the `POST /logout` endpoint, restart the server with `uvicorn`. Then,
    when calling the endpoint, make sure you provide the `fakesession` cookie in your
    HTTP request with the user bearer token. If you previously called the login endpoint,
    it should be automatically stored; otherwise, you can set it in the `Cookies`
    section of the request.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试`POST /logout`端点，使用`uvicorn`重新启动服务器。然后，在调用端点时，确保你在HTTP请求中提供了`fakesession`
    cookie和用户的身份验证令牌。如果你之前调用了登录端点，它应该被自动存储；否则，你可以在请求的**Cookies**部分中设置它。
- en: Check the response and confirm that the `fakesession` cookie is not present
    anymore in the response.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 检查响应并确认响应中不再存在`fakesession` cookie。
- en: There’s more…
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There is a lot to learn about cookies besides the basic recipe. In a real-world
    setting, you can use specialized libraries or even external services.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本配方之外，还有很多关于cookie可以学习。在实际环境中，你可以使用专门的库或外部服务。
- en: 'Whatever your choice is, put security first and follow those practices to make
    your session secure and efficient:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你的选择是什么，都要将安全放在首位，并遵循以下实践来确保你的会话既安全又高效：
- en: '`Secure`, `HttpOnly`, and `SameSite` to protect against **cross-site request
    forgery** (**CSRF**) and **cross-site scripting** (**XSS**) attacks'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Secure`、`HttpOnly`和`SameSite`用于防止**跨站请求伪造**（**CSRF**）和**跨站脚本**（**XSS**）攻击'
- en: '**Session expiry**: Implement session expiry both in your session store and
    by setting a maximum age on the cookie'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话过期**：在会话存储中实现会话过期，并在cookie上设置最大年龄'
- en: '**Regenerate Session ID**: Regenerate session IDs upon login to prevent session
    fixation attacks'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重新生成会话ID**：在登录时重新生成会话ID，以防止会话固定攻击'
- en: '**Monitor sessions**: Implement mechanisms to monitor active sessions and detect
    anomalies'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控会话**：实现机制来监控活动会话并检测异常'
- en: By integrating session management and logout functionality into your FastAPI
    application, you ensure that user state is managed securely and efficiently across
    requests. This enhances both the security and user experience of your application.
    Remember to follow best practices for session security to protect your users and
    their data effectively.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将会话管理和注销功能集成到你的FastAPI应用程序中，你确保了用户状态在请求之间得到安全且高效的管理。这增强了你应用程序的安全性和用户体验。请记住，遵循会话安全的最佳实践，以有效地保护用户及其数据。
- en: In the next chapter, we will see how to efficiently debug your FastAPI application.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何高效地调试你的FastAPI应用程序。
- en: See also
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'You can see more on managing cookies in Fast on the documentation page:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在文档页面了解更多关于在Fast中管理cookie的信息：
- en: '*Response* *cookies*: [https://fastapi.tiangolo.com/advanced/response-cookies/](https://fastapi.tiangolo.com/advanced/response-cookies/)'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*响应* *cookie*：[https://fastapi.tiangolo.com/advanced/response-cookies/](https://fastapi.tiangolo.com/advanced/response-cookies/)'
