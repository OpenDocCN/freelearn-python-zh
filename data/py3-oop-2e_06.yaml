- en: Chapter 6. Python Data Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。Python数据结构
- en: 'In our examples so far, we''ve already seen many of the built-in Python data
    structures in action. You''ve probably also covered many of them in introductory
    books or tutorials. In this chapter, we''ll be discussing the object-oriented
    features of these data structures, when they should be used instead of a regular
    class, and when they should not be used. In particular, we''ll be covering:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在示例中看到了许多内置的Python数据结构。你可能也在入门书籍或教程中涵盖了许多这些内容。在本章中，我们将讨论这些数据结构的面向对象特性，以及它们应该在何时使用而不是使用常规类，以及何时不应该使用。特别是，我们将讨论：
- en: Tuples and named tuples
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组和命名元组
- en: Dictionaries
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典
- en: Lists and sets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表和集合
- en: How and why to extend built-in objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何以及为什么扩展内置对象
- en: Three types of queues
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三种类型的队列
- en: Empty objects
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空对象
- en: 'Let''s start with the most basic Python built-in, one that we''ve seen many
    times already, the one that we''ve extended in every class we have created: the
    `object`. Technically, we can instantiate an `object` without writing a subclass:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最基本的Python内置对象开始，这是我们已经看到很多次的对象，我们在创建的每个类中都扩展了它：`object`。从技术上讲，我们可以实例化一个`object`而不编写子类。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Unfortunately, as you can see, it's not possible to set any attributes on an
    `object` that was instantiated directly. This isn't because the Python developers
    wanted to force us to write our own classes, or anything so sinister. They did
    this to save memory; a lot of memory. When Python allows an object to have arbitrary
    attributes, it takes a certain amount of system memory to keep track of what attributes
    each object has, for storing both the attribute name and its value. Even if no
    attributes are stored, memory is allocated for *potential* new attributes. Given
    the dozens, hundreds, or thousands of objects (every class extends object) in
    a typical Python program; this small amount of memory would quickly become a large
    amount of memory. So, Python disables arbitrary properties on `object`, and several
    other built-ins, by default.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，正如你所看到的，不可能在直接实例化的`object`上设置任何属性。这不是因为Python开发人员想要强迫我们编写自己的类，或者有什么邪恶的目的。他们这样做是为了节省内存；大量的内存。当Python允许对象具有任意属性时，它需要一定量的系统内存来跟踪每个对象具有的属性，用于存储属性名称和其值。即使没有存储属性，也会为*潜在*的新属性分配内存。在典型的Python程序中有数十、数百或数千个对象（每个类都扩展了object）；这小量的内存很快就会变成大量的内存。因此，Python默认禁用`object`和其他几个内置对象上的任意属性。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is possible to restrict arbitrary properties on our own classes using **slots**.
    Slots are beyond the scope of this book, but you now have a search term if you
    are looking for more information. In normal use, there isn't much benefit to using
    slots, but if you're writing an object that will be duplicated thousands of times
    throughout the system, they can help save memory, just as they do for `object`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用**slots**在我们自己的类上限制任意属性。Slots超出了本书的范围，但现在你有了一个搜索词，如果你想要更多信息。在正常使用中，使用slots并没有太多好处，但如果你正在编写一个将在整个系统中复制成千上万次的对象，它们可以帮助节省内存，就像对`object`一样。
- en: 'It is, however, trivial to create an empty object class of our own; we saw
    it in our earliest example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，创建一个空对象类非常简单；我们在最早的示例中看到了它：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And, as we''ve already seen, it''s possible to set attributes on such classes:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，正如我们已经看到的，可以在这样的类上设置属性：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If we wanted to group properties together, we could store them in an empty object
    like this. But we are usually better off using other built-ins designed for storing
    data. It has been stressed throughout this book that classes and objects should
    only be used when you want to specify *both* data and behaviors. The main reason
    to write an empty class is to quickly block something out, knowing we'll come
    back later to add behavior. It is much easier to adapt behaviors to a class than
    it is to replace a data structure with an object and change all references to
    it. Therefore, it is important to decide from the outset if the data is just data,
    or if it is an object in disguise. Once that design decision is made, the rest
    of the design naturally falls into place.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将属性分组在一起，我们可以将它们存储在一个空对象中。但是，通常最好使用其他专门用于存储数据的内置对象。本书始终强调，只有在想要指定*数据和行为*时才应该使用类和对象。创建一个空类的主要原因是为了快速地阻止某些东西，知道我们稍后会回来添加行为。将行为适应类要容易得多，而将数据结构替换为对象并更改所有引用则要困难得多。因此，重要的是从一开始就决定数据只是数据，还是伪装成对象。一旦做出了这个设计决定，其余的设计自然而然地就会落实。
- en: Tuples and named tuples
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组和命名元组
- en: Tuples are objects that can store a specific number of other objects in order.
    They are immutable, so we can't add, remove, or replace objects on the fly. This
    may seem like a massive restriction, but the truth is, if you need to modify a
    tuple, you're using the wrong data type (usually a list would be more suitable).
    The primary benefit of tuples' immutability is that we can use them as keys in
    dictionaries, and in other locations where an object requires a hash value.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是可以按顺序存储特定数量的其他对象的对象。它们是不可变的，因此我们无法在运行时添加、删除或替换对象。这可能看起来像是一个巨大的限制，但事实是，如果你需要修改一个元组，你正在使用错误的数据类型（通常列表更合适）。元组不可变的主要好处是我们可以将它们用作字典中的键，以及其他需要哈希值的对象的位置。
- en: Tuples are used to store data; behavior cannot be stored in a tuple. If we require
    behavior to manipulate a tuple, we have to pass the tuple into a function (or
    method on another object) that performs the action.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 元组用于存储数据；无法在元组中存储行为。如果我们需要行为来操作元组，我们必须将元组传递给执行该操作的函数（或另一个对象的方法）。
- en: Tuples should generally store values that are somehow different from each other.
    For example, we would not put three stock symbols in a tuple, but we might create
    a tuple of stock symbol, current price, high, and low for the day. The primary
    purpose of a tuple is to aggregate different pieces of data together into one
    container. Thus, a tuple can be the easiest tool to replace the "object with no
    data" idiom.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 元组通常应该存储一些在某种程度上不同的值。例如，我们不会在一个元组中放入三个股票符号，但我们可能会创建一个包含股票符号、当前价格、最高价和最低价的元组。元组的主要目的是将不同的数据片段聚合到一个容器中。因此，元组可能是最简单的工具，用来替换“没有数据的对象”习语。
- en: 'We can create a tuple by separating the values with a comma. Usually, tuples
    are wrapped in parentheses to make them easy to read and to separate them from
    other parts of an expression, but this is not always mandatory. The following
    two assignments are identical (they record a stock, the current price, the high,
    and the low for a rather profitable company):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过用逗号分隔值来创建一个元组。通常，元组用括号括起来，以使它们易于阅读并与表达式的其他部分分开，但这并不总是强制性的。以下两个赋值是相同的（它们记录了一家相当有利可图的公司的股票、当前价格、最高价和最低价）：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we''re grouping a tuple inside of some other object, such as a function
    call, list comprehension, or generator, the parentheses are required. Otherwise,
    it would be impossible for the interpreter to know whether it is a tuple or the
    next function parameter. For example, the following function accepts a tuple and
    a date, and returns a tuple of the date and the middle value between the stock''s
    high and low value:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将元组分组到其他对象中，比如函数调用、列表推导或生成器中，括号是必需的。否则，解释器将无法知道它是一个元组还是下一个函数参数。例如，以下函数接受一个元组和一个日期，并返回一个包含日期和股票最高价和最低价之间的中间值的元组：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The tuple is created directly inside the function call by separating the values
    with commas and enclosing the entire tuple in parenthesis. This tuple is then
    followed by a comma to separate it from the second argument.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是直接在函数调用中通过用逗号分隔值并将整个元组括在括号中创建的。然后，这个元组后面跟着一个逗号，以将它与第二个参数分开。
- en: This example also illustrates tuple unpacking. The first line inside the function
    unpacks the `stock` parameter into four different variables. The tuple has to
    be exactly the same length as the number of variables, or it will raise an exception.
    We can also see an example of tuple unpacking on the last line, where the tuple
    returned inside the function is unpacked into two values, `mid_value` and `date`.
    Granted, this is a strange thing to do, since we supplied the date to the function
    in the first place, but it gave us a chance to see unpacking at work.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子也说明了元组的解包。函数内的第一行将`stock`参数解包成四个不同的变量。元组的长度必须与变量的数量完全相同，否则会引发异常。我们还可以在最后一行看到元组解包的例子，其中函数内返回的元组被解包成两个值，`mid_value`和`date`。当然，这是一个奇怪的做法，因为我们首先向函数提供了日期，但这让我们有机会看到解包的工作原理。
- en: 'Unpacking is a very useful feature in Python. We can group variables together
    to make storing and passing them around simpler, but the moment we need to access
    all of them, we can unpack them into separate variables. Of course, sometimes
    we only need access to one of the variables in the tuple. We can use the same
    syntax that we use for other sequence types (lists and strings, for example) to
    access an individual value:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，解包是一个非常有用的功能。我们可以将变量组合在一起，使得存储和传递它们变得更简单，但是当我们需要访问它们所有时，我们可以将它们解包成单独的变量。当然，有时我们只需要访问元组中的一个变量。我们可以使用与其他序列类型（例如列表和字符串）相同的语法来访问单个值：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can even use slice notation to extract larger pieces of tuples:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以使用切片表示法来提取元组的较大部分：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'These examples, while illustrating how flexible tuples can be, also demonstrate
    one of their major disadvantages: readability. How does someone reading this code
    know what is in the second position of a specific tuple? They can guess, from
    the name of the variable we assigned it to, that it is `high` of some sort, but
    if we had just accessed the tuple value in a calculation without assigning it,
    there would be no such indication. They would have to paw through the code to
    find where the tuple was declared before they could discover what it does.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子展示了元组的灵活性，但也展示了它们的一个主要缺点：可读性。阅读这段代码的人怎么知道特定元组的第二个位置是什么？他们可以猜测，从我们分配给它的变量名，它是某种“高”，但如果我们在计算中只是访问了元组的值而没有分配它，就没有这样的指示。他们必须在代码中搜索元组声明的位置，然后才能发现它的作用。
- en: Accessing tuple members directly is fine in some circumstances, but don't make
    a habit of it. Such so-called "magic numbers" (numbers that seem to come out of
    thin air with no apparent meaning within the code) are the source of many coding
    errors and lead to hours of frustrated debugging. Try to use tuples only when
    you know that all the values are going to be useful at once and it's normally
    going to be unpacked when it is accessed. If you have to access a member directly
    or using a slice and the purpose of that value is not immediately obvious, at
    least include a comment explaining where it came from.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 直接访问元组成员在某些情况下是可以的，但不要养成这样的习惯。这种所谓的“魔术数字”（似乎毫无意义地出现在代码中的数字）是许多编码错误的根源，并导致了数小时的沮丧调试。尽量只在你知道所有的值一次性都会有用，并且在访问时通常会被解包时使用元组。如果必须直接访问成员或使用切片，并且该值的目的不是立即明显的，至少要包含一个解释它来自哪里的注释。
- en: Named tuples
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名元组
- en: So, what do we do when we want to group values together, but know we're frequently
    going to need to access them individually? Well, we could use an empty object,
    as discussed in the previous section (but that is rarely useful unless we anticipate
    adding behavior later), or we could use a dictionary (most useful if we don't
    know exactly how many or which specific data will be stored), as we'll cover in
    the next section.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，当我们想要将值组合在一起，但知道我们经常需要单独访问它们时，我们该怎么办？嗯，我们可以使用空对象，如前一节中讨论的（但除非我们预期稍后添加行为，否则很少有用），或者我们可以使用字典（如果我们不知道将存储多少个或哪些特定数据，这是最有用的），我们将在下一节中介绍。
- en: If, however, we do not need to add behavior to the object, and we know in advance
    what attributes we need to store, we can use a named tuple. Named tuples are tuples
    with attitude. They are a great way to group read-only data together.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们不需要向对象添加行为，并且事先知道需要存储哪些属性，我们可以使用命名元组。命名元组是带有态度的元组。它们是将只读数据组合在一起的绝佳方式。
- en: 'Constructing a named tuple takes a bit more work than a normal tuple. First,
    we have to import `namedtuple`, as it is not in the namespace by default. Then,
    we describe the named tuple by giving it a name and outlining its attributes.
    This returns a class-like object that we can instantiate with the required values
    as many times as we want:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 构造命名元组比普通元组需要更多的工作。首先，我们必须导入`namedtuple`，因为它不是默认的命名空间中。然后，我们通过给它一个名称并概述其属性来描述命名元组。这将返回一个类似的对象，我们可以根据需要实例化多次：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `namedtuple` constructor accepts two arguments. The first is an identifier
    for the named tuple. The second is a string of space-separated attributes that
    the named tuple can have. The first attribute should be listed, followed by a
    space (or comma if you prefer), then the second attribute, then another space,
    and so on. The result is an object that can be called just like a normal class
    to instantiate other objects. The constructor must have exactly the right number
    of arguments that can be passed in as arguments or keyword arguments. As with
    normal objects, we can create as many instances of this "class" as we like, with
    different values for each.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`namedtuple`构造函数接受两个参数。第一个是命名元组的标识符。第二个是命名元组可以具有的以空格分隔的属性字符串。应该列出第一个属性，然后是一个空格（或者如果你喜欢，逗号），然后是第二个属性，然后是另一个空格，依此类推。结果是一个可以像普通类一样调用的对象，以实例化其他对象。构造函数必须具有可以作为参数或关键字参数传递的恰好正确数量的参数。与普通对象一样，我们可以创建任意数量的此“类”的实例，并为每个实例提供不同的值。'
- en: 'The resulting `namedtuple` can then be packed, unpacked, and otherwise treated
    like a normal tuple, but we can also access individual attributes on it as if
    it were an object:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，生成的`namedtuple`可以像普通元组一样打包、解包和以其他方式处理，但我们也可以像访问对象一样访问它的单个属性：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember that creating named tuples is a two-step process. First, use `collections.namedtuple`
    to create a class, and then construct instances of that class.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，创建命名元组是一个两步过程。首先，使用`collections.namedtuple`创建一个类，然后构造该类的实例。
- en: 'Named tuples are perfect for many "data only" representations, but they are
    not ideal for all situations. Like tuples and strings, named tuples are immutable,
    so we cannot modify an attribute once it has been set. For example, the current
    value of my company''s stock has gone down since we started this discussion, but
    we can''t set the new value:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 命名元组非常适合许多“仅数据”表示，但并非适用于所有情况。与元组和字符串一样，命名元组是不可变的，因此一旦设置了属性，就无法修改属性。例如，自从我们开始讨论以来，我的公司股票的当前价值已经下跌，但我们无法设置新值：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If we need to be able to change stored data, a dictionary may be what we need
    instead.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要能够更改存储的数据，可能需要使用字典。
- en: Dictionaries
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字典
- en: Dictionaries are incredibly useful containers that allow us to map objects directly
    to other objects. An empty object with attributes to it is a sort of dictionary;
    the names of the properties map to the property values. This is actually closer
    to the truth than it sounds; internally, objects normally represent attributes
    as a dictionary, where the values are properties or methods on the objects (see
    the `__dict__` attribute if you don't believe me). Even the attributes on a module
    are stored, internally, in a dictionary.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是非常有用的容器，允许我们直接将对象映射到其他对象。具有属性的空对象是一种字典；属性的名称映射到属性值。这实际上比听起来更接近事实；在内部，对象通常将属性表示为字典，其中值是对象上的属性或方法（如果你不相信我，请查看`__dict__`属性）。甚至模块上的属性也是在字典中存储的。
- en: Dictionaries are extremely efficient at looking up a value, given a specific
    key object that maps to that value. They should always be used when you want to
    find one object based on some other object. The object that is being stored is
    called the **value**; the object that is being used as an index is called the
    **key**. We've already seen dictionary syntax in some of our previous examples.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 字典在查找特定键对象映射到该值时非常高效。当您想要根据其他对象找到一个对象时，应该始终使用它们。被存储的对象称为**值**；用作索引的对象称为**键**。我们已经在一些先前的示例中看到了字典语法。
- en: Dictionaries can be created either using the `dict()` constructor or using the
    `{}` syntax shortcut. In practice, the latter format is almost always used. We
    can prepopulate a dictionary by separating the keys from the values using a colon,
    and separating the key value pairs using a comma.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 字典可以使用`dict()`构造函数或使用`{}`语法快捷方式创建。实际上，几乎总是使用后一种格式。我们可以通过使用冒号分隔键和值，并使用逗号分隔键值对来预填充字典。
- en: 'For example, in a stock application, we would most often want to look up prices
    by the stock symbol. We can create a dictionary that uses stock symbols as keys,
    and tuples of current, high, and low as values like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在股票应用程序中，我们最常常希望按股票符号查找价格。我们可以创建一个使用股票符号作为键，当前价格、最高价格和最低价格的元组作为值的字典，如下所示：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As we''ve seen in previous examples, we can then look up values in the dictionary
    by requesting a key inside square brackets. If the key is not in the dictionary,
    it will raise an exception:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的例子中看到的，我们可以通过在方括号内请求一个键来查找字典中的值。如果键不在字典中，它会引发一个异常：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can, of course, catch the `KeyError` and handle it. But we have other options.
    Remember, dictionaries are objects, even if their primary purpose is to hold other
    objects. As such, they have several behaviors associated with them. One of the
    most useful of these methods is the `get` method; it accepts a key as the first
    parameter and an optional default value if the key doesn''t exist:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以捕获`KeyError`并处理它。但我们还有其他选择。记住，字典是对象，即使它们的主要目的是保存其他对象。因此，它们有几种与之相关的行为。其中最有用的方法之一是`get`方法；它接受一个键作为第一个参数，以及一个可选的默认值（如果键不存在）：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For even more control, we can use the `setdefault` method. If the key is in
    the dictionary, this method behaves just like `get`; it returns the value for
    that key. Otherwise, if the key is not in the dictionary, it will not only return
    the default value we supply in the method call (just like `get` does), it will
    also set the key to that same value. Another way to think of it is that `setdefault`
    sets a value in the dictionary only if that value has not previously been set.
    Then it returns the value in the dictionary, either the one that was already there,
    or the newly provided default value.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更多的控制，我们可以使用`setdefault`方法。如果键在字典中，这个方法的行为就像`get`一样；它返回该键的值。否则，如果键不在字典中，它不仅会返回我们在方法调用中提供的默认值（就像`get`一样），它还会将键设置为相同的值。另一种思考方式是，`setdefault`只有在该值以前没有被设置时才在字典中设置一个值。然后它返回字典中的值，无论是已经存在的值，还是新提供的默认值。
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `GOOG` stock was already in the dictionary, so when we tried to `setdefault`
    it to an invalid value, it just returned the value already in the dictionary.
    `BBRY` was not in the dictionary, so `setdefault` returned the default value and
    set the new value in the dictionary for us. We then check that the new stock is,
    indeed, in the dictionary.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`GOOG`股票已经在字典中，所以当我们尝试将其`setdefault`为一个无效值时，它只是返回了已经在字典中的值。`BBRY`不在字典中，所以`setdefault`返回了默认值，并为我们在字典中设置了新值。然后我们检查新的股票是否确实在字典中。'
- en: 'Three other very useful dictionary methods are `keys()`, `values()`, and `items()`.
    The first two return an iterator over all the keys and all the values in the dictionary.
    We can use these like lists or in `for` loops if we want to process all the keys
    or values. The `items()` method is probably the most useful; it returns an iterator
    over tuples of `(key, value)` pairs for every item in the dictionary. This works
    great with tuple unpacking in a `for` loop to loop over associated keys and values.
    This example does just that to print each stock in the dictionary with its current
    value:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 另外三个非常有用的字典方法是`keys()`，`values()`和`items()`。前两个返回字典中所有键和所有值的迭代器。如果我们想要处理所有键或值，我们可以像列表一样使用它们，或者在`for`循环中使用它们。`items()`方法可能是最有用的；它返回一个元组的迭代器，其中包含字典中每个项目的`(key,
    value)`对。这与在`for`循环中使用元组解包很好地配合，以循环遍历相关的键和值。这个例子就是这样做的，以打印出字典中每个股票及其当前值：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Each key/value tuple is unpacked into two variables named `stock` and `values`
    (we could use any variable names we wanted, but these both seem appropriate) and
    then printed in a formatted string.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 每个键/值元组都被解包成两个名为`stock`和`values`的变量（我们可以使用任何我们想要的变量名，但这两个似乎都合适），然后以格式化的字符串打印出来。
- en: Notice that the stocks do not show up in the same order in which they were inserted.
    Dictionaries, due to the efficient algorithm (known as hashing) that is used to
    make key lookup so fast, are inherently unsorted.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，股票并没有按照插入的顺序显示出来。由于用于使键查找如此快速的高效算法（称为哈希），字典本身是无序的。
- en: So, there are numerous ways to retrieve data from a dictionary once it has been
    instantiated; we can use square brackets as index syntax, the `get` method, the
    `setdefault` method, or iterate over the `items` method, among others.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦字典被实例化，就有许多种方法可以从中检索数据；我们可以使用方括号作为索引语法，`get`方法，`setdefault`方法，或者遍历`items`方法，等等。
- en: 'Finally, as you likely already know, we can set a value in a dictionary using
    the same indexing syntax we use to retrieve a value:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可能已经知道，我们可以使用与检索值相同的索引语法来在字典中设置一个值：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Google's price is lower today, so I've updated the tuple value in the dictionary.
    We can use this index syntax to set a value for any key, regardless of whether
    the key is in the dictionary. If it is in the dictionary, the old value will be
    replaced with the new one; otherwise, a new key/value pair will be created.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌的价格今天较低，所以我更新了字典中元组的值。我们可以使用这种索引语法为任何键设置一个值，而不管该键是否在字典中。如果它在字典中，旧值将被新值替换；否则，将创建一个新的键/值对。
- en: 'We''ve been using strings as dictionary keys, so far, but we aren''t limited
    to string keys. It is common to use strings as keys, especially when we''re storing
    data in a dictionary to gather it together (instead of using an object with named
    properties). But we can also use tuples, numbers, or even objects we''ve defined
    ourselves as dictionary keys. We can even use different types of keys in a single
    dictionary:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用字符串作为字典的键，但我们并不局限于字符串键。通常在存储数据以便将其聚集在一起时，使用字符串作为键是很常见的（而不是使用具有命名属性的对象）。但我们也可以使用元组、数字，甚至是我们自己定义的对象作为字典的键。我们甚至可以在单个字典中使用不同类型的键：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This code shows several different types of keys we can supply to a dictionary.
    It also shows one type of object that cannot be used. We've already used lists
    extensively, and we'll be seeing many more details of them in the next section.
    Because lists can change at any time (by adding or removing items, for example),
    they cannot hash to a specific value.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了我们可以提供给字典的几种不同类型的键。它还展示了一种不能使用的对象类型。我们已经广泛使用了列表，并且在下一节中将看到更多关于它们的细节。因为列表可以随时更改（例如通过添加或删除项目），它们无法哈希到一个特定的值。
- en: Objects that are **hashable** basically have a defined algorithm that converts
    the object into a unique integer value for rapid lookup. This hash is what is
    actually used to look up values in a dictionary. For example, strings map to integers
    based on the characters in the string, while tuples combine hashes of the items
    inside the tuple. Any two objects that are somehow considered equal (like strings
    with the same characters or tuples with the same values) should have the same
    hash value, and the hash value for an object should never ever change. Lists,
    however, can have their contents changed, which would change their hash value
    (two lists should only be equal if their contents are the same). Because of this,
    they can't be used as dictionary keys. For the same reason, dictionaries cannot
    be used as keys into other dictionaries.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 具有**可哈希性**的对象基本上具有一个定义好的算法，将对象转换为唯一的整数值，以便快速查找。这个哈希值实际上是用来在字典中查找值的。例如，字符串根据字符串中的字符映射到整数，而元组则组合了元组内部项目的哈希值。任何两个被视为相等的对象（比如具有相同字符的字符串或具有相同值的元组）应该具有相同的哈希值，并且对象的哈希值永远不应该改变。然而，列表的内容可以改变，这会改变它们的哈希值（只有当列表的内容相同时，两个列表才应该相等）。因此，它们不能用作字典的键。出于同样的原因，字典也不能用作其他字典的键。
- en: In contrast, there are no limits on the types of objects that can be used as
    dictionary values. We can use a string key that maps to a list value, for example,
    or we can have a nested dictionary as a value in another dictionary.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，对于可以用作字典值的对象类型没有限制。例如，我们可以使用字符串键映射到列表值，或者我们可以在另一个字典中将嵌套字典作为值。
- en: Dictionary use cases
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字典的用例
- en: Dictionaries are extremely versatile and have numerous uses. There are two major
    ways that dictionaries can be used. The first is dictionaries where all the keys
    represent different instances of similar objects; for example, our stock dictionary.
    This is an indexing system. We use the stock symbol as an index to the values.
    The values could even have been complicated self-defined objects that made buy
    and sell decisions or set a stop-loss, rather than our simple tuples.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 字典非常灵活，有很多用途。字典可以有两种主要用法。第一种是所有键表示类似对象的不同实例的字典；例如，我们的股票字典。这是一个索引系统。我们使用股票符号作为值的索引。这些值甚至可以是复杂的自定义对象，而不是我们简单的元组。
- en: The second design is dictionaries where each key represents some aspect of a
    single structure; in this case, we'd probably use a separate dictionary for each
    object, and they'd all have similar (though often not identical) sets of keys.
    This latter situation can often also be solved with named tuples. These should
    typically be used when we know exactly what attributes the data must store, and
    we know that all pieces of the data must be supplied at once (when the item is
    constructed). But if we need to create or change dictionary keys over time or
    we don't know exactly what the keys might be, a dictionary is more suitable.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种设计是每个键表示单个结构的某个方面的字典；在这种情况下，我们可能会为每个对象使用一个单独的字典，并且它们都具有相似（尽管通常不完全相同）的键集。这种情况通常也可以用命名元组解决。当我们确切地知道数据必须存储的属性，并且知道所有数据必须一次性提供（在构造项目时）时，应该使用这些。但是，如果我们需要随时间创建或更改字典键，或者我们不知道键可能是什么，那么字典更合适。
- en: Using defaultdict
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用defaultdict
- en: 'We''ve seen how to use `setdefault` to set a default value if a key doesn''t
    exist, but this can get a bit monotonous if we need to set a default value every
    time we look up a value. For example, if we''re writing code that counts the number
    of times a letter occurs in a given sentence, we could do this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用`setdefault`来设置默认值，如果键不存在，但是如果我们需要每次查找值时都设置默认值，这可能会有点单调。例如，如果我们正在编写代码来计算给定句子中字母出现的次数，我们可以这样做：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Every time we access the dictionary, we need to check that it has a value already,
    and if not, set it to zero. When something like this needs to be done every time
    an empty key is requested, we can use a different version of the dictionary, called
    `defaultdict`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 每次访问字典时，我们需要检查它是否已经有一个值，如果没有，将其设置为零。当每次请求一个空键时需要做这样的事情时，我们可以使用字典的另一个版本，称为`defaultdict`：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This code looks like it couldn't possibly work. The `defaultdict` accepts a
    function in its constructor. Whenever a key is accessed that is not already in
    the dictionary, it calls that function, with no parameters, to create a default
    value.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来似乎不可能工作。`defaultdict`在其构造函数中接受一个函数。每当访问一个不在字典中的键时，它调用该函数，不带任何参数，以创建一个默认值。
- en: In this case, the function it calls is `int`, which is the constructor for an
    integer object. Normally, integers are created simply by typing an integer number
    into our code, and if we do create one using the `int` constructor, we pass it
    the item we want to create (for example, to convert a string of digits into an
    integer). But if we call `int` without any arguments, it returns, conveniently,
    the number zero. In this code, if the letter doesn't exist in the `defaultdict`,
    the number zero is returned when we access it. Then we add one to this number
    to indicate we've found an instance of that letter, and the next time we find
    one, that number will be returned and we can increment the value again.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，它调用的函数是`int`，这是整数对象的构造函数。通常，整数是通过在代码中键入整数来创建的，如果我们使用`int`构造函数创建一个整数，我们将传递要创建的项目（例如，将数字字符串转换为整数）。但是，如果我们在没有任何参数的情况下调用`int`，它会方便地返回数字零。在这段代码中，如果字母不存在于`defaultdict`中，当我们访问它时将返回数字零。然后我们将这个数字加一，以表示我们找到了该字母的一个实例，下次再找到一个实例时，将返回该数字，然后我们可以再次递增该值。
- en: The `defaultdict` is useful for creating dictionaries of containers. If we want
    to create a dictionary of stock prices for the past 30 days, we could use a stock
    symbol as the key and store the prices in `list`; the first time we access the
    stock price, we would want it to create an empty list. Simply pass `list` into
    the `defaultdict`, and it will be called every time an empty key is accessed.
    We can do similar things with sets or even empty dictionaries if we want to associate
    one with a key.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultdict`对于创建容器字典非常有用。如果我们想要创建一个过去30天股票价格的字典，我们可以使用股票符号作为键，并将价格存储在`list`中；第一次访问股票价格时，我们希望它创建一个空列表。只需将`list`传递给`defaultdict`，它将在每次访问空键时被调用。如果我们想要将一个集合或者一个空字典与一个键关联起来，我们也可以做类似的事情。'
- en: 'Of course, we can also write our own functions and pass them into the `defaultdict`.
    Suppose we want to create a `defaultdict` where each new element contains a tuple
    of the number of items inserted into the dictionary at that time and an empty
    list to hold other things. Nobody knows why we would want to create such an object,
    but let''s have a look:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以编写自己的函数并将它们传递给`defaultdict`。假设我们想创建一个`defaultdict`，其中每个新元素都包含一个元组，该元组包含了在该时间插入字典中的项目数和一个空列表来保存其他东西。没有人知道为什么我们要创建这样一个对象，但让我们来看一下：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When we run this code, we can access empty keys and insert into the list all
    in one statement:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这段代码时，我们可以在一个语句中访问空键并插入列表：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When we print `dict` at the end, we see that the counter really was working.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在最后打印`dict`时，我们看到计数器确实在工作。
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This example, while succinctly demonstrating how to create our own function
    for `defaultdict`, is not actually very good code; using a global variable means
    that if we created four different `defaultdict` segments that each used `tuple_counter`,
    it would count the number of entries in all dictionaries, rather than having a
    different count for each one. It would be better to create a class and pass a
    method on that class to `defaultdict`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子虽然简洁地演示了如何为`defaultdict`创建自己的函数，但实际上并不是很好的代码；使用全局变量意味着如果我们创建了四个不同的`defaultdict`段，每个段都使用了`tuple_counter`，它将计算所有字典中的条目数，而不是为每个字典单独计数。最好创建一个类，并将该类的方法传递给`defaultdict`。
- en: Counter
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计数器
- en: 'You''d think that you couldn''t get much simpler than `defaultdict(int)`, but
    the "I want to count specific instances in an iterable" use case is common enough
    that the Python developers created a specific class for it. The previous code
    that counts characters in a string can easily be calculated in a single line:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会认为`defaultdict(int)`比这更简单，但“我想要计算可迭代对象中特定实例的数量”这种用例是足够常见，以至于Python开发人员为此创建了一个特定的类。在一个单行中很容易计算以前的代码中字符串中的字符数量：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `Counter` object behaves like a beefed up dictionary where the keys are
    the items being counted and the values are the number of such items. One of the
    most useful functions is the `most_common()` method. It returns a list of (key,
    count) tuples ordered by the count. You can optionally pass an integer argument
    into `most_common()` to request only the top most common elements. For example,
    you could write a simple polling application as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Counter`对象的行为类似于一个强化的字典，其中键是被计数的项目，值是这些项目的数量。其中最有用的函数之一是`most_common()`方法。它返回一个按计数排序的（键，计数）元组列表。您还可以选择将整数参数传递给`most_common()`，以请求仅返回最常见的元素。例如，您可以编写一个简单的投票应用程序如下：'
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Presumably, you'd get the responses from a database or by using a complicated
    vision algorithm to count the kids who raised their hands. Here, we hardcode it
    so that we can test the `most_common` method. It returns a list that has only
    one element (because we requested one element in the parameter). This element
    stores the name of the top choice at position zero, hence the double `[0][0]`
    at the end of the call. I think they look like a surprised face, don't you? Your
    computer is probably amazed it can count data so easily. It's ancestor, Hollerith's
    Tabulating Machine for the 1890 US census, must be so jealous!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 据推测，您可以从数据库中获取响应，或者使用复杂的视觉算法来计算举手的孩子。在这里，我们将其硬编码，以便我们可以测试`most_common`方法。它返回一个只有一个元素的列表（因为我们在参数中请求了一个元素）。这个元素在位置零存储了最受欢迎的选择的名称，因此在调用结束时有两个`[0][0]`。我觉得它们看起来像是一个惊讶的脸，你觉得呢？你的计算机可能对它能够如此轻松地计数数据感到惊讶。它的祖先，霍勒里斯的1890年美国人口普查用的整理机，一定会非常嫉妒！
- en: Lists
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: Lists are the least object-oriented of Python's data structures. While lists
    are, themselves, objects, there is a lot of syntax in Python to make using them
    as painless as possible. Unlike many other object-oriented languages, lists in
    Python are simply available. We don't need to import them and rarely need to call
    methods on them. We can loop over a list without explicitly requesting an iterator
    object, and we can construct a list (as with a dictionary) with custom syntax.
    Further, list comprehensions and generator expressions turn them into a veritable
    Swiss-army knife of computing functionality.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是Python数据结构中最不面向对象的。虽然列表本身是对象，但在Python中有很多语法可以尽可能地减少它们的使用痛苦。与许多其他面向对象的语言不同，Python中的列表是直接可用的。我们不需要导入它们，也很少需要调用它们的方法。我们可以在不明确请求迭代器对象的情况下循环遍历列表，并且可以使用自定义语法构造列表（与字典一样）。此外，列表推导和生成器表达式将它们转变为计算功能的多功能工具。
- en: We won't go into too much detail of the syntax; you've seen it in introductory
    tutorials across the Web and in previous examples in this book. You can't code
    Python very long without learning how to use lists! Instead, we'll be covering
    when lists should be used, and their nature as objects. If you don't know how
    to create or append to a list, how to retrieve items from a list, or what "slice
    notation" is, I direct you to the official Python tutorial, post-haste. It can
    be found online at [http://docs.python.org/3/tutorial/](http://docs.python.org/3/tutorial/).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会过多介绍语法；你在网络上的入门教程和本书中的先前示例中已经见过它。你不能长时间编写Python代码而不学会如何使用列表！相反，我们将介绍何时应该使用列表以及它们作为对象的性质。如果你不知道如何创建或附加到列表，如何从列表中检索项目，或者什么是“切片表示法”，我建议你立即查看官方Python教程。它可以在[http://docs.python.org/3/tutorial/](http://docs.python.org/3/tutorial/)上找到。
- en: In Python, lists should normally be used when we want to store several instances
    of the "same" type of object; lists of strings or lists of numbers; most often,
    lists of objects we've defined ourselves. Lists should always be used when we
    want to store items in some kind of order. Often, this is the order in which they
    were inserted, but they can also be sorted by some criteria.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，当我们想要存储“相同”类型的对象的多个实例时，通常应该使用列表；字符串列表或数字列表；最常见的是我们自己定义的对象列表。当我们想要按某种顺序存储项目时，应该始终使用列表。通常，这是它们被插入的顺序，但它们也可以按某些标准排序。
- en: 'As we saw in the case study from the previous chapter, lists are also very
    useful when we need to modify the contents: insert to or delete from an arbitrary
    location of the list, or update a value within the list.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章的案例研究中看到的，当我们需要修改内容时，列表也非常有用：在列表的任意位置插入或删除，或者更新列表中的值。
- en: Like dictionaries, Python lists use an extremely efficient and well-tuned internal
    data structure so we can worry about what we're storing, rather than how we're
    storing it. Many object-oriented languages provide different data structures for
    queues, stacks, linked lists, and array-based lists. Python does provide special
    instances of some of these classes, if optimizing access to huge sets of data
    is required. Normally, however, the list data structure can serve all these purposes
    at once, and the coder has complete control over how they access it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 与字典一样，Python列表使用非常高效和良好调整的内部数据结构，因此我们可以关注我们存储的内容，而不是我们如何存储它。许多面向对象的语言为队列、栈、链表和基于数组的列表提供了不同的数据结构。如果需要优化对大量数据的访问，Python确实提供了这些类的特殊实例。然而，通常情况下，列表数据结构可以同时满足所有这些目的，并且编码人员可以完全控制他们如何访问它。
- en: Don't use lists for collecting different attributes of individual items. We
    do not want, for example, a list of the properties a particular shape has. Tuples,
    named tuples, dictionaries, and objects would all be more suitable for this purpose.
    In some languages, they might create a list in which each alternate item is a
    different type; for example, they might write `['a', 1, 'b', 3]` for our letter
    frequency list. They'd have to use a strange loop that accesses two elements in
    the list at once or a modulus operator to determine which position was being accessed.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用列表来收集单个项目的不同属性。例如，我们不希望一个特定形状的属性列表。元组、命名元组、字典和对象都更适合这个目的。在某些语言中，它们可能创建一个列表，其中每个交替项是不同的类型；例如，他们可能为我们的字母频率列表写`['a',
    1, 'b', 3]`。他们必须使用一个奇怪的循环，一次访问两个元素，或者使用模运算符来确定正在访问的位置。
- en: 'Don''t do this in Python. We can group related items together using a dictionary,
    as we did in the previous section (if sort order doesn''t matter), or using a
    list of tuples. Here''s a rather convoluted example that demonstrates how we could
    do the frequency example using a list. It is much more complicated than the dictionary
    examples, and illustrates the effect choosing the right (or wrong) data structure
    can have on the readability of our code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中不要这样做。我们可以使用字典将相关项目分组在一起，就像我们在上一节中所做的那样（如果排序顺序不重要），或者使用元组列表。下面是一个相当复杂的示例，演示了我们如何使用列表来进行频率示例。它比字典示例复杂得多，并且说明了选择正确（或错误）的数据结构对我们代码的可读性产生的影响。
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This code starts with a list of possible characters. The `string.ascii_letters`
    attribute provides a string of all the letters, lowercase and uppercase, in order.
    We convert this to a list, and then use list concatenation (the plus operator
    causes two lists to be merged into one) to add one more character, the space.
    These are the available characters in our frequency list (the code would break
    if we tried to add a letter that wasn't in the list, but an exception handler
    could solve this).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码以可能的字符列表开始。`string.ascii_letters`属性提供了一个按顺序排列的所有字母（大写和小写）的字符串。我们将其转换为列表，然后使用列表连接（加号运算符将两个列表合并为一个）添加一个额外的字符，即空格。这些是我们频率列表中可用的字符（如果我们尝试添加不在列表中的字母，代码将会出错，但可以使用异常处理程序来解决这个问题）。
- en: The first line inside the function uses a list comprehension to turn the `CHARACTERS`
    list into a list of tuples. List comprehensions are an important, non-object-oriented
    tool in Python; we'll be covering them in detail in the next chapter.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 函数内的第一行使用列表推导将`CHARACTERS`列表转换为元组列表。列表推导是Python中一个重要的非面向对象的工具；我们将在下一章详细介绍它们。
- en: Then we loop over each of the characters in the sentence. We first look up the
    index of the character in the `CHARACTERS` list, which we know has the same index
    in our frequencies list, since we just created the second list from the first.
    We then update that index in the frequencies list by creating a new tuple, discarding
    the original one. Aside from the garbage collection and memory waste concerns,
    this is rather difficult to read!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们循环遍历句子中的每个字符。我们首先查找`CHARACTERS`列表中字符的索引，我们知道它在我们的频率列表中具有相同的索引，因为我们刚刚从第一个列表创建了第二个列表。然后我们通过创建一个新元组来更新频率列表中的索引，丢弃原始元组。除了垃圾收集和内存浪费的担忧外，这是相当难以阅读的！
- en: 'Like dictionaries, lists are objects too, and they have several methods that
    can be invoked upon them. Here are some common ones:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 像字典一样，列表也是对象，并且有几种可以在它们上调用的方法。以下是一些常见的方法：
- en: The `append(element)` method adds an element to the end of the list
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`append(element)`方法将一个元素添加到列表的末尾'
- en: The `insert(index, element)` method inserts an item at a specific position
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`insert(index, element)`方法在特定位置插入一个项目'
- en: The `count(element)` method tells us how many times an element appears in the
    list
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count(element)`方法告诉我们一个元素在列表中出现了多少次'
- en: The `index()`method tells us the index of an item in the list, raising an exception
    if it can't find it
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index()`方法告诉我们列表中项目的索引，如果找不到它会引发异常'
- en: The `find()`method does the same thing, but returns `-1` instead of raising
    an exception for missing items
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find()`方法也是做同样的事情，但是找不到项目时返回`-1`而不是引发异常'
- en: The `reverse()` method does exactly what it says—turns the list around
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reverse()`方法确实做了它所说的事情——将列表倒转过来'
- en: The `sort()` method has some rather intricate object-oriented behaviors, which
    we'll cover now
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort()`方法具有一些相当复杂的面向对象的行为，我们现在来介绍一下'
- en: Sorting lists
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序列表
- en: Without any parameters, `sort` will generally do the expected thing. If it's
    a list of strings, it will place them in alphabetical order. This operation is
    case sensitive, so all capital letters will be sorted before lowercase letters,
    that is `Z` comes before `a`. If it is a list of numbers, they will be sorted
    in numerical order. If a list of tuples is provided, the list is sorted by the
    first element in each tuple. If a mixture containing unsortable items is supplied,
    the sort will raise a `TypeError` exception.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何参数时，`sort`通常会做预期的事情。如果是字符串列表，它会按字母顺序排列。这个操作是区分大小写的，所以所有大写字母会排在小写字母之前，即`Z`排在`a`之前。如果是数字列表，它们将按数字顺序排序。如果提供了一个包含不可排序项目的混合列表，排序将引发`TypeError`异常。
- en: 'If we want to place objects we define ourselves into a list and make those
    objects sortable, we have to do a bit more work. The special method `__lt__`,
    which stands for "less than", should be defined on the class to make instances
    of that class comparable. The `sort` method on list will access this method on
    each object to determine where it goes in the list. This method should return
    `True` if our class is somehow less than the passed parameter, and `False` otherwise.
    Here''s a rather silly class that can be sorted based on either a string or a
    number:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想把自己定义的对象放入列表并使这些对象可排序，我们需要做更多的工作。类上应该定义特殊方法`__lt__`，它代表“小于”，以使该类的实例可比较。列表上的`sort`方法将访问每个对象上的这个方法来确定它在列表中的位置。如果我们的类在某种程度上小于传递的参数，则该方法应返回`True`，否则返回`False`。下面是一个相当愚蠢的类，它可以根据字符串或数字进行排序：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `__repr__` method makes it easy to see the two values when we print a list.
    The `__lt__` method''s implementation compares the object to another instance
    of the same class (or any duck typed object that has `string`, `number`, and `sort_num`
    attributes; it will fail if those attributes are missing). The following output
    illustrates this class in action, when it comes to sorting:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`__repr__`方法使我们在打印列表时很容易看到这两个值。`__lt__`方法的实现将对象与相同类的另一个实例（或具有`string`、`number`和`sort_num`属性的任何鸭子类型对象；如果这些属性缺失，它将失败）进行比较。以下输出展示了这个类在排序时的工作原理：'
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The first time we call `sort`, it sorts by numbers because `sort_num` is `True`
    on all the objects being compared. The second time, it sorts by letters. The `__lt__`
    method is the only one we need to implement to enable sorting. Technically, however,
    if it is implemented, the class should normally also implement the similar `__gt__`,
    `__eq__`, `__ne__`, `__ge__`, and `__le__` methods so that all of the `<`, `>`,
    `==`, `!=`, `>=`, and `<=` operators also work properly. You can get this for
    free by implementing `__lt__` and `__eq__`, and then applying the `@total_ordering`
    class decorator to supply the rest:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用`sort`时，它按数字排序，因为所有被比较的对象上的`sort_num`都是`True`。第二次，它按字母排序。我们只需要实现`__lt__`方法来启用排序。然而，从技术上讲，如果实现了它，类通常还应该实现类似的`__gt__`、`__eq__`、`__ne__`、`__ge__`和`__le__`方法，以便所有的`<`、`>`、`==`、`!=`、`>=`和`<=`操作符也能正常工作。通过实现`__lt__`和`__eq__`，然后应用`@total_ordering`类装饰器来提供其余的方法，你可以免费获得这些方法：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This is useful if we want to be able to use operators on our objects. However,
    if all we want to do is customize our sort orders, even this is overkill. For
    such a use case, the `sort` method can take an optional `key` argument. This argument
    is a function that can translate each object in a list into an object that can
    somehow be compared. For example, we can use `str.lower` as the key argument to
    perform a case-insensitive sort on a list of strings:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要能够在我们的对象上使用运算符，这是很有用的。然而，如果我们只想自定义我们的排序顺序，即使这样也是过度的。对于这样的用例，`sort`方法可以接受一个可选的`key`参数。这个参数是一个函数，可以将列表中的每个对象转换为某种可比较的对象。例如，我们可以使用`str.lower`作为键参数，在字符串列表上执行不区分大小写的排序：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Remember, even though `lower` is a method on string objects, it is also a function
    that can accept a single argument, `self`. In other words, `str.lower(item)` is
    equivalent to `item.lower()`. When we pass this function as a key, it performs
    the comparison on lowercase values instead of doing the default case-sensitive
    comparison.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，即使`lower`是字符串对象上的一个方法，它也是一个可以接受单个参数`self`的函数。换句话说，`str.lower(item)`等同于`item.lower()`。当我们将这个函数作为键传递时，它会对小写值进行比较，而不是进行默认的区分大小写比较。
- en: 'There are a few sort key operations that are so common that the Python team
    has supplied them so you don''t have to write them yourself. For example, it is
    often common to sort a list of tuples by something other than the first item in
    the list. The `operator.itemgetter` method can be used as a key to do this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些排序键操作是如此常见，以至于Python团队已经提供了它们，这样你就不必自己编写了。例如，通常常见的是按列表中的第一个项目之外的其他内容对元组列表进行排序。`operator.itemgetter`方法可以用作键来实现这一点：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `itemgetter` function is the most commonly used one (it works if the objects
    are dictionaries, too), but you will sometimes find use for `attrgetter` and `methodcaller`,
    which return attributes on an object and the results of method calls on objects
    for the same purpose. See the `operator` module documentation for more information.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`itemgetter`函数是最常用的一个（如果对象是字典，它也可以工作），但有时你会发现`attrgetter`和`methodcaller`也很有用，它们返回对象的属性和对象的方法调用的结果，用于相同的目的。有关更多信息，请参阅`operator`模块文档。'
- en: Sets
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: Lists are extremely versatile tools that suit most container object applications.
    But they are not useful when we want to ensure objects in the list are unique.
    For example, a song library may contain many songs by the same artist. If we want
    to sort through the library and create a list of all the artists, we would have
    to check the list to see if we've added the artist already, before we add them
    again.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是非常多才多艺的工具，适用于大多数容器对象应用。但是当我们想要确保列表中的对象是唯一的时，它们就不太有用了。例如，歌曲库可能包含同一位艺术家的许多歌曲。如果我们想要整理库并创建所有艺术家的列表，我们必须检查列表，看看我们是否已经添加了艺术家，然后再添加他们。
- en: This is where sets come in. Sets come from mathematics, where they represent
    an unordered group of (usually) unique numbers. We can add a number to a set five
    times, but it will show up in the set only once.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是集合的用武之地。集合来自数学，它们代表一个无序的（通常是）唯一数字的组。我们可以将一个数字添加到集合五次，但它只会出现一次。
- en: 'In Python, sets can hold any hashable object, not just numbers. Hashable objects
    are the same objects that can be used as keys in dictionaries; so again, lists
    and dictionaries are out. Like mathematical sets, they can store only one copy
    of each object. So if we''re trying to create a list of song artists, we can create
    a set of string names and simply add them to the set. This example starts with
    a list of (song, artist) tuples and creates a set of the artists:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，集合可以容纳任何可散列的对象，不仅仅是数字。可散列的对象与字典中可以用作键的对象相同；所以再次，列表和字典都不行。像数学集合一样，它们只能存储每个对象的一个副本。因此，如果我们试图创建一个歌手名单，我们可以创建一个字符串名称的集合，并简单地将它们添加到集合中。这个例子从一个（歌曲，艺术家）元组列表开始，并创建了一个艺术家的集合：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'There is no built-in syntax for an empty set as there is for lists and dictionaries;
    we create a set using the `set()` constructor. However, we can use the curly braces
    (borrowed from dictionary syntax) to create a set, so long as the set contains
    values. If we use colons to separate pairs of values, it''s a dictionary, as in
    `{''key'': ''value'', ''key2'': ''value2''}`. If we just separate values with
    commas, it''s a set, as in `{''value'', ''value2''}`. Items can be added individually
    to the set using its `add` method. If we run this script, we see that the set
    works as advertised:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '与列表和字典一样，没有内置的空集语法；我们使用`set()`构造函数创建一个集合。然而，我们可以使用花括号（从字典语法中借用）来创建一个集合，只要集合包含值。如果我们使用冒号来分隔值对，那就是一个字典，比如`{''key'':
    ''value'', ''key2'': ''value2''}`。如果我们只用逗号分隔值，那就是一个集合，比如`{''value'', ''value2''}`。可以使用`add`方法将项目单独添加到集合中。如果运行此脚本，我们会看到集合按照广告中的方式工作：'
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you''re paying attention to the output, you''ll notice that the items are
    not printed in the order they were added to the sets. Sets, like dictionaries,
    are unordered. They both use an underlying hash-based data structure for efficiency.
    Because they are unordered, sets cannot have items looked up by index. The primary
    purpose of a set is to divide the world into two groups: "things that are in the
    set", and, "things that are not in the set". It is easy to check whether an item
    is in the set or to loop over the items in a set, but if we want to sort or order
    them, we''ll have to convert the set to a list. This output shows all three of
    these activities:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意输出，你会注意到项目的打印顺序并不是它们添加到集合中的顺序。集合和字典一样，是无序的。它们都使用基于哈希的数据结构来提高效率。因为它们是无序的，集合不能通过索引查找项目。集合的主要目的是将世界分为两组：“在集合中的事物”和“不在集合中的事物”。检查一个项目是否在集合中或循环遍历集合中的项目很容易，但如果我们想要对它们进行排序或排序，我们就必须将集合转换为列表。这个输出显示了这三种活动：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: While the primary *feature* of a set is uniqueness, that is not its primary
    *purpose*. Sets are most useful when two or more of them are used in combination.
    Most of the methods on the set type operate on other sets, allowing us to efficiently
    combine or compare the items in two or more sets. These methods have strange names,
    since they use the same terminology used in mathematics. We'll start with three
    methods that return the same result, regardless of which is the calling set and
    which is the called set.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 集合的主要*特征*是唯一性，但这并不是它的主要*目的*。当两个或更多个集合组合使用时，集合最有用。集合类型上的大多数方法都作用于其他集合，允许我们有效地组合或比较两个或更多个集合中的项目。这些方法有奇怪的名称，因为它们使用数学中使用的相同术语。我们将从三种返回相同结果的方法开始，不管哪个是调用集合，哪个是被调用集合。
- en: The `union` method is the most common and easiest to understand. It takes a
    second set as a parameter and returns a new set that contains all elements that
    are in *either* of the two sets; if an element is in both original sets, it will,
    of course, only show up once in the new set. Union is like a logical `or` operation,
    indeed, the `|` operator can be used on two sets to perform the union operation,
    if you don't like calling methods.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`union`方法是最常见和最容易理解的。它将第二个集合作为参数，并返回一个新集合，其中包含两个集合中*任何一个*的所有元素；如果一个元素在两个原始集合中，它当然只会在新集合中出现一次。联合就像一个逻辑的`or`操作，实际上，`|`运算符可以用于两个集合执行联合操作，如果你不喜欢调用方法。'
- en: Conversely, the intersection method accepts a second set and returns a new set
    that contains only those elements that are in *both* sets. It is like a logical
    `and` operation, and can also be referenced using the `&` operator.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，交集方法接受第二个集合并返回一个新集合，其中只包含*两个*集合中的元素。这就像一个逻辑的`and`操作，并且也可以使用`&`运算符来引用。
- en: 'Finally, the `symmetric_difference` method tells us what''s left; it is the
    set of objects that are in one set or the other, but not both. The following example
    illustrates these methods by comparing some artists from my song library to those
    in my sister''s:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`symmetric_difference` 方法告诉我们剩下什么；它是一个集合，其中包含一个集合或另一个集合中的对象，但不包含两者都有的对象。以下示例通过比较我的歌曲库中的一些艺术家和我妹妹的歌曲库中的艺术家来说明这些方法：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we run this code, we see that these three methods do what the print statements
    suggest they will do:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这段代码，我们会发现这三种方法确实做了打印语句所暗示的事情：
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: These methods all return the same result, regardless of which set calls the
    other. We can say `my_artists.union(auburns_artists)` or `auburns_artists.union(my_artists)`
    and get the same result. There are also methods that return different results
    depending on who is the caller and who is the argument.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法无论哪个集合调用另一个集合，都会返回相同的结果。我们可以说 `my_artists.union(auburns_artists)` 或 `auburns_artists.union(my_artists)`，结果都是一样的。还有一些方法，根据调用者和参数的不同会返回不同的结果。
- en: These methods include `issubset` and `issuperset`, which are the inverse of
    each other. Both return a `bool`. The `issubset` method returns `True`, if all
    of the items in the calling set are also in the set passed as an argument. The
    `issuperset` method returns `True` if all of the items in the argument are also
    in the calling set. Thus `s.issubset(t)` and `t.issuperset(s)` are identical.
    They will both return `True` if `t` contains all the elements in `s`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法包括 `issubset` 和 `issuperset`，它们是彼此的反义。两者都返回一个 `bool` 值。`issubset` 方法返回 `True`，如果调用集合中的所有项也在作为参数传递的集合中。`issuperset`
    方法返回 `True`，如果参数中的所有项也在调用集合中。因此 `s.issubset(t)` 和 `t.issuperset(s)` 是相同的。如果 `t`
    包含了 `s` 中的所有元素，它们都会返回 `True`。
- en: 'Finally, the `difference` method returns all the elements that are in the calling
    set, but not in the set passed as an argument; this is like half a `symmetric_difference`.
    The `difference` method can also be represented by the `-` operator. The following
    code illustrates these methods in action:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`difference` 方法返回调用集合中的所有元素，但不在作为参数传递的集合中；这类似于`symmetric_difference` 的一半。`difference`
    方法也可以用 `-` 运算符表示。以下代码说明了这些方法的运行方式：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This code simply prints out the response of each method when called from one
    set on the other. Running it gives us the following output:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码简单地打印出了在一个集合上调用另一个集合时每个方法的响应。运行代码会得到以下输出：
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `difference` method, in the second case, returns an empty set, since there
    are no items in `bands` that are not in `my_artists`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，`difference` 方法返回一个空集，因为 `bands` 中没有不在 `my_artists` 中的项目。
- en: The `union`, `intersection`, and `difference` methods can all take multiple
    sets as arguments; they will return, as we might expect, the set that is created
    when the operation is called on all the parameters.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`union`、`intersection` 和 `difference` 方法都可以接受多个集合作为参数；它们会返回我们所期望的，即在调用所有参数时创建的集合。'
- en: So the methods on sets clearly suggest that sets are meant to operate on other
    sets, and that they are not just containers. If we have data coming in from two
    different sources and need to quickly combine them in some way, to determine where
    the data overlaps or is different, we can use set operations to efficiently compare
    them. Or if we have data incoming that may contain duplicates of data that has
    already been processed, we can use sets to compare the two and process only the
    new data.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，集合上的方法清楚地表明集合是用来操作其他集合的，并且它们不仅仅是容器。如果我们有来自两个不同来源的数据，并且需要快速地以某种方式将它们合并，以确定数据重叠或不同之处，我们可以使用集合操作来高效地比较它们。或者，如果我们有可能包含已经处理过的数据的重复数据，我们可以使用集合来比较这两者，并仅处理新数据。
- en: Finally, it is valuable to know that sets are much more efficient than lists
    when checking for membership using the `in` keyword. If you use the syntax `value
    in container` on a set or a list, it will return `True` if one of the elements
    in `container` is equal to `value` and `False` otherwise. However, in a list,
    it will look at every object in the container until it finds the value, whereas
    in a set, it simply hashes the value and checks for membership. This means that
    a set will find the value in the same amount of time no matter how big the container
    is, but a list will take longer and longer to search for a value as the list contains
    more and more values.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，了解到在使用 `in` 关键字检查成员资格时，集合比列表要高效得多。如果在集合或列表上使用语法 `value in container`，如果 `container`
    中的一个元素等于 `value`，则返回 `True`，否则返回 `False`。但是，在列表中，它会查看容器中的每个对象，直到找到该值，而在集合中，它只是对该值进行哈希处理并检查成员资格。这意味着集合将以相同的时间找到值，无论容器有多大，但列表在搜索值时会花费越来越长的时间，因为列表包含的值越来越多。
- en: Extending built-ins
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展内置对象
- en: We discussed briefly in [Chapter 3](ch03.html "Chapter 3. When Objects Are Alike"),
    *When Objects Are Alike*, how built-in data types can be extended using inheritance.
    Now, we'll go into more detail as to when we would want to do that.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第3章](ch03.html "第3章。对象相似时")中简要讨论了内置数据类型如何使用继承进行扩展。现在，我们将更详细地讨论何时需要这样做。
- en: When we have a built-in container object that we want to add functionality to,
    we have two options. We can either create a new object, which holds that container
    as an attribute (composition), or we can subclass the built-in object and add
    or adapt methods on it to do what we want (inheritance).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个内置容器对象需要添加功能时，我们有两个选择。我们可以创建一个新对象，将该容器作为属性（组合），或者我们可以对内置对象进行子类化，并添加或调整方法以实现我们想要的功能（继承）。
- en: Composition is usually the best alternative if all we want to do is use the
    container to store some objects using that container's features. That way, it's
    easy to pass that data structure into other methods and they will know how to
    interact with it. But we need to use inheritance if we want to change the way
    the container actually works. For example, if we want to ensure every item in
    a `list` is a string with exactly five characters, we need to extend `list` and
    override the `append()` method to raise an exception for invalid input. We'd also
    minimally have to override `__setitem__(self, index, value)`, a special method
    on lists that is called whenever we use the `x[index] = "value"` syntax, and the
    `extend()` method.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想使用容器来存储一些对象，使用组合通常是最好的选择，使用容器的特性。这样，很容易将数据结构传递到其他方法中，它们将知道如何与它交互。但是，如果我们想要改变容器的实际工作方式，我们需要使用继承。例如，如果我们想要确保`list`中的每个项目都是一个具有确切五个字符的字符串，我们需要扩展`list`并覆盖`append()`方法以引发无效输入的异常。我们还至少需要覆盖`__setitem__(self,
    index, value)`，这是列表上的一个特殊方法，每当我们使用`x[index] = "value"`语法时都会调用它，以及`extend()`方法。
- en: Yes, lists are objects. All that special non-object-oriented looking syntax
    we've been looking at for accessing lists or dictionary keys, looping over containers,
    and similar tasks is actually "syntactic sugar" that maps to an object-oriented
    paradigm underneath. We might ask the Python designers why they did this. Isn't
    object-oriented programming *always* better? That question is easy to answer.
    In the following hypothetical examples, which is easier to read, as a programmer?
    Which requires less typing?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，列表是对象。我们一直在访问列表或字典键，循环容器以及类似任务的特殊非面向对象的语法实际上是“语法糖”，它映射到对象导向范式下面。我们可能会问Python设计者为什么这样做。难道面向对象编程*总是*更好吗？这个问题很容易回答。在下面的假设例子中，哪个更容易阅读，作为程序员？哪个需要输入更少？
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The highlighted sections show what object-oriented code might look like (in
    practice, these methods actually exist as special double-underscore methods on
    associated objects). Python programmers agree that the non-object-oriented syntax
    is easier both to read and to write. Yet all of the preceding Python syntaxes
    map to object-oriented methods underneath the hood. These methods have special
    names (with double-underscores before and after) to remind us that there is a
    better syntax out there. However, it gives us the means to override these behaviors.
    For example, we can make a special integer that always returns `0` when we add
    two of them together:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 突出显示的部分展示了面向对象的代码可能是什么样子（实际上，这些方法实际上存在于相关对象的特殊双下划线方法中）。Python程序员一致认为，非面向对象的语法更容易阅读和编写。然而，所有前述的Python语法都映射到面向对象的方法下面。这些方法有特殊的名称（在前后都有双下划线），提醒我们有更好的语法。但是，它给了我们覆盖这些行为的手段。例如，我们可以创建一个特殊的整数，当我们将两个整数相加时总是返回`0`：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This is an extremely bizarre thing to do, granted, but it perfectly illustrates
    these object-oriented principles in action:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个极端奇怪的事情，毫无疑问，但它完美地诠释了这些面向对象的原则：
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The awesome thing about the `__add__` method is that we can add it to any class
    we write, and if we use the `+` operator on instances of that class, it will be
    called. This is how string, tuple, and list concatenation works, for example.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`__add__`方法的绝妙之处在于我们可以将其添加到我们编写的任何类中，如果我们在该类的实例上使用`+`运算符，它将被调用。这就是字符串、元组和列表连接的工作原理，例如。'
- en: This is true of all the special methods. If we want to use `x in myobj` syntax
    for a custom-defined object, we can implement `__contains__`. If we want to use
    `myobj[i] = value` syntax, we supply a `__setitem__` method and if we want to
    use `something = myobj[i]`, we implement `__getitem__`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于所有特殊方法。如果我们想要为自定义对象使用`x in myobj`语法，我们可以实现`__contains__`。如果我们想要使用`myobj[i]
    = value`语法，我们提供一个`__setitem__`方法，如果我们想要使用`something = myobj[i]`，我们实现`__getitem__`。
- en: 'There are 33 of these special methods on the `list` class. We can use the `dir`
    function to see all of them:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`list`类上有33个这样的特殊方法。我们可以使用`dir`函数查看所有这些方法：'
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Further, if we desire additional information on how any of these methods works,
    we can use the `help` function:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们想要了解这些方法的工作方式的其他信息，我们可以使用`help`函数：
- en: '[PRE40]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The plus operator on lists concatenates two lists. We don't have room to discuss
    all of the available special functions in this book, but you are now able to explore
    all this functionality with `dir` and `help`. The official online Python reference
    ([https://docs.python.org/3/](https://docs.python.org/3/)) has plenty of useful
    information as well. Focus, especially, on the abstract base classes discussed
    in the `collections` module.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 列表上的加号运算符连接两个列表。我们没有空间来讨论本书中所有可用的特殊函数，但是现在您可以使用`dir`和`help`来探索所有这些功能。官方在线Python参考([https://docs.python.org/3/](https://docs.python.org/3/))也有很多有用的信息。特别关注`collections`模块中讨论的抽象基类。
- en: 'So, to get back to the earlier point about when we would want to use composition
    versus inheritance: if we need to somehow change any of the methods on the class—including
    the special methods—we definitely need to use inheritance. If we used composition,
    we could write methods that do the validation or alterations and ask the caller
    to use those methods, but there is nothing stopping them from accessing the property
    directly. They could insert an item into our list that does not have five characters,
    and that might confuse other methods in the list.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，回到之前关于何时使用组合与继承的观点：如果我们需要以某种方式更改类上的任何方法，包括特殊方法，我们绝对需要使用继承。如果我们使用组合，我们可以编写执行验证或更改的方法，并要求调用者使用这些方法，但没有任何阻止他们直接访问属性。他们可以向我们的列表中插入一个不具有五个字符的项目，这可能会使列表中的其他方法感到困惑。
- en: Often, the need to extend a built-in data type is an indication that we're using
    the wrong sort of data type. It is not always the case, but if we are looking
    to extend a built-in, we should carefully consider whether or not a different
    data structure would be more suitable.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，需要扩展内置数据类型是使用错误类型的数据类型的迹象。这并不总是这样，但是如果我们想要扩展内置的话，我们应该仔细考虑是否不同的数据结构更合适。
- en: For example, consider what it takes to create a dictionary that remembers the
    order in which keys were inserted. One way to do this is to keep an ordered list
    of keys that is stored in a specially derived subclass of `dict`. Then we can
    override the methods `keys`, `values`, `__iter__`, and `items` to return everything
    in order. Of course, we'll also have to override `__setitem__` and `setdefault`
    to keep our list up to date. There are likely to be a few other methods in the
    output of `dir(dict)` that need overriding to keep the list and dictionary consistent
    (`clear` and `__delitem__` come to mind, to track when items are removed), but
    we won't worry about them for this example.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑创建一个记住插入键的顺序的字典需要做些什么。做到这一点的一种方法是保持一个有序的键列表，该列表存储在 `dict` 的特殊派生子类中。然后我们可以覆盖方法
    `keys`、`values`、`__iter__` 和 `items` 以按顺序返回所有内容。当然，我们还必须覆盖 `__setitem__` 和 `setdefault`
    以保持我们的列表最新。在 `dir(dict)` 的输出中可能还有一些其他方法需要覆盖以保持列表和字典一致（`clear` 和 `__delitem__`
    记录了何时删除项目），但是在这个例子中我们不用担心它们。
- en: 'So we''ll be extending `dict` and adding a list of ordered keys. Trivial enough,
    but where do we create the actual list? We could include it in the `__init__`
    method, which would work just fine, but we have no guarantees that any subclass
    will call that initializer. Remember the `__new__` method we discussed in [Chapter
    2](ch02.html "Chapter 2. Objects in Python"), *Objects in Python*? I said it was
    generally only useful in very special cases. This is one of those special cases.
    We know `__new__` will be called exactly once, and we can create a list on the
    new instance that will always be available to our class. With that in mind, here
    is our entire sorted dictionary:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将扩展 `dict` 并添加一个有序键列表。这很简单，但我们在哪里创建实际的列表呢？我们可以将它包含在 `__init__` 方法中，这样就可以正常工作，但我们不能保证任何子类都会调用该初始化程序。还记得我们在[第2章](ch02.html
    "第2章。Python中的对象")中讨论过的 `__new__` 方法吗？我说它通常只在非常特殊的情况下有用。这就是其中之一。我们知道 `__new__`
    将被调用一次，并且我们可以在新实例上创建一个列表，该列表将始终对我们的类可用。考虑到这一点，这就是我们整个排序字典：
- en: '[PRE41]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `__new__` method creates a new dictionary and then puts an empty list on
    that object. We don't override `__init__`, as the default implementation works
    (actually, this is only true if we initialize an empty `DictSorted` object, which
    is standard behavior. If we want to support other variations of the `dict` constructor,
    which accept dictionaries or lists of tuples, we'd need to fix `__init__` to also
    update our `ordered_keys` list). The two methods for setting items are very similar;
    they both update the list of keys, but only if the item hasn't been added before.
    We don't want duplicates in the list, but we can't use a set here; it's unordered!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`__new__` 方法创建一个新的字典，然后在该对象上放置一个空列表。我们不覆盖 `__init__`，因为默认实现有效（实际上，只有在我们初始化一个空的
    `DictSorted` 对象时才是真的。如果我们想要支持 `dict` 构造函数的其他变体，它接受字典或元组列表，我们需要修复 `__init__` 以更新我们的
    `ordered_keys` 列表）。设置项目的两种方法非常相似；它们都更新键列表，但只有在项目之前没有添加时才更新。我们不希望列表中有重复项，但我们不能在这里使用集合；它是无序的！'
- en: The `keys`, `items`, and `values` methods all return views onto the dictionary.
    The collections library provides three read-only `View` objects onto the dictionary;
    they use the `__iter__` method to loop over the keys, and then use `__getitem__`
    (which we didn't need to override) to retrieve the values. So, we only need to
    define our custom `__iter__` method to make these three views work. You would
    think the superclass would create these views properly using polymorphism, but
    if we don't override these three methods, they don't return properly ordered views.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`keys`、`items` 和 `values` 方法都返回字典的视图。collections 库为字典提供了三个只读的 `View` 对象；它们使用
    `__iter__` 方法循环遍历键，然后使用 `__getitem__`（我们不需要覆盖）来检索值。因此，我们只需要定义我们自定义的 `__iter__`
    方法来使这三个视图工作。你可能会认为超类会使用多态性正确地创建这些视图，但如果我们不覆盖这三个方法，它们就不会返回正确排序的视图。'
- en: Finally, the `__iter__` method is the really special one; it ensures that if
    we loop over the dictionary's keys (using `for`...`in` syntax), it will return
    the values in the correct order. It does this by returning the `__iter__` of the
    `ordered_keys` list, which returns the same iterator object that would be used
    if we used `for`...`in` on the list instead. Since `ordered_keys` is a list of
    all available keys (due to the way we overrode other methods), this is the correct
    iterator object for the dictionary as well.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`__iter__` 方法是真正特殊的；它确保如果我们循环遍历字典的键（使用 `for`...`in` 语法），它将按正确的顺序返回值。它通过返回
    `ordered_keys` 列表的 `__iter__` 来实现这一点，该列表返回的是与我们在列表上使用 `for`...`in` 时使用的相同的迭代器对象。由于
    `ordered_keys` 是所有可用键的列表（由于我们覆盖其他方法的方式），这也是字典的正确迭代器对象。
- en: 'Let''s look at a few of these methods in action, compared to a normal dictionary:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些方法中的一些是如何运作的，与普通字典相比：
- en: '[PRE42]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Ah, our dictionary is sorted and the normal dictionary is not. Hurray!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，我们的字典是有序的，而普通字典不是。万岁！
- en: Note
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you wanted to use this class in production, you'd have to override several
    other special methods to ensure the keys are up to date in all cases. However,
    you don't need to do this; the functionality this class provides is already available
    in Python, using the `OrderedDict` object in the `collections` module. Try importing
    the class from `collections`, and use `help(OrderedDict)` to find out more about
    it.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在生产中使用这个类，您将不得不覆盖其他几个特殊方法，以确保在所有情况下键都是最新的。但是，您不需要这样做；这个类提供的功能在 Python 中已经可用，使用
    `collections` 模块中的 `OrderedDict` 对象。尝试从 `collections` 导入该类，并使用 `help(OrderedDict)`
    了解更多信息。
- en: Queues
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列
- en: Queues are peculiar data structures because, like sets, their functionality
    can be handled entirely using lists. However, while lists are extremely versatile
    general-purpose tools, they are occasionally not the most efficient data structure
    for container operations. If your program is using a small dataset (up to hundreds
    or even thousands of elements on today's processors), then lists will probably
    cover all your use cases. However, if you need to scale your data into the millions,
    you may need a more efficient container for your particular use case. Python therefore
    provides three types of queue data structures, depending on what kind of access
    you are looking for. All three utilize the same API, but differ in both behavior
    and data structure.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 队列是奇特的数据结构，因为像集合一样，它们的功能可以完全使用列表来处理。然而，虽然列表是非常多才多艺的通用工具，但有时它们并不是最有效的容器数据结构。如果您的程序使用的是小型数据集（在今天的处理器上最多有数百甚至数千个元素），那么列表可能会涵盖所有您的用例。但是，如果您需要将数据扩展到百万级别，您可能需要一个更有效的容器来满足您特定的用例。因此，Python提供了三种类型的队列数据结构，具体取决于您要查找的访问类型。所有三种都使用相同的API，但在行为和数据结构上有所不同。
- en: 'Before we start our queues, however, consider the trusty list data structure.
    Python lists are the most advantageous data structure for many use cases:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们开始使用队列之前，考虑一下可靠的列表数据结构。Python列表是许多用例中最有利的数据结构：
- en: They support efficient random access to any element in the list
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们支持对列表中的任何元素进行高效的随机访问
- en: They have strict ordering of elements
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们有严格的元素排序
- en: They support the append operation efficiently
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们支持高效的附加操作
- en: They tend to be slow, however, if you are inserting elements anywhere but the
    end of the list (especially so if it's the beginning of the list). As we discussed
    in the section on sets, they are also slow for checking if an element exists in
    the list, and by extension, searching. Storing data in a sorted order or reordering
    the data can also be inefficient.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您在列表的末尾之外的任何位置插入元素，它们往往会很慢（特别是如果是列表的开头）。正如我们在集合部分讨论的那样，它们对于检查元素是否存在于列表中，以及通过扩展搜索也很慢。存储数据按排序顺序或重新排序数据也可能效率低下。
- en: Let's look at the three types of containers provided by the Python `queue` module.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看Python `queue`模块提供的三种类型的容器。
- en: FIFO queues
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FIFO队列
- en: FIFO stands for **First In First Out** and represents the most commonly understood
    definition of the word "queue". Imagine a line of people standing in line at a
    bank or cash register. The first person to enter the line gets served first, the
    second person in line gets served second, and if a new person desires service,
    they join the end of the line and wait their turn.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: FIFO代表**先进先出**，代表了“队列”这个词最常见的定义。想象一下在银行或收银台排队的人群。第一个进入队列的人先得到服务，第二个人得到第二个服务，如果有新的人需要服务，他们加入队列的末尾等待轮到他们。
- en: The Python `Queue` class is just like that. It is typically used as a sort of
    communication medium when one or more objects is producing data and one or more
    other objects is consuming the data in some way, probably at a different rate.
    Think of a messaging application that is receiving messages from the network,
    but can only display one message at a time to the user. The other messages can
    be buffered in a queue in the order they are received. FIFO queues are utilized
    a lot in such concurrent applications. (We'll talk more about concurrency in [Chapter
    12](ch12.html "Chapter 12. Testing Object-oriented Programs"), *Testing Object-oriented
    Programs*.)
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Python `Queue`类就像这样。它通常被用作一种通信媒介，当一个或多个对象产生数据，而一个或多个其他对象以某种方式消耗数据时，可能以不同的速率。想象一下一个消息应用程序，它从网络接收消息，但只能一次向用户显示一条消息。其他消息可以按接收顺序缓存在队列中。FIFO队列在这种并发应用程序中被广泛使用。（我们将在[第12章](ch12.html
    "第12章。测试面向对象的程序")中更多地讨论并发，*测试面向对象的程序*。）
- en: The `Queue` class is a good choice when you don't need to access any data inside
    the data structure except the next object to be consumed. Using a list for this
    would be less efficient because under the hood, inserting data at (or removing
    from) the beginning of a list can require shifting every other element in the
    list.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当您不需要访问数据结构内部的任何数据，只需要访问下一个要消耗的对象时，`Queue`类是一个不错的选择。使用列表会更低效，因为在列表的底层，插入数据（或从列表中删除数据）可能需要移动列表中的每个其他元素。
- en: Queues have a very simple API. A `Queue` can have "infinite" (until the computer
    runs out of memory) capacity, but it is more commonly bounded to some maximum
    size. The primary methods are `put()` and `get()`, which add an element to the
    back of the line, as it were, and retrieve them from the front, in order. Both
    of these methods accept optional arguments to govern what happens if the operation
    cannot successfully complete because the queue is either empty (can't get) or
    full (can't put). The default behavior is to block or idly wait until the `Queue`
    object has data or room available to complete the operation. You can have it raise
    exceptions instead by passing the `block=False` parameter. Or you can have it
    wait a defined amount of time before raising an exception by passing a `timeout`
    parameter.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 队列有一个非常简单的API。一个“队列”可以有“无限”（直到计算机耗尽内存）的容量，但更常见的是限制到某个最大大小。主要方法是`put()`和`get()`，它们将一个元素添加到队列的末尾，并按顺序从前面检索它们。这两种方法都接受可选参数来控制如果操作无法成功完成会发生什么，因为队列要么为空（无法获取）要么已满（无法放置）。默认行为是阻塞或空闲等待，直到`Queue`对象有数据或空间可用来完成操作。您可以通过传递`block=False`参数来代替引发异常。或者您可以通过传递`timeout`参数在引发异常之前等待一定的时间。
- en: 'The class also has methods to check whether the `Queue` is `full()` or `empty()`
    and there are a few additional methods to deal with concurrent access that we
    won''t discuss here. Here is a interactive session demonstrating these principles:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 该类还有方法来检查`Queue`是否`full()`或`empty()`，还有一些额外的方法来处理并发访问，我们这里不讨论。这是一个演示这些原则的交互式会话：
- en: '[PRE43]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Underneath the hood, Python implements queues on top of the `collections.deque`
    data structure. Deques are advanced data structures that permits efficient access
    to both ends of the collection. It provides a more flexible interface than is
    exposed by `Queue`. I refer you to the Python documentation if you'd like to experiment
    more with it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，Python使用`collections.deque`数据结构实现队列。双端队列是一种先进先出的数据结构，可以有效地访问集合的两端。它提供了一个比`Queue`更灵活的接口。如果你想要更多地尝试它，我建议你参考Python文档。
- en: LIFO queues
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LIFO队列
- en: '**LIFO** (**Last In First Out**) queues are more frequently called **stacks**.
    Think of a stack of papers where you can only access the top-most paper. You can
    put another paper on top of the stack, making it the new top-most paper, or you
    can take the top-most paper away to reveal the one beneath it.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**LIFO**（**后进先出**）队列更常被称为**栈**。想象一叠文件，你只能访问最顶部的文件。你可以在栈的顶部放另一张纸，使其成为新的顶部纸，或者你可以拿走最顶部的纸，以显示其下面的纸。'
- en: 'Traditionally, the operations on stacks are named push and pop, but the Python
    `queue` module uses the exact same API as for FIFO queues: `put()` and `get()`.
    However, in a LIFO queue, these methods operate on the "top" of the stack instead
    of at the front and back of a line. This is an excellent example of polymorphism.
    If you look at the `Queue` source code in the Python standard library, you''ll
    actually see that there is a superclass with subclasses for FIFO and LIFO queues
    that implement the few operations (operating on the top of a stack instead of
    front and back of a `deque` instance) that are critically different between the
    two.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，栈的操作被命名为push和pop，但Python的`queue`模块使用与FIFO队列完全相同的API：`put()`和`get()`。然而，在LIFO队列中，这些方法操作的是栈的“顶部”，而不是队列的前后。这是多态的一个很好的例子。如果你查看Python标准库中`Queue`的源代码，你会发现实际上有一个超类和子类，用于实现FIFO和LIFO队列之间的一些关键不同的操作（在栈的顶部而不是`deque`实例的前后进行操作）。
- en: 'Here''s an example of the LIFO queue in action:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是LIFO队列的一个示例：
- en: '[PRE44]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You might wonder why you couldn't just use the `append()` and `pop()` methods
    on a standard list. Quite frankly, that's probably what I would do. I rarely have
    occasion to use the `LifoQueue` class in production code. Working with the end
    of a list is an efficient operation; so efficient, in fact, that the `LifoQueue`
    uses a standard list under the hood!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想为什么不能只是在标准列表上使用`append()`和`pop()`方法。坦率地说，那可能是我会做的事情。我很少有机会在生产代码中使用`LifoQueue`类。与列表的末尾一起工作是一个高效的操作；实际上，`LifoQueue`在内部使用了标准列表！
- en: There are a couple of reasons that you might want to use `LifoQueue` instead
    of a list. The most important one is that `LifoQueue` supports clean concurrent
    access from multiple threads. If you need stack-like behavior in a concurrent
    setting, you should leave the list at home. Second, `LifoQueue` enforces the stack
    interface. You can't unwittingly insert a value to the wrong position in a `LifoQueue`,
    for example (although, as an exercise, you can work out how to do this completely
    wittingly).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个原因你可能想要使用`LifoQueue`而不是列表。最重要的原因是`LifoQueue`支持多个线程的干净并发访问。如果你需要在并发环境中使用类似栈的行为，你应该把列表留在家里。其次，`LifoQueue`实施了栈接口。你不能无意中在`LifoQueue`中插入一个值到错误的位置（尽管作为一个练习，你可以想出如何完全有意识地这样做）。
- en: Priority queues
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优先队列
- en: The priority queue enforces a very different style of ordering from the previous
    queue implementations. Once again, they follow the exact same `get()` and `put()`
    API, but instead of relying on the order that items arrive to determine when they
    should be returned, the most "important" item is returned. By convention, the
    most important, or highest priority item is the one that sorts lowest using the
    less than operator.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 优先队列实施了一种与以前队列实现非常不同的排序方式。再次强调，它们遵循完全相同的`get()`和`put()`API，但是不是依赖于项目到达的顺序来确定它们应该何时被返回，而是返回最“重要”的项目。按照约定，最重要或最高优先级的项目是使用小于运算符排序最低的项目。
- en: A common convention is to store tuples in the priority queue, where the first
    element in the tuple is the priority for that element, and the second element
    is the data. Another common paradigm is to implement the `__lt__` method, as we
    discussed earlier in this chapter. It is perfectly acceptable to have multiple
    elements with the same priority in the queue, although there are no guarantees
    on which one will be returned first.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的约定是在优先队列中存储元组，其中元组中的第一个元素是该元素的优先级，第二个元素是数据。另一个常见的范例是实现`__lt__`方法，就像我们在本章前面讨论的那样。在队列中可以有多个具有相同优先级的元素，尽管不能保证哪一个会被首先返回。
- en: A priority queue might be used, for example, by a search engine to ensure it
    refreshes the content of the most popular web pages before crawling sites that
    are less likely to be searched for. A product recommendation tool might use one
    to display information about the most highly ranked products while still loading
    data for the lower ranks.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，搜索引擎可能使用优先队列来确保在爬行不太可能被搜索的网站之前刷新最受欢迎的网页的内容。产品推荐工具可能使用它来显示关于排名最高的产品的信息，同时加载排名较低的数据。
- en: Note that a priority queue will always return the most important element currently
    in the queue. The `get()` method will block (by default) if the queue is empty,
    but it will not block and wait for a higher priority element to be added if there
    is already something in the queue. The queue knows nothing about elements that
    have not been added yet (or even about elements that have been previously extracted),
    and only makes decisions based on the current contents of the queue.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，优先队列总是返回当前队列中最重要的元素。`get()`方法将阻塞（默认情况下）如果队列为空，但如果队列中已经有东西，它不会阻塞并等待更高优先级的元素被添加。队列对尚未添加的元素一无所知（甚至对先前提取的元素也一无所知），只根据队列当前的内容做出决定。
- en: 'This interactive session shows a priority queue in action, using tuples as
    weights to determine what order items are processed in:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这个交互式会话展示了优先队列的工作原理，使用元组作为权重来确定处理项目的顺序：
- en: '[PRE45]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Priority queues are almost universally implemented using the `heap` data structure.
    Python's implementation utilizes the `heapq` module to effectively store a heap
    inside a normal list. I direct you to an algorithm and data-structure's textbook
    for more information on heaps, not to mention many other fascinating structures
    we haven't covered here. No matter what the data structure, you can use object-oriented
    principles to wrap relevant algorithms (behaviors), such as those supplied in
    the `heapq` module, around the data they are structuring in the computer's memory,
    just as the `queue` module has done on our behalf in the standard library.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的优先队列都是使用`heap`数据结构实现的。Python的实现利用`heapq`模块来有效地在普通列表中存储一个堆。我建议您查阅算法和数据结构的教科书，以获取有关堆的更多信息，更不用说我们在这里没有涵盖的许多其他迷人的结构了。无论数据结构如何，您都可以使用面向对象的原则来封装相关的算法（行为），就像`queue`模块在标准库中为我们所做的那样。
- en: Case study
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: 'To tie everything together, we''ll be writing a simple link collector, which
    will visit a website and collect every link on every page it finds in that site.
    Before we start, though, we''ll need some test data to work with. Simply write
    some HTML files to work with that contain links to each other and to other sites
    on the Internet, something like this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了把一切联系在一起，我们将编写一个简单的链接收集器，它将访问一个网站，并收集该站点上每个页面上的每个链接。不过，在我们开始之前，我们需要一些测试数据来使用。简单地编写一些HTML文件，这些文件包含彼此之间的链接，以及到互联网上其他站点的链接，就像这样：
- en: '[PRE46]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Name one of the files `index.html` so it shows up first when pages are served.
    Make sure the other files exist, and keep things complicated so there is lots
    of linking between them. The examples for this chapter include a directory called
    `case_study_serve` (one of the lamest personal websites in existence!) if you
    would rather not set them up yourself.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 将其中一个文件命名为`index.html`，这样当页面被提供时它会首先显示出来。确保其他文件存在，并且保持复杂，以便它们之间有很多链接。本章的示例包括一个名为`case_study_serve`的目录（存在的最无聊的个人网站之一！）如果您不想自己设置它们。
- en: 'Now, start a simple web server by entering the directory containing all these
    files and run the following command:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过进入包含所有这些文件的目录来启动一个简单的Web服务器，并运行以下命令：
- en: '[PRE47]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This will start a server running on port 8000; you can see the pages you made
    by visiting `http://localhost:8000/` in your web browser.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个运行在8000端口的服务器；您可以通过在浏览器中访问`http://localhost:8000/`来查看您创建的页面。
- en: Note
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I doubt anyone can get a website up and running with less work! Never let it
    be said, "you can't do that easily with Python."
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我怀疑没有人能够轻松地让一个网站运行起来！永远不要说，“你不能用Python轻松地做到这一点。”
- en: 'The goal will be to pass our collector the base URL for the site (in this case:
    `http://localhost:8000/`), and have it create a list containing every unique link
    on the site. We''ll need to take into account three types of URLs (links to external
    sites, which start with `http://`, absolute internal links, which start with a
    `/` character, and relative links, for everything else). We also need to be aware
    that pages may link to each other in a loop; we need to be sure we don''t process
    the same page multiple times, or it may never end. With all this uniqueness going
    on, it sounds like we''re going to need some sets.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是向我们的收集器传递站点的基本URL（在本例中为：`http://localhost:8000/`），并让它创建一个包含站点上每个唯一链接的列表。我们需要考虑三种类型的URL（指向外部站点的链接，以`http://`开头，绝对内部链接，以`/`字符开头，以及其他情况的相对链接）。我们还需要意识到页面可能会以循环方式相互链接；我们需要确保我们不会多次处理相同的页面，否则它可能永远不会结束。在所有这些唯一性发生时，听起来我们需要一些集合。
- en: Before we get into that, let's start with the basics. What code do we need to
    connect to a page and parse all the links from that page?
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们从基础知识开始。我们需要什么代码来连接到一个页面并解析该页面上的所有链接？
- en: '[PRE48]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This is a short piece of code, considering what it's doing. It connects to the
    server in the argument passed on the command line, downloads the page, and extracts
    all the links on that page. The `__init__` method uses the `urlparse` function
    to extract just the hostname from the URL; so even if we pass in `http://localhost:8000/some/page.html`,
    it will still operate on the top level of the host `http://localhost:8000/`. This
    makes sense, because we want to collect all the links on the site, although it
    assumes every page is connected to the index by some sequence of links.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到它的功能，这是一小段代码。它连接到命令行传递的服务器，下载页面，并提取该页面上的所有链接。`__init__`方法使用`urlparse`函数从URL中提取主机名；因此，即使我们传入`http://localhost:8000/some/page.html`，它仍将在主机的顶层`http://localhost:8000/`上运行。这是有道理的，因为我们想收集站点上的所有链接，尽管它假设每个页面都通过某些链接序列连接到索引。
- en: The `collect_links` method connects to and downloads the specified page from
    the server, and uses a regular expression to find all the links in the page. Regular
    expressions are an extremely powerful string processing tool. Unfortunately, they
    have a steep learning curve; if you haven't used them before, I strongly recommend
    studying any of the entire books or websites on the topic. If you don't think
    they're worth knowing, try writing the preceding code without them and you'll
    change your mind.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`collect_links`方法连接到服务器并下载指定页面，并使用正则表达式在页面中找到所有链接。正则表达式是一种非常强大的字符串处理工具。不幸的是，它们有一个陡峭的学习曲线；如果您以前没有使用过它们，我强烈建议您学习任何一本完整的书籍或网站上的相关主题。如果您认为它们不值得了解，那么尝试在没有它们的情况下编写前面的代码，您会改变主意的。'
- en: 'The example also stops in the middle of the `collect_links` method to print
    the value of links. This is a common way to test a program as we''re writing it:
    stop and output the value to ensure it is the value we expect. Here''s what it
    outputs for our example:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 示例还在`collect_links`方法的中间停止，以打印链接的值。这是测试程序的常见方法：停下来输出值，以确保它是我们期望的值。这是我们示例的输出：
- en: '[PRE49]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'So now we have a collection of all the links in the first page. What can we
    do with it? We can''t just pop the links into a set to remove duplicates because
    links may be relative or absolute. For example, `contact.html` and `/contact.html`
    point to the same page. So the first thing we should do is normalize all the links
    to their full URL, including hostname and relative path. We can do this by adding
    a `normalize_url` method to our object:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经收集了第一页中的所有链接。我们可以用它做什么？我们不能只是将链接弹出到一个集合中以删除重复项，因为链接可能是相对的或绝对的。例如，`contact.html`和`/contact.html`指向同一个页面。因此，我们应该做的第一件事是将所有链接规范化为它们的完整URL，包括主机名和相对路径。我们可以通过向我们的对象添加一个`normalize_url`方法来实现这一点：
- en: '[PRE50]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This method converts each URL to a complete address that includes protocol and
    hostname. Now the two contact pages have the same value and we can store them
    in a set. We'll have to modify `__init__` to create the set, and `collect_links`
    to put all the links into it.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法将每个URL转换为包括协议和主机名的完整地址。现在两个联系页面具有相同的值，我们可以将它们存储在一个集合中。我们将不得不修改`__init__`来创建这个集合，以及`collect_links`来将所有链接放入其中。
- en: 'Then, we''ll have to visit all the non-external links and collect them too.
    But wait a minute; if we do this, how do we keep from revisiting a link when we
    encounter the same page twice? It looks like we''re actually going to need two
    sets: a set of collected links, and a set of visited links. This suggests that
    we were wise to choose a set to represent our data; we know that sets are most
    useful when we''re manipulating more than one of them. Let''s set these up:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将不得不访问所有非外部链接并收集它们。但等一下；如果我们这样做，我们如何防止在遇到同一个页面两次时重新访问链接？看起来我们实际上需要两个集合：一个收集链接的集合，一个访问链接的集合。这表明我们明智地选择了一个集合来表示我们的数据；我们知道在操作多个集合时，集合是最有用的。让我们设置这些：
- en: '[PRE51]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The line that creates the normalized list of links uses a `set` comprehension,
    no different from a list comprehension, except that the result is a set of values.
    We''ll be covering these in detail in the next chapter. Once again, the method
    stops to print out the current values, so we can verify that we don''t have our
    sets confused, and that `difference` really was the method we wanted to call to
    collect `unvisited_links`. We can then add a few lines of code that loop over
    all the unvisited links and add them to the collection as well:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 创建规范化链接列表的行使用了`set`推导，与列表推导没有什么不同，只是结果是一组值。我们将在下一章中详细介绍这些。再次，该方法停下来打印当前值，以便我们可以验证我们没有混淆我们的集合，并且`difference`确实是我们想要调用的方法来收集`unvisited_links`。然后我们可以添加几行代码，循环遍历所有未访问的链接，并将它们添加到收集中：
- en: '[PRE52]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `if` statement ensures that we are only collecting links from the one website;
    we don''t want to go off and collect all the links from all the pages on the Internet
    (unless we''re Google or the Internet Archive!). If we modify the main code at
    the bottom of the program to output the collected links, we can see it seems to
    have collected them all:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句确保我们只从一个网站收集链接；我们不想去收集互联网上所有页面的所有链接（除非我们是Google或互联网档案馆！）。如果我们修改程序底部的主要代码以输出收集到的链接，我们可以看到它似乎已经收集了它们所有：'
- en: '[PRE53]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'It displays all the links we''ve collected, and only once, even though many
    of the pages in my example linked to each other multiple times:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示了我们收集到的所有链接，只显示了一次，即使我的示例中的许多页面多次链接到彼此：
- en: '[PRE54]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Even though it collected links *to* external pages, it didn't go off collecting
    links *from* any of the external pages we linked to. This is a great little program
    if we want to collect all the links in a site. But it doesn't give me all the
    information I might need to build a site map; it tells me which pages I have,
    but it doesn't tell me which pages link to other pages. If we want to do that
    instead, we're going to have to make some modifications.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 即使它收集了指向外部页面的链接，它也没有去收集我们链接到的任何外部页面的链接。如果我们想收集站点中的所有链接，这是一个很棒的小程序。但它并没有给我提供构建站点地图所需的所有信息；它告诉我我有哪些页面，但它没有告诉我哪些页面链接到其他页面。如果我们想要做到这一点，我们将不得不进行一些修改。
- en: 'The first thing we should do is look at our data structures. The set of collected
    links doesn''t work anymore; we want to know which links were linked to from which
    pages. The first thing we could do, then, is turn that set into a dictionary of
    sets for each page we visit. The dictionary keys will represent the exact same
    data that is currently in the set. The values will be sets of all the links on
    that page. Here are the changes:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该做的第一件事是查看我们的数据结构。收集链接的集合不再起作用；我们想知道哪些链接是从哪些页面链接过来的。因此，我们可以做的第一件事是将该集合转换为我们访问的每个页面的集合字典。字典键将表示当前集合中的确切数据。值将是该页面上的所有链接的集合。以下是更改：
- en: '[PRE55]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: It is a surprisingly small change; the line that originally created a union
    of two sets has been replaced with three lines that update the dictionary. The
    first of these simply tells the dictionary what the collected links for that page
    are. The second creates an empty set for any items in the dictionary that have
    not already been added to the dictionary, using `setdefault`. The result is a
    dictionary that contains all the links as its keys, mapped to sets of links for
    all the internal links, and empty sets for the external links.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个令人惊讶的小改变；原来创建两个集合的行已被三行代码替换，用于更新字典。其中第一行简单地告诉字典该页面的收集链接是什么。第二行使用`setdefault`为字典中尚未添加到字典中的任何项目创建一个空集。结果是一个包含所有链接的字典，将其键映射到所有内部链接的链接集，外部链接为空集。
- en: Finally, instead of recursively calling `collect_links`, we can use a queue
    to store the links that haven't been processed yet. This implementation won't
    support it, but this would be a good first step to creating a multithreaded version
    that makes multiple requests in parallel to save time.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用队列来存储尚未处理的链接，而不是递归调用`collect_links`。这种实现不支持它，但这将是创建一个多线程版本的良好第一步，该版本可以并行进行多个请求以节省时间。
- en: '[PRE56]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: I had to manually strip any trailing forward slashes in the `normalize_url`
    method to remove duplicates in this version of the code.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本的代码中，我不得不手动去除`normalize_url`方法中的任何尾部斜杠，以消除重复项。
- en: Because the end result is an unsorted dictionary, there is no restriction on
    what order the links should be processed in. Therefore, we could just as easily
    have used a `LifoQueue` instead of a `Queue` here. A priority queue probably wouldn't
    make a lot of sense since there is no obvious priority to attach to a link in
    this case.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 因为最终结果是一个未排序的字典，所以对链接进行处理的顺序没有限制。因此，在这里我们可以使用`LifoQueue`而不是`Queue`。由于在这种情况下没有明显的优先级可附加到链接上，使用优先级队列可能没有太多意义。
- en: Exercises
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: The best way to learn how to choose the correct data structure is to do it wrong
    a few times. Take some code you've recently written, or write some new code that
    uses a list. Try rewriting it using some different data structures. Which ones
    make more sense? Which ones don't? Which have the most elegant code?
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 选择正确数据结构的最佳方法是多次选择错误。拿出你最近写过的一些代码，或者写一些使用列表的新代码。尝试使用一些不同的数据结构来重写它。哪些更合理？哪些不合理？哪些代码最优雅？
- en: Try this with a few different pairs of data structures. You can look at examples
    you've done for previous chapter exercises. Are there objects with methods where
    you could have used `namedtuple` or `dict` instead? Attempt both and see. Are
    there dictionaries that could have been sets because you don't really access the
    values? Do you have lists that check for duplicates? Would a set suffice? Or maybe
    several sets? Would one of the queue implementations be more efficient? Is it
    useful to restrict the API to the top of a stack rather than allowing random access
    to the list?
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用几种不同的数据结构。你可以查看你之前章节练习中做过的例子。有没有对象和方法，你本来可以使用`namedtuple`或`dict`？尝试一下，看看结果如何。有没有本来可以使用集合的字典，因为你实际上并没有访问值？有没有检查重复项的列表？集合是否足够？或者可能需要几个集合？哪种队列实现更有效？将API限制在堆栈顶部是否有用，而不是允许随机访问列表？
- en: If you want some specific examples to work with, try adapting the link collector
    to also save the title used for each link. Perhaps you can generate a site map
    in HTML that lists all the pages on the site, and contains a list of links to
    other pages, named with the same link titles.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一些具体的例子来操作，可以尝试将链接收集器改编为同时保存每个链接使用的标题。也许你可以生成一个HTML站点地图，列出站点上的所有页面，并包含一个链接到其他页面的链接列表，使用相同的链接标题命名。
- en: Have you written any container objects recently that you could improve by inheriting
    a built-in and overriding some of the "special" double-underscore methods? You
    may have to do some research (using `dir` and `help`, or the Python library reference)
    to find out which methods need overriding. Are you sure inheritance is the correct
    tool to apply; could a composition-based solution be more effective? Try both
    (if it's possible) before you decide. Try to find different situations where each
    method is better than the other.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最近是否编写了任何容器对象，可以通过继承内置对象并重写一些“特殊”双下划线方法来改进？你可能需要进行一些研究（使用`dir`和`help`，或Python库参考）来找出哪些方法需要重写。你确定继承是应用的正确工具吗？基于组合的解决方案可能更有效吗？在决定之前尝试两种方法（如果可能的话）。尝试找到不同的情况，其中每种方法都比另一种更好。
- en: If you were familiar with the various Python data structures and their uses
    before you started this chapter, you may have been bored. But if that is the case,
    there's a good chance you use data structures too much! Look at some of your old
    code and rewrite it to use more self-made objects. Carefully consider the alternatives
    and try them all out; which one makes for the most readable and maintainable system?
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在开始本章之前，你已经熟悉各种Python数据结构及其用途，你可能会感到无聊。但如果是这种情况，很可能你使用数据结构太多了！看看你以前的一些代码，并重写它以使用更多自制对象。仔细考虑各种替代方案，并尝试它们所有；哪一个使系统更易读和易维护？
- en: Always critically evaluate your code and design decisions. Make a habit of reviewing
    old code and take note if your understanding of "good design" has changed since
    you've written it. Software design has a large aesthetic component, and like artists
    with oil on canvas, we all have to find the style that suits us best.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 始终对你的代码和设计决策进行批判性评估。养成审查旧代码的习惯，并注意如果你对“良好设计”的理解自你编写代码以来有所改变。软件设计有很大的审美成分，就像带有油画的艺术家一样，我们都必须找到最适合自己的风格。
- en: Summary
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We've covered several built-in data structures and attempted to understand how
    to choose one for specific applications. Sometimes, the best thing we can do is
    create a new class of objects, but often, one of the built-ins provides exactly
    what we need. When it doesn't, we can always use inheritance or composition to
    adapt them to our use cases. We can even override special methods to completely
    change the behavior of built-in syntaxes.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了几种内置数据结构，并试图了解如何为特定应用程序选择其中一种。有时，我们能做的最好的事情就是创建一类新的对象，但通常情况下，内置的数据结构提供了我们需要的东西。当它不提供时，我们总是可以使用继承或组合来使它们适应我们的用例。我们甚至可以重写特殊方法来完全改变内置语法的行为。
- en: In the next chapter, we'll discuss how to integrate the object-oriented and
    not-so-object-oriented aspects of Python. Along the way, we'll discover that it's
    more object-oriented than it looks at first sight!
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何整合Python的面向对象和非面向对象的方面。在此过程中，我们将发现它比乍一看更面向对象化！
