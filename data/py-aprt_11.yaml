- en: Chapter 6 – Exceptions
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6章 - 异常
- en: Exception handling is a mechanism for halting “normal” program flow and continuing
    at some surrounding context or code block.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理是一种停止“正常”程序流程并在某个周围上下文或代码块中继续的机制。
- en: The act of interrupting normal flow is called “raising” an exception. In some
    enclosing context the raised exception must be *handled*, which means control
    flow is transferred to an exception handler. If an exception propagates up the
    call stack to the start of the program, then an unhandled exception will cause
    the program to terminate. An exception object, containing information about where
    and why an exceptional event occurred, is transported from the point at which
    the exception was raised to the exception handler so that the handler can interrogate
    the exception object and take appropriate action.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 中断正常流程的行为称为“引发”异常。在某个封闭的上下文中，引发的异常必须被*处理*，这意味着控制流被转移到异常处理程序。如果异常传播到程序的起始点，那么未处理的异常将导致程序终止。异常对象包含有关异常事件发生的位置和原因的信息，被从引发异常的点传输到异常处理程序，以便处理程序可以询问异常对象并采取适当的行动。
- en: If you’ve used exceptions in other popular imperative languages like C++ or
    Java, then you’ve already got a good idea of how exceptions work in Python.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经在其他流行的命令式语言（如C++或Java）中使用过异常，那么您已经对Python中异常的工作原理有了一个很好的了解。
- en: There have been long and tiresome debates over exactly what constitutes an “exceptional
    event”, the core issue being that exceptionality is in reality a matter of degree
    (some things are more exceptional than others). This is problematic because programming
    languages impose a false dichotomy by insisting that an event is either entirely
    exceptional or not at all exceptional.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 关于什么构成“异常事件”的长期而令人厌倦的辩论一直存在，核心问题是异常性实际上是一个程度的问题（有些事情比其他事情更异常）。这是有问题的，因为编程语言通过坚持事件要么完全异常要么根本不异常的假二分法来强加了一个错误的二分法。
- en: The Python philosophy is at the liberal end of the spectrum when it comes to
    the use of exceptions. Exceptions are ubiquitous in Python, and it’s crucial to
    understand how to handle them.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Python的哲学在使用异常方面处于自由的一端。异常在Python中无处不在，了解如何处理异常至关重要。
- en: Exceptions and control flow
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异常和控制流
- en: 'Since exceptions are a means of control flow, they can be clumsy to demonstrate
    at the REPL, so in this chapter we’ll be using a Python module to contain our
    code. Let’s start with a very simple module we can use for exploring these important
    concepts and behaviors. Place this code in a module called `exceptional.py`:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 由于异常是一种控制流的手段，在REPL中演示可能会很笨拙，因此在本章中，我们将使用Python模块来包含我们的代码。让我们从一个非常简单的模块开始，以便探索这些重要的概念和行为。将以下代码放入名为`exceptional.py`的模块中：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Import the `convert()` function from this module into the Python REPL:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 将此模块中的`convert()`函数导入Python REPL中：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'and call our function with a string to see that it has the desired effect:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 并使用一个字符串调用我们的函数，以查看它是否产生了预期的效果：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we call our function with an object that can’t be converted to an integer,
    we get a traceback from the `int()` call:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用无法转换为整数的对象调用我们的函数，我们将从`int()`调用中获得一个回溯：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: What’s happened here is that `int()` *raised* an exception because it couldn’t
    sensibly perform the conversion. We didn’t have a handler in place, so it was
    caught by the REPL and the stack trace was displayed. In other words, the exception
    went unhandled.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的是`int()`引发了一个异常，因为它无法合理地执行转换。我们没有设置处理程序，所以它被REPL捕获并显示了堆栈跟踪。换句话说，异常未被处理。
- en: 'The `ValueError` referred to in the stack trace is the *type* of the exception
    object, and the error message `"invalid literal for int() with base 10: ''hedgehog''"`
    is part of the payload of the exception object that has been retrieved and printed
    by the REPL.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '堆栈跟踪中提到的`ValueError`是异常对象的*类型*，错误消息`"invalid literal for int() with base 10:
    ''hedgehog''"`是异常对象的有效负载的一部分，已被REPL检索并打印。'
- en: 'Notice that the exception propagates across several levels in the call stack:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，异常在调用堆栈中传播了几个级别：
- en: '| Call stack | Effect |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 调用堆栈 | 效果 |'
- en: '| --- | --- |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `int()` | exception raised here |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `int()` | 异常在此引发 |'
- en: '| `convert()` | exception conceptually passes through here |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `convert()` | 异常在这里概念上通过 |'
- en: '| REPL | exception caught here |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| REPL | 异常在这里被捕获 |'
- en: Handling exceptions
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理异常
- en: 'Let’s make our `convert()` function more robust by handling the `ValueError`
    using a `try` .. `except` construct. Both the `try` and `except` keywords introduce
    new blocks. The `try` block contains code that could raise an exception and the
    `except` block contains the code which performs error handling in the event that
    an exception is raised. Modify the `convert()` function to look like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用`try`..`except`结构来使我们的`convert()`函数更加健壮，处理`ValueError`。`try`和`except`关键字都引入了新的代码块。`try`块包含可能引发异常的代码，`except`块包含在引发异常时执行错误处理的代码。修改`convert()`函数如下：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We have decided that if a non-integer string is supplied, we’ll return minus
    one. To reinforce your understanding of the control-flow here we’ll also add a
    couple of print statements:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经决定，如果提供了一个非整数字符串，我们将返回负一。为了加强您对控制流的理解，我们还将添加一些打印语句：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let’s test this interactively after restarting the REPL:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在重新启动REPL后进行交互式测试：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note how the `print()` in the `try` block after the point at which the exception
    was raised was *not* executed when we passed in `'giraffe'` as the function argument.
    Instead, execution was transferred directly to the first statement of the `except`
    block.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们将'giraffe'作为函数参数传递时，`try`块中在引发异常后的`print()`*没有*被执行。相反，执行直接转移到了`except`块的第一条语句。
- en: 'The `int()` constructor only accepts numbers or strings, so let’s see what
    happens if we feed an object of another type into it, say a list:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`int()`构造函数只接受数字或字符串，所以让我们看看如果我们将另一种类型的对象，比如列表，传递给它会发生什么：'
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This time our handler didn’t intercept the exception. If we look closely at
    the trace, we can see that this time we received a `TypeError` – a different type
    of exception.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们的处理程序没有拦截异常。如果我们仔细看跟踪，我们会发现这次我们收到了一个`TypeError` - 一种不同类型的异常。
- en: Handling multiple exceptions
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理多个异常
- en: 'Each `try` block can have multiple corresponding `except` blocks which intercept
    exceptions of different types. Let’s add a handler for `TypeError` too:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`try`块可以有多个对应的`except`块，拦截不同类型的异常。让我们也为`TypeError`添加一个处理程序：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now if we re-run the same test in a fresh REPL we find that `TypeError` is
    handled too:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们在一个新的REPL中重新运行相同的测试，我们会发现`TypeError`也被处理了：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We’ve got some code duplication between our two exception handlers with that
    duplicated `print` statement and assignment. We’ll move the assignment in front
    of the `try` block, which doesn’t change the behavior of the program:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的两个异常处理程序之间存在一些代码重复，有重复的`print`语句和赋值。我们将赋值移到`try`块的前面，这不会改变程序的行为：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then we’ll exploit the fact that both handlers do the same thing by collapsing
    them into one, using the ability of the `except` statement to accept a tuple of
    exception types:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将利用`except`语句接受异常类型元组的能力，将两个处理程序合并为一个：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now we see that everything still works as designed:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到一切仍然按设计工作：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Programmer errors
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 程序员错误
- en: 'Now that we’re confident with the control flow for exception behavior, we can
    remove the print statements:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们对异常行为的控制流感到自信，我们可以删除打印语句了：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'But now when we try to import our program:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 但是现在当我们尝试导入我们的程序时：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: we get yet another type of exception, an `IndentationError`, because our `except`
    block is now empty and empty blocks are not permitted in Python programs.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了另一种类型的异常，一个`IndentationError`，因为我们的`except`块现在是空的，Python程序中不允许空块。
- en: This is not an exception type that is *ever* useful to catch with an `except`
    block! Almost anything that goes wrong with a Python program results in an exception,
    but some exception types, such as `IndentationError`, `SyntaxError` and `NameError`,
    are the result of programmer errors which should be identified and corrected during
    development rather than handled at runtime. The fact that these things are exceptions
    is mostly useful if you’re creating a Python development tool such as a Python
    IDE, embedding Python itself in a larger system to support application scripting,
    or designing a plugin system which dynamically loads code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个*有用*的异常类型，可以用`except`块捕获！Python程序出现的几乎所有问题都会导致异常，但某些异常类型，比如`IndentationError`、`SyntaxError`和`NameError`，是程序员错误的结果，应该在开发过程中被识别和纠正，而不是在运行时处理。这些异常的存在大多数情况下是有用的，如果你正在创建一个Python开发工具，比如Python
    IDE，将Python本身嵌入到一个更大的系统中以支持应用程序脚本，或者设计一个动态加载代码的插件系统。
- en: Empty blocks – the `pass` statement
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空块 - `pass`语句
- en: 'With that said, we still have the problem of what to do with our empty `except`
    block. The solution arrives in the form of the `pass` keyword, which is a special
    statement that does precisely nothing! It’s a no-op, and it’s only purpose is
    to allow us to construct syntactically permissible blocks that are semantically
    empty:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们仍然有一个问题，那就是如何处理我们的空`except`块。解决方案以`pass`关键字的形式出现，这是一个什么都不做的特殊语句！它是一个空操作，它的唯一目的是允许我们构造在语法上允许但在语义上为空的块：
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this case though, it would be better to simplify further by using multiple
    `return` statements, doing away with the `x` variable completely:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，在这种情况下，通过使用多个`return`语句进一步简化会更好，完全摆脱`x`变量：
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Exception objects
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异常对象
- en: 'Sometimes, we’d like to get hold of the exception object – in this case an
    object of type `ValueError` or `TypeError` - and interrogate it for more details
    of what went wrong. We can get a named reference to the exception object by tacking
    an `as` clause onto the end of the `except` statement with a variable name that
    will be bound to the exception object:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们想要获取异常对象 - 在这种情况下是`ValueError`或`TypeError`类型的对象，并对其进行详细的询问出了什么问题。我们可以通过在`except`语句的末尾添加一个`as`子句并使用一个变量名来获得对异常对象的命名引用：
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We’ll modify our function to print a message with exception details to the
    `stderr` stream before returning. To print to `stderr` we need to get a reference
    to the stream from the `sys` module, so at the top of our module we’ll need to
    `import sys`. We can then pass `sys.stderr` as a keyword argument called `file`
    to `print()`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改我们的函数，在返回之前向`stderr`流打印异常详细信息的消息。要打印到`stderr`，我们需要从`sys`模块中获取对流的引用，所以在我们的模块顶部，我们需要`import
    sys`。然后我们可以将`sys.stderr`作为一个名为`file`的关键字参数传递给`print()`：
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We take advantage of the fact that exception objects can be converted to strings
    using the `str()` constructor.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用异常对象可以使用`str()`构造函数转换为字符串的事实。
- en: 'Let’s see that at the REPL:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在REPL中看看：
- en: '[PRE19]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Imprudent return codes
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 轻率的返回代码
- en: 'Let’s add a second function, `string_log()` to our module, which calls our
    `convert()` function and computes the natural log of the result:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的模块中添加第二个函数`string_log()`，它调用我们的`convert()`函数并计算结果的自然对数：
- en: '[PRE20]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'At this point we must confess that we’ve gone out of our way here to be deeply
    unPythonic by wrapping the perfectly good `int()` conversion, which raises exceptions
    on failure, in our `convert()` function which returns a good old-fashioned negative
    error code. Rest assured that this unforgivable Python heresy has been committed
    solely to demonstrate the greatest folly of error return codes: That they can
    be ignored by the caller, wreaking havoc amongst unsuspecting code later in the
    program. A slightly better program might test the value of `v` before proceeding
    to the log call.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们必须承认，我们在这里通过将完全正常的`int()`转换（在失败时引发异常）包装在我们的`convert()`函数中，返回一个老式的负错误代码，这是非常不符合Python风格的。请放心，这种不可饶恕的Python异端行为仅仅是为了展示错误返回代码的最大愚蠢：它们可以被调用者忽略，在程序的后期对毫无戒心的代码造成严重破坏。稍微好一点的程序可能会在继续进行日志调用之前测试`v`的值。
- en: 'Without such a check `log()` will of course fail when passed the negative error
    code value:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有这样的检查，当传递负错误代码值时，`log()`当然会失败：
- en: '[PRE21]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Naturally, the consequence of the `log()` failure is the raising of another
    exception, also a `ValueError`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`log()`失败的后果是引发另一个异常，也是`ValueError`。
- en: Much better, and altogether more Pythonic, to forget about error return codes
    completely and revert to raising an exception from `convert()`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 更好，而且更符合Python风格的是，完全忘记错误返回代码，并恢复到从`convert()`引发异常。
- en: Re-raising exceptions
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新引发异常
- en: 'Instead of returning an unPythonic error code, we can emit our error message
    and re-raise the exception object we’re currently handling. This can be done by
    replacing the `return -1` with a `raise` statement at the end of our exception
    handling block:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以发出我们的错误消息并重新引发我们当前正在处理的异常对象，而不是返回一个非Python风格的错误代码。这可以通过在我们的异常处理块的末尾用`raise`语句替换`return
    -1`来完成：
- en: '[PRE22]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Without a parameter `raise` re-raises the exception that is currently being
    handled.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 没有参数`raise`重新引发当前正在处理的异常。
- en: 'Testing in the REPL, we can see that the original exception type is re-raised
    whether it’s a `ValueError` or a `TypeError`, and our “Conversion error” message
    is printed to `stderr` along the way:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在REPL中进行测试，我们可以看到原始异常类型被重新引发，无论是`ValueError`还是`TypeError`，我们的“Conversion error”消息都会打印到`stderr`：
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Exceptions are part of your function’s API
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异常是函数API的一部分
- en: Exceptions are an important aspect of the API of a function. Callers of a function
    need to know which exceptions to expect under various conditions so that they
    can ensure appropriate exception handlers are in place. We’ll use square-root
    finding as an example, using a home-grown square-root function, courtesy of Heron
    of Alexandria (although he probably didn’t use Python).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是函数API的重要组成部分。函数的调用者需要知道在各种条件下期望哪些异常，以便他们可以确保适当的异常处理程序已经就位。我们将使用寻找平方根作为示例，使用一个自制的平方根函数，由亚历山大的赫罗（尽管他可能没有使用Python）提供。
- en: '![Callers of a function need to know which exceptions to expect.](images/m06----callers-need-to-know.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![函数的调用者需要知道期望哪些异常。](images/m06----callers-need-to-know.png)'
- en: Callers of a function need to know which exceptions to expect.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的调用者需要知道期望哪些异常。
- en: 'Place the following code in a file `roots.py`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码放入一个名为`roots.py`的文件中：
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'There’s only one language feature in this program we haven’t met before: The
    logical `and` operator which we use in this case to test that two conditions are
    `True` on each iteration of the loop. Python also includes a logical `or` operator
    which can be used to test whether either or both of its operands are `True`.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们之前没有遇到过的只有一个语言特性：逻辑`and`运算符，我们在这种情况下使用它来测试循环的每次迭代上两个条件是否为`True`。Python还包括一个逻辑`or`运算符，它可以用来测试它的操作数是否一个或两个都为`True`。
- en: 'Running our program, we can see that Heron was really on to something:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们的程序，我们可以看到赫罗是真的有所发现：
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Exceptions raised by Python
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Python引发的异常
- en: 'Let’s add a new line to the `main()` function which takes the square-root of
    -1:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`main()`函数中添加一行新代码，它对-1进行平方根运算：
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we run that, we get a new exception:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行它，我们会得到一个新的异常：
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: What has happened is that Python has intercepted a division by zero, which occurs
    on the second iteration of the loop, and raised an exception – a `ZeroDivisionError`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的情况是Python拦截了除零，这发生在循环的第二次迭代中，并引发了一个异常-`ZeroDivisionError`。
- en: Catching exceptions
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 捕获异常
- en: 'Let’s modify our code to catch the exception before it propagates up to the
    top of the call stack (thereby causing our program to stop) using the `try` ..
    `except` construct:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我们的代码，在异常传播到调用堆栈的顶部之前捕获异常（从而导致我们的程序停止），使用`try`..`except`结构：
- en: '[PRE28]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now when we run the script we see that we’re handling the exception cleanly:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们运行脚本时，我们看到我们干净地处理了异常：
- en: '[PRE29]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We should be careful to avoid a beginners mistake of having too-tight scopes
    for exception handling blocks; we can easily use one `try` .. `except` block for
    all of our calls to `sqrt()`. We also add a third print statement to show how
    execution of the enclosed block is terminated:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该小心避免初学者在异常处理块中使用过于严格的范围的错误；我们可以很容易地对我们所有对`sqrt()`的调用使用一个`try`..`except`块。我们还添加了第三个打印语句，以显示封闭块的执行是如何终止的：
- en: '[PRE30]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Raising exceptions explicitly
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 显式引发异常
- en: This is an improvement on what we started with, but most likely users of a `sqrt()`
    function don’t expect it to throw a `ZeroDivisionError`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对我们开始的改进，但最有可能`sqrt()`函数的用户不希望它抛出`ZeroDivisionError`。
- en: Python provides us with several standard exception types to signal common errors.
    If a function parameter is supplied with an illegal value, it is customary to
    raise a `ValueError`. We can do this by using the `raise` keyword with a newly
    created exception object which we can create by calling the `ValueError` constructor.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Python为我们提供了几种标准的异常类型来表示常见的错误。如果函数参数提供了非法值，习惯上会引发`ValueError`。我们可以通过使用`raise`关键字和通过调用`ValueError`构造函数创建的新异常对象来实现这一点。
- en: There are two ways in which we could deal with the division by zero. The first
    approach would be to wrap the root-finding while-loop in a `try` .. `except ZeroDivisionError`
    construct and then raise a new `ValueError` exception from inside the exception
    handler.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以处理除零的两种方法。第一种方法是将寻找平方根的while循环包装在`try`..`except ZeroDivisionError`结构中，然后在异常处理程序内部引发一个新的`ValueError`异常。
- en: '[PRE31]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: While it works, this would be wasteful; we would knowingly proceed with a non-trivial
    computation which will ultimately be pointless.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它可以工作，但这将是浪费的；我们会明知道继续进行一个最终毫无意义的非平凡计算。
- en: '![](images/m06----wasteful.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](images/m06----wasteful.png)'
- en: Guard clauses
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 守卫子句
- en: 'We know this routine will always fail with negative numbers so we can detect
    this precondition early on and raise an exception at that point, a technique called
    a *guard clause*:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道这个例程总是会失败，所以我们可以在早期检测到这个前提条件，并在那一点上引发异常，这种技术称为*守卫子句*：
- en: '[PRE32]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The test is a simple if-statement and a call to `raise` passing a newly minted
    exception object. The `ValueError()` constructor accepts an error message. See
    how we also modify the docstring to make it plain which exception type will be
    raised by `sqrt()` and under what circumstances.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是一个简单的if语句和一个调用`raise`传递一个新铸造的异常对象。`ValueError()`构造函数接受一个错误消息。看看我们如何修改文档字符串，以明确`sqrt()`将引发哪种异常类型以及在什么情况下。
- en: 'But look what happens if we run the program – we’re still getting a traceback
    and an ungraceful program exit:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 但是看看如果我们运行程序会发生什么-我们仍然会得到一个回溯和一个不优雅的程序退出：
- en: '[PRE33]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This happens because we forgot to modify our exception handler to catch `ValueError`
    rather than `ZeroDivisionError`. Let’s modify our calling code to catch the right
    exception class and also assign the caught exception object to a named variable
    so we can interrogate it after it has been caught. In this case our interrogation
    is to `print` the exception object, which knows how to display itself as the message
    to stderr:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们忘记修改我们的异常处理程序来捕获`ValueError`而不是`ZeroDivisionError`。让我们修改我们的调用代码来捕获正确的异常类，并将捕获的异常对象分配给一个命名变量，这样我们就可以在捕获后对其进行询问。在这种情况下，我们的询问是`print`异常对象，它知道如何将自己显示为stderr的消息：
- en: '[PRE34]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Running the program again, we can see that our exception is being gracefully
    handled:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行程序，我们可以看到我们的异常被优雅地处理了：
- en: '[PRE35]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Exceptions, APIs, and protocols
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异常、API和协议
- en: Exceptions are part of a function’s API, and more broadly are part of certain
    *protocols*. For example, objects which implement the sequence protocol should
    raise an `IndexError` exception for indices which are out of range.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是函数的API的一部分，更广泛地说，是某些*协议*的一部分。例如，实现序列协议的对象应该为超出范围的索引引发`IndexError`异常。
- en: The exceptions which are raised are as much a part of a function’s specification
    as the arguments it accepts and must be documented appropriately.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 引发的异常与函数的参数一样，是函数规范的一部分，必须适当地记录。
- en: There are a handful of common exception types in Python, and usually when you
    need to raise an exception in your own code, one of the built-in types is a good
    choice. Much more rarely, you’ll need to define new exception types, but we don’t
    cover that in this book. (See the next book in this series *The Python Journeyman*
    for how to do that.)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Python中有几种常见的异常类型，通常当您需要在自己的代码中引发异常时，内置类型之一是一个不错的选择。更少见的是，您需要定义新的异常类型，但我们在本书中没有涵盖这一点。（请参阅本系列的下一本书*Python
    Journeyman*，了解如何做到这一点。）
- en: 'If you’re deciding which exceptions your code should raise, you should look
    for similar cases in existing code. The more your code follows existing patterns,
    the easier it will be for people to integrate and understand. For example, suppose
    you were writing a key-value database: it would be natural to use `KeyError` to
    indicate a request for a non-existent key because this is how `dict` works. Which
    is to say that “mapping” collections in Python follows certain protocols, and
    exceptions are part of those protocols.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您决定您的代码应该引发哪些异常，您应该在现有代码中寻找类似的情况。您的代码遵循现有模式的越多，人们集成和理解起来就越容易。例如，假设您正在编写一个键值数据库：使用`KeyError`来指示对不存在的键的请求是很自然的，因为这是`dict`的工作方式。也就是说，Python中的“映射”集合遵循某些协议，异常是这些协议的一部分。
- en: Let’s look at a few common exception types.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些常见的异常类型。
- en: IndexError
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: IndexError
- en: An `IndexError` is raised when an integer index is out of range.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当整数索引超出范围时，会引发`IndexError`。
- en: 'You can see this when you index past the end of a list:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在列表末尾索引时，您可以看到这一点：
- en: '[PRE36]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ValueError
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ValueError
- en: A `ValueError` is raised when an object is of the right type, but contains an
    inappropriate value.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象的类型正确，但包含不适当的值时，会引发`ValueError`。
- en: 'We’ve seen this already when trying to construct an `int` from a non-numeric
    string:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试从非数字字符串构造`int`时，我们已经看到了这一点：
- en: '[PRE37]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: KeyError
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: KeyError
- en: A `KeyError` is raised when a look-up in a mapping fails.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当查找映射失败时，会引发`KeyError`。
- en: 'You can see that here when we look up a non-existent key in a dict:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里看到，当我们在字典中查找一个不存在的键时：
- en: '[PRE38]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Choosing not to guard against `TypeError`
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择不防范`TypeError`
- en: We tend not to protect against `TypeErrors` in Python. To do so runs against
    the grain of dynamic typing in Python and limits the re-use potential of code
    we write.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不倾向于保护Python中的`TypeErrors`。这样做违反了Python中的动态类型的规则，并限制了我们编写的代码的重用潜力。
- en: 'For example, we could test whether the argument was an `str` using the built-in
    `isinstance()` function and raise a `TypeError` exception if it was not:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用内置的`isinstance()`函数测试参数是否为`str`，如果不是，则引发`TypeError`异常：
- en: '[PRE39]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: But then we’d also want to allow arguments that are instances of `float` as
    well. It soon gets complicated if we want to check whether our function will work
    with types such as rational, complex, or any other kind of number, and in any
    case, who is to say that it does?!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们还希望允许作为`float`实例的参数。如果我们想要检查我们的函数是否能够处理诸如有理数、复数或任何其他类型的数字的类型，情况很快就会变得复杂，而且无论如何，谁能说它会呢？！
- en: Alternatively we could intercept `TypeError` inside our function and re-raise
    it, but to what end?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以在函数内部拦截`TypeError`并重新引发它，但是有什么意义呢？
- en: '![Don''t usually bother to handle TypeErrors.](images/m06----just-let-it-fail.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![通常不必处理TypeErrors。](images/m06----just-let-it-fail.png)'
- en: Don’t usually bother to handle TypeErrors.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通常不必处理TypeErrors。
- en: Usually in Python it’s not worth adding type checking to your functions. If
    a function works with a particular type – even one you couldn’t have known about
    when you designed the function – then that’s all to the good. If not, execution
    will probably result in a `TypeError` anyway. Likewise, we tend not to *catch*
    `TypeErrors` with except blocks very frequently.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在Python中，向函数添加类型检查是不值得的。如果函数使用特定类型-即使是您在设计函数时可能不知道的类型-那就太好了。如果不是，执行可能最终会导致`TypeError`。同样，我们往往不会非常频繁地*捕获*`TypeErrors`。
- en: Pythonic style – EAFP versus LBYL
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pythonic风格- EAFP与LBYL
- en: Now let’s look at another tenet of Python philosophy and culture, the idea that
    “It’s Easier to Ask for Forgiveness than for Permission”.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看Python哲学和文化的另一个原则，即“宁求原谅，不要问权限”。
- en: There are only two approaches to dealing with a program operation that might
    fail. The first approach is to check that all the preconditions for a failure
    prone operation are met in advance of attempting the operation. The second approach
    is to blindly hope for the best, but be prepared to deal with the consequences
    if it doesn’t work out.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 处理可能失败的程序操作只有两种方法。第一种方法是在尝试操作之前检查所有易于失败的操作的前提条件是否满足。第二种方法是盲目地希望一切顺利，但准备好处理后果如果事情不顺利。
- en: In Python culture these two philosophies are known as “Look Before you Leap”
    (LBYL) and its “Easier to Ask for Forgiveness than for Permission” (EAFP) – which,
    incidentally, was coined by Rear Admiral Grace Hopper, inventor of the compiler.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python文化中，这两种哲学被称为“先入为主”（LBYL）和“宁求原谅，不要问权限”（EAFP）-顺便说一句，这是由编译器发明者Grace Hopper女将军创造的。
- en: Python is strongly in favor of EAFP because it puts primary logic for the “happy
    path” in its most readable form, with deviations from the normal flow handled
    separately, rather than interspersed with the main flow.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Python强烈支持EAFP，因为它将“快乐路径”的主要逻辑以最可读的形式呈现，而与主要流程交织在一起的异常情况则单独处理。
- en: Let’s consider an example – processing a file. The details of the processing
    aren’t relevant. All we need to know is that the `process_file()` function will
    open a file and read some data from it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子-处理一个文件。处理的细节并不重要。我们只需要知道`process_file()`函数将打开一个文件并从中读取一些数据。
- en: 'First, the LBYL version:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是LBYL版本：
- en: '[PRE40]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Before attempting to call `process_file()` we check that the file exists, and
    if it doesn’t we avoid making the call and print a helpful message instead. There
    are several problems with this approach, some obvious and some insidious. One
    obvious problem is that we only perform an existence check. What if the file exists
    but contains garbage? What if the path refers to a directory instead of a file?
    According to LBYL we should add preemptive tests for those too.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试调用`process_file()`之前，我们检查文件是否存在，如果不存在，我们避免调用并打印一条有用的消息。这种方法存在一些明显的问题，有些是显而易见的，有些是隐匿的。一个明显的问题是我们只执行了存在性检查。如果文件存在但包含垃圾怎么办？如果路径指的是一个目录而不是一个文件怎么办？根据LBYL，我们应该为这些情况添加预防性测试。
- en: A more subtle problem is that there is a race condition here. It’s possible
    for the file to be deleted, for example by another process, *between* the existence
    check and the `process_file()` call … a classic race condition. There’s really
    no good way to deal with this – handling of errors from `process_file()` will
    be needed in any case!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更微妙的问题是这里存在竞争条件。例如，文件可能在存在性检查和`process_file()`调用之间被另一个进程删除……这是一个经典的竞争条件。实际上没有好的方法来处理这个问题-无论如何都需要处理`process_file()`的错误！
- en: 'Now consider the alternative, using the more Pythonic EAFP approach:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑另一种选择，使用更符合Python风格的EAFP方法：
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this version we attempt the operation without checks in advance, but we have
    an exception handler in place to deal with any problems. We don’t even need to
    know in a lot of detail exactly what might go wrong. Here we catch `OSError` which
    covers all manner of conditions such as file-not-found and using directories where
    files are expected.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，我们尝试在事先不进行检查的情况下进行操作，但我们已经准备好了异常处理程序来处理任何问题。我们甚至不需要详细了解可能出现的问题。在这里，我们捕获了`OSError`，它涵盖了各种条件，比如文件未找到以及在期望文件的位置使用目录。
- en: EAFP is standard in Python, and following that philosophy is primarily facilitated
    by exceptions. Without exceptions, and being forced to use error codes instead,
    you are required to include error handling directly in the main flow of the logic.
    Since exceptions interrupt the main flow, they allow you to handle exceptional
    cases non-locally.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: EAFP在Python中是标准的，遵循这种哲学主要是通过异常来实现的。没有异常，并且被迫使用错误代码，你需要直接在逻辑的主流程中包含错误处理。由于异常中断了主流程，它们允许你非局部地处理异常情况。
- en: Exceptions coupled with EAFP are also superior because, unlike error codes,
    *exceptions cannot be easily ignored*. By default exceptions have a big effect,
    whereas error codes are silent by default. So the exception-/EAFP-based style
    makes it very difficult for problems to be silently ignored.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 异常与EAFP结合也更优越，因为与错误代码不同，*异常不能轻易被忽略*。默认情况下，异常会产生很大影响，而错误代码默认情况下是静默的。因此，基于异常/EAFP的风格使问题很难被悄悄忽略。
- en: Clean-up actions
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清理操作
- en: Sometimes you need to perform a clean-up action irrespective of whether an operation
    succeeds. In a later module we’ll introduce context managers which are the modern
    solution to this common situation, but here we’ll introduce the `try` .. `finally`
    construct, since creating a context manager can be overkill in simple cases. In
    any case, an understanding of `try` .. `finally` is useful for making your own
    context managers.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要执行一个清理操作，无论操作是否成功。在后面的模块中，我们将介绍上下文管理器，这是这种常见情况的现代解决方案，但在这里我们将介绍`try`..`finally`结构，因为在简单情况下创建上下文管理器可能有些过头。无论如何，了解`try`..`finally`对于制作自己的上下文管理器是有用的。
- en: 'Consider this function, which uses various facilities of the standard library
    `os` module to change the current working directory, create a new directory at
    that location, and then restore the original working directory:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个函数，它使用标准库`os`模块的各种功能来更改当前工作目录，创建一个新目录，并恢复原始工作目录：
- en: '[PRE42]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: At first sight this seems reasonable, but should the call to `os.mkdir()` fail
    for some reason the current working directory of the Python process won’t be restored
    to it’s original value, and the `make_at()` function will have had an unintended
    side-effect.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这似乎是合理的，但是如果`os.mkdir()`的调用因某种原因失败，Python进程的当前工作目录将不会恢复到其原始值，并且`make_at()`函数将产生意外的副作用。
- en: To fix this, we’d like the function to restore the original current working
    directory under all circumstances. We can achieve this with a `try` .. `finally`
    block. Code in the `finally` block is executed whether execution leaves the `try`
    block normally by reaching the end of the block, or exceptionally by an exception
    being raised.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们希望函数在任何情况下都能恢复原始的当前工作目录。我们可以通过`try`..`finally`块来实现这一点。`finally`块中的代码将被执行，无论执行是通过到达块的末尾而正常离开`try`块，还是通过引发异常而异常地离开。
- en: 'This construct can be combined with `except` blocks, used below to add a simple
    failure logging facility:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构可以与`except`块结合在一起，如下所示，用于添加一个简单的失败日志记录设施：
- en: '[PRE43]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now, if `os.mkdir()` raises an `OSError`, the `OSError` handler will be run
    and the exception will be re-raised. But since the `finally` block is always run
    no matter how the try-block ends, we can be sure that the final directory change
    will take place in all circumstances.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果`os.mkdir()`引发`OSError`，则将运行`OSError`处理程序并重新引发异常。但由于`finally`块始终运行，无论try块如何结束，我们可以确保最终的目录更改将在所有情况下发生。
- en: '* * *'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Moment of zen
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 禅意时刻
- en: '![](images/m06----zen-errors-should-never-pass-silently.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](images/m06----zen-errors-should-never-pass-silently.png)'
- en: '* * *'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Platform-specific code
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特定于平台的代码
- en: Detecting a single keypress from Python – such as the “Press any key to continue.”
    functionality at the console – requires use of operating system specific modules.
    We can’t use the built-in `input()` function, because that waits for the user
    to press *Enter* before giving us a string. To implement this on Windows we need
    to use functionality from the Windows-only `msvcrt` module, and on Linux and macOS
    we need to use functionality from the Unix-only `tty` and `termios` modules, in
    addition to the `sys` module.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 从Python中检测单个按键 - 例如在控制台上的“按任意键继续。”功能 - 需要使用特定于操作系统的模块。我们不能使用内置的`input()`函数，因为它等待用户按*Enter*键然后给我们一个字符串。要在Windows上实现这一点，我们需要使用仅限于Windows的`msvcrt`模块的功能，在Linux和macOS上，我们需要使用仅限于Unix的`tty`和`termios`模块的功能，以及`sys`模块。
- en: 'This example is quite instructive as it demonstrates many Python language features
    including `import` and `def` as *statements*, as opposed to merely declarations:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子非常有教育意义，因为它演示了许多Python语言特性，包括`import`和`def`作为*语句*，而不仅仅是声明：
- en: '[PRE44]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Recall that top-level module code is executed on first import. Within the first
    try-block we attempt to `import msvcrt`, the Microsoft Visual C Runtime. If this
    succeeds, we then proceed to define a function `getkey()` which delegates to the
    `msvcrt.getch()` function. Even though we’re inside a try-block at this point
    the function will be declared at the current scope, which is the module scope.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，顶层模块代码在首次导入时执行。在第一个try块中，我们尝试`import msvcrt`，即Microsoft Visual C Runtime。如果成功，然后我们继续定义一个名为`getkey()`的函数，该函数委托给`msvcrt.getch()`函数。即使在这一点上我们在try块内部，该函数也将在当前范围内声明，即模块范围。
- en: If, however, the import of `msvcrt` fails, because we’re not running on Windows,
    an `ImportError` will be raised and execution will transfer to the except-block.
    This is a case of an error being silenced explicitly, because we’re going to attempt
    an alternative course of action in the exception handler.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果`msvcrt`的导入失败，因为我们不在Windows上运行，将引发`ImportError`，并且执行将转移到except块。这是一个明确消除错误的情况，因为我们将尝试在异常处理程序中采取替代行动。
- en: Within the except-block we import three modules needed for a `getkey()` implementation
    on Unix-like systems and then proceed to the alternative definition of `getkey()`
    which again binds the function implementation to a name in the module scope.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在except块内，我们导入了三个在类Unix系统上实现`getkey()`所需的模块，然后继续使用替代定义`getkey()`，再次将函数实现绑定到模块范围内的名称。
- en: This Unix implementation of `getkey()` uses a `try` .. `finally` construct to
    restore various terminal attributes after the terminal has been put into raw mode
    for the purposes of reading a single character.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Unix实现的`getkey()`使用`try`..`finally`结构，在将终端置于原始模式以读取单个字符的目的后，恢复各种终端属性。
- en: In the event that our program is running on a system that is neither Windows
    nor Unix-like, the `import tty` statement will raise a second `ImportError`. This
    time we make no attempt to intercept this exception; we allow it to propagate
    to our caller – which is whatever attempted to import this `keypress` module.
    We know how to signal this error, but not how to handle it, so we defer that decision
    to our caller. The error will not pass silently.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的程序在既不是Windows也不是类Unix的系统上运行，`import tty`语句将引发第二个`ImportError`。这次我们不尝试拦截此异常；我们允许它传播到我们的调用者
    - 无论尝试导入此`keypress`模块的是什么。我们知道如何发出此错误，但不知道如何处理它，因此我们将这个决定推迟给我们的调用者。错误不会悄悄地传递。
- en: If the caller has more knowledge or alternative tactics available, it can in
    turn intercept this exception and take appropriate action, perhaps degrading to
    using Python’s `input()` built-in function and giving a different message to the
    user.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用者具有更多的知识或可用的替代策略，它可以依次拦截此异常并采取适当的操作，也许降级到使用Python的`input()`内置函数并向用户提供不同的消息。
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: The raising of an exception interrupts normal program flow and transfers control
    to an exception handler.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引发异常会中断正常的程序流程，并将控制转移到异常处理程序。
- en: Exception handlers are defined using the `try` .. `except` construct.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理程序使用`try`..`except`结构定义。
- en: '`try` blocks define a context in which exceptions can be detected.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try`块定义了可以检测异常的上下文。'
- en: Corresponding `except` blocks define handlers for specific types of exceptions.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相应的`except`块为特定类型的异常定义处理程序。
- en: Python uses exceptions pervasively and many built-in language features depend
    on them.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python广泛使用异常，并且许多内置语言功能依赖于它们。
- en: '`except` blocks can capture an exception object, which is often of a standard
    type such as `ValueError`, `KeyError` or `IndexError`.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`except`块可以捕获异常对象，通常是标准类型，如`ValueError`，`KeyError`或`IndexError`。'
- en: Programmer errors such as `IndentationError` and `SyntaxError` should not normally
    be handled.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序员错误，如`IndentationError`和`SyntaxError`通常不应该被处理。
- en: Exceptional conditions can be signaled using the `raise` keyword which accepts
    a single parameter of an exception object.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`raise`关键字发出异常条件，它接受异常对象的单个参数。
- en: '`raise` without an argument within an `except` block re-raises the exception
    which is currently being processed.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`except`块中没有参数的`raise`重新引发当前正在处理的异常。
- en: We tend not to routinely check for `TypeErrors`. To do so would negate the flexibility
    afforded to us by Python’s dynamic type system.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们倾向于不经常检查`TypeErrors`。这样做会否定Python动态类型系统所提供的灵活性。
- en: Exception objects can be converted to strings using the `str()` constructor
    for the purposes of printing message payloads.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常对象可以使用`str()`构造函数转换为字符串，以便打印消息载荷。
- en: The exceptions thrown by a function form part of it’s API and should be appropriately
    documented.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数抛出的异常是其API的一部分，应该得到适当的文档支持。
- en: When raising exceptions prefer to use the most appropriate built-in exception
    type.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在引发异常时，最好使用最合适的内置异常类型。
- en: Clean-up and restorative actions can be performed using the `try` .. `finally`
    construct which may optionally be used in conjunction with `except` blocks.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`try`..`finally`结构执行清理和恢复操作，这可能可以与`except`块一起使用。
- en: 'Along the way we saw that:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们看到：
- en: The output of the `print()` function can be redirected to `stderr` using the
    optional `file` argument.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print()`函数的输出可以使用可选的`file`参数重定向到`stderr`。'
- en: Python supports the logical operators `and` and `or` for combining boolean expressions.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python支持逻辑运算符`and`和`or`来组合布尔表达式。
- en: Return codes are too easily ignored.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回代码很容易被忽略。
- en: Platform specific actions can be implemented using an Easier to Ask Forgiveness
    than Permission approach facilitated by intercepting `ImportErrors` and providing
    alternative implementations.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用“宁可请求原谅，也不要问权限”的方法来实现特定于平台的操作，通过拦截`ImportErrors`并提供替代实现。
