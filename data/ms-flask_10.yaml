- en: Chapter 10. Useful Flask Extensions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章 有用的Flask扩展
- en: As we have seen throughout this book, Flask is designed to be as small as possible
    while still giving you the flexibility and tools needed to create web applications.
    However, there are a lot of features that are common to many web applications,
    which means that many applications will require writing code that does the same
    task for each web application. To solve this problem, people have created extensions
    to Flask to avoid reinventing the wheel, and we have seen many Flask extensions
    already throughout the book. This chapter will focus on some of the more useful
    Flask extensions that don't have enough content to separate them out into their
    own chapter, but will save you a lot of time and frustration.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在整本书中所看到的，Flask的设计是尽可能小，同时又给您提供了创建Web应用程序所需的灵活性和工具。然而，许多Web应用程序都具有许多共同的特性，这意味着许多应用程序将需要编写执行相同任务的代码。为了解决这个问题，人们已经为Flask创建了扩展，以避免重复造轮子，我们已经在整本书中看到了许多Flask扩展。本章将重点介绍一些更有用的Flask扩展，这些扩展内容不足以单独成章，但可以节省大量时间和烦恼。
- en: Flask Script
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flask Script
- en: In [Chapter 1](ch01.html "Chapter 1. Getting Started"), *Getting Started*, we
    created a basic manage script with the Flask extension Flask Script to allow easy
    running of the server and debugging with the shell. In this chapter, we will cover
    the features that were not covered in that basic introduction.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章 入门")中，*入门*，我们使用Flask扩展Flask Script创建了一个基本的管理脚本，以便轻松运行服务器并使用shell进行调试。在本章中，我们将介绍那些基本介绍中未涉及的功能。
- en: 'In Flask Script, you can create custom commands to be run within the application
    context. All that is needed is to create a command to decorate a normal Python
    function with a decorator function provided by Flask Script. For example, if we
    wanted a task that would return the string "Hello, World!" we would add the following
    to `manage.py`:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flask Script中，您可以创建自定义命令以在应用程序上下文中运行。所需的只是创建一个命令，用Flask Script提供的装饰器函数装饰一个普通的Python函数。例如，如果我们想要一个任务，返回字符串"Hello,
    World!"，我们将把以下内容添加到`manage.py`中：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'From the command line, the `test` command can now be run using the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行，现在可以使用以下命令运行`test`命令：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Delete the test command, and let''s create a simple command to help set up
    new developers on our application by creating their SQLite database and filling
    it with test data. This command is partially lifted from the script created in
    [Chapter 4](ch04.html "Chapter 4. Creating Controllers with Blueprints"), *Creating
    Controllers with Blueprints*:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 删除测试命令，让我们创建一个简单的命令，以帮助为我们的应用程序设置新开发人员的SQLite数据库并填充测试数据。这个命令部分地来自[第4章](ch04.html
    "第4章 创建蓝图控制器")中创建的脚本，*创建蓝图控制器*：
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now if a new developer is assigned the project, they could download the `git
    repo` from our server, install the `pip` libraries, run the `setup_db` command,
    and would be able to run the project with everything they need.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果有新的开发人员被分配到项目中，他们可以从我们的服务器下载`git repo`，安装`pip`库，运行`setup_db`命令，然后就可以运行项目了。
- en: Flask Script also provides two utility functions that can be easily added to
    our project.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Flask Script还提供了两个实用函数，可以轻松添加到我们的项目中。
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `show-urls` command lists all of the routes registered on the `app` object
    and the URL tied to that route. This is very useful while debugging Flask extensions,
    as it becomes trivial to see whether the registration of its blueprints is working
    or not. The Clean command just removes the `.pyc` and `.pyo` compiled Python files
    from our working directory.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`show-urls`命令列出了在`app`对象上注册的所有路由以及与该路由相关的URL。这在调试Flask扩展时非常有用，因为可以轻松地查看其蓝图的注册是否有效。清理命令只是从工作目录中删除`.pyc`和`.pyo`编译的Python文件。'
- en: Flask Debug Toolbar
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flask Debug Toolbar
- en: Flask Debug Toolbar is a Flask extension that aids development by adding debugging
    tools into the web view of your application. It gives you information such as
    the bottlenecks in your view rendering code, and how many SQLAlchemy queries it
    took to render the view.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Flask Debug Toolbar是一个Flask扩展，通过将调试工具添加到应用程序的Web视图中，帮助开发。它会提供一些信息，比如视图渲染代码中的瓶颈，以及渲染视图所需的SQLAlchemy查询次数。
- en: 'As always, we will use `pip` to install Flask Debug Toolbar:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们将使用`pip`来安装Flask Debug Toolbar：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we need to add Flask Debug Toolbar to the `extensions.py` file. As we
    will be modifying this file a lot in this chapter, here is the start of the file
    so far along with the code to initialize Flask Debug Toolbar:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将Flask Debug Toolbar添加到`extensions.py`文件中。由于在本章中我们将经常修改这个文件，所以以下是文件的开头以及初始化Flask
    Debug Toolbar的代码：
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, the initialization function needs to be called in our `create_app` function
    in `__init__.py`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，需要在`__init__.py`中的`create_app`函数中调用初始化函数：
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is all that is needed to get Flask Debug Toolbar up and running. If the
    `DEBUG` variable in your app's `config` is set to *true*, the toolbar will appear.
    If `DEBUG` is not set to *true*, the toolbar will not be injected into the page.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是让Flask Debug Toolbar运行起来所需的全部内容。如果应用程序的`config`中的`DEBUG`变量设置为*true*，则工具栏将显示出来。如果`DEBUG`没有设置为*true*，则工具栏将不会被注入到页面中。
- en: '![Flask Debug Toolbar](img/B03929_10_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![Flask Debug Toolbar](img/B03929_10_01.jpg)'
- en: On the right-hand side of the screen, you will see the toolbar. Each section
    is a link that will display a table of values on the page. To get a list of all
    the functions that were called in order to render the view, click the checkmark
    next to **Profiler** to enable it, reload the page, and click on **Profiler**.
    This view easily allows you to quickly diagnose which parts of your apps are the
    slowest or are called the most.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕的右侧，您将看到工具栏。每个部分都是一个链接，点击它将在页面上显示一个值表。要获取呈现视图所调用的所有函数的列表，请点击**Profiler**旁边的复选标记以启用它，重新加载页面，然后点击**Profiler**。这个视图可以让您快速诊断应用程序中哪些部分最慢或被调用最多。
- en: 'By default, Flask Debug Toolbar intercepts `HTTP 302 redirect` requests. To
    disable this, add the following to your configuration:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Flask Debug Toolbar拦截`HTTP 302重定向`请求。要禁用此功能，请将以下内容添加到您的配置中：
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Also, if you are using Flask-MongoEngine, you can view all of the queries that
    were made to render the page by overriding which panels are rendered and adding
    MongoEngine's custom panel.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果您使用Flask-MongoEngine，可以通过覆盖渲染的面板并添加MongoEngine的自定义面板来查看渲染页面时所做的所有查询。
- en: '[PRE8]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will add a panel to the toolbar that is very similar to the default SQLAlchemy
    one.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在工具栏中添加一个与默认SQLAlchemy非常相似的面板。
- en: Flask Cache
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flask Cache
- en: In [Chapter 7](ch07.html "Chapter 7. Using NoSQL with Flask"), *Using NoSQL
    with Flask*, we learned that page load time is one of the most important factors
    to determine the success of your web app. Despite the fact that our pages do not
    change very often and due to the fact that new posts will not be made very often,
    we still render the template and query the database every single time the page
    is asked for by our user's browsers.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html "第7章。使用Flask进行NoSQL")中，*使用Flask进行NoSQL*，我们了解到页面加载时间是确定您的Web应用程序成功的最重要因素之一。尽管我们的页面并不经常更改，而且由于新帖子不会经常发布，但我们仍然在用户浏览器每次请求页面时渲染模板并查询数据库。
- en: 'Flask Cache solves this problem by allowing us to store the results of our
    view functions and return the stored results rather than render the template again.
    First, we need to install Flask Cache from `pip`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Flask Cache通过允许我们存储视图函数的结果并返回存储的结果而不是再次渲染模板来解决了这个问题。首先，我们需要从`pip`安装Flask Cache：
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, initialize it in `extensions.py`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`extensions.py`中初始化它：
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, register the `Cache` object on the application, in the `create_app` function
    in `__init__.py`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`__init__.py`中的`create_app`函数中注册`Cache`对象：
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Before we can start caching our views, there is a need to tell Flash Cache how
    we want to store the results of our new functions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始缓存视图之前，需要告诉Flash Cache我们希望如何存储新函数的结果。
- en: '[PRE12]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `simple` option tells Flask Cache to store the results in memory in a Python
    dictionary, which for the vast majority of Flask apps is adequate. We'll cover
    more types of Cache backends later in this section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`simple`选项告诉Flask Cache将结果存储在Python字典中的内存中，对于绝大多数Flask应用程序来说是足够的。我们将在本节后面介绍更多类型的缓存后端。'
- en: Caching views and functions
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存视图和函数
- en: 'In order to cache the results of a view function, simply add a decorator to
    any function:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了缓存视图函数的结果，只需在任何函数上添加装饰器：
- en: '[PRE13]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `timeout` parameter specifies how many seconds the cached result should
    last before the function should be run again and stored again. To confirm that
    the view is actually being cached, check the SQLAlchemy section on the Debug Toolbar.
    Also, we can see that the impact caching has on page load times by activating
    the profiler and comparing the times before and after. On the author's top of
    the line laptop, the main blog page takes 34 ms to render, mainly due to the eight
    different queries that are made to the database. But after the cache is activated,
    this decreases to .08 ms. That's a 462.5 percent increase in speed!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeout`参数指定缓存结果在函数再次运行并再次存储之前应该持续多少秒。要确认视图实际上被缓存了，可以在调试工具栏上查看SQLAlchemy部分。此外，我们可以通过激活分析器并比较之前和之后的时间来看到缓存对页面加载时间的影响。在作者顶级的笔记本电脑上，主博客页面需要34毫秒来渲染，主要是因为对数据库进行了8次不同的查询。但在激活缓存后，这个时间减少到0.08毫秒。这是速度提高了462.5%！'
- en: 'View functions are not the only thing that can be cached. To cache any Python
    function, simply add a similar decorator to the function definition as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 视图函数并不是唯一可以被缓存的东西。要缓存任何Python函数，只需在函数定义中添加类似的装饰器：
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The keyword argument `key_prefix` is necessary for non view functions in order
    for Flask Cache to properly store the results of the function. This needs to be
    unique for every function cached, or the results of the functions will override
    each other. Also, note that the timeout for this function is set to 2 hours rather
    than the 60 seconds in the previous examples. This is because the results for
    this function are less likely to change than the view functions, and if the data
    is stale, it is not as big an issue.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数`key_prefix`对于非视图函数是必要的，以便Flask Cache正确地存储函数的结果。这需要对每个被缓存的函数都是唯一的，否则函数的结果将互相覆盖。另外，请注意，此函数的超时设置为2小时，而不是前面示例中的60秒。这是因为这个函数的结果不太可能改变，如果数据过时，这不是一个大问题。
- en: Caching functions with parameters
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带参数的函数缓存
- en: 'However, the normal cache decorator does not take function parameters into
    account. If we cached a function that took parameters with the normal cache decorator,
    it would return the same result for every parameter set. In order to fix this,
    we use the `memoize` function:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，普通的缓存装饰器不考虑函数参数。如果我们使用普通的缓存装饰器缓存了带有参数的函数，它将对每个参数集返回相同的结果。为了解决这个问题，我们使用`memoize`函数：
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`Memoize` stores the parameters passed to the function as well as the result.
    In the preceding example, `memoize` is being used to store the result of the `verify_auth_token`
    method, which is called many times and queries the database every single time.
    This method can safely be memoized because it returns the same result every time
    if the same token is passed to it. The only exception to this rule is if the user
    object gets deleted during the 60 seconds that the function is stored, but this
    is very unlikely.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`Memoize`存储传递给函数的参数以及结果。在前面的例子中，`memoize`被用来存储`verify_auth_token`方法的结果，该方法被多次调用并且每次都查询数据库。如果传递给它相同的令牌，这个方法可以安全地被记忆化，因为它每次都返回相同的结果。唯一的例外是如果用户对象在函数被存储的60秒内被删除，但这是非常不可能的。'
- en: Be careful not to `memoize` or cache functions that rely on either globally
    scoped variables or on constantly changing data. This can lead to some very subtle
    bugs, and in the worst case, data race. The best candidates for memoization are
    what are referred to as pure functions. Pure functions are functions that will
    produce the same result when the same parameters are passed to them. It does not
    matter how many times the function is run. Pure functions also do not have any
    side effects, which means that they do not change globally scoped variables. This
    also means that pure functions cannot do any IO operations. While the `verify_auth_token`
    function is not pure because it does database IO, it is ok because as was stated
    before it is very unlikely that the underlying data will change.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 小心不要对依赖于全局作用域变量或不断变化数据的函数进行`memoize`或缓存。这可能导致一些非常微妙的错误，甚至在最坏的情况下会导致数据竞争。最适合memoization的候选者是所谓的纯函数。纯函数是当传递相同的参数时将产生相同结果的函数。函数运行多少次都无所谓。纯函数也没有任何副作用，这意味着它们不会改变全局作用域变量。这也意味着纯函数不能执行任何IO操作。虽然`verify_auth_token`函数不是纯函数，因为它执行数据库IO，但这没关系，因为正如之前所述，底层数据很少会改变。
- en: 'While we are developing the application, we do not want the view functions
    to be cached because results will be changing all the time. To fix this, set the
    `CACHE_TYPE` variable to null and set the `CACHE_TYPE` variable to simple in the
    production configuration, so when the app is deployed everything works as expected:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发应用程序时，我们不希望缓存视图函数，因为结果会不断变化。为了解决这个问题，将`CACHE_TYPE`变量设置为null，并在生产配置中将`CACHE_TYPE`变量设置为simple，这样当应用程序部署时，一切都能按预期运行：
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Caching routes with query strings
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用查询字符串缓存路由
- en: 'Some routes, such as our home and `post` routes, take the parameters through
    the URL and return content specific to those parameters. We run into a problem
    if routes like these are cached, as the first rendering of the route will be returned
    for all requests regardless of the URL parameters. The solution is rather simple.
    The `key_prefix` keyword argument in the cache method can be either a string or
    a function, which will be executed to dynamically generate a key. This means that
    a function can be created to generate a key that is tied to the URL parameters,
    so each request only returns a cached page if that specific combination of parameters
    has been called before. In the `blog.py` file, add the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一些路由，比如我们的主页和`post`路由，通过URL传递参数并返回特定于这些参数的内容。如果缓存这样的路由，就会遇到问题，因为无论URL参数如何，路由的第一次渲染都将返回所有请求。解决方案相当简单。缓存方法中的`key_prefix`关键字参数可以是一个字符串或一个函数，该函数将被执行以动态生成一个键。这意味着可以创建一个函数来生成一个与URL参数相关联的键，因此只有在之前调用过具有特定参数组合的请求时，每个请求才会返回一个缓存的页面。在`blog.py`文件中，添加以下内容：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, each individual post page will be cached for 10 minutes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个单独的帖子页面将被缓存10分钟。
- en: Using Redis as a cache backend
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Redis作为缓存后端
- en: 'If the amount of view functions or the number of unique parameters passed to
    your cached functions becomes too large for memory, you can use a different backend
    for the cache. As was mentioned in [Chapter 7](ch07.html "Chapter 7. Using NoSQL
    with Flask"), *Using NoSQL with Flask*, Redis can be used as a backend for the
    cache. To implement that functionality, all that needs to be done is to add the
    following configuration variables to the `ProdConfig` class as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果视图函数的数量或传递给缓存函数的唯一参数的数量变得太大而超出内存限制，您可以使用不同的缓存后端。正如在[第7章](ch07.html "第7章。在Flask中使用NoSQL")中提到的，*在Flask中使用NoSQL*，Redis可以用作缓存的后端。要实现该功能，只需将以下配置变量添加到`ProdConfig`类中，如下所示：
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you replace the values of the variables with your own data, Flask Cache
    will automatically create a connection to your `redis` database and use it to
    store the results of the functions. All that is needed is to install the Python
    `redis` library:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用自己的数据替换变量的值，Flask Cache将自动创建到您的`redis`数据库的连接，并使用它来存储函数的结果。所需的只是安装Python `redis`库：
- en: '[PRE19]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Using memcached as a cache backend
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用memcached作为缓存后端
- en: 'Just like the `redis` backend, the `memcached` backend provides an alternative
    way of storing results if the memory option is too limiting. In contrast to `redis`,
    `memcached` is designed to `cache` objects for later use and reduce load on the
    database. Both `redis` and `memcached` can serve the same purpose, and choosing
    one over the other comes down to personal preference. To use `memcached`, we need
    to install its Python library:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与`redis`后端一样，`memcached`后端提供了一种替代的存储结果的方式，如果内存选项太过限制。与`redis`相比，`memcached`旨在缓存对象以供以后使用，并减少对数据库的负载。`redis`和`memcached`都可以达到相同的目的，选择其中一个取决于个人偏好。要使用`memcached`，我们需要安装其Python库：
- en: '[PRE20]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Connecting to your `memcached` server is handled in the configuration object,
    just like the `redis` setup:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到您的`memcached`服务器在配置对象中处理，就像`redis`设置一样：
- en: '[PRE21]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Flask Assets
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flask Assets
- en: Another bottleneck in web applications are the amount of HTTP requests required
    to download the CSS and JavaScript libraries for the page. The extra files can
    only be downloaded after HTML for the page has been loaded and parsed. To combat
    this, many modern browsers download many of these libraries at once, but there
    is a limit to how many simultaneous requests the browser makes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序中的另一个瓶颈是下载页面的CSS和JavaScript库所需的HTTP请求数量。只有在加载和解析页面的HTML之后才能下载额外的文件。为了解决这个问题，许多现代浏览器会同时下载许多这些库，但是浏览器发出的同时请求数量是有限制的。
- en: Several things can be done on the server to reduce the amount of time spent
    downloading these files. The main technique that developers use is to concatenate
    all of the JavaScript libraries into one file and all of the CSS libraries into
    another while removing all of the whitespace and carriage returns from the resulting
    files. This reduces the overhead of multiple HTTP requests, and removing the unnecessary
    whitespace and carriage returns can reduce a file's size by up to 30 percent.
    Another technique is to tell the browser to cache the files locally with specialized
    HTTP headers, so the file is only loaded again once it changes. These can be tedious
    to do manually because they need to be done after every deployment to the server.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器上可以做一些事情来减少下载这些文件所花费的时间。开发人员使用的主要技术是将所有JavaScript库连接成一个文件，将所有CSS库连接成另一个文件，同时从结果文件中删除所有空格和换行符。这样可以减少多个HTTP请求的开销，删除不必要的空格和换行符可以将文件大小减少多达30％。另一种技术是告诉浏览器使用专门的HTTP头在本地缓存文件，因此文件只有在更改后才会再次加载。这些手动操作可能很繁琐，因为它们需要在每次部署到服务器后进行。
- en: 'Thankfully, Flask Assets implements all the above techniques. Flask Assets
    works by giving it a list of files and a way to concatenate them, and then adding
    a special control block into your templates in place of the normal link and script
    tags. Flask Assets will then add in a link or a script tag that links to the newly
    generated file. To get started, Flask Assets needs to be installed. We also need
    to install `cssmin` and `jsmin`, which are Python libraries that handle the modification
    of the files:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Flask Assets实现了上述所有技术。Flask Assets通过给它一个文件列表和一种连接它们的方法来工作，然后在模板中添加一个特殊的控制块，代替正常的链接和脚本标签。然后，Flask
    Assets将添加一个链接或脚本标签，链接到新生成的文件。要开始使用Flask Assets，需要安装它。我们还需要安装`cssmin`和`jsmin`，这是处理文件修改的Python库：
- en: '[PRE22]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, the collections of files to be concatenated, named bundles, need to be
    created. In `extensions.py`, add the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，需要创建要连接的文件集合，即命名捆绑包。在`extensions.py`中，添加以下内容：
- en: '[PRE23]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Each `Bundle` object takes an infinite number of files as positional arguments
    to define the files to be bundled, a keyword argument `filters` to define the
    filters to send the files through, and an `output` that defines the filename in
    the `static` folder to save the result to.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Bundle`对象都需要无限数量的文件作为位置参数来定义要捆绑的文件，一个关键字参数`filters`来定义要通过的过滤器，以及一个`output`来定义`static`文件夹中要保存结果的文件名。
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `filters` keyword can be a single value or a list. To get the full list
    of available filters, including automatic Less and CSS compliers, see the docs
    at [http://webassets.readthedocs.org/en/latest/](http://webassets.readthedocs.org/en/latest/).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`filters`关键字可以是单个值或列表。要获取可用过滤器的完整列表，包括自动Less和CSS编译器，请参阅[http://webassets.readthedocs.org/en/latest/](http://webassets.readthedocs.org/en/latest/)上的文档。'
- en: While it's true that because our site is light on styles the CSS bundle has
    only one file in it. It's still a good idea to put the file in a bundle for two
    reasons.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的网站样式较轻，CSS捆绑包中只有一个文件。但是将文件放入捆绑包仍然是一个好主意，原因有两个。
- en: While we are in development, we can use the un-minified versions of the libraries,
    which makes debugging easier. When the app is deployed to production, the libraries
    are automatically minified.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，我们可以使用未压缩版本的库，这样调试更容易。当应用程序部署到生产环境时，库会自动进行压缩。
- en: These libraries will be sent to the browser with the cache headers, when linking
    them in HTML normally would not.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些库将被发送到浏览器，并带有缓存头，通常在HTML中链接它们不会。
- en: 'Before Flask Assets can be tested, three more changes need to be made. First,
    in the `__init__.py` format, the extension and bundles need to be registered:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试Flask Assets之前，需要进行三项更改。首先，在`__init__.py`格式中，需要注册扩展和捆绑包：
- en: '[PRE24]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, the `DevConfig` class needs an extra variable to tell Flask Assets to
    not compile the libraries while in development:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`DevConfig`类需要一个额外的变量，告诉Flask Assets在开发过程中不要编译库：
- en: '[PRE25]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, the link and script tags in both of the `base.html` files need to
    be replaced with the control block from Flask Assets. We have the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`base.html`文件中的链接和脚本标签都需要用Flask Assets的控制块替换。我们有以下内容：
- en: '[PRE26]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Replace this with the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下内容替换：
- en: '[PRE27]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We also have the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有以下内容：
- en: '[PRE28]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Replace this with the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下内容替换：
- en: '[PRE29]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, if you reload the page, all of the CSS and JavaScript will now be handled
    by Flask Assets.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果重新加载页面，所有的CSS和JavaScript现在都将由Flask Assets处理。
- en: Flask Admin
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flask Admin
- en: 'In [Chapter 6](ch06.html "Chapter 6. Securing Your App"), *Securing Your App*,
    we created an interface to allow users to create and edit blog posts without having
    to use the command line. This was adequate to demonstrate the security measures
    presented in the chapter, but there is still no way for posts to be deleted or
    tags assigned to them using the interface. We also do not have a way to delete
    or edit comments that we would rather not have common users see. What our app
    needs is a fully featured administrator interface in the same vein as the WordPress
    interface. This is such a common requirement for apps that a Flask extension name
    Flask Admin was created to easily create administrator interfaces. To get started,
    install Flask Admin with `pip`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章。保护您的应用程序")中，*保护您的应用程序*，我们创建了一个界面，允许用户创建和编辑博客文章，而无需使用命令行。这足以演示本章介绍的安全措施，但仍然没有办法使用界面删除帖子或为其分配标签。我们也没有办法删除或编辑我们不希望普通用户看到的评论。我们的应用程序需要的是一个功能齐全的管理员界面，与WordPress界面相同。这对于应用程序来说是一个常见的需求，因此创建了一个名为Flask
    Admin的Flask扩展，以便轻松创建管理员界面。要开始使用Flask Admin，请使用`pip`安装Flask Admin：
- en: '[PRE30]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As usual, we need to create the `extension` object in `extensions.py`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，在`extensions.py`中需要创建`extension`对象：
- en: '[PRE31]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, the object needs to be registered on the `app` object in `__init__.py`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，需要在`__init__.py`中的`app`对象上注册该对象：
- en: '[PRE32]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you navigate to `localhost:5000/admin`, you should now see the empty Flask
    Admin interface:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您导航到`localhost:5000/admin`，您现在应该看到空的Flask Admin界面：
- en: '![Flask Admin](img/B03929_10_02.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![Flask Admin](img/B03929_10_02.jpg)'
- en: 'Flask Admin works by registering view classes on the `admin` object that define
    one or more routes. Flask Admin has three main types of views: the `ModelView`,
    `FileAdmin`, and `BaseView` views.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Flask Admin通过在定义一个或多个路由的`admin`对象上注册视图类来工作。Flask Admin有三种主要类型的视图：`ModelView`、`FileAdmin`和`BaseView`视图。
- en: Creating basic admin pages
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建基本管理页面
- en: 'The `BaseView` class allows normal Flask pages to be added to your `admin`
    interface. This is normally the least used type of view in Flask Admin setups,
    but if you wish to include something like custom reporting with JavaScript charting
    libraries, you would do it with just a base view. In a new file in the controllers
    folder named `admin.py`, add the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseView`类允许将普通的Flask页面添加到您的`admin`界面中。这通常是Flask Admin设置中最少使用的视图类型，但如果您希望包括类似使用JavaScript图表库的自定义报告，您可以使用基本视图。在名为`admin.py`的控制器文件夹中添加以下内容：'
- en: '[PRE33]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In a subclass of `BaseView`, multiple views can be registered at once if they
    are defined together. Keep in mind, however, that each subclass of `BaseView`
    requires at least one exposed method on the path `/`. Also, methods other than
    the method within the path `/` will not be in the navigation of the administrator
    interface, and will have to be linked to the other pages in the class. The `expose`
    and `self.render` functions work exactly the same as their counterparts in the
    normal Flask API.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BaseView`的子类中，如果它们一起定义，可以一次注册多个视图。但是请记住，`BaseView`的每个子类都需要至少一个在路径`/`上公开的方法。此外，除了路径`/`中的方法之外，管理员界面的导航中将不会有其他方法，并且必须将它们链接到类中的其他页面。`expose`和`self.render`函数的工作方式与普通Flask
    API中的对应函数完全相同。
- en: 'To have your templates inherit the default styles of Flask Admin, create a
    new folder in the templates directory named `admin` with a file named `custom.html`
    and add the following Jinja code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要使您的模板继承Flask Admin的默认样式，请在模板目录中创建一个名为`admin`的新文件夹，其中包含一个名为`custom.html`的文件，并添加以下Jinja代码：
- en: '[PRE34]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To view this template, an instance of `CustomView` needs to be registered on
    the `admin` object. This will be done in the `create_app` function rather than
    in the `extensions.py` file because some of our admin pages will need the database
    object, which would lead to circular imports if the registrations were in `extensions.py`.
    In `__init__.py`, add the following code to register the class:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此模板，需要在`admin`对象上注册`CustomView`的实例。这将在`create_app`函数中完成，而不是在`extensions.py`文件中，因为我们的一些管理页面将需要数据库对象，如果注册在`extensions.py`中会导致循环导入。在`__init__.py`中，添加以下代码来注册该类：
- en: '[PRE35]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `name` keyword argument specifies that the label used in the navigation
    bar on the top of the `admin` interface should read `Custom`. After you have registered
    `CustomView` to the `admin` object, your `admin` interface should now have a second
    link in the navigation bar as follows.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`关键字参数指定`admin`界面顶部导航栏上使用的标签应该读取`Custom`。在将`CustomView`注册到`admin`对象之后，您的`admin`界面现在应该有第二个链接在导航栏中，如下所示。'
- en: '![Creating basic admin pages](img/B03929_10_03.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![Creating basic admin pages](img/B03929_10_03.jpg)'
- en: Creating database admin pages
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数据库管理页面
- en: 'The main power of Flask Admin comes from the fact that you can automatically
    create administrator pages for your data by giving Flask Admin your SQLAlchemy
    or MongoEngine models. Creating these pages is very easy; in `admin.py`, just
    add the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Flask Admin的主要功能来自于您可以通过将您的SQLAlchemy或MongoEngine模型提供给Flask Admin来自动创建数据的管理员页面。创建这些页面非常容易；在`admin.py`中，只需添加以下代码：
- en: '[PRE36]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, in `__init__.py`, register the class with the model you wish to use and
    the database `session` object as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`__init__.py`中，按照以下方式注册要使用的模型和数据库`session`对象的类：
- en: '[PRE37]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `category` keyword tells Flask Admin to put all of the views with the same
    category value into the same dropdown on the navigation bar.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`category`关键字告诉Flask Admin将具有相同类别值的所有视图放入导航栏上的同一个下拉菜单中。'
- en: 'If you go to the browser now, you will see a new drop-down menu labeled **Models**
    with links to the admin pages of all of the tables in the database as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在转到浏览器，您将看到一个名为**Models**的新下拉菜单，其中包含指向数据库中所有表的管理页面的链接，如下所示：
- en: '![Creating database admin pages](img/B03929_10_04.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![Creating database admin pages](img/B03929_10_04.jpg)'
- en: The generated interface for each model provides a lot of functionality. New
    posts can be created, and the existing posts can be deleted in bulk. All of the
    fields can be set from this interface, including the relationship fields, which
    are implemented as searchable drop-down menus. The `date` and `datetime` fields
    even have custom JavaScript inputs with calendar dropdowns. Overall, this is a
    huge improvement to the hand-created interface that was created in [Chapter 6](ch06.html
    "Chapter 6. Securing Your App"), *Securing Your App*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模型的生成界面提供了许多功能。可以创建新的帖子，并可以批量删除现有的帖子。可以从这个界面设置所有字段，包括关系字段，这些字段实现为可搜索的下拉菜单。`date`和`datetime`字段甚至具有带有日历下拉菜单的自定义JavaScript输入。总的来说，这是对[第6章](ch06.html
    "第6章。保护您的应用程序")中手动创建的界面的巨大改进，*保护您的应用程序*。
- en: Enhancing the post's administration
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增强文章管理
- en: While this interface is a huge step-up in quality, there are some features missing.
    We no longer have the WYSIWYG editor that was available in the original interface,
    and this page can be improved by enabling some of the more powerful Flask Admin
    features.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个界面在质量上有了很大的提升，但还是有一些功能缺失。我们不再拥有原始界面中可用的所见即所得编辑器，这个页面可以通过启用一些更强大的Flask Admin功能来改进。
- en: 'To add the WYSIWYG editor back into the `post` creation page, we will need
    a new `WTForms` field, as Flask Admin constructs its forms with Flask WTF. We
    will also need to override the `textarea` field in the `post` edit and creation
    page with this new field type. The first thing that needs to be done is to create
    the new field type in `forms.py` by using the `textarea` field as a base:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要将所见即所得编辑器添加回`post`创建页面，我们需要一个新的`WTForms`字段，因为Flask Admin使用Flask WTF构建其表单。我们还需要用这种新的字段类型覆盖`post`编辑和创建页面中的`textarea`字段。需要做的第一件事是在`forms.py`中使用`textarea`字段作为基础创建新的字段类型：
- en: '[PRE38]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In this code, we created a new field type `CKTextAreaField` that adds a widget
    to the `textarea`, and all that the widget does is adds a class to the HTML tag.
    Now, to add this field to the `Post` admin page, the `Post` will need its own
    `ModelView`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们创建了一个新的字段类型`CKTextAreaField`，它为`textarea`添加了一个小部件，而小部件所做的就是向HTML标签添加一个类。现在，要将此字段添加到`Post`管理员页面，`Post`将需要自己的`ModelView`：
- en: '[PRE39]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'There are several new things in this code. First, the `form_overrides` class
    variable tells Flask Admin to override the field type of the name text with this
    new field type. The `column_searchable_list` function defines which columns are
    searchable via text. Adding this will allow Flask Admin to include a search field
    on the overview page that searches the values of the defined fields. Next, the
    `column_filters` class variable tells Flask Admin to create a `filters` interface
    on the overview page of this model. The `filters` interface allows columns that
    are not text to be filtered down by adding conditions to the shown rows. An example
    with the preceding code is to create a filter that shows all rows with `publish_date`
    values greater than January 1, 2015\. Finally, the `create_template` and `edit_template`
    class variables allow you to define custom templates for Flask Admin to use. For
    the custom template that we will be using, we need to create a new file `post_edit.html`
    in the admin folder. In this template, we will include the same JavaScript library
    that was used in [Chapter 6](ch06.html "Chapter 6. Securing Your App"), *Securing
    Your App*:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中有几个新的东西。首先，`form_overrides`类变量告诉Flask Admin用这种新的字段类型覆盖名称文本的字段类型。`column_searchable_list`函数定义了哪些列可以通过文本进行搜索。添加这个将允许Flask
    Admin在概述页面上包括一个搜索字段，用于搜索已定义字段的值。接下来，`column_filters`类变量告诉Flask Admin在此模型的概述页面上创建一个`filters`界面。`filters`界面允许非文本列通过向显示的行添加条件进行过滤。使用上述代码的示例是创建一个过滤器，显示所有`publish_date`值大于2015年1月1日的行。最后，`create_template`和`edit_template`类变量允许您定义Flask
    Admin要使用的自定义模板。对于我们将要使用的自定义模板，我们需要在admin文件夹中创建一个新文件`post_edit.html`。在这个模板中，我们将包含与[第6章](ch06.html
    "第6章 保护您的应用")中使用的相同的JavaScript库，*保护您的应用*：
- en: '[PRE40]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The tail block of the inherited template is located at the end of the file.
    Once the template is created, your `post` edit and creation page should look like
    this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 继承模板的尾部块位于文件末尾。创建模板后，您的`post`编辑和创建页面应如下所示：
- en: '![Enhancing the post''s administration](img/B03929_10_05.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![增强帖子的管理](img/B03929_10_05.jpg)'
- en: Creating file system admin pages
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建文件系统管理员页面
- en: Another common function that most `admin` interfaces cover is being able to
    access the server's file system from the web. Thankfully, Flask Admin includes
    this feature with the `FileAdmin` class
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数`admin`界面涵盖的另一个常见功能是能够从Web访问服务器的文件系统。幸运的是，Flask Admin通过`FileAdmin`类包含了这个功能
- en: '[PRE41]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Securing Flask Admin
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护Flask Admin
- en: 'Currently, the entire `admin` interface is accessible to the world; let''s
    fix that. The routes in the `CustomView` can be secured just like any other route:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，整个“admin”界面对世界都是可访问的；让我们来修复一下。`CustomView`中的路由可以像任何其他路由一样进行保护：
- en: '[PRE42]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: To secure the `ModeView` and `FileAdmin` subclasses, they need to have a method
    named `is_accessible` defined, which either returns *true* or *false*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要保护`ModeView`和`FileAdmin`子类，它们需要定义一个名为`is_accessible`的方法，该方法返回*true*或*false*。
- en: '[PRE43]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Because we set up our authentication correctly in [Chapter 6](ch06.html "Chapter 6. Securing
    Your App"), *Securing Your App*, this task was trivial.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在[第6章](ch06.html "第6章 保护您的应用")中正确设置了我们的身份验证，所以这个任务很简单。
- en: Flask Mail
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flask Mail
- en: 'The final Flask extension that this chapter will cover is Flask Mail, which
    allows you to connect and configure your SMTP client from Flask''s configuration.
    Flask Mail will also help to simplify application testing in [Chapter 12](ch12.html
    "Chapter 12. Testing Flask Apps"), *Testing Flask Apps*. The first step is to
    install Flask Mail with `pip`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍的最终Flask扩展是Flask Mail，它允许您从Flask的配置中连接和配置您的SMTP客户端。Flask Mail还将帮助简化[第12章](ch12.html
    "第12章 测试Flask应用")中的应用测试，*测试Flask应用*。第一步是使用`pip`安装Flask Mail：
- en: '[PRE44]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, the `Mail` object needs to be initialized in the `extentions.py` file:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`extentions.py`文件中需要初始化`Mail`对象：
- en: '[PRE45]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`flask_mail` will connect to our SMTP server of choice by reading the configuration
    variables in our `app` object, so we need to add those values to our `config`
    object:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`flask_mail`将通过读取`app`对象中的配置变量连接到我们选择的SMTP服务器，因此我们需要将这些值添加到我们的`config`对象中：'
- en: '[PRE46]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, the `mail` object is initialized on the `app` object in `__init__.py`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`__init__.py`中的`app`对象上初始化`mail`对象：
- en: '[PRE47]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To see how Flask Mail can simplify our e-mailing code, this is the remind task
    created in [Chapter 9](ch09.html "Chapter 9. Creating Asynchronous Tasks with
    Celery"), *Creating Asynchronous Tasks with Celery*, but using Flask Mail instead
    of the standard library SMTP module:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解Flask Mail如何简化我们的邮件代码，这是在[第9章](ch09.html "第9章 使用Celery创建异步任务")中创建的提醒任务，*使用Celery创建异步任务*，但使用Flask
    Mail而不是标准库SMTP模块：
- en: '[PRE48]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has created a large increase in the functionality of our app. We
    now have a fully featured administrator interface, a useful debugging tool in
    the browser, two tools that greatly speed up page load times, and a utility to
    make sending e-mails less of a headache.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 本章大大增加了我们应用的功能。我们现在拥有一个功能齐全的管理员界面，在浏览器中有一个有用的调试工具，两个大大加快页面加载速度的工具，以及一个使发送电子邮件变得不那么头疼的实用程序。
- en: As was stated at the start of this chapter, Flask is bare-bones and allows you
    to pick and choose the functionality that you want. Therefore, it is important
    to keep in mind that it is not necessary to include all of these extensions in
    you app. If you are the only content creator of your app, maybe the command-line
    interface is all you need because adding in these features takes development time
    and maintenance time when they inevitably break. This warning is given at the
    end of the chapter because one of the main reasons many Flask apps become unwieldy
    is because they include so many extensions that testing and maintaining all of
    them becomes a very large task.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章开头所述，Flask是一个基本的框架，允许您挑选并选择您想要的功能。因此，重要的是要记住，在您的应用程序中并不需要包含所有这些扩展。如果您是应用程序的唯一内容创建者，也许命令行界面就是您所需要的，因为添加这些功能需要开发时间和维护时间，当它们不可避免地出现故障时。本章末尾提出了这个警告，因为许多Flask应用程序变得难以管理的主要原因之一是它们包含了太多的扩展，测试和维护所有这些扩展变成了一项非常庞大的任务。
- en: In the next chapter, you will learn the internals of how an extension works
    and how to create your own extension.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习扩展的内部工作原理以及如何创建自己的扩展。
