- en: '*Chapter 2*: Elements of Computational Thinking'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第2章*：计算思维的元素'
- en: 'The previous chapter provided some general information about the fundamentals
    of computer science. In this chapter, we will focus more closely on understanding
    computational thinking and the elements that make up computational thinking: decomposition,
    pattern recognition, pattern generalization or abstraction, and algorithm design.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章提供了关于计算机科学基础的一些一般信息。在本章中，我们将更专注于理解计算思维和构成计算思维的元素：分解、模式识别、模式泛化或抽象以及算法设计。
- en: The importance of the computational thinking process cannot be understated.
    Through the process, we analyze problems to design the best possible solutions
    based on a set of conditions. Although many algorithms can be written to answer
    the same questions, using the computational thinking process helps us to determine
    the optimal path to take to design a clear algorithm that can be generalized.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 计算思维过程的重要性不可低估。通过这个过程，我们分析问题，设计基于一组条件的最佳解决方案。虽然可以编写许多算法来回答相同的问题，但使用计算思维过程可以帮助我们确定设计清晰算法的最佳路径。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding computational thinking
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解计算思维
- en: Decomposing problems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分解问题
- en: Recognizing patterns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别模式
- en: Generalizing patterns
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛化模式
- en: Designing algorithms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计算法
- en: Additional problems
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外的问题
- en: In order to learn more about computational thinking, we will be looking at the
    elements through the lens of a problem presented. Keep in mind that we will be
    doing a deeper dive into the Python programming language in [*Chapter 8*](B15413_08_Final_SK_ePub.xhtml#_idTextAnchor114),
    *Introduction to Python*, but you can go back and forth to that chapter as needed
    while you dive into this and all the other chapters of the book.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更多地了解计算思维，我们将通过一个提出的问题来看待这些元素。请记住，在[*第8章*](B15413_08_Final_SK_ePub.xhtml#_idTextAnchor114)中，*Python简介*中，我们将深入研究Python编程语言，但在您深入研究本书的本章和其他章节时，您可以随时来回查阅该章节。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need the latest version of Python to run the codes in this chapter.
    You will find the full source code used in this chapter here: [https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter02](https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter02)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要最新版本的Python来运行本章中的代码。您可以在此处找到本章中使用的完整源代码：[https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter02](https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter02)
- en: Understanding computational thinking
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解计算思维
- en: 'In its most basic definition, computational thinking is a problem-solving process.
    Much like with design thinking, the scientific method, and other similar methods,
    there are a number of steps we go through to find solutions. For example, the
    scientific method has seven steps. Please keep in mind that there are multiple
    interpretations of the scientific method out there and some differ in terms of
    the number of steps. For the purposes of this discussion, we will use these seven
    steps:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最基本的定义中，计算思维是一个解决问题的过程。就像设计思维、科学方法和其他类似的方法一样，我们经历一系列步骤来找到解决方案。例如，科学方法有七个步骤。请记住，关于科学方法存在多种解释，有些在步骤数量上有所不同。在本讨论中，我们将使用以下七个步骤：
- en: '**Question**'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**问题**'
- en: '**Hypothesis**'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**假设**'
- en: '**Materials**'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**材料**'
- en: '**Experiment**'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**实验**'
- en: '**Results**'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**结果**'
- en: '**Conclusion**'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**结论**'
- en: '**Communication of findings**'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**发现的沟通**'
- en: The establishment of the scientific method is a highly debated topic, but most
    researchers agree that it dates back to the 10th century.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 科学方法的确立是一个备受争议的话题，但大多数研究人员都同意它可以追溯到10世纪。
- en: The scientific method made it possible to observe the natural world, create
    hypotheses to test observations, and develop tests and results through an established
    process. The method itself has some basis in philosophers such as Plato and Aristotle,
    who promoted empirical research. However, their methodology was not as developed
    as what we call the scientific method today.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 科学方法使我们能够观察自然界，提出假设来测试观察，并通过一个既定的过程开发测试和结果。这种方法本身在柏拉图和亚里士多德等哲学家的基础上有一定的依据，他们提倡经验研究。然而，他们的方法论不如今天我们所说的科学方法发展得那么成熟。
- en: The computational thinking elements are similar to the scientific method. Computational
    thinking uses fewer steps to tackle problems associated with programming, where
    the scientific method is used for experiments. With computational thinking, we
    generalize the algorithms, while in the scientific method, we are able to reproduce
    results and generalize the conclusions from samples to populations.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 计算思维的元素类似于科学方法。计算思维使用较少的步骤来解决与编程相关的问题，而科学方法用于实验。通过计算思维，我们泛化算法，而在科学方法中，我们能够重现结果并从样本泛化到总体得出结论。
- en: In modern times, we have developed other methodologies depending on the fields
    of study we pursue and technologies we have developed. Two examples of that are
    the design thinking process and computational thinking.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代，我们根据我们追求的研究领域和我们开发的技术，发展了其他方法论。其中两个例子是设计思维过程和计算思维。
- en: 'Design thinking has five steps or stages:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 设计思维有五个步骤或阶段：
- en: Empathize
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 共情
- en: Define
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义
- en: Ideate
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构思
- en: Prototype
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原型
- en: Test
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试
- en: We use these aforementioned stages to understand the needs of a client, class,
    problem, situation, or other circumstance that we need to address. Empathizing
    with the needs of the user helps us identify and define the problem. The ideation
    and prototype stages are where we create possible solutions. Testing the possible
    solutions is the next required step in finding the best possible one. After all
    the stages, we can go back through the cycle if we need to, since the goal of
    the design thinking process is not perfection, so additional work can always be
    carried out. The goal of design thinking is to provide a solution that is effective
    and plausible for a defined problem. This is not the only viable solution, nor
    is it perfect.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用上述阶段来理解客户、班级、问题、情况或其他需要解决的情况的需求。与用户的需求产生共鸣有助于我们确定和定义问题。构思和原型阶段是我们创建可能解决方案的地方。测试可能的解决方案是找到最佳解决方案的下一个必要步骤。在所有阶段之后，如果需要，我们可以重新进行循环，因为设计思维过程的目标不是完美，所以总是可以进行额外的工作。设计思维的目标是为明确定义的问题提供一个有效和可行的解决方案。这不是唯一可行的解决方案，也不是完美的解决方案。
- en: 'In computational thinking, we use a similar process that has four elements:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算思维中，我们使用了一个具有四个元素的类似过程：
- en: '**Decomposition**'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**分解**'
- en: '**Pattern recognition**'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模式识别**'
- en: '**Abstraction**'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**抽象**'
- en: '**Algorithm design**'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**算法设计**'
- en: As with the design thinking process, the problem is not clearly defined in computational
    thinking. These problems are sometimes referred to as *ill-defined*. We are presented
    with a set of circumstances and we define or decompose that problem before we
    start ideating, or creating possible solutions based on patterns we can see. When
    we think about the computational thinking process, what we are really doing is
    trying to figure out how we can get a computer to follow a set of steps in order
    to solve the problem we have been presented with.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 与设计思维过程一样，计算思维中的问题并不清晰。这些问题有时被称为*不明确的*。我们被呈现了一系列情况，我们在开始构思或根据我们可以看到的模式创建可能的解决方案之前，我们定义或分解该问题。当我们考虑计算思维过程时，我们真正做的是尝试弄清楚如何让计算机按照一系列步骤解决我们所面临的问题。
- en: Let's take a look at a simple computational thinking problem.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个简单的计算思维问题。
- en: Problem 1 - Conditions
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题1 - 条件
- en: 'Let''s imagine that a raffle at a radio station has contestants select one
    of two possible winning structures: $250 or the height, in quarters, of the contestant
    in cash.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下，广播电台的抽奖活动让参赛者选择两种可能的获奖方式：250美元现金或以25美分的高度。
- en: A computational thinking problem can be as vague as *Problem 1*, where no question
    is even being asked. You are given a set of conditions and it is your job to determine
    what the problem is and find solutions for that problem you yourself have defined.
    If you think about it, there is no perfect answer for this problem, but there
    are ways for you to create conditions that work to determine which option is indeed
    best, depending on the height of the contestant.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 计算思维问题可能像*问题1*那样模糊，甚至没有提出问题。你被给定了一系列条件，你的工作是确定问题是什么，并为你自己定义的问题找到解决方案。如果你仔细想想，这个问题没有完美的答案，但你可以创造条件来确定哪个选项确实是最好的，这取决于参赛者的身高。
- en: To **decompose** this problem, we need to look at what is stated and take into
    consideration what is not stated. We need rules.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了**分解**这个问题，我们需要看看陈述了什么，并考虑没有陈述的内容。我们需要规则。
- en: 'Simply stated, a winner will choose a monetary payout: either $250 in cash
    or the equivalent of their height in quarters. Those things are stated. But what
    isn''t stated is also important:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，赢家将选择货币支付：要么是250美元现金，要么是相当于他们身高的25美分。这些都是陈述的。但未陈述的内容也很重要：
- en: '*What is the timeline for the raffle?* *How many winners are there?*'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*抽奖的时间表是什么？* *有多少个赢家？*'
- en: '*Do we want to track how much we have spent after each contestant has chosen?*'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*我们是否想要在每个参赛者选择后跟踪我们花了多少？*'
- en: '*Do we want to use a baseline for comparison purposes?*'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*我们是否想要使用一个比较基准？*'
- en: There are other things that may come to mind, but for now, let's stick to these
    questions. We are going to assume that the raffle doesn't have a set start or
    end date and that the radio station may choose multiple winners in a given day
    – or none at all. These are some of the considerations we will look at when figuring
    out patterns, generalizing them, and designing the algorithms.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会想到其他事情，但现在让我们坚持这些问题。我们将假设抽奖没有固定的开始或结束日期，电台可能会在某一天选择多个赢家，也可能根本不选择。这些是我们在找出模式、概括它们并设计算法时要考虑的一些因素。
- en: Given all the information about payouts, we still do not have a way to figure
    out when the payout is greater. *Is it best to choose the $250?* *Or is it best
    to choose the height in quarters?* *Can we create an algorithm that tells us which
    option is best somehow?* Yes, we can create an algorithm that addresses the entire
    problem.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 关于支付的所有信息，我们仍然没有办法弄清楚何时支付更多。*选择250美元最好吗？* *还是选择以25美分的高度最好？* *我们能否创建一个算法，告诉我们哪个选项更好？*
    是的，我们可以创建一个解决整个问题的算法。
- en: 'The **pattern** for this problem will always be the same: the amount is set
    for the cash value and the height of a quarter is set, so we can always use math
    to figure out what the height in quarters converts to money-wise based on someone''s
    height.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的**模式**总是相同的：现金价值和25美分的高度是固定的，所以我们总是可以使用数学来计算根据某人的身高，25美分的高度转换成多少钱。
- en: 'We can clearly state the winnings based on each choice if we know a few things.
    This includes *the choice of cash or choice of height in quarters*. If height
    in quarters is chosen, we need the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道一些东西，我们可以清楚地陈述基于每个选择的赢得。这包括*现金选择或以25美分的高度选择*。如果选择以25美分的高度，我们需要以下内容：
- en: The contestant's height
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参赛者的身高
- en: The thickness of the quarter
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一美分的厚度
- en: What happens next is part of both **pattern** and **abstraction**. We do not
    know the choice until each contestant decides, but we can find out what each quarter's
    thickness is ahead of time. It will be needed later for our algorithm. Each quarter
    is approximately 0.069 inches, or 1.75 millimeters, thick.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来发生的事情是**模式**和**抽象**的一部分。我们不知道每个参赛者的选择，但我们可以提前找出每个四分之一的厚度。这将在我们的算法中稍后需要。每个四分之一大约是0.069英寸，或1.75毫米厚。
- en: 'Important Note:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: For the purpose of this book, we will be using customary measurements, for example,
    feet and inches. However, the algorithms for metric measurements will also be
    provided.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用惯例测量，例如英尺和英寸。然而，我们也会提供公制测量的算法。
- en: Looking at our problem, we can state the winnings in two ways. The following
    expressions included for the height in quarters winnings are **mathematical algorithms**.
    They show the steps needed in order to determine the total winnings given the
    height of the contestant.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 观察我们的问题，我们可以用两种方式陈述赢得的方式。以下表达包括了以四分之一赢得的高度的**数学算法**。它们展示了确定参赛者身高后确定总赢得所需的步骤。
- en: 'Note that in order to use the customary algorithms, height would need to be
    given in customary units. In order to use the metric algorithm, height would need
    to be given in metric units. If a contestant chooses the cash, then the total
    winnings are simply $250\. If the contestant chooses the height in quarters, then
    the algorithms for both customary and metric units are as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了使用惯例算法，身高需要以惯例单位给出。为了使用公制算法，身高需要以公制单位给出。如果参赛者选择现金，那么总赢得就是$250。如果参赛者选择以四分之一身高，那么惯例单位和公制单位的算法如下：
- en: 'Total winnings (customary): ![](image/Formula_B15413_02_001.png)'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总赢得（惯例）：![](image/Formula_B15413_02_001.png)
- en: 'Total winnings (metric): ![](image/Formula_B15413_02_002.png)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总赢得（公制）：![](image/Formula_B15413_02_002.png)
- en: 'I like a gamble that is not high stakes. So, I''m going to say that I want
    to test this out and use my own height. So instead of taking $250, I choose to
    find out what my height would be in quarters. I am 5''10" tall. Let''s figure
    out how many inches that is. Since we have 12 inches in a foot, the algorithm
    for the total height is as shown:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢不高风险的赌博。所以，我要说我想测试一下，用我的身高。所以我选择找出我的身高是多少个四分之一。我身高5'10"。让我们算一下这是多少英寸。因为一英尺有12英寸，总身高的算法如下所示：
- en: '![](image/Formula_B15413_02_003.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](image/Formula_B15413_02_003.jpg)'
- en: 'But I said I am 5''10", so we will need to add those 10 extra inches:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 但我说我是5'10"，所以我们需要加上那10英寸：
- en: '![](image/Formula_B15413_02_004.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](image/Formula_B15413_02_004.jpg)'
- en: 'Now, let''s use the mathematical algorithm we defined earlier, ![](image/Formula_B15413_02_005.png),
    in order to find out how much I''d win:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用我们之前定义的数学算法，![](image/Formula_B15413_02_005.png)，来找出我能赢得多少：
- en: '![](image/Formula_B15413_02_006.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](image/Formula_B15413_02_006.jpg)'
- en: I used the ![](image/Formula_B15413_02_007.png) symbol instead of = because
    ![](image/Formula_B15413_02_007.png) means this is an approximation. Since I rounded
    off, I wanted to make sure I showed it was the best approximation, not the exact
    number.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了![](image/Formula_B15413_02_007.png)符号而不是=，因为![](image/Formula_B15413_02_007.png)表示这是一个近似值。由于我四舍五入了，我想确保我显示的是最佳近似值，而不是精确数字。
- en: Maybe you are done with the problem now, but in computational thinking, we have
    to go through abstraction and design an algorithm that will apply to all instances.
    We can create a very simple program that uses simple input from a user, or we
    can create a more complex program that provides not just the basic total, but
    maybe the sums, a graphic, or whatever else we find relevant to our scenario and
    that applies to all cases.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你现在已经解决了这个问题，但在计算思维中，我们必须经过抽象并设计一个适用于所有情况的算法。我们可以创建一个非常简单的程序，从用户那里获得简单的输入，或者我们可以创建一个更复杂的程序，不仅提供基本的总数，还可能提供总和、图表或我们发现与我们的情景相关的其他任何内容，并适用于所有情况。
- en: We will be designing those algorithms more once we have learned about each part
    of the computational thinking process in more depth. We will even go back to this
    problem to show how to create that algorithm for the computer to run for us. We
    can create an algorithm that lets us use someone's height to make a decision about
    which winnings to use.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们更深入地了解了计算思维过程的每个部分，我们将更多地设计这些算法。我们甚至会回到这个问题，展示如何为计算机创建运行的算法。我们可以创建一个算法，让我们使用某人的身高来决定使用哪种赢得。
- en: Or, as mentioned earlier, we could write a baseline using $250 as the winnings
    for every contestant and then input what each contestant has chosen in order to
    see whether we are below or above the $250 baseline. We can aggregate those results,
    which means to continue adding them to see where we end up once the radio station
    stops the raffle. We could even have a graphic that shows us where we are over
    time, if contestants were choosing differently the longer the radio station ran
    the raffle, and so on.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如前所述，我们可以写一个以$250作为每个参赛者的赢得基准的基线，然后输入每个参赛者选择的内容，以便查看我们是否低于或高于$250的基准。我们可以汇总这些结果，也就是继续将它们相加，以查看当电台停止抽奖时我们最终会得到什么结果。如果参赛者在电台进行抽奖的时间越长选择不同，我们甚至可以有一个图表显示我们的情况，等等。
- en: In this section, we learned about the elements of computational thinking. We
    also looked at a computational thinking problem.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了计算思维的要素。我们还研究了一个计算思维问题。
- en: For now, however, let's continue to look at the elements of computational thinking
    – that is, decomposition, pattern recognition, pattern generalization and abstraction,
    and algorithm design, in more depth.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在让我们继续深入研究计算思维的要素——即分解、模式识别、模式概括和抽象以及算法设计。
- en: Decomposing problems
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分解问题
- en: '**Decomposition** is the process of breaking down data. It can include a number
    of processes or steps necessary in order to solve the problem. By decomposing
    the problem, we can identify the components, or smaller parts, of the problem
    before we generalize the pattern.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**分解**是分解数据的过程。它可以包括解决问题所需的一系列过程或步骤。通过分解问题，我们可以在概括模式之前识别问题的组成部分或较小部分。'
- en: 'Through decomposition, we can identify and solve one case in order to then
    generalize those steps to all possible instances of the problem. In order to really
    understand decomposition, we will need to go back to our problem stated earlier,
    which, simply stated, is asking the question: *Will my height result in more money
    if I take my height in quarters or should I take a $250 payout?* We can state
    that we want to know one instance and do that problem mathematically one time,
    such as solving the problem for my own height only. However, we may need the information
    for other instances. We could create a program that just identifies which option,
    $250 or your height in quarters, would be best. Or we could take into consideration
    some of the following scenarios, which would mean a different algorithm:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分解，我们可以识别和解决一个案例，然后将这些步骤概括到问题的所有可能实例中。为了真正理解分解，我们需要回到我们之前提出的问题，简单地说，就是问：*如果我用硬币换取我的身高，会得到更多的钱吗，还是应该选择250美元？*我们可以说我们想知道一个实例，并且数学上解决这个问题一次，比如只解决我的身高的问题。然而，我们可能需要其他实例的信息。我们可以创建一个程序，只是确定哪个选项，250美元还是你的身高的硬币，会更好。或者我们可以考虑以下一些情况，这将意味着不同的算法：
- en: We could check the option given the height but also add each item to a list
    in order to track all decisions.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以检查给定身高的选项，但也将每个项目添加到列表中，以便跟踪所有决策。
- en: We could also need the array and the sum of the elements in that list to track
    spending throughout the contest.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可能需要数组和该列表中元素的总和来跟踪比赛中的支出。
- en: We could also compare the sum to a baseline, using $250 as a base for each of
    the individuals.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以将总和与基线进行比较，以250美元作为每个个体的基准。
- en: We could also use all of the elements, such as the list, the sum, the comparison,
    and a visual graphic display to better understand and track the results.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以使用所有的元素，比如列表、总和、比较和可视化图形显示来更好地理解和跟踪结果。
- en: As you can see, the algorithm will depend on what it is exactly we want to track
    or answer for this problem. Our algorithm could be a simple yes or no type of
    problem, where we'd just check which option is best, or it could be a much more
    robust algorithm, with data and visual representations for the data tracked. Now
    let's take a look at how we work to find patterns in our problems.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，算法将取决于我们确切想要跟踪或回答这个问题。我们的算法可以是一个简单的是或否类型的问题，我们只需检查哪个选项最好，或者它可以是一个更健壮的算法，带有数据和数据跟踪的可视化表示。现在让我们来看看我们如何在问题中寻找模式。
- en: Recognizing patterns
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别模式
- en: '**Pattern recognition** is the process of finding similarities, or patterns,
    once we go through the decomposition of problems. In *Problem 1*, we were shown
    a problem where a contestant would win $250 or choose to take their height in
    quarters. This will be the same for every contestant. The only difference is that
    the total value changes depending on the height of the person.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式识别**是在我们分解问题后找到相似之处或模式的过程。在*问题1*中，我们展示了一个问题，其中参赛者可以赢得250美元，或选择用他们的身高来换取硬币。对于每个参赛者来说都是一样的。唯一的区别是总价值取决于个人的身高。'
- en: In this section, let's take a look at a different problem in order to better
    understand pattern recognition.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们看一个不同的问题，以更好地理解模式识别。
- en: Problem 2 - Mathematical algorithms and generalization
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题2 - 数学算法和概括
- en: 'Imagine you are preparing a party for a soccer team. This is a community team,
    so there are always between 12 and 15 children that stop by. You want to place
    an order for the food you will need. You know it will cost you $12 per child from
    the catering company you will be using. Now, let''s break down the problem:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在为一个足球队准备聚会。这是一个社区球队，所以总是有12到15个孩子过来。你想要订购你需要的食物。你知道你将从你将使用的餐饮公司那里支付12美元每个孩子。现在，让我们分解这个问题：
- en: '**Decomposition**: I know we have between 12 and 15 children. We also know
    there is a cost of $12 per child. Our problem can be thought of as a question:
    *How can we estimate the cost?*'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分解**：我知道我们有12到15个孩子。我们也知道每个孩子的费用是12美元。我们的问题可以被看作是一个问题：*我们如何估算费用？*'
- en: '**Pattern recognition**: You know the number of children, *k*, is between 12
    and 15\. You know it is going to cost $12\. If I had 5 children, for example,
    the cost would be ![](image/Formula_B15413_02_009.png)'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模式识别**：你知道孩子的数量*k*在12到15之间。你知道每个孩子的费用是12美元。例如，如果我有5个孩子，费用将是![](image/Formula_B15413_02_009.png)'
- en: '**Pattern generalization**: The number of children is not known, so we will
    use the variable *k* for that unknown value. That way, we can find out the total
    cost no matter how many children we have. We are generalizing from one case, 5
    children, to all cases, *k* children.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模式概括**：孩子的数量是未知的，所以我们将使用变量*k*表示未知值。这样，无论我们有多少孩子，我们都可以找出总费用。我们正在从一个案例，5个孩子，概括到所有案例，*k*个孩子。'
- en: '**Algorithm design**: We will write the mathematical algorithm for now. We
    will be working more with programmable algorithms coming up in [*Chapter 3*](B15413_03_Final_SK_ePub.xhtml#_idTextAnchor056),
    *Understanding Algorithms and Algorithmic Thinking*. We will be revisiting these
    mathematical algorithms there as well. The total cost will be given by the equation
    ![](image/Formula_B15413_02_010.png), where *T* is the total cost and *k* is the
    number of children.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**算法设计**：我们现在将编写数学算法。我们将在[*第3章*](B15413_03_Final_SK_ePub.xhtml#_idTextAnchor056)中更多地使用可编程算法，*理解算法和算法思维*。我们也将在那里重新讨论这些数学算法。总费用将由方程![](image/Formula_B15413_02_010.png)给出，其中*T*是总费用，*k*是孩子的数量。'
- en: As you can see from the preceding problem, pattern recognition is important
    in order to find a generalized pattern and write our algorithm. Now, let's look
    more closely at pattern generalization.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从前面的问题中所看到的，模式识别对于找到一个概括的模式并编写我们的算法是很重要的。现在，让我们更仔细地看一下模式概括。
- en: Generalizing patterns
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概括模式
- en: Once we have recognized our pattern, we need to go through **pattern generalization**
    and **abstraction**. That is, we want to make sure that the solution we come up
    with can be used for multiple instances of the problem we have identified. Pattern
    generalization can be something as simple as writing a basic linear mathematical
    algorithm, like we did for the cost of a party, where the cost per child was $12\.
    So, the cost for any number *k* of children would be given by 12*k*. But pattern
    generalization can be much more than that.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们认识到我们的模式，我们需要进行**模式概括**和**抽象**。也就是说，我们希望确保我们提出的解决方案可以用于我们已经确定的问题的多个实例。模式概括可以是一些简单的东西，比如编写一个基本的线性数学算法，就像我们为派对的成本所做的那样，其中每个孩子的成本是12美元。因此，任何数量*k*的孩子的成本将由12*k*给出。但模式概括可能远不止于此。
- en: If we go back to *Problem 1*, where you could choose $250 or you could choose
    your height in quarters, our pattern **generalization** would allow us to check
    for anyone's height against the $250 in order to determine whether you would get
    more money by choosing the cash option or by choosing the quarters.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到*问题1*，在那里你可以选择250美元，或者你可以选择用25美分的硬币来换算你的身高，我们的模式**概括**将允许我们检查任何人的身高与250美元的对比，以确定选择现金选项还是选择硬币哪个能让你得到更多的钱。
- en: '**Abstraction** lets us focus on the things we need and discard things we do
    not need in order to create the best algorithm for our problem. Now, depending
    on what we decide we need, we can add or remove some conditions.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**抽象**让我们专注于我们需要的东西，并丢弃我们不需要的东西，以便为我们的问题创建最佳算法。现在，根据我们决定需要什么，我们可以添加或删除一些条件。'
- en: For example, if I am a contestant, I only really want to know what option gives
    me more money. I do not care about total wins, who's choosing $250, who's choosing
    height, and so on. But if I'm the radio station, I may want to know the sum, the
    comparison to the baseline, and much more. I would have to choose that baseline
    and maybe even graphically show what has happened over time. That is all part
    of the abstraction process. When you are solving a computational thinking problem,
    you are also determining what matters and what does not matter to your solution
    and algorithm.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我是一个参赛者，我只想知道哪个选项给了我更多的钱。我不关心总胜利，谁选择了250美元，谁选择了身高等等。但如果我是广播电台，我可能想知道总和，与基准的比较，以及更多。我将不得不选择基准，甚至可能以图形方式显示随时间发生了什么。这都是抽象过程的一部分。当您解决计算思维问题时，您还在确定对您的解决方案和算法重要和不重要的事情。
- en: In the simplest form of this problem, if you are a contestant, you want to know
    what your best possible case for winnings is. If you choose $250 but your height
    makes it so that your height in quarters is more than $250, you would want to
    know. If you are working at the radio station, you may want to track more than
    just each winning individually. Abstraction allows you to adapt to all cases,
    from doing one mathematical problem to creating an algorithm that could track
    all the choices from all the contestants. Let's look now at how we can create
    those algorithms.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题的最简单形式中，如果你是一个参赛者，你想知道你赢得奖金的最佳可能情况是什么。如果你选择了250美元，但你的身高使得你的身高以25美分的硬币来换算的金额超过了250美元，你会想知道。如果你在广播电台工作，你可能想追踪不仅仅是每个获胜者的情况。抽象允许您适应所有情况，从解决一个数学问题到创建一个可以跟踪所有参赛者的所有选择的算法。现在让我们看看如何创建这些算法。
- en: Designing algorithms
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计算法
- en: As previously mentioned throughout this chapter, an *algorithm* is a set of
    instructions. When we are writing a computer program, the algorithm is a set of
    instructions given to the computer so it can provide a solution to a posted problem.
    We have been sticking to mathematical algorithms so far only because we haven't
    done a deeper dive into Python yet. However, we will now translate some of the
    algorithms into Python programming.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章中先前提到的，*算法*是一组指令。当我们编写计算机程序时，算法是一组指令，提供给计算机，以便它可以为所提出的问题提供解决方案。到目前为止，我们一直坚持数学算法，只是因为我们还没有深入研究Python。然而，我们现在将一些算法转化为Python编程。
- en: First, let's take a look at *Problem 1*. Here, we had a situation where you
    can win $250 or your height in quarters. Assuming it is you who's competing, you
    would want to know which option gives you the most in winnings.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来看一下*问题1*。在这里，我们有一个情况，你可以赢得250美元，或者你的身高以25美分的硬币来换算。假设是你在竞争，你会想知道哪个选项能让你赢得最多的奖金。
- en: 'Let''s take a look again at our mathematical algorithms from earlier in this
    chapter:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看一下本章前面的数学算法：
- en: 'Total winnings (customary): ![](image/Formula_B15413_02_011.png)'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总获胜金额（习惯单位）：![](image/Formula_B15413_02_011.png)
- en: 'Total winnings (metric): ![](image/Formula_B15413_02_012.png)'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总获胜金额（度量单位）：![](image/Formula_B15413_02_012.png)
- en: Remember, if you are using your height in customary units, you'll use the first
    algorithm. If you are using metric units, you'll want to adapt the program accordingly.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果您使用的是习惯单位的身高，您将使用第一个算法。如果您使用的是公制单位，您将需要相应地调整程序。
- en: When we are programming, we need to define our variables. In this case, `h`
    is the variable we are using for height. But think about it; your height may not
    change if you're an adult, but for the sake of argument, we will assume it won't
    always be the same. So, we will need whoever wants to know what the best option
    is, $250 or their height in quarters, to *input* their height so that the program
    will provide them with the answer.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编程时，我们需要定义我们的变量。在这种情况下，`h`是我们用于身高的变量。但想想看；如果你是一个成年人，你的身高可能不会改变，但为了论证的目的，我们将假设它不会总是相同。因此，我们需要想知道哪个选项更好，250美元还是用25美分的硬币来换算他们的身高的人*输入*他们的身高，以便程序会为他们提供答案。
- en: '**Input** is something the user can enter. So, when we define our variable,
    we are going to ask for input. A good practice in Python and any other language
    is not to just ask for the input with no guidance. That is, we want to tell the
    user the question they are answering. For example, I can write the following code
    to ask a user for their height input:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 输入是用户可以输入的内容。因此，当我们定义变量时，我们将要求输入。在Python和任何其他语言中，一个好的做法不仅仅是要求输入而没有任何指导。也就是说，我们希望告诉用户他们正在回答的问题。例如，我可以编写以下代码来要求用户输入他们的身高：
- en: '[PRE0]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code will ask the user to enter some input. It also asks that
    the user enter the information in inches. If you were using metric units, you
    would state that instead.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将要求用户输入一些内容。它还要求用户以英寸输入信息。如果您使用的是公制单位，您将相应说明。
- en: We also saved the information as the variable `h`. But we haven't done anything
    with that variable yet.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将信息保存为变量`h`。但我们还没有对该变量做任何操作。
- en: 'We can just do the basic math and print out the value we get based on height:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进行基本的数学运算，并根据身高打印出我们得到的值：
- en: '[PRE1]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice in the preceding snippet that we used `int(h)` in the definition of the
    `total` variable. We converted the `h` value to an integer so we could perform
    a mathematical operation using that variable. When we asked for the input, the
    variable was saved as a string, which is why we need to convert it to be able
    to use it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在上面的片段中，我们在`total`变量的定义中使用了`int(h)`。我们将`h`值转换为整数，以便可以使用该变量进行数学运算。当我们要求输入时，变量被保存为字符串，这就是为什么我们需要转换它以便使用它。
- en: 'Running the previous code with my height, which is 70 inches, yields the following
    result:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我的身高运行上述代码，即70英寸，得到以下结果：
- en: '[PRE2]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It would look much better if we rounded that answer, and Python has a way for
    us to do that easily. If we adjust the print code shown as follows, our answer
    will result in `253.62`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将打印代码调整如下所示，我们的答案将是`253.62`，看起来会好得多：
- en: '[PRE3]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When I run this program, here''s what the window looks like:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行这个程序时，窗口看起来是这样的：
- en: '![Figure 2.1 – Python program output'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.1 – Python程序输出'
- en: '](image/Figure_02.01_B15413.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_02.01_B15413.jpg)'
- en: Figure 2.1 – Python program output
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – Python程序输出
- en: 'But sometimes we want the code to do more. Let''s remove that `print` command
    and create some conditions. In the next few lines, we will use the value provided
    to make some comparisons. For example, we can ask the computer to check some things
    for us. There are three possibilities:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时我们希望代码做更多的事情。让我们删除那个`print`命令并创建一些条件。在接下来的几行中，我们将使用提供的值进行一些比较。例如，我们可以要求计算机为我们检查一些事情。有三种可能性：
- en: Our height could yield exactly the same as $250.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的身高可能会产生与250美元完全相同的结果。
- en: Our height could yield less than $250.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的身高可能会产生少于250美元的结果。
- en: Our height could yield more than $250.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的身高可能会产生超过250美元的结果。
- en: 'Now, I will ask the computer to tell me what to do based on those conditions.
    We will need an **if-elif**, **else** statement for this. These are conditions
    that we will test in order to receive better output. We will test whether the
    total is the same as $250\. Else, if the total is less than $250, we will want
    the computer to do something (that is our `elif` statement). Finally, in all other
    cases, we will use the `else` command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我将要求计算机根据这些条件告诉我该做什么。我们将需要一个**if-elif**，**else**语句。这些是我们将测试的条件，以便获得更好的输出。我们将测试总额是否与250美元相同。否则，如果总额少于250美元，我们将希望计算机执行某些操作（这是我们的`elif`语句）。最后，在所有其他情况下，我们将使用`else`命令：
- en: '[PRE4]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let's see what some test cases look like.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些测试案例是什么样子的。
- en: 'First, let''s use a height of **69** inches:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用**69**英寸的身高：
- en: '![Figure 2.2 – Case 1: Height yields $250'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.2 – 情况1：身高产生250美元'
- en: '](image/Figure_02.02_B15413.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_02.02_B15413.jpg)'
- en: 'Figure 2.2 – Case 1: Height yields $250'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 情况1：身高产生250美元
- en: So, anyone who is 5'9" cannot go wrong with either choice, since they'll always
    end up winning $250.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，任何身高为5'9"的人无论做出哪种选择都不会错，因为他们最终都会赢得250美元。
- en: 'Now, let''s look at my height, **70** inches:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我的身高，**70**英寸：
- en: '![Figure 2.3 – Case 2: Height yields more than $250'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.3 – 情况2：身高产生的金额超过250美元'
- en: '](image/Figure_02.03_B15413.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_02.03_B15413.jpg)'
- en: 'Figure 2.3 – Case 2: Height yields more than $250'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – 情况2：身高产生的金额超过250美元
- en: 'Finally, let''s look at a height less than 69 inches, so let''s use **55**
    inches:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看一下小于69英寸的身高，所以让我们使用**55**英寸：
- en: '![Figure 2.4 – Case 3: Height yields less than $250'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.4 – 情况3：身高产生的金额少于250美元'
- en: '](image/Figure_02.04_B15413.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_02.04_B15413.jpg)'
- en: 'Figure 2.4 – Case 3: Height yields less than $250'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – 情况3：身高产生的金额少于250美元
- en: Notice that we can adjust the code to say what we want it to. I chose to use
    full sentences to establish the results, but you could adapt and adjust the code
    as needed to suit your needs or preferences. Some of the code may be challenging
    at this point, but we will be doing a deeper dive with the Python programming
    language in [*Chapter 8*](B15413_08_Final_SK_ePub.xhtml#_idTextAnchor114), *Introduction
    to Python*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们可以调整代码以表达我们想要的内容。我选择使用完整的句子来阐明结果，但您可以根据需要调整代码以满足您的需求或偏好。此时，一些代码可能具有挑战性，但我们将在[*第8章*](B15413_08_Final_SK_ePub.xhtml#_idTextAnchor114)中深入学习Python编程语言，*Python简介*。
- en: As you can see, we have three algorithms that provide us with the same kind
    of information. One is more robust than the other two, but how complex or simple
    our algorithm is depends on what we need from it. If you were holding this raffle
    again later on, you might have forgotten what the algorithm was, how you wrote
    it, or what everything meant. However, with the last code, you get a lot of information
    just by running it, which is more helpful than the first two. You can also add
    all that information as comments within the code too, but we will talk about those
    in [*Chapter 8*](B15413_08_Final_SK_ePub.xhtml#_idTextAnchor114), *Introduction
    to Python*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们有三种算法，它们为我们提供了相同类型的信息。其中一种比其他两种更加健壮，但我们的算法是复杂还是简单取决于我们从中需要什么。如果您稍后再次举行这次抽奖，您可能会忘记算法是什么，您是如何编写的，或者一切意味着什么。然而，通过最后的代码，您只需运行它就可以获得大量信息，这比前两种更有帮助。您还可以将所有这些信息作为注释添加到代码中，但我们将在[*第8章*](B15413_08_Final_SK_ePub.xhtml#_idTextAnchor114)中讨论这些内容，*Python简介*。
- en: Also keep in mind that we ran this as if we were the contestants. While that
    is helpful, you may want to consider what changes you would make if you were the
    radio station. You could write some code that saves all the instances that are
    run so that you can then check and add all the winnings. You could even calculate
    that sum through code. Since that code is a bit more complex, we will be touching
    on it more throughout the book and, more specifically, in [*Chapter 8*](B15413_08_Final_SK_ePub.xhtml#_idTextAnchor114),
    *Introduction to Python*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，我们运行这个程序就好像我们是参赛者一样。虽然这很有帮助，但您可能要考虑如果您是广播电台会做出什么改变。您可以编写一些代码来保存所有运行的实例，以便随后检查和添加所有的奖金。您甚至可以通过代码计算出总和。由于该代码稍微复杂，我们将在整本书中更详细地讨论它，特别是在[*第8章*](B15413_08_Final_SK_ePub.xhtml#_idTextAnchor114)中，*Python简介*。
- en: Now, let's take a look at a few more problems and respective algorithms in order
    to get more comfortable with the computational thinking process.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一些更多的问题和相应的算法，以便更加熟悉计算思维过程。
- en: Additional problems
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他问题
- en: Throughout this section, we are going to take a look at additional problems.
    For *Problem 2*, we will go right into the algorithm, as we went through the other
    steps in the problem earlier in this chapter. The next problem will have the entire
    computational thinking process as well.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将继续研究其他问题。对于*问题2*，我们将直接进入算法，因为我们在本章的早些时候已经完成了其他步骤。下一个问题也将包括整个计算思维过程。
- en: Problem 2 - Children's soccer party
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题2 - 儿童足球派对
- en: Earlier in this chapter, we were planning a party for a soccer team, where there
    was a cost of $12 per child. We stated that the number of children was unknown,
    so we will use the variable *k* to designate the unknown quantity. We also stated
    that we had a mathematical algorithm, T = 12*k*, that gave us the total cost,
    T, of *k* children. Let's add a condition here. If we had a budget of $200, we'd
    want to know if we are over, under, or right on that budget.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早些时候，我们正在为一个足球队筹办派对，每个孩子的费用是12美元。我们说孩子的数量是未知的，所以我们将使用变量*k*来表示未知数量。我们还说我们有一个数学算法，T
    = 12*k*，它给出了*k*个孩子的总费用T。让我们在这里添加一个条件。如果我们的预算是200美元，我们想知道我们是超支、不足还是正好符合预算。
- en: 'We can use Python to write an algorithm for this situation as well:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用Python为这种情况编写算法：
- en: '[PRE5]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s test some cases in order to verify that our code is working:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一些情况，以验证我们的代码是否有效：
- en: '![Figure 2.5 – Case 1: 12 children attend the party'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.5–案例1：有12个孩子参加派对'
- en: '](image/Figure_02.05_B15413.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_02.05_B15413.jpg)'
- en: 'Figure 2.5 – Case 1: 12 children attend the party'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5–案例1：有12个孩子参加派对
- en: '*Great!* We are under budget if 12 children attend. So, *what if 20 children
    attend?* Let''s have a look:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*太好了！*如果有12个孩子参加，我们就不会超支。那么*如果有20个孩子参加呢？*让我们看一下：'
- en: '![Figure 2.6 – Case 2: 20 children attend the party'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.6–案例2：有20个孩子参加派对'
- en: '](image/Figure_02.06_B15413.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_02.06_B15413.jpg)'
- en: 'Figure 2.6 – Case 2: 20 children attend the party'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6–案例2：有20个孩子参加派对
- en: '*We do not have enough money for 20 children!*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们没有足够的钱供20个孩子！*'
- en: As you can see, the program provides us with some information about the total
    and whether we are over or under budget. As with any algorithm, this isn't the
    only way we could write the program in order to get this information. Try your
    hand at different algorithms to solve this simple problem or add a few conditions
    of your own and code them. Practice and adding conditions will allow you to get
    more comfortable designing and writing algorithms.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，程序为我们提供了有关总数以及我们是否超支或不足的一些信息。与任何算法一样，这并不是我们获取此信息的唯一方式。尝试使用不同的算法来解决这个简单的问题，或者添加一些自己的条件并编写代码。练习和添加条件将使您更加熟悉设计和编写算法。
- en: Problem 3 - Savings and interest
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题3 - 储蓄和利息
- en: Now we have a new problem. A bank pays compound interest at a rate of *x*% per
    month. *What will be the payout after a number of years if you deposit any given
    amount?*
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个新问题。一家银行以每月*x*％的复利率支付复利。*如果您存入任意金额，经过多年后将会支付多少？*
- en: Let's **decompose** this problem. First of all, we know interest is compounded
    monthly. Let's talk about compound interest. The interest on an investment is
    the percentage that is paid out in a time period. Compound interest means that
    the interest pays out on the initial amount plus interest each time. Compound
    interest is a **pattern**. In fact, a formula exists for it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们**分解**一下这个问题。首先，我们知道利息是按月复利的。让我们谈谈复利。投资的利息是在一段时间内支付的百分比。复利意味着利息每次都是在初始金额加上利息支付的。复利是一种**模式**。实际上，它有一个公式。
- en: 'The thing I do not know is what percentage the bank is paying out, or the amount
    deposited, or the number of years it''ll be deposited for. So, we will need to
    write a program that addresses all of the possibilities. This is **pattern generalization**.
    What we do know is that the interest is compounded monthly. There is actually
    a mathematical formula for this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道的是银行支付的百分比、存款金额或存款年限。因此，我们需要编写一个程序来处理所有可能性。这就是**模式概括**。我们知道的是利息是按月复利的。实际上，这有一个数学公式：
- en: '![](image/Formula_B15413_02_013.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](image/Formula_B15413_02_013.jpg)'
- en: 'Let''s talk about the terms from the preceding equation:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈一下上述方程中的术语：
- en: '*A* is the total amount.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*A*是总金额。'
- en: '*P* is the principal amount, that is, the initial deposit.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*P*是本金，即初始存款。'
- en: '*r* is the interest rate (keep in mind that for 3%, the interest is written
    as 0.03, for example).'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*r*是利率（请记住，对于3%，利率写作0.03，例如）。'
- en: '*n* is the number of times interest is compounded per year.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n*是每年复利的次数。'
- en: '*t* is the number of years the deposit goes untouched.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*t*是存款未动的年数。'
- en: 'Because there is a mathematical algorithm, we can now create a program for
    this using the formula. However, we will need to make sure whoever runs the program
    knows what it is we are asking for with regard to all the inputs. We are asking
    for a few things:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 因为有一个数学算法，我们现在可以使用公式为此创建一个程序。但是，我们需要确保运行程序的人知道我们要求关于所有输入的内容。我们需要询问一些事情：
- en: '*What amount is being deposited?*'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*存入多少金额？*'
- en: '*At what rate is the bank paying?*'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*银行支付的利率是多少？*'
- en: '*For how many years will the money be deposited?*'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*存款多少年？*'
- en: We do know the *n* in the formula. That *n* is 12 because this is monthly compound
    interest. That means it will compound 12 times each year. So, *n* = 12.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道公式中的*n*。这里*n*等于12，因为这是按月复利。这意味着每年会复利12次。所以，*n* = 12。
- en: 'Now it is time to write the program for this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候编写这个程序了：
- en: '![Figure 2.7 – Sample program for compound interest'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.7 - 复利样本程序'
- en: '](image/Figure_02.07_B15413.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_02.07_B15413.jpg)'
- en: Figure 2.7 – Sample program for compound interest
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 - 复利样本程序
- en: 'The preceding screenshot shows us the Python program for compound interest.
    Notice the comment, which is preceded by the `#` symbol. It states that we needed
    to convert the rate to use the formula. We would have otherwise obtained an incorrect
    total. In addition, we used float here because we need to use decimals. The integers,
    or `int`, would not give us the information we needed. Also, we rounded the total
    to two decimal places. That is because we use two decimal places when we talk
    about money. The text for the algorithm shown in *Figure 2.7* is included as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的截图显示了复利的Python程序。请注意注释前面有`#`符号。它说明我们需要将利率转换为公式中使用的形式。否则，我们将得到一个不正确的总额。此外，我们在这里使用了浮点数，因为我们需要使用小数。整数或`int`不会给我们所需的信息。此外，我们将总额四舍五入到两位小数。这是因为我们在谈论金钱时使用两位小数。*图2.7*中显示的算法文本如下：
- en: '[PRE6]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Using the code from the compound interest algorithm, we can run any possible
    instance for compound interest if we have the initial amount, the rate, and the
    number of years we will be depositing the amount for. The output of the program
    given an initial deposit of $1,000 at a rate of 4.5% for 10 years is provided
    as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用复利算法中的代码，如果我们有初始金额、利率和存款年限，我们可以运行任何可能的复利实例。给定初始存款$1,000，利率4.5%，存款10年的程序输出如下：
- en: '![Figure 2.8 – Sample 1: Output for compound interest'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.8 - 复利输出示例'
- en: '](image/Figure_02.08_B15413.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_02.08_B15413.jpg)'
- en: 'Figure 2.8 – Sample 1: Output for compound interest'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 - 复利输出示例
- en: As you can see, the total after 10 years for a deposit of $1,000 at 4.5% compounded
    monthly is $1,566.99.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，按月复利存入$1,000，10年后的总额为$1,566.99。
- en: 'Let''s test the program one more time. This time, we will deposit $**5,000**
    at a **3.5**% rate compounded monthly for **20** years:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次测试程序。这一次，我们将以3.5%的利率按月复利存入**5,000**美元，存款期为**20**年：
- en: '![Figure 2.9 – Sample 2: Output for compound interest'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.9 - 复利输出示例'
- en: '](image/Figure_02.09_B15413.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_02.09_B15413.jpg)'
- en: 'Figure 2.9 – Sample 2: Output for compound interest'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 - 复利输出示例
- en: Our total after 20 years would be $10,058.51\. *That means our money doubled!*
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 20年后我们的总额将是$10,058.51。*这意味着我们的钱翻了一番！*
- en: 'Having this calculator program allows us to only calculate for interest compounded
    monthly. We can create a new program to calculate interest compounded at any rate:
    monthly, annually, bi-monthly, and so on. You can try playing with the code in
    order to create your calculators. These are helpful if you want to know what to
    expect when investing money or depositing in savings accounts. For example, you
    can determine how long it would take for your deposits to reach a certain amount.
    Say you wanted $50,000 for a college education for your children. In this case,
    you could figure out how much you would need to deposit in order to have that
    amount in 18 years, when they''d most likely be ready to go to college.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个计算器程序，我们只能计算按月复利的利息。我们可以创建一个新程序来计算以任何利率复利的利息：每月、每年、每两个月等等。您可以尝试使用代码来创建自己的计算器。如果您想知道投资或存款在未来会有什么预期，这些都是很有帮助的。例如，您可以确定需要多长时间才能将存款达到一定金额。比如，您想要为孩子的大学教育存入50,000美元。在这种情况下，您可以计算出在18年内需要存入多少金额，到那时他们很可能已经准备好上大学了。
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we have gone through the computational thinking process. We
    learned about the four major elements of computational thinking: decomposition,
    pattern recognition, pattern generalization, and algorithm design. We also learned
    that problems in computational thinking are not always clearly defined. It is
    up to us to interpret and decompose the information so we can find the patterns.
    Once we find the patterns and define what we''d like to generalize, we can then
    design algorithms in order to solve our problems.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们已经经历了计算思维的过程。我们了解了计算思维的四个主要元素：分解、模式识别、模式概括和算法设计。我们还了解到，在计算思维中的问题并不总是清晰定义的。我们需要解释和分解信息，以便找到模式。一旦我们找到模式并定义了我们想要概括的内容，我们就可以设计算法来解决问题。
- en: We also learned that algorithms and solutions are not unique. There are multiple
    ways to write an algorithm for each problem we encounter. The computational thinking
    process allows us to explore problems in multiple ways and create solutions that
    align with our own interpretations and needs.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解到，算法和解决方案并不是唯一的。对于我们遇到的每个问题，都有多种编写算法的方式。计算思维过程使我们能够以多种方式探索问题，并创建符合我们自己解释和需求的解决方案。
- en: In the next chapter, we will be learning about algorithms and algorithmic thinking
    more in depth, as they are the product of all computational thinking problems.
    In order to better understand algorithms, we will take a look at Boolean operators
    and learn how to identify and address errors in logic processing. We will write
    algorithms for problems presented, as well as analyze given algorithms for possible
    errors in processing.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地学习算法和算法思维，因为它们是所有计算思维问题的产物。为了更好地理解算法，我们将研究布尔运算符，并学习如何识别和解决逻辑处理中的错误。我们将为所提出的问题编写算法，并分析给定算法中可能存在的处理错误。
