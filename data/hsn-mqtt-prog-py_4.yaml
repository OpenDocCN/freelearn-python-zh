- en: Writing Code to Control a Vehicle with Python and MQTT Messages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python和MQTT消息编写控制车辆的代码
- en: 'In this chapter, we will write Python 3.x code to control a vehicle with MQTT
    messages delivered through encrypted connections (TLS 1.2). We will write code
    that will be able to run on different popular IoT platforms, such as a Raspberry
    Pi 3 board. We will understand how we can leverage our knowledge of the MQTT protocol
    to build a solution based on requirements. We will learn to work with the latest
    version of the Eclipse Paho MQTT Python client library. We will gain take an in-depth
    look at the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将编写Python 3.x代码，以通过加密连接（TLS 1.2）传递MQTT消息来控制车辆。我们将编写能够在不同流行的物联网平台上运行的代码，例如Raspberry
    Pi 3板。我们将了解如何利用我们对MQTT协议的了解来构建基于要求的解决方案。我们将学习如何使用最新版本的Eclipse Paho MQTT Python客户端库。我们将深入研究以下内容：
- en: Understanding the requirements to control a vehicle with MQTT
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解使用MQTT控制车辆的要求
- en: Defining the topics and commands
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义主题和命令
- en: Learning the benefits of working with Python
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习使用Python的好处
- en: Creating a virtual environment with Python 3.x and PEP 405
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python 3.x和PEP 405创建虚拟环境
- en: Understanding the directory structure for a virtual environment
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解虚拟环境的目录结构
- en: Activating the virtual environment
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 激活虚拟环境
- en: Deactivating the virtual environment
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停用虚拟环境
- en: Installing paho-mqtt for Python
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Python安装paho-mqtt
- en: Connecting a client to the secured MQTT server with paho-mqtt
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用paho-mqtt将客户端连接到安全的MQTT服务器
- en: Understanding callbacks
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解回调
- en: Subscribing to topics with Python
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python订阅主题
- en: Configuring certificates for IoT boards that will work as clients
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为将作为客户端工作的物联网板配置证书
- en: Creating a class to represent a vehicle
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建代表车辆的类
- en: Receiving messages in Python
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中接收消息
- en: Working with multiple calls to the loop method
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多次调用循环方法
- en: Understanding the requirements to control a vehicle with MQTT
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解使用MQTT控制车辆的要求
- en: In the previous three chapters, we learned how MQTT works in detail. We understood
    how to establish a connection between an MQTT client and an MQTT server. We learned
    what happened when we subscribed to topic filters and when a publisher sent messages
    to specific topics. We installed a Mosquitto server and then we secured it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在前三章中，我们详细了解了MQTT的工作原理。我们了解了如何在MQTT客户端和MQTT服务器之间建立连接。我们了解了当我们订阅主题过滤器时以及当发布者向特定主题发送消息时会发生什么。我们安装了Mosquitto服务器，然后对其进行了安全设置。
- en: Now, we will use Python as our main programming language to generate MQTT clients
    that will act as publishers and subscribers. We will connect a Python MQTT client
    to the MQTT server and we will process commands to control a small vehicle with
    MQTT messages. The small vehicle replicates many capabilities found in real-life
    road vehicles.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用Python作为我们的主要编程语言，生成将充当发布者和订阅者的MQTT客户端。我们将连接Python MQTT客户端到MQTT服务器，并处理命令以通过MQTT消息控制小型车辆。这辆小车复制了现实道路车辆中发现的许多功能。
- en: 'We will use TLS encryption and TLS authentication because we don''t want any
    MQTT client to be able to send commands to our vehicle. We want our Python 3.x
    code to run on many platforms because we will use the same code base to control
    vehicles that use the following IoT boards:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用TLS加密和TLS认证，因为我们不希望任何MQTT客户端能够向我们的车辆发送命令。我们希望我们的Python 3.x代码能够在许多平台上运行，因为我们将使用相同的代码库来控制使用以下物联网板的车辆：
- en: Raspberry Pi 3 Model B+
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raspberry Pi 3 Model B+
- en: Qualcomm DragonBoard 410c
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高通龙板410c
- en: BeagleBone Black
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BeagleBone Black
- en: MinnowBoard Turbot Quad-Core
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MinnowBoard Turbot Quad-Core
- en: LattePanda 2G
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LattePanda 2G
- en: UP Core 4GB
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UP Core 4GB
- en: UP Squared
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UP Squared
- en: Depending on the platform, each vehicle is going to provide additional features
    because some boards are more powerful compared to other boards. However, we will
    focus on the basic features to keep our example simple and stay concentrated on
    MQTT. Then, we will be able to use this project as a baseline for other solutions
    that require us to run code on an IoT board that runs Python 3.x code, has to
    connect to an MQTT server, and processes commands.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 根据平台的不同，每辆车将提供额外的功能，因为一些板比其他板更强大。但是，我们将专注于基本功能，以保持我们的示例简单，并集中在MQTT上。然后，我们将能够将此项目用作其他需要我们在运行Python
    3.x代码的物联网板上运行代码，连接到MQTT服务器并处理命令的解决方案的基线。
- en: The code that runs on the boards that power the vehicles must be able to process
    commands received in messages on a specific topic. We will use JSON strings in
    the payloads.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动车辆的板上运行的代码必须能够处理在特定主题的消息中接收到的命令。我们将在有效载荷中使用JSON字符串。
- en: A client application also written in Python must be able to control one or more
    vehicles. We will also write the client application in Python and it will publish
    MQTT messages with JSON strings to the topic for each vehicle. The client application
    must display the results of executing each command. Each vehicle must publish
    a message to a specific topic whenever a command is successfully executed.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，还必须使用Python编写的客户端应用程序能够控制一个或多个车辆。我们还将使用Python编写客户端应用程序，并且它将向每辆车的主题发布带有JSON字符串的MQTT消息。客户端应用程序必顶要显示执行每个命令的结果。每辆车在成功执行命令时必须向特定主题发布消息。
- en: Defining the topics and commands
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义主题和命令
- en: 'We will use the following topic name to publish the commands for a vehicle:
    `vehicles/vehiclename/commands`, where `vehiclename` must be replaced with a unique
    name assigned to a vehicle. For example, if we assign `vehiclepi01` as the name
    for a vehicle that is powered by a Raspberry Pi 3 Model B+ board, we will have
    to publish commands to the `vehicles/vehiclepi01/commands` topic. The Python code
    that runs on this board will subscribe to this topic to receive messages with
    commands and react to them.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下主题名称发布车辆的命令：`vehicles/vehiclename/commands`，其中`vehiclename`必须替换为分配给车辆的唯一名称。例如，如果我们将`vehiclepi01`分配为由Raspberry
    Pi 3 Model B+板驱动的车辆的名称，我们将不得不向`vehicles/vehiclepi01/commands`主题发布命令。在该板上运行的Python代码将订阅此主题，以接收带有命令的消息并对其做出反应。
- en: 'We will use the following topic name to make the vehicles publish details about
    the successfully executed commands: `vehicles/vehiclename/executedcommands`, where
    `vehiclename` must be replaced with a unique name assigned to a vehicle. For example,
    if we assign `vehiclebeagle03` as the name for a vehicle that is powered by a
    BeagleBone Black board, the client that wants to receive information about successfully
    processed commands has to subscribe to the `vehicles/vehiclebeagle03/executedcommands`
    topic.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下主题名称使车辆发布有关成功执行命令的详细信息：`vehicles/vehiclename/executedcommands`，其中`vehiclename`必须替换为分配给车辆的唯一名称。例如，如果我们将`vehiclebeagle03`分配为由BeagleBone
    Black板提供动力的车辆的名称，那么想要接收有关成功处理命令的信息的客户端必须订阅`vehicles/vehiclebeagle03/executedcommands`主题。
- en: 'The commands will be sent in a JSON string with a key-value pair. The key must
    be equal to CMD and the value must specify any of the following valid commands.
    When the command requires additional parameters, the parameter name must be included
    in the next key and the value for this parameter in the value for this key:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将以JSON字符串的形式发送，其中包含键值对。键必须等于CMD，值必须指定以下任何有效命令之一。当命令需要额外参数时，参数名称必须包含在下一个键中，而此参数的值必须包含在此键的值中：
- en: '`TURN_ON_ENGINE`: Turn on the vehicle''s engine.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动车辆的发动机。
- en: '`TURN_OFF_ENGINE`: Turn off the vehicle''s engine.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭车辆的发动机。
- en: '`LOCK_DOORS`: Close and lock the vehicle''s doors.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁上车门。
- en: '`UNLOCK_DOORS`: Unlock and open the vehicle''s doors.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解锁并打开车门。
- en: '`PARK`: Park the vehicle.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停车：停车。
- en: '`PARK_IN_SAFE_PLACE`: Park the vehicle in a safe place that is configured for
    the vehicle.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在为车辆配置的安全位置停车。
- en: '`TURN_ON_HEADLIGHTS`: Turn on the vehicle''s headlights.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开车辆的前灯。
- en: '`TURN_OFF_HEADLIGHTS`: Turn off the vehicle''s headlights.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭车辆的前灯。
- en: '`TURN_ON_PARKING_LIGHTS`: Turn on the vehicle''s parking lights, also known
    as sidelights.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开车辆的停车灯，也称为侧灯。
- en: '`TURN_OFF_PARKING_LIGHTS`: Turn off the vehicle''s parking lights, also known
    as sidelights.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭车辆的停车灯，也称为侧灯。
- en: '`ACCELERATE`: Accelerate the vehicle, that is, press the gas pedal.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加速：加速车辆，即踩油门。
- en: '`BRAKE`: Brake the vehicle, that is, press the brake pedal.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 刹车：刹车车辆，即踩刹车踏板。
- en: '`ROTATE_RIGHT`: Make the vehicle rotate to the right. We must specify how many
    degrees we want the vehicle to rotate right in the value for the DEGREES key.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向右旋转：使车辆向右旋转。我们必须在DEGREES键的值中指定我们希望车辆向右旋转多少度。
- en: '`ROTATE_LEFT`: Make the vehicle rotate to the left. We must specify how many
    degrees we want the vehicle to rotate left in the value for the DEGREES key.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向左旋转：使车辆向左旋转。我们必须在DEGREES键的值中指定我们希望车辆向左旋转多少度。
- en: '`SET_MAX_SPEED`: Set the maximum speed that we allow to the vehicle. We must
    specify the desired maximum speed in miles per hour in the value for the MPH key.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置我们允许车辆的最高速度。我们必须在MPH键的值中指定所需的最高速度（以每小时英里为单位）。
- en: '`SET_MIN_SPEED`: Set the minimum speed that we allow to the vehicle. We must
    specify the desired minimum speed in miles per hour in the value for the MPH key.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置我们允许车辆的最低速度。我们必须在MPH键的值中指定所需的最低速度（以每小时英里为单位）。
- en: 'The following line shows an example of the payload for the command that turns
    on the vehicle''s engine:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下一行显示了将车辆的发动机打开的命令的有效负载示例：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following line shows an example of the payload for the command that sets
    the maximum speed for the vehicle to five miles per hour:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下一行显示了将车辆的最高速度设置为每小时五英里的命令的有效负载示例：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have all the necessary details to start coding with Python.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好开始使用Python编码所需的所有细节。
- en: Creating a virtual environment with Python 3.6.x and PEP 405
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python 3.6.x和PEP 405创建虚拟环境
- en: 'In the next sections and chapters, we will be writing different pieces of Python
    code that will subscribe to topics and will also publish messages to topics. As
    happens whenever we want to isolate an environment that requires additional packages,
    it is convenient to work with Python virtual environments. Python 3.3 introduced
    lightweight virtual environments, and they were improved in Python 3.4\. We will
    work with these virtual environments, and therefore, you will need Python 3.4
    or greater. You can read more about PEP 405 Python Virtual Environment, which
    introduced the `venv` module, here: [https://www.python.org/dev/peps/pep-0405](https://www.python.org/dev/peps/pep-0405).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将编写不同的Python代码片段，这些代码片段将订阅主题，并且还将向主题发布消息。每当我们想要隔离需要额外软件包的环境时，最好使用Python虚拟环境。Python
    3.3引入了轻量级虚拟环境，并在Python 3.4中进行了改进。我们将使用这些虚拟环境，因此，您需要Python 3.4或更高版本。您可以在此处阅读有关PEP
    405 Python虚拟环境的更多信息，该文档介绍了venv模块：[https://www.python.org/dev/peps/pep-0405](https://www.python.org/dev/peps/pep-0405)。
- en: All the examples for this book were tested on Python 3.6.2 on macOS and Linux.
    The examples were also tested on the IoT boards mentioned throughout the book
    and their most popular operating systems. For example, all the examples were tested
    on Raspbian. Raspbian is based on Debian Linux, and therefore, all the instructions
    for Linux will work for Raspbian.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的所有示例都在macOS和Linux上的Python 3.6.2上进行了测试。这些示例还在本书中提到的物联网板上进行了测试，以及它们最流行的操作系统。例如，所有示例都在Raspbian上进行了测试。
    Raspbian基于Debian Linux，因此，所有Linux的说明都适用于Raspbian。
- en: If you decide to use the popular `virtualenv` ([https://pypi.python.org/pypi/virtualenv](https://pypi.python.org/pypi/virtualenv))
    third-party virtual environment builder or the virtual environment options provided
    by your Python IDE, you just have to make sure that you activate your virtual
    environment with the appropriate mechanism whenever it is necessary to do so,
    instead of following the step explained to activate the virtual environment generated
    with the `venv` module integrated in Python.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您决定使用流行的`virtualenv`（[https://pypi.python.org/pypi/virtualenv](https://pypi.python.org/pypi/virtualenv)）第三方虚拟环境构建器或您的Python
    IDE提供的虚拟环境选项，您只需确保在必要时激活您的虚拟环境，而不是按照使用Python中集成的`venv`模块生成的虚拟环境的步骤来激活它。
- en: Each virtual environment we create with `venv` is an isolated environment and
    it will have its own independent set of installed Python packages in its site
    directories (folders). When we create a virtual environment with `venv` in Python
    3.4 and greater, `pip` is included in the new virtual environment. In Python 3.3,
    it was necessary to manually install `pip` after creating the virtual environment.
    Note that the instructions provided are compatible with Python 3.4 or greater,
    including Python 3.6.x. The following commands assume that you have Python 3.5.x
    or greater installed on Linux, macOS, or Windows.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`venv`创建的每个虚拟环境都是一个隔离的环境，并且它将在其站点目录（文件夹）中具有其自己独立安装的Python软件包集。在Python 3.4及更高版本中，使用`venv`创建虚拟环境时，`pip`已包含在新的虚拟环境中。在Python
    3.3中，需要在创建虚拟环境后手动安装`pip`。请注意，所提供的说明与Python 3.4或更高版本兼容，包括Python 3.6.x。以下命令假定您在Linux、macOS或Windows上已安装了Python
    3.5.x或更高版本。
- en: 'First, we have to select the target folder or directory for our lightweight
    virtual environment. The following is the path we will use in the example for
    Linux and macOS. The target folder for the virtual environment will be the `HillarMQTT/01`
    folder within our home directory. For example, if our home directory in macOS
    or Linux is `/Users/gaston`, the virtual environment will be created within `/Users/gaston/HillarMQTT/01`.
    You can replace the specified path with your desired path in each command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须选择我们轻量级虚拟环境的目标文件夹或目录。以下是我们在Linux和macOS示例中将使用的路径。虚拟环境的目标文件夹将是我们的主目录中的`HillarMQTT/01`文件夹。例如，如果我们在macOS或Linux中的主目录是`/Users/gaston`，则虚拟环境将在`/Users/gaston/HillarMQTT/01`中创建。您可以在每个命令中用您想要的路径替换指定的路径：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following is the path we will use in the example for Windows. The target
    folder for the virtual environment will be the `HillarMQTT\01` folder within our
    user profile folder. For example, if our user profile folder is `C:\Users\gaston`,
    the virtual environment will be created within `C:\Users\gaston\HillarMQTT\01`.
    You can replace the specified path with your desired path in each command:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们在Windows示例中将使用的路径。虚拟环境的目标文件夹将是用户个人资料文件夹中的`HillarMQTT\01`文件夹。例如，如果我们的用户个人资料文件夹是`C:\Users\gaston`，则虚拟环境将在`C:\Users\gaston\HillarMQTT\01`中创建。您可以在每个命令中用您想要的路径替换指定的路径：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In Windows PowerShell, the previous path would be:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows PowerShell中，上一个路径将是：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, we have to use the `-m` option followed by the `venv` module name and the
    desired path to make Python run this module as a script and create a virtual environment
    in the specified path. The instructions are different depending on the platform
    in which we are creating the virtual environment.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须使用`-m`选项，后跟`venv`模块名称和所需的路径，使Python运行此模块作为脚本，并在指定的路径中创建虚拟环境。根据我们创建虚拟环境的平台，指令是不同的。
- en: 'Open Terminal in Linux or macOS and execute the following command to create
    a virtual environment:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux或macOS中打开终端并执行以下命令创建虚拟环境：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In Windows, in Command Prompt, execute the following command to create a virtual
    environment:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows的命令提示符中，执行以下命令创建虚拟环境：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you want to work with Windows PowerShell, execute the following command
    to create a virtual environment:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要在Windows PowerShell中工作，请执行以下命令创建虚拟环境：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: None of the previous commands produce any output. The script created the specified
    target folder and installed `pip` by invoking `ensurepip` because we didn't specify
    the `--without-pip` option.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 上述任何命令都不会产生任何输出。脚本通过调用`ensurepip`安装了`pip`，因为我们没有指定`--without-pip`选项。
- en: Understanding the directory structure for a virtual environment
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解虚拟环境的目录结构
- en: The specified target folder has a new directory tree that contains Python-executable
    files and other files that indicate it is a PEP405 virtual environment.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 指定的目标文件夹具有一个新的目录树，其中包含Python可执行文件和其他文件，表明它是一个PEP405虚拟环境。
- en: 'In the root directory for the virtual environment, the `pyenv.cfg` configuration
    file specifies different options for the virtual environment and its existence
    is an indicator that we are in the root folder for a virtual environment. In Linux
    and macOS, the folder will have the following main subfolders: `bin`, `include`,
    `lib`, `lib/python3.6`, and `lib/python3.6/site-packages`. Note that the folder
    names can be different based on the specific Python version. In Windows, the folder
    will have the following main subfolders: `Include`, `Lib`, `Lib\site-packages`,
    and `Scripts`. The directory trees for the virtual environment in each platform
    are the same as the layout of the Python installation in these platforms.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟环境的根目录中，`pyenv.cfg`配置文件指定了虚拟环境的不同选项，其存在表明我们处于虚拟环境的根文件夹中。在Linux和macOS中，该文件夹将具有以下主要子文件夹：`bin`、`include`、`lib`、`lib/python3.6`和`lib/python3.6/site-packages`。请注意，文件夹名称可能根据具体的Python版本而有所不同。在Windows中，该文件夹将具有以下主要子文件夹：`Include`、`Lib`、`Lib\site-packages`和`Scripts`。每个平台上的虚拟环境的目录树与这些平台上Python安装的布局相同。
- en: 'The following screenshot shows the folders and files in the directory trees
    generated for the `01` virtual environment in macOS and Linux platforms:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了在macOS和Linux平台上为`01`虚拟环境生成的目录树中的文件夹和文件：
- en: '![](assets/89de4379-d681-4d7d-bfe2-e816e637fa68.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/89de4379-d681-4d7d-bfe2-e816e637fa68.png)'
- en: 'The following screenshot shows the main folders in the directory trees generated
    for the virtual environment in Windows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图显示了在Windows为虚拟环境生成的目录树中的主要文件夹：
- en: '![](assets/e5e90a3e-c514-4f2a-be55-350e276a53e6.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e5e90a3e-c514-4f2a-be55-350e276a53e6.png)'
- en: After we activate the virtual environment, we will install third-party packages
    into the virtual environment and the modules will be located within the `lib/python3.6/site-packages`
    or `Lib\site-packages` folder, based on the platform and the specific Python version.
    The executables will be copied to the `bin` or `Scripts` folder, based on the
    platform. The packages we install won't make changes to other virtual environments
    or our base Python environment.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 激活虚拟环境后，我们将在虚拟环境中安装第三方软件包，模块将位于`lib/python3.6/site-packages`或`Lib\site-packages`文件夹中，根据平台和特定的Python版本。可执行文件将被复制到`bin`或`Scripts`文件夹中，根据平台而定。我们安装的软件包不会对其他虚拟环境或我们的基本Python环境进行更改。
- en: Activating the virtual environment
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 激活虚拟环境
- en: Now that we have created a virtual environment, we will run a platform-specific
    script to activate it. After we activate the virtual environment, we will install
    packages that will only be available in this virtual environment. This way, we
    will work with an isolated environment in which all the packages we install won't
    affect our main Python environment.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个虚拟环境，我们将运行一个特定于平台的脚本来激活它。激活虚拟环境后，我们将安装软件包，这些软件包只能在此虚拟环境中使用。这样，我们将使用一个隔离的环境，在这个环境中，我们安装的所有软件包都不会影响我们的主Python环境。
- en: 'Run the following command in Terminal in Linux or macOS. Note that the results
    of this command will be accurate if you don''t start a different shell than the
    default shell in the Terminal session. If you have doubts, check your Terminal
    configuration and preferences:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux或macOS的终端中运行以下命令。请注意，如果您在终端会话中没有启动与默认shell不同的其他shell，此命令的结果将是准确的。如果您有疑问，请检查您的终端配置和首选项：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The command will display the name of the shell you are using in Terminal. In
    macOS, the default is `/bin/bash` and this means you are working with the bash
    shell. Depending on the shell, you must run a different command to activate the
    virtual environment in Linux or macOS.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将显示您在终端中使用的shell的名称。在macOS中，默认值为`/bin/bash`，这意味着您正在使用bash shell。根据shell的不同，您必须在Linux或macOS中运行不同的命令来激活虚拟环境。
- en: 'If your Terminal is configured to use the bash shell in Linux or macOS, run
    the following command to activate the virtual environment. The command also works
    for the `zsh` shell:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的终端配置为在Linux或macOS中使用bash shell，请运行以下命令来激活虚拟环境。该命令也适用于`zsh` shell：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If your Terminal is configured to use either the `csh` or `tcsh` shell, run
    the following command to activate the virtual environment:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的终端配置为使用`csh`或`tcsh` shell，请运行以下命令来激活虚拟环境：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If your Terminal is configured to use the `fish` shell, run the following command
    to activate the virtual environment:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的终端配置为使用`fish` shell，请运行以下命令来激活虚拟环境：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After you activate the virtual environment, the Command Prompt will display
    the virtual environment root folder name enclosed in parentheses as a prefix of
    the default prompt to remind us that we are working in the virtual environment.
    In this case, we will see **(01)** as a prefix for the Command Prompt because
    the root folder for the activated virtual environment is `01`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 激活虚拟环境后，命令提示符将显示虚拟环境根文件夹名称括在括号中作为默认提示的前缀，以提醒我们正在虚拟环境中工作。在这种情况下，我们将看到**(01)**作为命令提示符的前缀，因为激活的虚拟环境的根文件夹是`01`。
- en: 'The following screenshot shows the virtual environment activated in a macOS
    High Sierra Terminal with a `bash` shell, after executing the previously shown
    commands:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图显示在macOS High Sierra终端中使用`bash` shell激活的虚拟环境，在执行先前显示的命令后：
- en: '![](assets/42c36ca7-12a9-421e-a366-c41041a57ec5.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/42c36ca7-12a9-421e-a366-c41041a57ec5.png)'
- en: As we can see from the previous screenshot, the prompt changed from `Gastons-MacBook-Pro:~
    gaston$` to `(01) Gastons-MacBook-Pro:~ gaston$` after the activation of the virtual
    environment.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 从先前的屏幕截图中可以看出，在激活虚拟环境后，提示从`Gastons-MacBook-Pro:~ gaston$`变为`(01) Gastons-MacBook-Pro:~
    gaston$`。
- en: In Windows, you can run either a batch file in Command Prompt or a Windows PowerShell
    script to activate the virtual environment.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，您可以在命令提示符中运行批处理文件或Windows PowerShell脚本来激活虚拟环境。
- en: 'If you prefer Command Prompt, run the following command in the Windows command
    line to activate the virtual environment:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您喜欢使用命令提示符，请在Windows命令行中运行以下命令来激活虚拟环境：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following screenshot shows the virtual environment activated in a Windows
    10 Command Prompt, after executing the previously shown commands:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图显示在Windows 10命令提示符中激活的虚拟环境，在执行先前显示的命令后：
- en: '![](assets/d93be1d1-aa98-40a6-94f6-e84f628a5ea3.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d93be1d1-aa98-40a6-94f6-e84f628a5ea3.png)'
- en: As we can see from the previous screenshot, the prompt changed from `C:\Users\gaston`
    to `(01) C:\Users\gaston` after the activation of the virtual environment.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 从先前的屏幕截图中可以看出，在激活虚拟环境后，提示从`C:\Users\gaston`变为`(01) C:\Users\gaston`。
- en: 'If you prefer Windows PowerShell, launch it and run the following commands
    to activate the virtual environment. Note that you must have scripts execution
    enabled in Windows PowerShell to be able to run the script:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您喜欢使用Windows PowerShell，请启动它并运行以下命令来激活虚拟环境。请注意，您必须在Windows PowerShell中启用脚本执行才能运行该脚本：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you receive an error similar to the following, it means that you don''t
    have scripts execution enabled:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您收到类似以下错误的错误，这意味着您没有启用脚本执行：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The Windows PowerShell default execution policy is `Restricted`. This policy
    allows the execution of individual commands but it doesn''t run scripts. Thus,
    if you want to work with Windows PowerShell, you will have to change the policy
    to allow the execution of scripts. It is very important to make sure that you
    understand the risks of the Windows PowerShell execution policies that allow you
    to run unsigned scripts. For more information about the different policies, check
    the following web page: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-6](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-6).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Windows PowerShell的默认执行策略是`Restricted`。此策略允许执行单个命令，但不运行脚本。因此，如果要使用Windows PowerShell，必须更改策略以允许执行脚本。非常重要的是确保您了解允许运行未签名脚本的Windows
    PowerShell执行策略的风险。有关不同策略的更多信息，请查看以下网页：[https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-6](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-6)。
- en: 'The following screenshot shows the virtual environment activated in a Windows
    10 PowerShell, after executing the previously shown commands:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了在Windows 10 PowerShell中激活的虚拟环境，执行了先前显示的命令：
- en: '![](assets/14730ab3-23c5-456b-a559-bacda570a93a.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/14730ab3-23c5-456b-a559-bacda570a93a.png)'
- en: Deactivating the virtual environment
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消激活虚拟环境
- en: It is extremely easy to deactivate a virtual environment generated with the
    previously explained process. The deactivation will remove all the changes made
    in the environment variables and will change the prompt back to its default message.
    Once you deactivate a virtual environment, you will go back to the default Python
    environment.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用先前解释的过程生成的虚拟环境非常容易取消激活。取消激活将删除环境变量中的所有更改，并将提示更改回其默认消息。取消激活虚拟环境后，您将返回到默认的Python环境。
- en: In macOS or Linux, just type `deactivate` and press *Enter*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS或Linux中，只需键入`deactivate`并按*Enter*。
- en: In Command Prompt, you have to run the `deactivate.bat` batch file included
    in the `Scripts` folder. In our example, the full path for this file is `%USERPROFILE%\HillarMQTT\01\Scripts\deactivate.bat`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令提示符中，您必须运行`Scripts`文件夹中包含的`deactivate.bat`批处理文件。在我们的示例中，此文件的完整路径为`%USERPROFILE%\HillarMQTT\01\Scripts\deactivate.bat`。
- en: In Windows PowerShell, you have to run the `Deactivate.ps1` script in the `Scripts`
    folder. In our example, the full path for this file is `$env:userprofile\HillarMQTT\01\Scripts\Deactivate.ps1`.
    Remember that you must have scripts execution enabled in Windows PowerShell to
    be able to run the script.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows PowerShell中，您必须在`Scripts`文件夹中运行`Deactivate.ps1`脚本。在我们的示例中，此文件的完整路径为`$env:userprofile\HillarMQTT\01\Scripts\Deactivate.ps1`。请记住，必须在Windows
    PowerShell中启用脚本执行，才能运行该脚本。
- en: The instructions in the next sections assume that the virtual environment we
    have created is activated.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节的说明假定我们创建的虚拟环境已激活。
- en: Installing paho-mqtt for Python
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Python的paho-mqtt
- en: 'The Eclipse Paho project provides an open source client implementation of MQTT.
    The project includes a Python client, also known as the Paho Python Client or
    Eclipse Paho MQTT Python client library. This Python client has been contributed
    from the Mosquitto project and was originally known as the Mosquitto Python client.
    The following is the web page for the Eclipse Paho project: [http://www.eclipse.org/paho](http://www.eclipse.org/paho).
    The following is the web page for the Eclipse Paho MQTT Python client library
    version 1.3.1, that is, the `paho-mqtt` module version 1.3.1: [https://pypi.python.org/pypi/paho-mqtt/1.3.1](https://pypi.python.org/pypi/paho-mqtt/1.3.1).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse Paho项目提供了MQTT的开源客户端实现。该项目包括Python客户端，也称为Paho Python客户端或Eclipse Paho
    MQTT Python客户端库。此Python客户端是从Mosquitto项目贡献的，最初被称为Mosquitto Python客户端。以下是Eclipse
    Paho项目的网页：[http://www.eclipse.org/paho](http://www.eclipse.org/paho)。以下是Eclipse
    Paho MQTT Python客户端库版本1.3.1的网页，即`paho-mqtt`模块版本1.3.1：[https://pypi.python.org/pypi/paho-mqtt/1.3.1](https://pypi.python.org/pypi/paho-mqtt/1.3.1)。
- en: We can use `paho-mqtt` in many modern IoT boards that support Python 3.x or
    greater. We just need to make sure that `pip` is installed to make it easier to
    install `paho-mqtt`. You can use your development computer to run the examples
    or any of the afore mentioned boards.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在许多支持Python 3.x或更高版本的现代物联网板上使用`paho-mqtt`。我们只需要确保安装了`pip`，以便更容易安装`paho-mqtt`。您可以使用开发计算机来运行示例，也可以使用前面提到的任何一个物联网板。
- en: Make sure that the virtual environment we created in the previous steps is activated
    before moving forward with the next steps.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在继续下一步之前，我们在上一步中创建的虚拟环境已激活。
- en: If you are going to work with an IoT board to run the example, make sure that
    you run all the commands in the SSH terminal or the Terminal window that runs
    on the board. If you use your development computer, run the commands in a Terminal
    in macOS or Linux, or Command Prompt in Windows.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要使用物联网板运行示例，请确保在SSH终端或运行在板子上的终端窗口中运行所有命令。如果使用开发计算机，请在macOS或Linux中的终端或Windows中的命令提示符中运行命令。
- en: 'Now, we will use `pip` installer to install `paho-mqtt` 1.3.1\. We just need
    to run the following command in the SSH terminal or the local terminal window
    we are using with the board, or on the computer we are using to install the package:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用`pip`安装程序安装`paho-mqtt` 1.3.1。我们只需要在SSH终端或我们与板子一起使用的本地终端窗口中运行以下命令，或者在用于安装软件包的计算机上运行：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Some IoT boards have operating systems that will require you to install `pip`
    before running the previous commands. On Raspberry Pi 3 boards with Raspbian,
    `pip` is already installed. If you are using your computer, the Python installation
    usually includes `pip`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一些物联网板具有需要您在运行上述命令之前安装`pip`的操作系统。在带有Raspbian的Raspberry Pi 3板上，`pip`已经安装。如果您使用计算机，则Python安装通常包括`pip`。
- en: 'If you have Python installed in the default folder in Windows and you aren''t
    working with a Python virtual environment, you will have to run the previous command
    in an administrator Command Prompt. If you aren''t working with a Python virtual
    environment in Raspbian, you will have to run the previous command with `sudo`
    as a prefix: `sudo pip install paho-mqtt`. However, as previously explained, it
    is highly recommended to use a virtual environment.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Windows的默认文件夹中安装了Python，并且没有使用Python虚拟环境，您将不得不在管理员命令提示符中运行上一个命令。如果您在Raspbian中没有使用Python虚拟环境，您将不得不在前面加上`sudo`前缀运行上一个命令：`sudo
    pip install paho-mqtt`。然而，如前所述，强烈建议使用虚拟环境。
- en: 'The last lines for the output will indicate that the `paho-mqtt` package version
    1.3.1 has been successfully installed. The output will be similar to the following
    lines, but not exactly the same because it will vary based on the platform in
    which you are running the command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示`paho-mqtt`包版本1.3.1已成功安装。输出将类似于以下行，但不完全相同，因为它将根据您运行命令的平台而变化：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Connecting a client to the secured MQTT server with paho-mqtt
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用paho-mqtt将客户端连接到安全的MQTT服务器
- en: First, we will use `paho-mqtt` to create an MQTT client that connects to the
    Mosquitto MQTT server. We will write a few lines of Python code to establish a
    secured connection and subscribe to a topic.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用`paho-mqtt`创建一个连接到Mosquitto MQTT服务器的MQTT客户端。我们将编写几行Python代码来建立一个安全连接并订阅一个主题。
- en: In [Chapter 3](89bdce8f-72bc-4fda-82a0-5cab33fa4bd8.xhtml), *Securing an MQTT
    3.1.1 Mosquitto Server*, we secured our Mosquitto server, and therefore, we will
    use the digital certificates we created to authenticate the client. Most of the
    time, we will work with an MQTT server that uses TLS, and therefore, it is a good
    idea to learn how to establish a connection with TLS and TLS authentication. It
    is easier to establish an unsecured connection with an MQTT server, but it won't
    be the most common scenario we will face when developing applications that work
    with MQTT.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](89bdce8f-72bc-4fda-82a0-5cab33fa4bd8.xhtml)中，*保护MQTT 3.1.1 Mosquitto服务器*，我们保护了我们的Mosquitto服务器，因此，我们将使用我们创建的数字证书来对客户端进行身份验证。大多数情况下，我们将使用TLS的MQTT服务器，因此，学习如何建立TLS和TLS身份验证连接是一个好主意。建立与MQTT服务器的非安全连接更容易，但在开发与MQTT配合工作的应用程序时，这不会是我们面临的最常见情况。
- en: 'First, we need to copy the following files, which we created in [Chapter 3](https://cdp.packtpub.com/hands_on_mqtt_programming_with_python/wp-admin/post.php?post=107&action=edit#post_26), *Securing
    an MQTT 3.1.1 Mosquitto Server*, to a directory on the computer or device we will
    use to run a Python script. We saved the files in a directory called `mqtt_certificates`.
    Create a `board_certificates` directory on the computer or board you are going
    to use as the MQTT client for this example. Copy the following three files to
    this new directory:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要复制以下文件，这些文件是我们在[第3章](https://cdp.packtpub.com/hands_on_mqtt_programming_with_python/wp-admin/post.php?post=107&action=edit#post_26)中创建的，*保护MQTT
    3.1.1 Mosquitto服务器*，到计算机或设备上的目录，我们将用它来运行Python脚本。我们将文件保存在一个名为`mqtt_certificates`的目录中。在您将用作MQTT客户端的计算机或板上创建一个名为`board_certificates`的新目录。将以下三个文件复制到这个新目录中：
- en: '`ca.crt`: Certificate authority certificate file'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ca.crt`：证书颁发机构证书文件'
- en: '`board001.crt`: Client certificate file'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`board001.crt`：客户端证书文件'
- en: '`board001.key`: Client key'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`board001.key`：客户端密钥'
- en: 'Now, we will create a new Python file named `config.py` in the main virtual
    environment folder. The following lines show the code for this file that defines
    many configuration values that will be used to establish a connection with the
    Mosquitto MQTT server. This way, all the configuration values are included in
    a specific Python script. You have to replace the `/Users/gaston/board_certificates` value
    in the `certificates_path` string with the path to the `board_certificates` directory
    you created. In addition, replace the value for the `mqtt_server_host` with the
    IP address or hostname for the Mosquitto server or any other MQTT server you might
    decide to use. The code file for the sample is included in the `mqtt_python_gaston_hillar_04_01`
    folder, in the `config.py` file:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在主虚拟环境文件夹中创建一个名为`config.py`的新的Python文件。以下几行显示了该文件的代码，该代码定义了许多配置值，这些值将用于与Mosquitto
    MQTT服务器建立连接。这样，所有配置值都包含在一个特定的Python脚本中。您必须将`certificates_path`字符串中的`/Users/gaston/board_certificates`值替换为您创建的`board_certificates`目录的路径。此外，用Mosquitto服务器或任何其他您决定使用的MQTT服务器的IP地址或主机名替换`mqtt_server_host`的值。示例的代码文件包含在`mqtt_python_gaston_hillar_04_01`文件夹中的`config.py`文件中：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The code declares the `certificates_path` variable initialized with a string
    that specifies the path in which you saved the certificate authority file, the
    client certificate file, and the client key (`ca.crt`, `board001.crt`, and `board001.key`).
    Then, the code declares the following string variables with the full path to the
    certificate and key files we need to configure TLS and the TLS client authentication:
    `ca_certificate`, `client_certificate`, and `client_key`.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码声明了`certificates_path`变量，该变量初始化为一个字符串，指定了您保存证书颁发机构文件、客户端证书文件和客户端密钥（`ca.crt`、`board001.crt`和`board001.key`）的路径。然后，该代码声明了以下字符串变量，这些变量包含了我们需要配置TLS和TLS客户端身份验证的证书和密钥文件的完整路径：`ca_certificate`、`client_certificate`和`client_key`。
- en: The call to `os.path.join` makes it easy to join the path specified in the `certificates_path`
    variable with the filename and generate the full path. The `os.path.join` function
    works for any platform, and therefore, we don't have to worry about whether to
    use a slash (`/`) or a backslash (`\`) to join the path with the filename. Sometimes,
    we can develop and test in Windows and then run the code on an IoT board that
    can use different Unix or Linux flavors, such as Raspbian or Ubuntu. The usage
    of `os.path.join` makes our job easier in scenarios where we switch between different
    platforms.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`os.path.join`使得将`certificates_path`变量中指定的路径与文件名连接并生成完整路径变得容易。`os.path.join`函数适用于任何平台，因此我们不必担心是使用斜杠(`/`)还是反斜杠(`\`)来将路径与文件名连接。有时，我们可以在Windows中开发和测试，然后在可以使用不同Unix或Linux版本的IoT板上运行代码，例如Raspbian或Ubuntu。在我们在不同平台之间切换的情况下，使用`os.path.join`使得我们的工作更加容易。
- en: The `mqtt_server_host`, `mqtt_server_port`, and `mqtt_keepalive` variables specify
    the IP address for the MQTT server (the Mosquitto server), the port that we want
    to use (`8883`), and the number of seconds for the keep alive option. It is very
    important to replace `192.168.1.101` with the IP address for the MQTT server.
    We specify `8883` for `mqtt_server_port` because we use TLS and this is the default
    port for MQTT over TLS, as we learned in [Chapter 3](https://cdp.packtpub.com/hands_on_mqtt_programming_with_python/wp-admin/post.php?post=107&action=edit#post_26), *Securing
    an MQTT 3.1.1 Mosquitto Server*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`mqtt_server_host`、`mqtt_server_port`和`mqtt_keepalive`变量指定了MQTT服务器（Mosquitto服务器）的IP地址（`192.168.1.101`），我们要使用的端口（`8883`），以及保持连接的秒数。非常重要的是要用MQTT服务器的IP地址替换`192.168.1.101`。我们将`mqtt_server_port`指定为`8883`，因为我们使用TLS，这是MQTT
    over TLS的默认端口，正如我们在[第3章](https://cdp.packtpub.com/hands_on_mqtt_programming_with_python/wp-admin/post.php?post=107&action=edit#post_26)中学到的，*Securing
    an MQTT 3.1.1 Mosquitto Server*。'
- en: 'Now, we will create a new Python file named `subscribe_with_paho.py` in the
    main virtual environment folder. The following lines show the code for this file
    that establishes a connection with our Mosquitto MQTT server, subscribes to the
    `vehicles/vehiclepi01/tests` topic filter, and prints all the messages received
    in the subscribed topic filter. The code file for the sample is included in the
    `mqtt_python_gaston_hillar_04_01` folder, in the `subscribe_with_paho.py` file:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在主虚拟环境文件夹中创建一个名为`subscribe_with_paho.py`的新Python文件。以下行显示了该文件的代码，该代码与我们的Mosquitto
    MQTT服务器建立连接，订阅`vehicles/vehiclepi01/tests`主题过滤器，并打印出订阅主题过滤器中接收到的所有消息。示例的代码文件包含在`mqtt_python_gaston_hillar_04_01`文件夹中的`subscribe_with_paho.py`文件中。
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that the code is compatible with `paho-mqtt` version 1.3.1\. Previous versions
    of `paho-mqtt` aren't compatible with the code. Hence, make sure you follow the
    previously explained steps to install `paho-mqtt` version 1.3.1.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，该代码与`paho-mqtt`版本1.3.1兼容。早期版本的`paho-mqtt`与该代码不兼容。因此，请确保按照先前解释的步骤安装`paho-mqtt`版本1.3.1。
- en: Understanding callbacks
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解回调
- en: The previous code uses the recently installed `paho-mqtt` version 1.3.1 module
    to establish an encrypted connection with the MQTT server, subscribe to the `vehicles/vehiclepi01/tests`
    topic filter, and run code when we receive messages in the topic. We will use
    this code to understand the basics of `paho-mqtt`. The code is a very simple version
    of an MQTT client that subscribes to a topic filter and we will definitely improve
    it in the next sections.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用了最近安装的`paho-mqtt`版本1.3.1模块与MQTT服务器建立加密连接，订阅`vehicles/vehiclepi01/tests`主题过滤器，并在接收到主题中的消息时运行代码。我们将使用这段代码来了解`paho-mqtt`的基础知识。该代码是一个非常简单的MQTT客户端版本，订阅了一个主题过滤器，我们将在接下来的部分中对其进行改进。
- en: The first line imports the variables we have declared in the previously coded
    `config.py` file. The second line imports `paho.mqtt.client` as `mqtt`. This way,
    whenever we use the `mqtt` alias, we will be referencing `paho.mqtt.client`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行导入了我们在先前编写的`config.py`文件中声明的变量。第二行将`paho.mqtt.client`导入为`mqtt`。这样，每当我们使用`mqtt`别名时，我们将引用`paho.mqtt.client`。
- en: When we declare a function, we pass this function as an argument to another
    function or method, or we assign this function to an attribute and then some code
    calls this function at some time; this mechanism is known as a **callback.** The
    name callback is used because the code calls back a function at some time. The
    `paho-mqtt` version 1.3.1 package requires us to work with many callbacks, and
    therefore, it is very important to understand how they work.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们声明一个函数时，我们将此函数作为参数传递给另一个函数或方法，或者将此函数分配给一个属性，然后一些代码在某个时候调用此函数；这种机制被称为**回调**。之所以称之为回调，是因为代码在某个时候回调函数。`paho-mqtt`版本1.3.1包要求我们使用许多回调，因此了解它们的工作原理非常重要。
- en: 'The code declares the following three functions that we specify as callbacks
    later:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码声明了以下三个我们稍后指定为回调的函数：
- en: '`on_connect`: This function will be called when the MQTT client receives a
    `CONNACK` response from the MQTT server, that is, when a connection has been successfully
    established with the MQTT server.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on_connect`：当MQTT客户端从MQTT服务器接收到`CONNACK`响应时，即成功与MQTT服务器建立连接时，将调用此函数。'
- en: '`on_subscribe`: This function will be called when the MQTT client receives
    a `SUBACK` response from the MQTT server, that is, when a subscription has been
    successfully completed.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on_subscribe`：当MQTT客户端从MQTT服务器接收到`SUBACK`响应时，即成功完成订阅时，将调用此函数。'
- en: '`on_message`: This function will be called when the MQTT client receives a
    `PUBLISH` message from the MQTT server. Whenever the MQTT server publishes a message
    based on the subscriptions for the client, this function will be called.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on_message`：当MQTT客户端从MQTT服务器接收到`PUBLISH`消息时，将调用此函数。每当MQTT服务器基于客户端的订阅发布消息时，将调用此函数。'
- en: 'The next table summarizes the functions that will be called based on the received
    responses from the MQTT server:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了基于从MQTT服务器接收到的响应调用的函数：
- en: '| **Response from the MQTT server** | **Function that will be called** |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| **来自MQTT服务器的响应** | **将被调用的函数** |'
- en: '| `CONNACK` | `on_connnect` |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `CONNACK` | `on_connnect` |'
- en: '| `SUBACK` | `on_subscribe` |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `SUBACK` | `on_subscribe` |'
- en: '| `PUBLISH` | `on_message` |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `PUBLISH` | `on_message` |'
- en: 'The code for the main block creates an instance of the `mqtt.Client` class
    (`paho.mqtt.client.Client`) that represents an MQTT client. We use this instance
    to communicate with our MQTT server: Mosquitto. If we used the default parameters
    to create the new instance, we would work with MQTT version 3.1\. We want to work
    with MQTT version 3.11, and therefore, we specified `mqtt.MQTTv311` as the value
    for the protocol argument.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 主要代码块创建了代表MQTT客户端的`mqtt.Client`类（`paho.mqtt.client.Client`）的实例。我们使用这个实例与我们的MQTT服务器Mosquitto进行通信。如果我们使用默认参数创建新实例，我们将使用MQTT版本3.1。我们想要使用MQTT版本3.11，因此我们将`mqtt.MQTTv311`指定为协议参数的值。
- en: 'Then, the code assigns functions to attributes. The following table summarizes
    these assignments:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码将函数分配给属性。以下表总结了这些分配：
- en: '| **Attribute** | **Assigned function** |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **分配的函数** |'
- en: '| `client.on_connect` | `on_connect` |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `client.on_connect` | `on_connect` |'
- en: '| `client.on_message` | `on_message` |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `client.on_message` | `on_message` |'
- en: '| `client.on_subscribe` | `on_subscribe` |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `client.on_subscribe` | `on_subscribe` |'
- en: The call to the `client.tls_set` method configures encryption and authentication
    options. It is very important to call this method before running the `client.connect`
    method. We specify the full string paths to the certificate authority certificate
    file, the client certificate, and the client key in the `ca_certs`, `certfile`,
    and `keyfile` arguments. The `ca_certs` argument name is a bit confusing, but
    we just need to specify the string path to the certificate authority certificate
    file, not multiple certificates.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`client.tls_set`方法配置加密和认证选项非常重要，在运行`client.connect`方法之前调用此方法。我们在`ca_certs`、`certfile`和`keyfile`参数中指定证书颁发机构证书文件、客户端证书和客户端密钥的完整字符串路径。`ca_certs`参数名称有点令人困惑，但我们只需要指定证书颁发机构证书文件的字符串路径，而不是多个证书。
- en: Finally, the main block calls the `client.connect` method and specifies the
    values for the `host`, `port`, and `keepalive` arguments. This way, the code asks
    the MQTT client to establish a connection to the specified MQTT server.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，主要代码块调用`client.connect`方法，并指定`host`、`port`和`keepalive`参数的值。这样，代码要求MQTT客户端与指定的MQTT服务器建立连接。
- en: The `connect` method runs with an asynchronous execution, and therefore, it
    is a non-blocking call.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`connect`方法以异步执行方式运行，因此它是一个非阻塞调用。'
- en: After a connection has been successfully established with the MQTT server, the
    specified callback in the `client.on_connect` attribute will be executed, that
    is, the `on_connect` function. This function receives the `mqtt.Client` instance
    that established the connection with the MQTT server in the client argument.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 成功与MQTT服务器建立连接后，将执行`client.on_connect`属性中指定的回调，即`on_connect`函数。此函数在client参数中接收与MQTT服务器建立连接的`mqtt.Client`实例。
- en: If you want to establish a connection with an MQTT server that isn't using TLS,
    you don't need to call the `client.tls_set` method. In addition, you need to use
    the appropriate port instead of the `8883` port that is specified when working
    with TLS. Remember that the default port when you don't work with TLS is `1883`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要与不使用TLS的MQTT服务器建立连接，则无需调用`client.tls_set`方法。此外，您需要使用适当的端口，而不是在使用TLS时指定的`8883`端口。请记住，当不使用TLS时，默认端口是`1883`。
- en: Subscribing to topics with Python
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python订阅主题
- en: The code calls the `client.subscribe` method with `"vehicles/vehiclepi01/tests"`
    as an argument to subscribe to this specific single topic and the `qos` argument
    set to `2` to request a QoS level of 2.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 代码调用`client.subscribe`方法，参数为`"vehicles/vehiclepi01/tests"`，以订阅这个特定的单个主题，并将`qos`参数设置为`2`，以请求QoS级别为2。
- en: In this case, we will only subscribe to one topic. However, it is very important
    to know that we are not limited to subscribing to a single topic filter; we might
    subscribe to many topic filters with a single call to the `subscribe` method.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只订阅一个主题。但是，非常重要的是要知道，我们不限于订阅单个主题过滤器；我们可以通过一次调用`subscribe`方法订阅许多主题过滤器。
- en: After the MQTT server confirms the successful subscription to the specified
    topic filter with a `SUBACK` response, the specified callback in the `client.on_subscribe`
    attribute will be executed, that is, the `on_subscribe` function. This function
    receives a list of integers in the `granted_qos` argument that provides the QoS
    level that the MQTT server has granted for each of the topic filter subscription
    requests. The code in the `on_subscribe` function displays the QoS level granted
    by the MQTT server for the topic filter we specified. In this case, we just subscribed
    to a single topic filter, and therefore, the code grabs the first value from the
    received `granted_qos` array.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在MQTT服务器确认成功订阅指定主题过滤器并返回`SUBACK`响应后，将执行`client.on_subscribe`属性中指定的回调，即`on_subscribe`函数。此函数在`granted_qos`参数中接收一个整数列表，提供MQTT服务器为每个主题过滤器订阅请求授予的QoS级别。`on_subscribe`函数中的代码显示了MQTT服务器为我们指定的主题过滤器授予的QoS级别。在这种情况下，我们只订阅了一个单一的主题过滤器，因此代码从接收到的`granted_qos`数组中获取第一个值。
- en: Whenever there is a new message received that matches the topic filter to which
    we have subscribed, the specified callback in the `client.on_messsage` attribute
    will be executed, that is, the `on_message` function. This function receives the
    `mqtt.Client` instance that established the connection with the MQTT server in
    the client argument and an `mqtt.MQTTMessage` instance in the `msg` argument.
    The `mqtt.MQTTMessage` class describes an incoming message.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 每当收到与我们订阅的主题过滤器匹配的新消息时，将执行`client.on_messsage`属性中指定的回调，即`on_message`函数。此函数在client参数中接收与MQTT服务器建立连接的`mqtt.Client`实例，并在`msg`参数中接收一个`mqtt.MQTTMessage`实例。`mqtt.MQTTMessage`类描述了一条传入消息。
- en: In this case, whenever the `on_message` function is executed, the value in `msg.topic`
    will always match `"vehicles/vehiclepi01/tests"` because we just subscribed to
    a single topic and no other topic name will match the topic filter. However, if
    we subscribed to one or many topic filters to which more than one topic might
    match, it would always be necessary to check which is the topic in which the message
    was sent by checking the value of the `msg.topic` attribute.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，每当执行`on_message`函数时，`msg.topic`中的值将始终匹配`"vehicles/vehiclepi01/tests"`，因为我们刚刚订阅了一个主题，没有其他主题名称与主题过滤器匹配。但是，如果我们订阅了一个或多个主题过滤器，其中可能有多个主题匹配，那么始终需要检查`msg.topic`属性的值来确定消息是发送到哪个主题。
- en: The code in the `on_message` function prints the topic for the message that
    has been received, `msg.topic`, and the string representation of the payload for
    the message, that is, the `msg.payload` attribute.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`on_message`函数中的代码打印已接收消息的主题`msg.topic`和消息的有效负载的字符串表示形式，即`msg.payload`属性。'
- en: Finally, the main block calls the `client.loop_forever` method that calls the
    `loop` method for us in an infinite blocking loop. At this point, we only want
    to run the MQTT client loop in our program. We will receive the messages whose
    topic matches the topic to which we have subscribed.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，主块调用`client.loop_forever`方法，该方法以无限阻塞循环为我们调用`loop`方法。在这一点上，我们只想在我们的程序中运行MQTT客户端循环。我们将接收与我们订阅的主题匹配的消息。
- en: The `loop` method is responsible for processing the network events, that is,
    it makes sure communication with the MQTT server is carried out. You can think
    about the `loop` method as the equivalent of synchronizing your email client to
    receive incoming messages and send the messages in the outbox.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`loop`方法负责处理网络事件，即确保与MQTT服务器的通信进行。您可以将`loop`方法视为将电子邮件客户端同步以接收传入消息并发送发件箱中的消息的等效方法。'
- en: 'Make sure the Mosquitto server or any other MQTT server you might want to use
    for this example is running. Then, execute the following line to start the example
    on any computer or device that you want to use as the MQTT client and uses Linux
    or macOS:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 确保Mosquitto服务器或您可能要用于此示例的任何其他MQTT服务器正在运行。然后，在要用作MQTT客户端并使用Linux或macOS的任何计算机或设备上执行以下行以启动示例：
- en: '[PRE19]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In Windows, you must execute the following line:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，您必须执行以下行：
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you see a traceback with an `SSLError` similar to the following lines, it
    means that the MQTT server hostname or IP doesn''t match the value specified for
    the `Common Name` attribute when you generated the server certificate file named
    `server.crt`. Make sure that you check the IP address for the MQTT server (Mosquitto
    server) and generate the server certificate file and key again with the appropriate
    IP address or hostname specified for `Common Name`, as explained in  [Chapter
    3](https://cdp.packtpub.com/hands_on_mqtt_programming_with_python/wp-admin/post.php?post=107&action=edit#post_26), *Securing
    an MQTT 3.1.1 Mosquitto Server*, if you are working with the self-signed certificates
    we generated. If you are working with self-signed certificates, IP addresses,
    and a DHCP server, also check that the DHCP server didn''t change the IP address
    for your Mosquitto server:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到类似以下行的`SSLError`的回溯，这意味着MQTT服务器的主机名或IP与生成名为`server.crt`的服务器证书文件时指定的`Common
    Name`属性的值不匹配。确保检查MQTT服务器（Mosquitto服务器）的IP地址，并使用指定为`Common Name`的适当IP地址或主机名再次生成服务器证书文件和密钥，如[第3章](https://cdp.packtpub.com/hands_on_mqtt_programming_with_python/wp-admin/post.php?post=107&action=edit#post_26)中所述，*Securing
    an MQTT 3.1.1 Mosquitto Server*，如果您正在使用我们生成的自签名证书。如果您正在使用自签名证书、IP地址和DHCP服务器，请还要检查DHCP服务器是否更改了Mosquitto服务器的IP地址：
- en: '[PRE21]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, follow these steps to use the MQTT.fx GUI utility to publish two messages
    to the `vehicles/vehiclepi01/tests` topic:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照以下步骤使用MQTT.fx GUI实用程序向`vehicles/vehiclepi01/tests`主题发布两条消息：
- en: Launch MQTT.fx and establish a connection with the MQTT server by following
    the steps we learned in  [Chapter 3](https://cdp.packtpub.com/hands_on_mqtt_programming_with_python/wp-admin/post.php?post=107&action=edit#post_26), *Securing
    an MQTT 3.1.1 Mosquitto Server*.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动MQTT.fx，并按照我们在[第3章](https://cdp.packtpub.com/hands_on_mqtt_programming_with_python/wp-admin/post.php?post=107&action=edit#post_26)中学到的步骤与MQTT服务器建立连接，*Securing
    an MQTT 3.1.1 Mosquitto Server*。
- en: Click Publish and enter `vehicles/vehiclepi01/tests` in the drop-down menu at
    the left-hand side of the Publish button.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击Publish并在Publish按钮左侧的下拉菜单中输入`vehicles/vehiclepi01/tests`。
- en: Click QoS 2 at the right-hand side of the Publish button.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击Publish按钮右侧的QoS 2。
- en: 'Enter the following text in the textbox under the Publish button: `{"CMD":
    " UNLOCK_DOORS"}`. Then, click the Publish button. MQTT.fx will publish the entered
    text to the specified topic.'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在Publish按钮下的文本框中输入以下文本：`{"CMD": " UNLOCK_DOORS"}`。然后，单击Publish按钮。MQTT.fx将输入的文本发布到指定的主题。'
- en: 'Enter the following text in the textbox under the Publish button: `{"CMD":
    "TURN_ON_HEADLIGHTS"}`. Then, click the Publish button. MQTT.fx will publish the
    entered text to the specified topic.'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在Publish按钮下的文本框中输入以下文本：`{"CMD": "TURN_ON_HEADLIGHTS"}`。然后，单击Publish按钮。MQTT.fx将输入的文本发布到指定的主题。'
- en: 'If you don''t want to work with the MQTT.fx utility, you can run two `mosquitto_pub`
    commands to generate MQTT clients that publish messages to the topic. You just
    need to open another Terminal in macOS or Linux, or another Command Prompt in
    Windows, go to the directory in which Mosquitto is installed, and run the following
    commands. In this case, it isn''t necessary to specify the `-d` option. Replace
    `192.168.1.101` with the IP or hostname for the MQTT server. Remember to replace
    `ca.crt`, `board001.crt`, and `board001.key` with the full path to these files
    created in the `board_certificates` directory. The code file for the sample is
    included in the `mqtt_python_gaston_hillar_04_01` folder, in the `script_01.txt`
    file:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想使用MQTT.fx实用程序，可以运行两个`mosquitto_pub`命令来生成发布消息到主题的MQTT客户端。您只需要在macOS或Linux中打开另一个终端，或者在Windows中打开另一个命令提示符，转到Mosquitto安装的目录，并运行以下命令。在这种情况下，不需要指定`-d`选项。将`192.168.1.101`替换为MQTT服务器的IP或主机名。记得将`ca.crt`、`board001.crt`和`board001.key`替换为在`board_certificates`目录中创建的这些文件的完整路径。示例的代码文件包含在`mqtt_python_gaston_hillar_04_01`文件夹中的`script_01.txt`文件中：
- en: '[PRE22]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Go to the device and window in which you executed the Python script. You will
    see the following output:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 转到您执行Python脚本的设备和窗口。您将看到以下输出：
- en: '[PRE23]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The Python program successfully established a secured and encrypted connection
    with the MQTT server and became a subscriber to the `vehicles/vehiclepi01/tests`
    topic with a granted QoS level of 2\. The program displayed the two messages it
    has received in the `vehicles/vehiclepi01/tests` topic.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Python程序成功地与MQTT服务器建立了安全加密的连接，并成为了`vehicles/vehiclepi01/tests`主题的订阅者，授予了QoS级别2。该程序显示了它在`vehicles/vehiclepi01/tests`主题中接收到的两条消息。
- en: 'Press *Ctrl* + *C* to stop the execution of the program. The generated MQTT
    client will close the connection with the MQTT server. You will see an error message
    similar to the following output because the loop execution is interrupted:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*Ctrl* + *C*停止程序的执行。生成的MQTT客户端将关闭与MQTT服务器的连接。您将看到类似以下输出的错误消息，因为循环执行被中断：
- en: '[PRE24]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Configuring certificates for IoT boards that will work as clients
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为将作为客户端工作的物联网板配置证书
- en: Now, we will write Python code that will be ready to work on the different IoT
    boards. Of course, you can work with a single development computer or development
    board. There is no need to run the code on different devices. We just want to
    make sure we can write code that will be capable of running on different devices.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写Python代码，该代码将准备在不同的物联网板上运行。当然，您可以在单个开发计算机或开发板上工作。无需在不同设备上运行代码。我们只是想确保我们可以编写能够在不同设备上运行的代码。
- en: Remember to copy the files we created in the previous chapter to a directory
    on the computer or device that will represent the board that controls a vehicle
    and that we will use to run a Python script. If you will be working with the same
    computer or device you have been using so far, you don't need to follow the next
    step.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 记得将我们在上一章中创建的文件复制到代表控制车辆的板的计算机或设备上，并且我们将用它来运行Python脚本。如果您将继续使用到目前为止一直在使用的同一台计算机或设备，您无需遵循下一步。
- en: 'We saved the files in a directory called `mqtt_certificates`. Create a `board_certificates`
    directory on the computer or board you are going to use as the MQTT client for
    this example. Copy the following three files to this new directory:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将文件保存在一个名为`mqtt_certificates`的目录中。在您将用作此示例的MQTT客户端的计算机或板上创建一个`board_certificates`目录。将以下三个文件复制到这个新目录中：
- en: '`ca.crt`: Certificate authority certificate file'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ca.crt`：证书颁发机构证书文件'
- en: '`board001.crt`: Client certificate file'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`board001.crt`：客户端证书文件'
- en: '`board001.key`: Client key'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`board001.key`：客户端密钥'
- en: Creating a class to represent a vehicle
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个代表车辆的类
- en: 'We will create the following two classes:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建以下两个类：
- en: '`Vehicle`: This class will represent a vehicle and provide methods that will
    be called whenever a command has to be processed. In order to keep the example
    simple, our methods will just print the actions that the vehicle executes after
    each method is called to the console output. A real-life class that represents
    a vehicle would interact with the engine, the lights, the actuators, the sensors,
    and the other different components of the vehicle whenever each method is called.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vehicle`：这个类将代表一个车辆，并提供在处理命令时将被调用的方法。为了保持示例简单，我们的方法将在每次调用后将车辆执行的操作打印到控制台输出。代表车辆的真实类将在每次调用每个方法时与发动机、灯、执行器、传感器和车辆的其他不同组件进行交互。'
- en: '`VehicleCommandProcessor`: This class will represent a command processor that
    will establish a connection with an MQTT server, subscribe to a topic in which
    the MQTT client will receive messages with commands, analyze the incoming messages,
    and delegate the execution of the commands to an associated instance of the `Vehicle`
    class. The `VehicleCommandProcessor` class will declare many static methods that
    we will specify as the callbacks for the MQTT client.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VehicleCommandProcessor`：这个类将代表一个命令处理器，它将与MQTT服务器建立连接，订阅一个主题，其中MQTT客户端将接收带有命令的消息，分析传入的消息，并将命令的执行委托给`Vehicle`类的相关实例。`VehicleCommandProcessor`类将声明许多静态方法，我们将指定为MQTT客户端的回调。'
- en: 'Create a new Python file named `vehicle_commands.py` in the main virtual environment
    folder. The following lines declare many variables with the values that identify
    each of the supported commands for the vehicle. In addition, the code declares
    many variables with the key string we will use to specify a command and the key
    we will use to specify a successfully executed command. All these variables are
    defined with all uppercase because we will use them as constants. The code file
    for the sample is included in the `mqtt_python_gaston_hillar_04_01` folder, in
    the `vehicle_commands.py` file:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在主虚拟环境文件夹中创建一个名为`vehicle_commands.py`的新Python文件。以下行声明了许多变量，这些变量具有标识车辆支持的每个命令的值。此外，代码还声明了许多变量，这些变量具有我们将用于指定命令的关键字符串以及我们将用于指定成功执行的命令的关键字符串。所有这些变量都以全大写字母定义，因为我们将把它们用作常量。示例的代码文件包含在`mqtt_python_gaston_hillar_04_01`文件夹中的`vehicle_commands.py`文件中。
- en: '[PRE25]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `COMMAND_KEY` variable defines the key string that defines what the code
    will understand as the command. Whenever we receive a message that includes the
    specified key string, we know that the value associated with this key in the dictionary
    will indicate the command that the message wants the code running in the board
    to be processed. The MQTT client won't receive messages as dictionaries, and therefore,
    it is necessary to convert them from strings to dictionaries when they are not
    just a string.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`COMMAND_KEY`变量定义了一个关键字符串，该字符串定义了代码将理解为命令。每当我们接收包含指定关键字符串的消息时，我们知道字典中与此关键相关联的值将指示消息希望代码在板上运行的命令被处理。MQTT客户端不会接收消息作为字典，因此，当它们不仅仅是一个字符串时，有必要将它们从字符串转换为字典。'
- en: The `SUCCESSFULLY_PROCESSED_COMMAND_KEY` variable defines the key string that
    defines what the code will use as a successfully processed command key in a response
    message published to the appropriate topic. Whenever we publish a message that
    includes the specified key string, we know that the value associated with this
    key in the dictionary will indicate the command that the board has successfully
    processed.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`SUCCESSFULLY_PROCESSED_COMMAND_KEY`变量定义了一个关键字符串，该字符串定义了代码将在发布到适当主题的响应消息中用作成功处理的命令键。每当我们发布包含指定关键字符串的消息时，我们知道字典中与此关键相关联的值将指示板成功处理的命令。'
- en: 'Create a new Python file, named `vehicle_mqtt_client.py`, in the main virtual
    environment folder. The following lines declare the necessary imports and the
    same variables we used in the previous example to establish the connection with
    the MQTT server. Then, the lines declare the `Vehicle` class. The code file for
    the sample is included in the `mqtt_python_gaston_hillar_04_01` folder, in the
    `vehicle_mqtt_client.py` file:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在主虚拟环境文件夹中创建一个名为`vehicle_mqtt_client.py`的新Python文件。以下行声明了必要的导入和与前面示例中使用的相同变量，以建立与MQTT服务器的连接。然后，这些行声明了`Vehicle`类。示例的代码文件包含在`mqtt_python_gaston_hillar_04_01`文件夹中的`vehicle_mqtt_client.py`文件中。
- en: '[PRE26]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As in the previous example, all the configuration values to establish a connection
    with the Mosquitto MQTT server are defined in the Python file named `config.py`
    in the main virtual environment folder. If you want to run this example on a different
    device, you will have to create a new `config.py` file with the appropriate values
    and change the line that imports the values from the `config` module to use the
    new configuration file. Don't forget to replace the `/Users/gaston/board_certificates` value
    in the `certificates_path` string with the path to the `board_certificates` directory
    you created. In addition, replace the value for the `mqtt_server_host` with the
    IP address or hostname for the Mosquitto server or other MQTT server you might
    decide to use.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的示例一样，用于与Mosquitto MQTT服务器建立连接的所有配置值都在名为`config.py`的Python文件中定义在主虚拟环境文件夹中。如果要在不同的设备上运行此示例，您将不得不创建一个新的`config.py`文件，并更改导入`config`模块的行，以使用新的配置文件。不要忘记将`certificates_path`字符串中的值`/Users/gaston/board_certificates`替换为您创建的`board_certificates`目录的路径。此外，将`mqtt_server_host`的值替换为Mosquitto服务器或其他您决定使用的MQTT服务器的IP地址或主机名。
- en: 'We have to specify the vehicle''s name in the name required argument. The constructor,
    that is, the `__init__` method, saves the received name in an attribute with the
    same name. Then, the constructor sets the initial values for two attributes: `min_speed_mph`
    and `max_speed_mph`. These attributes establish the minimum and maximum speed
    values for the vehicle, expressed in miles per hour.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在所需的名称参数中指定车辆的名称。构造函数，即`__init__`方法，将接收的名称保存在具有相同名称的属性中。然后，构造函数为两个属性设置了初始值：`min_speed_mph`和`max_speed_mph`。这些属性确定了车辆的最小和最大速度值，以英里每小时表示。
- en: The `Vehicle` class declares the `print_action_with_name_prefix` method that
    receives a string with the action that is being executed in the `action` argument
    and prints it with the value saved in the `name` attribute as a prefix. The other
    methods defined in this class call the `print_action_with_name_prefix` method
    to print messages indicating the actions that the vehicle is executing, with the
    vehicle's name as a prefix.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vehicle`类声明了`print_action_with_name_prefix`方法，该方法接收一个包含正在执行的动作的字符串，并将其与保存在`name`属性中的值一起作为前缀打印出来。此类中定义的其他方法调用`print_action_with_name_prefix`方法，以打印指示车辆正在执行的动作的消息，并以车辆的名称作为前缀。'
- en: Receiving messages in Python
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Python中接收消息
- en: We will use the recently installed `paho-mqtt` version 1.3.1 module to subscribe
    to a specific topic and run code when we receive messages in the topic. We will
    create a `VehicleCommandProcessor` class in the same Python file, named `vehicle_mqtt_client.py`,
    in the main virtual environment folder. This class will represent a command processor
    associated to an instance of the previously coded `Vehicle` class, configure the
    MQTT client and the subscription to the client, and declare the code for the callbacks
    that are going to be executed when certain events related to MQTT are fired.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用最近安装的`paho-mqtt`版本1.3.1模块订阅特定主题，并在接收到主题消息时运行代码。我们将在同一个Python文件中创建一个名为`vehicle_mqtt_client.py`的`VehicleCommandProcessor`类，该文件位于主虚拟环境文件夹中。这个类将代表一个与先前编码的`Vehicle`类实例相关联的命令处理器，配置MQTT客户端和订阅客户端，并声明当与MQTT相关的某些事件被触发时将要执行的回调代码。
- en: 'We will split the code for the `VehicleCommandProcessor` class into many code
    snippets to make it easier to understand each code section. You have to add the
    next lines to the existing `vehicle_mqtt_client.py` Python file. The following
    lines declare the `VehicleCommandProcessor` class and its constructor, that is,
    the `__init__` method. The code file for the sample is included in the `mqtt_python_gaston_hillar_04_01`
    folder, in the `vehicle_mqtt_client.py` file:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`VehicleCommandProcessor`类的代码拆分成许多代码片段，以便更容易理解每个代码部分。您必须将下面的代码添加到现有的`vehicle_mqtt_client.py`
    Python文件中。以下代码声明了`VehicleCommandProcessor`类及其构造函数，即`__init__`方法。示例的代码文件包含在`mqtt_python_gaston_hillar_04_01`文件夹中的`vehicle_mqtt_client.py`文件中：
- en: '[PRE27]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We have to specify a name for the command processor and the `Vehicle` instance
    that the command processor will control in the `name` and `vehicle` required arguments.
    The constructor, that is, the `__init__` method, saves the received `name` and
    `vehicle` in attributes with the same names. Then, the constructor sets the values
    for the `commands_topic` and `processed_commands_topic` class attributes. The
    constructor uses the received `name` to determine the topic name for the commands
    and for the successfully processed commands, based on the specifications we discussed
    earlier. The MQTT client will receive messages in the topic name saved in the
    `command_topic` class attribute, and will publish messages to the topic name saved
    in the `processed_commands_topic` class attribute.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须为命令处理器和命令处理器将控制的`Vehicle`实例指定一个名称，分别在`name`和`vehicle`参数中。构造函数，即`__init__`方法，将接收到的`name`和`vehicle`保存在同名的属性中。然后，构造函数设置了`commands_topic`和`processed_commands_topic`类属性的值。构造函数使用接收到的`name`来确定命令和成功处理的命令的主题名称，根据我们之前讨论的规范。MQTT客户端将在`command_topic`类属性中保存的主题名称接收消息，并将消息发布到`processed_commands_topic`类属性中保存的主题名称。
- en: Then, the constructor creates an instance of the `mqtt.Client` class (`paho.mqtt.client.Client`)
    that represents an MQTT client and that we will use to communicate with an MQTT
    server. The code assigns this instance to the `client` attribute (`self.client`).
    As in our previous example, we want to work with MQTT version 3.11, and therefore,
    we specified `mqtt.MQTTv311` as the value for the protocol argument.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，构造函数创建了一个`mqtt.Client`类的实例（`paho.mqtt.client.Client`），表示一个MQTT客户端，我们将使用它与MQTT服务器进行通信。代码将此实例分配给`client`属性（`self.client`）。与我们之前的示例一样，我们希望使用MQTT版本3.11，因此我们将`mqtt.MQTTv311`指定为协议参数的值。
- en: The code also saves a reference to this instance in the `active_instance` class
    attribute because we have to access the instance in the static methods that the
    constructor will specify as callbacks for the different events that the MQTT client
    fires. We want to have all the methods related to the vehicle command processor
    in the `VehicleCommandProcessor` class.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 代码还将此实例的引用保存在`active_instance`类属性中，因为我们必须在构造函数指定为MQTT客户端触发的不同事件的回调中访问该实例。我们希望将与车辆命令处理器相关的所有方法都放在`VehicleCommandProcessor`类中。
- en: 'Then, the code assigns static methods to attributes of the `self.client` instance.
    The following table summarizes these assignments:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码将静态方法分配给`self.client`实例的属性。以下表总结了这些分配：
- en: '| **Attribute** | **Assigned static method** |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **分配的静态方法** |'
- en: '| `client.on_connect` | `VehicleCommandProcessor.on_connect` |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `client.on_connect` | `VehicleCommandProcessor.on_connect` |'
- en: '| `client.on_message` | `VehicleCommandProcessor.on_message` |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `client.on_message` | `VehicleCommandProcessor.on_message` |'
- en: '| `client.on_subscribe` | `VehicleCommandProcessor.on_subscribe` |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `client.on_subscribe` | `VehicleCommandProcessor.on_subscribe` |'
- en: Static methods do not receive either `self` or `cls` as the first argument,
    and therefore, we can use them as callbacks with the required number of arguments.
    Note that we will code and analyze these static methods in the next paragraphs.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法不接收`self`或`cls`作为第一个参数，因此我们可以将它们用作具有所需数量参数的回调。请注意，我们将在下一段编码和分析这些静态方法。
- en: The call to the `self.client.tls_set` method configures encryption and authentication
    options. Finally, the constructor calls the `client.connect` method and specifies
    the values for the `host`, `port`, and `keepalive` arguments. This way, the code
    asks the MQTT client to establish a connection to the specified MQTT server. Remember
    that the `connect` method runs with an asynchronous execution, and therefore,
    it is a non-blocking call.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.client.tls_set`方法的调用配置了加密和认证选项。最后，构造函数调用`client.connect`方法，并指定`host`、`port`和`keepalive`参数的值。这样，代码要求MQTT客户端与指定的MQTT服务器建立连接。请记住，`connect`方法以异步执行方式运行，因此它是一个非阻塞调用。'
- en: If you want to establish a connection with an MQTT server that isn't using TLS,
    you need to remove the call to the `self.client.tls_set` method. In addition,
    you need to use the appropriate port instead of the `8883` port that is specified
    when working with TLS. Remember that the default port when you don't work with
    TLS is `1883`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要与未使用TLS的MQTT服务器建立连接，则需要删除对`self.client.tls_set`方法的调用。此外，您需要使用适当的端口，而不是在使用TLS时指定的`8883`端口。请记住，当您不使用TLS时，默认端口是`1883`。
- en: 'The following lines declare the `on_connect` static method that is part of
    the `VehicleCommandProcessor` class. You have to add these lines to the existing
    `vehicle_mqtt_client.py` Python file. The code file for the sample is included
    in the `mqtt_python_gaston_hillar_04_01` folder, in the `vehicle_mqtt_client.py`
    file:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行声明了`on_connect`静态方法，该方法是`VehicleCommandProcessor`类的一部分。您需要将这些行添加到现有的`vehicle_mqtt_client.py`
    Python文件中。示例的代码文件包含在`mqtt_python_gaston_hillar_04_01`文件夹中的`vehicle_mqtt_client.py`文件中：
- en: '[PRE28]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: After a connection has been successfully established with the MQTT server, the
    specified callback in the `self.client.on_connect` attribute will be executed,
    that is, the `on_connect` static method (marked with the `@staticmethod` decorator).
    This static method receives the `mqtt.Client` instance that established the connection
    with the MQTT server in the client argument.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 成功与MQTT服务器建立连接后，将执行`self.client.on_connect`属性中指定的回调，即`on_connect`静态方法（使用`@staticmethod`装饰器标记）。此静态方法接收了与MQTT服务器建立连接的`mqtt.Client`实例作为client参数。
- en: The code checks the value of the `rc` argument that provides the `CONNACK` code
    returned by the MQTT server. If this value matches `mqtt.CONNACK_ACCEPTED`, it
    means that the MQTT server accepted the connection request, and therefore, the
    code calls the `client.subscribe` method with `VehicleCommandProcessor.commands_topic`
    as an argument to subscribe to the topic specified in the `commands_topic` class
    attribute and specifies a QoS level of 2 for the subscription.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码检查`rc`参数的值，该参数提供了MQTT服务器返回的`CONNACK`代码。如果此值与`mqtt.CONNACK_ACCEPTED`匹配，则意味着MQTT服务器接受了连接请求，因此，代码调用`client.subscribe`方法，并将`VehicleCommandProcessor.commands_topic`作为参数订阅到`commands_topic`类属性中指定的主题，并为订阅指定了QoS级别为2。
- en: 'The following lines declare the `on_subscribe` static method that is part of
    the `VehicleCommandProcessor` class. You have to add these lines to the existing
    `vehicle_mqtt_client.py` Python file. The code file for the sample is included
    in the `mqtt_python_gaston_hillar_04_01` folder, in the `vehicle_mqtt_client.py`
    file:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行声明了`on_subscribe`静态方法，该方法是`VehicleCommandProcessor`类的一部分。您需要将这些行添加到现有的`vehicle_mqtt_client.py`
    Python文件中。示例的代码文件包含在`mqtt_python_gaston_hillar_04_01`文件夹中的`vehicle_mqtt_client.py`文件中：
- en: '[PRE29]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `on_subscribe` static method displays the QoS level granted by the MQTT
    server for the topic filter we specified. In this case, we just subscribed to
    a single topic filter, and therefore, the code grabs the first value from the
    received `granted_qos` array.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`on_subscribe`静态方法显示了MQTT服务器为我们指定的主题过滤器授予的QoS级别。在这种情况下，我们只订阅了一个单一主题过滤器，因此，代码从接收的`granted_qos`数组中获取第一个值。'
- en: 'The following lines declare the `on_message` static method that is part of
    the `VehicleCommandProcessor` class. You have to add these lines to the existing
    `vehicle_mqtt_client.py` Python file. The code file for the sample is included
    in the `mqtt_python_gaston_hillar_04_01` folder, in the `vehicle_mqtt_client.py`
    file:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行声明了`on_message`静态方法，该方法是`VehicleCommandProcessor`类的一部分。您需要将这些行添加到现有的`vehicle_mqtt_client.py`
    Python文件中。示例的代码文件包含在`mqtt_python_gaston_hillar_04_01`文件夹中的`vehicle_mqtt_client.py`文件中：
- en: '[PRE30]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Whenever there is a new message received in the topic saved in the `commands_topic`
    class attribute to which we have subscribed, the specified callback in the `self.client.on_messsage`
    attribute will be executed, that is, the previously coded `on_message` static
    method (marked with the `@staticmethod` decorator). This static method receives
    the `mqtt.Client` instance that established the connection with the MQTT server
    in the client argument and an `mqtt.MQTTMessage` instance in the `msg` argument.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 每当在我们订阅的`commands_topic`类属性中保存的主题中收到新消息时，将执行`self.client.on_messsage`属性中指定的回调，即先前编码的`on_message`静态方法（使用`@staticmethod`装饰器标记）。此静态方法接收了与MQTT服务器建立连接的`mqtt.Client`实例作为client参数，并在`msg`参数中接收了一个`mqtt.MQTTMessage`实例。
- en: The `mqtt.MQTTMessage` class describes an incoming message.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`mqtt.MQTTMessage`类描述了传入的消息。'
- en: The `msg.topic` attribute indicates the topic in which the message has been
    received. Thus, the static method checks whether the `msg.topic` attribute matches
    the value in the `commands_topic` class attribute. In this case, whenever the
    `on_message` method is executed, the value in `msg.topic` will always match the
    value in the topic class attribute because we just subscribed to one topic. However,
    if we subscribe to more than one topic, it is always necessary to check which
    is the topic in which the message was sent and in which we are receiving the message.
    Hence, we included the code to have a clear idea of how to check the `topic` for
    the received message.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`msg.topic`属性指示接收消息的主题。因此，静态方法检查`msg.topic`属性是否与`commands_topic`类属性中的值匹配。在这种情况下，每当执行`on_message`方法时，`msg.topic`中的值将始终与主题类属性中的值匹配，因为我们只订阅了一个主题。但是，如果我们订阅了多个主题，则始终需要检查消息发送的主题以及我们接收消息的主题。因此，我们包含了代码以清楚地了解如何检查接收消息的`topic`。'
- en: The code prints the payload for the message that has been received, that is,
    the `msg.payload` attribute. Then, the code assigns the result of the `json.loads`
    function to deserialize `msg.payload` to a Python object and assigns the results
    to the `message_dictionary` local variable. If the contents of `msg.payload` are
    not JSON, a `ValueError` exception will be captured, the code will print a message
    indicating that the message doesn't include a valid command, and no more code
    will be executed in the static method. If the contents of `msg.payload` are JSON,
    we will have a dictionary in the `message_dictionary` local variable.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 代码打印了已接收消息的payload，即`msg.payload`属性。然后，代码将`json.loads`函数的结果分配给`msg.payload`以将其反序列化为Python对象，并将结果分配给`message_dictionary`本地变量。如果`msg.payload`的内容不是JSON，则会捕获`ValueError`异常，代码将打印一条消息，指示消息不包含有效命令，并且不会执行更多代码。如果`msg.payload`的内容是JSON，则`message_dictionary`本地变量中将有一个字典。
- en: Then, the code checks whether the value saved in the `COMMAND_KEY` string is
    included in the `message_dictionary` dictionary. If the expression evaluates to
    `True`, it means that the JSON message converted to a dictionary includes a command
    that we have to process. However, before we can process the command, we have to
    check which is the command, and therefore, it is necessary to retrieve the value
    associated with the key equivalent to the value saved in the `COMMAND_KEY` string.
    The code is capable of running specific code when the value is any of the commands
    that we have analyzed as requirements.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码检查`COMMAND_KEY`字符串中保存的值是否包含在`message_dictionary`字典中。如果表达式求值为`True`，则意味着将JSON消息转换为字典后包含我们必须处理的命令。但是，在我们处理命令之前，我们必须检查是哪个命令，因此需要检索与与`COMMAND_KEY`字符串中保存的值相等的键关联的值。当值是我们分析为要求的命令之一时，代码能够运行特定的代码。
- en: The code uses the `active_instance` class attribute that has a reference to
    the active `VehicleCommandProcessor` instance to call the necessary methods for
    the associated vehicle based on the command that has to be processed. We had to
    declare the callbacks as static methods, and therefore, we use this class attribute
    to access the active instance. Once the command has been successfully processed,
    the code sets the `is_command_executed` flag to `True`. Finally, the code checks
    the value of this flag, and if it is equal to `True`, the code calls the `publish_executed_command_message`
    for the `VehicleCommandProcessor` instance saved in the `active_instance` class
    attribute.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用`active_instance`类属性，该属性引用了活动的`VehicleCommandProcessor`实例，以调用基于必须处理的命令的相关车辆的必要方法。我们必须将回调声明为静态方法，因此我们使用此类属性来访问活动实例。一旦命令成功处理，代码将`is_command_executed`标志设置为`True`。最后，代码检查此标志的值，如果等于`True`，则代码将为`active_instance`类属性中保存的`VehicleCommandProcessor`实例调用`publish_executed_command_message`。
- en: Of course, in a real-life example, we should add more validations. The previous
    code is simplified to allow us to keep our focus on MQTT.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在实际示例中，我们应该添加更多的验证。前面的代码被简化，以便我们可以将注意力集中在MQTT上。
- en: 'The following lines declare the `publish_executed_command_message` method that
    is part of the `VehicleCommandProcessor` class. You have to add these lines to
    the existing `vehicle_mqtt_client.py` Python file. The code file for the sample
    is included in the `mqtt_python_gaston_hillar_04_01` folder, in the `vehicle_mqtt_client.py`
    file:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行声明了`publish_executed_command_message`方法，该方法是`VehicleCommandProcessor`类的一部分。您需要将这些行添加到现有的`vehicle_mqtt_client.py`
    Python文件中。示例的代码文件包含在`mqtt_python_gaston_hillar_04_01`文件夹中的`vehicle_mqtt_client.py`文件中：
- en: '[PRE31]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `publish_executed_command_message` method receives the message dictionary
    that has been received with the command in the message argument. The method calls
    the `json.dumps` function to serialize a dictionary to a JSON-formatted string
    with the response message that indicates the command has been successfully processed.
    Finally, the code calls the `client.publish` method with the `processed_commands_topic`
    variable as the topic argument and the JSON-formatted string (`response_message`)
    in the `payload` argument.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`publish_executed_command_message`方法接收了带有消息参数的命令的消息字典。该方法调用`json.dumps`函数将字典序列化为JSON格式的字符串，其中包含指示命令已成功处理的响应消息。最后，代码调用`client.publish`方法，将`processed_commands_topic`变量作为主题参数，并将JSON格式的字符串（`response_message`）作为`payload`参数。'
- en: In this case, we are not evaluating the response received from the `publish`
    method. In addition, we are using the default value for the `qos` argument that
    specifies the desired quality of service. Thus, we will publish this message with
    a QoS level equal to 0\. In [Chapter 5](1fa4ce92-f009-4676-813f-bd4590593c27.xhtml),
    *Testing and Improving our Vehicle Control Solution in Python*, we will work with
    more advanced scenarios in which we will add code to check the results of the
    method and we will add code to the `on_publish` callback that is fired when a
    message is successfully published, as we did in our previous example. In this
    case, we use QoS level 2 only for the messages that we receive with the commands.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不评估从`publish`方法接收到的响应。此外，我们使用了`qos`参数的默认值，该参数指定所需的服务质量。因此，我们将以QoS级别等于0发布此消息。在[第5章](1fa4ce92-f009-4676-813f-bd4590593c27.xhtml)中，《在Python中测试和改进我们的车辆控制解决方案》，我们将处理更高级的场景，在这些场景中，我们将添加代码来检查方法的结果，并且我们将添加代码到`on_publish`回调中，该回调在成功发布消息时触发，就像我们在之前的示例中所做的那样。在这种情况下，我们仅对接收到的带有命令的消息使用QoS级别2。
- en: Working with multiple calls to the loop method
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多次调用循环方法
- en: 'The following lines declare the `process_incoming_commands` method that is
    part of the `VehicleCommandProcessor` class. You have to add these lines to the
    existing `vehicle_mqtt_client.py` Python file. The code file for the sample is
    included in the `mqtt_python_gaston_hillar_04_01` folder, in the `vehicle_mqtt_client.py`
    file:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行声明了`process_incoming_commands`方法，该方法是`VehicleCommandProcessor`类的一部分。 您必须将这些行添加到现有的`vehicle_mqtt_client.py`
    Python文件中。 示例的代码文件包含在`mqtt_python_gaston_hillar_04_01`文件夹中的`vehicle_mqtt_client.py`文件中：
- en: '[PRE32]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `process_incoming_commands` method calls the `loop` method for the MQTT
    client and ensures communication with the MQTT server is carried out. Think about
    the call to the `loop` method as synchronizing your mailbox. Any pending messages
    to be published in the outgoing box will be sent, any incoming messages will arrive
    to the inbox, and the events that we have previously analyzed will be fired. This
    way, the vehicle command processor will receive messages and process commands.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`process_incoming_commands`方法调用MQTT客户端的`loop`方法，并确保与MQTT服务器的通信已完成。 将调用`loop`方法视为同步您的邮箱。
    将发送要发布的任何未决消息，任何传入消息将到达收件箱，并且我们先前分析过的事件将被触发。 这样，车辆命令处理器将接收消息并处理命令。'
- en: 'Finally, the following lines declare the main block of code. You have to add
    these lines to the existing `vehicle_mqtt_client.py` Python file. The code file
    for the sample is included in the `mqtt_python_gaston_hillar_04_01` folder, in
    the `vehicle_mqtt_client.py` file:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下行声明了代码的主要块。 您必须将这些行添加到现有的`vehicle_mqtt_client.py` Python文件中。 示例的代码文件包含在`mqtt_python_gaston_hillar_04_01`文件夹中的`vehicle_mqtt_client.py`文件中：
- en: '[PRE33]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `__main__` method creates an instance of the `Vehicle` class, named vehicle,
    with `"vehiclepi01"` as the value for the name argument. The next line creates
    an instance of the `VehicleCommandProcessor` class, named `vehicle_command_processor`,
    with `"vehiclepi01"` and the previously created `Vehicle` instance, *X*, as the
    values for the `name` and `vehicle` arguments. This way, `vehicle_command_processor`
    will delegate the execution of the commands to instance methods in `vehicle`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`__main__`方法创建了`Vehicle`类的一个实例，命名为vehicle，名称参数的值为`"vehiclepi01"`。 下一行创建了`VehicleCommandProcessor`类的一个实例，命名为`vehicle_command_processor`，名称参数的值为`"vehiclepi01"`，先前创建的`Vehicle`实例*X*的值为`vehicle`参数。
    这样，`vehicle_command_processor`将把命令的执行委托给`vehicle`中的实例方法。'
- en: The constructor for the `VehicleCommandProcessor` class will subscribe to the
    `vehicles/vehiclepi01/commands` topic in the MQTT server, and therefore, we must
    publish messages to this topic in order to send the commands that the code will
    process. Whenever a command is successfully processed, new messages will be published
    to the `vehicles/vehiclepi01/executedcommands` topic. Hence, we must subscribe
    to this topic to check the commands that the vehicle has executed.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`VehicleCommandProcessor`类的构造函数将订阅MQTT服务器上的`vehicles/vehiclepi01/commands`主题，因此，我们必须发布消息到此主题，以便发送代码将处理的命令。
    每当成功处理命令时，将发布新消息到`vehicles/vehiclepi01/executedcommands`主题。 因此，我们必须订阅此主题以检查车辆执行的命令。'
- en: The while loop calls the `vehicle_command_processor.process_commands` method
    and sleeps for one second. The `process_commands` method calls the loop method
    for the MQTT client and ensures communication with the MQTT server is carried
    out.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: while循环调用`vehicle_command_processor.process_commands`方法并休眠一秒钟。 `process_commands`方法调用MQTT客户端的循环方法，并确保与MQTT服务器的通信已完成。
- en: There is also a threaded interface that we can run by calling the `loop_start`
    method for the MQTT client. This way, we can avoid multiple calls to the loop
    method. However, we call the loop method to make it easier to debug the code and
    understand how everything works under the hood. We will work with the threaded
    interfaces in [Chapter 5](https://cdp.packtpub.com/hands_on_mqtt_programming_with_python/wp-admin/post.php?post=107&action=edit#post_129), *Testing
    and Improving our Vehicle Control Solution in Python*.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个线程化的接口，我们可以通过调用MQTT客户端的`loop_start`方法来运行。 这样，我们可以避免多次调用循环方法。 但是，我们调用循环方法使得调试代码和理解底层工作变得更容易。
    我们将在[第5章](https://cdp.packtpub.com/hands_on_mqtt_programming_with_python/wp-admin/post.php?post=107&action=edit#post_129)中使用线程化接口，*在Python中测试和改进我们的车辆控制解决方案*。
- en: Test your knowledge
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: 'Let''s see whether you can answer the following questions correctly:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否能正确回答以下问题：
- en: Which of the following Python modules is the Paho Python Client?
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个Python模块是Paho Python客户端？
- en: '`paho-mqtt`'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`paho-mqtt`'
- en: '`paho-client-pip`'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`paho-client-pip`'
- en: '`paho-python-client`'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`paho-python-client`'
- en: To establish a connection with an MQTT server that uses TLS, which method do
    you have to call for the `paho.mqtt.client.Client` instance before calling `connect`?
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要与使用TLS的MQTT服务器建立连接，必须在调用`connect`之前为`paho.mqtt.client.Client`实例调用哪个方法？
- en: '`connect_with_tls`'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`connect_with_tls`'
- en: '`tls_set`'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tls_set`'
- en: '`configure_tls`'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`configure_tls`'
- en: After the `paho.mqtt.client.Client` instance establishes a connection with the
    MQTT server, the callback assigned to which of the following attributes will be
    called?
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`paho.mqtt.client.Client`实例与MQTT服务器建立连接后，将调用分配给以下哪个属性的回调函数？
- en: '`on_connection`'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`on_connection`'
- en: '`on_connect`'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`on_connect`'
- en: '`connect_callback`'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`connect_callback`'
- en: After the `paho.mqtt.client.Client` instance receives a message from one of
    the topic filters to which it has subscribed, the callback assigned to which of
    the following attributes will be called?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`paho.mqtt.client.Client`实例从其订阅的主题过滤器之一接收到消息后，将调用分配给以下哪个属性的回调函数？
- en: '`on_message_arrived`'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`on_message_arrived`'
- en: '`on_message`'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`on_message`'
- en: '`message_arrived_callback`'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`message_arrived_callback`'
- en: Which of the following methods of a `paho.mqtt.client.Client` instance calls
    the loop method for us in an infinite blocking loop?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`paho.mqtt.client.Client`实例的以下哪个方法会以无限阻塞循环为我们调用循环方法？'
- en: '`infinite_loop`'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`infinite_loop`'
- en: '`loop_while_true`'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`loop_while_true`'
- en: '`loop_forever`'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`loop_forever`'
- en: The right answers are included in the [Appendix](d9cf708f-f027-4bfa-a2d2-9fd3653165d9.xhtml), *Solutions*.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 正确答案包含在[附录](d9cf708f-f027-4bfa-a2d2-9fd3653165d9.xhtml)中，*解决方案*。
- en: Summary
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we analyzed the requirements to control a vehicle with MQTT
    messages. We defined the topics that we would use and the commands that would
    be part of the messages’ payloads to control a vehicle. Then, we worked with the
    Paho Python Client to write Python code that connected an MQTT client to the MQTT
    server.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们分析了使用MQTT消息控制车辆的要求。我们定义了要使用的主题以及消息有效载荷中将成为控制车辆一部分的命令。然后，我们使用Paho Python客户端编写了Python代码，将MQTT客户端连接到MQTT服务器。
- en: We understood the methods we needed to call for the Paho Python Client and their
    parameters. We analyzed how callbacks worked and we wrote code to subscribe to
    topic filters as well as to receive and process messages.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解了Paho Python客户端需要调用的方法及其参数。我们分析了回调函数的工作原理，并编写了代码来订阅主题过滤器，以及接收和处理消息。
- en: We wrote code that processed commands for a vehicle with Python. The code is
    able to run on different IoT platforms, including Raspberry Pi 3 family boards,
    Qualcomm DragonBoard, BeagleBone Black, MinnowBoard Turbot, LattePanda, UP squared,
    and also on any computer that is capable of executing Python 3.6.x code. We worked
    with the network loop for the MQTT client in Python.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了使用Python处理车辆命令的代码。该代码能够在不同的物联网平台上运行，包括树莓派3系列板，高通DragonBoard，BeagleBone
    Black，MinnowBoard Turbot，LattePanda，UP squared，以及任何能够执行Python 3.6.x代码的计算机。我们还使用了Python中的MQTT客户端的网络循环。
- en: Now that we have understood the basics to use Python to work with MQTT, we will
    use and improve our vehicle control solution with MQTT messages and Python code
    and we will take advantage of additional MQTT features, which are the topics we
    are going to discuss in [Chapter 5](https://cdp.packtpub.com/hands_on_mqtt_programming_with_python/wp-admin/post.php?post=107&action=edit#post_129), *Testing
    and Improving our Vehicle Control Solution in Python*.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了使用Python与MQTT一起工作的基础知识，我们将使用并改进我们的车辆控制解决方案，使用MQTT消息和Python代码，并利用其他MQTT功能，这些功能将在[第5章](https://cdp.packtpub.com/hands_on_mqtt_programming_with_python/wp-admin/post.php?post=107&action=edit#post_129)中讨论，*在Python中测试和改进我们的车辆控制解决方案*。
