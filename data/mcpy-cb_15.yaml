- en: Coding on the Adafruit HalloWing Microcontroller
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Adafruit HalloWing微控制器上编码
- en: In this chapter, we will create a joke-telling machine. We will use the Adafruit
    HalloWing M0 Express board that comes with a full color TFT display and capacitive
    touch sensors. Each time you press the touch button, a new joke riddle will be
    presented. You can try and figure out the answer to the riddle and when you are
    ready, touch the button to show the answer to the riddle. Pressing the touch button
    again randomly selects a new riddle and starts another game.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个讲笑话的机器。我们将使用Adafruit HalloWing M0 Express板，该板配有全彩TFT显示屏和电容式触摸传感器。每次按下触摸按钮时，都会呈现一个新的笑话谜语。您可以尝试猜出谜底，当您准备好时，触摸按钮以显示谜底。再次按下触摸按钮会随机选择一个新的谜语并开始另一场游戏。
- en: This chapter will be a useful source of information and help you build projects
    that let you leverage the power of a full color screen with a good enough resolution
    to present multi-line text and full color graphical images.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将是一个有用的信息来源，并帮助您构建项目，让您利用全彩屏幕的强大功能，具有足够的分辨率来呈现多行文本和全彩图像。
- en: 'We will be covering the following recipe in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中介绍以下内容：
- en: Discovering I2C devices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现I2C设备
- en: Reading data from the accelerometer using I2C
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用I2C从加速计读取数据
- en: Detecting board-flipping with the accelerometer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用加速计检测翻转板
- en: Controlling screen brightness
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制屏幕亮度
- en: Displaying a bitmap image
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示位图图像
- en: Listing all image files
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出所有图像文件
- en: Creating a joke-telling machine
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个讲笑话的机器
- en: The Adafruit HalloWing M0 Express
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Adafruit HalloWing M0 Express
- en: 'The Adafruit HalloWing is a microcontroller with a built-in 1.44 inch 128 x
    128 full-color TFT display. The software for displaying images fully supports
    displaying full color bitmap image files. With 8 MB storage on the device, this
    gives you plenty of space to store and display a large number of images. The board
    also comes equipped with a 3-axis accelerometer, light sensor, and 4 capacitive
    touchpads. The following screenshot shows the TFT screen displaying a bitmap image:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Adafruit HalloWing是一款带有内置1.44英寸128 x 128全彩TFT显示屏的微控制器。用于显示图像的软件完全支持显示全彩位图图像文件。设备上有8MB的存储空间，这为您提供了足够的空间来存储和显示大量图像。该板还配备有3轴加速计、光传感器和4个电容式触摸板。以下屏幕截图显示了TFT屏幕显示位图图像：
- en: '![](assets/147b6ec4-61e4-4d56-a458-7865333945e9.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/147b6ec4-61e4-4d56-a458-7865333945e9.png)'
- en: The board can be powered by a portable power source. It supports both rechargeable
    lithium-ion polymer batteries and a USB portable power bank.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 该板可以由便携式电源供电。它支持可充电锂聚合物电池和USB便携式电源银行。
- en: Where to buy
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 购买地点
- en: The Adafruit HalloWing M0 Express board can be purchased directly from Adafruit
    ([https://www.adafruit.com/product/3900](https://www.adafruit.com/product/3900)).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Adafruit HalloWing M0 Express板可以直接从Adafruit([https://www.adafruit.com/product/3900](https://www.adafruit.com/product/3900))购买。
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files for this chapter can be found in the `Chapter15` folder of this
    book's GitHub repository, at [https://github.com/PacktPublishing/MicroPython-Cookbook](https://github.com/PacktPublishing/MicroPython-Cookbook).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在本书的GitHub存储库的`Chapter15`文件夹中找到，网址为[https://github.com/PacktPublishing/MicroPython-Cookbook](https://github.com/PacktPublishing/MicroPython-Cookbook)。
- en: This chapter uses the Adafruit HalloWing M0 Express board, loaded with the CircuitPython
    firmware. CircuitPython version 4.0.0-rc.1 was used for all the recipes in this
    chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用加载了CircuitPython固件的Adafruit HalloWing M0 Express板。本章中的所有配方都使用了CircuitPython版本4.0.0-rc.1。
- en: You may download the firmware image from [https://circuitpython.org/board/hallowing_m0_express/](https://circuitpython.org/board/hallowing_m0_express/).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://circuitpython.org/board/hallowing_m0_express/](https://circuitpython.org/board/hallowing_m0_express/)下载固件图像。
- en: Many of the recipes in this chapter require a set of bitmap images to be transferred
    to the Adafruit HalloWing device. They can all be downloaded from the `Chapter15`
    folder in this book's GitHub repository. They should be saved in the top-level
    folder, along with your `main.py` file.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的许多配方需要一组位图图像传输到Adafruit HalloWing设备。它们都可以从本书的GitHub存储库的`Chapter15`文件夹中下载。它们应该保存在顶层文件夹中，与您的`main.py`文件一起。
- en: Discovering I2C devices
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现I2C设备
- en: This recipe will show you how to scan for I2C devices connected to the bus using
    the `i2c` object. The I2C protocol supports multiple devices being connected to
    a single I2C connection. One of the first steps in connecting to a device is to
    scan and list all detected devices. This recipe will help you troubleshoot an
    I2C device to confirm that it is connected and can be found in scans. It can also
    help you build Python scripts that can automatically scan and detect multiple
    devices.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将向您展示如何使用`i2c`对象扫描连接到总线的I2C设备。I2C协议支持多个设备连接到单个I2C连接。连接到设备的第一步之一是扫描和列出所有检测到的设备。这个配方将帮助您排除I2C设备，以确认它已连接并且可以在扫描中找到。它还可以帮助您构建可以自动扫描和检测多个设备的Python脚本。
- en: Getting ready
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on the Adafruit HalloWing board to run the
    code presented in this recipe.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问Adafruit HalloWing板上的REPL来运行本配方中提供的代码。
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to learn how to discover I2C devices:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何发现I2C设备：
- en: 'Run the following lines of code in the REPL:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中运行以下代码行：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The required libraries will have been imported. Run the following line of code
    to create the `i2c` object that will be used for scanning:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所需的库已经被导入。运行以下代码行以创建将用于扫描的`i2c`对象：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following lines of code will keep looping until a lock is acquired on the
    I2C bus:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码行将一直循环，直到在I2C总线上获得锁定：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following block of code performs a scan and lists all detected devices:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块执行扫描并列出所有检测到的设备：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can perform the scan again and convert the returned device addresses into
    hex format:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以再次执行扫描，并将返回的设备地址转换为十六进制格式：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following code should be put into the `main.py` file:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块应放入`main.py`文件中：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When this script is executed, it will print out the addresses of all discovered
    devices.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此脚本时，它将打印出所有发现设备的地址。
- en: How it works...
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The main function sets up the `i2c` object. The `try_lock` method is then repeatedly
    called until a lock is acquired. This lock is needed to perform a scan on the
    I2C bus. The `scan` method is then called, which returns a list of device addresses.
    Each address is then converted into hex notation and saved as a list of strings
    in the device's variable. Finally, the contents of this variable are output with
    a message, indicating that this is the list of devices that were discovered on
    the bus.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 主要函数设置了`i2c`对象。然后重复调用`try_lock`方法，直到获得锁。这个锁是需要执行I2C总线扫描的。然后调用`scan`方法，它返回一个设备地址列表。然后将每个地址转换为十六进制表示法，并保存为字符串列表在设备的变量中。最后，输出这个变量的内容，并指示这是在总线上发现的设备列表。
- en: There's more...
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Some I2C operation, such as scanning, require a lock. If you try and perform
    a scan without first acquiring a lock, you will get a runtime error indicating
    that this function requires a lock. In the next recipe, we will see that there
    are other operations that don't require a lock. The addresses of I2C are frequently
    referred to using hex notation, and this is the reason why we converted the value
    from an integer into a hex value.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一些I2C操作，比如扫描，需要一个锁。如果您尝试在没有先获取锁的情况下执行扫描，您将收到一个运行时错误，指示此函数需要一个锁。在下一个教程中，我们将看到还有其他不需要锁的操作。I2C的地址经常使用十六进制表示法来引用，这就是为什么我们将值从整数转换为十六进制值的原因。
- en: The Adafruit HalloWing M0 Express board comes with one I2C device—an accelerometer—which
    should have the address `0x18`. Our scans confirm that. If you're not sure of
    the specific address value for your device, you can use the scan method to detect
    these values.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Adafruit HalloWing M0 Express板配备了一个I2C设备——一个加速度计，其地址应为`0x18`。我们的扫描证实了这一点。如果您不确定您的设备的具体地址值，您可以使用扫描方法来检测这些值。
- en: See also
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references regarding this recipe:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于这个教程的一些参考资料：
- en: Documentation on the `scan` method can be found at [https://circuitpython.readthedocs.io/en/3.x/shared-bindings/busio/I2C.html#busio.I2C.scan](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/busio/I2C.html#busio.I2C.scan).
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`scan`方法的文档可以在[https://circuitpython.readthedocs.io/en/3.x/shared-bindings/busio/I2C.html#busio.I2C.scan](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/busio/I2C.html#busio.I2C.scan)找到。
- en: Documentation on a project that uses the accelerometer on the Adafruit HalloWing
    board can be found at [https://learn.adafruit.com/hallowing-magic-9-ball/](https://learn.adafruit.com/hallowing-magic-9-ball/).
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在[https://learn.adafruit.com/hallowing-magic-9-ball/](https://learn.adafruit.com/hallowing-magic-9-ball/)找到一个使用Adafruit
    HalloWing板上加速度计的项目的文档。
- en: Reading data from the accelerometer using I2C
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用I2C从加速度计读取数据
- en: This recipe will show you how to connect to the onboard accelerometer using
    the I2C protocol. Once we have an I2C object, we will use the Python `adafruit_lis3dh`
    library to create a `LIS3DH_I2C` object. This object will let us read live sensor
    data from the accelerometer. This recipe will help you whenever you want to create
    a project that uses board's orientation to create an interactive experience. You
    could, for example, create a project that reacts to the board being shaken by
    changing the image that's currently being displayed.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程将向您展示如何使用I2C协议连接板载加速度计。一旦我们有了一个I2C对象，我们将使用Python的`adafruit_lis3dh`库创建一个`LIS3DH_I2C`对象。这个对象将让我们从加速度计中读取实时传感器数据。这个教程将帮助您在想要创建一个利用板的方向来创建交互体验的项目时。例如，您可以创建一个根据板被摇动而改变当前显示图像的项目。
- en: Getting ready
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on the Adafruit HalloWing device to run the
    code presented in this recipe.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问Adafruit HalloWing设备上的REPL来运行本教程中提供的代码。
- en: How to do it...
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to learn how to read data from the accelerometer using I2C:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何使用I2C从加速度计读取数据：
- en: 'Execute the following block of code in the REPL:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中执行以下代码块：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The required libraries have now been imported, and the accelerometer address
    has been defined in the `ACCEL_ADDRESS` constant. Run the following block of code
    to create an `i2c` object and use that object to create a `LIS3DH_I2C` object:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所需的库现在已经被导入，并且加速度计地址已经在`ACCEL_ADDRESS`常量中定义。运行以下代码块来创建一个`i2c`对象，并使用该对象来创建一个`LIS3DH_I2C`对象：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following block of code will fetch accelerometer orientation data and display
    its values:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块将获取加速度计方向数据并显示其值：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can also access specific information, such as the *x* axis orientation data,
    using the following block of code:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以使用以下代码块访问特定信息，比如*x*轴方向数据：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following loop is used to print the live accelerometer sensor data every
    0.1 seconds:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下循环用于每0.1秒打印一次实时加速度计传感器数据：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following code should be put into the `main.py` file:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码应该放入`main.py`文件中：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When this script is executed, it will print sensor data from the accelerometer
    every 0.1 seconds.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此脚本时，它将每0.1秒打印一次来自加速度计的传感器数据。
- en: How it works...
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `ACCEL_ADDRESS` constant contains the address for the accelerometer on the
    Adafruit HalloWing M0 Express board. Once we've created an `i2c` object, we take
    it and the `ACCEL_ADDRESS` to create a `LIS3DH_I2C` object, which we will save
    in a variable called `accel`. An infinite loop is started that reads the sensor
    data from the accelerometer on each iteration and prints them out. The loop then
    waits for a 0.1 second delay before starting the next iteration.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`ACCEL_ADDRESS`常量包含Adafruit HalloWing M0 Express板上加速度计的地址。一旦我们创建了一个`i2c`对象，我们将它和`ACCEL_ADDRESS`一起创建一个`LIS3DH_I2C`对象，我们将保存在一个名为`accel`的变量中。然后启动一个无限循环，每次迭代都从加速度计中读取传感器数据并将其打印出来。然后循环等待0.1秒延迟，然后开始下一次迭代。'
- en: There's more...
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The name of the accelerometer that's used on the Adafruit HalloWing device is
    called LIS3DH, which is why the Python library that knows how to speak to this
    device is called `adafruit_lis3dh`. This sensor can be used to detect both the
    orientation and acceleration of the board. In the next recipe, we will use this
    orientation data to detect when the board has been flipped over.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Adafruit HalloWing设备上使用的加速度计的名称为LIS3DH，这就是为什么知道如何与该设备通信的Python库被称为`adafruit_lis3dh`。该传感器可用于检测板的方向和加速度。在下一个教程中，我们将使用这些方向数据来检测板何时被翻转。
- en: See also
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Here are a few references regarding this recipe:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于这个教程的一些参考资料：
- en: Documentation on the LIS3DH accelerometer can be found at [https://www.st.com/en/mems-and-sensors/lis3dh.html](https://www.st.com/en/mems-and-sensors/lis3dh.html).
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LIS3DH加速度计的文档可以在[https://www.st.com/en/mems-and-sensors/lis3dh.html](https://www.st.com/en/mems-and-sensors/lis3dh.html)找到。
- en: Documentation on the `LIS3DH_I2C` object can be found at [https://circuitpython.readthedocs.io/projects/lis3dh/en/latest/api.html#adafruit_lis3dh.LIS3DH_I2C](https://circuitpython.readthedocs.io/projects/lis3dh/en/latest/api.html#adafruit_lis3dh.LIS3DH_I2C).
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LIS3DH_I2C`对象的文档可以在[https://circuitpython.readthedocs.io/projects/lis3dh/en/latest/api.html#adafruit_lis3dh.LIS3DH_I2C](https://circuitpython.readthedocs.io/projects/lis3dh/en/latest/api.html#adafruit_lis3dh.LIS3DH_I2C)找到。'
- en: Detecting board-flipping with the accelerometer
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用加速度计检测板翻转
- en: This recipe will show you how to create a function that detects when the board
    is flipped over. To achieve this, we will use the orientation data that we fetched
    from the accelerometer. We will focus on the *z* axis data as this will indicate
    whether the board is facing up or facing down. The approach presented in this
    recipe can be useful to you whenever you are creating a project and want to find
    a more creative way of interacting with the project than just pushing buttons.
    This can create a fun level of interaction when someone discovers that all they
    have to do is flip over your board to interact with it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程将向您展示如何创建一个函数，用于检测板何时被翻转。为了实现这一点，我们将使用从加速度计获取的方向数据。我们将专注于*z*轴数据，因为这将指示板是面朝上还是面朝下。本教程中提出的方法在您创建项目并希望以比只是按按钮更有创意的方式与项目进行交互时可能对您有用。当有人发现他们只需翻转您的板就可以与之交互时，这可以创造一种有趣的交互水平。
- en: Getting ready
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on the Adafruit HalloWing device to run the
    code presented in this recipe.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '您将需要在Adafruit HalloWing设备上访问REPL以运行本教程中提供的代码。 '
- en: How to do it...
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to learn how you can detect board flipping with the accelerometer:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何使用加速度计检测板翻转：
- en: 'Use the REPL to run the following lines of code:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用REPL运行以下代码行：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The required libraries have been imported and constantly defined. Run the following
    block of code to create the `i2c` and `LIS3DH_I2C` objects:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所需的库已被导入并不断定义。运行以下代码块以创建`i2c`和`LIS3DH_I2C`对象：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can now inspect the *z* axis orientation data:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以检查*z*轴的方向数据：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Flip the board so that its display is face-down and then run the following
    block of code:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将板翻转，使其显示面朝下，然后运行以下代码块：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The orientation value of the *z* axis will be a positive or negative number,
    depending on whether the board is face-up or face-down. Execute the following
    block of code to calculate this value:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*z*轴的方向值将是一个正数或负数，具体取决于板是面朝上还是面朝下。执行以下代码块来计算这个值：'
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run the following block of code while you flip the board between face-down
    and face-up:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将板翻转至面朝下和面朝上时运行以下代码块：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following code should be put into the `main.py` file:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码应放入`main.py`文件中：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When this script is executed, it will print whether the board is facing up or
    down every 0.1 seconds.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此脚本时，它将每0.1秒打印板是面朝上还是面朝下。
- en: How it works...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Once the `i2c` and `accel` variables are set up, we can then start accessing
    the orientation data from the accelerometer. When the board is facing up, the
    `z` value will be a negative number, and when the board is facing down, the `z`
    value will be a positive number. We can use this piece of information to calculate
    whether the board is facing up or down. An infinite loop is started and the variable
    face has `up` or `down` values saved to it, depending on the board's current orientation.
    This information is then printed while the loop waits for a 0.1 second delay before
    starting the next iteration.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`i2c`和`accel`变量设置好，我们就可以开始从加速度计中访问方向数据。当板面朝上时，`z`值将是一个负数，当板面朝下时，`z`值将是一个正数。我们可以利用这部分信息来计算板是面朝上还是面朝下。开始一个无限循环，并将变量face保存为`up`或`down`值，取决于板的当前方向。然后在循环等待0.1秒延迟之前，打印这些信息，然后开始下一次迭代。
- en: There's more...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This recipe showed you how you can use one piece of information from the accelerometer
    to detect a change in the physical orientation of the board. Once we've detected
    this change, we can make the script change its output, for example, whenever the
    board's face value changes. The accelerometer is also accurate enough to provide
    the angle the board is pointed at in reference to the *z* axis. We can use this
    information to change the behavior of our application, depending on how far the
    board is tilted in a certain direction.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程向您展示了如何使用加速度计的一部分信息来检测板的物理方向的变化。一旦我们检测到这种变化，我们可以使脚本改变其输出，例如，每当板的面值发生变化时。加速度计还足够精确，可以提供板相对于*z*轴的指向角度。我们可以利用这些信息来改变我们的应用程序的行为，取决于板向某个方向倾斜的程度。
- en: See also
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Here are a few references regarding this recipe:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于这个教程的一些参考资料：
- en: Documentation on how accelerometers detect orientation can be found at [https://ieeexplore.ieee.org/document/1241424](https://ieeexplore.ieee.org/document/1241424).
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于加速度计如何检测方向的文档可以在[https://ieeexplore.ieee.org/document/1241424](https://ieeexplore.ieee.org/document/1241424)找到。
- en: Documentation on the `acceleration` attribute can be found at [https://circuitpython.readthedocs.io/projects/lis3dh/en/latest/api.html#adafruit_lis3dh.LIS3DH.acceleration](https://circuitpython.readthedocs.io/projects/lis3dh/en/latest/api.html#adafruit_lis3dh.LIS3DH.acceleration).
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`acceleration`属性的文档可以在[https://circuitpython.readthedocs.io/projects/lis3dh/en/latest/api.html#adafruit_lis3dh.LIS3DH.acceleration](https://circuitpython.readthedocs.io/projects/lis3dh/en/latest/api.html#adafruit_lis3dh.LIS3DH.acceleration)找到。
- en: Controlling screen brightness
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制屏幕亮度
- en: This recipe will show you how to control the brightness level on the TFT display
    that comes with the Adafruit HalloWing device. The brightness can be set to the
    maximum level or to lower levels by providing a fractional value between 0 and
    1\. The brightness setting can also be used to turn off the display by setting
    the brightness level to 0\. This recipe can be useful to you in projects where
    you don't want the screen on all the time, and want to turn it on and off. It
    can also be helpful when you want to tweak the brightness levels of the backlight
    to a lower level to reduce power consumption.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱将向您展示如何在Adafruit HalloWing设备附带的TFT显示屏上控制亮度级别。亮度可以通过提供0到1之间的分数值设置为最大级别或较低级别。亮度设置还可以用于通过将亮度级别设置为0来关闭显示器。在您不希望屏幕一直开启的项目中，这个食谱可能对您有用，并且希望打开和关闭屏幕。当您希望将背光的亮度级别调整到较低级别以减少功耗时，它也可能有所帮助。
- en: Getting ready
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on the Adafruit HalloWing device to run the
    code presented in this recipe.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问Adafruit HalloWing设备上的REPL才能运行此食谱中提供的代码。
- en: How to do it...
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to learn how to control the Adafruit HalloWing device''s
    screen brightness:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何控制Adafruit HalloWing设备的屏幕亮度：
- en: 'Run the following lines of code in the REPL:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中运行以下代码行：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The required libraries have been imported you can run the following block of
    code to set the brightness level to 50%:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 已导入所需的库，您可以运行以下代码块将亮度级别设置为50%：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following block of code will turn of the display by setting brightness
    to 0%:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块将通过将亮度设置为0%关闭显示器：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can now set the brightness to the maximum level with the following block
    of code:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以用以下代码块将亮度设置为最大级别：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following function will take the brightness from the lowest level to the
    maximum level over 11 iterations:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下函数将在11次迭代中将亮度从最低级别提升到最大级别：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Run the following block of code. You should see the display fade up to maximum
    brightness:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下代码块。您应该看到显示器逐渐变亮到最大亮度：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following code should be put into the `main.py` file:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码应放入`main.py`文件中：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When this script is executed, it will fade the screen from black to full brightness,
    with a 0.1 second delay between each fade.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此脚本时，它将使屏幕从黑色渐变到完全亮度，每次渐变之间延迟0.1秒。
- en: How it works...
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The main function starts an infinite loop that repeatedly calls the `fade_in`
    function. Each call to the `fade_in` function will start a `for` loop that loops
    over 11 brightness values. The values vary, from the display being off to setting
    the display to its maximum brightness. The brightness level is calculated for
    each iteration and stored in the brightness variable. The value is printed and
    then applied to the brightness attribute on the `DISPLAY` object. A sleep of 0.1
    second is then applied before the next iteration of the fade in the loop is applied.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 主函数启动一个无限循环，不断调用`fade_in`函数。每次调用`fade_in`函数都会启动一个`for`循环，循环遍历11个亮度值。这些值从显示关闭到将显示设置为最大亮度不等。每次迭代都会计算亮度级别并存储在亮度变量中。该值被打印，然后应用于`DISPLAY`对象上的亮度属性。然后应用0.1秒的延迟，然后应用淡入循环的下一次迭代。
- en: There's more...
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This recipe demonstrates how easy it is to set the brightness level of the display.
    It also shows you how screen effects such as fading the screen in and out can
    also be implemented in Python. The brightness attribute can be particularly useful
    when you want to turn off the display by switching the backlight of the display
    off. You might create a battery-operated device that can use this technique to
    optimize power consumption.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱演示了设置显示屏亮度有多容易。它还向您展示了如何在Python中实现屏幕淡入淡出等屏幕效果。当您想要通过关闭显示器的背光来关闭显示器时，亮度属性可能特别有用。您可能会创建一个使用这种技术来优化电量消耗的电池操作设备。
- en: See also
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references regarding this recipe:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱有一些参考资料：
- en: An example of controlling screen brightness can be found at [https://circuitpython.readthedocs.io/en/latest/shared-bindings/displayio/OnDiskBitmap.html](https://circuitpython.readthedocs.io/en/latest/shared-bindings/displayio/OnDiskBitmap.html).
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制屏幕亮度的示例可以在[https://circuitpython.readthedocs.io/en/latest/shared-bindings/displayio/OnDiskBitmap.html](https://circuitpython.readthedocs.io/en/latest/shared-bindings/displayio/OnDiskBitmap.html)找到。
- en: Details on the TFT display on the Adafruit HalloWing device can be found at
    [https://learn.adafruit.com/adafruit-hallowing?view=all#tft-2-18](https://learn.adafruit.com/adafruit-hallowing?view=all#tft-2-18).
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关Adafruit HalloWing设备上的TFT显示屏的详细信息，请访问[https://learn.adafruit.com/adafruit-hallowing?view=all#tft-2-18](https://learn.adafruit.com/adafruit-hallowing?view=all#tft-2-18)。
- en: Displaying a bitmap image
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示位图图像
- en: This recipe will show you how to create a function that receives the path to
    a bitmap image, takes this image, and displays it on the HalloWing screen. There
    are many different objects and options available for manipulating the contents
    of the screen. We will have to interact with a number of these different objects,
    even when we just want to show a single image. This recipe gives you an insight
    into what is involved in getting an image rendered on the board's screen. This
    recipe can be helpful if you are using the HalloWing device for projects that
    need to display different images and you want a straightforward way to change
    the currently displayed image.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 该食谱将向您展示如何创建一个接收位图图像路径的函数，获取该图像，并在HalloWing屏幕上显示它。有许多不同的对象和选项可用于操作屏幕的内容。即使我们只想显示单个图像，我们也必须与许多不同的对象进行交互。该食谱让您了解在将图像呈现在板的屏幕上所涉及的内容。如果您正在使用HalloWing设备进行需要显示不同图像的项目，并且希望以简单的方式更改当前显示的图像，这个食谱可能会有所帮助。
- en: Getting ready
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on the Adafruit HalloWing device to run the
    code presented in this recipe.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要访问Adafruit HalloWing设备上的REPL来运行本食谱中提供的代码。
- en: How to do it...
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to learn how to display a bitmap image on the HalloWing
    device''s screen:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何在HalloWing设备屏幕上显示位图图像：
- en: 'Execute the following block of code in the REPL:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中执行以下代码块：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The necessary objects from the `displayio` module have now been imported. Run
    the following block of code to open a file object as a binary stream:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在已经导入了`displayio`模块中的必要对象。运行以下代码块以将文件对象打开为二进制流：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We will use this file object to create our bitmap object and then prepare the
    `pixel_shader` object:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用此文件对象来创建我们的位图对象，然后准备`pixel_shader`对象：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'These two objects are then used as arguments for creating a `TileGrid` object
    called `sprite`:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，这两个对象被用作创建名为`sprite`的`TileGrid`对象的参数：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following block of code creates a group object and appends the `sprite`
    to it:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块创建了一个组对象，并将`sprite`附加到其中：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can use the following block of code to show this group on the display and
    call `wait_for_frame` to make the block of code wait until the display has been
    fully updated. Now, we will close the file object as it is no longer needed:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码块在显示器上显示此组，并调用`wait_for_frame`使代码块等待直到显示器完全更新。现在，我们将关闭文件对象，因为它不再需要：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run the following block of code to define the `show_image` function and call
    it to show a different image on the display:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下代码块来定义`show_image`函数并调用它在显示屏上显示不同的图像：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following code should be put into the `main.py` file:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码应放入`main.py`文件中：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When this script is executed, it will repeatedly change the image being displayed
    between two different bitmaps.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此脚本时，它将重复在显示屏上显示两个不同位图之间切换的图像。
- en: How it works...
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `show_image` function in this recipe does all the heavy lifting of displaying
    the bitmap on the screen. It receives one argument, which is the path to the bitmap
    file. This file is opened for reading and then used to create an `OnDiskBitmap`
    object called bitmap.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 该食谱中的`show_image`函数负责在屏幕上显示位图。它接收一个参数，即位图文件的路径。该文件被打开进行读取，然后用于创建一个名为位图的`OnDiskBitmap`对象。
- en: The `ColorConverter` object is used to create the `pixel_shader` variable. A
    `TileGrid` object is created and requires the bitmap to be displayed, as well
    as the pixel shader that will be used. Both of these arguments are provided and
    the new `TileGrid` object is saved in the sprite variable. The sprite variable
    cannot be given directly to the `DISPLAY` object, so we must create a `Group`
    object and append the sprite to it.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`ColorConverter`对象用于创建`pixel_shader`变量。创建了一个`TileGrid`对象，并需要显示位图以及将要使用的像素着色器。这两个参数都已提供，并且新的`TileGrid`对象保存在`sprite`变量中。`sprite`变量不能直接提供给`DISPLAY`对象，因此我们必须创建一个`Group`对象并将`sprite`附加到其中。'
- en: We can now call the show method on the `DISPLAY` object to show the `group`
    variable. The `wait_for_frame` method is called to make sure that the image is
    fully displayed on the screen before continuing. The main function starts an infinite
    loop that repeatedly calls `show_image` to continuously change the currently displayed
    image.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在`DISPLAY`对象上调用`show`方法来显示`group`变量。调用`wait_for_frame`方法以确保图像在屏幕上完全显示后继续。主函数启动一个无限循环，不断调用`show_image`来连续更改当前显示的图像。
- en: There's more...
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来...
- en: There are a lot of different types of objects that need to be employed to display
    a bitmap image on the HalloWing device. Part of the reason for this is that each
    object provides a wide variety of flexibility in terms of how the image is displayed
    on the screen. You can, for example, control the *x* and *y* coordinates of an
    image or use other bitmap objects that don't come from files.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在HalloWing设备上显示位图图像需要使用许多不同类型的对象。部分原因是每个对象在图像在屏幕上显示方面提供了广泛的灵活性。例如，您可以控制图像的*x*和*y*坐标，或者使用其他不来自文件的位图对象。
- en: The display can display images with a resolution of up to 128 x 128, saved in
    the 24-bit pixel BMP file format. You can use the open source GIMP image editor
    to create these images.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 显示器可以显示分辨率高达128 x 128的图像，保存在24位像素BMP文件格式中。您可以使用开源的GIMP图像编辑器创建这些图像。
- en: 'When you create a new image in the GIMP application, you should set the correct
    resolution, as shown in the following screenshot:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在GIMP应用程序中创建新图像时，应设置正确的分辨率，如下截图所示：
- en: '![](assets/71187889-9643-49fd-b1a2-31085a1b88a7.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/71187889-9643-49fd-b1a2-31085a1b88a7.png)'
- en: 'When you are ready to save the image, use the Export function in the file menu
    and save your image in BMP file format. When you do this, make sure you select
    the correct bits per pixel setting, as shown in the following screenshot:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当您准备保存图像时，请使用文件菜单中的导出功能，并以BMP文件格式保存图像。在执行此操作时，请确保选择正确的每像素位数设置，如下截图所示：
- en: '![](assets/9f973955-24eb-4610-8356-4b5f357d9dbf.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9f973955-24eb-4610-8356-4b5f357d9dbf.png)'
- en: It's important to know that you can also use images of a smaller resolution,
    and that this will be automatically detected and correctly displayed on the screen.
    Smaller images also tend to be displayed on the screen faster.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，您还可以使用较小分辨率的图像，并且这将自动检测并正确显示在屏幕上。较小的图像也往往会更快地显示在屏幕上。
- en: See also
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references regarding this recipe:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是有关此配方的一些参考资料：
- en: Downloads for the GIMP image editor can be found at [https://www.gimp.org/](https://www.gimp.org/).
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GIMP图像编辑器的下载地址为[https://www.gimp.org/](https://www.gimp.org/)。
- en: Documentation on the `OnDiskBitmap` object can be found at [https://circuitpython.readthedocs.io/en/latest/shared-bindings/displayio/OnDiskBitmap.html](https://circuitpython.readthedocs.io/en/latest/shared-bindings/displayio/OnDiskBitmap.html).
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`OnDiskBitmap`对象的文档可在[https://circuitpython.readthedocs.io/en/latest/shared-bindings/displayio/OnDiskBitmap.html](https://circuitpython.readthedocs.io/en/latest/shared-bindings/displayio/OnDiskBitmap.html)找到。
- en: Listing all image files
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出所有图像文件
- en: This recipe will show you how to list all the image files in a specific directory.
    In the joke-telling machine, we are creating each joke question and response as
    a pair of images. This recipe will allow you to list all your bitmap images on
    the board. We will then extend this functionality to filter the list further and
    have all the bitmap images of the joke questions at hand. This recipe can be useful
    in any project that you create where you want to retrieve a list of images to
    display or audio files or play in your project.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方将向您展示如何列出特定目录中的所有图像文件。在讲笑话的机器中，我们将每个笑话问题和响应创建为一对图像。此配方将允许您列出板上的所有位图图像。然后，我们将扩展此功能以进一步过滤列表，并拥有所有笑话问题的位图图像。此配方可在您创建的任何项目中使用，其中您希望检索要显示的图像列表或音频文件或在您的项目中播放。
- en: Getting ready
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on the Adafruit HalloWing device to run the
    code presented in this recipe.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问Adafruit HalloWing设备上的REPL来运行此配方中提供的代码。
- en: How to do it...
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to learn how to list image files:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何列出图像文件：
- en: 'Use the REPL to run the following lines of code:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用REPL运行以下代码行：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We have now retrieved and output a sorted list of all the paths on the board''s
    root directory. We will use the following block of code to list only bitmap image
    files:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在已经检索并输出了板上根目录中所有路径的排序列表。我们将使用以下代码块仅列出位图图像文件：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can extend this further and only list joke question image files, as shown
    in the following block of code:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以进一步扩展这一点，只列出笑话问题图像文件，如下面的代码块所示：
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following block of code will select the first question image and save it
    to a variable:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块将选择第一个问题图像并将其保存到一个变量中：
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following block of code can be used to calculate the name of a joke''s
    response image based on the question image:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块可用于根据问题图像计算笑话的响应图像的名称：
- en: '[PRE38]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We will use the following block of code to confirm that the calculated response
    image exists as a file:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用以下代码块来确认计算的响应图像是否存在为文件：
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following code should be put into the `main.py` file:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码应放入`main.py`文件中：
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When this script is executed, it will list all question images and calculate
    their related response images.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此脚本时，将列出所有问题图像并计算其相关的响应图像。
- en: How it works...
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `get_questions` function in this recipe saves a sorted list of filenames
    in the `paths` variable. It then filters the listing to only include the question
    images by checking whether the `question.bmp` string appears in the filename.
    This filtered list is then returned by the function.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方中的`get_questions`函数将排序后的文件名列表保存在`paths`变量中。然后，它通过检查文件名中是否出现`question.bmp`字符串来过滤列表，仅包括问题图像。然后函数返回过滤后的列表。
- en: The main function calls the `get_questions` function and saves its results to
    the `questions` variable. Each question is looped through and has its response
    image calculated when we replace the `question.bmp` value with `response.bmp`
    in the filename. Both the question and response filenames are then printed before
    the next iteration of the loop commences.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 主函数调用`get_questions`函数，并将其结果保存到`questions`变量中。每个问题都会循环遍历，并在我们将文件名中的`question.bmp`值替换为`response.bmp`时计算其响应图像。然后打印问题和响应文件名，然后开始下一次循环。
- en: There's more...
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: A number of images will be used to create the joke-telling machine. We could
    have saved the names of the necessary images in the script itself, instead of
    directly listing them in the filesystem. But the approach taken in this recipe
    is better because it avoids us having to hardcode the image list directly in our
    application. This means that we can have 5 jokes or even 50 on the board without
    us having to change our application's code.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用多张图像来创建讲笑话的机器。我们本可以将所需图像的名称保存在脚本本身中，而不是直接在文件系统中列出它们。但是，此配方中采取的方法更好，因为它避免了我们直接在应用程序中硬编码图像列表。这意味着我们可以在不更改应用程序代码的情况下在板上拥有5个笑话甚至50个笑话。
- en: 'Each time we start the joke-telling machine, it will automatically grab the
    latest listing of joke images. The following screenshot shows the joke question
    and the responses that will be used in the next recipe to create the joke-telling
    machine:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 每次启动讲笑话的机器时，它都会自动抓取最新的笑话图像列表。以下屏幕截图显示了下一个配方中将用于创建讲笑话的机器的笑话问题和响应：
- en: '![](assets/ae0c3e94-3e8b-43bf-b075-d12389207c90.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ae0c3e94-3e8b-43bf-b075-d12389207c90.png)'
- en: You can see that the filenames follow a simple naming convention to make it
    easy for you to see each question and response when they're viewed in an image
    viewer. This naming convention also makes it an easy process to calculate the
    related response image for a specific question image.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，文件名遵循简单的命名约定，使您在图像查看器中查看每个问题和响应时更容易。这种命名约定还使得计算特定问题图像的相关响应图像变得更加容易。
- en: See also
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references regarding this recipe:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是有关此配方的一些参考资料：
- en: Documentation on the BMP file format can be found at [https://www.fileformat.info/format/bmp/egff.htm](https://www.fileformat.info/format/bmp/egff.htm).
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关BMP文件格式的文档可以在[https://www.fileformat.info/format/bmp/egff.htm](https://www.fileformat.info/format/bmp/egff.htm)找到。
- en: Details on using bitmap images on the HalloWing device can be found at [https://learn.adafruit.com/hallowing-badge/hallowing-badge-and-image-player](https://learn.adafruit.com/hallowing-badge/hallowing-badge-and-image-player).
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关在HalloWing设备上使用位图图像的详细信息可以在[https://learn.adafruit.com/hallowing-badge/hallowing-badge-and-image-player](https://learn.adafruit.com/hallowing-badge/hallowing-badge-and-image-player)找到。
- en: Creating a joke-telling machine
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个讲笑话机
- en: This recipe will show you how to list all the image files in a specific directory.
    In the joke-telling machine we are creating, each joke question and response will
    be provided as a pair of images. This recipe will show us how to list all our
    bitmap images on the board.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程将向您展示如何列出特定目录中的所有图像文件。在我们创建的讲笑话机中，每个笑话问题和回答都将作为一对图像提供。这个教程将向我们展示如何列出板上所有的位图图像。
- en: We will then extend this functionality to further filter the list so that we
    have all the bitmap images of the joke questions at hand. This recipe will help
    you if you want to create a project where you want to retrieve a list of images
    or audio files so that you can display or play them in your project.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将扩展此功能，以进一步过滤列表，以便我们手头有所有笑话问题的位图图像。如果您想创建一个项目，其中需要检索图像或音频文件的列表，以便在项目中显示或播放它们，那么这个教程将对您有所帮助。
- en: Getting ready
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on the Adafruit HalloWing device to run the
    code presented in this recipe.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问Adafruit HalloWing设备上的REPL，以运行本教程中提供的代码。
- en: How to do it...
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to learn how to create a joke-telling machine:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何创建一个讲笑话机：
- en: 'Run the following lines of code in the REPL:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中运行以下代码行：
- en: '[PRE41]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We have now imported all the necessary modules. The following block of code
    will create a `TouchIn` object:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在已经导入了所有必要的模块。以下代码块将创建一个`TouchIn`对象：
- en: '[PRE42]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the following block of code, we will check the status of the touchpad:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码块中，我们将检查触摸板的状态：
- en: '[PRE43]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Touch the pad while executing the following block of code:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行以下代码块时触摸板：
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The following block of code will define the `wait_for_touch` function, which
    will keep looping until a touch event is detected:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块将定义`wait_for_touch`函数，该函数将一直循环，直到检测到触摸事件为止：
- en: '[PRE45]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We will use the following block of code to call `wait_for_touch`. After executing
    this function, wait a few moments before touching the pad to confirm that the
    function returns from its `while` loop once it detects the touch event:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用以下代码块来调用`wait_for_touch`。执行此函数后，等待片刻，然后触摸板以确认函数在检测到触摸事件后是否从其`while`循环中返回：
- en: '[PRE46]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The following block of code will save the list of question images in the `questions`
    variable:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块将保存`questions`变量中的问题图像列表：
- en: '[PRE47]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We will use the following block of code to randomly select a question from
    the questions list:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用以下代码块来随机选择问题列表中的问题：
- en: '[PRE48]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The following code should be put into the `main.py` file:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码应放入`main.py`文件中：
- en: '[PRE49]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: When this script is executed, it will start the joke-telling machine and let
    you see joke questions and responses on the display each time you press the touchpad.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此脚本时，它将启动讲笑话机，并在每次按触摸板时让您在显示器上看到笑话问题和回答。
- en: How it works...
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `main` function creates a `TouchIn` object that's connected to the first
    touchpad connector on the board. The list of question images is retrieved by calling
    the `get_questions()` function and saving the returned list in the `questions`
    variable.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数创建一个连接到板上第一个触摸板连接器的`TouchIn`对象。通过调用`get_questions()`函数检索问题图像列表，并将返回的列表保存在`questions`变量中。'
- en: An infinite event loop is then started, which first selects a random question
    and calculates the associated response image for that question. The question image
    is then displayed on the screen by calling the `show_image` function. The `wait_for_touch`
    function is then called, which loops and checks for a touch event every 100 milliseconds.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然后启动一个无限事件循环，首先选择一个随机问题，并计算与该问题相关的响应图像。然后通过调用`show_image`函数在屏幕上显示问题图像。然后调用`wait_for_touch`函数，该函数循环检查触摸事件，每100毫秒检查一次。
- en: Once a touch event is detected, the function is returned, and then the `show_image`
    function is called to show the response image. The `wait_for_touch` function is
    called again so that the user can see the response before deciding to load another
    question by pressing the touchpad. Once the touchpad is pressed, the current loop
    iteration ends and the process starts again with a new, randomly selected question.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦检测到触摸事件，函数将返回，然后调用`show_image`函数显示响应图像。然后再次调用`wait_for_touch`函数，以便用户在决定通过按触摸板加载另一个问题之前可以看到响应。一旦按下触摸板，当前循环迭代结束，进程将以新选择的随机问题重新开始。
- en: There's more...
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The joke-telling machine is a fun way to use the input and output potential
    of this board. It uses the board's graphical display to show the different joke
    questions and responses, as well as the capacitive touch sensors as input to make
    the application load the next question or show the answer to a loaded question.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 讲笑话机是使用该板的输入和输出功能的一种有趣方式。它使用板的图形显示来显示不同的笑话问题和回答，以及电容触摸传感器作为输入，以使应用程序加载下一个问题或显示加载问题的答案。
- en: This base recipe can be extended in many ways. Since the board comes with four
    touchpads, you could create a simple menu system where people can choose from
    different categories of jokes. You could even create a project for digital dice
    by having images of the six sides of a die and showing a random side each time
    the touchpad is pressed.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基本教程可以以许多方式进行扩展。由于该板带有四个触摸板，您可以创建一个简单的菜单系统，让人们可以从不同类别的笑话中进行选择。您甚至可以通过拥有骰子六个面的图像，并在每次按触摸板时显示一个随机面，来创建一个数字骰子的项目。
- en: See also
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references regarding this recipe:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于这个配方的一些参考资料：
- en: Documentation on the `ColorConverter` object can be found at [https://circuitpython.readthedocs.io/en/latest/shared-bindings/displayio/ColorConverter.html](https://circuitpython.readthedocs.io/en/latest/shared-bindings/displayio/ColorConverter.html).
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ColorConverter` 对象的文档可以在 [https://circuitpython.readthedocs.io/en/latest/shared-bindings/displayio/ColorConverter.html](https://circuitpython.readthedocs.io/en/latest/shared-bindings/displayio/ColorConverter.html)
    找到。'
- en: Documentation on the `TileGrid` object can be found at [https://circuitpython.readthedocs.io/en/latest/shared-bindings/displayio/TileGrid.html](https://circuitpython.readthedocs.io/en/latest/shared-bindings/displayio/TileGrid.html).
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TileGrid` 对象的文档可以在 [https://circuitpython.readthedocs.io/en/latest/shared-bindings/displayio/TileGrid.html](https://circuitpython.readthedocs.io/en/latest/shared-bindings/displayio/TileGrid.html)
    找到。'
