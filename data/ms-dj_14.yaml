- en: Chapter 14. Generating Non-HTML Content
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章。生成非HTML内容
- en: 'Usually when we talk about developing websites, we''re talking about producing
    HTML. Of course, there''s a lot more to the web than HTML; we use the web to distribute
    data in all sorts of formats: RSS, PDFs, images, and so forth.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们谈论开发网站时，我们谈论的是生成HTML。当然，网页不仅仅是HTML；我们使用网页以各种格式分发数据：RSS、PDF、图像等等。
- en: 'So far, we''ve focused on the common case of HTML production, but in this chapter
    we''ll take a detour and look at using Django to produce other types of content.
    Django has convenient built-in tools that you can use to produce some common non-HTML
    content:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们专注于HTML生成的常见情况，但在本章中，我们将走一条弯路，看看如何使用Django生成其他类型的内容。Django有方便的内置工具，可以用来生成一些常见的非HTML内容：
- en: Comma-delimited (CSV) files for importing into spreadsheet applications.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逗号分隔（CSV）文件，用于导入到电子表格应用程序中。
- en: PDF files.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PDF文件。
- en: RSS/Atom syndication feeds.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RSS/Atom订阅源。
- en: Sitemaps (an XML format originally developed by Google that gives hints to search
    engines).
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 站点地图（最初由谷歌开发的XML格式，为搜索引擎提供提示）。
- en: We'll examine each of those tools a little later, but first we'll cover the
    basic principles.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会详细讨论这些工具，但首先我们将介绍基本原则。
- en: 'The basics: views and MIME types'
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础知识：视图和MIME类型
- en: Recall from [Chapter 2](ch02.xhtml "Chapter 2. Views and URLconfs"), *Views
    and URLconfs*, that a view function is simply a Python function that takes a web
    request and returns a web response. This response can be the HTML contents of
    a web page, or a redirect, or a 404 error, or an XML document, or an image ...or
    anything, really. More formally, a Django view function must*:*
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第2章](ch02.xhtml“第2章。视图和URLconfs”)中回忆，*视图和URLconfs*，视图函数只是一个接受Web请求并返回Web响应的Python函数。这个响应可以是网页的HTML内容，或者重定向，或者404错误，或者XML文档，或者图像...或者任何东西。更正式地说，Django视图函数必须*：*
- en: Accept an `HttpRequest` instance as its first argument; and
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受一个`HttpRequest`实例作为其第一个参数；和
- en: Return an `HttpResponse` instance.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回一个`HttpResponse`实例。
- en: The key to returning non-HTML content from a view lies in the `HttpResponse`
    class, specifically the `content_type` argument. By default, Django sets `content_type`
    to text/html. You can however, set `content_type` to any of the official Internet
    media types (MIME types) managed by IANA (for more information visit [http://www.iana.org/assignments/media-types/media-types.xhtml](http://www.iana.org/assignments/media-types/media-types.xhtml)).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从视图返回非HTML内容的关键在于`HttpResponse`类，特别是`content_type`参数。默认情况下，Django将`content_type`设置为text/html。但是，您可以将`content_type`设置为IANA管理的任何官方互联网媒体类型（MIME类型）（有关更多信息，请访问[http://www.iana.org/assignments/media-types/media-types.xhtml](http://www.iana.org/assignments/media-types/media-types.xhtml)）。
- en: 'By tweaking the MIME type, we can indicate to the browser that we''ve returned
    a response of a different format. For example, let''s look at a view that returns
    a PNG image. To keep things simple, we''ll just read the file off the disk:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调整MIME类型，我们可以告诉浏览器我们返回了不同格式的响应。例如，让我们看一个返回PNG图像的视图。为了保持简单，我们只需从磁盘上读取文件：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That's it! If you replace the image path in the `open()` call with a path to
    a real image, you can use this very simple view to serve an image, and the browser
    will display it correctly.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！如果您用`open()`调用中的图像路径替换为真实图像的路径，您可以使用这个非常简单的视图来提供图像，浏览器将正确显示它。
- en: The other important thing to keep in mind is that `HttpResponse` objects implement
    Python's standard file-like object API. This means that you can use an `HttpResponse`
    instance in any place Python (or a third-party library) expects a file. For an
    example of how that works, let's take a look at producing CSV with Django.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的事情是`HttpResponse`对象实现了Python的标准文件类对象API。这意味着您可以在任何需要文件的地方使用`HttpResponse`实例，包括Python（或第三方库）。让我们看一下如何使用Django生成CSV的示例。
- en: Producing CSV
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成CSV
- en: 'Python comes with a CSV library, `csv`. The key to using it with Django is
    that the `csv` module''s CSV-creation capability acts on file-like objects, and
    Django''s `HttpResponse` objects are file-like objects. Here''s an example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Python自带一个CSV库，`csv`。使用它与Django的关键在于`csv`模块的CSV创建功能作用于类似文件的对象，而Django的`HttpResponse`对象是类似文件的对象。下面是一个例子：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The code and comments should be self-explanatory, but a few things deserve
    a mention:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 代码和注释应该是不言自明的，但有几件事值得一提：
- en: The response gets a special MIME type, `text/csv`. This tells browsers that
    the document is a CSV file, rather than an HTML file. If you leave this off, browsers
    will probably interpret the output as HTML, which will result in ugly, scary gobbledygook
    in the browser window.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应获得了特殊的MIME类型`text/csv`。这告诉浏览器该文档是CSV文件，而不是HTML文件。如果不这样做，浏览器可能会将输出解释为HTML，这将导致浏览器窗口中出现丑陋、可怕的胡言乱语。
- en: The response gets an additional `Content-Disposition` header, which contains
    the name of the CSV file. This filename is arbitrary; call it whatever you want.
    It'll be used by browsers in the Save as... dialogue, and so on.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应获得了额外的`Content-Disposition`头，其中包含CSV文件的名称。这个文件名是任意的；随便取什么名字。它将被浏览器用于“另存为...”对话框等。
- en: 'Hooking into the CSV-generation API is easy: Just pass `response` as the first
    argument to `csv.writer`. The `csv.writer` function expects a file-like object,
    and `HttpResponse` objects fit the bill.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到CSV生成API很容易：只需将`response`作为`csv.writer`的第一个参数。`csv.writer`函数期望一个类似文件的对象，而`HttpResponse`对象符合要求。
- en: For each row in your CSV file, call `writer.writerow`, passing it an iterable
    object such as a list or tuple.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于CSV文件中的每一行，调用`writer.writerow`，将其传递给一个可迭代对象，如列表或元组。
- en: The CSV module takes care of quoting for you, so you don't have to worry about
    escaping strings with quotes or commas in them. Just pass `writerow()` your raw
    strings, and it'll do the right thing.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSV模块会为您处理引用，因此您不必担心用引号或逗号转义字符串。只需将`writerow()`传递给您的原始字符串，它就会做正确的事情。
- en: Streaming large CSV files
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流式传输大型CSV文件
- en: 'When dealing with views that generate very large responses, you might want
    to consider using Django''s `StreamingHttpResponse` instead. For example, by streaming
    a file that takes a long time to generate you can avoid a load balancer dropping
    a connection that might have otherwise timed out while the server was generating
    the response. In this example, we make full use of Python generators to efficiently
    handle the assembly and transmission of a large CSV file:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 处理生成非常大响应的视图时，您可能希望考虑改用Django的`StreamingHttpResponse`。例如，通过流式传输需要很长时间生成的文件，您可以避免负载均衡器在服务器生成响应时可能会超时而断开连接。在这个例子中，我们充分利用Python生成器来高效地处理大型CSV文件的组装和传输：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using the template system
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模板系统
- en: 'Alternatively, you can use the Django template system to generate CSV. This
    is lower-level than using the convenient Python `csv` module, but the solution
    is presented here for completeness. The idea here is to pass a list of items to
    your template, and have the template output the commas in a `for` loop. Here''s
    an example, which generates the same CSV file as above:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用Django模板系统来生成CSV。这比使用方便的Python `csv`模块更低级，但是这里提供了一个完整的解决方案。这里的想法是将一个项目列表传递给您的模板，并让模板在`for`循环中输出逗号。以下是一个示例，它生成与上面相同的CSV文件：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The only difference between this example and the previous example is that this
    one uses template loading instead of the CSV module. The rest of the code-such
    as the `content_type=''text/csv''`-is the same. Then, create the template `my_template_name.txt`,
    with this template code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子和之前的例子唯一的区别是这个例子使用模板加载而不是CSV模块。其余的代码，比如`content_type='text/csv'`，都是一样的。然后，创建模板`my_template_name.txt`，其中包含以下模板代码：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This template is quite basic. It just iterates over the given data and displays
    a line of CSV for each row. It uses the `addslashes` template filter to ensure
    there aren't any problems with quotes.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板非常基础。它只是遍历给定的数据，并为每一行显示一个CSV行。它使用`addslashes`模板过滤器来确保引号没有问题。
- en: Other text-based formats
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他基于文本的格式
- en: Notice that there isn't very much specific to CSV here-just the specific output
    format. You can use either of these techniques to output any text-based format
    you can dream of. You can also use a similar technique to generate arbitrary binary
    data; For example, generating PDFs.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里与CSV相关的内容并不多，只是特定的输出格式。您可以使用这些技术中的任何一种来输出您梦想中的任何基于文本的格式。您还可以使用类似的技术来生成任意二进制数据；例如，生成PDF文件。
- en: Generating PDF
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成PDF
- en: Django is able to output PDF files dynamically using views. This is made possible
    by the excellent, open-source ReportLab (for more information visit [http://www.reportlab.com/opensource/](http://www.reportlab.com/opensource/))
    Python PDF library. The advantage of generating PDF files dynamically is that
    you can create customized PDFs for different purposes-say, for different users
    or different pieces of content.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Django能够使用视图动态输出PDF文件。这得益于出色的开源ReportLab（有关更多信息，请访问[http://www.reportlab.com/opensource/](http://www.reportlab.com/opensource/)）Python
    PDF库。动态生成PDF文件的优势在于，您可以为不同目的创建定制的PDF文件，比如为不同用户或不同内容创建。
- en: Install ReportLab
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装ReportLab
- en: 'The **ReportLab** library is available on PyPI. A user guide (not coincidentally,
    a PDF file) is also available for download. You can install ReportLab with `pip`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**ReportLab**库可在PyPI上获得。还可以下载用户指南（不巧的是，是一个PDF文件）。您可以使用`pip`安装ReportLab：'
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Test your installation by importing it in the Python interactive interpreter:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在Python交互解释器中导入它来测试您的安装：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If that command doesn't raise any errors, the installation worked.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该命令没有引发任何错误，则安装成功。
- en: Write your view
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写您的视图
- en: 'The key to generating PDFs dynamically with Django is that the ReportLab API,
    like the `csv` library acts on file-like objects, like Django''s `HttpResponse`.
    Here''s a Hello World example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Django动态生成PDF的关键是ReportLab API，就像`csv`库一样，它作用于文件样对象，比如Django的`HttpResponse`。以下是一个Hello
    World示例：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The code and comments should be self-explanatory, but a few things deserve
    a mention:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 代码和注释应该是不言自明的，但有几点值得一提：
- en: The response gets a special MIME type, `application/pdf`. This tells browsers
    that the document is a PDF file, rather than an HTML file.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应获得了特殊的MIME类型，`application/pdf`。这告诉浏览器该文档是一个PDF文件，而不是HTML文件。
- en: 'The response gets an additional `Content-Disposition` header, which contains
    the name of the PDF file. This filename is arbitrary: Call it whatever you want.
    It''ll be used by browsers in the Save as... dialogue, and so on.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应获得了额外的`Content-Disposition`头部，其中包含PDF文件的名称。这个文件名是任意的：随便取什么名字都可以。浏览器将在“另存为...”对话框中使用它，等等。
- en: 'The `Content-Disposition` header starts with `''attachment; ''` in this example.
    This forces web browsers to pop-up a dialog box prompting/confirming how to handle
    the document even if a default is set on the machine. If you leave off `''attachment;''`,
    browsers will handle the PDF using whatever program/plugin they''ve been configured
    to use for PDFs. Here''s what that code would look like:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个例子中，`Content-Disposition`头部以`'attachment; '`开头。这会强制Web浏览器弹出一个对话框，提示/确认如何处理文档，即使在计算机上设置了默认值。如果省略`'attachment;'`，浏览器将使用为PDF配置的任何程序/插件来处理PDF。以下是该代码的样子：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Hooking into the ReportLab API is easy: Just pass `response` as the first argument
    to `canvas.Canvas`. The `Canvas` class expects a file-like object, and `HttpResponse`
    objects fit the bill.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到ReportLab API很容易：只需将`response`作为`canvas.Canvas`的第一个参数传递。`Canvas`类需要一个文件样对象，而`HttpResponse`对象正合适。
- en: Note that all subsequent PDF-generation methods are called on the PDF object
    (in this case, `p`)-not on `response`.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请注意，所有后续的PDF生成方法都是在PDF对象（在本例中是`p`）上调用的，而不是在`response`上调用的。
- en: Finally, it's important to call `showPage()` and `save()` on the PDF file.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，重要的是在PDF文件上调用`showPage()`和`save()`。
- en: Complex PDF's
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复杂的PDF
- en: 'If you''re creating a complex PDF document with ReportLab, consider using the
    `io` library as a temporary holding place for your PDF file. This library provides
    a file-like object interface that is particularly efficient. Here''s the above
    Hello World example re-written to use `io`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用ReportLab创建复杂的PDF文档，考虑使用`io`库作为PDF文件的临时存储位置。这个库提供了一个特别高效的类文件对象接口。以下是上面的Hello
    World示例重写，使用`io`：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Further resources
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多资源
- en: PDFlib ([http://www.pdflib.org/](http://www.pdflib.org/)) is another PDF-generation
    library that has Python bindings. To use it with Django, just use the same concepts
    explained in this article.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PDFlib ([http://www.pdflib.org/](http://www.pdflib.org/))是另一个具有Python绑定的PDF生成库。要在Django中使用它，只需使用本文中解释的相同概念。
- en: Pisa XHTML2PDF ([http://www.xhtml2pdf.com/](http://www.xhtml2pdf.com/)) is yet
    another PDF-generation library. Pisa ships with an example of how to integrate
    Pisa with Django.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pisa XHTML2PDF ([http://www.xhtml2pdf.com/](http://www.xhtml2pdf.com/)) 是另一个PDF生成库。Pisa附带了如何将Pisa与Django集成的示例。
- en: HTMLdoc ([http://www.htmldoc.org/](http://www.htmldoc.org/)) is a command-line
    script that can convert HTML to PDF. It doesn't have a Python interface, but you
    can escape out to the shell using `system` or `popen` and retrieve the output
    in Python.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTMLdoc ([http://www.htmldoc.org/](http://www.htmldoc.org/))是一个可以将HTML转换为PDF的命令行脚本。它没有Python接口，但你可以使用`system`或`popen`跳出到shell，并在Python中检索输出。
- en: Other possibilities
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他可能性
- en: 'There''s a whole host of other types of content you can generate in Python.
    Here are a few more ideas and some pointers to libraries you could use to implement
    them:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，你可以生成许多其他类型的内容。以下是一些更多的想法和一些指向你可以用来实现它们的库的指针：
- en: '**ZIP****files**: Python''s standard library ships with the `zipfile` module,
    which can both read and write compressed ZIP files. You could use it to provide
    on-demand archives of a bunch of files, or perhaps compress large documents when
    requested. You could similarly produce TAR files using the standard library''s
    `tarfile` module.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ZIP文件**：Python的标准库配备了`zipfile`模块，可以读取和写入压缩的ZIP文件。你可以使用它提供一堆文件的按需存档，或者在请求时压缩大型文档。你也可以使用标准库的`tarfile`模块类似地生成TAR文件。'
- en: '**Dynamic ****images**: The **Python Imaging Library** (**PIL**) ([http://www.pythonware.com/products/pil/](http://www.pythonware.com/products/pil/))
    is a fantastic toolkit for producing images (PNG, JPEG, GIF, and a whole lot more).
    You could use it to automatically scale down images into thumbnails, composite
    multiple images into a single frame, or even do web-based image processing.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态图片**：**Python Imaging Library**（**PIL**）([http://www.pythonware.com/products/pil/](http://www.pythonware.com/products/pil/))是一个用于生成图片（PNG、JPEG、GIF等）的绝妙工具包。你可以使用它自动缩小图片为缩略图，将多个图片合成单个框架，甚至进行基于网络的图像处理。'
- en: '**Plots and charts**: There are a number of powerful Python plotting and charting
    libraries you could use to produce on-demand maps, charts, plots, and graphs.
    We can''t possibly list them all, so here are a couple of the highlights:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图表和图表**：有许多强大的Python绘图和图表库，你可以使用它们生成按需地图、图表、绘图和图表。我们不可能列出它们所有，所以这里是一些亮点：'
- en: '`matplotlib` ([http://matplotlib.sourceforge.net/](http://matplotlib.sourceforge.net/))
    can be used to produce the type of high-quality plots usually generated with MatLab
    or Mathematica.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`matplotlib` ([http://matplotlib.sourceforge.net/](http://matplotlib.sourceforge.net/))可用于生成通常使用MatLab或Mathematica生成的高质量图表。'
- en: '`pygraphviz` ([http://networkx.lanl.gov/pygraphviz/](http://networkx.lanl.gov/pygraphviz/)),
    an interface to the Graphviz graph layout toolkit, can be used for generating
    structured diagrams of graphs and networks.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pygraphviz` ([http://networkx.lanl.gov/pygraphviz/](http://networkx.lanl.gov/pygraphviz/))，一个与Graphviz图形布局工具包的接口，可用于生成图和网络的结构化图表。'
- en: In general, any Python library capable of writing to a file can be hooked into
    Django. The possibilities are immense. Now that we've looked at the basics of
    generating non-HTML content, let's step up a level of abstraction. Django ships
    with some pretty nifty built-in tools for generating some common types of non-HTML
    content.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，任何能够写入文件的Python库都可以连接到Django。可能性是巨大的。现在我们已经了解了生成非HTML内容的基础知识，让我们提高一个抽象级别。Django配备了一些非常巧妙的内置工具，用于生成一些常见类型的非HTML内容。
- en: The syndication feed framework
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联合供稿框架
- en: Django comes with a high-level syndication-feed-generating framework that makes
    creating RSS and Atom feeds easy. RSS and Atom are both XML-based formats you
    can use to provide automatically updating feeds of your site's content. Read more
    about RSS here ([http://www.whatisrss.com/](http://www.whatisrss.com/)), and get
    information on Atom here ([http://www.atomenabled.org/](http://www.atomenabled.org/)).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Django配备了一个高级别的联合供稿生成框架，可以轻松创建RSS和Atom供稿。RSS和Atom都是基于XML的格式，你可以用它们提供站点内容的自动更新供稿。在这里阅读更多关于RSS的信息([http://www.whatisrss.com/](http://www.whatisrss.com/))，并在这里获取有关Atom的信息([http://www.atomenabled.org/](http://www.atomenabled.org/))。
- en: To create any syndication feed, all you have to do is write a short Python class.
    You can create as many feeds as you want. Django also comes with a lower-level
    feed-generating API. Use this if you want to generate feeds outside of a web context,
    or in some other lower-level way.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 创建任何联合供稿，你所要做的就是编写一个简短的Python类。你可以创建任意数量的供稿。Django还配备了一个低级别的供稿生成API。如果你想在网页上下文之外或以其他低级别方式生成供稿，可以使用这个API。
- en: The high-level framework
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级别框架
- en: Overview
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: The high-level feed-generating framework is supplied by the `Feed` class. To
    create a feed, write a `Feed` class and point to an instance of it in your URLconf.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 高级别的供稿生成框架由`Feed`类提供。要创建一个供稿，编写一个`Feed`类，并在你的URLconf中指向它的一个实例。
- en: Feed classes
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 供稿类
- en: A `Feed` class is a Python class that represents a syndication feed. A feed
    can be simple (for example, a site news feed, or a basic feed displaying the latest
    entries of a blog) or more complex (for example, a feed displaying all the blog
    entries in a particular category, where the category is variable). Feed classes
    subclass `django.contrib.syndication.views.Feed`. They can live anywhere in your
    codebase. Instances of `Feed` classes are views which can be used in your URLconf.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`Feed`类是表示订阅源的Python类。订阅源可以是简单的（例如，站点新闻订阅，或者显示博客最新条目的基本订阅源）或更复杂的（例如，显示特定类别中的所有博客条目的订阅源，其中类别是可变的）。Feed类是`django.contrib.syndication.views.Feed`的子类。它们可以存在于代码库的任何位置。`Feed`类的实例是视图，可以在您的URLconf中使用。'
- en: A simple example
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的例子
- en: 'This simple example, taken from a hypothetical police beat news site describes
    a feed of the latest five news items:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子，取自一个假设的警察打击新闻网站，描述了最新的五条新闻项目的订阅：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To connect a URL to this feed, put an instance of the Feed object in your URLconf.
    For example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要将URL连接到此订阅源，请在您的URLconf中放置`Feed`对象的实例。例如：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Note:**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：**'
- en: The Feed class subclasses `django.contrib.syndication.views.Feed`.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Feed类是`django.contrib.syndication.views.Feed`的子类。
- en: '`title`, `link` and `description` correspond to the standard RSS `<title>`,
    `<link>` and `<description>` elements, respectively.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`，`link`和`description`分别对应于标准的RSS`<title>`，`<link>`和`<description>`元素。'
- en: '`items()` is, simply, a method that returns a list of objects that should be
    included in the feed as `<item>` elements. Although this example returns `NewsItem`
    objects using Django''s object-relational mapper doesn''t have to return model
    instances. Although you get a few bits of functionality for free by using Django
    models, `items()` can return any type of object you want.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`items()`只是一个返回应包含在订阅源中的对象列表的方法。尽管此示例使用Django的对象关系映射器返回`NewsItem`对象，但不必返回模型实例。尽管使用Django模型可以免费获得一些功能，但`items()`可以返回任何类型的对象。'
- en: If you're creating an Atom feed, rather than an RSS feed, set the `subtitle`
    attribute instead of the `description` attribute. See Publishing Atom and RSS
    feeds in tandem later in this chapter for an example.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您要创建Atom订阅源，而不是RSS订阅源，请设置`subtitle`属性，而不是`description`属性。有关示例，请参见本章后面的同时发布Atom和RSS订阅源。
- en: One thing is left to do. In an RSS feed, each `<item>` has a `<title>`, `<link>`
    and `<description>`. We need to tell the framework what data to put into those
    elements.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事要做。在RSS订阅源中，每个`<item>`都有一个`<title>`，`<link>`和`<description>`。我们需要告诉框架将哪些数据放入这些元素中。
- en: For the contents of `<title>` and `<description>`, Django tries calling the
    methods `item_title()` and `item_description()` on the `Feed` class. They are
    passed a single parameter, `item`, which is the object itself. These are optional;
    by default, the unicode representation of the object is used for both.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`<title>`和`<description>`的内容，Django尝试在`Feed`类上调用`item_title()`和`item_description()`方法。它们传递了一个参数`item`，即对象本身。这些是可选的；默认情况下，对象的unicode表示用于两者。
- en: 'If you want to do any special formatting for either the title or description,
    Django templates can be used instead. Their paths can be specified with the `title_template`
    and `description_template` attributes on the `Feed` class. The templates are rendered
    for each item and are passed two template context variables:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想对标题或描述进行任何特殊格式化，可以使用Django模板。它们的路径可以在`Feed`类的`title_template`和`description_template`属性中指定。模板为每个项目呈现，并传递了两个模板上下文变量：
- en: '`{{ obj }}`-: The current object (one of whichever objects you returned in
    `items()`).'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{{ obj }}`-：当前对象（您在`items()`中返回的任何对象之一）。'
- en: '`{{ site }}`-: A Django `site` object representing the current site. This is
    useful for `{{ site.domain }}` or `{{ site.name }}`.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{{ site }}`-：表示当前站点的Django`site`对象。这对于`{{ site.domain }}`或`{{ site.name }}`非常有用。'
- en: See *A complex example* below that uses a description template.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅下面使用描述模板的*一个复杂的例子*。
- en: 'There is also a way to pass additional information to title and description
    templates, if you need to supply more than the two variables mentioned before.
    You can provide your implementation of `get_context_data` method in your `Feed`
    subclass. For example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要提供比之前提到的两个变量更多的信息，还有一种方法可以将标题和描述模板传递给您。您可以在`Feed`子类中提供`get_context_data`方法的实现。例如：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And the template:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 和模板：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This method will be called once per item in the list returned by `items()`
    with the following keyword arguments:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将针对`items()`返回的列表中的每个项目调用一次，并带有以下关键字参数：
- en: '`item`: the current item. For backward compatibility reasons, the name of this
    context variable is `{{ obj }}`.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`item`：当前项目。出于向后兼容的原因，此上下文变量的名称为`{{ obj }}`。'
- en: '`obj`: the object returned by `get_object()`. By default, this is not exposed
    to the templates to avoid confusion with `{{ obj }}` (see above), but you can
    use it in your implementation of `get_context_data()`.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`obj`：由`get_object()`返回的对象。默认情况下，这不会暴露给模板，以避免与`{{ obj }}`（见上文）混淆，但您可以在`get_context_data()`的实现中使用它。'
- en: '`site`: current site as described above.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`site`：如上所述的当前站点。'
- en: '`request`: current request.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`request`：当前请求。'
- en: The behavior of `get_context_data()` mimics that of generic views-you're supposed
    to call `super()` to retrieve context data from the parent class, add your data
    and return the modified dictionary.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_context_data()`的行为模仿了通用视图的行为-您应该调用`super()`来从父类检索上下文数据，添加您的数据并返回修改后的字典。'
- en: To specify the contents of `<link>`, you have two options. For each item in
    `items()`, Django first tries calling the `item_link()` method on the `Feed` class.
    In a similar way to the title and description, it's passed a single parameter-`item`.
    If that method doesn't exist, Django tries executing a `get_absolute_url()` method
    on that object.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定`<link>`的内容，您有两个选项。对于`items()`中的每个项目，Django首先尝试在`Feed`类上调用`item_link()`方法。类似于标题和描述，它传递了一个参数-`item`。如果该方法不存在，Django尝试在该对象上执行`get_absolute_url()`方法。
- en: Both `get_absolute_url()` and `item_link()` should return the item's URL as
    a normal Python string. As with `get_absolute_url()`, the result of `item_link()`
    will be included directly in the URL, so you are responsible for doing all necessary
    URL quoting and conversion to ASCII inside the method itself.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_absolute_url()`和`item_link()`都应返回项目的URL作为普通的Python字符串。与`get_absolute_url()`一样，`item_link()`的结果将直接包含在URL中，因此您负责在方法本身内部执行所有必要的URL引用和转换为ASCII。'
- en: A complex example
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个复杂的例子
- en: The framework also supports more complex feeds, via arguments. For example,
    a website could offer an RSS feed of recent crimes for every police beat in a
    city. It'd be silly to create a separate `Feed` class for each police beat; that
    would violate the DRY principle and would couple data to programming logic.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架还通过参数支持更复杂的源。例如，网站可以为城市中每个警察拍摄提供最新犯罪的RSS源。为每个警察拍摄创建单独的`Feed`类是愚蠢的；这将违反DRY原则，并将数据耦合到编程逻辑中。
- en: 'Instead, the syndication framework lets you access the arguments passed from
    your URLconf so feeds can output items based on information in the feed''s URL.
    The police beat feeds could be accessible via URLs like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，辛迪加框架允许您访问从URLconf传递的参数，因此源可以根据源URL中的信息输出项目。警察拍摄源可以通过以下URL访问：
- en: '`/beats/613/rss/`-: Returns recent crimes for beat 613.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/beats/613/rss/`-：返回613拍摄的最新犯罪。'
- en: '`/beats/1424/rss/`-: Returns recent crimes for beat 1424.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/beats/1424/rss/`-：返回1424拍摄的最新犯罪。'
- en: 'These can be matched with a URLconf line such as:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以与URLconf行匹配，例如：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Like a view, the arguments in the URL are passed to the `get_object()` method
    along with the request object. Here''s the code for these beat-specific feeds:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与视图一样，URL中的参数将与请求对象一起传递到`get_object()`方法。以下是这些特定于拍摄的源的代码：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To generate the feed's `<title>`, `<link>` and `<description>`, Django uses
    the `title()`, `link()` and `description()` methods.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成源的`<title>`，`<link>`和`<description>`，Django使用`title()`，`link()`和`description()`方法。
- en: 'In the previous example, they were simple string class attributes, but this
    example illustrates that they can be either strings *or* methods. For each of
    `title`, `link` and `description`, Django follows this algorithm:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，它们是简单的字符串类属性，但是此示例说明它们可以是字符串*或*方法。对于`title`，`link`和`description`，Django遵循此算法：
- en: First, it tries to call a method, passing the `obj` argument, where `obj` is
    the object returned by `get_object()`.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它尝试调用一个方法，传递`obj`参数，其中`obj`是`get_object()`返回的对象。
- en: Failing that, it tries to call a method with no arguments.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果失败，它将尝试调用一个没有参数的方法。
- en: Failing that, it uses the class attribute.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果失败，它将使用class属性。
- en: 'Also note that `items()` also follows the same algorithm-first, it tries `items(obj)`,
    then `items()`, then finally an `items` class attribute (which should be a list).
    We are using a template for the item descriptions. It can be very simple:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，`items()`也遵循相同的算法-首先尝试`items(obj)`，然后尝试`items()`，最后尝试`items`类属性（应该是一个列表）。我们正在使用模板来描述项目。它可以非常简单：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: However, you are free to add formatting as desired. The `ExampleFeed` class
    below gives full documentation on methods and attributes of `Feed` classes.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您可以根据需要自由添加格式。下面的`ExampleFeed`类完整记录了`Feed`类的方法和属性。
- en: Specifying the type of feed
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定源的类型
- en: 'By default, feeds produced in this framework use RSS 2.0\. To change that,
    add a `feed_type` attribute to your `Feed` class, like so:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，此框架生成的源使用RSS 2.0。要更改此设置，请向您的`Feed`类添加`feed_type`属性，如下所示：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note that you set `feed_type` to a class object, not an instance. Currently
    available feed types are:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，将`feed_type`设置为类对象，而不是实例。当前可用的源类型有：
- en: '`django.utils.feedgenerator.Rss201rev2Feed` (RSS 2.01\. Default.)'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django.utils.feedgenerator.Rss201rev2Feed`（RSS 2.01。默认）。'
- en: '`django.utils.feedgenerator.RssUserland091Feed` (RSS 0.91.)'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django.utils.feedgenerator.RssUserland091Feed`（RSS 0.91）。'
- en: '`django.utils.feedgenerator.Atom1Feed` (Atom 1.0.)'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django.utils.feedgenerator.Atom1Feed`（Atom 1.0）。'
- en: Enclosures
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附件
- en: To specify enclosures, such as those used in creating podcast feeds, use the
    `item_enclosure_url`, `item_enclosure_length` and `item_enclosure_mime_type` hooks.
    See the `ExampleFeed` class below for usage examples.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定附件，例如在创建播客源时使用的附件，请使用`item_enclosure_url`，`item_enclosure_length`和`item_enclosure_mime_type`挂钩。有关用法示例，请参阅下面的`ExampleFeed`类。
- en: Language
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语言
- en: Feeds created by the syndication framework automatically include the appropriate
    `<language>` tag (RSS 2.0) or `xml:lang` attribute (Atom). This comes directly
    from your `LANGUAGE_CODE` setting.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用辛迪加框架创建的源自动包括适当的`<language>`标签（RSS 2.0）或`xml:lang`属性（Atom）。这直接来自您的`LANGUAGE_CODE`设置。
- en: URLs
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: URL
- en: The `link` method/attribute can return either an absolute path (for example,
    `/blog/`) or a URL with the fully-qualified domain and protocol (for example,
    `http://www.example.com/blog/`). If `link` doesn't return the domain, the syndication
    framework will insert the domain of the current site, according to your `SITE_ID`
    setting. Atom feeds require a `<link rel="self">` that defines the feed's current
    location. The syndication framework populates this automatically, using the domain
    of the current site according to the `SITE_ID` setting.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`link`方法/属性可以返回绝对路径（例如，`/blog/`）或具有完全合格的域和协议的URL（例如，`http://www.example.com/blog/`）。如果`link`不返回域，辛迪加框架将根据您的`SITE_ID`设置插入当前站点的域。Atom源需要定义源的当前位置的`<link
    rel="self">`。辛迪加框架会自动填充这一点，使用当前站点的域，根据`SITE_ID`设置。'
- en: Publishing Atom and RSS Feeds in tandem
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同时发布Atom和RSS源
- en: 'Some developers like to make available both Atom and RSS versions of their
    feeds. That''s easy to do with Django: Just create a subclass of your `Feed` class
    and set the `feed_type` to something different. Then update your URLconf to add
    the extra versions. Here''s a full example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发人员喜欢提供其源的Atom和RSS版本。在Django中很容易做到：只需创建`Feed`类的子类，并将`feed_type`设置为不同的内容。然后更新您的URLconf以添加额外的版本。以下是一个完整的示例：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this example, the RSS feed uses a `description` while the Atom feed uses
    a `subtitle`. That's because Atom feeds don't provide for a feed-level description,
    but they do provide for a subtitle. If you provide a `description` in your `Feed`
    class, Django will not automatically put that into the `subtitle` element, because
    a subtitle and description are not necessarily the same thing. Instead, you should
    define a `subtitle` attribute.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，RSS feed 使用 `description`，而 Atom feed 使用 `subtitle`。这是因为 Atom feed 不提供
    feed 级别的描述，但它们提供了一个副标题。如果您在 `Feed` 类中提供了 `description`，Django 将不会自动将其放入 `subtitle`
    元素中，因为副标题和描述不一定是相同的。相反，您应该定义一个 `subtitle` 属性。
- en: 'In the above example, we simply set the Atom feed''s `subtitle` to the RSS
    feed''s `description`, because it''s quite short already. And the accompanying
    URLconf:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们将 Atom feed 的 `subtitle` 设置为 RSS feed 的 `description`，因为它已经相当短了。并且相应的
    URLconf：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For an example that illustrates all possible attributes and methods for a `Feed`
    class, see: `https://docs.djangoproject.com/en/1.8/ref/contrib/syndication/#feed-class-reference`'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 `Feed` 类的所有可能属性和方法的示例，请参见：`https://docs.djangoproject.com/en/1.8/ref/contrib/syndication/#feed-class-reference`
- en: The low-level framework
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 低级别框架
- en: 'Behind the scenes, the high-level RSS framework uses a lower-level framework
    for generating feeds'' XML. This framework lives in a single module: `django/utils/feedgenerator.py`.
    You use this framework on your own, for lower-level feed generation. You can also
    create custom feed generator subclasses for use with the `feed_type` `Feed` option.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，高级 RSS 框架使用较低级别的框架来生成 feed 的 XML。这个框架存在于一个单独的模块中：`django/utils/feedgenerator.py`。您可以自己使用这个框架进行较低级别的
    feed 生成。您还可以创建自定义 feed 生成器子类，以便与 `feed_type` `Feed` 选项一起使用。
- en: SyndicationFeed classes
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SyndicationFeed 类
- en: 'The `feedgenerator` module contains a base class:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`feedgenerator` 模块包含一个基类：'
- en: '`django.utils.feedgenerator.SyndicationFeed`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django.utils.feedgenerator.SyndicationFeed`'
- en: 'and several subclasses:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 和几个子类：
- en: '`django.utils.feedgenerator.RssUserland091Feed`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django.utils.feedgenerator.RssUserland091Feed`'
- en: '`django.utils.feedgenerator.Rss201rev2Feed`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django.utils.feedgenerator.Rss201rev2Feed`'
- en: '`django.utils.feedgenerator.Atom1Feed`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django.utils.feedgenerator.Atom1Feed`'
- en: 'Each of these three classes knows how to render a certain type of feed as XML.
    They share this interface:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个类都知道如何将某种类型的 feed 渲染为 XML。它们共享这个接口：
- en: SyndicationFeed.__init__()
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SyndicationFeed.__init__()
- en: 'Initialize the feed with the given dictionary of metadata, which applies to
    the entire feed. Required keyword arguments are:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用给定的元数据字典初始化 feed，该元数据适用于整个 feed。必需的关键字参数是：
- en: '`title`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`标题`'
- en: '`link`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`链接`'
- en: '`description`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`描述`'
- en: 'There''s also a bunch of other optional keywords:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一堆其他可选关键字：
- en: '`language`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`语言`'
- en: '`author_email`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`作者电子邮件`'
- en: '`author_name`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`作者名称`'
- en: '`author_link`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`作者链接`'
- en: '`subtitle`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`副标题`'
- en: '`categories`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`类别`'
- en: '`feed_url`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`feed_url`'
- en: '`feed_copyright`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`feed_copyright`'
- en: '`feed_guid`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`feed_guid`'
- en: '`ttl`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ttl`'
- en: Any extra keyword arguments you pass to `__init__` will be stored in `self.feed`
    for use with custom feed generators.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您传递给 `__init__` 的任何额外关键字参数都将存储在 `self.feed` 中，以便与自定义 feed 生成器一起使用。
- en: All parameters should be Unicode objects, except `categories`, which should
    be a sequence of Unicode objects.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 所有参数都应该是 Unicode 对象，除了 `categories`，它应该是 Unicode 对象的序列。
- en: SyndicationFeed.add_item()
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SyndicationFeed.add_item()
- en: Add an item to the feed with the given parameters.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用给定参数向 feed 添加一个项目。
- en: 'Required keyword arguments are:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 必需的关键字参数是：
- en: '`title`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`标题`'
- en: '`link`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`链接`'
- en: '`description`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`描述`'
- en: 'Optional keyword arguments are:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 可选关键字参数是：
- en: '`author_email`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`作者电子邮件`'
- en: '`author_name`'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`作者名称`'
- en: '`author_link`'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`作者链接`'
- en: '`pubdate`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pubdate`'
- en: '`comments`'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`评论`'
- en: '`unique_id`'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unique_id`'
- en: '`enclosure`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enclosure`'
- en: '`categories`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`类别`'
- en: '`item_copyright`'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`item_copyright`'
- en: '`ttl`'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ttl`'
- en: '`updateddate`'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updateddate`'
- en: 'Extra keyword arguments will be stored for custom feed generators. All parameters,
    if given, should be Unicode objects, except:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的关键字参数将被存储以供自定义 feed 生成器使用。所有参数，如果给定，都应该是 Unicode 对象，除了：
- en: '`pubdate` should be a Python `datetime` object.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pubdate` 应该是 Python `datetime` 对象。'
- en: '`updateddate` should be a Python `datetime` object.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updateddate` 应该是 Python `datetime` 对象。'
- en: '`enclosure` should be an instance of `django.utils.feedgenerator.Enclosure`.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enclosure` 应该是 `django.utils.feedgenerator.Enclosure` 的一个实例。'
- en: '`categories` should be a sequence of Unicode objects.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`categories` 应该是 Unicode 对象的序列。'
- en: SyndicationFeed.write()
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SyndicationFeed.write()
- en: Outputs the feed in the given encoding to outfile, which is a file-like object.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 将 feed 以给定编码输出到 outfile，这是一个类似文件的对象。
- en: SyndicationFeed.writeString()
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SyndicationFeed.writeString()
- en: 'Returns the feed as a string in the given encoding. For example, to create
    an Atom 1.0 feed and print it to standard output:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以给定编码的字符串形式返回 feed。例如，要创建 Atom 1.0 feed 并将其打印到标准输出：
- en: '[PRE20]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Custom feed generators
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义 feed 生成器
- en: If you need to produce a custom feed format, you've got a couple of options.
    If the feed format is totally custom, you'll want to subclass `SyndicationFeed`
    and completely replace the `write()` and `writeString()` methods. However, if
    the feed format is a spin-off of RSS or Atom (that is, GeoRSS, (link to website
    [http://georss.org/](http://georss.org/)), Apple's iTunes podcast format (link
    to website [http://www.apple.com/itunes/podcasts/specs.html](http://www.apple.com/itunes/podcasts/specs.html)),
    and so on.), you've got a better choice.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要生成自定义 feed 格式，您有几个选择。如果 feed 格式完全自定义，您将需要对 `SyndicationFeed` 进行子类化，并完全替换
    `write()` 和 `writeString()` 方法。但是，如果 feed 格式是 RSS 或 Atom 的一个衍生格式（即 GeoRSS，（链接到网站
    [http://georss.org/](http://georss.org/)），苹果的 iTunes podcast 格式（链接到网站 [http://www.apple.com/itunes/podcasts/specs.html](http://www.apple.com/itunes/podcasts/specs.html)）等），您有更好的选择。
- en: 'These types of feeds typically add extra elements and/or attributes to the
    underlying format, and there are a set of methods that `SyndicationFeed` calls
    to get these extra attributes. Thus, you can subclass the appropriate feed generator
    class (`Atom1Feed` or `Rss201rev2Feed`) and extend these call-backs. They are:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的 feed 通常会向底层格式添加额外的元素和/或属性，并且有一组方法，`SyndicationFeed` 调用这些额外的属性。因此，您可以对适当的
    feed 生成器类（`Atom1Feed` 或 `Rss201rev2Feed`）进行子类化，并扩展这些回调。它们是：
- en: SyndicationFeed.root_attributes(self, )
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SyndicationFeed.root_attributes(self, )
- en: Return a `dict` of attributes to add to the root feed element (`feed`/`channel`).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 返回要添加到根源元素（`feed`/`channel`）的属性字典。
- en: SyndicationFeed.add_root_elements(self, handler)
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SyndicationFeed.add_root_elements(self, handler)
- en: Callback to add elements inside the root feed element (`feed`/`channel`). `handler`
    is an `XMLGenerator` from Python's built-in SAX library; you'll call methods on
    it to add to the XML document in process.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 回调以在根源元素（`feed`/`channel`）内添加元素。`handler`是Python内置SAX库中的`XMLGenerator`；您将在其上调用方法以添加到正在处理的XML文档中。
- en: SyndicationFeed.item_attributes(self, item)
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SyndicationFeed.item_attributes(self, item)
- en: Return a `dict` of attributes to add to each item (`item`/`entry`) element.
    The argument, `item`, is a dictionary of all the data passed to `SyndicationFeed.add_item()`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 返回要添加到每个条目（`item`/`entry`）元素的属性字典。参数`item`是传递给`SyndicationFeed.add_item()`的所有数据的字典。
- en: SyndicationFeed.add_item_elements(self, handler, item)
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SyndicationFeed.add_item_elements(self, handler, item)
- en: Callback to add elements to each item (`item`/`entry`) element. `handler` and
    `item` are as above.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 回调以向每个条目（`item`/`entry`）元素添加元素。`handler`和`item`与上述相同。
- en: Note
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you override any of these methods, be sure to call the superclass methods
    since they add the required elements for each feed format.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您覆盖了这些方法中的任何一个，请确保调用超类方法，因为它们会为每个feed格式添加所需的元素。
- en: 'For example, you might start implementing an iTunes RSS feed generator like
    so:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以开始实现一个iTunes RSS feed生成器，如下所示：
- en: '[PRE21]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Obviously there's a lot more work to be done for a complete custom feed class,
    but the above example should demonstrate the basic idea.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，要创建一个完整的自定义feed类还有很多工作要做，但上面的例子应该演示了基本思想。
- en: The Sitemap framework
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 站点地图框架
- en: A **sitemap** is an XML file on your website that tells search engine indexers
    how frequently your pages change and how important certain pages are in relation
    to other pages on your site. This information helps search engines index your
    site. For more on sitemaps, see the sitemaps.org website.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**站点地图**是您网站上的一个XML文件，告诉搜索引擎索引器您的页面更改的频率以及与站点上其他页面的重要性。这些信息有助于搜索引擎索引您的站点。有关站点地图的更多信息，请参阅sitemaps.org网站。'
- en: The Django sitemap framework automates the creation of this XML file by letting
    you express this information in Python code. It works much like Django's syndication
    framework. To create a sitemap, just write a `Sitemap` class and point to it in
    your URLconf.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Django站点地图框架通过让您在Python代码中表达此信息来自动创建此XML文件。它的工作方式与Django的Syndication框架类似。要创建站点地图，只需编写一个`Sitemap`类并在URLconf中指向它。
- en: Installation
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装
- en: 'To install the sitemap app, follow these steps:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装站点地图应用，请按照以下步骤进行：
- en: Add `"django.contrib.sitemaps"` to your `INSTALLED_APPS` setting.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`"django.contrib.sitemaps"`添加到您的`INSTALLED_APPS`设置中。
- en: Make sure your `TEMPLATES` setting contains a `DjangoTemplates` backend whose
    `APP_DIRS` options is set to True. It's in there by default, so you'll only need
    to change this if you've changed that setting.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您的`TEMPLATES`设置包含一个`DjangoTemplates`后端，其`APP_DIRS`选项设置为True。默认情况下就在那里，所以只有在更改了该设置时才需要更改这一点。
- en: Make sure you've installed the sites framework.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您已安装了站点框架。
- en: Initialization
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化
- en: 'To activate sitemap generation on your Django site, add this line to your URLconf:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Django站点上激活站点地图生成，请将此行添加到您的URLconf中：
- en: '[PRE22]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This tells Django to build a sitemap when a client accesses `/sitemap.xml`.
    The name of the sitemap file is not important, but the location is. Search engines
    will only index links in your sitemap for the current URL level and below. For
    instance, if `sitemap.xml` lives in your root directory, it may reference any
    URL in your site. However, if your sitemap lives at `/content/sitemap.xml`, it
    may only reference URLs that begin with `/content/`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Django在客户端访问`/sitemap.xml`时构建站点地图。站点地图文件的名称并不重要，但位置很重要。搜索引擎只会索引站点地图中当前URL级别及以下的链接。例如，如果`sitemap.xml`位于根目录中，它可以引用站点中的任何URL。但是，如果您的站点地图位于`/content/sitemap.xml`，它只能引用以`/content/`开头的URL。
- en: 'The sitemap view takes an extra, required argument: `{''sitemaps'': sitemaps}`.
    `sitemaps` should be a dictionary that maps a short section label (for example,
    `blog` or `news`) to its `Sitemap` class (for example, `BlogSitemap` or `NewsSitemap`).
    It may also map to an instance of a `Sitemap` class (for example, `BlogSitemap(some_var)`).'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '站点地图视图需要一个额外的必需参数：`{''sitemaps'': sitemaps}`。`sitemaps`应该是一个将短部分标签（例如`blog`或`news`）映射到其`Sitemap`类（例如`BlogSitemap`或`NewsSitemap`）的字典。它也可以映射到`Sitemap`类的实例（例如`BlogSitemap(some_var)`）。'
- en: Sitemap classes
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 站点地图类
- en: A `Sitemap` class is a simple Python class that represents a section of entries
    in your sitemap. For example, one `Sitemap` class could represent all the entries
    of your weblog, while another could represent all of the events in your events
    calendar.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sitemap`类是一个简单的Python类，表示站点地图中的条目部分。例如，一个`Sitemap`类可以表示您博客的所有条目，而另一个可以表示您事件日历中的所有事件。'
- en: In the simplest case, all these sections get lumped together into one `sitemap.xml`,
    but it's also possible to use the framework to generate a sitemap index that references
    individual sitemap files, one per section. (See Creating a sitemap index below.)
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，所有这些部分都被合并到一个`sitemap.xml`中，但也可以使用框架生成引用各个站点地图文件的站点地图索引，每个部分一个文件。（请参阅下面的创建站点地图索引。）
- en: '`Sitemap` classes must subclass `django.contrib.sitemaps.Sitemap`. They can
    live anywhere in your codebase.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sitemap`类必须是`django.contrib.sitemaps.Sitemap`的子类。它们可以存在于代码库中的任何位置。'
- en: A simple example
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的例子
- en: 'Let''s assume you have a blog system, with an `Entry` model, and you want your
    sitemap to include all the links to your individual blog entries. Here''s how
    your sitemap class might look:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个博客系统，其中有一个`Entry`模型，并且您希望您的站点地图包括到您个人博客条目的所有链接。以下是您的站点地图类可能如何看起来：
- en: '[PRE23]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Note:**'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：**'
- en: '`changefreq` and `priority` are class attributes corresponding to `<changefreq>`
    and `<priority>` elements, respectively. They can be made callable as functions,
    as `lastmod` was in the example.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`changefreq`和`priority`是对应于`<changefreq>`和`<priority>`元素的类属性。它们可以作为函数调用，就像上面的`lastmod`一样。'
- en: '`items()` is simply a method that returns a list of objects. The objects returned
    will get passed to any callable methods corresponding to a sitemap property (`location`,
    `lastmod`, `changefreq` and `priority`).'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`items()`只是返回对象列表的方法。返回的对象将传递给与站点地图属性（`location`，`lastmod`，`changefreq`和`priority`）对应的任何可调用方法。'
- en: '`lastmod` should return a Python `datetime` object.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lastmod`应返回Python `datetime`对象。'
- en: There is no `location` method in this example, but you can provide it in order
    to specify the URL for your object. By default, `location()` calls `get_absolute_url()`
    on each object and returns the result.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此示例中没有`location`方法，但您可以提供它以指定对象的URL。默认情况下，`location()`调用每个对象上的`get_absolute_url()`并返回结果。
- en: Sitemap class reference
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 站点地图类参考
- en: 'A `Sitemap` class can define the following methods/attributes:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sitemap`类可以定义以下方法/属性：'
- en: items
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: items
- en: '**Required.** A method that returns a list of objects. The framework doesn''t
    care what *type* of objects they are; all that matters is that these objects get
    passed to the `location()`, `lastmod()`, `changefreq()` and `priority()` methods.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**必需。**返回对象列表的方法。框架不关心它们是什么*类型*的对象；重要的是这些对象传递给`location()`，`lastmod()`，`changefreq()`和`priority()`方法。'
- en: location
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位置
- en: '**Optional.** Either a method or attribute. If it''s a method, it should return
    the absolute path for a given object as returned by `items()`. If it''s an attribute,
    its value should be a string representing an absolute path to use for every object
    returned by `items()`.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**可选。**可以是方法或属性。如果是方法，它应该返回`items()`返回的给定对象的绝对路径。如果是属性，其值应该是表示`items()`返回的每个对象使用的绝对路径的字符串。'
- en: 'In both cases, absolute path means a URL that doesn''t include the protocol
    or domain. Examples:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，绝对路径表示不包括协议或域的URL。示例：
- en: 'Good: `''/foo/bar/''`'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 好的：`'/foo/bar/'`
- en: 'Bad: `''example.com/foo/bar/''`'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不好：`'example.com/foo/bar/'`
- en: 'Bad: `''http://example.com/foo/bar/''`'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不好：`'http://example.com/foo/bar/'`
- en: If `location` isn't provided, the framework will call the `get_absolute_url()`
    method on each object as returned by `items()`. To specify a protocol other than
    `http`, use `protocol`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未提供`location`，框架将调用`items()`返回的每个对象上的`get_absolute_url()`方法。要指定除`http`之外的协议，请使用`protocol`。
- en: lastmod
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: lastmod
- en: '**Optional.** Either a method or attribute. If it''s a method, it should take
    one argument-an object as returned by `items()`-and return that object''s last-modified
    date/time, as a Python `datetime.datetime` object.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**可选。**可以是方法或属性。如果是方法，它应该接受一个参数-`items()`返回的对象-并返回该对象的最后修改日期/时间，作为Python `datetime.datetime`对象。'
- en: If it's an attribute, its value should be a Python `datetime.datetime` object
    representing the last-modified date/time for *every* object returned by `items()`.
    If all items in a sitemap have a `lastmod`, the sitemap generated by `views.sitemap()`
    will have a `Last-Modified` header equal to the latest `lastmod`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它是一个属性，其值应该是一个Python `datetime.datetime`对象，表示`items()`返回的*每个*对象的最后修改日期/时间。如果站点地图中的所有项目都有`lastmod`，则`views.sitemap()`生成的站点地图将具有等于最新`lastmod`的`Last-Modified`标头。
- en: You can activate the `ConditionalGetMiddleware` to make Django respond appropriately
    to requests with an `If-Modified-Since` header which will prevent sending the
    sitemap if it hasn't changed.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以激活`ConditionalGetMiddleware`，使Django对具有`If-Modified-Since`标头的请求做出适当响应，这将防止在站点地图未更改时发送站点地图。
- en: changefreq
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: changefreq
- en: '**Optional.** Either a method or attribute. If it''s a method, it should take
    one argument-an object as returned by `items()`-and return that object''s change
    frequency, as a Python string. If it''s an attribute, its value should be a string
    representing the change frequency of every object returned by `items()`. Possible
    values for `changefreq`, whether you use a method or attribute, are:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**可选。**可以是方法或属性。如果是方法，它应该接受一个参数-`items()`返回的对象-并返回该对象的更改频率，作为Python字符串。如果是属性，其值应该是表示`items()`返回的每个对象的更改频率的字符串。无论您使用方法还是属性，`changefreq`的可能值是：'
- en: '`''always''`'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''always''`'
- en: '`''hourly''`'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''hourly''`'
- en: '`''daily''`'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''daily''`'
- en: '`''weekly''`'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''weekly''`'
- en: '`''monthly''`'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''monthly''`'
- en: '`''yearly''`'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''yearly''`'
- en: '`''never''`'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''never''`'
- en: priority
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: priority
- en: '**Optional.** Either a method or attribute. If it''s a method, it should take
    one argument-an object as returned by `items()`-and return that object''s priority,
    as either a string or float.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**可选。**可以是方法或属性。如果是方法，它应该接受一个参数-`items()`返回的对象-并返回该对象的优先级，作为字符串或浮点数。'
- en: 'If it''s an attribute, its value should be either a string or float representing
    the priority of every object returned by `items()`. Example values for `priority`:
    `0.4`, `1.0`. The default priority of a page is `0.5`. See the sitemaps.org documentation
    for more.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它是一个属性，其值应该是一个字符串或浮点数，表示`items()`返回的每个对象的优先级。`priority`的示例值：`0.4`，`1.0`。页面的默认优先级为`0.5`。有关更多信息，请参阅sitemaps.org文档。
- en: protocol
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协议
- en: '**Optional.** This attribute defines the protocol (`http` or `https`) of the
    URLs in the sitemap. If it isn''t set, the protocol with which the sitemap was
    requested is used. If the sitemap is built outside the context of a request, the
    default is `http`.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**可选。**此属性定义站点地图中URL的协议（`http`或`https`）。如果未设置，将使用请求站点地图的协议。如果站点地图是在请求的上下文之外构建的，则默认值为`http`。'
- en: i18n
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: i18n
- en: '**Optional.** A Boolean attribute that defines if the URLs of this sitemap
    should be generated using all of your `LANGUAGES`. The default is `False`.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**可选。**一个布尔属性，定义此站点地图的URL是否应使用所有`LANGUAGES`生成。默认值为`False`。'
- en: Shortcuts
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快捷方式
- en: The sitemap framework provides a convenience class for a common case-`django.contrib.syndication.GenericSitemap`
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 网站地图框架为常见情况提供了一个方便的类-`django.contrib.syndication.GenericSitemap`
- en: The `django.contrib.sitemaps.GenericSitemap` class allows you to create a sitemap
    by passing it a dictionary which has to contain at least a `queryset` entry. This
    queryset will be used to generate the items of the sitemap. It may also have a
    `date_field` entry that specifies a date field for objects retrieved from the
    `queryset`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`django.contrib.sitemaps.GenericSitemap`类允许您通过向其传递至少包含`queryset`条目的字典来创建站点地图。此查询集将用于生成站点地图的项目。它还可以具有指定从`queryset`检索的对象的日期字段的`date_field`条目。'
- en: This will be used for the `lastmod` attribute in the generated sitemap. You
    may also pass `priority` and `changefreq` keyword arguments to the `GenericSitemap`
    constructor to specify these attributes for all URLs.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这将用于生成的站点地图中的`lastmod`属性。您还可以将`priority`和`changefreq`关键字参数传递给`GenericSitemap`构造函数，以指定所有URL的这些属性。
- en: Example
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 例子
- en: 'Here''s an example of a URLconf using `GenericSitemap`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`GenericSitemap`的URLconf示例：
- en: '[PRE24]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Sitemap for static views
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态视图的站点地图
- en: 'Often you want the search engine crawlers to index views which are neither
    object detail pages nor flat pages. The solution is to explicitly list URL names
    for these views in `items` and call `reverse()` in the `location` method of the
    sitemap. For example:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您希望搜索引擎爬虫索引既不是对象详细页面也不是平面页面的视图。解决方案是在`sitemap`的`items`中显式列出这些视图的URL名称，并在`sitemap`的`location`方法中调用`reverse()`。例如：
- en: '[PRE25]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Creating a sitemap index
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建站点地图索引
- en: 'The sitemap framework also has the ability to create a sitemap index that references
    individual sitemap files, one per each section defined in your `sitemaps` dictionary.
    The only differences in usage are:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 站点地图框架还具有创建引用各自`sitemaps`字典中定义的每个部分的单独站点地图文件的站点地图索引的功能。使用的唯一区别是：
- en: 'You use two views in your URLconf: `django.contrib.sitemaps.views.index()`
    and `django.contrib.sitemaps.views.sitemap()`.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您在URLconf中使用了两个视图：`django.contrib.sitemaps.views.index()`和`django.contrib.sitemaps.views.sitemap()`。
- en: The `django.contrib.sitemaps.views.sitemap()` view should take a `section` keyword
    argument.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django.contrib.sitemaps.views.sitemap()`视图应该接受一个`section`关键字参数。'
- en: 'Here''s what the relevant URLconf lines would look like for the example above:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述示例的相关URLconf行的样子：
- en: '[PRE26]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This will automatically generate a `sitemap.xml` file that references both `sitemap-flatpages.xml`
    and `sitemap-blog.xml`. The `Sitemap` classes and the `sitemaps` dictionary don't
    change at all.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这将自动生成一个`sitemap.xml`文件，其中引用了`sitemap-flatpages.xml`和`sitemap-blog.xml`。`Sitemap`类和`sitemaps`字典完全不会改变。
- en: 'You should create an index file if one of your sitemaps has more than 50,000
    URLs. In this case, Django will automatically paginate the sitemap, and the index
    will reflect that. If you''re not using the vanilla sitemap view-for example,
    if it''s wrapped with a caching decorator-you must name your sitemap view and
    pass `sitemap_url_name` to the index view:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的站点地图中有超过50,000个URL，则应创建一个索引文件。在这种情况下，Django将自动对站点地图进行分页，并且索引将反映这一点。如果您没有使用原始站点地图视图-例如，如果它被缓存装饰器包装-您必须为您的站点地图视图命名，并将`sitemap_url_name`传递给索引视图：
- en: '[PRE27]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Template customization
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板自定义
- en: 'If you wish to use a different template for each sitemap or sitemap index available
    on your site, you may specify it by passing a `template_name` parameter to the
    `sitemap` and `index` views via the URLconf:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望在站点上可用的每个站点地图或站点地图索引使用不同的模板，您可以通过在URLconf中向`sitemap`和`index`视图传递`template_name`参数来指定它：
- en: '[PRE28]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Context variables
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文变量
- en: When customizing the templates for the `index()` and `sitemap()` views, you
    can rely on the following context variables.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在自定义`index()`和`sitemap()`视图的模板时，您可以依赖以下上下文变量。
- en: Index
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 索引
- en: The variable `sitemaps` is a list of absolute URLs to each of the sitemaps.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`sitemaps`是每个站点地图的绝对URL的列表。
- en: Sitemap
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 站点地图
- en: 'The variable `urlset` is a list of URLs that should appear in the sitemap.
    Each URL exposes attributes as defined in the `Sitemap` class:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`urlset`是应该出现在站点地图中的URL列表。每个URL都公开了`Sitemap`类中定义的属性：
- en: '`changefreq`'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`changefreq`'
- en: '`item`'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`item`'
- en: '`lastmod`'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lastmod`'
- en: '`location`'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`位置`'
- en: '`priority`'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`priority`'
- en: 'The `item` attribute has been added for each URL to allow more flexible customization
    of the templates, such as Google news sitemaps. Assuming Sitemap''s `items()`
    would return a list of items with `publication_data` and a `tags` field something
    like this would generate a Google compatible sitemap:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 已为每个URL添加了`item`属性，以允许对模板进行更灵活的自定义，例如Google新闻站点地图。假设Sitemap的`items()`将返回一个具有`publication_data`和`tags`字段的项目列表，类似这样将生成一个与Google兼容的站点地图：
- en: '[PRE29]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Pinging google
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ping google
- en: 'You may want to ping Google when your sitemap changes, to let it know to reindex
    your site. The sitemaps framework provides a function to do just that:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的站点地图发生更改时，您可能希望向Google发送ping，以便让它知道重新索引您的站点。站点地图框架提供了一个函数来实现这一点：
- en: django.contrib.syndication.ping_google()
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: django.contrib.syndication.ping_google()
- en: '`ping_google()` takes an optional argument, `sitemap_url`, which should be
    the absolute path to your site''s sitemap (for example, `''/sitemap.xml''`). If
    this argument isn''t provided, `ping_google()` will attempt to figure out your
    sitemap by performing a reverse looking in your URLconf. `ping_google()` raises
    the exception `django.contrib.sitemaps.SitemapNotFound` if it cannot determine
    your sitemap URL.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`ping_google()`接受一个可选参数`sitemap_url`，它应该是站点地图的绝对路径（例如`''/sitemap.xml''`）。如果未提供此参数，`ping_google()`将尝试通过在URLconf中执行反向查找来确定您的站点地图。如果无法确定您的站点地图URL，`ping_google()`会引发异常`django.contrib.sitemaps.SitemapNotFound`。'
- en: 'One useful way to call `ping_google()` is from a model''s `save()` method:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 从模型的`save()`方法中调用`ping_google()`的一个有用的方法是：
- en: '[PRE30]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: A more efficient solution, however, would be to call `ping_google()` from a
    cron script, or some other scheduled task. The function makes an HTTP request
    to Google's servers, so you may not want to introduce that network overhead each
    time you call `save()`.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，更有效的解决方案是从cron脚本或其他计划任务中调用`ping_google()`。该函数会向Google的服务器发出HTTP请求，因此您可能不希望在每次调用`save()`时引入网络开销。
- en: Pinging Google via manage.py
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过manage.py向Google发送ping
- en: 'Once the sitemaps application is added to your project, you may also ping Google
    using the `ping_google` management command:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦站点地图应用程序添加到您的项目中，您还可以使用`ping_google`管理命令来ping Google：
- en: '[PRE31]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Register with Google first!** The `ping_google()` command only works if you
    have registered your site with Google webmaster Tools.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '**首先向Google注册！**只有在您已经在Google网站管理员工具中注册了您的站点时，`ping_google()`命令才能起作用。'
- en: What's next?
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: Next, we'll continue to dig deeper into the built-in tools Django gives you
    by taking a closer look at the Django session framework.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将继续深入研究Django提供的内置工具，通过更仔细地查看Django会话框架。
