- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Profiling
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析
- en: It is quite common that written code doesn't behave perfectly after being tested
    with real data. Other than bugs, we can find the problem that the performance
    of the code is not adequate. Perhaps some requests are taking too much time, or
    perhaps the usage of memory is too high.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用真实数据测试后，编写的代码可能并不完美。除了错误之外，我们还可以发现代码的性能不足的问题。可能某些请求花费了太多时间，或者可能是内存使用过高。
- en: In those cases, it's difficult to know exactly what the key elements are, that
    are taking the most time or memory. While it's possible to try to follow the logic,
    normally once the code is released, the bottlenecks will be at points that are
    almost impossible to know beforehand.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在那些情况下，很难确切知道哪些关键元素花费了最多时间或内存。虽然尝试跟踪逻辑是可能的，但通常一旦代码发布，瓶颈将出现在几乎无法事先知晓的点。
- en: To get information on what exactly is going on and follow the code flow, we
    can use profilers to dynamically analyze the code and better understand how the
    code is executed, in particular, where most time is spent. This can lead to adjustments
    and improvements affecting the most significant elements of the code, driven by
    data, instead of vague speculation.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解确切发生的情况并跟踪代码流，我们可以使用分析器来动态分析代码，更好地理解代码的执行情况，特别是大多数时间花在了哪里。这可能导致对代码最关键部分的调整和改进，这些改进是由数据驱动的，而不是模糊的推测。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Profiling basics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析基础
- en: Types of profilers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析器的类型
- en: Profiling code for time
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对代码进行时间分析
- en: Partial profiling
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分分析
- en: Memory profiling
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存分析
- en: First, we will take a look at the basic principles of profiling.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将探讨分析的基本原则。
- en: Profiling basics
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析基础
- en: Profiling is a dynamic analysis that instruments code to understand how it runs.
    This information is extracted and compiled in a way that can be used to get a
    better knowledge of a particular behavior based on a real case, as the code is
    running as usual. This information can be used to improve the code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 分析是一种动态分析，它通过向代码添加工具来理解其运行情况。这些信息被提取并编译成可以用于基于实际案例更好地了解特定行为的方式，因为代码是正常运行的。这些信息可以用来改进代码。
- en: Certain static analysis tools, as opposed to dynamic, can provide insight into
    aspects of the code. For example, they can be used to detect if certain code is
    dead code, meaning it's not called anywhere in the whole code. Or, they can detect
    some bugs, like the usage of variables that haven't been defined before, like
    when having a typo. But they don't work with the specifics of code that's actually
    being run. Profiling will bring specific data based on the use case instrumented
    and will return much more information on the flow of the code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 与动态分析相比，某些静态分析工具可以提供对代码某些方面的洞察。例如，它们可以用来检测某些代码是否是死代码，这意味着它在整个代码中没有被调用过。或者，它们可以检测一些错误，比如使用未定义的变量，比如在打字错误时。但它们不适用于实际运行的代码的特定细节。分析将基于被仪器化的用例提供具体数据，并将返回关于代码流的更多信息。
- en: The normal application of profiling is to improve the performance of the code
    under analysis. By understanding how it executes in practice, it sheds light on
    the dynamics of the code modules and parts that could be causing problems. Then,
    actions can be taken in those specific areas.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 常规的代码分析应用是为了提升被分析代码的性能。通过理解其在实际中的执行情况，可以揭示代码模块和可能引起问题的部分的动态。然后，可以在这些特定区域采取行动。
- en: 'Performance can be understood in two ways: either *time performance* (how long
    code takes to execute) or *memory performance* (how much memory the code takes
    to execute). Both can be bottlenecks. Some code may take too long to execute or
    use a lot of memory, which may limit the hardware where it''s executed.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 性能可以从两个方面来理解：要么是*时间性能*（代码执行所需的时间）要么是*内存性能*（代码执行所需的内存）。两者都可能成为瓶颈。某些代码可能执行时间过长或使用大量内存，这可能会限制其运行的硬件。
- en: We will focus more on time performance in this chapter, as it is typically a
    bigger problem, but we will also explain how to use a memory profiler.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更关注时间性能，因为它通常是一个更大的问题，但我们也会解释如何使用内存分析器。
- en: A common case in software development is that you don't really know what your
    code is going to do until it gets executed. Clauses to cover corner cases that
    appear rare may execute much more than expected, and software works differently
    when there are big arrays, as some algorithms may not be adequate.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，一个常见的案例是，直到代码执行之前，你并不真正知道你的代码将要做什么。覆盖那些出现频率较低的边缘情况的条款可能会执行比预期更多的操作，而且当存在大数组时，软件的工作方式也会不同，因为某些算法可能不够充分。
- en: The problem is that doing that analysis before having the system running is
    incredibly difficult, and at most times, futile, as the problematic pieces of
    code will very likely be completely unexpected.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于在系统运行之前进行这种分析非常困难，而且在大多数时候，是徒劳的，因为问题代码很可能完全出乎意料。
- en: 'Programmers waste enormous amounts of time thinking about, or worrying about,
    the speed of noncritical parts of their programs, and these attempts at efficiency
    actually have a strong negative impact when debugging and maintenance are considered.
    We should forget about small efficiencies, say about 97% of the time: **premature
    optimization is the root of all evil**. Yet we should not pass up our opportunities
    in that critical 3%.'
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 程序员会浪费大量的时间思考或担心他们程序中非关键部分的运行速度，而这些试图提高效率的努力在考虑调试和维护时实际上会产生强烈的负面影响。我们应该忘记小的效率，比如说97%的时间：**过早优化是万恶之源**。然而，我们不应该错过那关键的3%的机会。
- en: ''
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Donald Knuth – Structured Programing with GOTO Statements - 1974.
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 邓肯·克努特 – 使用GOTO语句进行结构化编程 - 1974年。
- en: Profiling gives us the ideal tool to *not* prematurely optimize, but to optimize
    according to real, tangible data. The idea is that you cannot optimize what you
    cannot measure. The profiler measures so it can be acted upon.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 分析提供了我们理想的工具来*不*过早优化，而是根据真实、具体的数据进行优化。其理念是你不能优化你不能衡量的东西。分析器测量，以便可以采取行动。
- en: The famous quote above is sometimes reduced to "premature optimization is the
    root of all evil," which is a bit reductionist and doesn't carry the nuance. Sometimes
    it's important to design elements with care and it's possible to plan in advance.
    As good as profiling (or other techniques) may be, they can only go so far. But
    it's important to understand, on most occasions, it's better to take the simple
    approach, as performance will be good enough, and it will be possible to improve
    it later in the few cases when it's not.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的著名引言有时被简化为“过早优化是万恶之源”，这有点过于简化，没有体现出细微差别。有时，精心设计元素很重要，并且可以提前规划。尽管分析（或其他技术）可能很好，但它们只能走这么远。但重要的是要理解，在大多数情况下，采取简单的方法更好，因为性能已经足够好，而且可以在少数情况下进行改进。
- en: Profiling can be achieved in different ways, each with its pros and cons.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 分析可以通过不同的方式实现，每种方式都有其优缺点。
- en: Types of profilers
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析器的类型
- en: 'There are two main kinds of time profilers:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 主要有两种时间分析器：
- en: '**Deterministic profilers**, through a process of tracing. A deterministic
    profiler instruments the code and records each individual command. This makes
    deterministic profilers very detailed, as they can follow up the code on each
    step, but at the same time, the code is executed slower than without the instrumentation.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确定性分析器**，通过跟踪过程。确定性分析器对代码进行仪器化并记录每个单独的命令。这使得确定性分析器非常详细，因为它们可以跟踪每一步的代码，但与此同时，代码的执行速度比没有仪器化时要慢。'
- en: Deterministic profilers are not great to execute continuously. Instead, they
    can be activated in specific situations, like while running specific tests offline,
    to find out problems.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定性分析器不适合持续执行。相反，它们可以在特定情况下被激活，比如在运行特定的离线测试时，以找出问题。
- en: '**Statistical profiles**, through sampling. This kind of profiler, instead
    of instrumenting the code and detecting each operation, awakes at certain intervals
    and takes a sample of the current code execution stack. If this process is done
    for long enough, it captures the general execution of the program.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**统计配置文件**，通过采样。这种类型的分析器，而不是通过代码的仪器化和检测每个操作，而是在特定间隔内唤醒并获取当前代码执行堆栈的样本。如果这个过程持续足够长的时间，它将捕获程序的总体执行情况。'
- en: Taking a sample of the stack is similar to taking a picture. Imagine a train
    or subway hall where people are moving across to go from one platform to another.
    Sampling is analogous to taking pictures at periodic intervals, for example, once
    every 5 minutes. Sure, it's not possible to get exactly who comes from one platform
    and goes to another, but after a whole day, it will provide good enough information
    on how many people have been around and what platforms are the most popular.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对堆栈进行采样类似于拍照。想象一下火车站或地铁站，人们正在穿越以从一个站台到另一个站台。采样类似于每隔一定时间拍照，例如每5分钟一次。当然，不可能精确地知道谁从哪个站台来，到哪个站台去，但经过一整天，它将提供足够的信息，了解有多少人经过以及哪些站台最受欢迎。
- en: While they don't give as detailed information as deterministic profiles, statistical
    profilers are much more lightweight and don't consume many resources. They can
    be enabled to constantly monitor live systems without interfering with their performance.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它们提供的信息不如确定性分析器详细，但统计分析器更加轻量级，并且不消耗许多资源。它们可以启用以持续监控实时系统，而不会干扰其性能。
- en: Statistical profilers only make sense on systems that are under relative load,
    as in a system that is not stressed, they'll show that most time is spent waiting.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 统计分析器仅在相对负载的系统上才有意义，因为在系统未受压力的情况下，它们会显示大部分时间都在等待。
- en: Statistical profilers can be internal, if the sampling is done directly on the
    interpreter, or even external if it's a different program that is taking the samples.
    An external profiler has the advantage that, even if there's any problem with
    the sampling process, it won't interfere with the program being sampled.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果采样是在解释器上直接进行的，统计分析器可以是内部的；如果是一个不同的程序在采样，它甚至可以是外部的。外部分析器的优势在于，即使采样过程中有任何问题，也不会干扰被采样的程序。
- en: Both profilers can be seen as complementary. Statistical profilers are good
    tools for understanding the most-visited parts of the code and where the system,
    aggregated, is spending time. They live in the live system, where the real case
    usages determine the behavior of the system.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种分析器可以看作是互补的。统计分析器是理解代码中最常访问部分以及系统总体上花费时间的好工具。它们存在于实时系统中，其中实际的案例使用决定了系统的行为。
- en: The deterministic profilers are tools for analyzing specific use cases in the
    petri dish of the developer's laptop, where a specific task that is having some
    problem can be dissected and analyzed carefully, to be improved.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 确定性分析器是分析开发者笔记本电脑中Petri Dish中特定用例的工具，其中某个有问题的特定任务可以被仔细分解和分析，以进行改进。
- en: In some respects, statistical profilers are analogous to metrics and deterministic
    profilers to logs. One displays the aggregated elements and the other the specific
    elements. Deterministic profilers, contrary to logs, are not ideal tools for using
    in live systems without care, though.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些方面，统计分析器类似于指标，而确定性分析器类似于日志。一个显示聚合元素，另一个显示特定元素。与日志不同，确定性分析器并不是在实时系统中使用时的理想工具，尽管如此。
- en: Typically, code will present *hotspots*, slow parts of it that get executed
    often. Finding the specific parts to focus attention on and then act on them is
    a great way to improve the overall speed.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，代码会呈现*热点*，即经常执行的慢速部分。找到需要关注的特定部分并对其采取行动是提高整体速度的好方法。
- en: These hotspots can be revealed by profiling, either by checking the *global*
    hotspots using a statistical profiler or the *specific* hotspots for a task with
    a deterministic profiler. The first will display the specific parts of the code
    that are most used in general, which allows us to understand the pieces that get
    hit more often and take the most time in aggregate. The deterministic profiler
    can show, for a specific task, how long it takes for each line of code, and determine
    what are the slow elements.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些热点可以通过分析来揭示，无论是通过使用统计分析器检查*全局*热点，还是使用确定性分析器针对特定任务检查*特定*热点。前者将显示代码中最常使用的特定部分，这使我们能够了解哪些部分被频繁调用并且总体上花费了最多的时间。确定性分析器可以显示对于特定任务，每一行代码需要多长时间，并确定哪些是慢速元素。
- en: We won't look at statistical profilers as they require systems that are under
    load and they are difficult to create in a test that's fit for the scope of this
    book. You can check `py-spy` ([https://pypi.org/project/py-spy/](https://pypi.org/project/py-spy/))
    or `pyinstrument` ([https://pypi.org/project/pyinstrument/](https://pypi.org/project/pyinstrument/)).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会查看统计分析器，因为它们需要负载下的系统，并且很难在适合本书范围的测试中创建。您可以检查`py-spy`([https://pypi.org/project/py-spy/](https://pypi.org/project/py-spy/))或`pyinstrument`([https://pypi.org/project/pyinstrument/](https://pypi.org/project/pyinstrument/))。
- en: Another kind of profiler is the memory profiler. A memory profiler records when
    memory is increased and decreased, tracking the usage of memory. Profiling memory
    is typically used to find out memory leaks, which are rare for a Python program,
    but they can happen.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种分析器是内存分析器。内存分析器记录内存增加和减少的时间，跟踪内存的使用情况。通常使用内存分析来找出内存泄漏，尽管在Python程序中这种情况很少见，但它们确实可能发生。
- en: Python has a garbage collector that releases memory automatically when an object
    is not referenced anymore. This happens without having to take any action, so
    compared with programs with manual memory assignment, like C/C++, the memory management
    is easier to handle. The garbage collection mechanism used for Python is called
    *reference counting*, and it frees memory immediately once a memory object is
    not used by anyone, as compared with other kinds of garbage collectors that wait.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个垃圾收集器，当对象不再被引用时，它会自动释放内存。这不需要采取任何行动，因此与像C/C++这样的手动内存分配程序相比，内存管理更容易处理。Python使用的垃圾收集机制称为*引用计数*，一旦内存对象不再被任何人使用，它就会立即释放内存，与其他类型的垃圾收集器相比，后者会等待。
- en: 'In the case of Python, memory leaks can be created by three main use cases,
    from more likely to least:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python的情况下，内存泄漏可以通过以下三种主要使用场景来创建，从更可能到最少：
- en: Some objects are still referenced, even if they are not used anymore. This can
    typically happen if there are long-lived objects that keep small elements in big
    elements, like lists of dictionaries when they are added and not removed.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些对象即使不再使用，仍然被引用。这通常发生在存在长期存在的对象，它们将小元素保存在大元素中时，例如，当列表或字典被添加而不是删除时。
- en: An internal C extension is not managing the memory correctly. This may require
    further investigation with specific C profiling tools, which is out of scope for
    this book.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部C扩展没有正确管理内存。这可能需要使用特定的C分析工具进行进一步调查，但这本书的范围不包括这一点。
- en: 'Complex reference cycles. A reference cycle is a group of objects that reference
    each other, e.g. object A references B and object B references A. While Python
    has algorithms to detect them and release the memory nonetheless, there''s the
    small possibility that the garbage collector is disabled or any other bug problem.
    You can see more information on the Python garbage collector here: [https://docs.python.org/3/library/gc.html](https://docs.python.org/3/library/gc.html).'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂的引用循环。引用循环是一组相互引用的对象，例如，对象A引用B，对象B引用A。虽然Python有算法可以检测它们并释放内存，但垃圾收集器被禁用或存在其他错误的可能性很小。您可以在Python垃圾收集器这里了解更多信息：[https://docs.python.org/3/library/gc.html](https://docs.python.org/3/library/gc.html)。
- en: The most likely situation for extra usage of memory is an algorithm that uses
    a lot of memory, and detecting when the memory is allocated can be achieved with
    the help of a memory profiler.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最可能额外使用内存的情况是使用大量内存的算法，而检测内存分配的时间可以通过内存分析器来实现。
- en: Memory profiling is typically more complicated and takes more effort than time
    profiling.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 内存分析通常比时间分析更复杂，需要更多的努力。
- en: Let's introduce some code and profile it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们引入一些代码并对其进行分析。
- en: Profiling code for time
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析代码以计时
- en: We will start by creating a short program that will calculate and display all
    prime numbers up to a particular number. Prime numbers are numbers that are only
    divisible by themselves and one.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个简短的程序，该程序将计算并显示所有小于特定数字的素数。素数是只能被自己和1整除的数。
- en: 'We will start by taking a naïve approach first:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先尝试一种简单的方法：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code will take every number from 2 to the number under test (without including
    it), and check whether the number is divisible. If at any point it is divisible,
    the number is not a prime number.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将取从2到待测试数字（不包括它本身）的每个数字，并检查该数字是否可被整除。如果在任何点上它可被整除，则该数字不是素数。
- en: To calculate all the way from 1 to 5,000, to verify that we are not making any
    mistakes, we will include the first prime numbers lower than 100 and compare them.
    This is on GitHub, available as `primes_1.py` at [https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/primes_1.py](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/primes_1.py).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从 1 到 5,000 进行计算，以验证我们没有犯任何错误，我们将包括小于 100 的第一个素数，并进行比较。这是在 GitHub 上，作为 `primes_1.py`
    可用，[https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/primes_1.py](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/primes_1.py)。
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The calculation of prime numbers is performed by creating a list of all numbers
    (from 1 to `NUM_PRIMES_UP_TO`) and verifying each of them. Only values that return
    `True` will be kept:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 素数的计算是通过创建一个包含所有数字（从 1 到 `NUM_PRIMES_UP_TO`）的列表，并验证每个数字来完成的。只有返回 `True` 的值才会被保留：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The next line `assert`s that the first prime numbers are the same as the ones
    defined in the `PRIMES` list, which is a hardcoded list of the first primes lower
    than 100.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个 `assert` 行断言第一个素数与在 `PRIMES` 列表中定义的相同，这是一个硬编码的包含小于 100 的第一个素数的列表。
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The primes are finally printed. Let''s execute the program, timing its execution:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后打印出素数。让我们执行程序，计时其执行时间：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: From here, we will start analyzing the code to see what is going on internally
    and see if we can improve it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们将开始分析代码，看看内部发生了什么，并看看我们是否可以改进它。
- en: Using the built-in cProfile module
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用内置的 cProfile 模块
- en: 'The easiest, faster way of profiling a module is to directly use the included
    `cProfile` module in Python. This module is part of the standard library and can
    be called as part of the external call, like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 分析模块最简单、最快的方法是直接使用 Python 中包含的 `cProfile` 模块。此模块是标准库的一部分，可以作为外部调用的一部分进行调用，如下所示：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note this called the script normally, but also presented the profile analysis.
    The table shows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里正常调用脚本，但也展示了分析结果。表格显示：
- en: '`ncalls`: Number of times each element has been called'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ncalls`：每个元素被调用的次数'
- en: '`tottime`: Total time spent on each element, not including sub calls'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tottime`：每个元素上花费的总时间，不包括子调用'
- en: '`percall`: Time per call on each element (not including sub calls)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`percall`：每个元素上的调用时间（不包括子调用）'
- en: '`cumtime`: Cumulative time – the total time spent on each element, including
    subcalls'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cumtime`：累计时间 – 每个元素上花费的总时间，包括子调用'
- en: '`percall`: Time per call on an element, including subcalls'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`percall`：元素上的调用时间，包括子调用'
- en: '`filename:lineno`: Each of the elements under analysis'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filename:lineno`：分析下的每个元素'
- en: In this case, the time is clearly seen to be spent in the `check_if_prime` function,
    which is called 4,999 times, and it takes the practical totality of the time (744
    milliseconds compared with a total of 762).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，时间明显花在了 `check_if_prime` 函数上，该函数被调用了 4,999 次，占用了几乎全部的时间（744 毫秒，与总共 762
    毫秒相比）。
- en: While not easy to see here due to the fact that it's a small script, `cProfile`
    increases the time it takes to execute the code. There's an equivalent module
    called `profile` that's a direct replacement but implemented in pure Python, as
    opposed to a C extension. Please generally use `cProfile` as it's faster, but
    `profile` can be useful at certain moments, like when trying to extend the functionality.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个小脚本，这里不容易看到，但 `cProfile` 会增加代码的执行时间。有一个名为 `profile` 的等效模块，它是直接替换的，但用纯
    Python 实现，而不是 C 扩展。请一般使用 `cProfile`，因为它更快，但 `profile` 在某些时刻可能很有用，比如尝试扩展功能时。
- en: 'While this text table can be enough for simple scripts like this one, the output
    can be presented as a file and then displayed with other tools:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个文本表格对于像这样的简单脚本已经足够，但输出可以作为一个文件呈现，然后使用其他工具显示：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now we need to install the visualizer SnakeViz, installing it through `pip`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要安装可视化工具 SnakeViz，通过 `pip` 安装：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, open the file with `snakeviz`, which will open a browser with the
    information:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 `snakeviz` 打开文件，它将打开一个浏览器并显示信息：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![Graphical user interface, application'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![图形用户界面，应用程序'
- en: Description automatically generated](img/B17580_14_01.png)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_14_01.png)
- en: 'Figure 14.1: Graphical representation of the profiling information. The full
    page is too big to fit here and has been cropped purposefully to show some of
    the info.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1：分析信息的图形表示。整个页面太大，无法全部显示，因此有意裁剪以展示部分信息。
- en: 'This graph is interactive, and we can click and hover on different elements
    to get more information:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此图是交互式的，我们可以点击并悬停在不同的元素上以获取更多信息：
- en: '![Graphical user interface, application'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图形用户界面，应用程序'
- en: Description automatically generated](img/B17580_14_02.png)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成描述](img/B17580_14_02.png)
- en: 'Figure 14.2: Checking the information about check_if_prime. The full page is
    too big to fit here and has been cropped purposefully to show some of the info.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2：检查`check_if_prime`的信息。整页内容太大，无法在这里显示，因此有意裁剪以显示一些信息。
- en: We can confirm here that the bulk of the time is spent on `check_if_prime`,
    but we don't get information about what's inside it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以确认大部分时间都花在了`check_if_prime`上，但我们没有得到关于其内部的信息。
- en: This is because `cProfile` only has function granularity. You'll see how long
    each function call takes, but not a lower resolution. For this specifically simple
    function, this may not be enough.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`cProfile`只有函数粒度。你会看到每个函数调用花费了多长时间，但没有更低的分辨率。对于这个特别简单的函数，这可能不够。
- en: Do not underestimate this tool. The code example presented is purposefully simple
    to avoid spending too much time explaining its use. Most of the time, localizing
    the function that's taking most of the time is good enough to visually inspect
    it and discover what's taking too long. Keep in mind that, in most practical situations,
    the time spent will be on external calls like DB accesses, remote requests, etc.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 不要低估这个工具。提供的代码示例故意很简单，以避免花费太多时间解释其使用方法。大多数情况下，定位占用最多时间的函数就足够了，以便进行视觉检查并发现哪些操作耗时过长。请记住，在大多数实际情况下，耗时将花在外部调用上，如数据库访问、远程请求等。
- en: We will see how to use a profiler that has a higher resolution, analyzing each
    line of code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何使用具有更高分辨率的分析器，分析每一行代码。
- en: Line profiler
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行分析器
- en: To analyze the `check_if_prime` function, we need to first install the module
    `line_profiler`
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要分析`check_if_prime`函数，我们首先需要安装模块`line_profiler`。
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After it's installed, we will make a small change in the code, and save it as
    `primes_2.py`. We will add the decorator `@profile` for the `check_if_prime` function,
    to indicate to the line profiler to look into it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们将在代码中进行一些小的更改，并将其保存为`primes_2.py`。我们将为`check_if_prime`函数添加装饰器`@profile`，以指示行分析器查看它。
- en: Keep in mind that you should only profile sections of the code where you want
    to know more in this way. If all the code was profiled in this way, it would take
    a lot of time to analyze.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您应该只分析您想了解更多信息的代码部分。如果所有代码都以这种方式进行分析，分析将花费很多时间。
- en: The code will be like this (the rest will be unaffected). You can check the
    whole file on GitHub at [https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/primes_2.py](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/primes_2.py).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将如下所示（其余部分不受影响）。您可以在GitHub上查看整个文件[https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/primes_2.py](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/primes_2.py)。
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Execute the code now with `kernprof`, which will be installed after the installation
    of `line_profiler`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用`kernprof`执行代码，该工具将在安装`line_profiler`后安装。
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note the execution took noticeably longer – 12 seconds compared with subsecond
    execution without the profiler enabled. Now we can take a look at the results
    with this command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到执行时间明显更长——启用分析器后为12秒，而没有启用分析器时为亚秒级执行。现在我们可以使用以下命令查看结果：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we can start analyzing the specifics of the algorithm used. The main problem
    seems to be that we are doing a lot of comparisons. Both lines 11 and 12 are being
    called too many times, though the time per hit is short. We need to find a way
    to reduce the number of times they're being called.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以开始分析所使用的算法的具体细节。主要问题似乎是我们做了很多比较。第11行和第12行都被调用得太多次，尽管每次调用的时间很短。我们需要找到一种方法来减少它们被调用的次数。
- en: 'The first one is easy. Once we find a `False` result, we don''t need to wait
    anymore; we can return directly, instead of continuing with the loop. The code
    will be like this (stored in `primes_3.py`, available at [https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/primes_3.py](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/primes_3.py)):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个很简单。一旦找到`False`结果，我们就不需要再等待了；我们可以直接返回，而不是继续循环。代码将如下所示（存储在`primes_3.py`中，可在[https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/primes_3.py](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/primes_3.py)找到）：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We see how time has gone down by a big factor (2 seconds compared with the 12
    seconds before, as measured by `time`) and we see the great reduction in time
    spent on comparisons (3,749,127 microseconds before, and then 473,788 microseconds),
    mainly due to the fact there are 10 times fewer comparisons, 1,563,868 compared
    with 12,487,503.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到时间已经大幅减少（与之前用`time`测量的12秒相比，减少了2秒），我们看到比较所花费的时间大幅减少（之前是3,749,127微秒，然后是473,788微秒），这主要是因为比较次数减少了10倍，从1,563,868次减少到12,487,503次。
- en: We can also improve and further reduce the number of comparisons by limiting
    the size of the loop.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过限制循环的大小来进一步减少比较次数。
- en: Right now, the loop will try to divide the source number between all the numbers
    up to itself. For example, for 19, we try these numbers (as 19 is a prime number,
    it's not divisible by any except for itself).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，循环将尝试将源数字除以所有小于或等于自身的数字。例如，对于19，我们尝试这些数字（因为19是一个质数，它只能被自身整除）。
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Trying all these numbers is not necessary. At least, we can skip half of them,
    as no number will be divisible by a number higher than half itself. For example,
    19 divided by 10 or higher is less than 2.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试所有这些数字并不是必要的。至少，我们可以跳过其中的一半，因为没有任何数字能被大于它一半的数字整除。例如，19除以10或更高的数字小于2。
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Furthermore, any factor of a number will be lower than its square root. This
    can be explained as follows: If a number is the factor of two or more numbers,
    the highest they may be is the square root of the whole number. So we check only
    the numbers up to the square root (rounded down):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一个数字的任何因子都将小于它的平方根。这可以这样解释：如果一个数字是两个或更多数字的因子，它们可能的最大值是整个数字的平方根。所以我们只检查到平方根（向下取整）的数字：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: But we can reduce it even further. We only need to check the odd numbers after
    2, as any even number will be divisible by 2\. So, in this case, we even reduce
    it further.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们可以进一步减少它。我们只需要检查2之后的奇数，因为任何偶数都能被2整除。所以，在这种情况下，我们甚至进一步减少了它。
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To apply all of this, we need to tweak the code again and store it in `primes_4.py`,available
    on GitHub at [https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/primes_4.py](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/primes_4.py):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应用所有这些，我们需要再次调整代码，并将其存储在`primes_4.py`中，可在GitHub上找到：[https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/primes_4.py](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/primes_4.py)：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The code always checks for divisibility by 2, unless the number is 2\. This
    is to keep returning 2 correctly as a prime.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 代码总是检查除以2的余数，除非数字是2。这是为了正确地返回2作为质数。
- en: Then, we create a range of numbers that starts from 3 (we already tested 2)
    and continue until the square root of the number. We use the `math` module to
    perform the action and to floor the number to the nearest lower integer. The `range`
    function requires a `+1` of this number, as it doesn't include the defined number.
    Finally, the range step on 2 integers at time so that all the numbers are odd,
    since we started with 3.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个从3开始的数字范围（因为我们已经测试了2），直到该数字的平方根。我们使用`math`模块来执行操作并将数字向下取整到最接近的整数。`range`函数需要这个数字的`+1`，因为它不包括定义的数字。最后，范围步长为2个整数，这样所有的数字都是奇数，因为我们从3开始。
- en: For example, to test a number like 1,000, this is the equivalent code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了测试像1,000这样的数字，这是等效的代码。
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that 31 is returned as we added the `+1`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于我们添加了`+1`，31被返回。
- en: Let's profile the code again.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次分析代码。
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We see another big increase in performance. Let's see the line profile.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到性能有了显著提升。让我们看看线形图。
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We've reduced the number of loop iterations drastically to 22,228, from 1.5
    million in `primes_3.py` and over 12 million in `primes_2.py`, when we started
    the line profiling. That's some serious improvement!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将循环迭代次数大幅减少到22,228次，从`primes_3.py`中的150万次和`primes_2.py`中的超过1200万次，当我们开始线形分析时。这是一项重大的改进！
- en: You can try to do the test to increase `NUM_PRIMES_UP_TO` in `primes_2.py` and
    `primes_4.py` and compare them. The change will be clearly perceptible.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试在`primes_2.py`和`primes_4.py`中增加`NUM_PRIMES_UP_TO`的值，并比较它们。变化将非常明显。
- en: The line approach should be used only for small sections. In general, we've
    seen how `cProfile` can be more useful, as it's easier to run and gives information.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 线形方法应该只用于小部分。一般来说，我们已经看到`cProfile`可以更有用，因为它更容易运行，并且提供信息。
- en: Previous sections have assumed that we are able to run the whole script and
    then receive the results, but that may not be correct. Let's take a look at how
    to profile in sections of the program, for example, when a request is received.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的章节假设我们能够运行整个脚本并接收结果，但这可能并不正确。让我们看看如何在程序的各个部分进行分析，例如，当接收到请求时。
- en: Partial profiling
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分分析
- en: In many scenarios, profilers will be useful in environments where the system
    is in operation and we cannot wait until the process finishes before obtaining
    profiling information. Typical scenarios are web requests.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多场景中，分析器在系统运行的环境中非常有用，我们不能等待整个过程完成后再获取分析信息。典型的场景是网络请求。
- en: If we want to analyze a particular web request, we may need to start a web server,
    produce a single request, and stop the process to obtain the result. This doesn't
    work as well as you may think due to some problems that we will see.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要分析特定的网络请求，我们可能需要启动一个网络服务器，生成一个单独的请求，然后停止过程以获取结果。由于我们将看到的一些问题，这并不像您想象的那么有效。
- en: But first, let's create some code to explain this situation.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们编写一些代码来解释这种情况。
- en: Example web server returning prime numbers
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例网络服务器返回质数
- en: We will use the final version of the function `check_if_prime` and create a
    web service that returns all the primes up to the number specified in the path
    of the request. The code will be the following, and it's fully available in the
    `server.py` file on GitHub at [https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/server.py](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/server.py).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用函数 `check_if_prime` 的最终版本，并创建一个返回请求路径中指定数字的所有质数的网络服务。代码如下，并且可以在GitHub上的
    `server.py` 文件中完全找到，网址为 [https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/server.py](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/server.py)。
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The code is better understood if you start from the end. The final block creates
    a web server using the base `HTTPServer` definition in the Python module `http.server`.
    Previously, we created the class `MyServer`, which defines what to do if there's
    a `GET` request in the `do_GET` method.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从结尾开始，代码更容易理解。最后的代码块使用Python模块 `http.server` 中的基本 `HTTPServer` 定义创建了一个网络服务器。之前，我们创建了
    `MyServer` 类，该类在 `do_GET` 方法中定义了如果发生 `GET` 请求应该做什么。
- en: The `do_GET` method returns an HTML response with the result calculated by `get_result`.
    It adds all the required headers and formats the body in HTML.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`do_GET` 方法返回一个包含由 `get_result` 计算的结果的HTML响应。它添加所有必要的头信息，并以HTML格式格式化正文。'
- en: The interesting bits of the process happen in the next functions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 过程中有趣的部分发生在接下来的函数中。
- en: '`get_result` is the root one. It first calls `extract_param` to get a number,
    up to which to calculate the threshold number for us to calculate primes up to.
    If correct, then that''s passed to `prime_numbers_up_to`.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_result` 是根函数。它首先调用 `extract_param` 来获取一个数字，这是我们用来计算质数的阈值。如果正确，则将其传递给 `prime_numbers_up_to`。'
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The function `extract_params` will extract a number from the URL path. It first
    removes any `/` character, and then tries to convert it into an integer and checks
    the integer is positive. For any errors, it returns `None`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `extract_params` 会从URL路径中提取一个数字。它首先移除任何 `/` 字符，然后尝试将其转换为整数并检查该整数是否为正。对于任何错误，它返回
    `None`。
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The function `prime_numbers_up_to`, finally, calculates the prime numbers up
    to the number passed. This is similar to the code that we saw earlier in the chapter.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `prime_numbers_up_to` 最终计算的是传入数字的所有质数。这与我们在本章前面看到的代码类似。
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Finally, `check_if_prime`, which we covered extensively earlier in the chapter,
    is the same as it was at `primes_4.py`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在本章前面广泛讨论的 `check_if_prime` 函数与 `primes_4.py` 中的相同。
- en: 'The process can be started with:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下方式启动此过程：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: And then tested by going to `http://localhost:8000/500` to try to get prime
    numbers up to 500.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过访问 `http://localhost:8000/500` 来测试，尝试获取500以内的所有质数。
- en: '![Graphical user interface, text'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![图形用户界面，文本'
- en: Description automatically generated](img/B17580_14_03.png)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_14_03.png)
- en: 'Figure 14.3: The interface displaying all primes up to 500'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3：显示所有500以内质数的界面
- en: As you can see, we have an understandable output. Let's move on to profiling
    the process we used to get it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们得到了一个可理解的输出。让我们继续分析我们用来获取它的过程。
- en: Profiling the whole process
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析整个过程
- en: We can profile the whole process by starting it under `cProfile` and then capturing
    its output with. We start it like this, make a single request to `http://localhost:8000/500`,
    and check the results.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`cProfile`下启动整个过程来分析整个流程，然后捕获其输出。我们这样启动，向`http://localhost:8000/500`发送单个请求，并检查结果。
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We have stored the results in the file `server.prof`. This file can then be
    analyzed as before, using `snakeviz`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将结果存储在文件`server.prof`中。然后可以使用`snakeviz`像以前一样分析此文件。
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Which displays the following diagram:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了以下图示：
- en: '![Graphical user interface, application'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图形用户界面，应用程序'
- en: Description automatically generated](img/B17580_14_04.png)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_14_04.png)
- en: 'Figure 14.4: Diagram of the full profile. The full page is too big to fit here
    and has been cropped purposefully to show some of the info.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4：完整配置文件的图示。整个页面太大，无法在这里显示，因此有意裁剪以显示一些信息。
- en: As you can see, the diagram shows that for the vast majority of the test duration,
    the code was waiting for a new request, and internally doing a poll action. This
    is part of the server code and not our code.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，该图显示在测试的大部分时间内，代码正在等待新的请求，并在内部执行轮询操作。这是服务器代码，而不是我们的代码。
- en: 'To find the code that we care about, we can manually search in the long list
    below for `get_result`, which is the root of the interesting bits of our code.
    Be sure to select `Cutoff: None` to display all the functions.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '要找到我们关心的代码，我们可以在下面的长列表中手动搜索`get_result`，这是我们代码中有趣部分的根源。务必选择`Cutoff: None`以显示所有函数。'
- en: Once selected, the diagram will display from there onward. Be sure to scroll
    up to see the new diagram.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 选择后，图示将从那里开始显示。务必向上滚动以查看新的图示。
- en: '![Chart'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![图表'
- en: Description automatically generated with low confidence](img/B17580_14_05.png)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的低置信度描述](img/B17580_14_05.png)
- en: 'Figure 14.5: The diagram showing from get_result. The full page is too big
    to fit here and has been cropped purposefully to show some of the info.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.5：从`get_result`开始的图示。整个页面太大，无法在这里显示，因此有意裁剪以显示一些信息。
- en: Here, you can see more of the general structure of the code execution. You can
    see that most of the time is spent on the multiple `check_if_prime` calls, which
    comprise the bulk of `prime_numbers_up_to` and the list comprehension included
    in it, and very little time is spent on `extract_params`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到代码执行的更多一般结构。您可以看到，大部分时间都花在了多次`check_if_prime`调用上，这些调用构成了`prime_numbers_up_to`的大部分，以及其中包含的列表推导，而花在`extract_params`上的时间非常少。
- en: 'But this approach has some problems:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种方法存在一些问题：
- en: First of all, we need to go a full cycle between starting and stopping a process.
    This is cumbersome to do for requests.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们需要在启动和停止进程之间完成一个完整的周期。对于请求来说，这样做很麻烦。
- en: Everything that happens in the cycle is included. That adds noise to the analysis.
    Fortunately, we knew that the interesting part was in `get_result`, but that may
    not be evident. This case also uses a minimal structure but adding that in the
    case of a complex framework like Django can lead to a lot of .
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 周期中发生的所有事情都被包括在内。这给分析增加了噪音。幸运的是，我们知道有趣的部分在`get_result`中，但这可能并不明显。此案例也使用了一个最小结构，但在像Django这样的复杂框架中添加它可能会导致很多问题。
- en: If we process two different requests, they will be added into the same file,
    again mixing the results.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们处理两个不同的请求，它们将被添加到同一个文件中，再次混合结果。
- en: These problems can be solved by applying the profiler to only the part that
    is of interest and producing a new file for each request.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题可以通过仅对感兴趣的部分应用分析器并为每个请求生成新文件来解决。
- en: Generating a profile file per request
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个请求生成一个配置文件
- en: To be able to generate a different file with information per individual request,
    we need to create a decorator for easy access. This will profile and produce an
    independent file.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够为每个单独的请求生成包含信息的不同文件，我们需要创建一个易于访问的装饰器。这将进行性能分析和生成独立的文件。
- en: In the file `server_profile_by_request.py`, we get the same code as in `server.py`,
    but adding the following decorator.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件`server_profile_by_request.py`中，我们得到与`server.py`中相同的代码，但添加了以下装饰器。
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The decorator defines a `wrapper` function that replaces the original function.
    We use the `wraps` decorator to keep the original name and docstring.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器定义了一个`wrapper`函数，它替换了原始函数。我们使用`wraps`装饰器来保留原始名称和文档字符串。
- en: This is just a standard decorator process. A decorator function in Python is
    one that returns a function that then replaces the original one. As you can see,
    the original function `func` is still called inside the wrapper that replaces
    it, but it adds extra functionality.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个标准的装饰器过程。Python中的装饰器函数是返回一个函数，然后替换原始函数。如您所见，原始函数`func`仍然在替换它的包装器内部被调用，但它增加了额外的功能。
- en: Inside, we start a profiler and run the function under it using the `runcall`
    function. This line is the core of it – using the profiler generated, we run the
    original function `func` with its parameters and store its returned value.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，我们启动一个性能分析器，并使用`runcall`函数在其下运行函数。这一行是核心——使用生成的性能分析器，我们运行原始函数`func`及其参数，并存储其返回值。
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: After that, we generate a new file that includes the current time and dump the
    stats in it with the `.dump_stats` call.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们生成一个包含当前时间的新文件，并通过`.dump_stats`调用将统计信息存入其中。
- en: We also decorate the `get_result` function, so we start our profiling there.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还装饰了`get_result`函数，因此我们的性能分析从这里开始。
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The full code is available in the file `server_profile_by_request.py`, available
    on GitHub at [https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/server_profile_by_request.py](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/server_profile_by_request.py).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 完整代码位于文件`server_profile_by_request.py`中，可在GitHub上找到：[https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/server_profile_by_request.py](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/server_profile_by_request.py)。
- en: Let's start the server now and make some calls through the browser, one to `http://localhost:8000/500`
    and another to `http://localhost:8000/800`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们启动服务器并通过浏览器进行一些调用，一个调用到`http://localhost:8000/500`，另一个调用到`http://localhost:8000/800`。
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can see how new files are created:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到新文件的创建过程：
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'These files can be displayed using `snakeviz`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件可以使用`snakeviz`显示：
- en: '[PRE34]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '![Graphical user interface, chart'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '![图形用户界面，图表'
- en: Description automatically generated](img/B17580_14_06.png)
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_14_06.png)
- en: 'Figure 14.6: The profile information of a single request. The full page is
    too big to fit here and has been cropped purposefully to show some of the info.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.6：单个请求的性能信息。整个页面太大，无法全部显示，因此有意裁剪以展示部分信息。
- en: Each file contains only the information from `get_result` onwards, which gets
    information only up to a point. Even more so, each file displays information only
    for a specific request, so it can be profiled individually, with a high level
    of detail.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件只包含从`get_result`开始的信息，该信息只获取到某个点。更重要的是，每个文件只显示特定请求的信息，因此可以单独进行性能分析，具有很高的详细程度。
- en: The code can be adapted to adapt the filename more specifically to include details
    like call parameters, which can be useful. Another interesting possible adaptation
    is to create a random sample, so only 1 in X calls produces profiled code. This
    can help reduce the overhead of profiling and allow you to completely profile
    some requests.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可以调整以更具体地包含诸如调用参数之类的详细信息，这可能很有用。另一个有趣的可能的调整是创建一个随机样本，这样只有X次调用中的1次会产生性能分析代码。这有助于减少性能分析的开销，并允许您完全分析一些请求。
- en: This is different from a statistical profiler, as it will still completely profile
    some requests, instead of detecting what's going on at a particular time. This
    can help follow the flow of what happens for particular requests.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这与统计性能分析器不同，因为它仍然会完全分析一些请求，而不是检测特定时间发生的事情。这有助于跟踪特定请求的流程。
- en: Next, we'll see how to perform memory profiling.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何进行内存分析。
- en: Memory profiling
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存分析
- en: Sometimes, applications use too much memory. The worst-case scenario is that
    they use more and more memory as time goes by, normally due to what's called a
    memory leak, maintaining memory that is no longer used, due to some mistake in
    the coding. Other problems can also include the fact that the usage of memory
    may be improved, as it's a limited resource.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，应用程序会使用过多的内存。最坏的情况是，随着时间的推移，它们会使用越来越多的内存，通常是由于所谓的内存泄漏，由于编码中的某些错误，保持不再使用的内存。其他问题也可能包括内存使用可能得到改进的事实，因为它是有限的资源。
- en: To profile memory and analyze what the objects are that use the memory, we need
    first to create some example code. We will generate enough Leonardo numbers.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分析内存使用情况以及确定占用内存的对象，我们首先需要创建一些示例代码。我们将生成足够的莱昂纳多数。
- en: 'Leonardo numbers are numbers that follow a sequence defined as the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 伦纳德数是遵循以下定义的序列的数：
- en: The first Leonardo number is one
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个伦纳德数是1
- en: The second Leonardo number is also one
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个伦纳德数也是1
- en: Any other Leonardo number is the two previous Leonardo numbers plus one
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何其他的伦纳德数都是前两个伦纳德数加1
- en: Leonardo numbers are similar to Fibonacci numbers. They are actually related
    to them. We use them instead of Fibonacci to show more variety. Numbers are fun!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 伦纳德数与斐波那契数相似。实际上，它们是相关的。我们用它们代替斐波那契数来展示更多的多样性。数字很有趣！
- en: We present the first 35 Leonardo numbers by creating a recursive function and
    store it in `leonardo_1.py`, available on GitHub at [https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/leonardo_1.py](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/leonardo_1.py).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建一个递归函数并存储在`leonardo_1.py`文件中，来展示前35个伦纳德数，该文件可在GitHub上找到，链接为[https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/leonardo_1.py](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/leonardo_1.py)。
- en: '[PRE35]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You can run the code and see it takes progressively longer.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以运行代码，并看到它逐渐变慢。
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: To speed up the process, we see that it's possible to use memorization techniques,
    which means to store the results and use them instead of calculating them all
    the time.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加快过程，我们发现可以使用记忆化技术，这意味着存储结果并使用它们而不是每次都进行计算。
- en: We change the code like this, creating the `leonardo_2.py` file (available on
    GitHub at [https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/leonardo_2.py](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/leonardo_2.py)).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像这样更改代码，创建`leonardo_2.py`文件（可在GitHub上找到，链接为[https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/leonardo_2.py](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/leonardo_2.py)）。
- en: '[PRE37]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This uses a global dictionary, `CACHE`, to store all Leonardo numbers, speeding
    up the process. Note that we increased the number of numbers to calculate from
    `35` to `35000`, a thousand times more. The process runs quite quickly.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了一个全局字典`CACHE`来存储所有的伦纳德数，从而加快了过程。注意，我们将要计算的数字数量从`35`增加到`35000`，增加了千倍。这个过程运行得相当快。
- en: '[PRE38]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Let's take a look now at memory usage.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看内存使用情况。
- en: Using memory_profiler
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用内存分析器
- en: Now that we have our application storing information, let's use a profiler to
    show where the memory is stored.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们的应用程序开始存储信息了，让我们使用一个分析器来显示内存存储的位置。
- en: We need to install the package `memory_profiler`. This package is similar to
    `line_profiler`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要安装`memory_profiler`这个包。这个包与`line_profiler`类似。
- en: '[PRE39]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We can now add a `@profile` decorator in the `leonardo` function (stored in
    `leonardo_2p.py`, on GitHub at [https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/leonardo_2p.py](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/leonardo_2p.py)),
    and run it using the `memory_profiler` module. You'll notice that it runs slower
    this time, but after the usual result, it displays a table.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在`leonardo`函数中添加一个`@profile`装饰器（该函数存储在`leonardo_2p.py`文件中，可在GitHub上找到，链接为[https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/leonardo_2p.py](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/leonardo_2p.py)），并使用`memory_profiler`模块运行它。你会注意到这次运行速度变慢了，但在常规结果之后，它会显示一个表格。
- en: '[PRE40]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This table shows first the memory usage, and the increment or decrement, as
    well as how many times each line appears.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表格首先显示了内存使用情况，以及增加或减少的量，以及每一行出现的次数。
- en: 'You can see the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到以下内容：
- en: Line 9 gets executed only a few times. When it does, the amount of memory is
    around `38 MiB`, which will be the minimum memory used by the program.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第9行只执行几次。当它执行时，内存量大约为`38 MiB`，这将是最小内存使用量。
- en: The total memory used is almost `105 MiB`.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总共使用的内存接近`105 MiB`。
- en: The whole memory increase is localized in lines 12 and 13, when we create a
    new Leonardo number and when we store it in the `CACHE` dictionary. Note how we
    are never releasing memory here.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个内存增加都集中在第12行和第13行，当我们创建一个新的伦纳德数并将其存储在`CACHE`字典中时。注意我们在这里从未释放内存。
- en: We don't really need to keep all the previous Leonardo numbers in memory at
    all times, and we can try a different approach to keep only a few.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不真的需要在任何时候都保留所有之前的伦纳德数在内存中，我们可以尝试一种不同的方法来只保留少数几个。
- en: Memory optimization
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存优化
- en: 'We create the file `leonardo_3.py` with the following code, available on GitHub
    at [https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/leonardo_3.py](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/leonardo_3.py):'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `leonardo_3.py` 的文件，其中包含以下代码，可在 GitHub 上找到：[https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/leonardo_3.py](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/leonardo_3.py)：
- en: '[PRE41]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Note we keep the `@profile` decorator to run the memory profiler again. Most
    of the code is the same, but we added the following extra block:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们保留了 `@profile` 装饰器以再次运行内存分析器。大部分代码都是相同的，但我们添加了以下额外的代码块：
- en: '[PRE42]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This code will keep the number of elements in the `CACHE` dictionary within
    a limit. When the limit is reached, it will remove the first element returned
    by `CACHE.keys()`, which will be the oldest.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将 `CACHE` 字典中的元素数量保持在一定范围内。当达到限制时，它将删除 `CACHE.keys()` 返回的第一个元素，这将是最旧的元素。
- en: Since Python 3.6, all Python dictionaries are ordered, so they'll return their
    keys in the order they have been input previously. We take advantage of that for
    this. Note we need to convert the result from `CACHE.keys()` (a `dict_keys` object)
    to a list to allow getting the first element.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 Python 3.6 版本以来，所有的 Python 字典都是有序的，因此它们会按照之前输入的顺序返回它们的键。我们正是利用这一点。注意，我们需要将
    `CACHE.keys()`（一个 `dict_keys` 对象）的结果转换为列表，以便获取第一个元素。
- en: The dictionary won't be able to grow. Let's now try to run it and see the results
    of the profiling.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 字典无法增长。现在让我们尝试运行它，看看分析的结果。
- en: '[PRE43]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this case, we see how the memory remains stable at around the `38 MiB`, that
    we see is the minimum. In this case, note how there are no increments or decrements.
    Really what happens here is that increments and decrements are too small to be
    noticed. Because they cancel each other, the report is close to zero.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们看到内存稳定在约 `38 MiB` 左右，这是我们看到的最低值。在这种情况下，请注意没有增加或减少。实际上，这里发生的是增加和减少的幅度太小，以至于无法察觉。因为它们相互抵消，所以报告接近零。
- en: The `memory-profiler` module is also able to perform more actions, including
    showing the usage of memory based on time and plotting it, so you can see memory
    increasing or decreasing over time. Take a look at its full documentation at [https://pypi.org/project/memory-profiler/](https://pypi.org/project/memory-profiler/).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`memory-profiler` 模块还能够执行更多操作，包括根据时间显示内存使用情况并绘制图表，因此您可以查看内存随时间增加或减少。请查看其完整文档：[https://pypi.org/project/memory-profiler/](https://pypi.org/project/memory-profiler/)。'
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we described what profiling is and when it's useful to apply
    it. We described that profiling is a dynamic tool that allows you to understand
    how code runs. This information is useful in understanding the flow in a practice
    situation and being able to optimize the code with that information. Code can
    be optimized normally to execute faster, but other alternatives are open, like
    using fewer resources (normally memory), reducing external accesses, etc.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们描述了什么是分析以及何时应用它是有用的。我们描述了分析是一个动态工具，它允许您了解代码是如何运行的。这些信息在理解实际情境中的流程以及能够利用这些信息优化代码时非常有用。代码通常可以通过优化来执行得更快，但还有其他替代方案，例如使用更少的资源（通常是内存）、减少外部访问等。
- en: 'We described the main types of profilers: deterministic profilers, statistical
    profilers, and memory profilers. The first two are mostly oriented toward improving
    the performance of code and memory profilers analyze the memory used by the code
    in execution. Deterministic profilers instrument the code to detail the flow of
    the code as it''s executed. Statistical profilers sample the code at periodic
    times to provide a general view of the parts of the code that are executed more
    often.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们描述了主要的分析器类型：确定性分析器、统计性分析器和内存分析器。前两者主要面向提高代码性能，而内存分析器则分析代码在执行过程中使用的内存。确定性分析器通过在代码执行时详细记录代码的流程来对代码进行测量。统计性分析器在固定时间间隔对代码进行采样，以提供代码中执行频率较高的部分的总体视图。
- en: We then showed how to profile the code using deterministic profilers, presenting
    an example. We analyzed it first with the built-in module `cProfile`, which gives
    a function resolution. We saw how to use graphical tools to show the results.
    To dig deeper, we used the third-party module `line-profiler`, which goes through
    each of the code lines. Once the flow of the code is understood, it is optimized
    to greatly reduce its execution time.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了如何使用确定性分析器来分析代码，并给出了一个示例。我们首先使用内置模块`cProfile`进行分析，它提供了函数解析。我们看到了如何使用图形工具来展示结果。为了更深入地分析，我们使用了第三方模块`line-profiler`，它会遍历每一行代码。一旦理解了代码的流程，就可以对其进行优化，以大大减少其执行时间。
- en: The next step was to see how to profile a process intended to keep running,
    like a web server. We showed the problems with trying to profile the whole application
    in these cases and described how we can profile each individual request instead
    for clarity.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是了解如何分析一个打算持续运行的过程，比如一个网络服务器。我们展示了在这种情况下尝试分析整个应用程序的问题，并描述了如何为了清晰起见，对每个单独的请求进行分析。
- en: These techniques are also applicable to other situations like conditional profiling,
    profiling in only certain situations, like at certain times or one of each 100
    requests.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术也适用于其他情况，如条件分析、仅在特定情况下分析，例如在特定时间或每100个请求中的一个。
- en: Finally, we also presented an example to profile memory and see how it's used
    by using the module `memory-profiler`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还提供了一个示例来分析内存，并使用`memory-profiler`模块查看其使用情况。
- en: In the next chapter, we will learn more details about how to find and fix problems
    in code, including in complex situations, through debugging techniques.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习更多关于如何通过调试技术找到和修复代码中的问题的细节，包括在复杂情况下的处理。
