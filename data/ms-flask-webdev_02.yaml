- en: Creating Models with SQLAlchemy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SQLAlchemy 创建模型
- en: As we saw in the last chapter, models are a means of abstracting and providing
    a common interface to access data. In most web applications, data is stored and
    retrieved from a **relational database management system** (**RDBMS**), which
    is a database that holds data in a tabular format with rows and columns and is
    able to implement a relational model with data across tables. Some examples include
    MySQL, Postgres, Oracle, and MSSQL.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中看到的，模型是抽象数据和提供访问数据的通用接口的一种方式。在大多数 Web 应用程序中，数据是从 **关系数据库管理系统**（**RDBMS**）存储和检索的，这是一个以行和列的表格格式存储数据的数据库，能够实现跨表的数据关系模型。一些例子包括
    MySQL、Postgres、Oracle 和 MSSQL。
- en: In order to create models on top of our database, we will use a Python package
    named **SQLAlchemy**. SQLAlchemy is a database API at its lowest level, and performs
    **object relational mapping** at its highest level. An **ORM** (**object relational
    mapper**) is a tool that allows developers to store and retrieve data using object-oriented
    approaches and solve object-relational mismatches—a set of conceptual and technical
    difficulties that are often encountered when a relational database management
    system is being used by a program that is written in an object-oriented programming
    language. Relational and object-oriented models are so different that additional
    code and functionalities are required to make them work together efficiently. This
    creates a virtual object database and converts data between the large number of
    types in databases into the mix of types and objects in Python. Also, a programming
    language, such as Python, allows you to have different objects that hold references
    to each other, and to get and set their attributes. An ORM, such as SQLAlchemy,
    helps translate these when inserting them into a traditional database.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的数据库上创建模型，我们将使用一个名为 **SQLAlchemy** 的 Python 包。SQLAlchemy 是最低级别的数据库 API，并在最高级别执行
    **对象关系映射**。**ORM**（对象关系映射器）是一种工具，允许开发人员使用面向对象的方法存储和检索数据，并解决对象关系不匹配——当使用面向对象编程语言编写的程序使用关系数据库管理系统时，经常会遇到的一组概念和技术难题。关系型和面向对象模型差异如此之大，以至于需要额外的代码和功能才能使它们有效地协同工作。这创建了一个虚拟对象数据库，并将数据库中的大量类型转换为
    Python 中的类型和对象的混合。此外，编程语言，如 Python，允许您拥有不同的对象，它们相互持有引用，并获取和设置它们的属性。像 SQLAlchemy
    这样的 ORM 帮助在将它们插入传统数据库时进行转换。
- en: In order to tie SQLAlchemy into our application context, we will use **Flask
    SQLAlchemy**. Flask SQLAlchemy is a convenience layer on top of SQLAlchemy that
    provides useful defaults and Flask-specific functions. If you are already familiar
    with SQLAlchemy, then you are free to use it without Flask SQLAlchemy.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将 SQLAlchemy 集成到我们的应用上下文中，我们将使用 **Flask SQLAlchemy**。Flask SQLAlchemy 是在 SQLAlchemy
    之上提供有用默认值和 Flask 特定功能的便利层。如果您已经熟悉 SQLAlchemy，那么您可以在不使用 Flask SQLAlchemy 的情况下自由使用它。
- en: By the end of this chapter, we will have a full database schema of our blogging
    application, as well as models that interact with that schema.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将拥有我们博客应用的完整数据库模式，以及与该模式交互的模型。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Designing database tables and relationships using SQLAlchemy
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SQLAlchemy 设计数据库表和关系
- en: Creating, reading, updating, and deleting models
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建、读取、更新和删除模型
- en: Learning to define model relationships, constraints, and indexes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习定义模型关系、约束和索引
- en: Creating automatic database migrations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自动数据库迁移
- en: Setting up SQLAlchemy
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 SQLAlchemy
- en: In order to go through the exercises in this chapter, you will need a running
    database, if you do not already have one. If you have never installed a database,
    or you do not have a preference, then **SQLite** is the best option for beginners,
    or if you want to quickly bootstrap a proof of concept.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章中的练习，您需要一个正在运行的数据库，如果您还没有的话。如果您从未安装过数据库，或者您没有偏好，那么 **SQLite** 是初学者的最佳选择，或者如果您想快速启动一个概念验证。
- en: '**SQLite** is an SQL-embedded database engine that is fast, works without a
    server, and is entirely contained in one file. SQLite is also natively supported
    in Python, so if you choose to go with SQLite, an SQLite database will be automatically created
    for you during the exercise in the *Our first model* section.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**SQLite** 是一个快速、无需服务器即可工作且完全包含在一个文件中的 SQL 嵌入式数据库引擎。SQLite 还在 Python 中原生支持，因此如果您选择使用
    SQLite，那么在 *我们的第一个模型* 部分的练习中，将自动为您创建一个 SQLite 数据库。'
- en: Python packages
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 包
- en: 'Flask SQLAlchemy can be used with multiple database engines, such as ORACLE,
    MSSQL, MySQL, PostgreSQL, SQLite, and Sybase, but we need to install additional
    specific packages for these engines. Now it is time to bootstrap our project by
    creating a new virtual environment for all our application''s dependencies. This
    virtual environment will be used for our blogging application. Enter the following
    code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Flask SQLAlchemy可以与多个数据库引擎一起使用，例如ORACLE、MSSQL、MySQL、PostgreSQL、SQLite和Sybase，但我们需要为这些引擎安装额外的特定包。现在，是时候通过为所有应用依赖项创建一个新的虚拟环境来引导我们的项目了。这个虚拟环境将用于我们的博客应用。输入以下代码：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, in `requirements.txt`, add the following code to install the package:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`requirements.txt`中添加以下代码以安装包：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You will also need to install specific packages for your chosen database that
    will act as the connector for SQLAlchemy, so add the specific packages for your
    engine in `requirements.txt`, as shown in the following code. SQLite users can
    skip this step:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要为所选数据库安装特定的包，这些包将作为SQLAlchemy的连接器。因此，在`requirements.txt`中添加特定于你的引擎的包，如下所示。SQLite用户可以跳过此步骤：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, activate and install the dependencies using the following code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用以下代码激活并安装依赖项：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Flask SQLAlchemy
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flask SQLAlchemy
- en: 'Before we can abstract our data, we need to set up Flask SQLAlchemy. SQLAlchemy
    creates its database connection through a special database URI. This is a string
    that looks like a URL that contains all the information that SQLAlchemy needs
    to connect. It takes the general form of the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们抽象数据之前，我们需要设置Flask SQLAlchemy。SQLAlchemy通过特殊的数据库URI创建其数据库连接。这是一个看起来像URL的字符串，包含SQLAlchemy连接所需的所有信息。它采用以下代码的一般形式：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For each driver that you installed previously, the URI would be as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你之前安装的每个驱动程序，URI将如下所示：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In our `config.py` file, add the URI to the `DevConfig` file with the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`config.py`文件中，使用以下方式将URI添加到`DevConfig`文件中：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Our first model
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个模型
- en: You may have noticed that we did not actually create any tables in our database
    to abstract from. This is because SQLAlchemy allows us to create either models
    from tables or tables from our models. We will look at this after we have created
    the first model.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们没有在我们的数据库中实际创建任何表来抽象。这是因为SQLAlchemy允许我们创建模型或从模型创建表。我们将在创建第一个模型之后查看这一点。
- en: 'In our `main.py` file, SQLAlchemy must first be initialized with our app as
    follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`main.py`文件中，SQLAlchemy必须首先使用以下方式初始化我们的应用：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'SQLAlchemy will read our app''s configuration and automatically connect to
    our database. Let''s create a `User` model to interact with a user table in the
    `main.py` file, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy将读取我们应用的配置并自动连接到我们的数据库。让我们在`main.py`文件中创建一个`User`模型来与用户表交互，如下所示：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: What have we accomplished? We now have a model that is based on a user table
    with three columns. When we inherit from `db.Model`, the entire connection and
    communication with the database will already be handled for us.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们取得了什么成果？我们现在有一个基于用户表且包含三个列的模型。当我们从`db.Model`继承时，与数据库的整个连接和通信将已经为我们处理。
- en: 'Each class variable that is the `db.Column` instance represents a column in
    the database. There is an optional first argument in the `db.Column` instance
    that allows us to specify the name of the column in the database. Without it,
    SQLAlchemy will assume that the name of the variable is the same as the name of
    the column. Using this, optional variable would look like the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 每个是`db.Column`实例的类变量都代表数据库中的一个列。在`db.Column`实例中有一个可选的第一个参数，允许我们指定数据库中列的名称。如果没有它，SQLAlchemy将假设变量的名称与列的名称相同。使用这个可选变量将看起来如下：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The second argument to `db.Column` tells SQLAlchemy what type the column should
    be treated as. The main types that we will work with in this book are as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`db.Column`的第二个参数告诉SQLAlchemy该列应该被处理为什么类型。在这本书中，我们将使用的主要类型如下：'
- en: '`db.String`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.String`'
- en: '`db.Text`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.Text`'
- en: '`` `db.Integer` ``'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`` `db.Integer` ``'
- en: '`db.Float`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.Float`'
- en: '`` `db.Boolean` ``'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`` `db.Boolean` ``'
- en: '`db.Date`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.Date`'
- en: '`db.DateTime`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.DateTime`'
- en: '`db.Time`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.Time`'
- en: 'What each type represents is rather simple, as shown in the following list:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型代表的内容相当简单，如下表所示：
- en: The `String` and `Text` types take Python strings and translate them to the
    `varchar` and `text` type columns, respectively.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String`和`Text`类型将Python字符串转换为`varchar`和`text`类型的列。'
- en: The `Integer` and `Float` types take any Python number and translates it into
    the correct type before inserting it into the database.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Integer`和`Float`类型会将任何Python数字转换为正确的类型，然后再将其插入数据库中。'
- en: Boolean takes Python `True` or `False` statements and, if the database has a
    `boolean` type, inserts a Boolean into the database. If there is no `boolean`
    type in the database, SQLAlchemy automatically translates between Python Booleans
    and a 0 or a 1 in the database.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boolean`类型接受Python的`True`或`False`语句，如果数据库有`boolean`类型，则将布尔值插入数据库。如果没有`boolean`类型在数据库中，SQLAlchemy会自动在Python布尔值和数据库中的0或1之间进行转换。'
- en: The `Date`, `DateTime`, and `Time` types use the Python types of the same names
    from the `datetime` native library and translates them into the database.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date`、`DateTime`和`Time`类型使用来自`datetime`原生库的同名Python类型，并将它们转换为数据库。'
- en: The `String`, `Integer`, and `Float` types take an extra argument that tells
    SQLAlchemy the length limit of our column.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`、`Integer`和`Float`类型接受一个额外的参数，告诉SQLAlchemy我们列的长度限制。'
- en: If you wish to truly understand how SQLAlchemy translates your code into SQL
    queries, add the following to the `DevConfig` file, `SQLALCHEMY_ECHO = True`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望真正理解SQLAlchemy如何将你的代码转换为SQL查询，请将以下内容添加到`DevConfig`文件中，`SQLALCHEMY_ECHO
    = True`。
- en: This will print out the created queries to the Terminal. You may wish to turn
    this feature off as you get further along in the book, as dozens of queries could
    be printed to the terminal with every page load.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在终端中打印出创建的查询。随着你在书中进一步学习，你可能希望关闭此功能，因为每次页面加载时，终端可能会打印出数十个查询。
- en: The `primary_key` argument tells SQLAlchemy that this column has the **primary
    key index** on it. Each SQLAlchemy model requires a primary key to function. All
    object-relationally mapped objects are linked to their database rows within the
    session via an identity map, a pattern central to the unit of work mechanism implemented
    in SQLAlchemy. That's why we need primary keys to be declared in the model.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`primary_key`参数告诉SQLAlchemy该列具有**主键索引**。每个SQLAlchemy模型都需要一个主键才能正常工作。所有对象关系映射对象都通过会话中的身份映射与数据库行相关联，这是SQLAlchemy中实现的工作单元机制的核心。这就是为什么我们需要在模型中声明主键的原因。'
- en: SQLAlchemy will assume that the name of your table is the lowercase version
    of your model class name. However, what if we want our table to be called something
    other than `user`? To tell SQLAlchemy what name to use, add the `__tablename__`
    class variable.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy会假设你的表名是模型类名称的小写版本。然而，如果我们想将表命名为`user`以外的名称怎么办？为了告诉SQLAlchemy使用什么名称，请添加`__tablename__`类变量。
- en: 'This is also how you connect to tables that already exist in your database.
    Just place the name of the table in the following string:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是你连接到数据库中已存在的表的方式。只需将表名放在以下字符串中：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We don't have to include the `__init__` or `__repr__` functions. If we don't,
    then SQLAlchemy will automatically create an `__init__` function that accepts
    the names and values of your columns as keyword arguments.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必包含`__init__`或`__repr__`函数。如果我们不包含，那么SQLAlchemy将自动创建一个`__init__`函数，该函数接受列的名称和值作为关键字参数。
- en: Naming a table `user` using an ORM may lead to problems, since in MySQL, `user`
    is a reserved word. One of the advantages of using an ORM is that you can easily
    migrate your engine from SQLite to MySQL and then to ORACLE, for example. One
    very easy fix would be to prefix your schema and use.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ORM命名表为`user`可能会导致问题，因为在MySQL中，`user`是一个保留字。使用ORM的一个优点是，你可以轻松地将你的引擎从SQLite迁移到MySQL，然后到ORACLE等。一个非常简单的修复方法是使用前缀你的模式并使用。
- en: Creating the user table
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用户表
- en: 'Using SQLAlchemy to do the heavy lifting, we will now create the user table
    in our database. Update `manage.py` to the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SQLAlchemy进行繁重的工作，我们现在将在数据库中创建用户表。将`manage.py`更新为以下内容：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: From now on, whenever we create a new model, we will import it and add it to
    the returned `dict`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，每次我们创建一个新的模型时，我们都会导入它并将其添加到返回的`dict`中。
- en: 'This will allow us to work with our models in the Flask shell, because we are
    injecting. Run the shell now and use `db.create_all()` to create all of the tables,
    as shown in the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们在Flask shell中使用我们的模型，因为我们正在注入。现在运行shell，并使用`db.create_all()`创建所有表，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In your database, you should now see a table called `users` with the columns
    specified. Also, if you are using SQLite, you should now see a file named `database.db`
    in your file structure, as shown in the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的数据库中，您现在应该看到一个名为 `users` 的表，其中包含指定的列。此外，如果您正在使用 SQLite，您现在应该能在文件结构中看到一个名为
    `database.db` 的文件，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: CRUD
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CRUD
- en: 'In every storage mechanism for data, there are four basic types of functions:
    **create**, **read**, **update**, and **delete** (**CRUD**). These allow us to
    perform all the basic ways of manipulating and viewing the data that is needed
    for our web apps. To use these functions, we will use an object in the database
    named a **session**. Sessions will be explained later in the chapter, but for
    now, think of them as a storage location for all of our changes to the database.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据存储的每一种机制中，都有四种基本类型的函数：**创建**、**读取**、**更新**和**删除**（**CRUD**）。这些允许我们执行所有基本的数据操作和查看方式，这些对于我们的
    Web 应用程序是必需的。为了使用这些函数，我们将使用数据库中的一个名为 **session** 的对象。会话将在本章后面进行解释，但就现在而言，可以将它们视为数据库中所有更改的存储位置。
- en: Creating models
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模型
- en: 'To create a new row in your database using our models, add the model to the
    `session` and `commit` objects. Adding an object to the session marks its changes
    for saving. Committing is when the session is saved to the database, as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们的模型在数据库中创建新行，请将模型添加到 `session` 和 `commit` 对象中。将对象添加到会话中会标记其更改以保存。提交是将会话保存到数据库的过程，如下所示：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, adding a new row to our table is simple.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，向我们的表中添加新行很简单。
- en: Reading models
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取模型
- en: After we have added data to our database, data can be queried using `Model.query`.
    For those who use SQLAlchemy, this is shorthand for `db.session.query(Model)`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将数据添加到数据库后，可以使用 `Model.query` 进行数据查询。对于使用 SQLAlchemy 的人来说，这是 `db.session.query(Model)`
    的简写。
- en: 'For our first example, use `all()` to get all rows from the user table as a
    list, as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一个示例，使用 `all()` 获取用户表的所有行作为列表，如下所示：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When the number of items in the database increases, this query process becomes
    slower. In SQLAlchemy, as in SQL, we have the `limit` function to specify the
    total number of rows we wish to work with:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据库中的项目数量增加时，此查询过程会变慢。在 SQLAlchemy 中，就像在 SQL 中一样，我们有 `limit` 函数来指定我们希望处理的总行数：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'By default, SQLAlchemy returns the records ordered by their primary keys. To
    control this, we have the `order_by` function, which is given as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，SQLAlchemy 按照主键顺序返回记录。为了控制这一点，我们有一个 `order_by` 函数，其用法如下：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To return just one record, we use `first()` instead of `all()`, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要返回单个记录，我们使用 `first()` 而不是 `all()`，如下所示：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To return one model by its primary key, use `query.get()`, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过其主键返回一个模型，使用 `query.get()`，如下所示：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'All these functions are chainable, which means that they can be appended onto
    each other to modify the returned result. Those of you who are fluent in JavaScript
    will find the following syntax familiar:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数都是可链式的，这意味着可以将它们附加在一起以修改返回的结果。那些精通 JavaScript 的您会发现以下语法很熟悉：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `first()` and `all()` methods return a value, and therefore end the chain.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`first()` 和 `all()` 方法返回一个值，因此结束链式调用。'
- en: There is also a Flask-SQLAlchemy-specific method, called **pagination**, that
    can be used rather than `first()` or `all()`. This is a convenient method that
    is designed to enable the pagination feature that most websites use while displaying
    a long list of items. The first parameter defines which page the query should
    return to and the second parameter defines the number of items per page. So, if
    we passed `1` and `10` as the parameters, the first 10 objects would be returned.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个 Flask-SQLAlchemy 特定的方法，称为 **pagination**，可以用来代替 `first()` 或 `all()`。这是一个方便的方法，旨在启用大多数网站在显示长列表时使用的分页功能。第一个参数定义了查询应返回的页面，第二个参数定义了每页的项目数。因此，如果我们传递
    `1` 和 `10` 作为参数，将返回前 10 个对象。
- en: 'If we instead passed `2` and `10`, then objects 11–20 would be returned, and
    so on. The pagination method is different from the `first()` and `all()` methods
    because it returns a pagination object rather than a list of models. For example,
    if we want to get the first 10 items of a fictional `Post` object for the first
    page in our blog, we would use the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们改为传递 `2` 和 `10`，则将返回对象 11–20，依此类推。分页方法与 `first()` 和 `all()` 方法不同，因为它返回一个分页对象而不是模型列表。例如，如果我们想获取我们博客第一页的虚构
    `Post` 对象的前 10 项，我们会使用以下方法：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This object has several useful properties, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象具有几个有用的属性，如下所示：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Filtering queries
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤查询
- en: 'Now we get to the actual power of SQL—that is, filtering results by a set of
    rules. To get a list of models that satisfy a set of qualities, we use the `query.filter_by`
    filter. The `query.filter_by` filter takes named arguments that represent the
    values we are looking for in each column in the database. To get a list of all
    users with a username of `fake_name`, we would use the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到了 SQL 的真正威力所在——即通过一系列规则来过滤结果。为了获取满足一系列特性的模型列表，我们使用 `query.filter_by` 过滤器。`query.filter_by`
    过滤器接受命名参数，这些参数代表我们在数据库的每一列中寻找的值。要获取用户名为 `fake_name` 的所有用户列表，我们会使用以下代码：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This example is filtering on one value, but multiple values can be passed to
    the `filter_by` filter. Just like our previous functions, `filter_by` is chainable,
    as shown in the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是针对一个值进行过滤，但可以向 `filter_by` 过滤器传递多个值。就像我们之前的函数一样，`filter_by` 是可链式的，如下所示：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `query.filter_by` phrase only works if you know the exact values that you
    are looking for. This is avoided by passing Python comparison statements to the
    query with `query.filter`, as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`query.filter_by` 语句仅在你知道你正在寻找的确切值时才有效。通过将 Python 比较语句传递给查询，可以避免这种情况，如下所示：'
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is a simple example, but `query.filter` accepts any Python comparison.
    With common Python types, such as `integers`, `strings`, and `dates`, the `==`
    operator can be used for equality comparisons. If you had an `integer`, `float`,
    or `date` column, an inequality statement could also be passed with the `>`, `<`,
    `<=`, and `>=` operators.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子，但 `query.filter` 接受任何 Python 比较。对于常见的 Python 类型，如 `integers`、`strings`
    和 `dates`，可以使用 `==` 操作符进行相等比较。如果你有一个 `integer`、`float` 或 `date` 列，也可以使用 `>`、`<`、`<=`
    和 `>=` 操作符传递不等式语句。
- en: 'We can also translate complex SQL queries with SQLAlchemy functions. For example,
    to use `IN`, `OR`, or `NOT` SQL comparisons, we would use the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 SQLAlchemy 函数翻译复杂的 SQL 查询。例如，要使用 `IN`、`OR` 或 `NOT` SQL 比较，我们会使用以下代码：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In SQLAlchemy, comparisons to `None` are translated to comparisons to `NULL`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLAlchemy 中，对 `None` 的比较会被翻译为对 `NULL` 的比较。
- en: Updating models
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新模型
- en: 'To update the values of models that already exist, apply the `update` method
    to a query object—that is, before you return the models with a method such as
    `first()` or `all()`, as shown in the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新已存在模型的值，将 `update` 方法应用于查询对象——即在返回模型之前，使用如 `first()` 或 `all()` 等方法，如下所示：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Deleting models
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除模型
- en: 'If we wish to remove a model from the database, we would use the following
    code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望从数据库中删除一个模型，我们会使用以下代码：
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Relationships between models
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型之间的关系
- en: Relationships between models in SQLAlchemy are links between two or more models
    that allow models to reference each other automatically. This allows naturally
    related data, such as comments on posts, to be easily retrieved from the database
    with its related data. This is where the R in RDBMS comes from, and it gives this
    type of database a large amount of power.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 中模型之间的关系是两个或多个模型之间的链接，允许模型自动相互引用。这使得自然相关的数据，如文章的评论，可以很容易地从数据库及其相关数据中检索出来。这正是
    RDBMS 中的 R 的来源，这也赋予了这种类型的数据库大量的能力。
- en: 'Let''s create our first relation. Our blogging website is going to need some
    blog posts. Each blog post is going to be written by one user, so it makes sense
    to link posts back to the user who wrote them so that we can easily get all the
    posts by a user. This is an example of a **one-to-many** relationship, as shown
    in the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的第一个关系。我们的博客网站将需要一些博客文章。每篇博客文章将由一个用户撰写，因此将文章链接回撰写它们的用户是有意义的，这样我们就可以轻松地获取一个用户的全部文章。这是一个
    **一对多** 关系的例子，如下所示：
- en: SQLite and MySQL/MyISAM engines do not enforce relationship constraints. This
    might cause problems if you are using SQLite on your development environment and
    a different engine on production (MySQL with innodb), but you can tell SQLite
    to enforce foreign key constraints (with a performance penalty).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 和 MySQL/MyISAM 引擎不强制执行关系约束。如果你在开发环境中使用 SQLite，而在生产环境中使用不同的引擎（如带有 innodb
    的 MySQL），这可能会引起问题，但你可以告诉 SQLite 强制执行外键约束（这将带来性能上的惩罚）。
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: One-to-many relationship
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一对多关系
- en: 'Let''s add a model to represent the blog posts on our website:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个模型来表示我们网站上的博客文章：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note the `user_id `column. Those who are familiar with RDBMSes will know that
    this represents a **foreign key constraint**. A foreign key constraint is a rule
    in the database that forces the value of `user_id` to exist in the `id` column
    in the user table. This is a check in the database to make sure that `Post` will
    always refer to an existing user. The parameter to `db.ForeignKey` is a string
    representation of the user ID field. If you have decided to call your user table
    with `__table_name__`, then you must change this string. This string is used instead
    of a direct reference with `User.id` because during initialization of SQLAlchemy,
    the `User` object might not exist yet.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`user_id`列。熟悉RDBMS的人会知道这代表一个**外键约束**。外键约束是数据库中的一个规则，它强制`user_id`的值存在于用户表中的`id`列。这是数据库中的一个检查，以确保`Post`始终引用一个存在的用户。`db.ForeignKey`的参数是用户ID字段的字符串表示。如果你已经决定用`__table_name__`来调用你的用户表，那么你必须更改这个字符串。这个字符串用于代替直接使用`User.id`的引用，因为在SQLAlchemy初始化期间，`User`对象可能还不存在。
- en: 'The `user_id` column itself is not enough to tell SQLAlchemy that we have a
    relationship. We must modify our `User` model as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`user_id`列本身不足以告诉SQLAlchemy我们有一个关系。我们必须按照以下方式修改我们的`User`模型：'
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `db.relationship` function creates an attribute in SQLAlchemy that connects
    with `db.ForeignKey` in our `Post` model. The first parameter is the name of the
    class that we are referencing. We will cover what `backref` does soon, but what
    is the `lazy` parameter? The `lazy` parameter controls how SQLAlchemy will load
    our related objects. The `subquery` phrase would load our relations as soon as
    our `Post` object is loaded. This cuts down the number of queries, but will slow
    down when the number of returned items grows larger. In contrast, with the `dynamic`
    option, the related objects will be loaded upon access and can be filtered down
    before returning. This is best if the number of returned objects is or will become
    large.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`db.relationship`函数在SQLAlchemy中创建了一个与`Post`模型中的`db.ForeignKey`连接的属性。第一个参数是我们引用的类的名称。我们很快就会介绍`backref`的作用，但`lazy`参数是什么？`lazy`参数控制SQLAlchemy如何加载我们的相关对象。`subquery`短语会在我们的`Post`对象被加载时立即加载我们的关系。这减少了查询的数量，但当返回的项目数量增加时，速度会减慢。相比之下，使用`dynamic`选项，相关对象将在访问时加载，并且可以在返回之前进行过滤。如果返回的对象数量很大或将成为很大，这是最好的选择。'
- en: 'We may now access the `User.posts` variable that will return a list of all
    the posts whose `user_id` field equals our `User.id`. Let''s try this now in our
    shell, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以访问`User.posts`变量，它将返回一个包含所有`user_id`字段等于我们的`User.id`的帖子的列表。现在让我们在我们的shell中尝试这个操作，如下所示：
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that we were not able to access our post from our relationship without
    committing our changes to the database.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有能够在不提交我们的数据库更改的情况下从我们的关系访问我们的帖子。
- en: 'The `backref` parameter gives us the ability to access and set our `User` class
    via `Post.user`. This is given by the following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`backref`参数给了我们通过`Post.user`访问和设置我们的`User`类的能力。这是由以下代码给出的：'
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Because `user.posts` is a list, we could have also added our `Post` model to
    the list to save it automatically, as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`user.posts`是一个列表，我们也可以将我们的`Post`模型添加到列表中来自动保存，如下所示：
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'With the `backref` option as dynamic, we can treat our relation column as a
    query as well as a list, as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`backref`选项作为动态的，我们可以将我们的关系列视为一个查询以及一个列表，如下所示：
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Before we move on to our next relationship type, let''s add another model for
    user comments with a one-to-many relationship, which will be used in the book
    later on. We can do this using the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续到下一个关系类型之前，让我们添加一个用于用户评论的一对多关系的另一个模型，这个模型将在后面的书中使用。我们可以使用以下代码来完成这个操作：
- en: '[PRE36]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Note the `__repr__` method signature in the preceding code. This is a built-in
    function in Python that is used to return the string representation of the object.
    Next is the `Comment` model, as shown in the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意前面代码中的`__repr__`方法签名。这是一个Python中的内置函数，用于返回对象的字符串表示。接下来是`Comment`模型，如下所示：
- en: '[PRE37]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Many-to-many relationship
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多对多关系
- en: 'What if we have two models that can reference each other, but each model needs
    to reference more than one of each type? In our example, our blog posts will need
    tags in order for our users to easily group similar posts. Each tag can refer
    to many posts, but each post can have multiple tags. This type of relationship
    is called a **many-to-many** relationship. Consider the following example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有两个模型可以相互引用，但每个模型都需要引用每种类型的多于一个实例呢？在我们的例子中，我们的博客帖子需要标签以便用户可以轻松地对相似帖子进行分组。每个标签可以引用多个帖子，但每个帖子可以有多个标签。这种关系称为**多对多**关系。考虑以下例子：
- en: '[PRE38]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `db.Table` object is a lower-level access to the database than the abstraction
    of `db.Model`. The `db.Model` object rests on top of `db.Table` and provides a
    representation of specific rows in the table. The `db.Table` object is used because
    there is no need to access the individual rows of the table.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`db.Table`对象是对数据库的底层访问，比`db.Model`抽象级别低。`db.Model`对象位于`db.Table`之上，并提供了对表中特定行的表示。使用`db.Table`对象是因为没有必要访问表中的单个行。'
- en: 'The `tags` variable is used to represent the `post_tags` table, which contains
    two rows: one that represents an ID of a post, and another that represents the
    ID of a tag. To illustrate how this works, let''s look at an example. Say that
    the table had the following data:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`tags`变量用于表示`post_tags`表，该表包含两行：一行代表帖子的ID，另一行代表标签的ID。为了说明这是如何工作的，让我们来看一个例子。假设表中有以下数据：'
- en: '[PRE39]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'SQLAlchemy would translate this to the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy会将此翻译为以下内容：
- en: A post with an ID of `1` has the tags with the IDs of `1` and `3`
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个ID为`1`的帖子有ID为`1`和`3`的标签
- en: A post with an ID of `2` has the tags with the IDs of `3`, `4`, and `5`
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个ID为`2`的帖子有ID为`3`、`4`和`5`的标签
- en: A post with an ID of `3` has the tags with the IDs of `1` and `2`
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个ID为`3`的帖子有ID为`1`和`2`的标签
- en: You may describe this data as easily as tags being related to posts.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像描述标签与帖子相关联一样轻松地描述这些数据。
- en: 'Before the `db.relationship` function sets up our relationship, this time it
    has the secondary parameter. The secondary parameter tells SQLAlchemy that this
    relationship is stored in the `tags` table, as shown in the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在`db.relationship`函数设置我们的关系之前，这次它有一个次要参数。次要参数告诉SQLAlchemy，这个关系存储在`tags`表中，如下面的代码所示：
- en: '[PRE40]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As given in the one-to-many relationship, the main relationship column is just
    a list, the main difference being that the `backref` option is now also a list.
    Because it''s a list, we may add posts to tags from the `tag` object, as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在单对多关系中，主关系列只是一个列表，主要区别在于`backref`选项现在也是一个列表。因为它是列表，我们可以从`tag`对象添加帖子到标签，如下所示：
- en: '[PRE41]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Constraints and indexing
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 约束和索引
- en: 'Using constraints is considered a good practice. This way, you can restrict
    the domain of a certain model attribute and ensure data integrity and quality.
    There are many types of constraints that you can use; primary key and foreign
    key constraintswere already covered in the previous sections. The other kinds
    of constraints that are supported by SQLAlchemy are shown in the following list:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用约束被认为是一种良好的实践。这样，你可以限制某个模型属性的域，并确保数据完整性和质量。你可以使用许多类型的约束；在前面的章节中已经介绍了主键和外键约束。SQLAlchemy支持的其它类型的约束如下所示：
- en: Not NULL (ensures that a certain attribute contains data)
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NOT NULL（确保某个属性包含数据）
- en: UNIQUE (ensures that a certain attribute value is always unique in the database
    table, which contains the model data)
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UNIQUE（确保数据库表中的某个属性值始终是唯一的，该表包含模型数据）
- en: DEFAULT (sets a default value for the attribute when no values were provided)
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DEFAULT（在未提供值时为属性设置默认值）
- en: CHECK (used to specify range of values)
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CHECK（用于指定值的范围）
- en: Using SQLAlchemy, you can ensure that your data's domain restrictions are explicit
    and all in the same place, not spread across your application code.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SQLAlchemy，你可以确保你的数据域限制是明确的，并且都在同一个地方，而不是分散在应用程序代码中。
- en: 'Let''s improve our models by setting some constraints on the data. First, we
    should not accept NULL values for usernames on the user model, and ensure that
    a username is always unique. We do this using the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在数据上设置一些约束来改进我们的模型。首先，我们不应接受用户模型中用户名的NULL值，并确保用户名始终唯一。我们使用以下代码来完成：
- en: '[PRE42]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The same principle applies to the rest of our models: A `Post` must always
    have a title, a `Comment` is always made by someone, and a `Tag` always has a
    title, and this title value is unique. We put these constraints in place using
    the following code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的原则适用于我们的其他模型：`Post`必须始终有一个标题，`Comment`总是由某人创建，`Tag`总是有一个标题，并且这个标题值是唯一的。我们使用以下代码来设置这些约束：
- en: '[PRE43]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Default values are really nice; they ensure data quality, and make your code
    shorter. We can let SQLAlchemy handle the date timestamp of when a comment or
    post was made using the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值非常好；它们确保数据质量，并使你的代码更短。我们可以让SQLAlchemy处理评论或帖子创建的日期时间戳，以下代码：
- en: '[PRE44]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note how SQLAlchemy handles the default definitions. This is a powerful feature.
    We are passing a reference to a Python function, so we can use any Python function
    we want as long as no parameters are required (except for partials). This function
    will be called upon the creation of a record or an update, and its return value
    is used for the column's value. Of course, SQLAlchemy also supports simple scalar
    values on default definitions.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意SQLAlchemy如何处理默认定义。这是一个强大的功能。我们传递了一个Python函数的引用，因此只要不需要参数（除了部分函数），我们就可以使用任何我们想要的Python函数。这个函数将在创建记录或更新时被调用，并且它的返回值用于列的值。当然，SQLAlchemy也支持简单的标量值在默认定义中。
- en: RDBMS indexes are used to improve query performance, yet you should be careful
    about using them as this comes at a cost of additional writes on `INSERT`, `UPDATE`,
    and `DELETE` functions, as well as an increase in storage. Careful index choice
    and configuration is out of the scope of this book, but take into account the
    fact that an index is used to reduce the O(N) lookup on certain table columns
    that may be frequently used, or that are in tables with a huge number of rows
    where a linear lookup is simply not possible in production. Index query performance
    can go from logarithmic to O(1). This is possible at a cost of additional writes
    and checks.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: RDBMS索引用于提高查询性能，但你应该小心使用它们，因为这会在`INSERT`、`UPDATE`和`DELETE`函数上带来额外的写入，以及存储的增加。仔细选择和配置索引超出了本书的范围，但请考虑这样一个事实：索引用于减少对某些表列的O(N)查找，这些列可能经常被使用，或者位于具有大量行的表中，在生产中线性查找根本不可能。索引查询性能可以从对数级提高到O(1)。这是以额外的写入和检查为代价的。
- en: 'An example of creating an index using Flask SQLAlchemy, can be seen in the
    following code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例展示了使用Flask SQLAlchemy创建索引的方法：
- en: '[PRE45]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The following code shows an example of using an index for multiple columns:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了使用多个列的索引的示例：
- en: '[PRE46]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The convenience of SQLAlchemy sessions
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQLAlchemy会话的便利性
- en: Now you understand the power of SQLAlchemy and what the SQLAlchemy session object
    is, and why web apps should never be made without them. As stated before, the
    session can be simply described as an object that tracks the changes in our models
    and commits them to the database when we tell it to. However, there is a bit more
    to it than this.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了SQLAlchemy的力量以及SQLAlchemy会话对象是什么，以及为什么Web应用在没有任何会话的情况下不应该被创建。正如之前所述，会话可以简单地描述为一个跟踪我们模型中的更改并在我们告诉它时将它们提交到数据库的对象。然而，这不仅仅是这一点。
- en: First, the session is also the handler for **transactions**. Transactions are
    sets of changes that are flushed to the database on commit. Transactions provide
    a lot of hidden functionality. For example, transactions automatically determine
    which objects are to be saved first when objects have relations. You might have
    noted this when we were saving tags in the previous section. When we added tags
    to the posts, the session automatically knew to save the tags first despite the
    fact that we did not add them to be committed. If we are working with raw SQL
    queries and a database connection, we will have to keep track of which rows are
    related to which other rows to avoid saving a foreign key reference to an object
    that does not exist.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，会话也是**事务**的处理者。事务是一系列在提交时刷新到数据库中的更改集合。事务提供了许多隐藏的功能。例如，当对象有关系时，事务会自动确定哪些对象应该首先保存。你可能在前一节保存标签时注意到了这一点。当我们向帖子添加标签时，会话自动知道首先保存标签，尽管我们没有将它们添加为要提交的内容。如果我们使用原始SQL查询和数据库连接，我们将不得不跟踪哪些行与哪些其他行相关联，以避免保存一个指向不存在对象的键外键引用。
- en: Transactions also automatically mark data as stale when changes to an object
    are saved to the database. The next time we access the object, a query is made
    to the database to update the data, but all of this happens behind the scenes.
    If we are not using SQLAlchemy, we will also need to manually track which rows
    need to be updated. If we want to be resource efficient, we only need to query
    and update those rows.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象的更改保存到数据库时，事务也会自动将数据标记为过时。下次我们访问该对象时，将查询数据库以更新数据，但所有这些都在幕后发生。如果我们不使用 SQLAlchemy，我们还需要手动跟踪哪些行需要更新。如果我们想资源高效，我们只需要查询和更新这些行。
- en: Second, the session makes it impossible for there to be two different references
    to the same row in the database. This is accomplished by ensuring that all queries
    go through the session (`Model.query` is actually `db.session.query(Model)`),
    and if the row has already been queried in this transaction, that the pointer
    to that object will be returned and not a new object. If this check did not exist,
    two objects that represent the same row could be saved to the database with different
    changes. This creates subtle bugs that might not be caught instantly.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，会话确保数据库中同一行的引用不会出现两个不同的情况。这是通过确保所有查询都通过会话进行（`Model.query` 实际上是 `db.session.query(Model)`），并且如果该行已经在当前事务中查询过，那么将返回对该对象的指针而不是一个新的对象。如果这个检查不存在，两个代表同一行的对象可能会以不同的更改保存到数据库中。这会创建一些微妙的错误，这些错误可能不会立即被发现。
- en: Keep in mind that Flask SQLAlchemy creates a new session for every request and
    discards any changes that were not committed at the end of the request, so always
    remember to save your work.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Flask SQLAlchemy 为每个请求创建一个新的会话，并在请求结束时丢弃任何未提交的更改，所以请始终记得保存你的工作。
- en: For an in-depth look at sessions, the creator of SQLAlchemy, Mike Bayer, gave
    a talk at PyCon Canada 2012\. Refer to *The SQLAlchemy Session - In Depth*, at [https://www.youtube.com/watch?v=PKAdehPHOMo](https://www.youtube.com/watch?v=PKAdehPHOMo).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解会话，SQLAlchemy 的创建者 Mike Bayer 在 2012 年的 PyCon Canada 上发表了一次演讲。请参阅[https://www.youtube.com/watch?v=PKAdehPHOMo](https://www.youtube.com/watch?v=PKAdehPHOMo)上的*The
    SQLAlchemy Session - In Depth*。
- en: Database migrations with Alembic
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Alembic 进行数据库迁移
- en: The functionality of web apps changes all the time, and with every new functionality,
    we need to change the structure of our database. Whether it's adding or dropping
    new columns or creating new tables, our models will change throughout the life
    cycle of our app. However, problems quickly arise when the database changes often.
    When moving our changes from development to production, how can you be sure that
    you carried over every change without manually comparing each model and its corresponding
    table? Let's say that you want to go back into your Git history to see whether
    an earlier version of your app had the same bug that you are now encountering
    in production. How will you change your database back to the correct schema without
    a lot of extra work?
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用的功能总是在不断变化，并且随着每个新功能的加入，我们需要更改数据库的结构。无论是添加或删除新列还是创建新表，我们的模型将在应用的生命周期中不断变化。然而，当数据库经常变化时，问题会迅速出现。当我们把更改从开发环境迁移到生产环境时，如何确保没有手动比较每个模型及其对应的表就完成了所有更改？假设你想回到你的
    Git 历史记录中查看你的应用早期版本是否有你现在在生产环境中遇到的相同错误。在没有大量额外工作的前提下，你将如何将数据库更改回正确的模式？
- en: As programmers, we hate extra work. Thankfully, there is a tool called **Alembic**,
    which automatically creates and tracks database migrations from the changes in
    our SQLAlchemy models. **Database migrations** are records of all the changes
    of our schema. Alembic allows us to upgrade or downgrade our database to a specific
    saved version. Upgrading or downgrading by several versions will execute all the
    files between the two selected versions. The best thing about Alembic is that
    its history files are only Python files. When we create our first migration, we
    can see how simple the Alembic syntax is.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们讨厌额外的工作。幸运的是，有一个名为 **Alembic** 的工具，它可以自动从我们的 SQLAlchemy 模型的更改中创建和跟踪数据库迁移。**数据库迁移**是我们模式所有更改的记录。Alembic
    允许我们将数据库升级或降级到特定的保存版本。通过几个版本进行升级或降级将执行两个选定版本之间的所有文件。Alembic 最好的地方在于，其历史文件仅仅是 Python
    文件。当我们创建第一个迁移时，我们可以看到 Alembic 语法是多么简单。
- en: Alembic does not capture every possible change—for example, it does not record
    changes on the SQL indexes. After every migration, the reader is encouraged to
    review the migration file and make any necessary corrections.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Alembic 并不捕获所有可能的变化——例如，它不会记录 SQL 索引上的变化。每次迁移后，都鼓励读者回顾迁移文件并进行任何必要的修正。
- en: 'We won''t work directly with Alembic. Instead, we will use **Flask-Migrate**,
    which is an extension created specifically for SQLAlchemy, and which works with
    the Flask CLI. You will find it in the `requirements.txt` file, as shown in the
    following code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会直接使用 Alembic。相反，我们将使用 **Flask-Migrate**，这是一个专门为 SQLAlchemy 创建的扩展，并且与 Flask
    CLI 一起工作。您可以在以下代码中找到它，在 `requirements.txt` 文件中，如下所示：
- en: '[PRE47]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To get started, we don''t need to add anything to our `manage.py` file since
    Flask-Migrate already extends the Flask CLI with its own CLI options, as shown
    in the following code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们不需要向我们的 `manage.py` 文件中添加任何内容，因为 Flask-Migrate 已经通过其自己的 CLI 选项扩展了 Flask
    CLI，如下所示：
- en: '[PRE48]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'And on our `main.py`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `main.py` 中：
- en: '[PRE49]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To initialize the `Migrate` object with our app and our SQLAlchemy instance,
    run the following code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们的应用程序和 SQLAlchemy 实例初始化 `Migrate` 对象，请运行以下代码：
- en: '[PRE50]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To start tracking our changes, we use the `init` command, as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始跟踪我们的更改，我们使用 `init` 命令，如下所示：
- en: '[PRE51]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This will create a new folder in our directory named `migrations` that will
    hold all of our history. Now we start with our first migration, as shown in the
    following code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们的目录中创建一个新的名为 `migrations` 的文件夹，用于存储所有历史记录。现在我们开始第一个迁移，如下所示：
- en: '[PRE52]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This command will cause Alembic to scan our SQLAlchemy object and find all the
    tables and columns that did not exist before this commit. As this is our first
    commit, the migration file will be rather long. Be sure to specify the migration
    message with `-m`, as it's the easiest way to identify what each migration is
    doing. Each migration file is stored in the `migrations/versions/` folder.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将导致 Alembic 扫描我们的 SQLAlchemy 对象，并找到所有在此提交之前不存在的表和列。由于这是我们第一次提交，迁移文件将会相当长。请务必使用
    `-m` 选项指定迁移信息，因为这是识别每次迁移所做操作的最简单方法。每个迁移文件都存储在 `migrations/versions/` 文件夹中。
- en: 'To apply the migration to your database and change your schema, run the following
    code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要将迁移应用到数据库并更改架构，请运行以下代码：
- en: '[PRE53]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If we want to check out all the SQLAlchemy generated DDL code, then we use
    the following code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想检查所有 SQLAlchemy 生成的 DDL 代码，则使用以下代码：
- en: '[PRE54]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To return to the previous version, find the version number with the `history`
    command and pass it to the `downgrade` command, as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要返回到上一个版本，使用 `history` 命令找到版本号，并将其传递给 `downgrade` 命令，如下所示：
- en: '[PRE55]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Like Git, a hash marks each migration. This is the main functionality of Alembic,
    but it is only surface level. Try to align your migrations with your Git commits
    in order to make it easier to downgrade or upgrade when reverting commits.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如同 Git，一个哈希标记每个迁移。这是 Alembic 的主要功能，但它只是表面层次。尝试将您的迁移与 Git 提交对齐，以便在回滚提交时更容易降级或升级。
- en: In the code for this book, you will find in each chapter an initialization script
    that will create a Python virtual environment, install all declared dependencies,
    and initialize the database. Take a look at the `init.sh` Bash script.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的代码中，您将在每一章找到一个初始化脚本，该脚本将创建一个 Python 虚拟环境，安装所有声明的依赖项，并初始化数据库。请查看 `init.sh`
    Bash 脚本。
- en: Summary
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Now that we have mastered data control, we may move on to displaying our data
    in our application. The next chapter, `Chapter 3`, *Creating Views with Templates*,
    will dynamically cover creating HTML based on our models and adding models from
    our web interface.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了数据控制，我们可以继续在我们的应用程序中显示数据。下一章，`第 3 章`，*使用模板创建视图*，将动态介绍基于我们的模型创建 HTML
    以及从我们的网络界面添加模型。
