- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Accessing the Network
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问网络
- en: In the previous chapter, we looked into programmable networks and their history.
    One of the ideas we explored was **Software-Defined Networking** (**SDN**), where
    we saw why the separation between the data plane and the control plane was important.
    One important point of SDN was its architecture and how it separates the **North
    Bound Interface** (**NBI**) and **South Bound Interface** (**SBI**). In this chapter,
    we are going to explore how to access the network devices that can be interpreted
    as the SBI for SDN when OpenFlow is not available on the device.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了可编程网络及其历史。我们探讨的一个想法是**软件定义网络**（**SDN**），我们看到了为什么数据平面和控制平面的分离很重要。SDN的一个重要点是它的架构以及它是如何分离**北向接口**（**NBI**）和**南向接口**（**SBI**）的。在本章中，我们将探讨如何在OpenFlow不可用的情况下，访问可以解释为SDN的SBI的网络设备。
- en: As we have seen before, OpenFlow is not a widely adopted protocol, and its availability
    is limited to a few manufacturers and devices. Therefore, if you are planning
    to use SDN, you may need to use the available native methods to configure the
    devices.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所看到的，OpenFlow并不是一个广泛采用的协议，其可用性仅限于少数制造商和设备。因此，如果您计划使用SDN，您可能需要使用可用的本地方法来配置设备。
- en: Network access is not only used for SDN but also for a variety of software,
    such as network configuration, configuration audit, upgrade tools, and automation,
    among others. Additionally, devices usually have multiple methods or protocols,
    some of which may be better than others.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 网络访问不仅用于SDN，还用于各种软件，例如网络配置、配置审计、升级工具和自动化等。此外，设备通常有多种方法或协议，其中一些可能比其他的好。
- en: In this chapter, we will explore the most common methods and protocols for accessing
    network devices for our network automation. Since devices have multiple methods,
    we will aim to give you enough information so that you can choose the one that
    is most appropriate for your network automation code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨访问网络设备的最常见方法和协议，以实现我们的网络自动化。由于设备有多种方法，我们的目标是提供足够的信息，以便您可以选择最适合您网络自动化代码的方法。
- en: 'We are going to explore the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探讨以下主题：
- en: Working with the CLI
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CLI
- en: Using SNMP
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SNMP
- en: Employing NETCONF
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采用NETCONF
- en: Adopting gRPC
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采用gRPC
- en: Operating with gNMI
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用gNMI操作
- en: Working with the CLI
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CLI
- en: The **Command-Line Interface** (**CLI**) is perhaps the most widely available
    method for accessing a network device. It is a term imported from computers, which
    was a replacement for **teletypewriter** (**TTY**) machines. A CLI is normally
    implemented by using a program that runs inside the device to interpret the keys
    being typed. Early implementations of the CLI program monitored the device’s serial
    port, where a terminal with a keyboard was connected to communicate.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令行界面**（**CLI**）可能是访问网络设备最广泛可用的方法。这是一个从计算机中引入的术语，它是**电传打字机**（**TTY**）机的替代品。CLI通常通过在设备内部运行的程序来实现，该程序解释正在键入的键。CLI程序的早期实现监控设备的串行端口，其中连接了带有键盘的终端以进行通信。'
- en: In UNIX, the CLI program was called a shell, and the first shell, called the
    **V6 shell**, was created in 1971 by Ken Thompson at Bell Labs. The **Bourne shell**
    was introduced in 1977 as a replacement for the V6 shell. Although the UNIX shell
    is used as an interactive command interpreter, it was also intended to be a scripting
    language and contains most of the features that are commonly considered to produce
    structured programs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在UNIX系统中，CLI程序被称为shell，第一个shell，称为**V6 shell**，是在1971年由贝尔实验室的Ken Thompson创建的。**Bourne
    shell**于1977年推出，作为V6 shell的替代品。尽管UNIX shell用作交互式命令解释器，但它也被设计为一种脚本语言，并包含大多数被认为是用于生成结构化程序的功能。
- en: Network devices use a simplified version of a shell for their CLIs. Let’s explore
    a bit more what CLI access can offer.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 网络设备使用shell的简化版本作为它们的CLI。让我们更深入地探讨CLI访问可以提供的内容。
- en: The command prompt
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令提示符
- en: When using the CLI in our network automation work, the command prompt is the
    most important piece in our code to be interpreted. We will see that the device
    uses the command prompt to indicate when it is ready to receive a new command.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的网络自动化工作中使用CLI时，命令提示符是我们代码中最重要的部分，需要被解释。我们将看到设备使用命令提示符来指示它何时准备好接收新命令。
- en: A `$`, `%`, `#`, `:`, `>`, or `-`. It also can include additional information,
    such as the current time, working directory, username, or hostname. On many network
    devices, the prompt normally ends with `$` or `%`, and for the privileged CLI
    access mode, it normally ends with `#`, which is similar to the UNIX superuser,
    `root`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`$`、`%`、`#`、`:`、`>`或`-`。它还可以包括其他信息，例如当前时间、工作目录、用户名或主机名。在许多网络设备上，提示符通常以`$`或`%`结束，而对于特权CLI访问模式，它通常以`#`结束，这与UNIX超级用户`root`类似。
- en: Most of the prompts can be modified by the user – however, the most common information
    presented in the prompts of network devices is the hostname and sometimes, the
    username used for login.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数提示符都可以由用户修改 – 然而，网络设备提示符中最常见的信息是主机名，有时还包括用于登录的用户名。
- en: 'The example in *Figure 3.1* shows an `core-router` and the `>` character at
    the end, meaning it is waiting for the commands to be placed where the cursor
    is:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.1*中的示例显示了一个`core-router`和末尾的`>`字符，这意味着它正在等待将命令放置在光标所在的位置：'
- en: '![Figure 3.1 – A FRR router command prompt example](img/B18165_03_001.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 一个FRR路由器命令提示符示例](img/B18165_03_001.jpg)'
- en: Figure 3.1 – A FRR router command prompt example
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 一个FRR路由器命令提示符示例
- en: Serial access
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 串行访问
- en: A network device normally has a special port called a *console* or *serial console*.
    This port is normally configured to operate at a slow speed, and the common configuration
    sets the baud rate to 9,600, with some devices able to accept up to 115,200 bits
    per second. The serial port is normally a **DB9** connector or an **RJ45**, with
    **RS232** technical specifications. *Figure 3.2* shows an example of the pins
    used for DB9 and RJ45 serial console connectors.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 网络设备通常有一个称为*控制台*或*串行控制台*的特殊端口。此端口通常配置为以较慢的速度运行，常见的配置将波特率设置为9,600，有些设备能够接受高达每秒115,200位的速率。串行端口通常是一个**DB9**连接器或**RJ45**，具有**RS232**技术规范。*图3.2*显示了用于DB9和RJ45串行控制台连接器的引脚示例。
- en: 'The program that handles the serial port is normally independent of the device’s
    operating system, allowing this type of port to be used in catastrophic scenarios:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 处理串行端口的程序通常独立于设备的操作系统，允许在这种灾难性场景中使用此类端口：
- en: '![Figure 3.2 – An example of a device’s serial port pin configuration ](img/B18165_03_002.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – 设备串行端口引脚配置示例](img/B18165_03_002.jpg)'
- en: Figure 3.2 – An example of a device’s serial port pin configuration
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 设备串行端口引脚配置示例
- en: 'It’s important to note that the serial port is used in the following cases:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，串行端口在以下情况下使用：
- en: Extreme cases when the network device is unresponsible
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络设备不可靠的极端情况
- en: For local maintenance in the presence of a technician
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在技术人员在场的情况下进行本地维护
- en: Critical upgrades with the risk of crashes or operation system deletion
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有崩溃或操作系统删除风险的临界升级
- en: Operation system or hardware failure
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统或硬件故障
- en: The network automation should avoid using the serial port to configure the device
    because no parallelism exists (only one port) and its speed is limited.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 网络自动化应避免使用串行端口来配置设备，因为没有并行性（只有一个端口）且其速度有限。
- en: Remote insecure access
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 远程不安全访问
- en: For the reasons explained previously, the serial port is slow and can’t be used
    in parallel. Therefore, the best way to access the network device is via remote
    access, which can be done via **Out-Of-Band** (**OOB**) or in-band management
    (described in [*Chapter 1*](B18165_01.xhtml#_idTextAnchor015)*.*
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于之前解释的原因，串行端口速度较慢，不能并行使用。因此，访问网络设备的最佳方式是通过远程访问，这可以通过**Out-Of-Band**（**OOB**）或带内管理（在[*第1章*](B18165_01.xhtml#_idTextAnchor015)*中描述）来实现。
- en: How to determine whether the access is secure or not will depend on the protocol
    used and what kind of network is used to transport this remote access. If access
    is via an OOB network, it is normally secured and has separated and isolated infrastructure,
    but if it is in-band, some extra care needs to be taken to avoid some common security
    breaches.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如何确定访问是否安全将取决于所使用的协议以及用于传输此远程访问的网络类型。如果通过OOB网络访问，通常它是安全的，并且具有分离和隔离的基础设施，但如果它是带内的，则需要特别注意以避免一些常见的安全漏洞。
- en: Insecure applications and protocols
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不安全的应用和协议
- en: The following applications are normally not encrypted and are easy to eavesdrop
    on, proxy, or hijack.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下应用程序通常未加密，容易被窃听、代理或劫持。
- en: Telnet
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Telnet
- en: Telnet is an application that uses TCP port `23` to access a remote device.
    The data is not encrypted and there is no authentication on the connection. TCP
    hijacking and eavesdropping are the most common security problems when using Telnet.
    To make sure these threats are not present, the network path carrying the access
    must be secured or isolated.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Telnet是一个使用TCP端口`23`来访问远程设备的应用程序。数据未加密，且连接上没有身份验证。在使用Telnet时，TCP劫持和窃听是最常见的安全问题。为了确保这些威胁不存在，承载访问的网络路径必须得到保护或隔离。
- en: Telnet normally requires a password and sometimes a username as well.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Telnet通常需要密码，有时还需要用户名。
- en: RSH
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: RSH
- en: '`514` and does not provide encryption or a password. As IP addresses are used
    to authenticate access, this protocol is extremely insecure and susceptible to
    IP spoofing attacks.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`514`且不提供加密或密码。由于使用IP地址进行身份验证，此协议极其不安全，容易受到IP欺骗攻击。'
- en: If it were not for its lack of security, RSH would be a fast and easy option
    for running commands and creating network automation.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是因为其缺乏安全性，RSH将是一个运行命令和创建网络自动化的快速且简单选项。
- en: Remote secure access
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 远程安全访问
- en: To make sure remote access is secure, the data has to be encrypted and the hosts
    need to have some sort of identity-based authentication to make sure whoever is
    connecting is allowed to connect.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保远程访问安全，数据必须加密，主机需要某种基于身份的认证，以确保连接的人被允许连接。
- en: The most used application for remote CLI access is `22` as the default.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 用于远程CLI访问的最常用的应用程序是默认的`22`。
- en: Identity-based authentication
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于身份的认证
- en: 'The identity-based authentication on SSH is based on a key fingerprint using
    SHA-256 (an encryption algorithm). When SSH is used for the first time, SSH asks
    you to confirm the fingerprint key to make sure the host you are connecting to
    is the correct one. An example of this fingerprint is shown in *Figure 3.3*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: SSH上的基于身份的认证基于SHA-256（一种加密算法）的密钥指纹。当SSH首次使用时，SSH会要求你确认指纹密钥，以确保你连接到的主机是正确的。此指纹的一个示例如图3.3所示：
- en: '![Figure 3.3 – An example of an SSH fingerprint acceptance request ](img/B18165_03_003.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – SSH指纹接受请求的示例](img/B18165_03_003.jpg)'
- en: Figure 3.3 – An example of an SSH fingerprint acceptance request
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – SSH指纹接受请求的示例
- en: 'Although SSH is considered a secure application protocol for accessing devices,
    the identity-based key fingerprint needs to be managed properly to avoid the most
    common attack, called *man-in-the-middle*. This attack redirects the traffic to
    another device, pretends it is the end device, and uses this procedure to capture
    the password of the final target network device, as shown in *Figure 3.4*:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SSH被认为是访问设备的加密应用程序协议，但基于身份的密钥指纹需要得到妥善管理，以避免最常见的攻击，即所谓的*中间人攻击*。这种攻击将流量重定向到另一个设备，假装它是终端设备，并使用此程序捕获最终目标网络设备的密码，如图3.4所示：
- en: '![Figure 3.4 – An example of a man-in-the-middle attack on a network device](img/B18165_03_004.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 – 网络设备中间人攻击的示例](img/B18165_03_004.jpg)'
- en: Figure 3.4 – An example of a man-in-the-middle attack on a network device
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 网络设备中间人攻击的示例
- en: 'There are several ways to avoid a man-in-the-middle attack: one is to make
    sure the network device has an ACL (discussed in [*Chapter 1*](B18165_01.xhtml#_idTextAnchor015))
    that filters incoming IPs that are not part of the management. Another is to make
    sure identity key management is shared with the agent who is requesting remote
    access.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以避免中间人攻击：一种是确保网络设备有一个ACL（在第1章中讨论，[*第1章*](B18165_01.xhtml#_idTextAnchor015)），它可以过滤掉不属于管理的传入IP。另一种是确保与请求远程访问的代理共享身份密钥管理。
- en: Why is this important? Because network automation needs to make sure it uses
    a secure channel to modify the network and the key management is a shared responsibility
    between the network operators and the network automation teams.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这很重要？因为网络自动化需要确保它使用一个安全的通道来修改网络，而密钥管理是网络操作员和网络自动化团队之间的共同责任。
- en: 'Here are some pros and cons of using a CLI for network automation:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用CLI进行网络自动化的优缺点：
- en: '**Pros**:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**:'
- en: Available on almost all network devices
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几乎所有网络设备都支持
- en: Able to access the whole network device’s operating system
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够访问整个网络设备的操作系统
- en: Critical and privileged access
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临界和特权访问
- en: Remote or local access via serial access without a network
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过串行访问进行远程或本地访问，没有网络
- en: '**Cons**:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**:'
- en: Slow
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 慢速
- en: Limited parallel access
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行访问有限
- en: When not correctly used, may allow hackers to interfere
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用不当，可能会允许黑客进行干扰
- en: Interactive, requiring prompt
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交互式，需要即时响应
- en: Data information is not structured (such as JSON or XML), which makes it prone
    to interpretation errors
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据信息没有结构化（如JSON或XML），这使得它容易产生解释错误
- en: To wrap up this section, we’ve covered the usage of the CLI, which is the oldest
    interface known for gathering information from network devices. We also learned
    that a CLI is the only way to collect or configure the device for some network
    devices. One of the important points is that CLI is always present on the network
    device. In the next section, we will see how we can improve the interface of the
    network device for gathering network information, called SNMP.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 总结本节，我们介绍了CLI的使用，CLI是用于从网络设备收集信息的最老接口。我们还了解到，对于某些网络设备，CLI是收集或配置设备的唯一方式。其中一个重要点是CLI始终存在于网络设备上。在下一节中，我们将看到如何改进网络设备的接口以收集网络信息，这被称为SNMP。
- en: Using SNMP
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SNMP
- en: '**Simple Network Management Protocol** (**SNMP**) is perhaps the oldest and
    most used protocol to gather management information from devices. The SNMP specification
    was first published in 1998 in RFC 2261 and was designed to be simple and fast.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单网络管理协议**（**SNMP**）可能是最古老和最常用的协议，用于从设备收集管理信息。SNMP规范首次于1998年在RFC 2261中发布，旨在简单快捷。'
- en: SNMP agents and managers
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SNMP代理和管理器
- en: 'SNMP defines two identities:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: SNMP定义了两个身份：
- en: The manager (or server)
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理器（或服务器）
- en: The agent
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理
- en: The agent is normally a network device and the manager is a network management
    system.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 代理通常是一个网络设备，而管理器是一个网络管理系统。
- en: SNMP uses UDP and TCP as transport protocols with ports `161` and `162`. The
    UDP port `161` is used to gather or set information in an on-demand manner, where
    the manager sends the request to the agent. The UDP port `162` is used asynchronously
    without a request from the manager. The agent sends UDP packets to the server
    whenever necessary. This method is called an SNMP trap and is used to send unsolicited
    messages, such as alarms or threshold-level breaches.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: SNMP使用UDP和TCP作为传输协议，端口为`161`和`162`。UDP端口`161`用于按需收集或设置信息，其中管理器向代理发送请求。UDP端口`162`用于无需管理器请求的异步操作。代理在必要时向服务器发送UDP数据包。这种方法称为SNMP陷阱，用于发送未经请求的消息，如警报或阈值违规。
- en: An SNMP MIB
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SNMP MIB
- en: As described in [*Chapter 1*](B18165_01.xhtml#_idTextAnchor015), a **Management
    Information Base** (**MIB**) is used as an identifier to access the network information
    variable. The identifier is known as an **Object Identifier** (**OID**), as seen
    in *Figure 1.8*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*第一章*](B18165_01.xhtml#_idTextAnchor015)所述，**管理信息库**（**MIB**）用作访问网络信息变量的标识符。该标识符被称为**对象标识符**（**OID**），如*图1.8*所示。
- en: SNMP versions
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SNMP版本
- en: SNMP comes with version 1, version 2c, and version 3\. They were published at
    different times, and the differences are the available methods, transport protocol,
    MIB variables, and cryptography. SNMP agents are compatible backward – therefore,
    an agent that supports version 3 can work with all versions. The following sections
    present a summary of each version.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: SNMP包含版本1、版本2c和版本3。它们在不同的时间发布，差异在于可用方法、传输协议、MIB变量和加密。SNMP代理向后兼容——因此，支持版本3的代理可以与所有版本一起工作。以下各节将总结每个版本。
- en: SNMPv1
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SNMPv1
- en: This is the first version and contains most of the MIB variables and methods.
    It is based on UDP, using a community string as authentication. It only supported
    32-bit MIB counters, which is a problem with fast interfaces, as the counter expires
    quickly.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一个版本，包含了大多数MIB变量和方法。它基于UDP，使用社区字符串作为身份验证。它只支持32位MIB计数器，这对于快速接口来说是一个问题，因为计数器会很快过期。
- en: SNMPv2c
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SNMPv2c
- en: Introduced 64-bit MIB variable counters and the `InformRequest` and `GetBulkRequest`
    methods. Version 2 was not adopted because of security complexity. Version 2c
    was then published with simplifications and was widely accepted.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 引入了64位MIB变量计数器和`InformRequest`以及`GetBulkRequest`方法。由于安全复杂性，版本2没有被采用。随后发布了简化后的版本2c，并得到了广泛接受。
- en: SNMPv3
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SNMPv3
- en: Introduced cryptography for authentication and privacy. The `Report` method
    was added.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 引入了用于身份验证和隐私的加密。增加了`Report`方法。
- en: SNMP primitive methods
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SNMP原始方法
- en: SNMP essentially uses the following primitive methods.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: SNMP本质上使用以下原始方法。
- en: '`GET`: Methods to gather information from the agent:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：从代理获取信息的方法：'
- en: '`GetRequest`: Given an OID, returns the variable associated with it'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetRequest`：给定一个OID，返回与之关联的变量'
- en: '`GetNextRequest`: Given an OID, returns the next OID with the variable associated
    with it (used on an SNMP MIB walk function)'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetNextRequest`：给定 OID，返回与变量相关联的下一个 OID（用于 SNMP MIB 遍历功能）'
- en: '`GetBulkRequest`: Given an OID base, returns all OIDs and variables under this
    OID branch (sometimes causes long responses that can’t be interrupted)'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetBulkRequest`：给定 OID 基，返回此 OID 分支下的所有 OID 和变量（有时会导致无法中断的长响应）'
- en: '`SET`: Methods to set a value on the agent:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SET`：在代理程序上设置值的方 法：'
- en: '`SetRequest`: Given an OID and a value, sets it on the MIB'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetRequest`：给定 OID 和值，在 MIB 上设置它'
- en: '`Response`: All responses for `SET` and `GET`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Response`：`SET` 和 `GET` 的所有响应'
- en: '`TRAP`: Asynchronous information sent from the agent to the manager with an
    OID and a variable'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TRAP`：从代理程序发送到管理器的异步信息，包含 OID 和变量'
- en: '`InformRequest`: Used to send asynchronous information with acknowledgment'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InformRequest`：用于发送带有确认的异步信息'
- en: SNMP security issues
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SNMP 安全问题
- en: Because of a lack of cryptography and authentication, SNMPv1 and v2 are vulnerable
    to IP spoofing attacks, which allow hackers to potentially send `SET` requests
    to agents compromising the network. Historically, because of this security issue,
    SNMP is not used to write configuration and only gathers configuration using the
    `GET` method or `TRAP`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于缺乏加密和认证，SNMPv1 和 v2 易受 IP 欺骗攻击，这允许黑客向代理发送 `SET` 请求，从而危害网络。历史上，由于这个安全问题，SNMP
    不用于写入配置，而只使用 `GET` 方法或 `TRAP` 汇总配置。
- en: 'Here are some pros and cons of using SNMP for network automation:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列举了使用 SNMP 进行网络自动化的优缺点：
- en: '**Pros**:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**：'
- en: Easy to implement
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于实现
- en: Fast
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速
- en: Parallelism is easy
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行性容易
- en: No privileged access
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无特权访问
- en: '**Cons**:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**：'
- en: Requires pooling to gather information frequently
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要汇总以频繁收集信息
- en: Not normally used for writing information
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常不用于写入信息
- en: Very limited scope of data coverage compared to a CLI
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 CLI 相比，数据覆盖范围非常有限
- en: Security issues when writing
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入时的安全问题
- en: As we saw in this section, SNMP is the oldest and most robust protocol for network
    management. Although it has security and scope problems for writing configurations,
    its protocol is light, fast, and easy to read. The following section will cover
    the protocol developed by the IETF working group to fill the gap in network management
    concerning configuration. It is called NETCONF.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本节所述，SNMP 是网络管理中最古老且最健壮的协议。尽管它在写入配置方面存在安全和范围问题，但其协议轻量级、快速且易于阅读。下一节将介绍由 IETF
    工作组开发的协议，以填补网络管理中配置方面的空白。它被称为 NETCONF。
- en: Employing NETCONF
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 NETCONF
- en: The **Network Configuration Protocol** (**NETCONF**) is a network management
    protocol developed and standardized by the IETF in 2006\. It provides mechanisms
    to install, manipulate, and delete the configuration of network devices.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络配置协议**（**NETCONF**）是由 IETF 于 2006 年开发和标准化的网络管理协议。它提供了安装、操作和删除网络设备配置的机制。'
- en: NETCONF operations are implemented on top of a **Remote Procedure Call** (**RPC**)
    layer. The NETCONF protocol uses **Extensible Markup Language** (**XML**)-based
    data encoding for the configuration data as well as the protocol messages. The
    protocol messages can also be exchanged on top of a secure transport protocol
    such as SSH (RFC 6242) or using TLS (RFC 7589).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: NETCONF 操作是在 **远程过程调用**（**RPC**）层上实现的。NETCONF 协议使用基于 **可扩展标记语言**（**XML**）的数据编码来配置数据以及协议消息。协议消息也可以在安全的传输协议（如
    SSH [RFC 6242]）或使用 TLS [RFC 7589] 上进行交换。
- en: Motivation
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: Up until the early part of the 21st century, the only management protocol available
    from IETF was SNMP, which was developed in the late 1980s. It became clear that
    despite what was originally intended, SNMP was not being used to configure network
    equipment and was mainly being used for gathering network device information (as
    we have seen previously). The reasons are various, but mainly because SNMP was
    insecure and had a limited scope compared to a CLI for instance.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 直到 21 世纪初的早期，IETF 可用的唯一管理协议是 SNMP，该协议于 20 世纪 80 年代末期开发。很明显，尽管最初的目的如此，但 SNMP
    并未用于配置网络设备，而主要用于收集网络设备信息（如我们之前所见）。原因多种多样，但主要是由于与 CLI 相比，SNMP 不安全且范围有限。
- en: In June 2002, the network management community and the Internet Architecture
    Board got together with network key operators to discuss the real situation on
    network management protocols and usage. The results of this meeting are documented
    in RFC 3535 ([https://datatracker.ietf.org/doc/html/rfc3535](https://datatracker.ietf.org/doc/html/rfc3535)).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 2002年6月，网络管理社区和互联网架构委员会与网络关键运营商一起讨论了网络管理协议和使用的实际情况。这次会议的结果记录在RFC 3535中 ([https://datatracker.ietf.org/doc/html/rfc3535](https://datatracker.ietf.org/doc/html/rfc3535))。
- en: It turned out that network operators, instead of using SNMP, were primarily
    using different proprietary CLIs to configure their network devices. The reasons
    were various, including security issues and the lack of scope to configure or
    write configs because SNMP was too rigid to do so.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，网络运营商并没有使用SNMP，而是主要使用不同的专有CLI来配置他们的网络设备。原因多种多样，包括安全问题以及由于SNMP过于僵化而无法配置或编写配置的缺乏。
- en: On the other hand, around this time, Juniper Networks had started to use an
    XML-based network management approach, which was seen by IETF and the network
    operator community as an opportunity to combine efforts. This led to the creation
    of the NETCONF working group in May 2003.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在这个时候，Juniper Networks已经开始使用基于XML的网络管理方法，这在IETF和网络运营商社区看来是一个结合力量的机会。这导致了2003年5月NETCONF工作组的成立。
- en: In December 2006, with a lot of help from Juniper Networks, the first version
    of the base NETCONF protocol was published, RFC 4741 ([https://datatracker.ietf.org/doc/html/rfc4741](https://datatracker.ietf.org/doc/html/rfc4741)).
    After that, several extensions were published in subsequent years (RFC 5277, RFC
    5717, RFC 6243, RFC 6470, and RFC 6536, among others). The last revised version
    of NETCONF is documented in RFC 6241, published in June 2011 (updated by RFC 7803
    and RFC 8526).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 2006年12月，在Juniper Networks的大力帮助下，发布了第一个版本的基NETCONF协议，RFC 4741 ([https://datatracker.ietf.org/doc/html/rfc4741](https://datatracker.ietf.org/doc/html/rfc4741))。此后，在随后的几年中发布了几个扩展（RFC
    5277、RFC 5717、RFC 6243、RFC 6470和RFC 6536等）。NETCONF的最后修订版记录在RFC 6241中，于2011年6月发布（由RFC
    7803和RFC 8526更新）。
- en: OpenConfig
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenConfig
- en: '**OpenConfig** is an informal working group of network operators sharing the
    goal of moving our networks toward a more dynamic, programmable infrastructure
    by adopting SDN principles such as declarative configuration and model-driven
    management and operations.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenConfig**是一个由网络运营商组成的非正式工作组，他们共同的目标是通过采用SDN原则，如声明性配置和模型驱动的管理和操作，将我们的网络推向更动态、可编程的基础设施。'
- en: Our initial focus in OpenConfig is on compiling a consistent set of vendor-neutral
    data models – written in **Yet Another Next Generation** (**YANG**) – based on
    the actual operational needs from use cases and requirements from multiple network
    operators.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenConfig中，我们的初步重点是编译一套一致的无厂商数据模型——用**Yet Another Next Generation** (**YANG**)编写——基于来自多个网络运营商的实际操作需求和需求。
- en: YANG
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: YANG
- en: YANG is a data modeling language that is used by the NETCONF protocol. YANG
    can be used to model both configuration data and state data from network devices.
    It is a modular language representing data structures in the XML format but can
    also be represented by other formats.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: YANG是一种数据建模语言，它被NETCONF协议所使用。YANG可以用来建模网络设备中的配置数据和状态数据。它是一种模块化语言，以XML格式表示数据结构，但也可以用其他格式表示。
- en: For each network device feature, at least one RFC describes the data model with
    YANG – for instance, VRRP (in [*Chapter 2*](B18165_02.xhtml#_idTextAnchor041))
    describes the YANG data model in RFC 8347 ([https://datatracker.ietf.org/doc/html/rfc8347](https://datatracker.ietf.org/doc/html/rfc8347)).
    Another effort to cover network ACLs (see [*Chapter 1*](B18165_01.xhtml#_idTextAnchor015))
    describes the YANG models in RFC 8519 ([https://datatracker.ietf.org/doc/html/rfc8519](https://datatracker.ietf.org/doc/html/rfc8519)).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个网络设备功能，至少有一个RFC使用YANG描述数据模型——例如，VRRP（在[*第2章*](B18165_02.xhtml#_idTextAnchor041)）中描述了RFC
    8347中的YANG数据模型 ([https://datatracker.ietf.org/doc/html/rfc8347](https://datatracker.ietf.org/doc/html/rfc8347))。另一个覆盖网络ACLs的努力（见[*第1章*](B18165_01.xhtml#_idTextAnchor015)）描述了RFC
    8519中的YANG模型 ([https://datatracker.ietf.org/doc/html/rfc8519](https://datatracker.ietf.org/doc/html/rfc8519))）。
- en: Let’s examine the characteristics of YANG and the details of the model a bit
    more closely.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地考察YANG的特点和模型细节。
- en: The data modeling process is hard
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据建模过程是困难的
- en: 'It is important to understand that creating a YANG data model for a router
    function is not an easy task because it has to accommodate possible scenarios
    from the existing methods of all possible devices. So, it is not a fresh start
    from scratch, but the task of modeling functions that are already in use in several
    vendors and devices. Let’s take one example – the YANG data model for **Routing
    Policy**. As you can see on the timeline shown in *Figure 3.5*, the work started
    in 2015, and after more than 30 drafts, the standard was finally published in
    October 2021, which meant it took almost 7 years:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 需要理解的是，为路由器功能创建 YANG 数据模型不是一项容易的任务，因为它必须适应所有可能设备现有方法的可能场景。因此，这并不是从头开始，而是对已在多个供应商和设备中使用的功能进行建模的任务。让我们以一个例子为例
    – 路由策略的 YANG 数据模型。如图 3.5 所示的时序图所示，这项工作始于 2015 年，经过 30 多个草案后，该标准终于在 2021 年 10 月发布，这意味着它几乎花了
    7 年时间：
- en: '![Figure 3.5 – Timeline for creating a YANG data model for Routing Policy](img/B18165_03_005.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – 创建路由策略 YANG 数据模型的时序图](img/B18165_03_005.jpg)'
- en: Figure 3.5 – Timeline for creating a YANG data model for Routing Policy
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 创建路由策略 YANG 数据模型的时序图
- en: It would be easier if each vendor had its own YANG data model, but then that
    would remove the general dependency.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个供应商都有自己的 YANG 数据模型会更容易，但那样就会消除通用依赖。
- en: NETCONF
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NETCONF
- en: NETCONF uses client-server communication based on RPCs. With NETCONF, server
    configurations are stored in a NETCONF configuration datastore that follows a
    YANG data format specification. To change or update data, a client sends an XML-based
    remote procedure call over one of the secure transfer methods, and the server
    replies with XML-encoded data.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: NETCONF 使用基于 RPC 的客户端-服务器通信。使用 NETCONF，服务器配置存储在遵循 YANG 数据格式规范的 NETCONF 配置数据存储中。要更改或更新数据，客户端通过一种安全传输方法发送基于
    XML 的远程过程调用，服务器以 XML 编码的数据回复。
- en: 'NETCONF has four layers, as shown in *Figure 3.6*, extracted from the original
    RFC 6241:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: NETCONF 有四个层次，如图 3.6 所示，摘自原始 RFC 6241：
- en: '![Figure 3.6 – The four layers described in the RFC 6241](img/B18165_03_006.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – RFC 6241 中描述的四个层次](img/B18165_03_006.jpg)'
- en: Figure 3.6 – The four layers described in the RFC 6241
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – RFC 6241 中描述的四个层次
- en: 'Let’s summarize each of the layers:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结每一层：
- en: '**Content** layer: Consists of configuration data and notification data. Valid
    content is defined in the YANG specification.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内容**层：由配置数据和通知数据组成。有效内容在 YANG 规范中定义。'
- en: '`get`, `get-config`, `edit-config`, `copy-config`, `delete-config`, `lock`,
    `unlock`, `close-session`, and `kill-session`.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get`、`get-config`、`edit-config`、`copy-config`、`delete-config`、`lock`、`unlock`、`close-session`
    和 `kill-session`。'
- en: '`<rpc>` request from a client or a `<rpc-reply>` from a server. RFC6241 also
    added notifications to this layer.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自客户端的 `<rpc>` 请求或来自服务器的 `<rpc-reply>`。RFC6241 还向此层添加了通知。
- en: '**Secure Transport** layer: This layer deals with the protocols used to transmit
    NETCONF messages. SSH, TLS, and HTTP are a few of the protocols associated with
    this layer.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全传输**层：此层处理用于传输 NETCONF 消息的协议。SSH、TLS 和 HTTP 是与此层关联的几个协议。'
- en: RESTCONF
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RESTCONF
- en: 'The RESTCONF protocol is a proposed standard defined in RFC 8040 ([https://www.rfc-editor.org/rfc/rfc8040.html](https://www.rfc-editor.org/rfc/rfc8040.html)).
    NETCONF and RESTCONF are similar in terms of their capabilities, but RESTCONF
    came later in 2017 with a **Representational State Transfer** (**REST**)**ful
    API** model using HTTP. They both allow administrators to query information or
    modify settings using a client-server model. RESTCONF is different in a few key
    ways:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: RESTCONF 协议是在 RFC 8040 中定义的提议标准（[https://www.rfc-editor.org/rfc/rfc8040.html](https://www.rfc-editor.org/rfc/rfc8040.html)）。NETCONF
    和 RESTCONF 在功能方面相似，但 RESTCONF 在 2017 年晚些时候出现，使用基于 HTTP 的 **表示状态转移**（**REST**）**API**
    模型。它们都允许管理员使用客户端-服务器模型查询信息或修改设置。RESTCONF 在几个关键方面有所不同：
- en: RESTCONF uses HTTP
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RESTCONF 使用 HTTP
- en: RESTCONF supports both JSON and XML
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RESTCONF 支持 JSON 和 XML
- en: RESTCONF does not have the concept of transaction and therefore does not have
    the `lock` concept as NETCONF does
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RESTCONF 没有事务的概念，因此没有像 NETCONF 那样的 `lock` 概念。
- en: RESTCONF is not intended to replace NETCONF. Rather, it was created to allow
    the use of a RESTful API that can be used to query and configure devices with
    NETCONF or YANG configuration datastores.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: RESTCONF 并不打算取代 NETCONF。相反，它被创建出来，以便可以使用 RESTful API，该 API 可以用于使用 NETCONF 或
    YANG 配置数据存储查询和配置设备。
- en: '*Figure 3.7* shows a table extracted from RFC 8040 that demonstrates the overlap
    between RESTCONF and NETCONF calls:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.7* 展示了一个从RFC 8040中提取的表格，展示了RESTCONF和NETCONF调用的重叠：'
- en: '![Figure 3.7 – The overlap between RESTCONF and NETCONF methods extracted from
    RFC 8040](img/B18165_03_007.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图3.7 – 从RFC 8040中提取的RESTCONF和NETCONF方法的重叠](img/B18165_03_007.jpg)'
- en: Figure 3.7 – The overlap between RESTCONF and NETCONF methods extracted from
    RFC 8040
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 – 从RFC 8040中提取的RESTCONF和NETCONF方法的重叠
- en: 'Here are some pros and cons of using NETCONF or RESTCONF:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用NETCONF或RESTCONF的一些优缺点：
- en: '**Pros**:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**：'
- en: Incorporate network specification
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成网络规范
- en: IETF standards
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IETF标准
- en: No privileged access
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无特权访问
- en: Allow stream event notifications
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许流事件通知
- en: Programmatic device configuration
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序化设备配置
- en: '**Cons**:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**：'
- en: Not all device capabilities are covered in YANG
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: YANG没有涵盖所有设备功能
- en: Adoption of NETCONF has been really slow
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NETCONF的采用速度非常慢
- en: NETCONF transport is limited and implementation is old
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NETCONF传输有限且实现过时
- en: Not that efficient
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 效率不高
- en: This section summarizes how NETCONF, RESTCONF, and YANG are used to interact
    with network devices. The transaction states of NETCONF make it a powerful tool
    for network configuration. Despite its good base of IETF standards, NETCONF is
    not efficient enough to handle some of the network automation we want, such as
    collecting data at a high-frequency rate. In the following section, we are going
    to explore a newer protocol called gRPC.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 本节总结了如何使用NETCONF、RESTCONF和YANG与网络设备进行交互。NETCONF的事务状态使其成为网络配置的强大工具。尽管它基于良好的IETF标准，但NETCONF在处理一些我们想要的网络自动化任务（如以高频率收集数据）方面效率并不足够。在下一节中，我们将探讨一个名为gRPC的新协议。
- en: Adopting gRPC
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采用gRPC
- en: '**gRPC** was published in 2015 as an open source RPC framework. It is one of
    the most promising protocols to be used in automation because it is easy to create
    a program and add methods to obtain or set configuration on the network device.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**gRPC**于2015年作为一个开源RPC框架发布。由于它易于创建程序并添加方法以在网络上获取或设置配置，因此它是自动化中最有前途的协议之一。'
- en: 'gRPC does not directly use TCP for transport, but HTTP/2 instead, which was
    published in 2015 to overcome the limitations of HTTP/1.1\. While it is backward
    compatible with HTTP/1.1, HTTP/2 brings many added advanced capabilities, such
    as the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC并不直接使用TCP进行传输，而是使用HTTP/2，该协议于2015年发布，旨在克服HTTP/1.1的限制。虽然它与HTTP/1.1向后兼容，但HTTP/2带来了许多额外的先进功能，如下所示：
- en: '**Binary framing layer**: Request and response is divided into small messages
    and framed in binary format, making message transmission efficient'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二进制帧层**：请求和响应被划分为小消息并以二进制格式进行封装，使消息传输更高效'
- en: '**Bidirectional full-duplex streaming**: Here, the client can request and the
    server can respond simultaneously'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双向全双工流**：在这里，客户端可以请求，服务器可以同时响应'
- en: '**Flow control (used in HTTP/2)**: Enables the detailed control of memory used
    for the network buffers'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流控制（用于HTTP/2）**：允许对网络缓冲区使用的内存进行详细控制'
- en: '**Header compression**: Everything in HTTP/2, including headers, is encoded
    before it is sent, significantly improving performance'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**头部压缩**：在发送之前，HTTP/2中的所有内容（包括头部）都会进行编码，这显著提高了性能'
- en: '**Asynchronous and synchronous processing**: Can be used to perform different
    types of interaction and streaming RPCs'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步和同步处理**：可用于执行不同类型的交互和流式RPC'
- en: All these features of HTTP/2 enable gRPC to use fewer resources, resulting in
    reduced response times between clients and servers.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些HTTP/2的特性使得gRPC能够使用更少的资源，从而减少了客户端和服务器之间的响应时间。
- en: To ensure the security of gRPC, TLS end-to-end encryption can be used, and authentication
    can use SSL or TLS with or without token-based authentication or the need to define
    your own authentication system by extending the provided code (more on authentication
    can be found at [https://grpc.io/docs/guides/auth/](https://grpc.io/docs/guides/auth/)).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保gRPC的安全性，可以使用端到端加密的TLS，并且可以使用SSL或TLS进行身份验证，无论是否基于令牌的身份验证或需要通过扩展提供的代码来定义自己的身份验证系统（更多关于身份验证的信息可以在[https://grpc.io/docs/guides/auth/](https://grpc.io/docs/guides/auth/)找到）。
- en: The letter g
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字母g
- en: 'Initially, in version 1.0 of the protocol, the letter *g* was a recursive reference
    to the name gRPC, but as later versions were published, another word was added,
    making the name a bit of code entertainment. For instance, in version 1.1, the
    word was *good*, in version 1.2, it was *green*, and for version 1.42, it was
    *granola*. A complete list of names used for the letter *g* can be found in the
    gRPC source code here: [https://grpc.github.io/grpc/core/md_doc_g_stands_for.html](https://grpc.github.io/grpc/core/md_doc_g_stands_for.html).'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在协议的1.0版本中，字母*g*是对gRPC名称的递归引用，但随着后续版本的发布，又添加了另一个单词，使得名称成为了一点代码娱乐。例如，在1.1版本中，这个单词是*good*，在1.2版本中，它是*green*，而在1.42版本中，它是*granola*。用于字母*g*的完整名称列表可以在gRPC源代码中找到：[https://grpc.github.io/grpc/core/md_doc_g_stands_for.html](https://grpc.github.io/grpc/core/md_doc_g_stands_for.html).
- en: Motivation
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: Google has used a single general-purpose RPC infrastructure called **Stubby**
    to connect the large number of microservices running within and across Google
    data centers for more than a decade. That motivated Google to publish and sponsor
    the creation of gRPC.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌已经使用了一个名为**Stubby**的单个通用RPC基础设施，连接了在谷歌数据中心内部和跨数据中心运行的大量微服务超过十年。这促使谷歌发布并赞助了gRPC的创建。
- en: Letter from the gRPC team on Monday, October 26, 2015
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年10月26日星期一gRPC团队的信件
- en: '*The gRPC team is excited to announce the immediate availability of gRPC Beta.
    This release represents a major step forward in API stability, with most API changes
    in the future being additive in nature. It opens the door for gRPC use in production
    environments.*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*gRPC团队很高兴地宣布gRPC Beta的立即可用性。这次发布代表了API稳定性的重大进步，未来的大多数API更改都是添加性的。它为gRPC在生产环境中的应用打开了大门。*'
- en: '*We updated grpc.io documentation to reflect the latest changes and released
    language-specific reference documentation. In the release notes on GitHub for
    Java, Go, and all other languages, you will find information on what has changed.*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们更新了grpc.io文档以反映最新的变化，并发布了特定语言的参考文档。在GitHub上Java、Go和其他所有语言的发布说明中，您可以找到有关更改的信息。*'
- en: '*We would like to thank everyone who contributed code, gave presentations,
    adopted the technology, and participated in the community. We look forward to
    1.0 with your support!*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们感谢所有贡献代码、进行演示、采用这项技术并参与社区的人。我们期待在您的支持下推出1.0版本！*'
- en: Overview
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: gRPC uses the concept of a client and server application. Client applications
    can directly invoke server applications on remote machines just as if they were
    local objects. gRPC is based on the idea of defining a service and specifying
    methods that can be called remotely using their parameters and return types. The
    server implements this interface and runs a gRPC server to handle client calls.
    The client has a stub (just referred to as a client in some languages) that provides
    the same methods as the server.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC使用客户端和服务器应用程序的概念。客户端应用程序可以直接调用远程机器上的服务器应用程序，就像它们是本地对象一样。gRPC基于定义一个服务和指定可以通过它们的参数和返回类型远程调用的方法的想法。服务器实现这个接口并运行gRPC服务器来处理客户端调用。客户端有一个存根（在某些语言中仅称为客户端），它提供了与服务器相同的方法。
- en: 'In the world of network automation, the gRCP client is actually our automation
    software and the gRPC server is the network device, as illustrated in *Figure
    3.8*:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络自动化的世界中，gRCP客户端实际上是我们的自动化软件，而gRPC服务器是网络设备，如图*图3.8*所示：
- en: '![Figure 3.8 – Basic request and response for gRPC](img/B18165_03_008.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图3.8 – gRPC的基本请求和响应](img/B18165_03_008.jpg)'
- en: Figure 3.8 – Basic request and response for gRPC
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 – gRPC的基本请求和响应
- en: 'The gRPC server and client are not required to use the same programming language.
    Today, there are several implementations of different languages, whether Go, Python,
    Java, or Ruby. A complete list of the languages supported can be found here: [https://grpc.io/docs/languages/](https://grpc.io/docs/languages/).'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC服务器和客户端不需要使用相同的编程语言。如今，有几种不同语言的实现，无论是Go、Python、Java还是Ruby。支持的语言完整列表可以在这里找到：[https://grpc.io/docs/languages/](https://grpc.io/docs/languages/).
- en: Protobuf
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Protobuf
- en: By default, gRPC uses **Protocol Buffers** (**Protobuf**), which is another
    open source mechanism for serializing data created by Google. Although Protobuf
    is the default, gRPC can also use JSON instead, but that is less efficient, as
    we are going to see.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，gRPC使用**协议缓冲区**（**Protobuf**），这是由谷歌创建的另一种用于序列化数据的开源机制。尽管Protobuf是默认的，但gRPC也可以使用JSON，但那效率较低，我们将在后面看到。
- en: Protobuf is a language- and platform-neutral mechanism for serializing data,
    like JSON or XML but much smaller, faster, and simpler. The structure of the data
    is defined once and then a specially generated source code is used to easily write
    and read this structured data from a variety of data streams with any programming
    language.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Protobuf 是一种语言和平台无关的数据序列化机制，类似于 JSON 或 XML，但更小、更快、更简单。数据结构一旦定义，就使用特别生成的源代码来轻松地从各种数据流中用任何编程语言写入和读取这种结构化数据。
- en: 'More about Protobuf can be found here: [https://developers.google.com/protocol-buffers](https://developers.google.com/protocol-buffers).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 Protobuf 的信息可以在这里找到：[https://developers.google.com/protocol-buffers](https://developers.google.com/protocol-buffers)。
- en: gRPC and network telemetry
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: gRPC 和网络遥测
- en: During our network automation work, we are going to experience a series of limitations,
    especially in gathering network information in an effective way. So, let’s explore
    the following example.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的网络自动化工作中，我们将遇到一系列限制，尤其是在有效收集网络信息方面。因此，让我们探讨以下示例。
- en: Imagine a network with 500 devices, with 50 interfaces on each device on average.
    Each interface needs to gather multiple variables, such as the current state,
    the error rate, drop counts, packet-in counts, or packet-out counts. If we consider
    a conservative approach, such as only collecting 10 variables per interface, for
    this network example, we are going to gather information from 10 variables x 50
    interfaces x 500 devices, which adds up to 250,000 variables.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个有 500 台设备的网络，每台设备平均有 50 个接口。每个接口需要收集多个变量，例如当前状态、错误率、丢弃计数、入包计数或出包计数。如果我们考虑一种保守的方法，例如每个接口只收集
    10 个变量，对于这个网络示例，我们将从 10 个变量 x 50 个接口 x 500 台设备的信息中收集数据，总计 250,000 个变量。
- en: The other point to consider is the frequency of the data. In the 90s, network
    management required information from the network every 5 minutes and that was
    sufficient for handling failures and troubleshooting, but nowadays, the interval
    is much smaller. We are looking to gather information at intervals of less than
    1 minute, ideally every 30 or 10 seconds. The reason is that troubleshooting and
    failure resolution can occur faster when detecting failures quickly.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要考虑的是数据的频率。在 90 年代，网络管理需要每 5 分钟从网络获取信息，这对于处理故障和故障排除来说是足够的，但如今，间隔要小得多。我们希望以每分钟不到
    1 秒的间隔收集信息，理想情况下是每 30 秒或 10 秒。原因是当快速检测到故障时，故障排除和故障解决可以更快地进行。
- en: So, in our example, 250,000 variables every 10 seconds give us an enormous amount
    of data using traditional polling mechanisms such as SNMP. However, one important
    point to note here is most of the content of the variables might not change at
    all, such as the counters for interfaces when there is no traffic, the state of
    the interface when nothing has changed, the interface discard counter when there
    aren’t any, or the error rate when the interface is perfectly fine. Therefore,
    several or even the majority of the contents of the network variables are not
    going to change that often, meaning that pooling mechanisms are inefficient and
    accumulate redundant information over time. What would be better than polling?
    Streaming telemetry. Streaming telemetry allows devices to send incremental updates
    continuously as soon as changes occur. In this way, the collection of network
    information can be done more effectively than with pooling.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的示例中，每 10 秒收集 250,000 个变量，使用传统的轮询机制（如 SNMP）会产生大量数据。然而，这里的一个重要观点是，变量的大部分内容可能根本不会改变，例如在没有流量时接口的计数器、接口状态没有变化时的接口状态、没有流量时的接口丢弃计数器，或者接口完全正常时的错误率。因此，网络变量的内容不会经常改变，这意味着轮询机制效率低下，并且随着时间的推移积累冗余信息。什么比轮询更好？流式遥测。流式遥测允许设备在变化发生时立即连续发送增量更新。这样，网络信息的收集可以比轮询更有效地进行。
- en: gRPC supports bidirectional streaming, which gives this protocol a huge advantage
    compared to the others we saw so far for data collection.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 支持双向流，这使得该协议在数据收集方面比我们之前看到的其他协议具有巨大优势。
- en: Code examples using gRPC
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 gRPC 的代码示例
- en: 'To make the example more realistic for network automation, let’s have a service
    on the routers that can return the following information:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使示例更符合网络自动化的实际情况，让我们在路由器上设置一个可以返回以下信息的服务：
- en: Return the memory utilization in percent
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回内存利用率（百分比）
- en: Return the CPU utilization in percent
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回 CPU 利用率（百分比）
- en: Return the router uptime in seconds
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回路由器运行时间（秒）
- en: Our examples will create a client gRPC stub to communicate to the router, which
    will be the gRPC server, as depicted in *Figure 3.8*. We are only going to demonstrate
    the client side and we are going to assume the gRPC server on the router has already
    been implemented.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例将创建一个客户端gRPC存根以与路由器通信，该路由器将作为gRPC服务器，如图3.8所示。我们只将演示客户端，并假设路由器上的gRPC服务器已经实现。
- en: The Protobuf file
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Protobuf文件
- en: 'The Protobuf file definition is a single part of the code that is not tied
    to any language. The same file definition is used on the client and the server.
    It is compiled once and feeds the client and server programs to interpret the
    data used to generate the RPCs. For our example, the Protobuf file would look
    as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Protobuf文件定义是代码的一个部分，它与任何语言无关。相同的文件定义在客户端和服务器上使用。它编译一次，为客户端和服务器程序提供解释用于生成RPC的数据。对于我们的示例，Protobuf文件将如下所示：
- en: '[PRE0]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: An example using Python
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Python的示例
- en: 'Here is an example using Python. The import name, `r_grpc`, compiles the code
    for Python from the Protobuf file:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用Python的示例。导入名称`r_grpc`从Protobuf文件编译Python代码：
- en: '[PRE1]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: An example using Go
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Go的示例
- en: 'Here is an example using a Go program client. Note that `pb` (used on the import)
    is the code compiled for the Protobuf:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用Go程序客户端的示例。请注意，`pb`（在导入中使用）是针对Protobuf编译的代码：
- en: '[PRE2]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here are some pros and cons of using gRPC for network automation:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用gRPC进行网络自动化的优缺点如下：
- en: '**Pros**:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**：'
- en: Secure
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全
- en: Fast
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速
- en: Parallelism is easy
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行处理很容易
- en: No privileged access is possible
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法进行特权访问
- en: Flexible and can expose any local device command using the gRPC server
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灵活，可以使用gRPC服务器暴露任何本地设备命令
- en: '**Cons**:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**：'
- en: Not many network devices have gRPC capability
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很少有网络设备具备gRPC功能
- en: In this section, we saw that gRPC is a powerful protocol to use for network
    automation. However, it is not well integrated into network devices yet. The majority
    of the new operating systems on network devices come with this capability. In
    the next section, a higher-level protocol called gNMI will be used to make better
    use of the gRPC protocol for network automation.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解到gRPC是一个用于网络自动化的强大协议。然而，它尚未很好地集成到网络设备中。大多数新的网络设备操作系统都自带这种功能。在下一节中，将使用一个名为gNMI的高级协议来更好地利用gRPC协议进行网络自动化。
- en: Operating with gNMI
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用gNMI操作
- en: As we saw before, gRPC is probably the most appropriate protocol for working
    with devices in terms of performance. However, it is actually a generic protocol
    to be used in any client and server interaction – not only network devices but
    also computer servers. For this reason, **gRPC Network Management Interface**
    (**gNMI**) was created.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如前文所述，gRPC可能是性能方面与设备协同工作的最合适的协议。然而，它实际上是一个通用的协议，可用于任何客户端和服务器交互——不仅限于网络设备，还包括计算机服务器。因此，**gRPC网络管理接口**（**gNMI**）被创建出来。
- en: gNMI is an open source protocol specification created by the OpenConfig working
    group that is used to communicate to and from network devices using YANG (discussed
    in the *NETCONF* section). In other words, gNMI was created to utilize the good
    work done by people defining the network specification data using YANG but with
    a more modern protocol such as gRPC instead of NETCONF.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: gNMI是由OpenConfig工作组创建的开源协议规范，用于使用YANG（在*NETCONF*部分中讨论）与网络设备进行通信。换句话说，gNMI是为了利用定义网络规范数据的人所做的良好工作而创建的，但使用的是更现代的协议gRPC而不是NETCONF。
- en: Protocol layers
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协议层
- en: gNMI uses gRPC. For that, it has to translate the YANG data description into
    Protobuf to serialize the communication, as illustrated in *Figure 3.9*. At the
    bottom of the diagram is a normal gRPC connection over HTTP/2 and TLS. The gRPC
    code is auto-generated from the gNMI Protobuf model and gNMI carries the data
    modeled in YANG, which can support encoding in JSON, like the example below.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: gNMI使用gRPC。为此，它必须将YANG数据描述转换为Protobuf以序列化通信，如图3.9所示。图的最底部是一个正常的基于HTTP/2和TLS的gRPC连接。gRPC代码是从gNMI
    Protobuf模型自动生成的，gNMI携带在YANG中建模的数据，可以支持像下面示例中的JSON编码。
- en: '![Figure 3.9 – gNMI protocol layers](img/B18165_03_009.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图3.9 – gNMI协议层](img/B18165_03_009.jpg)'
- en: Figure 3.9 – gNMI protocol layers
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 – gNMI协议层
- en: The data model
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据模型
- en: gNMI uses a data model called `PathElem` messages. Each `PathElem` consists
    of a name encoded as a string. An element’s name must be encoded as a `PathElem`
    may optionally specify a set of keys, specified as a `map<string,string>` (dictionary
    or map).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: gNMI 使用一种名为 `PathElem` 的数据模型消息。每个 `PathElem` 包含一个编码为字符串的名称。一个元素名称必须编码为 `PathElem`
    可以选择指定一组键，指定为 `map<string,string>`（字典或映射）。
- en: 'The root path, `/`, is encoded as a zero-length array (slice) of `PathElem`
    messages. Here are some example declarations in Go and Python:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 根路径 `/` 编码为零长度的 `PathElem` 消息数组（切片）。以下是在 Go 和 Python 中的示例声明：
- en: '`path := []*PathElem{}`'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path := []*PathElem{}`'
- en: '`path = []`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path = []`'
- en: A human-readable path can be formed by concatenating elements of the prefix
    and path using the `/` separator.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用 `/` 分隔符连接前缀和路径的元素来形成可读的路径。
- en: 'So, let’s see the following representation: `/interfaces/interface[name=Ethernet1/2/3]/state.`'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看以下表示：`/interfaces/interface[name=Ethernet1/2/3]/state.`
- en: 'This is specified as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这如下所示：
- en: '[PRE3]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The communication model
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通信模型
- en: 'The communication model uses a target and client as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 通信模型使用目标客户端如下：
- en: '**Target**: The device within the gNMI that acts as the owner of the data that
    is being manipulated or collected. Typically, this is our network device.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标**：在 gNMI 中作为正在操作或收集的数据的所有者的设备。通常，这是我们的网络设备。'
- en: '**Client or collector:** The system using the gNMI to query or modify data
    on the target or act as a collector for streamed data. Typically, this is the
    network management system or our automation code.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端或收集器：** 使用 gNMI 查询或修改目标上的数据或作为流数据的收集器的系统。通常，这是网络管理系统或我们的自动化代码。'
- en: 'Similar to gRPC, the server actually is on the network device, as depicted
    in *Figure 3.10*:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 与 gRPC 类似，服务器实际上位于网络设备上，如 *图 3.10* 所示：
- en: "![Figure 3.10 – gNMI \uFEFFtarget and \uFEFFclient communication](img/B18165_03_010.jpg)"
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.10 – gNMI 目标和客户端通信](img/B18165_03_010.jpg)'
- en: Figure 3.10 – gNMI target and client communication
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – gNMI 目标和客户端通信
- en: Service definition
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务定义
- en: The gNMI service is based on RPC calls called `Capabilities`, `Get`, `Set`,
    and `Subscribe`, which will be detailed in the following sections.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: gNMI 服务基于名为 `Capabilities`、`Get`、`Set` 和 `Subscribe` 的 RPC 调用，这些将在以下章节中详细介绍。
- en: Capabilities RPC
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 功能 RPC
- en: A client can discover the capabilities of the target using the `CapabilityRequest`
    message is sent by the client to interrogate the target. The target must then
    reply with a `CapabilityResponse` message that includes its gNMI service version,
    the versioned data models it supports, and the supported data encodings. This
    information is used in subsequent RPC messages from the client to indicate the
    set of models that the client will use for the `Get` and `Subscribe` RPC calls
    and the encoding to be used for the data.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以使用 `CapabilityRequest` 消息来发现目标的功能。客户端发送此消息以查询目标。然后，目标必须回复一个包含其 gNMI 服务版本、它支持的数据模型版本以及支持的数据编码的
    `CapabilityResponse` 消息。这些信息用于客户端后续的 RPC 消息，以指示客户端将用于 `Get` 和 `Subscribe` RPC
    调用的模型集以及用于数据的编码。
- en: Get RPC
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取 RPC
- en: The `GetRequest` message to the target, specifying the path that is to be retrieved.
    Upon reception of the `GetRequest` message, the target serializes the requested
    path and returns a `GetResponse` message. This connection is short-lived and the
    target closes the `Get` RPC following the transmission of the `GetResponse` message.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 向目标发送 `GetRequest` 消息，指定要检索的路径。在接收到 `GetRequest` 消息后，目标序列化请求的路径并返回一个 `GetResponse`
    消息。此连接是短暂的，目标在传输 `GetResponse` 消息后关闭 `Get` RPC。
- en: Set RPC
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置 RPC
- en: Modifications to the state of the target are made through the `SetRequest` message
    to the target indicating the modifications it desires.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向目标发送 `SetRequest` 消息来对目标的状态进行修改，以指示它希望进行的修改。
- en: A target receiving a `SetRequest` message processes the operations specified
    within it, which are treated as a transaction. In response to a `SetRequest` message,
    the target must respond with a `SetResponse` message. For each operation specified
    in the `SetReques`t message, an `UpdateResult` message must be included in the
    response field of `SetResponse`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 接收 `SetRequest` 消息的目标会处理其中指定的操作，这些操作被视为一个事务。作为对 `SetRequest` 消息的响应，目标必须回复一个
    `SetResponse` 消息。对于 `SetRequest` 消息中指定的每个操作，必须在 `SetResponse` 的响应字段中包含一个 `UpdateResult`
    消息。
- en: Subscribe RPC
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 订阅 RPC
- en: This perhaps is the most important call on the gNMI because it is the one that
    allows Streaming Telemetry, as discussed before.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是gNMI上最重要的调用，因为它允许流式遥测，正如之前讨论的那样。
- en: When a client wishes to receive updates relating to the state of data instances
    on a target, it creates a subscription via the **Subscribe RPC**. A subscription
    consists of one or more paths, with a specified subscription mode. The mode of
    each subscription determines the triggers for updates to the data sent from the
    target to the client.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端希望接收有关目标上数据实例状态更新的信息时，它通过 **Subscribe RPC** 创建一个订阅。订阅由一个或多个路径组成，并指定了订阅模式。每个订阅的模式决定了从目标发送到客户端的数据更新的触发器。
- en: All requests for new subscriptions are encapsulated within a `SubscribeRequest`
    message, which itself has a mode describing the longevity of the subscription.
    A client may create a subscription that has a dedicated stream to return one-off
    data (`ONCE`); a subscription that utilizes a stream to periodically request a
    set of data (`POLL`); or a long-lived subscription that streams data according
    to the triggers specified within the individual subscription’s mode (`STREAM`).
    For Streaming Telemetry, the mode is set to `STREAM`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 所有新的订阅请求都被封装在一个`SubscribeRequest`消息中，该消息本身有一个模式，描述了订阅的持久性。客户端可以创建一个订阅，该订阅有一个专门的流来返回一次性数据（`ONCE`）；一个利用流来定期请求一组数据的订阅（`POLL`）；或者一个长期存在的订阅，根据单个订阅模式中指定的触发器流式传输数据（`STREAM`）。对于流式遥测，模式设置为`STREAM`。
- en: gNMI-gateway
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: gNMI-gateway
- en: '**gNMI-gateway** is open source software that was initially developed by Netflix
    and then released as part of the OpenConfig working group to collect and distribute
    OpenConfig-modeled gNMI data from network devices.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**gNMI-gateway** 是由Netflix最初开发的开源软件，后来作为OpenConfig工作组的一部分发布，用于从网络设备收集和分发基于OpenConfig模式的gNMI数据。'
- en: 'The motivations to create gNMI-gateway were various, as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 创建gNMI-gateway的动机多种多样，如下所述：
- en: First, there were not many open source services available to consume and distribute
    OpenConfig-modeled gNMI Streaming Telemetry data.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，可用的开源服务不多，无法消费和分发基于OpenConfig模式的gNMI流式遥测数据。
- en: Second, there was a lack of failure tolerance for the client and target connection
    using gNMI data streaming, making Streaming Telemetry vulnerable. As the client
    dies, the streamed data is lost until another subscription takes place.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二，使用gNMI数据流进行客户端和目标连接的容错性不足，使得流式遥测容易受到威胁。当客户端崩溃时，流式数据会丢失，直到另一个订阅发生。
- en: The third was the lack of supporting multiple consumers. If multiple departments
    in a company want data from a network device or a group of network devices, it
    would be necessary for all of them to send subscriptions to the targets. With
    clustering functionality and replication in gNMI-gateway, it is possible to avoid
    unnecessarily duplicating gNMI connections to targets and offer the same data
    to multiple customers.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三是缺乏支持多个消费者的功能。如果公司内的多个部门需要从网络设备或一组网络设备获取数据，那么所有这些部门都需要向目标发送订阅。在gNMI-gateway的集群功能和复制功能下，可以避免不必要地重复连接到目标，并向多个客户提供相同的数据。
- en: Fourth, there was a lack of unifying gNMI clients with non-gNMI clients. gNMI-gateway
    allows either gNMI clients or non-gNMI clients to gather information.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四，缺乏将gNMI客户端与非gNMI客户端统一的功能。gNMI-gateway允许gNMI客户端或非gNMI客户端收集信息。
- en: '*Figure 3.11* shows a single instance of gNMI-gateway with gNMI clients and
    non-gNMI clients, also known as exporters. **Apache Kafta** ([https://kafka.apache.org/](https://kafka.apache.org/))
    is one piece of software that can be used as an exporter; another one already
    implemented is **Prometheus** ([https://prometheus.io/](https://prometheus.io/)):'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.11* 展示了gNMI客户端和非gNMI客户端（也称为导出器）的单个实例。**Apache Kafka** ([https://kafka.apache.org/](https://kafka.apache.org/))
    是可以用来作为导出器的一种软件；另一个已经实现的是 **Prometheus** ([https://prometheus.io/](https://prometheus.io/))：'
- en: '![Figure 3.11 – A single instance of gNMI-gateway](img/B18165_03_011.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![图3.11 – gNMI-gateway的单个实例](img/B18165_03_011.jpg)'
- en: Figure 3.11 – A single instance of gNMI-gateway
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 – gNMI-gateway的单个实例
- en: 'The redundancy can be obtained by using multiple instances of gNMI-gateway
    which is implemented by using **Apache Zookeeper** ([https://zookeeper.apache.org/](https://zookeeper.apache.org/)),
    as illustrated in *Figure 3.12*. If only one instance is running, there is no
    need to use Apache Zookeeper:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用多个gNMI-gateway实例来获得冗余，这些实例是通过使用**Apache Zookeeper** ([https://zookeeper.apache.org/](https://zookeeper.apache.org/))实现的，如图*图3.12*所示。如果只有一个实例正在运行，则不需要使用Apache
    Zookeeper：
- en: '![Figure 3.12 – Multiple instances of gNMI-gateway](img/B18165_03_012.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图3.12 – gNMI-gateway的多个实例](img/B18165_03_012.jpg)'
- en: Figure 3.12 – Multiple instances of gNMI-gateway
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 – gNMI-gateway的多个实例
- en: 'More on gNMI-gateway can be found here: [https://github.com/openconfig/gnmi](https://github.com/openconfig/gnmi).'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于gNMI-gateway的信息可以在这里找到：[https://github.com/openconfig/gnmi](https://github.com/openconfig/gnmi)。
- en: 'For reference, here is a full presentation on gNMI-gateway presented at 2020’s
    NANOG Webcast: [https://nanog.org/news-stories/nanog-tv/nanog-80-webcast/gnmi-gateway/](https://nanog.org/news-stories/nanog-tv/nanog-80-webcast/gnmi-gateway/).'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参考，以下是2020年NANOG网络广播中展示的关于gNMI-gateway的完整演示：[https://nanog.org/news-stories/nanog-tv/nanog-80-webcast/gnmi-gateway/](https://nanog.org/news-stories/nanog-tv/nanog-80-webcast/gnmi-gateway/)。
- en: Important note
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Full specification on gNMI can be found here: [https://github.com/openconfig/reference/blob/master/rpc/gnmi/gnmi-specification.md](https://github.com/openconfig/reference/blob/master/rpc/gnmi/gnmi-specification.md).'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: gNMI的完整规范可以在这里找到：[https://github.com/openconfig/reference/blob/master/rpc/gnmi/gnmi-specification.md](https://github.com/openconfig/reference/blob/master/rpc/gnmi/gnmi-specification.md)。
- en: 'Here are some pros and cons of using gNMI for network automation:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用gNMI进行网络自动化的优缺点：
- en: '**Pros**:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**:'
- en: Secure
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全
- en: Fast
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速
- en: Parallelism is easy
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行化很容易
- en: No privileged access is possible
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可能获得特权访问
- en: Incorporates YANG specification for networking
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成了网络YANG规范
- en: Allows easy Streaming Telemetry
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许轻松进行流式遥测
- en: Capable of adding gNMI-gateway with full redundancy
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够添加具有完全冗余的gNMI-gateway
- en: '**Cons**:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**:'
- en: Not many network devices have gNMI capability
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并非许多网络设备都具备gNMI功能
- en: Summary
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the major methods used by software engineers to
    interact with network devices. Not many more methods are available, so I would
    assume we have covered perhaps 99.9% of all existing methods at the time of writing.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了软件工程师用来与网络设备交互的主要方法。可用的方法并不多，所以我假设在写作时我们已经覆盖了大约99.9%的所有现有方法。
- en: Using the information provided in this chapter, you can choose which method
    or methods to incorporate into your network automation code. In most cases, you
    won’t be able to cover all scenarios using just one method; you will probably
    have to combine two or more methods.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本章提供的信息，您可以选择将哪种方法或哪些方法纳入您的网络自动化代码。在大多数情况下，您无法仅使用一种方法覆盖所有场景；您可能需要结合两种或更多方法。
- en: The next chapter will explore how files can be used to define a network. We
    will discuss the pros and cons of each type of file that’s available.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将探讨如何使用文件来定义网络。我们将讨论每种可用文件类型的优缺点。
