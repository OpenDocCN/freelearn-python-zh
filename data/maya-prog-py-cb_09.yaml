- en: Chapter 9. Communicating with the Web
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章。与 Web 通信
- en: 'In this chapter, we''ll be looking at the following ways to get your scripts
    talking to the outside world by sending and receiving web requests:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下方法，通过发送和接收 Web 请求，让你的脚本与外界进行通信：
- en: Opening a web page from script
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从脚本中打开网页
- en: Grabbing data from a server
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从服务器获取数据
- en: Working with XML data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 XML 数据
- en: Working with JSON data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 JSON 数据
- en: Sending POST data to a web server from Maya
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Maya 向网络服务器发送 POST 数据
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we looked at how to read and write data to disk, which
    can be a great way to build up toolchains and pipelines for your teams. However,
    you will almost always be working as part of a team (or working to support a team
    as a TD), which means that you'll generally want to read and write data to some
    central repository.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了如何读取和写入数据到磁盘，这对于构建团队的工具链和管道来说是一种很好的方法。然而，你几乎总是作为团队的一部分（或者作为 TD 支持团队）工作，这意味着你通常想要将数据读取和写入某个中央存储库。
- en: And in order to do it, you'll probably need to communicate with a web server
    of some kind. In this chapter, we'll be looking at how to do just that—how to
    pull data from and push data onto the Web.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，你可能需要与某种类型的网络服务器进行通信。在本章中，我们将探讨如何做到这一点——如何从 Web 上拉取数据和推送到 Web。
- en: Opening a web page from script
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从脚本中打开网页
- en: If you find yourself writing a complex script, it can often be helpful to provide
    documentation for your script in the form of a web page. A great way to do that
    is to include an easy way to show that page to the user. In this example, we'll
    create a simple script that will open a given URL in the user's default web browser.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己正在编写一个复杂的脚本，提供以网页形式存在的脚本文档通常很有帮助。一个很好的方法是通过提供一种简单的方式来向用户展示该页面。在本例中，我们将创建一个简单的脚本，该脚本将在用户的默认网络浏览器中打开指定的
    URL。
- en: How to do it...
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new script and add the following code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的脚本并添加以下代码：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Run the script, and you'll see the specified URL appear in your default browser.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本，你将在默认浏览器中看到指定的 URL 出现。
- en: How it works...
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'All we''re really doing here is using the `showHelp` command. It''s a bit misleading,
    as the `showHelp` command is also used to show Maya''s documentation for a specific
    command. However, as long as you specify the absolute flag to true, you can pass
    in a full path to the URL you would like to open:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里真正做的是使用 `showHelp` 命令。这有点误导，因为 `showHelp` 命令也用于显示 Maya 对特定命令的文档。然而，只要将绝对标志设置为
    true，你就可以传递一个你想要打开的 URL 的完整路径：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that there are a few deprecated commands that you might come across that
    no longer work. In older versions of Maya, there was a `webBrowser` command that
    would allow for the inclusion of web content in script-based UIs. Unfortunately,
    that command has been removed, necessitating the use of `showHelp` to open content
    in the browser.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可能遇到一些已弃用的命令，它们不再工作。在 Maya 的旧版本中，有一个 `webBrowser` 命令，它允许在基于脚本的 UI 中包含网页内容。不幸的是，该命令已被删除，需要使用
    `showHelp` 命令在浏览器中打开内容。
- en: There's more...
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It's highly likely that if you have a script that is complex enough to warrant
    a page of documentation, it also includes (possibly complex) UI. Rather than just
    having a button to show help, it's easy enough to implement a proper "Help" menu,
    as is commonly seen in other programs.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的脚本足够复杂，需要一页文档，那么它很可能还包括（可能是复杂的）UI。与其只提供一个显示帮助的按钮，不如轻松实现一个“帮助”菜单，这在其他程序中很常见。
- en: '![There''s more...](img/B04657_09_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/B04657_09_01.jpg)'
- en: 'This is easily done with the menu and `menuItem` commands. Here''s a full listing
    to produce the preceding result:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过菜单和 `menuItem` 命令轻松完成。以下是生成前面结果的完整列表：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We start by creating a window, just as we've done in previous examples. Then,
    we add a new menu with the `menu` command. The label is the text that will appear
    as the top of the menu, and specifying `helpMenu=True` ensures that this particular
    menu will be treated as a help menu (displayed to the far right of all menu options).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个窗口，就像我们在之前的例子中所做的那样。然后，我们使用 `menu` 命令添加一个新的菜单。标签是将在菜单顶部显示的文本，指定 `helpMenu=True`
    确保这个特定的菜单将被视为帮助菜单（显示在所有菜单选项的最右侧）。
- en: Once we have a menu, we can add menu items to it. This is a lot like adding
    a button, in that we specify a label and a command that will be executed when
    the item is selected.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了菜单，我们就可以向其中添加菜单项。这很像添加一个按钮，我们指定一个标签和一个当项目被选中时将执行的命令。
- en: Note that the new `menuItem` will be added to the most recent menu. To add menu
    items in different menus (to have both a "File" and a "Help" category, for example),
    be sure to call `cmds.menu` to start a new menu before adding additional items.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，新的`menuItem`将被添加到最新的菜单中。要添加不同菜单中的菜单项（例如，同时拥有“文件”和“帮助”类别），确保在添加其他项之前调用`cmds.menu`来启动一个新的菜单。
- en: Grabbing data from a server
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从服务器获取数据
- en: In this example, we'll look at the simplest possible way to grab data from a
    given URL, using Python's built-in `urllib2` library.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将查看从给定URL获取数据的最简单方法，使用Python的内置`urllib2`库。
- en: Getting ready
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You''ll want to make sure that you have a URL to grab. You can use any website
    you like, but for the sake of testing, it can be helpful to have a minimal page
    served on your local machine. If you want to do that, start by creating a simple
    html file, something like the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要确保你有一个要获取的URL。你可以使用任何你喜欢的网站，但为了测试的目的，在你的本地机器上有一个最小的页面可能会有所帮助。如果你想那样做，首先创建一个简单的html文件，如下所示：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once you''ve done that, you''ll want to have that served as a page on your
    own machine. Python offers a really simple way to do just that. Open a command
    line (terminal on a mac) and navigate to wherever you saved your html file. From
    there, enter the following command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你做了这些，你将希望在自己的机器上提供这些内容作为页面。Python提供了一种非常简单的方式来做到这一点。打开命令行（mac上的终端）并导航到你保存html文件的地方。从那里，输入以下命令：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will cause Python to serve the contents of the current directory as a
    website on localhost. The -m flag tells python to include a given module (in this
    case, `SimpleHTTPServer`) when running the interpreter. It''s the equivalent of
    using the following at the beginning of a Python script:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致Python将当前目录的内容作为网站在本地主机上提供服务。`-m`标志告诉Python在运行解释器时包含一个给定的模块（在本例中为`SimpleHTTPServer`）。这相当于在Python脚本开头使用以下命令：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'By default, the contents of the current directory will be served on port 8000,
    meaning that you can access the contents by opening a browser and going to:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当前目录的内容将在端口8000上提供服务，这意味着你可以通过打开浏览器并访问以下链接来访问内容：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How to do it...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new file and add the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件并添加以下代码：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Make sure that you''ve created an `index.htm` (or html) file somewhere and
    that you''ve run `python -m SimpleHTTPServer` from that same directory. If you''ve
    done that, running the preceding script should output something like the following
    followed by the entire contents of your `index.htm` file:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经在某个地方创建了一个`index.htm`（或html）文件，并且已经从该目录运行了`python -m SimpleHTTPServer`。如果你已经那样做了，运行前面的脚本应该会输出以下内容，然后是整个`index.htm`文件的内容：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First off, we have to make sure to import the `urllib2` library in addition
    to our standard `maya.cmds`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须确保导入`urllib2`库以及我们的标准`maya.cmds`：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will give us access to the commands we''ll need to load data from a given
    URL. We start by setting up a variable to hold the URL we''re loading, and printing
    a message indicating that we''re about to attempt to load it:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们能够访问加载给定URL所需的所有命令。我们首先设置一个变量来保存我们正在加载的URL，并打印一条消息，表明我们即将尝试加载它：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now we're ready to actually attempt to load the data. When loading data from
    a URL, it's important that you never assume that the URL is accessible. There
    are any number of things that can go wrong either on the server side (the server
    could be down or not responding to requests) or on the client side (the indicated
    URL could be blocked by a firewall, the Ethernet cable could be unplugged, and
    so on) any one of which would prevent the URL from loading.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备实际尝试加载数据。当从URL加载数据时，你永远不要假设URL是可访问的。服务器端（服务器可能已关闭或未响应请求）或客户端（指定的URL可能被防火墙阻止，以太网电缆可能被拔掉等）可能发生任何错误，任何一种都会阻止URL的加载。
- en: 'As such, we''ll wrap our attempt to fetch the URL in a try/catch block. If
    anything goes wrong in the loading of the URL, we''ll print out the error and
    return:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将尝试获取URL的尝试包裹在try/catch块中。如果在加载URL的过程中出现任何错误，我们将打印出错误并返回：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we manage to actually retrieve the URL in question, we''re left with a "file-like
    object". This means that we can use all the functions that we would use when opening
    a file, such as `read()` to get the contents. The specific file-like objects returned
    by `urllib2.urlopen` also implement a couple of additional functions, which we
    make use of here. First, we get the HTTP code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们成功检索到相关的URL，我们将得到一个“文件-like对象”。这意味着我们可以使用在打开文件时使用的所有函数，例如使用`read()`来获取内容。`urllib2.urlopen`返回的特定文件-like对象还实现了几个额外的函数，我们在这里使用了它们。首先，我们获取HTTP代码：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If everything went as expected, that *should* print out "200", indicating a
    successful request. Next, we retrieve some information about the URL:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切如预期进行，那么它应该会打印出"200"，表示请求成功。接下来，我们检索一些关于URL的信息：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This will display the information in the headers (server type, time of last
    modification, and so on):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示头部信息（服务器类型、最后修改时间等）：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Finally, we'll get the actual data at the web address with the `read()` function.
    Calling `read()` without specifying a number of bytes to read will grab the entire
    contents of the file (or in this case, the website).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`read()`函数从Web地址获取实际数据。调用`read()`而不指定要读取的字节数将获取文件的全部内容（或在这种情况下，网站的全部内容）。
- en: There's more...
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: In this example, we loaded the entirety of a website. While you generally wouldn't
    want to do that for most websites, it makes a lot of sense when requesting data
    from a web API, where the result will typically be a small(ish) amount of formatted
    data (either XML or JSON).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们加载了整个网站。虽然你通常不会想为大多数网站这样做，但在请求来自Web API的数据时，这很有意义，因为结果通常是一小部分格式化的数据（XML或JSON）。
- en: If what you want is to just display a full website (rather than retrieving data
    via an API), see the previous example where we use the `showHelp` command to display
    a given website.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是想显示一个完整的网站（而不是通过API检索数据），请参考之前的示例，其中我们使用`showHelp`命令来显示指定的网站。
- en: Working with XML data
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理XML数据
- en: When grabbing data from a web server, it's highly likely that you'll receive
    it in a structured format of one kind or another, with XML and JSON being the
    most common options. In this example, we'll look at how to make use of data served
    up as XML.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当从Web服务器获取数据时，你很可能以某种结构化格式接收它，XML和JSON是最常见的选项。在这个示例中，我们将看看如何利用作为XML提供的数据。
- en: Getting ready
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To use this example, you''ll need to have an XML file available on a server
    somewhere. The easiest way to do this is to create a file locally on your machine,
    then run the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此示例，你需要在某台服务器上有一个可用的XML文件。最简单的方法是在你的机器上本地创建一个文件，然后运行以下命令：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'From the same directory as the file, provide access to it via localhost. Here''s
    the file that I''ll be using as the example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从与文件相同的目录中，通过localhost提供对它的访问。以下是我将用作示例的文件：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The file is pretty simple, but will allow us to look at iterating over XML nodes
    and parsing both attributes and elements.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 文件相当简单，但它将允许我们查看遍历XML节点并解析属性和元素。
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Create a new file and add the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件并添加以下代码：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Be sure to point the URL at the proper location for your XML file, and run the
    script; you should see a cube and a sphere appear.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将URL指向你的XML文件的正确位置，并运行脚本；你应该会看到一个立方体和一个球体出现。
- en: How it works...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First off, we add another library `xml.etree.ElementTree` to our imports and
    give it a shorter name to make it easier to work with:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加另一个库`xml.etree.ElementTree`到我们的导入中，并给它一个更短的名字，以便更容易使用：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we create a simple function to create either a sphere or a cube of a
    given size and move it to a given position. This is pretty straightforward and
    probably seems quite familiar at this point:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个简单的函数来创建给定大小的球体或立方体，并将其移动到指定位置。这相当直接，并且在这个阶段可能看起来相当熟悉：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we grab the data from the specified URL, as we have in the previous examples
    this chapter:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们像本章前面的示例一样从指定的URL获取数据：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now we're ready to move onto the meat of the example—the actual XML parsing.
    First off, we parse the data we received from the Web into an XML tree with the
    `xml.etree.ElementTree` parse command.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备进入示例的核心——实际的XML解析。首先，我们使用`xml.etree.ElementTree`的解析命令将我们从Web接收到的数据解析成一个XML树。
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The parse command can accept either a string or a file-like object. Because
    we receive a file-like object from the `urllib2.urlopen` command, we can pass
    the result straight in.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 解析命令可以接受字符串或文件对象。因为我们从`urllib2.urlopen`命令接收文件对象，我们可以直接传递结果。
- en: 'Once we''ve done that, we have a proper tree of XML nodes, and we''re ready
    to start traversing the tree and parsing our data. To get started parsing, we
    first need to grab the root node, which we do with the `getroot()` command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成这些，我们就有了正确的XML节点树，我们就可以开始遍历树并解析我们的数据。要开始解析，我们首先需要获取根节点，我们使用`getroot()`命令来完成：
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The actual parsing will be a bit different, depending on the nature of your
    XML schema. In this case, we have some number of <object> nodes, each of which
    containing a "type" attribute and several child nodes for the *x*, *y*, and *z*
    positions as well as the size.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的解析将根据你的XML模式性质有所不同。在这种情况下，我们有一些<object>节点，每个节点都包含一个“type”属性以及用于*x*、*y*和*z*位置以及大小的几个子节点。
- en: 'We''ll want to start by iterating through all of the child nodes of the root
    to give us all of the object nodes. The `ElementTree` library makes that really
    easy—we can simply use a for loop to get all the child nodes. For each object
    we find, we''ll start by setting variables for object type, position, and size
    to default values:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先遍历根的所有子节点，以获取所有的对象节点。`ElementTree`库使这变得非常简单——我们可以简单地使用for循环来获取所有子节点。对于每个找到的对象，我们首先将对象类型、位置和大小变量设置为默认值：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this case, our local `item` variable represents a node that is a direct child
    of the root. Given the structure of our example XML document, that means we have
    an <object> node. First off, we'll want to examine the `type` attribute to see
    if we should be making a cube or a sphere.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的本地`item`变量代表一个根的直接子节点。根据我们示例XML文档的结构，这意味着我们有一个<object>节点。首先，我们将检查`type`属性以确定我们应该创建立方体还是球体。
- en: 'The attributes of a given node are stored as a dictionary in the node''s `attrib`
    attribute. We can index into that to grab the value, and if we find that it''s
    equal to `sphere`, we set our `objectType` to `2`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 给定节点的属性存储在节点的`attrib`属性中作为字典。我们可以索引它以获取值，如果我们发现它等于`sphere`，我们将我们的`objectType`设置为`2`：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now we need to look at the children of our current node to get the *x*, *y*,
    *z* positions and the size. We''ll use the same trick as before, iterating over
    the children of a given node with a for loop. For each child we find, we want
    to know two things:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要查看当前节点的子节点以获取*x*、*y*、*z*位置和大小。我们将使用之前相同的技巧，使用for循环遍历给定节点的子节点。对于每个找到的子节点，我们想知道两件事：
- en: The name of the tag.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签的名称。
- en: The value contained within the tag, as a float.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签内包含的值，作为一个浮点数。
- en: 'The name of a given node can be accessed via its tag property, and any text
    contained within it can be grabbed via the text property. For our purposes, we
    want to ensure floating point values, so we''ll be sure to cast the text to a
    float. Putting all that together gives us the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 给定节点的名称可以通过其标签属性访问，并且其中包含的任何文本都可以通过文本属性获取。就我们的目的而言，我们希望确保是浮点值，因此我们将确保将文本转换为浮点数。将这些放在一起，我们得到以下内容：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'All that''s left is to make use of the tag that we found and set the appropriate
    variable to our `tagValue`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是利用我们找到的标签，并将适当的变量设置为`tagValue`：
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Having done all of that, we pass our data into our `makeObjectAt` function to
    produce the object.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些后，我们将数据传递给我们的`makeObjectAt`函数以生成对象。
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Working with JSON data
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理JSON数据
- en: In this example, we'll look at the other format you're likely to want to use—JSON.
    JSON can model data just as well as XML, but is considerably more compact. As
    such, it has been growing in popularity in recent years and has all but replaced
    XML for many tasks.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将查看你可能想要使用的另一种格式——JSON。JSON可以像XML一样建模数据，但更加紧凑。因此，近年来它越来越受欢迎，几乎取代了XML在许多任务中的应用。
- en: Getting ready
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Once again, you'll want to make sure that you have a file being served by a
    server that you have access to, but this time you'll want to make sure that it's
    JSON data. Once again, we'll create some number of cubes and spheres, but this
    time, we'll specify the data as an array of JSON objects.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，你需要确保你有一个由你能够访问的服务器提供的文件，但这次你需要确保它是JSON数据。再次，我们将创建一些立方体和球体，但这次，我们将数据指定为一个JSON对象的数组。
- en: 'The full listing for the example document is as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 示例文档的完整列表如下：
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The square brackets indicate an array, and the curly brackets indicate an object.
    Within an object, there can be any number of named values. Arrays and objects
    can also be nested, allowing us to have an array *of* objects, as we do here.
    For more information on how to structure JSON data, be sure to have a look at
    [http://www.json.org/](http://www.json.org/).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号表示一个数组，花括号表示一个对象。在一个对象中可以有任意数量的命名值。数组和对象也可以嵌套，这样我们就可以有一个对象数组，就像我们在这里做的那样。有关如何结构化JSON数据的更多信息，请务必查看[http://www.json.org/](http://www.json.org/)。
- en: How to do it...
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new script and add the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的脚本并添加以下代码：
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Make sure that you have a JSON file formatted in the same way as the example
    and that it's accessible via a URL, localhost, or otherwise. Run the script, and
    you should have some number of cubes and spheres appear on your scene.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你有一个格式与示例相同的JSON文件，并且可以通过URL、localhost或其他方式访问。运行脚本，你应该在你的场景中看到一些立方体和球体。
- en: How it works...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Most of the script is the same as our previous example of parsing XML data.
    The first difference is that we change the import statements slightly, removing
    the `xml.etree.ElementTree` library and adding the JSON library instead:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分脚本与我们的上一个示例解析XML数据相同。第一个不同之处在于我们稍微改变了导入语句，移除了`xml.etree.ElementTree`库，并添加了JSON库：
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Next up, we have the same function as was used in the XML example to create
    either a sphere or a cube of a given size and move it to a specified position.
    I'll omit the details because it's identical to the function from the previous
    example.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有与XML示例中相同的函数，用于创建给定大小的一个球体或立方体并将其移动到指定的位置。我将省略细节，因为这与前面的示例中的函数相同。
- en: 'In the function responsible for actually loading the data, we start off grabbing
    the URL as we have in the previous examples in this chapter:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在负责实际加载数据的函数中，我们开始时像本章前面的示例中那样获取URL：
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The new functionality comes in the form of a call to the `loads()` or "load
    string" function, which will load data from a string into a proper JSON object.
    By passing the result of `webData.read()` into that function, we will be left
    with the full contents of our file into an object:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 新功能是以对`loads()`或“加载字符串”函数的调用形式出现的，该函数将数据从字符串加载到适当的JSON对象中。通过将`webData.read()`的结果传递给该函数，我们将得到文件的全部内容到一个对象中：
- en: '[PRE32]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Once we've done that, we'll want to step through the entries in the data. The
    result of parsing JSON in Python will translate arrays into lists and objects
    into dictionaries. Because our JSON data was in the form of an array of objects,
    we are left with a list of dictionaries after loading.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成这个步骤，我们就会想要遍历数据中的条目。在Python中解析JSON的结果会将数组转换为列表，将对象转换为字典。由于我们的JSON数据是以对象数组的形式存在的，在加载后我们留下的是一个字典列表。
- en: 'We start our parsing by stepping through the array and grabbing the data for
    each object. As in the XML example, we set up placeholder variables with default
    values for `objectType`, `objectSize`, and `position`, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始解析是通过遍历数组并获取每个对象的数据。就像XML示例中一样，我们为`objectType`、`objectSize`和`position`设置了具有默认值的占位符变量，如下所示：
- en: '[PRE33]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Within the loop, we''ll grab the values for each of our attributes by first
    checking to see if they''re present in the current dictionary and, if so, set
    the value of the corresponding variable. We have the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中，我们将通过首先检查它们是否存在于当前字典中，如果是，则设置相应变量的值来获取我们每个属性的值。我们有以下代码：
- en: '[PRE34]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that we cast `objectSize` to a float. That's necessary, since we divide
    it by 2 in our `makeObjectAt()` function. If we happen to have an integer input,
    dividing it by 2 would result in an integer result, possibly giving us a bad value
    (if we pass in 1, we would get 0 instead of 0.5, for example).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将`objectSize`转换为浮点数。这是必要的，因为我们将在`makeObjectAt()`函数中将它除以2。如果我们输入的是整数，除以2的结果将是一个整数，可能会得到一个不良的值（例如，如果我们输入1，我们会得到0而不是0.5）。
- en: 'Finally, we pass in the retrieved values to our `makeObjectAt()` function:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将检索到的值传递给我们的`makeObjectAt()`函数：
- en: '[PRE35]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There's more...
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You'll probably note that JSON data is a bit easier to work with than XML—with
    JSON, we end up with standard Python lists and dictionaries, whereas XML requires
    that we walk up and down a series of nodes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，与XML相比，JSON数据更容易处理——使用JSON，我们最终得到标准的Python列表和字典，而XML则需要我们遍历一系列节点。
- en: That's true not only in Python, but in many other languages as well. If you
    happen to be working in JavaScript, there's often no actual parsing required,
    as JSON is a subset of JavaScript itself (JSON is short for JavaScript Object
    Notation).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅适用于Python，也适用于许多其他语言。如果你碰巧在JavaScript中工作，通常不需要实际解析，因为JSON本身就是JavaScript的一个子集（JSON是JavaScript
    Object Notation的缩写）。
- en: There are still good reasons to use XML, but if all that's needed is a way to
    move structured data from one place to another, JSON tends to be easier to parse,
    and just as easy to read.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然有很好的理由使用XML，但如果所有需要的是将结构化数据从一个地方移动到另一个地方，JSON通常更容易解析，并且同样容易阅读。
- en: See also
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: If you're new to JSON, it's a good idea to have a look at the official docs,
    available at [http://www.json.org/](http://www.json.org/). You'll find that for
    all its flexibility, it's actually a pretty simple format.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚开始接触JSON，查看官方文档是个好主意，官方文档可在[http://www.json.org/](http://www.json.org/)找到。你会发现，尽管它非常灵活，但实际上它是一个非常简单的格式。
- en: Sending POST data to a web server from Maya
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Maya向Web服务器发送POST数据
- en: So far, everything we've looked at involves pulling data from the Web into Maya.
    In this example, we'll look at how to send data to a server from within Maya.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所看到的一切都涉及到从网络中提取数据到Maya中。在这个例子中，我们将看看如何在Maya内部将数据发送到服务器。
- en: There are two main ways to send data to a server—GET and POST. Using GET involves
    adding arguments onto a URL directly. It has the benefit of being able to be bookmarked
    (since the arguments are in the URL), but has limitations on the amount of data
    that can be sent. POST requests are more flexible and will usually be what you
    want to use to build tool pipelines in a production environment.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 发送数据到服务器主要有两种方式——GET和POST。使用GET涉及直接在URL上添加参数。它的好处是可以被书签（因为参数在URL中），但数据发送量有限制。POST请求更灵活，通常是你想在生产环境中构建工具管道时想要使用的方法。
- en: In this example, we'll implement two different examples of sending POST data.
    First, we'll look at sending summary data about a scene (the name of the file
    and the number of objects). Then, we'll look at using POST requests to send a
    selected model to a server as an OBJ file. This could form the backbone of an
    asset management pipeline.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将实现发送POST数据的两个不同示例。首先，我们将看看如何发送关于场景的摘要数据（文件的名称和对象的数量）。然后，我们将看看如何使用POST请求将选定的模型作为OBJ文件发送到服务器。这可以形成一个资产管理管道的核心。
- en: Getting ready
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll be using the requests library for this example, so make sure to install
    it. For details on how to do that, visit [http://docs.python-requests.org/en/master/user/install/#install](http://docs.python-requests.org/en/master/user/install/#install).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个例子中使用requests库，所以请确保安装它。有关如何安装的详细信息，请访问[http://docs.python-requests.org/en/master/user/install/#install](http://docs.python-requests.org/en/master/user/install/#install)。
- en: In order to make the most of this example, you'll need to have a server that
    can respond to GET and POST requests. Setting that up is beyond the scope of this
    book, and there are any number of ways to go about it (and any number of languages
    you can use to do so). Luckily, there's an easy way to test your requests in the
    form of [http://httpbin.org/](http://httpbin.org/). The httpbin site can be used
    to test a wide range of HTTP requests, and will return whatever data is passed
    to it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用这个例子，你需要有一个可以响应GET和POST请求的服务器。设置这个服务器超出了本书的范围，有无数种方法可以做到这一点（以及你可以用来做到这一点的无数种语言）。幸运的是，有一个简单的方法来测试你的请求，那就是[http://httpbin.org/](http://httpbin.org/)。这个httpbin网站可以用来测试广泛的HTTP请求，并将返回传递给它的任何数据。
- en: Also, since we're going to be sending actual model data, you'll need to have
    at least one polygonal mesh in your scene.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们将发送实际的模型数据，你至少需要在场景中有一个多边形网格。
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new file and add the following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件并添加以下代码：
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Select a polygonal mesh and run the script. Both of the examples will send
    data to httpbin and output the result that gets parroted back from the site. You
    should see something like the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个多边形网格并运行脚本。这两个示例都将向httpbin发送数据，并输出从网站返回的结果。你应该看到以下类似的内容：
- en: '[PRE37]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We start off the script with importing everything we need—`maya.cmds` as always,
    plus the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在脚本中导入所有需要的模块——`maya.cmds` 如常，以及以下内容：
- en: '`- requests`: This provides nicer tools for working with requests and sending
    data'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`- requests`: 这提供了更方便的工具来处理请求和发送数据'
- en: '`- os`: This is needed to work with paths'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`- os`: 这是为了处理路径'
- en: '`- json`: This is needed to parse the response that we''ll get from httpbin.org'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`- json`：这是为了解析我们从httpbin.org获取的响应'
- en: 'We also set a global variable to hold the URL that we''ll be sending data to,
    in this case, `httpbin.org/post`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还设置了一个全局变量来保存我们将要发送数据的URL，在这种情况下，`httpbin.org/post`：
- en: '[PRE38]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now we're ready to implement our first example—sending some summary data about
    our scene. In this case, we'll send the name of the scene and the number of objects
    it contains. To get the name of the current scene, we use the file command in
    query mode, and setting the `sceneName` flag.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备实现我们的第一个示例——发送有关场景的一些摘要数据。在这种情况下，我们将发送场景的名称和它包含的物体数量。为了获取当前场景的名称，我们使用查询模式的文件命令，并设置`sceneName`标志。
- en: 'This will give us the full path to the current scene, which we''ll pass into
    `os.path.basename` to retrieve just the filename itself:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出当前场景的完整路径，我们将将其传递给`os.path.basename`以获取文件名本身：
- en: '[PRE39]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, we''ll get the total number of objects in the scene by using the `ls`
    command and setting the geometry flag to true. The length of that list will give
    us the total number of (geometric) objects:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`ls`命令并设置几何标志为true来获取场景中物体的总数。该列表的长度将给我们总的（几何）物体数量：
- en: '[PRE40]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'At this point, we have all of the data that we want to send. In order to prep
    it for sending, we''ll need to create a new dictionary and create an entry for
    each value we want to send:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经有了我们想要发送的所有数据。为了准备发送，我们需要创建一个新的字典并为每个我们想要发送的值创建一个条目：
- en: '[PRE41]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Actually, sending the data is very straightforward, thanks to the requests
    library. All that we need to do is to call `requests.post` with our desired URL,
    and with our data variable passed in as the value for the JSON option. We''ll
    be sure to save the result to a variable so that we can examine the response from
    the server:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，由于requests库的存在，发送数据非常简单。我们只需要调用`requests.post`并传递我们想要的URL，以及作为JSON选项值的数据变量。我们将确保将结果保存到变量中，以便我们可以检查服务器的响应：
- en: '[PRE42]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Once we''ve sent the request, we''ll want to examine whether or not it was
    successful. To do that, we examine the `status_code` attribute of the result,
    checking it against 200\. If the request went through, we parse the actual response
    into a JSON object and print the data attribute. Otherwise, we display an error,
    as in the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们发送了请求，我们希望检查它是否成功。为此，我们检查结果的`status_code`属性，将其与200进行比较。如果请求成功，我们将实际响应解析为JSON对象并打印数据属性。否则，我们显示错误，如下面的代码所示：
- en: '[PRE43]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Since `httpbin.org/post` will echo back any data sent to it, we should see
    something like the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`httpbin.org/post`会回显发送给它的任何数据，我们应该看到以下内容：
- en: '[PRE44]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This indicates that the data was successfully sent to the server and returned
    to us as a response.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明数据已成功发送到服务器并作为响应返回给我们。
- en: Now, let's look at a slightly more involved example. We'll create a function
    that will save a selected polygonal object as an OBJ, then send that file to a
    server as POST data. We'll build that up from a few smaller functions, starting
    with one to test whether or not the current selection is a polygon mesh.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个稍微复杂一点的例子。我们将创建一个函数，该函数将保存选定的多边形对象为OBJ，然后将该文件作为POST数据发送到服务器。我们将从几个较小的函数开始构建，首先是测试当前选择是否为多边形网格的函数。
- en: '[PRE45]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This is similar to what we've done in previous examples; we get the current
    selection and start by checking to see if at least one object is selected. If
    that succeeds, we use the `listRelatives` command to retrieve the shape node associated
    with the selected object and test its node type. If it's anything other than "mesh"
    (indicating a polygonal object), we return false. If we pass through both checks,
    we return true.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在前面的例子中所做的是类似的；我们获取当前选择并首先检查是否至少选择了一个对象。如果这成功了，我们使用`listRelatives`命令检索与所选对象关联的形状节点并测试其节点类型。如果它不是“mesh”（表示多边形对象），我们返回false。如果我们通过了这两个检查，我们返回true。
- en: 'Next, we implement a function to save the currently selected object as an OBJ.
    Since exporting OBJs requires that the OBJ export plugin be loaded, we start our
    function with a call to `loadPlugin` to make sure that it is. See the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实现一个函数来保存当前选定的对象为OBJ。由于导出OBJ需要加载OBJ导出插件，我们首先调用`loadPlugin`来确保它已加载。如下所示：
- en: '[PRE46]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We pass in `objExport` as the plugin to load, and we set the quiet flag to true,
    which will prevent Maya from displaying a message if the plugin was already loaded.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`objExport`作为要加载的插件传入，并将静默标志设置为true，这将防止Maya在插件已加载时显示消息。
- en: To export the model, we'll need to use the `file` command, but before doing
    that, we'll want to make sure that the file exists. That's needed in order to
    avoid a quirk of the file command, which can cause it to error out if saving to
    a file that doesn't exist.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了导出模型，我们需要使用`file`命令，但在做之前，我们想要确保文件存在。这是必要的，以避免`file`命令的怪癖，它可能会在保存到不存在的文件时出错。
- en: 'We start by using the `file` command in the query mode to see if a file of
    the given name exists. If not, we create one by opening it in write mode, then
    immediately closing it, as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用查询模式的`file`命令来查看是否存在给定名称的文件。如果不存在，我们通过以写入模式打开它然后立即关闭它来创建一个，如下所示：
- en: '[PRE47]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now we''re ready to actually write out the OBJ file, using the file command
    once again:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好实际写入OBJ文件，再次使用`file`命令：
- en: '[PRE48]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The first argument is the full path to where we want to save the file. After
    that, we set `exportSelected` to true to indicate the main operation that should
    be performed, in this case, exporting only the currently selected object. Next,
    we specify that we want to save it as an OBJ, and we set force to true to avoid
    prompting the user for a file overwrite confirmation. Finally, we set the options
    for the OBJ export as a single string, with semicolons to separate out each of
    the parts. In this case, we'll turn everything off except `normals`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是我们想要保存文件的完整路径。之后，我们将`exportSelected`设置为true以指示应该执行的主要操作，在这种情况下，仅导出当前选定的对象。然后，我们指定我们想要将其保存为OBJ，并将强制设置为true以避免提示用户进行文件覆盖确认。最后，我们将OBJ导出选项作为单个字符串设置，用分号分隔每个部分。在这种情况下，我们将关闭除`normals`之外的所有选项。
- en: 'Now that we''ve created both of our helper functions, we''re ready to move
    to the function to put them together and send the model to a server. We start
    by running the check for polygonal geometry and throwing an error if it fails:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了两个辅助函数，我们准备将它们组合到函数中并发送模型到服务器。我们首先运行对多边形几何形状的检查，如果失败则抛出错误：
- en: '[PRE49]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Once we''ve done that, we build up the path to save the file by first using
    the workspace command to retrieve the current workspace location and using `os.path.join`
    to append the desired filename:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了这些，我们将通过首先使用`workspace`命令来检索当前工作区位置，然后使用`os.path.join`来附加所需的文件名来构建保存文件的路径：
- en: '[PRE50]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'With the full path, we can save out the model using our `saveSelectionAsOBJ()`
    function:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用完整的路径，我们可以使用我们的`saveSelectionAsOBJ()`函数保存模型：
- en: '[PRE51]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now we're ready to send the file. In order to send files via POST data, we'll
    need to send a "multipart" request in order to send the file data as its own part.
    Luckily for us, the requests library handles all of that for us. It ends up looking
    quite similar to our previous example of sending simple POST data, in that we
    start by setting up our data in a dictionary.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好发送文件。为了通过POST数据发送文件，我们需要发送一个“multipart”请求，以便将文件数据作为其自己的部分发送。幸运的是，对于我们来说，requests库为我们处理了所有这些。它最终看起来与我们的上一个示例非常相似，即发送简单的POST数据，我们首先在字典中设置我们的数据。
- en: '[PRE52]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In this case, we have only a single entry, named `file`, which we set equal
    to the output of the `file open` command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只有一个条目，名为`file`，我们将其设置为`file open`命令的输出：
- en: '[PRE53]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Once we''ve done that, all we need to do to actually send the file is to call
    `requests.post` with the desired URL, and pass in our `modelFile` dictionary as
    the value for the `files` attribute:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了这些，我们实际上发送文件只需要调用`requests.post`并传递所需的URL，并将我们的`modelFile`字典作为`files`属性的值：
- en: '[PRE54]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Just as with the simple example, we''ll check the `result.status_code` and,
    if we find 200, parse the response as JSON and output some of it, though in this
    case, we output the `files` attribute instead of data. We have the following code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 就像简单的例子一样，我们将检查`result.status_code`，如果发现是200，我们将解析响应为JSON并输出其中的一部分，尽管在这种情况下，我们输出的是`files`属性而不是数据。以下是我们的代码：
- en: '[PRE55]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: There's more...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: While we sent data and files in two separate requests for the sake of the examples,
    you can certainly send both at the same time. For example, if you wanted to build
    an asset management pipeline for an MMO, you might want to send the models to
    a central server, along with some metadata, such as which textures they use or
    what their in-game attributes are.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然为了示例的缘故，我们分别发送了数据和文件两个请求，但你当然可以同时发送它们。例如，如果你想要为大型多人在线游戏（MMO）构建一个资产管理管道，你可能希望将模型发送到一个中央服务器，同时附带一些元数据，例如它们使用的纹理或它们在游戏中的属性。
