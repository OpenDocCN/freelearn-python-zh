- en: Implementing Concurrency
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现并发
- en: So far, we have explored how to measure and improve the performance of programs
    by reducing the number of operations performed by the CPU through clever algorithms
    and more efficient machine code. In this chapter, we will shift our focus to programs
    where most of the time is spent waiting for resources that are much slower than
    the CPU, such as persistent storage and network resources.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了如何通过使用巧妙的算法和更高效的机器代码来减少CPU执行的操作数量，从而测量和改进程序的性能。在本章中，我们将把重点转向那些大部分时间都花在等待比CPU慢得多的资源（如持久存储和网络资源）的程序。
- en: Asynchronous programming is a programming paradigm that helps to deal with slow
    and unpredictable resources (such as users) and is widely used to build responsive
    services and user interfaces. In this chapter, we will show you how to program
    asynchronously in Python using techniques such as coroutines and reactive programming.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程是一种编程范式，有助于处理慢速和不可预测的资源（如用户），并且广泛用于构建响应式服务和用户界面。在本章中，我们将向您展示如何使用协程和响应式编程等技术以异步方式在Python中进行编程。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The memory hierarchy
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存层次结构
- en: Callbacks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调
- en: Futures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未来
- en: Event loops
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件循环
- en: Writing coroutines with `asyncio`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`asyncio`编写协程
- en: Converting synchronous code to asynchronous code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将同步代码转换为异步代码
- en: Reactive programming with RxPy
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RxPy进行响应式编程
- en: Working with observables
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与可观察对象一起工作
- en: Building a memory monitor with RxPY
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RxPY构建内存监控器
- en: Asynchronous programming
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步编程
- en: Asynchronous programming is a way of dealing with slow and unpredictable resources.
    Rather than waiting idle for resources to become available, asynchronous programs
    are able to handle multiple resources concurrently and efficiently. Programming
    in an asynchronous way can be challenging because it is necessary to deal with
    external requests that can arrive in any order, may take a variable amount of
    time, or may fail unpredictably. In this section, we will introduce the topic
    by explaining the main concepts and terminology as well as by giving an idea of
    how asynchronous programs work.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程是一种处理慢速和不可预测资源（如用户）的方法。异步程序能够同时高效地处理多个资源，而不是空闲等待资源可用。以异步方式编程可能具有挑战性，因为必须处理可能以任何顺序到达、可能花费可变的时间或可能不可预测地失败的外部请求。在本节中，我们将通过解释主要概念和术语以及异步程序的工作方式来介绍这个主题。
- en: Waiting for I/O
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待I/O
- en: A modern computer employs different kinds of memory to store data and perform
    operations. In general, a computer possesses a combination of expensive memory
    that is capable of operating at fast speeds and cheaper, and more abundant memory
    that operates at lower speeds and is used to store a larger amount of data.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现代计算机使用不同类型的内存来存储数据和执行操作。一般来说，计算机拥有能够以快速速度运行的昂贵内存和更便宜、更丰富的内存，后者以较慢的速度运行，用于存储大量数据。
- en: 'The memory hierarchy is shown in the following diagram:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了内存层次结构：
- en: '![](img/B06440_06CHPNO_01.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B06440_06CHPNO_01.png)'
- en: At the top of the memory hierarchy are the CPU registers. Those are integrated
    in the CPU and are used to store and execute machine instructions. Accessing data
    in a register generally takes one clock cycle. This means that if the CPU operates
    at 3 GHz, the time it takes to access one element in a CPU register is in the
    order of 0.3 nanoseconds.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存层次结构的顶部是CPU寄存器。这些是集成在CPU中的，用于存储和执行机器指令。在寄存器中访问数据通常需要一个时钟周期。这意味着如果CPU以3 GHz的速度运行，那么访问CPU寄存器中的一个元素所需的时间大约是0.3纳秒。
- en: At the layer just below the **registers**, you can find the CPU cache, which
    is comprised of multiple levels and is integrated in the processor. The **cache**
    operates at a slightly slower speed than the **registers** but within the same
    order of magnitude.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在**寄存器**层之下，你可以找到CPU缓存，它由多个级别组成，并集成在处理器中。**缓存**的运行速度略慢于**寄存器**，但处于同一数量级。
- en: The next item in the hierarchy is the main memory (**RAM**), which holds much
    more data but is slower than the cache. Fetching an item from memory can take
    a few hundred clock cycles.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 层次结构中的下一项是主存储器（**RAM**），它能够存储更多的数据，但比缓存慢。从内存中检索一个项目可能需要几百个时钟周期。
- en: At the bottom layer, you can find persistent storage, such as a rotating disks
    (HDD) and **Solid State Drives** (**SSD**). These devices hold the most data and
    are orders of magnitude slower than the main memory. An HDD may take a few milliseconds
    to seek and retrieve an item, while an SSD is substantially faster and takes only
    a fraction of a millisecond.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，你可以找到持久存储，例如旋转磁盘（HDD）和**固态硬盘**（**SSD**）。这些设备存储的数据最多，比主存储慢几个数量级。一个HDD可能需要几毫秒来定位和检索一个项目，而SSD则快得多，只需几分之一毫秒。
- en: To put the relative speed of each memory type into perspective, if you were
    to have the CPU with a clock speed of about one second, a register access would
    be equivalent to picking up a pen from the table. A cache access will be equivalent
    to picking up a book from the shelf. Moving higher in the hierarchy, a RAM access
    will be equivalent to loading up the laundry (about twenty x slower than the cache).
    When we move to persistent storage, things are quite a bit different. Retrieving
    an element from an SSD will be equivalent to doing a four day trip, while retrieving
    an element from an HDD can take up to six months! The times can stretch even further
    if we move on to access resources over the network.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将每种存储类型的相对速度置于一个可比较的视角，假设CPU的时钟速度大约为一秒，那么对寄存器的访问就相当于从桌子上拿起一支笔。对缓存的访问则相当于从书架上取下一本书。在层次结构中继续向上，对RAM的访问将相当于洗衣服（比缓存慢大约二十倍）。当我们转向持久存储时，情况就大不相同了。从SSD中检索一个元素将相当于进行四天的旅行，而从HDD中检索一个元素可能需要长达六个月！如果我们转向通过网络访问资源，时间可能会进一步延长。
- en: From the preceding example, it should be clear that accessing data from storage
    and other I/O devices is much slower compared to the CPU; therefore, it is very
    important to handle those resources so that the CPU is never stuck waiting aimlessly.
    This can be accomplished by carefully designing software capable of managing multiple,
    ongoing requests at the same time.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子中，应该很明显，从存储和其他I/O设备访问数据比CPU慢得多；因此，非常重要的是要妥善处理这些资源，以确保CPU不会无目的地等待。这可以通过精心设计软件来实现，该软件能够同时管理多个正在进行中的请求。
- en: Concurrency
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发
- en: Concurrency is a way to implement a system that is able to deal with multiple
    requests at the same time. The idea is that we can move on and start handling
    other resources while we wait for a resource to become available. Concurrency
    works by splitting a task into smaller subtasks that can be executed out of order
    so that multiple tasks can be partially advanced without waiting for the previous
    tasks to finish.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 并发是一种实现能够同时处理多个请求的系统的方法。其思想是，我们可以在等待资源可用时继续处理其他资源。并发通过将任务分割成可以无序执行的小子任务来实现，这样多个任务就可以在不等待前一个任务完成的情况下部分地向前推进。
- en: 'As a first example, we will describe how to implement concurrent access to
    a slow network resource. Let''s say we have a web service that takes the square
    of a number, and the time between our request and the response will be approximately
    one second.  We can implement the `network_request` function that takes a number
    and returns a dictionary that contains information about the success of the operation
    and the result. We can simulate such services using the `time.sleep` function,
    as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个例子，我们将描述如何实现对慢速网络资源的并发访问。假设我们有一个将数字平方的Web服务，我们的请求和响应之间的时间大约为一秒。我们可以实现`network_request`函数，该函数接受一个数字并返回一个包含操作成功信息和结果的字典。我们可以使用`time.sleep`函数来模拟这样的服务，如下所示：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will also write some additional code that performs the request, verifies
    that the request was successful, and prints the result. In the following code,
    we define the `fetch_square` function and use it to calculate the square of the
    number two using a call to `network_request`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将编写一些额外的代码来执行请求，验证请求是否成功，并打印结果。在下面的代码中，我们定义了`fetch_square`函数，并使用它通过调用`network_request`来计算数字二的平方：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Fetching a number from the network will take one second because of the slow
    network. What if we want to calculate the square of multiple numbers? We can call
    `fetch_square`, which will start a network request as soon as the previous one
    is done:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于网络速度慢，从网络上获取一个数字将需要一秒钟。如果我们想计算多个数字的平方呢？我们可以调用`fetch_square`函数，该函数将在前一个请求完成后立即启动网络请求：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The previous code will take three seconds to run, but it's not the best we can
    do. Waiting for the previous result to finish is unnecessary as we can technically
    submit multiple requests at and wait for them parallely.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将需要三秒钟来运行，但这并不是我们能做的最好的。等待前一个结果完成是不必要的，因为我们实际上可以提交多个请求并并行等待它们。
- en: 'In the following diagram, the three tasks are represented as boxes. The time
    spent by the CPU processing and submitting the request is in orange while the waiting
    times are in blue. You can see how most of the time is spent waiting for the resources
    while our machine sits idle without doing anything else:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，三个任务被表示为方框。CPU处理和提交请求所花费的时间用橙色表示，而等待时间用蓝色表示。您可以看到，大部分时间都花在等待资源上，而我们的机器闲置，什么也不做：
- en: '![](img/B06440_06CHPNO_02.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B06440_06CHPNO_02.png)'
- en: 'Ideally, we would like to start other new task while we are waiting for the
    already submitted tasks to finish. In the following figure, you can see that as
    soon as we submit our request in **fetch_square(2)**, we can start preparing for
    **fetch_square(3)** and so on. This allows us to reduce the CPU waiting time and
    to start processing the results as soon as they become available:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们希望在等待已提交的任务完成的同时开始其他新的任务。在下面的图中，您可以看到，当我们提交请求到**fetch_square(2)**后，我们可以立即开始准备**fetch_square(3)**等等。这使我们能够减少CPU的等待时间，并在结果可用时立即开始处理：
- en: '![](img/B06440_06CHPNO_03.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B06440_06CHPNO_03.png)'
- en: This strategy is made possible by the fact that the three requests are completely
    independent, and we don't need to wait for the completion of a previous task to
    start the next one. Also, note how a single CPU can comfortably handle this scenario.
    While distributing the work on multiple CPUs can further speedup the execution,
    if the waiting time is large compared to the processing times, the speedup will
    be minimal.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略之所以可行，是因为这三个请求是完全独立的，我们不需要等待前一个任务的完成就可以开始下一个任务。此外，请注意，单个CPU可以轻松地处理这种场景。虽然将工作分配到多个CPU可以进一步提高执行速度，但如果等待时间与处理时间相比很大，那么速度提升将是微不足道的。
- en: To implement concurrency, it is necessary to think and code differently; in
    the following sections, we'll demonstrate techniques and best practices to implement
    robust concurrent applications.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现并发，需要不同的思考和编码方式；在接下来的章节中，我们将展示实现健壮并发应用程序的技术和最佳实践。
- en: Callbacks
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调
- en: The code we have seen so far blocks the execution of the program until the resource
    is available. The call responsible for the waiting is `time.sleep`. To make the
    code start working on other tasks, we need to find a way to avoid blocking the
    program flow so that the rest of the program can go on with the other tasks.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止看到的代码会在资源可用之前阻塞程序的执行。负责等待的调用是`time.sleep`。为了使代码开始处理其他任务，我们需要找到一种方法来避免阻塞程序流程，以便程序的其余部分可以继续处理其他任务。
- en: One of the simplest ways to accomplish this behavior is through callbacks. The
    strategy is quite similar to what we do when we request a cab.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这种行为的最简单方法是通过回调。这种策略与我们请求出租车时所做的非常相似。
- en: Imagine that you are at a restaurant and you've had a few drinks. It's raining
    outside, and you'd rather not take the bus; therefore, you request a taxi and
    ask them to call when they're outside so that you can come out, and you don't
    have to wait in the rain.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在一家餐厅，已经喝了几杯酒。外面在下雨，你也不想坐公交车；因此，你要求叫一辆出租车，并让他们在你外面时打电话给你，这样你就可以出来，不必在雨中等待。
- en: What you did in this case is request a taxi (that is, the slow resource) but
    instead of waiting outside until the taxi arrives, you provide your number and
    instructions (callback) so that you can come outside when they're ready and go
    home.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你所做的是请求一辆出租车（即慢速资源），但你不是在外面等待出租车到达，而是提供你的电话号码和指示（回调），这样他们准备好时你可以出来，然后回家。
- en: We will now show how this mechanism can work in code. We will compare the blocking
    code of `time.sleep` with the equivalent non-blocking code of `threading.Timer`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将展示这种机制如何在代码中工作。我们将比较`time.sleep`的阻塞代码与等效的非阻塞代码`threading.Timer`。
- en: 'For this example, we will write a function, `wait_and_print`, that will block
    the program execution for one second and then print a message:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将编写一个函数`wait_and_print`，该函数将阻塞程序执行一秒钟，然后打印一条消息：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we want to write the same function in a non-blocking way, we can use the
    `threading.Timer` class. We can initialize a `threading.Timer` instance by passing
    the amount of time we want to wait and a callback. A **callback** is simply a
    function that will be called when the timer expires. Note that we have to also
    call the `Timer.start` method to activate the timer:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想以非阻塞的方式编写相同的函数，我们可以使用`threading.Timer`类。我们可以通过传递我们想要等待的时间量和回调函数来初始化一个`threading.Timer`实例。**回调**是一个当计时器到期时将被调用的函数。请注意，我们还需要调用`Timer.start`方法来激活计时器：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: An important feature of the `wait_and_print_async` function is that none of
    the statements are blocking the execution flow of the program.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`wait_and_print_async`函数的一个重要特性是，没有任何语句会阻塞程序的执行流程。'
- en: How is `threading.Timer` capable of waiting without blocking?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`threading.Timer`是如何在不阻塞的情况下等待的呢？'
- en: The strategy used by `threading.Timer` involves starting a new thread that is
    able to execute code in parallel. If this is confusing, don't worry, we will explore
    threading and parallel programming in detail in the following chapters.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`threading.Timer`使用的策略是启动一个新的线程，该线程能够并行执行代码。如果这让你感到困惑，不要担心，我们将在接下来的章节中详细探讨线程和并行编程。'
- en: This technique of registering callbacks for execution in response to certain
    events is commonly called the *Hollywood principle*. This is because, after an
    audition for a role at Hollywood, you may be told "<q>Don't call us, we'll call
    you</q>", meaning that they won't tell you if they chose you for the role immediately,
    but they'll call you in case they do.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这种在响应某些事件时注册回调以执行的技术通常被称为*好莱坞原则*。这是因为，在好莱坞试镜一个角色后，你可能会被告知"<q>不要给我们打电话，我们会给你打电话</q>"，这意味着他们不会立即告诉你是否选择了你，但如果他们选择了你，他们会给你打电话。
- en: 'To highlight the difference between the blocking and non-blocking version of
    `wait_and_print`, we can test and compare the execution of the two versions. In
    the output comments, the waiting periods are indicated by `<wait...>`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了突出`wait_and_print`的阻塞和非阻塞版本之间的差异，我们可以测试和比较两个版本的执行。在输出注释中，等待时间由`<wait...>`表示：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The synchronous version behaves in a very familiar way. The code waits for a
    second, prints `First call`, waits for another second, and then prints the `Second
    call` and `After call` messages.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 同步版本的行为非常熟悉。代码等待一秒钟，打印`First call`，然后等待另一秒钟，接着打印`Second call`和`After call`消息。
- en: In the asynchronous version, `wait_and_print_async` *submits  (*rather than
    *execute*) those calls and moves on *immediately*. You can see this mechanism
    in action by acknowledging that the `"After submission"` message is printed immediately.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步版本中，`wait_and_print_async`*提交*（而不是*执行*）那些调用，并立即继续。你可以通过确认“提交后”消息立即打印出来看到这个机制的作用。
- en: With this in mind, we can explore a slightly more complex situation by rewriting
    our `network_request` function using callbacks. In the following code, we define
    the `network_request_async` function. The biggest difference between `network_request_async` and
    its blocking counterpart is that `network_request_async` *doesn't return anything*.
    This is because we are merely submitting the request when `network_request_async`
    is called, but the value is available only when the request is completed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个前提下，我们可以通过使用回调重写我们的`network_request`函数来探索一个稍微复杂的情况。在下面的代码中，我们定义了`network_request_async`函数。`network_request_async`与其阻塞版本之间最大的区别是`network_request_async`*不返回任何内容*。这是因为我们在调用`network_request_async`时仅提交请求，但值只有在请求完成时才可用。
- en: If we can't return anything, how do we pass the result of the request? Rather
    than returning the value, we will pass the result as an argument to the `on_done`
    callback.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们无法返回任何内容，我们如何传递请求的结果？与其返回值，我们不如将结果作为参数传递给`on_done`回调函数。
- en: 'The rest of the function consists of submitting a callback (called `timer_done`)
    to the `timer.Timer` class that will call `on_done` when it''s ready:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的其余部分包括向`timer.Timer`类提交一个回调（称为`timer_done`），当它准备好时将调用`on_done`：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The usage of `network_request_async` is quite similar to `timer.Timer`; all
    we have to do is pass the number we want to square and a callback that will receive
    the result *when it''s ready*. This is demonstrated in the following snippet:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`network_request_async`的使用与`timer.Timer`非常相似；我们只需传递我们想要平方的数字和一个将在结果准备好时接收结果的回调函数。这将在下面的代码片段中演示：'
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, if we submit multiple network requests, we note that the calls get executed
    concurrently and do not block the code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们提交多个网络请求，我们会注意到调用是并发执行的，并不会阻塞代码：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In order to use `network_request_async` in `fetch_square`, we need to adapt
    the code to use asynchronous constructs. In the following code, we modify `fetch_square`
    by defining and passing the `on_done` callback to `network_request_async`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在`fetch_square`中使用`network_request_async`，我们需要修改代码以使用异步构造。在下面的代码中，我们通过定义和传递`on_done`回调到`network_request_async`来修改`fetch_square`：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You may have noted that the asynchronous code is significantly more convoluted
    than its synchronous counterpart. This is due to the fact that we are required
    to write and pass a callback every time we need to retrieve a certain result,
    causing the code to become nested and hard to follow.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，异步代码比它的同步版本要复杂得多。这是因为每次我们需要检索某个结果时，都必须编写和传递一个回调，导致代码变得嵌套且难以跟踪。
- en: Futures
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 期货
- en: Futures are a more convenient pattern that can be used to keep track of the
    results of asynchronous calls. In the preceding code, we saw that rather than
    returning values, we accept callbacks and pass the results when they are ready.
    It is interesting to note that, so far, there is no easy way to track the status
    of the resource.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 期货是一种更方便的模式，可以用来跟踪异步调用的结果。在前面的代码中，我们看到我们不是返回值，而是接受回调，并在结果准备好时传递结果。值得注意的是，到目前为止，还没有简单的方法来跟踪资源的状态。
- en: 'A **future** is an abstraction that helps us keep track of the requested resources
    and that we are waiting to become available. In Python, you can find a future
    implementation in the `concurrent.futures.Future` class. A `Future` instance can
    be created by calling its constructor with no arguments:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 期货是一个抽象，帮助我们跟踪请求的资源，并等待它们变得可用。在Python中，你可以在`concurrent.futures.Future`类中找到期货的实现。可以通过不带参数调用其构造函数来创建`Future`实例：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A future represents a value that is not yet available. You can see that its
    string representation reports the current status of the result which, in our case,
    is still pending. In order to make a result available, we can use the `Future.set_result` method:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 期货代表一个尚未可用的值。你可以看到它的字符串表示报告了结果当前的状态，在我们的例子中，仍然是挂起的。为了使结果可用，我们可以使用`Future.set_result`方法：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can see that once we set the result, the `Future` will report that the
    task is finished and can be accessed using the `Future.result` method. It is also
    possible to subscribe a callback to a future so that, as soon as the result is
    available, the callback is executed. To attach a callback, it is sufficient to
    pass a function to the `Future.add_done_callback` method. When the task completes,
    the function will be called with the `Future` instance as its first argument and
    the result can be retrieved using the `Future.result()` method:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，一旦我们设置了结果，`Future`将报告任务已完成，并且可以使用`Future.result`方法访问。还可能订阅一个回调到期货，以便一旦结果可用，回调就会被执行。要附加回调，只需将一个函数传递给`Future.add_done_callback`方法。当任务完成时，该函数将以`Future`实例作为其第一个参数被调用，并且可以使用`Future.result()`方法检索结果：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To get a grasp on how futures can be used in practice, we will adapt the `network_request_async`
    function to use futures. The idea is that, this time, instead of returning nothing,
    we return a `Future` that will keep track of the result for us. Note two things:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解期货在实际中的应用，我们将`network_request_async`函数修改为使用期货。想法是，这次，我们不是返回空值，而是返回一个`Future`，它会为我们跟踪结果。注意两点：
- en: We don't need to accept an `on_done callback` as callbacks can be connected
    later using the `Future.add_done_callback` method. Also, we pass the generic `Future.set_result`
    method as the callback for `threading.Timer`.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不需要接受`on_done callback`，因为回调可以在之后使用`Future.add_done_callback`方法连接。此外，我们将通用的`Future.set_result`方法作为`threading.Timer`的回调。
- en: 'This time we are able to return a value, thus making the code a bit more similar
    to the blocking version we saw in the preceding section:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这次我们能够返回一个值，从而使代码与我们在上一节中看到的阻塞版本更加相似：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Even though we instantiate and manage futures directly in these examples; in
    practical applications, the futures are handled by frameworks.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这些例子中我们直接实例化和管理期货；在实际应用中，期货是由框架处理的。
- en: 'If you execute the preceding code, nothing will happen as the code only consists
    of preparing and returning a `Future` instance. To enable further operation of
    the future results, we need to use the `Future.add_done_callback` method. In the
    following code, we adapt the `fetch_square` function to use futures:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行前面的代码，将不会发生任何事情，因为代码只包含准备和返回一个`Future`实例。为了启用对未来的进一步操作，我们需要使用`Future.add_done_callback`方法。在下面的代码中，我们将`fetch_square`函数调整为使用futures：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The code still looks quite similar to the callback version. Futures are a different
    and slightly more convenient way of working with callbacks. Futures are also advantageous,
    because they can keep track of the resource status, cancel (unschedule) scheduled
    tasks, and handle exceptions more naturally.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来仍然与回调版本非常相似。Futures是处理回调的不同且稍微方便一些的方式。Futures还有优势，因为它们可以跟踪资源状态，取消（取消调度）已安排的任务，并且更自然地处理异常。
- en: Event loops
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件循环
- en: So far, we have implemented parallelism using OS threads. However, in many asynchronous
    frameworks, the coordination of concurrent tasks is managed by an **event loop**.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用操作系统线程实现了并行性。然而，在许多异步框架中，并发任务的协调是由**事件循环**管理的。
- en: The idea behind an event loop is to continuously monitor the status of the various
    resources (for example, network connections and database queries) and trigger
    the execution of callbacks when events take place (for example, when a resource
    is ready or when a timer expires).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环背后的想法是持续监控各种资源的状态（例如，网络连接和数据库查询），并在事件发生时（例如，当资源就绪或计时器过期时）触发回调的执行。
- en: Why not just stick to threading?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不坚持使用线程呢？
- en: Events loops are sometimes preferred as every unit of execution never runs at
    the same time as another and this can simplify dealing with shared variables,
    data structures, and resources. Read the next chapter for more details about parallel
    execution and its shortcomings.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有时人们更喜欢事件循环，因为每个执行单元永远不会同时运行，这可以简化处理共享变量、数据结构和资源。阅读下一章了解更多关于并行执行及其缺点的详细信息。
- en: 'As a first example, we will implement a thread-free version of `threading.Timer`.
    We can define a `Timer` class that will take a timeout and implement the `Timer.done` method
    that returns `True` if the timer has expired:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个例子，我们将实现一个无线程版本的`threading.Timer`。我们可以定义一个`Timer`类，它将接受一个超时时间，并实现一个`Timer.done`方法，如果计时器已过期则返回`True`：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To determine whether the timer has expired, we can write a loop that continuously
    checks the timer status by calling the `Timer.done` method. When the timer expires,
    we can print a message and exit the cycle:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定计时器是否已过期，我们可以编写一个循环，通过调用`Timer.done`方法连续检查计时器状态。当计时器过期时，我们可以打印一条消息并退出循环：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: By implementing the timer in this way, the flow of execution is never blocked
    and we can, in principle, do other work inside the while loop.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式实现计时器，执行流程永远不会被阻塞，原则上我们可以在while循环内部做其他工作。
- en: Waiting for events to happen by continuously polling using a loop is commonly
    termed as *busy-waiting*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过循环不断轮询等待事件发生，通常被称为*忙等待*。
- en: 'Ideally, we would like to attach a custom function that executes when the timer
    goes off, just like we did in `threading.Timer`. To do this, we can implement
    a method, `Timer.on_timer_done`, that will accept a callback to be executed when
    the timer goes off:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们希望附加一个自定义函数，当计时器响起时执行，就像我们在`threading.Timer`中做的那样。为此，我们可以实现一个方法，`Timer.on_timer_done`，它将接受一个回调，当计时器响起时执行：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note that `on_timer_done` merely stores a reference to the callback. The entity
    that monitors the event and executes the callback is the loop. This concept is
    demonstrated as follows. Rather than using the print function, the loop will call
    `timer.callback` when appropriate:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`on_timer_done`仅仅存储了回调的引用。监控事件并执行回调的是循环。这一概念如下所示。而不是使用打印函数，循环将在适当的时候调用`timer.callback`：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, an asynchronous framework is starting to take place. All we
    did outside the loop was define the timer and the callback, while the loop took
    care of monitoring the timer and executing the associated callback. We can further
    extend our code by implementing support for multiple timers.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，异步框架正在开始占据一席之地。我们在循环之外所做的所有事情只是定义计时器和回调，而循环则负责监控计时器并执行相关的回调。我们可以通过实现对多个计时器的支持来进一步扩展我们的代码。
- en: 'A natural way to implement multiple timers is to add a few `Timer` instances
    to a list and modify our event loop to periodically check all the timers and dispatch
    the callbacks when required. In the following code, we define two timers and attach
    a callback to each of them. Those timers are added to a list, `timers`, that is
    continuously monitored by our event loop. As soon as a timer is done, we execute
    the callback and remove the event from the list:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 实现多个计时器的一种自然方式是将几个`Timer`实例添加到一个列表中，并修改我们的事件循环，使其定期检查所有计时器，并在需要时调度回调。在下面的代码中，我们定义了两个计时器，并将它们各自附加了一个回调。这些计时器被添加到列表`timers`中，该列表由我们的事件循环持续监控。一旦计时器完成，我们就执行回调并将事件从列表中删除：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The main restriction of an event loop is, since the flow of execution is managed
    by a continuously running loop, that it **never uses blocking calls**. If we use
    any blocking statement (such as `time.sleep`) inside the loop, you can imagine
    how the event monitoring and callback dispatching will stop until the blocking
    call is done.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环的主要限制是，由于执行流程是由一个持续运行的循环管理的，因此它**永远不会使用阻塞调用**。如果我们在这个循环中使用任何阻塞语句（例如`time.sleep`），你可以想象事件监控和回调调度将停止，直到阻塞调用完成。
- en: To avoid this, rather than using a blocking call, such as `time.sleep`, we let
    the event loop detect and execute the callback when the resource is ready. By
    not blocking the execution flow, the event loop is free to monitor multiple resources
    in a concurrent way.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，我们不是使用阻塞调用，如`time.sleep`，而是让事件循环在资源准备好时检测并执行回调。通过不阻塞执行流程，事件循环可以自由地以并发方式监控多个资源。
- en: The notification for events is usually implemented through operating system
    calls (such as the `select` Unix tool) that will resume the execution of the program
    whenever an event is ready (in contrast to busy-waiting).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 事件的通知通常是通过操作系统调用（例如`select` Unix工具）来实现的，这些调用会在事件准备好时（与忙等待相反）恢复程序的执行。
- en: The Python standard libraries include a very convenient event loop-based concurrency
    framework, `asyncio`, which will be the topic of the next section.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Python 标准库包括一个非常方便的事件循环基于的并发框架，`asyncio`，这将是下一节的主题。
- en: The asyncio framework
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: asyncio 框架
- en: By now, you should have a solid foundation of how concurrency works, and how
    to use callbacks and futures. We can now move on and learn how to use the `asyncio`
    package present in the standard library since version 3.4\. We will also explore
    the brand new `async`/`await` syntax to deal with asynchronous programming in
    a very natural way.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经对并发的工作原理以及如何使用回调和未来有了坚实的基础。现在我们可以继续学习如何使用从版本 3.4 开始的标准库中存在的`asyncio`包。我们还将探索全新的`async`/`await`语法，以非常自然的方式处理异步编程。
- en: 'As a first example, we will see how to retrieve and execute a simple callback
    using `asyncio`. The `asyncio` loop can be retrieved by calling the `asyncio.get_event_loop()` function.
    We can schedule a callback for execution using  `loop.call_later` that takes a
    delay in seconds and a callback. We can also use the `loop.stop` method to halt
    the loop and exit the program.  To start processing the scheduled call, it is
    necessary to start the loop, which can be done using `loop.run_forever`. The following
    example demonstrates the usage of these basic methods by scheduling a callback
    that will print a message and halt the loop:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个示例，我们将看到如何使用`asyncio`检索和执行一个简单的回调。可以通过调用`asyncio.get_event_loop()`函数来检索`asyncio`循环。我们可以使用`loop.call_later`来调度一个回调执行，该函数接受秒数延迟和回调。我们还可以使用`loop.stop`方法来停止循环并退出程序。要开始处理计划中的调用，必须启动循环，这可以通过`loop.run_forever`来完成。以下示例通过调度一个将打印消息并停止循环的回调来演示这些基本方法的用法：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Coroutines
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协程
- en: One of the main problems with callbacks is that they require you to break the
    program execution into small functions that will be invoked when a certain event
    takes place. As we saw in the earlier sections, callbacks can quickly become cumbersome.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数的一个主要问题在于，它们要求你将程序执行分解成小的函数，这些函数将在某个事件发生时被调用。正如我们在前面的章节中看到的，回调函数很快就会变得繁琐。
- en: Coroutines are another, perhaps a more natural, way to break up the program
    execution into chunks. They allow the programmer to write code that resembles
    synchronous code but will execute asynchronously. You may think of a coroutine
    as a function that can be stopped and resumed. A basic example of coroutines is generators.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 协程是另一种，也许更自然的方法，将程序执行分解成块。它们允许程序员编写类似于同步代码的代码，但将以异步方式执行。你可以把协程想象成一个可以被停止和恢复的函数。协程的基本例子是生成器。
- en: 'Generators can be defined in Python using the `yield` statement inside a function.
    In the following example, we implement the `range_generator` function, which produces
    and returns values from `0` to `n`. We also add a print statement to log the internal
    state of the generator:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器可以在 Python 中使用函数内的 `yield` 语句定义。在下面的例子中，我们实现了 `range_generator` 函数，它从 `0`
    到 `n` 产生并返回值。我们还添加了一个打印语句来记录生成器的内部状态：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When we call the `range_generator` function, the code is not executed immediately.
    Note that nothing is printed to output when the following snippet is executed.
    Instead, a *generator object* is returned:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `range_generator` 函数时，代码不会立即执行。注意，当执行以下代码片段时，没有任何内容打印到输出。相反，返回了一个 *生成器对象*：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In order to start pulling values from a generator, it is necessary to use the
    `next` function:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始从生成器中提取值，必须使用 `next` 函数：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that every time we invoke `next`, the code runs until it encounters the
    next `yield` statement and it is necessary to issue another `next` statement to
    resume the generator execution. You can think of a `yield` statement as a breakpoint
    where we can stop and resume execution (while also maintaining the internal state
    of the generator). This ability of stopping and resuming execution can be leveraged
    by the event loop to allow for concurrency.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每次我们调用 `next` 时，代码会运行直到遇到下一个 `yield` 语句，并且必须发出另一个 `next` 语句来恢复生成器的执行。你可以把
    `yield` 语句看作是一个断点，在那里我们可以停止和恢复执行（同时保持生成器的内部状态）。这种停止和恢复执行的能力可以被事件循环利用，以实现并发。
- en: 'It is also possible to *inject* (rather than *extract)* values in the generator
    through the `yield` statement. In the following example, we declare a function
    parrot that will repeat each message that we send. To allow a generator to receive
    a value, you can assign yield to a variable (in our case, it is `message = yield`).
    To insert values in the generator, we can use the `send` method. In the Python
    world, a generator that can also receive values is called a *generator-based coroutine*:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过 `yield` 语句在生成器中 *注入*（而不是 *提取*）值。在下面的例子中，我们声明了一个名为 parrot 的函数，它将重复发送的每条消息。为了允许生成器接收一个值，你可以将
    `yield` 赋值给一个变量（在我们的例子中，它是 `message = yield`）。要在生成器中插入值，我们可以使用 `send` 方法。在 Python
    世界中，既能接收值又能产生值的生成器被称为 *基于生成器的协程*：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that we also need to issue a `generator.send(None)` before we can start
    sending messages; this is done to bootstrap the function execution and bring us
    to the first `yield` statement. Also, note that there is an infinite loop inside
    `parrot`; if we implement this without using generators, we will get stuck running
    the loop forever!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在我们开始发送消息之前，我们还需要发出 `generator.send(None)`；这是为了启动函数执行并带我们到第一个 `yield` 语句。另外，注意
    `parrot` 中有一个无限循环；如果我们不使用生成器来实现这个循环，我们将陷入无限循环中！
- en: With this in mind, you can imagine how an event loop can partially progress
    several of these generators without blocking the execution of the whole program.
    You can also imagine how a generator can be advanced only when some resource is
    ready, therefore eliminating the need for a callback.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可以想象事件循环如何在不阻塞整个程序执行的情况下部分地推进这些生成器。你也可以想象，只有在某些资源准备好时，生成器才能被推进，从而消除了回调的需要。
- en: It is possible to implement coroutines in `asyncio` using the `yield` statement.
    However, Python supports the definition of powerful coroutines using a more intuitive
    syntax since version 3.5.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `asyncio` 可以通过 `yield` 语句实现协程。然而，自 Python 3.5 版本以来，Python 支持使用更直观的语法定义强大的协程。
- en: 'To define a coroutine with `asyncio`, you can use the `async def` statement:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `asyncio` 定义协程，你可以使用 `async def` 语句：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As you can see, if we call the `hello` function, the function body is not executed
    immediately, but a *coroutine object* is returned. The `asyncio` coroutines do
    not support `next`, but they can be easily run in the `asyncio` event loop using
    the `run_until_complete` method:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，如果我们调用 `hello` 函数，函数体不会立即执行，而是返回一个 *协程对象*。`asyncio` 协程不支持 `next`，但它们可以很容易地通过使用
    `run_until_complete` 方法在 `asyncio` 事件循环中运行：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Coroutines defined with the `async def` statement are also called *native coroutines*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `async def` 语句定义的协程也被称为 *原生协程*。
- en: 'The `asyncio`  module provides resources (called *awaitables*) that can be
    requested inside coroutines through the `await` syntax. For example, if we want
    to wait for a certain time and then execute a statement, we can use the `asyncio.sleep` function:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio` 模块提供了资源（称为 *awaitables*），这些资源可以通过 `await` 语法在协程内部请求。例如，如果我们想等待一段时间然后执行一个语句，我们可以使用
    `asyncio.sleep` 函数：'
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The result is beautiful, clean code. We are writing perfectly functional asynchronous
    code without all the ugliness of callbacks!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是漂亮的、干净的代码。我们正在编写功能齐全的异步代码，而没有回调的所有丑陋之处！
- en: You may have noted how `await` provides a breakpoint for the event loop so that,
    as it wait for the resource, the event loop can move on and concurrently manage
    other coroutines.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了 `await` 如何为事件循环提供一个断点，这样在等待资源的同时，事件循环可以继续运行并并发管理其他协程。
- en: 'Even better, coroutines are also `awaitable`, and we can use the `await` statement
    to chain coroutines asynchronously. In the following example, we rewrite the `network_request` function,
    which we defined earlier, by replacing the call to `time.sleep` with `asyncio.sleep`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，协程也是 `awaitable` 的，我们可以使用 `await` 语句来异步地链式调用协程。在下面的示例中，我们通过将 `time.sleep`
    调用替换为 `asyncio.sleep` 来重写我们之前定义的 `network_request` 函数：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We can follow up by reimplementing `fetch_square`. As you can see, we can await
    `network_request` directly without needing additional futures or callbacks.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过重新实现 `fetch_square` 来跟进。正如你所看到的，我们可以直接等待 `network_request`，而不需要额外的 futures
    或回调。
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The coroutines can be executed individually using `loop.run_until_complete`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `loop.run_until_complete` 单独执行协程：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Running tasks using `run_until_complete` is fine for testing and debugging.
    However, our program will be started with `loop.run_forever` most of the times,
    and we will need to submit our tasks while the loop is already running.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `run_until_complete` 运行任务对于测试和调试来说是可行的。然而，我们的程序大多数情况下将以 `loop.run_forever`
    启动，并且我们需要在循环已经运行时提交我们的任务。
- en: '`asyncio` provides the `ensure_future` function, which schedules coroutines
    (as well as futures) for execution. `ensure_future` can be used by simply passing
    the coroutine we want to schedule. The following code will schedule multiple calls
    to `fetch_square` that will be executed concurrently:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio` 提供了 `ensure_future` 函数，该函数安排协程（以及 futures）的执行。`ensure_future` 可以通过简单地传递我们想要安排的协程来使用。以下代码将安排多个并发执行的
    `fetch_square` 调用：'
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As a bonus, when passing a coroutine, the `asyncio.ensure_future` function will
    return a `Task` instance (which is a subclass of `Future`) so that we can take
    advantage of the await syntax without having to give up the resource tracking
    capabilities of regular futures.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的好处，当传递一个协程时，`asyncio.ensure_future` 函数将返回一个 `Task` 实例（它是 `Future` 的子类），这样我们就可以利用
    `await` 语法，而不必放弃常规未来的资源跟踪能力。
- en: Converting blocking code into non-blocking code
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将阻塞代码转换为非阻塞代码
- en: While `asyncio` supports connecting to resources in an asynchronous way, it
    is required to use blocking calls in certain cases. This happens, for example,
    when third-party APIs exclusively expose blocking calls (for example, many database
    libraries), but also when executing long-running computations. In this subsection,
    we will learn how to deal with blocking APIs and make them compatible with `asyncio`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `asyncio` 支持以异步方式连接到资源，但在某些情况下需要使用阻塞调用。例如，当第三方 API 仅公开阻塞调用（例如，许多数据库库）时，以及执行长时间运行的计算时，这种情况会发生。在本小节中，我们将学习如何处理阻塞
    API 并使其与 `asyncio` 兼容。
- en: An effective strategy for dealing with blocking code is to run it in a separate
    thread. Threads are implemented at the **Operating System** (**OS**) level and
    allow parallel execution of blocking code. For this purpose, Python provides the
    `Executor` interface designed to run tasks in a separate thread and to monitor
    their progress using futures.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 处理阻塞代码的有效策略是在单独的线程中运行它。线程在 **操作系统** （**OS**） 级别实现，并允许并行执行阻塞代码。为此，Python 提供了
    `Executor` 接口，用于在单独的线程中运行任务，并使用未来来监控它们的进度。
- en: You can initialize a `ThreadPoolExecutor` by importing it from the `concurrent.futures`
    module. The executor will spawn a collection of threads (called `workers`) that
    will wait to execute whatever task we throw at them. Once a function is submitted,
    the executor will take care of dispatching its execution to an available worker
    thread and keep track of the result. The `max_workers` argument can be used to
    select the number of threads.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过从 `concurrent.futures` 模块导入它来初始化 `ThreadPoolExecutor`。执行器将启动一组线程（称为 `workers`），它们将等待执行我们向它们投递的任何任务。一旦提交了一个函数，执行器将负责将其执行调度到可用的工作线程，并跟踪结果。可以使用
    `max_workers` 参数来选择线程数。
- en: Note that the executor will not destroy a thread once a task is completed. By
    doing so, it reduces the cost associated with the creation and destruction of
    threads.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一旦任务完成，执行器不会销毁一个线程。这样做可以减少与线程创建和销毁相关的成本。
- en: 'In the following example, we create a `ThreadPoolExecutor` with three workers,
    and we submit a `wait_and_return` function that will block the program execution
    for one second and return a message string. We then use the `submit` method to
    schedule its execution:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们创建了一个具有三个工作者的 `ThreadPoolExecutor`，并提交了一个 `wait_and_return` 函数，该函数将阻塞程序执行一秒钟并返回一个消息字符串。然后我们使用
    `submit` 方法来安排其执行：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `executor.submit` method immediately schedules the function and returns
    a future. It is possible to manage the execution of tasks in `asyncio` using the
    `loop.run_in_executor` method, which works quite similarly to `executor.submit`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`executor.submit` 方法立即安排函数并返回一个未来。可以使用 `loop.run_in_executor` 方法来管理 `asyncio`
    中的任务执行，该方法与 `executor.submit` 工作方式非常相似：'
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `run_in_executor` method will also return an `asyncio.Future` instance
    that can be awaited from other code, the main difference being that the future
    will not be run until we start the loop. We can run and obtain the response using
    `loop.run_until_complete`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`run_in_executor` 方法也会返回一个 `asyncio.Future` 实例，可以从其他代码中等待，主要区别在于未来将不会运行，直到我们开始循环。我们可以使用
    `loop.run_until_complete` 来运行并获取响应：'
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As a practical example, we can use this technique to implement concurrent fetching
    of several web pages. To do this, we will import the popular (blocking) `requests`
    library and run the `requests.get` function in the executor:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 作为实际示例，我们可以使用这项技术来实现多个网页的并发获取。为此，我们将导入流行的（阻塞的）`requests` 库，并在执行器中运行 `requests.get`
    函数：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This version of `fetch_url` will not block the execution and allow other coroutines
    in `asyncio` to run; however, it is not optimal as the function will not fetch
    a URL in parallel. To do this, we can use `asyncio.ensure_future` or employ the
    `asyncio.gather` convenience function that will submit all the coroutines at once
    and gather the results as they come. The usage of `asyncio.gather` is demonstrated
    here:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此版本的 `fetch_url` 不会阻塞执行，并允许 `asyncio` 中的其他协程运行；然而，它并不理想，因为函数不会并行获取 URL。为此，我们可以使用
    `asyncio.ensure_future` 或使用 `asyncio.gather` 便利函数，该函数将一次性提交所有协程并收集结果。这里展示了 `asyncio.gather`
    的用法：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The number of URLs you can fetch in parallel with this method will be dependent
    on the number of worker threads you have. To avoid this limitation, you should
    use a natively non-blocking library, such as `aiohttp`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法可以并行获取的 URL 数量将取决于您拥有的工作线程数量。为了避免这种限制，您应该使用原生的非阻塞库，例如 `aiohttp`。
- en: Reactive programming
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式编程
- en: 'Reactive programming is a paradigm that aims at building better concurrent
    systems. Reactive applications are designed to comply with the requirements exemplified
    by the reactive manifesto:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程是一种旨在构建更好的并发系统的范式。响应式应用程序旨在符合响应式宣言中例示的要求：
- en: '**Responsive**:  The system responds immediately to the user.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应式**：系统立即响应用户。'
- en: '**Elastic**: The system is capable of handling different levels of load and
    is able to adapt to accommodate increasing demands.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：系统能够处理不同级别的负载，并能适应不断增长的需求。'
- en: '**Resilient**: The system deals with failure gracefully. This is achieved by
    modularity and avoiding having a single point of failure.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：系统优雅地处理故障。这是通过模块化和避免单一故障点来实现的。'
- en: '**Message driven**: The system should not block and take advantage of events
    and messages. A message-driven application helps achieve all the previous requirements.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息驱动**：系统不应阻塞并利用事件和消息。消息驱动型应用程序有助于实现所有先前的要求。'
- en: As you can see, the intent of reactive systems is quite noble, but how exactly
    does reactive programming work? In this section, we will learn about the principles
    of reactive programming using the RxPy library.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，反应式系统的意图非常崇高，但反应式编程究竟是如何工作的呢？在本节中，我们将通过使用 RxPy 库来学习反应式编程的原则。
- en: The RxPy library is part of ReactiveX ([http://reactivex.io/](http://reactivex.io/)),
    which is a project that implements reactive programming tools for a large variety
    of languages.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: RxPy 库是 ReactiveX ([http://reactivex.io/](http://reactivex.io/)) 的一部分，ReactiveX
    是一个实现多种语言反应式编程工具的项目。
- en: Observables
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可观察对象
- en: As the name implies, the main idea of reactive programming is to *react* to
    events. In the preceding section, we saw some examples of this idea with callbacks;
    you subscribe to them and the callback is executed as soon as the event takes
    place.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如同其名所暗示的，反应式编程的主要思想是*响应*事件。在前一节中，我们通过回调示例看到了这个想法的一些例子；您订阅它们，回调在事件发生时立即执行。
- en: 'In reactive programming, this idea is expanded by thinking of events as streams
    of data. This can be exemplified by showing examples of such streams in RxPy.
    A data stream can be created from an iterator using the `Observable.from_iterable`
    factory method, as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在反应式编程中，这种想法通过将事件视为数据流来扩展。这可以通过在 RxPy 中展示此类数据流的示例来体现。可以使用 `Observable.from_iterable`
    工厂方法从迭代器创建数据流，如下所示：
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In order to receive data from `obs`, we can use the `Observable.subscribe` method,
    which will execute the function we pass for each value that the data source emits:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从 `obs` 接收数据，我们可以使用 `Observable.subscribe` 方法，该方法将为数据源发出的每个值执行我们传递的函数：
- en: '[PRE38]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You may have noted that observables are ordered collections of items just like
    lists or, more generally, iterators. This is not a coincidence.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，可观察对象就像列表或更一般地说，迭代器一样是有序集合。这不是巧合。
- en: The term observable comes from the combination of observer and iterable. An
    *observer* is an object that reacts to changes of the variable it observes, while
    an *iterable* is an object that is capable of producing and keeping track of an
    iterator.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: “可观察”一词来自观察者和可迭代的组合。一个*观察者*是一个对它观察的变量的变化做出反应的对象，而一个*可迭代*是一个能够产生并跟踪迭代器的对象。
- en: 'In Python, iterators are objects that define the `__next__` method, and whose
    elements can be extracted by calling `next`. An iterator can generally be obtained
    by a collection using `iter`; then we can extract elements using `next` or a `for`
    loop. Once an element is consumed from the iterator, we can''t go back. We can
    demonstrate its usage by creating an iterator from a list:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，迭代器是定义了 `__next__` 方法的对象，并且可以通过调用 `next` 提取其元素。迭代器通常可以通过使用 `iter`
    从集合中获得；然后我们可以使用 `next` 或 `for` 循环提取元素。一旦从迭代器中消耗了一个元素，我们就不能回退。我们可以通过从列表创建迭代器来演示其用法：
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You can see how, every time we call `next` or we iterate, the iterator produces
    a value and advances. In a sense, we are *pulling* results from the iterator.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，每次我们调用 `next` 或迭代时，迭代器都会产生一个值并前进。从某种意义上说，我们是从迭代器中“拉取”结果。
- en: Iterators sound a lot like generators; however, they are more general. In Python,
    generators are returned by functions that use yield expressions. As we saw, generators
    support `next`, therefore, they are a special class of iterators.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器听起来很像生成器；然而，它们更为通用。在 Python 中，生成器是由使用 yield 表达式的函数返回的。正如我们所见，生成器支持 `next`，因此，它们是迭代器的一个特殊类别。
- en: 'Now you can appreciate the contrast between an iterator and an observable. 
    An observable*pushes* a stream of data to us whenever it''s ready, but that''s
    not everything. An observable is also able to tell us when there is an error and
    where there is no more data. In fact, it is possible to register further callbacks
    to the `Observable.subscribe` method. In the following example, we create an observable
    and register callbacks to be called using `on_next` whenever the next item is
    available and using the `on_completed` argument when there is no more data:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以欣赏到迭代器和可观察对象之间的对比。可观察对象在准备好时将数据流 *推送* 给我们，但这不仅仅是这样。可观察对象还能告诉我们何时出现错误以及何时没有更多数据。实际上，可以注册更多的回调到
    `Observable.subscribe` 方法。在以下示例中，我们创建了一个可观察对象，并注册了回调，当有下一个项目可用时使用 `on_next` 调用，当没有更多数据时使用
    `on_completed` 参数：
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This analogy with the iterator is important because we can use the same techniques
    that can be used with iterators to handle streams of events.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个与迭代器的类比很重要，因为我们可以使用与迭代器相同的技巧来处理事件流。
- en: RxPy provides operators that can be used to create, transform, filter, and group
    observables. The power of reactive programming lies in the fact that those operations
    return other observables that can be conveniently chained and composed together.
    For a quick taste, we will demonstrate the usage of the `take` operator.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: RxPy 提供了可以用来创建、转换、过滤和分组可观察对象的操作符。响应式编程的强大之处在于，这些操作返回其他可观察对象，可以方便地链接和组合在一起。为了快速体验，我们将演示
    `take` 操作符的使用。
- en: 'Given an observable, `take` will return a new observable that will stop after
    `n` items. Its usage is straightforward:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个可观察对象，`take` 将返回一个新的可观察对象，该对象将在 `n` 个项目后停止。其用法很简单：
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The collection of operations implemented in RxPy is varied and rich, and can
    be used to build complex applications using these operators as building blocks.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RxPy 中实现的操作集合多种多样且丰富，可以用这些操作符作为构建块来构建复杂的应用程序。
- en: Useful operators
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用的操作符
- en: 'In this subsection, we will explore operators that transform the elements of
    a source observable in some way. The most prominent member of this family of operators
    is the familiar `map`, which emits the elements of the source observable after
    applying a function to them. For example, we may use `map` to calculate the square
    of a sequence of numbers:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将探讨以某种方式转换源可观察对象元素的运算符。这个家族中最突出的成员是熟悉的 `map`，它在应用函数后发出源可观察对象的元素。例如，我们可能使用
    `map` 来计算数字序列的平方：
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Operators can be represented with marble diagrams that help us better understand
    how the operator works, especially when taking into account the fact that elements
    can be emitted over a region of time. In a marble diagram, a data stream (in our
    case, an observable) is represented by a solid line. A circle (or other shape)
    identifies a value emitted by the observable, an **X** symbol represents an error,
    and a vertical line represents the end of the stream.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符可以用水滴图来表示，这有助于我们更好地理解操作符的工作原理，尤其是在考虑到元素可以在一段时间内发出时。在水滴图中，数据流（在我们的例子中，是一个可观察对象）由一条实线表示。一个圆圈（或其他形状）标识由可观察对象发出的值，一个
    **X** 符号表示错误，一条垂直线表示流的结束。
- en: 'In the following figure, we can see the marble diagram of **map**:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，我们可以看到 **map** 的水滴图：
- en: '![](img/B06440_06CHPNO_04.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06440_06CHPNO_04.png)'
- en: The source observable is placed at the top of the diagram, the transformation
    is placed in the middle, and the resulting observable is placed at the bottom.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 源可观察对象位于图的顶部，转换位于中间，结果可观察对象位于底部。
- en: Another example of a transformation is `group_by`, which sorts the items into
    groups based on a key. The `group_by` operator takes a function that extracts
    a key when given an element and produces an observable for each key with the elements
    associated to it.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个转换的例子是 `group_by`，它根据键将项目排序到组中。`group_by` 操作符接受一个函数，当给定一个元素时提取一个键，并为每个键生成一个与相关元素关联的可观察对象。
- en: 'The `group_by` operation can be expressed more clearly using a marble diagram.
    In the following figure, you can see how `group_by` emits two observables. Additionally,
    the items are dynamically sorted into groups *as soon as they are emitted*:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用水滴图可以更清楚地表达 `group_by` 操作。在下面的图中，你可以看到 `group_by` 发出两个可观察对象。此外，项目在发出后立即动态地排序到组中：
- en: '![](img/B06440_06CHPNO_05.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06440_06CHPNO_05.png)'
- en: 'We can further understand how `group_by` works with a simple example. Let''s
    say that we want to group the number according to the fact that they''re even
    or odd. We can implement this using `group_by` by passing the `lambda x: x % 2` expression
    as a key function, which will return `0` if the number is even and `1` if the
    number is odd:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以通过一个简单的例子进一步了解`group_by`的工作方式。假设我们想要根据数字是偶数还是奇数来分组。我们可以通过传递`lambda x: x
    % 2`表达式作为键函数来实现这一点，如果数字是偶数则返回`0`，如果是奇数则返回`1`：'
- en: '[PRE43]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'At this point, if we subscribe and print the content of `obs`, actually two
    observables are printed:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，如果我们订阅并打印`obs`的内容，实际上会打印出两个可观测量：
- en: '[PRE44]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You can determine the group key using the `key` attribute. To extract all the
    even numbers, we can take the first observable (corresponding to a key equal to
    0) and subscribe to it. In the following code, we show how this works:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`key`属性来确定组密钥。为了提取所有偶数，我们可以取第一个可观测量（对应于等于0的密钥）并订阅它。在下面的代码中，我们展示了这是如何工作的：
- en: '[PRE45]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: With `group_by`, we introduced an observable that emits other observables. This
    turns out to be quite a common pattern in reactive programming, and there are
    functions that allow you to combine different observables.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`group_by`，我们引入了一个发出其他可观测量的可观测量。这实际上是响应式编程中相当常见的一种模式，并且有一些函数允许您组合不同的可观测量。
- en: 'Two useful tools for combining observables are `merge_all` and `concat_all`.
    Merge takes multiple observables and produces a single observable that contains
    the element of the two observables in the order they are emitted. This is better
    illustrated using a marble diagram:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 结合可观测量的两个有用工具是`merge_all`和`concat_all`。合并操作接受多个可观测量，并产生一个包含两个可观测量元素的单一可观测量，其顺序与它们被发射的顺序相同。这可以通过一个弹珠图更好地说明：
- en: '![](img/B06440_06CHPNO_06.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B06440_06CHPNO_06.png)'
- en: '`merge_all` can be compared to a similar operator, `concat_all`, which returns
    a new observable that emits the elements of all the elements of the first observable,
    followed by the elements of the second observable and so on. The marble diagram
    for `concat_all` is presented here:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`merge_all`可以与类似的操作符`concat_all`进行比较，它返回一个新的可观测量，该可观测量发射第一个可观测量的所有元素，然后是第二个可观测量的元素，依此类推。`concat_all`的弹珠图如下所示：'
- en: '![](img/B06440_06CHPNO_07.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B06440_06CHPNO_07.png)'
- en: 'To demonstrate the usage of these two operators, we can apply those operations
    to the observable of observables returned by `group_by`. In the case of `merge_all`,
    the items are returned in the same order as they were initially (remember that
    `group_by` emits elements in the two groups as they come):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这两个操作符的用法，我们可以将这些操作应用于`group_by`返回的可观测量的可观测量。在`merge_all`的情况下，项目以它们最初相同的顺序返回（记住`group_by`以两个组中的元素顺序发射）：
- en: '[PRE46]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'On the other hand, `concat_all` first returns the even elements and then the
    odd elements as it waits for the first observable to complete, and then starts
    emitting the elements of the second observable. This is demonstrated in the following
    snippet. In this specific example, we also applied a function, `make_replay`;
    this is needed because, by the time the "even" stream is consumed, the elements
    of the second stream have already been produced and will not be available to `concat_all`.
    This concept will become much clearer after reading the *Hot and cold observables* section:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`concat_all`首先返回偶数元素，然后等待第一个可观测量完成，然后开始发射第二个可观测量的元素。这在下述代码片段中得到了演示。在这个特定的例子中，我们还应用了一个函数`make_replay`；这是必需的，因为在“偶数”流被消费时，第二个流的元素已经被产生，并且将不可用给`concat_all`。在阅读了*热和冷可观测量*章节后，这个概念将变得更加清晰：
- en: '[PRE47]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This time around, the even numbers are printed first, followed by the odd numbers.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，首先打印偶数，然后打印奇数。
- en: RxPy also provides the  `merge` and `concat` operations that can be used to
    combine individual observables
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: RxPy还提供了`merge`和`concat`操作，可以用来组合单个可观测量。
- en: Hot and cold observables
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 热和冷可观测量
- en: In the preceding section, we learned how to create an observable using the `Observable.from_iterable`
    method. RxPy provides many other tools to create more interesting event sources.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了如何使用`Observable.from_iterable`方法创建可观测量。RxPy提供了许多其他工具来创建更有趣的事件源。
- en: '`Observable.interval` takes a time interval in milliseconds, `period`, and
    will create an observable that emits a value every time the period has passed.
    The following line of code can be used to define an observable, `obs`, that will
    emit a number, starting from zero, every second. We use the `take` operator to
    limit the timer to four events:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.interval` 接收一个时间间隔（以毫秒为单位），`period`，并且会创建一个在每次周期过去时发出值的可观察对象。以下代码行可以用来定义一个可观察对象
    `obs`，它将从零开始，每秒发出一个数字。我们使用 `take` 操作符来限制计时器只触发四个事件：'
- en: '[PRE48]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'A very important fact about `Observable.interval` is that the timer doesn''t
    start until we subscribe. We can observe this by printing both the index and the
    delay from when the timer starts definition using `time.time()`, as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `Observable.interval` 的一个非常重要的事实是，计时器只有在订阅时才会开始。我们可以通过打印从计时器开始定义时的索引和延迟来观察这一点，如下所示：
- en: '[PRE49]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As you can see, the first element (corresponding to a `0` index) is produced
    after three seconds, which means that the timer started when we issue the `subscribe(print)`
    method.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，第一个元素（对应于 `0` 索引）在经过三秒后产生，这意味着计时器是在我们发出 `subscribe(print)` 方法时开始的。
- en: 'Observables, such as `Observable.interval`, are called *lazy* because they
    start producing values only when requested (think of them as vending machines,
    which won''t dispense food unless we press the button). In Rx jargon, these kind
    of observables are called **cold**. A property of cold observables is that, if
    we attach two subscribers, the interval timer will be started multiple times.
    This is quite evident from the following example. Here, we add a new subscription
    0.5 seconds after the first, and you can see how the output of the two subscriptions
    come at different times:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如 `Observable.interval` 这样的可观察对象被称为 **lazy**，因为它们只有在请求时才开始产生值（想想自动售货机，除非我们按下按钮，否则它们不会发放食物）。在
    Rx 术语中，这类可观察对象被称为 **cold**。冷可观察对象的一个特性是，如果我们附加两个订阅者，间隔计时器将多次启动。这可以从以下示例中清楚地看出。在这里，我们在第一个订阅后
    0.5 秒添加一个新的订阅，你可以看到两个订阅的输出在不同的时间到来：
- en: '[PRE50]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Sometimes we may not want this behavior as we may want multiple subscribers
    to subscribe to the same data source. To make the observable produce the same
    data, we can delay the data production and ensure that all the subscribers will
    get the same data using the `publish` method.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们可能不希望这种行为，因为我们可能希望多个订阅者订阅相同的数据源。为了使可观察对象产生相同的数据，我们可以延迟数据的生产，并确保所有订阅者都会通过
    `publish` 方法获得相同的数据。
- en: 'Publish will transform our observable into a `ConnectableObservable`, which
    won''t start pushing data immediately, but only when we call the `connect` method.
    The usage of `publish` and `connect` is demonstrated in the following snippet:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`Publish` 将将我们的可观察对象转换为 `ConnectableObservable`，它不会立即开始推送数据，而只有在调用 `connect`
    方法时才会开始。`publish` 和 `connect` 的用法在以下代码片段中得到了演示：'
- en: '[PRE51]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the preceding example, you can see how we first issue `publish`, then we
    subscribe the first subscriber and, finally, we issue `connect`. When `connect`
    is issued, the timer will start producing data. The second subscriber joins the
    party late and, in fact, won't receive the first two messages but will start receiving
    data from the third and so on. Note how, this time around, the subscribers share
    the exact same data. This kind of data source, where data is produced independently
    of the subscribers, is called **hot**.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，你可以看到我们首先发出 `publish`，然后订阅第一个订阅者，最后发出 `connect`。当发出 `connect` 时，计时器将开始产生数据。第二个订阅者晚到了派对，实际上将不会收到前两条消息，而是从第三条开始接收数据。注意，这一次，订阅者共享了完全相同的数据。这种独立于订阅者产生数据的数据源被称为
    **hot**。
- en: 'Similar to `publish`, you can use the `replay` method that will produce the
    data *from the beginning* for each new subscriber. This is illustrated in the
    following example that, which is identical to the preceding one except that we
    replaced `publish` with `replay`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `publish` 类似，你可以使用 `replay` 方法，该方法将为每个新的订阅者产生从开始的数据。以下示例说明了这一点，它与前面的示例相同，只是我们将
    `publish` 替换为了 `replay`：
- en: '[PRE52]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You can see how, this time around, even though the second subscriber arrives
    late to the party, it is still given all the items that have been given out so
    far.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，这一次，尽管第二个订阅者晚到了派对，但他仍然得到了到目前为止已经发放的所有物品。
- en: 'Another way of creating hot observables is through the `Subject` class. `Subject`
    is interesting because it''s capable of both receiving and pushing data, and thus
    it can be used to manually *push* items to an observable. Using `Subject` is very
    intuitive; in the following code, we create a `Subject` and subscribe to it. Later,
    we push values to it using the `on_next` method; as soon as we do that, the subscriber
    is called:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 创建热可观察量的另一种方式是通过`Subject`类。`Subject`很有趣，因为它既能接收数据也能推送数据，因此可以用来手动*推送*项目到一个可观察量。使用`Subject`非常直观；在下面的代码中，我们创建了一个`Subject`并订阅它。稍后，我们使用`on_next`方法向它推送值；一旦这样做，订阅者就会被调用：
- en: '[PRE53]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note that `Subject` is another example of hot observables.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Subject`是热可观察量的另一个例子。
- en: Building a CPU monitor
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建CPU监控器
- en: Now that we have a grasp on the main reactive programming concepts, we can implement
    a sample application. In this subsection, we will implement a monitor that will
    give us real-time information about our CPU usage and is capable of detecting
    spikes.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了主要反应式编程概念，我们可以实现一个示例应用程序。在本小节中，我们将实现一个监控器，它将提供有关我们CPU使用情况的实时信息，并且能够检测到峰值。
- en: The complete code for the CPU monitor can be found in the `cpu_monitor.py` file.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: CPU监控器的完整代码可以在`cpu_monitor.py`文件中找到。
- en: 'As a first step, let''s implement a data source. We will use the `psutil` module
    that provides a function, `psutil.cpu_percent`, that returns the latest available
    CPU usage as a percent (and doesn''t block):'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，让我们实现一个数据源。我们将使用`psutil`模块，它提供了一个名为`psutil.cpu_percent`的函数，该函数返回最新的CPU使用率作为百分比（并且不会阻塞）：
- en: '[PRE54]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Since we are developing a monitor, we would like to sample this information
    over a few time intervals. To accomplish this we can use the familiar `Observable.interval`
    , followed by `map` just like we did in the previous section. Also, we would like
    to make this observable *hot* as, for this application, all subscribers should
    receive a single source of data; to make `Observable.interval` hot,  we can use
    the `publish` and `connect` methods. The full code for the creation of the `cpu_data`
    observable is as follows
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在开发一个监控器，我们希望在不同时间间隔内采样这些信息。为此，我们可以使用熟悉的`Observable.interval`，然后像上一节那样使用`map`。此外，我们希望使这个可观察量*热*，因为对于这个应用程序，所有订阅者都应该接收单一的数据源；为了使`Observable.interval`成为热可观察量，我们可以使用`publish`和`connect`方法。创建`cpu_data`可观察量的完整代码如下
- en: '[PRE55]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We can test our monitor by printing a sample of 4 items
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过打印4个样本来测试我们的监控器。
- en: '[PRE56]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now that our main data source is in place, we can implement a monitor visualization
    using `matplotlib`. The idea is to create a plot that contains a fixed amount
    of measurements and, as new data arrives, we include the newest measurement and
    remove the oldest one. This is commonly referred to as a *moving window* and is
    better understood with an illustration. In the following figure, our `cpu_data`
    stream is represented as a list of numbers. The first plot is produced as soon
    as we have the first four numbers and, each time a new number arrives, we shift
    the window by one position and update the plot:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了主要数据源，我们可以使用`matplotlib`实现一个监控器可视化。想法是创建一个包含固定数量测量的图表，并且随着新数据的到来，我们包括最新的测量值并移除最旧的测量值。这通常被称为*移动窗口*，通过以下插图可以更好地理解。在下面的图中，我们的`cpu_data`流被表示为数字列表。第一个图表是在我们获得前四个数字时产生的，每次新数字到达时，我们通过一个位置移动窗口并更新图表：
- en: '![](img/B06440_06CHPNO_08.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B06440_06CHPNO_08.png)'
- en: 'To implement this algorithm, we can write a function, called `monitor_cpu`,
    that will create and update our plotting window. The function will do the following
    things:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个算法，我们可以编写一个名为`monitor_cpu`的函数，该函数将创建和更新我们的绘图窗口。该函数将执行以下操作：
- en: Initialize an empty plot and set up the correct plot limits.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化一个空图表并设置正确的绘图限制。
- en: Transform our `cpu_data` observable to return a moving window over the data.
    This can be accomplished using the `buffer_with_count` operator, which will take
    the number of points in our window, `npoints`, as parameters and the shift as `1`.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的`cpu_data`可观察量转换为一个在数据上移动的窗口。这可以通过使用`buffer_with_count`运算符来完成，它将窗口中的点数`npoints`作为参数，并将偏移量设置为`1`。
- en: Subscribe to this new data stream and update the plot with the incoming data.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅这个新的数据流并更新图表中的传入数据。
- en: 'The complete code for the function is shown here and, as you can see, is extremely
    compact. Take some time to run the function and play with the parameters:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的完整代码如下所示，如您所见，它非常紧凑。花点时间运行该函数并调整参数：
- en: '[PRE57]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Another feature we may want to develop is, for example, an alert that triggers
    when the CPU has been high for a certain amount of time as this may indicate that
    some of the  processes in our machine are working very hard. This can be accomplished
    by combining `buffer_with_count` and `map`. We can take the CPU stream and a window,
    and then we will test whether all items have a value higher than twenty percent usage
    (in a quad-core CPU that corresponds to about one processor working at hundred
    percent) in the map function. If all the points in the window have a higher than
    twenty percent usage, we display a warning in our plot window.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能还想开发的一个功能是，例如，当CPU使用率持续一段时间时触发警报，因为这可能表明我们机器中的某些进程正在非常努力地工作。这可以通过结合`buffer_with_count`和`map`来实现。我们可以取CPU流和窗口，然后在`map`函数中测试所有项的值是否高于二十百分比的使用率（在一个四核CPU中，这相当于大约一个处理器以百分之一百的速度工作）。如果窗口中的所有点使用率都高于二十百分比，我们将在我们的绘图窗口中显示警告。
- en: 'The implementation of the new observable can be written as follows and will
    produce an observable that emits `True` if the CPU has high usage, and `False`
    otherwise:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 新观察量的实现可以写成以下形式，并将产生一个观察量，如果CPU使用率高，则发出`True`，否则发出`False`：
- en: '[PRE58]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now that the `high_cpu` observable is ready, we can create a `matplotlib` label
    and subscribe to it for updates:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当`high_cpu`观察量准备就绪后，我们可以创建一个`matplotlib`标签并订阅它以获取更新：
- en: '[PRE59]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Summary
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Asynchronous programming is useful when our code deals with slow and unpredictable
    resources, such as I/O devices and networks. In this chapter, we explored the
    fundamental concepts of concurrency and asynchronous programming and how to write
    concurrent code with the `asyncio` and RxPy libraries.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的代码处理缓慢且不可预测的资源时，如I/O设备和网络，异步编程是有用的。在本章中，我们探讨了并发和异步编程的基本概念，以及如何使用`asyncio`和RxPy库编写并发代码。
- en: '`asyncio` coroutines are an excellent choice when dealing with multiple, interconnected
    resources as they greatly simplify the code logic by cleverly avoiding callbacks.
    Reactive programming is also very good in these situations, but it truly shines
    when dealing with streams of data that are common in real-time applications and
    user interfaces.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理多个相互关联的资源时，`asyncio`协程是一个很好的选择，因为它们通过巧妙地避免回调来极大地简化代码逻辑。在这些情况下，响应式编程也非常好，但它真正闪耀的时候是处理在实时应用程序和用户界面中常见的流数据。
- en: In the next two chapters, we will learn about parallel programming and how to
    achieve impressive performance gain by taking advantage of multiple cores and
    multiple machines.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两章中，我们将学习并行编程以及如何通过利用多个核心和多个机器来实现令人印象深刻的性能提升。
