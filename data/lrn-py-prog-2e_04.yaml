- en: Functions, the Building Blocks of Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数，代码的构建块
- en: '"To create architecture is to put in order. Put what in order? Functions and
    objects." – Le Corbusier'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “创建建筑就是整理。整理什么？函数和对象。” - 勒·柯布西耶
- en: In the previous chapters, we have seen that everything is an object in Python,
    and functions are no exception. But, what exactly is a function? A **function**
    is a sequence of instructions that perform a task, bundled as a unit. This unit
    can then be imported and used wherever it's needed. There are many advantages
    to using functions in your code, as we'll see shortly.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们已经看到在Python中一切都是对象，函数也不例外。但是，函数究竟是什么？**函数**是一系列执行任务的指令，作为一个单元捆绑在一起。然后可以导入这个单元并在需要的地方使用。在代码中使用函数有许多优点，我们很快就会看到。
- en: 'In this chapter, we are going to cover the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Functions—what they are and why we should use them
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数-它们是什么，为什么我们应该使用它们
- en: Scopes and name resolution
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作用域和名称解析
- en: Function signatures—input parameters and return values
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数签名-输入参数和返回值
- en: Recursive and anonymous functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归和匿名函数
- en: Importing objects for code reuse
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入对象以便重用代码
- en: 'I believe the saying, *a picture is worth one thousand words*, is particularly
    true when explaining functions to someone who is new to this concept, so please
    take a look at the following diagram:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信这句话，*一张图片胜过一千言语*，在向一个对这个概念新手解释函数时尤其正确，所以请看一下下面的图表：
- en: '![](../images/00007.jpeg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00007.jpeg)'
- en: As you can see, a function is a block of instructions, packaged as a whole,
    like a box. Functions can accept input arguments and produce output values. Both
    of these are optional, as we'll see in the examples in this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，函数是一系列指令的块，作为一个整体打包，就像一个盒子。函数可以接受输入参数并产生输出值。这两者都是可选的，正如我们将在本章的例子中看到的那样。
- en: A function in Python is defined by using the `def` keyword, after which the
    name of the function follows, terminated by a pair of parentheses (which may or
    may not contain input parameters), and a colon (`:`) signals the end of the function
    definition line. Immediately afterwards, indented by four spaces, we find the
    body of the function, which is the set of instructions that the function will
    execute when called.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，函数是通过使用`def`关键字来定义的，随后是函数的名称，后面跟着一对括号（可能包含输入参数，也可能不包含），冒号（`:`）表示函数定义行的结束。紧接着，缩进四个空格，我们找到函数的主体，这是函数在调用时将执行的一系列指令。
- en: Note that the indentation by four spaces is not mandatory, but it is the amount
    of spaces suggested by **PEP 8**, and, in practice, it is the most widely used
    spacing measure.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，缩进四个空格不是强制性的，但这是**PEP 8**建议的空格数量，并且在实践中是最广泛使用的间距度量。
- en: A function may or may not return an output. If a function wants to return an
    output, it does so by using the `return` keyword, followed by the desired output.
    If you have an eagle eye, you may have noticed the little ***** after **Optional**
    in the output section of the preceding diagram. This is because a function always
    returns something in Python, even if you don't explicitly use the `return` clause.
    If the function has no `return` statement in its body, or no value is given to
    the `return` statement itself, the function returns  `None`. The reasons behind
    this design choice are outside the scope of an introductory chapter, so all you
    need to know is that this behavior will make your life easier. As always, thank
    you, Python.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可能会返回输出，也可能不会。如果函数想要返回输出，它会使用`return`关键字，后面跟着期望的输出。如果你有鹰眼，你可能已经注意到在前面图表的输出部分中**Optional**后面的小*****。这是因为在Python中，函数总是返回一些东西，即使你没有明确使用`return`子句。如果函数体中没有`return`语句，或者`return`语句本身没有给出值，函数将返回`None`。这种设计选择背后的原因超出了介绍章节的范围，所以你需要知道的是这种行为会让你的生活更轻松。一如既往，感谢Python。
- en: Why use functions?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用函数？
- en: 'Functions are among the most important concepts and constructs of any language,
    so let me give you a few reasons why we need them:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是任何语言中最重要的概念和构造之一，所以让我给你一些我们需要它们的原因：
- en: They reduce code duplication in a program. By having a specific task taken care
    of by a nice block of packaged code that we can import and call whenever we want,
    we don't need to duplicate its implementation.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们减少了程序中的代码重复。通过让一个特定的任务由一个好的打包代码块来处理，我们可以导入并在需要时调用它，而不需要复制它的实现。
- en: They help in splitting a complex task or procedure into smaller blocks, each
    of which becomes a function.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们有助于将复杂的任务或过程分割成较小的块，每个块都成为一个函数。
- en: They hide the implementation details from their users.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们隐藏了实现细节，使用户看不到。
- en: They improve traceability.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提高了可追溯性。
- en: They improve readability.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提高了可读性。
- en: Let's look at a few examples to get a better understanding of each point.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看几个例子，以更好地理解每一点。
- en: Reducing code duplication
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少代码重复
- en: Imagine that you are writing a piece of scientific software, and you need to
    calculate primes up to a limit, as we did in the previous chapter. You have a
    nice algorithm to calculate them, so you copy and paste it to wherever you need.
    One day, though, your friend, *B. Riemann*, gives you a better algorithm to calculate
    primes, which will save you a lot of time. At this point, you need to go over
    your whole code base and replace the old code with the new one.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在编写一款科学软件，需要计算素数直到一个限制，就像我们在上一章中所做的那样。你有一个很好的算法来计算它们，所以你把它复制粘贴到你需要的地方。然而，有一天，你的朋友，*B.黎曼*，给了你一个更好的算法来计算素数，这将节省你很多时间。在这一点上，你需要检查整个代码库，并用新的代码替换旧的代码。
- en: This is actually a bad way to go about it. It's error-prone, you never know
    what lines you are chopping out or leaving in by mistake, when you cut and paste
    code into other code, and you may also risk missing one of the places where prime
    calculation is done, leaving your software in an inconsistent state where the
    same action is performed in different places in different ways. What if, instead
    of replacing code with a better version of it, you need to fix a bug, and you
    miss one of the places? That would be even worse.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是一个不好的做法。这容易出错，你永远不知道你是不是误删或遗漏了哪些行，当你将代码剪切和粘贴到其他代码中时，你也可能会错过其中进行质数计算的地方之一，导致软件处于不一致的状态，同样的操作在不同地方以不同的方式执行。如果你需要用更好的版本替换代码，而不是修复错误，你会错过其中一个地方吗？那将更糟糕。
- en: So, what should you do? Simple! You write a function, `get_prime_numbers(upto)`,
    and use it anywhere you need a list of primes. When *B. Riemann* comes to you
    and gives you the new code, all you have to do is replace the body of that function
    with the new implementation, and you're done! The rest of the software will automatically
    adapt, since it's just calling the function.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你应该怎么做呢？简单！你写一个函数，`get_prime_numbers(upto)`，并在任何需要质数列表的地方使用它。当 *B. Riemann*
    给你新代码时，你只需要用新实现替换该函数的主体，然后就完成了！软件的其余部分将自动适应，因为它只是调用函数。
- en: Your code will be shorter, it will not suffer from inconsistencies between old
    and new ways of performing a task, or undetected bugs due to copy-and-paste failures
    or oversights. Use functions, and you'll only gain from it, I promise.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码会更短，不会受到在执行任务的旧方法和新方法之间的不一致性的影响，也不会因为复制粘贴失败或疏忽而导致未检测到的错误。使用函数，你只会从中获益，我保证。
- en: Splitting a complex task
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分解复杂任务
- en: Functions are also very useful for splitting long or complex tasks into smaller
    ones. The end result is that the code benefits from it in several ways, for example,
    readability, testability, and reuse. To give you a simple example, imagine that
    you're preparing a report. Your code needs to fetch data from a data source, parse
    it, filter it, polish it, and then a whole series of algorithms needs to be run
    against it, in order to produce the results that will feed the `Report` class.
    It's not uncommon to read procedures like this that are just one big `do_report(data_source)` function.
    There are tens or hundreds of lines of code that end with `return report`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 函数还非常有用，可以将长或复杂的任务分解为较小的任务。最终结果是，代码从中受益的方式有很多，例如可读性、可测试性和可重用性。举个简单的例子，想象一下你正在准备一份报告。你的代码需要从数据源获取数据，解析数据，过滤数据，整理数据，然后需要运行一系列算法来产生将供`Report`类使用的结果。阅读这样的程序通常只有一个大的`do_report(data_source)`函数。有数十行或数百行代码以`return
    report`结束。
- en: 'These situations are slightly more common in scientific code, which tend to
    be brilliant from an algorithmic point of view, but sometimes lack the touch of
    experienced programmers when it comes to the style in which they are written.
    Now, picture a few hundred lines of code. It''s very hard to follow through, to
    find the places where things are changing context (such as finishing one task
    and starting the next one). Do you have the picture in your mind? Good. Don''t
    do it! Instead, look at this code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些情况在科学代码中更常见，科学代码在算法上往往很出色，但有时在编写风格方面缺乏经验丰富的程序员的触感。现在，想象一下几百行代码。很难跟进，找到事情在改变上下文的地方（比如完成一个任务并开始下一个任务）。你有心中的画面了吗？好。不要这样做！相反，看看这段代码：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The previous example is fictitious, of course, but can you see how easy it would
    be to go through the code? If the end result looks wrong, it would be very easy
    to debug each of the single data outputs in the `do_report` function. Moreover,
    it's even easier to exclude part of the process temporarily from the whole procedure
    (you just need to comment out the parts you need to suspend). Code like this is
    easier to deal with.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子当然是虚构的，但你能看出通过代码会有多容易吗？如果最终结果看起来不对，逐个调试`do_report`函数中的每个单个数据输出将非常容易。此外，暂时从整个过程中排除部分过程也更容易（你只需要注释掉需要暂停的部分）。这样的代码更容易处理。
- en: Hiding implementation details
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐藏实现细节
- en: Let's stay with the preceding example to talk about this point as well. You
    can see that, by going through the code of the `do_report` function, you can get
    a pretty good understanding without reading one single line of implementation.
    This is because functions hide the implementation details. This feature means
    that, if you don't need to delve into the details, you are not forced to, in the
    way you would if `do_report` was just one big, fat function. In order to understand
    what was going on, you would have to read every single line of code. With functions,
    you don't need to. This reduces the time you spend reading the code and since,
    in a professional environment, reading code takes much more time than actually
    writing it, it's very important to reduce it by as much as we can.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用前面的例子来谈谈这一点。你可以看到，通过查看`do_report`函数的代码，即使不阅读一行实现代码，你也能很好地理解。这是因为函数隐藏了实现细节。这个特性意味着，如果你不需要深入了解细节，你就不会被迫这样做，就像如果`do_report`只是一个庞大的函数一样。为了理解发生了什么，你必须阅读每一行代码。但使用函数，你就不需要这样做。这减少了你阅读代码的时间，而在专业环境中，阅读代码所花费的时间远远超过编写代码的时间，因此尽可能减少这一时间非常重要。
- en: Improving readability
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高可读性
- en: Coders sometimes don't see the point in writing a function with a body of one
    or two lines of code, so let's look at an example that shows you why you should
    do it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 编码人员有时看不出编写一个只有一两行代码的函数的意义，所以让我们看一个示例，告诉你为什么你应该这样做。
- en: 'Imagine that you need to multiply two matrices:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你需要将两个矩阵相乘：
- en: '![](../images/00008.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00008.jpeg)'
- en: 'Would you prefer to have to read this code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你更喜欢阅读这段代码吗：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Or would you prefer this one:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你更喜欢这个：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It's much easier to understand that `c` is the result of the multiplication
    between `a` and `b` in the second example. It's much easier to read through the
    code and, if you don't need to modify that multiplication logic, you don't even
    need to go into the implementation details. Therefore, readability is improved
    here while, in the first snippet, you would have to spend time trying to understand
    what that complicated list comprehension is doing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，更容易理解`c`是`a`和`b`之间乘法的结果。通过代码更容易阅读，如果你不需要修改乘法逻辑，甚至不需要深入了解实现细节。因此，在这里提高了可读性，而在第一个片段中，你将不得不花时间去理解那个复杂的列表推导在做什么。
- en: Don't worry if you don't understand *list comprehensions*, we'll study them
    in [Chapter 5](part0142.html#47DFS0-2ddb708647cc4530a187c2c6c0e9acfe), *Saving
    Time and Memory*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不理解*列表推导*，不要担心，我们将在[第5章](part0142.html#47DFS0-2ddb708647cc4530a187c2c6c0e9acfe)中学习它们，*节省时间和内存*。
- en: Improving traceability
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高可追踪性
- en: 'Imagine that you have written an e-commerce website. You have displayed the
    product prices all over the pages. Imagine that the prices in your database are
    stored with no VAT (sales tax), but you want to display them on the website with
    VAT at 20%. Here''s a few ways of calculating the VAT-inclusive price from the
    VAT-exclusive price:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你已经写了一个电子商务网站。你在页面上展示了产品价格。假设你的数据库中的价格是不含增值税（销售税）的，但你想在网站上以20%的增值税显示它们。以下是从不含增值税价格计算含增值税价格的几种方式：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: All these four different ways of calculating a VAT-inclusive price are perfectly
    acceptable, and I promise you I have found them all in my colleagues' code, over
    the years. Now, imagine that you have started selling your products in different
    countries and some of them have different VAT rates, so you need to refactor your
    code (throughout the website) in order to make that VAT calculation dynamic.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这四种不同的计算增值税含价的方式都是完全可以接受的，我向你保证，这些方式我在多年的同事代码中都找到过。现在，想象一下，你已经开始在不同的国家销售你的产品，其中一些国家有不同的增值税率，所以你需要重构你的代码（整个网站）以使增值税计算动态化。
- en: How do you trace all the places in which you are performing a VAT calculation?
    Coding today is a collaborative task and you cannot be sure that the VAT has been
    calculated using only one of those forms. It's going to be hell, believe me.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何追踪所有进行增值税计算的地方？编码今天是一个协作的任务，你不能确定增值税是使用这些形式中的一个进行计算的。相信我，这将是一场噩梦。
- en: 'So, let''s write a function that takes the input values, `vat` and `price`
    (VAT-exclusive), and returns a VAT-inclusive price:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们编写一个函数，它接受输入值`vat`和`price`（不含增值税），并返回含增值税的价格：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now you can import that function and use it in any place in your website where
    you need to calculate a VAT-inclusive price, and when you need to trace those
    calls, you can search for `calculate_price_with_vat`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以导入该函数，并在网站中任何需要计算含增值税价格的地方使用它，当你需要追踪这些调用时，你可以搜索`calculate_price_with_vat`。
- en: Note that, in the preceding example, `price` is assumed to be VAT-exclusive,
    and `vat` is a percentage value (for example, 19, 20, or 23).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的例子中，假定`price`是不含增值税的，`vat`是一个百分比值（例如，19、20或23）。
- en: Scopes and name resolution
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作用域和名称解析
- en: 'Do you remember when we talked about scopes and namespaces in [Chapter 1](part0021.html#K0RQ0-2ddb708647cc4530a187c2c6c0e9acfe), *A
    Gentle Introduction to Python*? We''re going to expand on that concept now. Finally,
    we can talk about functions and this will make everything easier to understand.
    Let''s start with a very simple example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们在[第1章](part0021.html#K0RQ0-2ddb708647cc4530a187c2c6c0e9acfe)中讨论作用域和命名空间吗，*Python简介*？我们现在要扩展这个概念。最后，我们可以谈谈函数，这将使一切更容易理解。让我们从一个非常简单的例子开始：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'I have defined the `test` name in two different places in the previous example.
    It is actually in two different scopes. One is the global scope (`test = 0`),
    and the other is the local scope of the `my_function` function (`test = 1`). If
    you execute the code, you''ll see this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我在两个不同的地方定义了`test`名称。它实际上在两个不同的作用域中。一个是全局作用域（`test = 0`），另一个是`my_function`函数的局部作用域（`test
    = 1`）。如果你执行这段代码，你会看到这个：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It''s clear that `test = 1` shadows the `test = 0` assignment in `my_function`.
    In the global context, `test` is still `0`, as you can see from the output of
    the program, but we define the `test` name again in the function body, and we
    set it to point to an integer of value `1`. Both the two `test` names therefore
    exist, one in the global scope, pointing to an `int` object with a value of `0`,
    the other in the `my_function` scope, pointing to an `int` object with a value
    of `1`. Let''s comment out the line with `test = 1`. Python searches for the `test` name
    in the next enclosing namespace (recall the **LEGB** rule: **local**, **enclosing**,
    **global**, **built-in** described in [Chapter 1](part0021.html#K0RQ0-2ddb708647cc4530a187c2c6c0e9acfe),
    *A Gentle Introduction to Python*) and, in this case, we will see the value `0`
    printed twice. Try it in your code.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，`test = 1`覆盖了`my_function`中的`test = 0`赋值。在全局上下文中，`test`仍然是`0`，正如你从程序的输出中看到的那样，但是我们在函数体中重新定义了`test`名称，并将其指向值为`1`的整数。因此，这两个`test`名称都存在，一个在全局范围内，指向值为`0`的`int`对象，另一个在`my_function`范围内，指向值为`1`的`int`对象。让我们注释掉`test
    = 1`的那一行。Python会在下一个封闭的命名空间中搜索`test`名称（回想一下**LEGB**规则：**local**，**enclosing**，**global**，**built-in**，在[第1章](part0021.html#K0RQ0-2ddb708647cc4530a187c2c6c0e9acfe)中描述的*Python简介*），在这种情况下，我们将看到值`0`被打印两次。在你的代码中试一下。
- en: 'Now, let''s raise the stakes here and level up:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们提高一下难度：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding code, we have two levels of shadowing. One level is in the
    function `outer`, and the other one is in the function `inner`. It is far from
    rocket science, but it can be tricky. If we run the code, we get:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有两个级别的遮蔽。一个级别在函数`outer`中，另一个级别在函数`inner`中。这并不是什么高深的科学，但可能会有些棘手。如果我们运行这段代码，我们会得到：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Try commenting out the `test = 1` line. Can you figure out what the result will
    be? Well, when reaching the `print('outer:', test)` line, Python will have to
    look for `test` in the next enclosing scope, therefore it will find and print
    `0`, instead of `1`. Make sure you comment out `test = 2` as well, to see whether
    you understand what happens, and whether the LEGB rule is clear, before proceeding.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 试着注释掉`test = 1`这一行。你能猜到结果会是什么吗？嗯，当到达`print('outer:', test)`这一行时，Python将不得不在下一个封闭作用域中查找`test`，因此它会找到并打印`0`，而不是`1`。确保你也注释掉`test
    = 2`，看看你是否理解发生了什么，以及LEGB规则是否清楚，然后再继续。
- en: Another thing to note is that Python gives you the ability to define a function
    in another function. The inner function's name is defined within the namespace
    of the outer function, exactly as would happen with any other name.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一点要注意的是，Python允许你在另一个函数中定义一个函数。内部函数的名称是在外部函数的命名空间中定义的，就像其他任何名称一样。
- en: The global and nonlocal statements
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局和非局部语句
- en: 'Going back to the preceding example, we can alter what happens to the shadowing
    of the test name by using one of these two special statements: `global` and `nonlocal`.
    As you can see from the previous example, when we define `test = 2` in the `inner` function,
    we overwrite `test` neither in the `outer` function nor in the global scope. We
    can get read access to those names if we use them in a nested scope that doesn''t
    define them, but we cannot modify them because, when we write an assignment instruction,
    we''re actually defining a new name in the current scope.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 回到前面的例子，我们可以通过使用这两个特殊语句之一：`global`和`nonlocal`，来改变对`test`名称的遮蔽。正如你从前面的例子中看到的，当我们在`inner`函数中定义`test
    = 2`时，我们既没有覆盖`outer`函数中的`test`，也没有覆盖全局作用域中的`test`。如果我们在没有定义它们的嵌套作用域中使用它们，我们可以获得对这些名称的读取访问权限，但我们不能修改它们，因为当我们写一个赋值指令时，实际上是在当前作用域中定义一个新名称。
- en: 'How do we change this behavior? Well, we can use the `nonlocal` statement.
    According to the official documentation:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何改变这种行为呢？嗯，我们可以使用`nonlocal`语句。根据官方文档：
- en: '"The nonlocal statement causes the listed identifiers to refer to previously
    bound variables in the nearest enclosing scope excluding globals."'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: “非局部语句使得列出的标识符引用最近的封闭作用域中先前绑定的变量，不包括全局变量。”
- en: 'Let''s introduce it in the `inner` function, and see what happens:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`inner`函数中引入它，看看会发生什么：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Notice how in the body of the `inner` function, I have declared the `test`
    name to be `nonlocal`. Running this code produces the following result:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`inner`函数的主体中，我已经声明了`test`名称为`nonlocal`。运行这段代码会产生以下结果：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Wow, look at that result! It means that, by declaring `test` to be `nonlocal`
    in the `inner` function, we actually get to bind the `test` name to the one declared
    in the `outer` function. If we removed the `nonlocal test` line from the `inner` function
    and tried the same trick in the `outer` function, we would get a `SyntaxError`,
    because the `nonlocal` statement works on enclosing scopes excluding the global
    one.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，看看那个结果！这意味着，通过在`inner`函数中声明`test`为`nonlocal`，我们实际上将`test`名称绑定到了在`outer`函数中声明的`test`。如果我们从`inner`函数中删除`nonlocal
    test`行，并在`outer`函数中尝试相同的技巧，我们将得到一个`SyntaxError`，因为`nonlocal`语句只在不包括全局作用域的封闭作用域中起作用。
- en: 'Is there a way to get to that `test = 0` in the global namespace then? Of course,
    we just need to use the `global` statement:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 那么有没有办法访问全局命名空间中的`test = 0`呢？当然有，我们只需要使用`global`语句：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note that we have now declared the `test` name to be `global`, which will basically
    bind it to the one we defined in the global namespace (`test = 0`). Run the code
    and you should get the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们现在已经声明了`test`名称为`global`，这基本上将其绑定到我们在全局命名空间中定义的那个（`test = 0`）。运行代码，你应该会得到以下结果：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This shows that the name affected by the `test = 2` assignment is now the `global`
    one. This trick would also work in the `outer` function because, in this case,
    we're referring to the global scope. Try it for yourself and see what changes,
    get comfortable with scopes and name resolution, it's very important. Also, could
    you tell what happens if you defined `inner` outside `outer` in the preceding
    examples?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明受`test = 2`赋值影响的名称现在是`global`。这个技巧在`outer`函数中也会起作用，因为在这种情况下，我们是在引用全局作用域。试一试，看看有什么变化，熟悉一下作用域和名称解析，这很重要。另外，你能告诉我在前面的例子中如果在`outer`之外定义`inner`会发生什么吗？
- en: Input parameters
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入参数
- en: 'At the beginning of this chapter, we saw that a function can take input parameters.
    Before we delve into all possible type of parameters, let''s make sure you have
    a clear understanding of what passing a parameter to a function means. There are
    three key points to keep in mind:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们看到函数可以接受输入参数。在我们深入讨论所有可能类型的参数之前，让我们确保你清楚地理解了将参数传递给函数意味着什么。有三个关键点需要记住：
- en: Argument-passing is nothing more than assigning an object to a local variable
    name
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数传递只不过是将一个对象分配给一个局部变量名
- en: Assigning an object to an argument name inside a function doesn't affect the
    caller
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数内部将对象分配给参数名称不会影响调用者
- en: Changing a mutable object argument in a function affects the caller
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数中更改可变对象参数会影响调用者
- en: Let's look at an example for each of these points.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分别看一下每个观点的例子。
- en: Argument-passing
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数传递
- en: 'Take a look at the following code. We declare a name, `x`, in the global scope,
    then we declare a function, `func(y)`, and finally we call it, passing `x`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的代码。我们在全局作用域中声明了一个名称`x`，然后我们声明了一个函数`func(y)`，最后我们调用它，传递了`x`：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When `func` is called with `x`, within its local scope, a name, `y`, is created,
    and it''s pointed to the same object `x` is pointing to. This is better clarified
    by the following figure (don''t worry about Python 3.3, this is a feature that
    hasn''t changed):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当`func`被`x`调用时，在它的局部作用域中，创建了一个名称`y`，它指向了`x`指向的相同对象。这通过下图更好地解释了（不用担心Python 3.3，这是一个没有改变的特性）：
- en: '![](../images/00009.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00009.jpeg)'
- en: 'The right part of the preceding figure depicts the state of the program when
    execution has reached the end, after `func` has returned (`None`). Take a look
    at the Frames column, and note that we have two names, `x` and `func`, in the
    global namespace (Global frame), pointing to an `int` (with a value of **3**)
    and to a `function` object, respectively. Right beneath it, in the rectangle titled
    `func`, we can see the function''s local namespace, in which only one name has
    been defined: `y`. Because we have called `func` with `x` (line **5** in the left
    part of the figure), `y` is pointing to the same object that `x` is pointing to.
    This is what happens under the hood when an argument is passed to a function.
    If we had used the name `x` instead of `y` in the function definition, things
    would have been exactly the same (only maybe a bit confusing at first), there
    would be a local `x` in the function, and a global `x` outside, as we saw in the
    *Scopes and name resolution* section previously in this chapter.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 前面图的右侧部分描述了程序在执行到最后（`func`返回`None`后）的状态。看一下Frames列，注意全局命名空间（全局帧）中有两个名称，`x`和`func`，分别指向一个`int`（值为**3**）和一个`function`对象。在其下方的名为`func`的矩形中，我们可以看到函数的局部命名空间，其中只定义了一个名称`y`。因为我们用`x`调用了`func`（图的左侧第5行），`y`指向与`x`指向的相同的对象。这就是在将参数传递给函数时发生的情况。如果我们在函数定义中使用名称`x`而不是`y`，情况将完全相同（可能一开始有点混乱），函数中会有一个局部的`x`，外部会有一个全局的`x`，就像我们在本章前面看到的*作用域和名称解析*部分一样。
- en: So, in a nutshell, what really happens is that the function creates, in its
    local scope, the names defined as arguments and, when we call it, we basically
    tell Python which objects those names must be pointed toward.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，实际发生的是函数在其局部范围内创建了作为参数定义的名称，当我们调用它时，我们基本上告诉Python这些名称必须指向哪些对象。
- en: Assignment to argument names doesn't affect the caller
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配给参数名称不会影响调用者
- en: 'This is something that can be tricky to understand at first, so let''s look
    at an example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点一开始可能会难以理解，所以让我们看一个例子：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, when the `x = 7` line is executed, within the local scope
    of the `func` function, the name, `x`, is pointed to an integer with a value of
    `7`, leaving the global `x` unaltered.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，当执行`x = 7`时，在`func`函数的局部范围内，名称`x`指向一个值为`7`的整数，而全局的`x`保持不变。
- en: Changing a mutable affects the caller
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改变可变对象会影响调用者
- en: 'This is the final point, and it''s very important because Python apparently
    behaves differently with mutables (just apparently, though). Let''s look at an
    example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最后一点，非常重要，因为Python在处理可变对象时表现出不同的行为（尽管只是表面上）。让我们看一个例子：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Wow, we actually changed the original object! If you think about it, there is
    nothing weird in this behavior. The `x` name in the function is set to point to
    the caller object by the function call and within the body of the function, we're
    not changing `x`, in that we're not changing its reference, or, in other words,
    we are not changing the object `x` is pointing to. We're accessing that object's
    element at position 1, and changing its value.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，我们实际上改变了原始对象！如果你仔细想想，这种行为并不奇怪。函数调用中的`x`名称被设置为指向调用者对象，并且在函数体内，我们没有改变`x`，也就是说，我们没有改变它的引用，换句话说，我们没有改变`x`指向的对象。我们正在访问该对象在位置1的元素，并改变它的值。
- en: 'Remember point #2 under the *Input parameters* section: *Assigning an object
    to an argument name within a function doesn''t affect the caller*. If that is
    clear to you, the following code should not be surprising:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 记住*输入参数*部分的第2点：*在函数内将对象分配给参数名称不会影响调用者*。如果这对你来说很清楚，下面的代码就不会让人感到惊讶：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Take a look at the two lines I have highlighted. At first, like before, we just
    access the caller object again, at position 1, and change its value to number
    `42`. Then, we reassign `x` to point to the `'something else'` string. This leaves
    the caller unaltered and, in fact, the output is the same as that of the previous
    snippet.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下我标记的两行。一开始，就像以前一样，我们再次访问调用者对象，在位置1处将其值更改为数字`42`。然后，我们重新分配`x`指向`'something
    else'`字符串。这不会改变调用者，并且实际上输出与前面片段的输出相同。
- en: Take your time to play around with this concept, and experiment with prints
    and calls to the `id` function until everything is clear in your mind. This is
    one of the key aspects of Python and it must be very clear, otherwise you risk
    introducing subtle bugs into your code. Once again, the Python Tutor website ([http://www.pythontutor.com/](http://www.pythontutor.com/))
    will help you a lot by giving you a visual representation of these concepts.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 花点时间来玩弄这个概念，并尝试使用打印和调用`id`函数，直到你的思维中一切都清楚为止。这是Python的一个关键方面，必须非常清楚，否则你可能会在代码中引入微妙的错误。再一次，Python
    Tutor网站（[http://www.pythontutor.com/](http://www.pythontutor.com/)）将通过可视化这些概念来帮助你很多。
- en: Now that we have a good understanding of input parameters and how they behave,
    let's see how we can specify them.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对输入参数及其行为有了很好的理解，让我们看看如何指定它们。
- en: How to specify input parameters
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何指定输入参数
- en: 'There are five different ways of specifying input parameters:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有五种不同的指定输入参数的方式：
- en: Positional arguments
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置参数
- en: Keyword arguments
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字参数
- en: Variable positional arguments
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变位置参数
- en: Variable keyword arguments
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变关键字参数
- en: Keyword-only arguments
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅限关键字参数
- en: Let's look at them one by one.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个来看看它们。
- en: Positional arguments
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位置参数
- en: 'Positional arguments are read from left to right and they are the most common
    type of arguments:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 位置参数是从左到右读取的，它们是最常见的参数类型：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: There is not much else to say. They can be as numerous as you want and they
    are assigned by position. In the function call, `1` comes first, `2` comes second,
    and `3` comes third, therefore they are assigned to `a`, `b`, and `c`, respectively.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 没有太多其他的事情可说。它们可以是任意多的，并且按位置分配。在函数调用中，`1`先出现，`2`第二出现，`3`第三出现，因此它们分别分配给`a`，`b`和`c`。
- en: Keyword arguments and default values
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关键字参数和默认值
- en: '**Keyword arguments** are assigned by keyword using the `name=value` syntax:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键字参数**是使用`name=value`语法按关键字分配的：'
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Keyword arguments are matched by name, even when they don't respect the definition's
    original position (we'll see that there is a limitation to this behavior later,
    when we mix and match different types of arguments).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数是根据名称匹配的，即使它们不遵守定义的原始位置（当我们混合和匹配不同类型的参数时，我们将看到这种行为有一个限制）。
- en: 'The counterpart of keyword arguments, on the definition side, is **default
    values**. The syntax is the same, `name=value`, and allows us to not have to provide
    an argument if we are happy with the given default:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数的对应物，在定义方面，是**默认值**。语法是相同的，`name=value`，并且允许我们不必提供参数，如果我们对给定的默认值满意的话：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The are two things to notice, which are very important. First of all, you cannot
    specify a default argument on the left of a positional one. Second, note how in
    the examples, when an argument is passed without using the `argument_name=value`
    syntax, it must be the first one in the list, and it is always assigned to `a`.
    Notice also that passing values in a positional fashion still works, and follows
    the function signature order (last line of the example).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有两件很重要的事情需要注意。首先，你不能在位置参数的左边指定默认参数。其次，在这些例子中，当一个参数被传递而没有使用`argument_name=value`语法时，它必须是列表中的第一个，并且总是被赋值给`a`。还要注意，以位置方式传递值仍然有效，并且遵循函数签名的顺序（例子的最后一行）。
- en: 'Try and scramble those arguments and see what happens. Python error messages
    are very good at telling you what''s wrong. So, for example, if you tried something
    such as this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试混淆这些参数，看看会发生什么。Python的错误消息非常擅长告诉你出了什么问题。所以，例如，如果你尝试这样做：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You would get the following error:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到以下错误：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This informs you that you've called the function incorrectly.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这会告诉你你调用函数的方式不正确。
- en: Variable positional arguments
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变位置参数
- en: 'Sometimes you may want to pass a variable number of positional arguments to
    a function, and Python provides you with the ability to do it. Let''s look at
    a very common use case, the `minimum` function. This is a function that calculates
    the minimum of its input values:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你可能想要向函数传递可变数量的位置参数，Python提供了这样的能力。让我们看一个非常常见的用例，`minimum`函数。这是一个计算其输入值的最小值的函数：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, when we specify a parameter prepending a `*` to its name, we
    are telling Python that that parameter will be collecting a variable number of
    positional arguments, according to how the function is called. Within the function,
    `n` is a tuple. Uncomment `print(type(n))` to see for yourself and play around
    with it for a bit.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，当我们在参数名前面加上`*`时，我们告诉Python该参数将根据函数的调用方式收集可变数量的位置参数。在函数内部，`n`是一个元组。取消注释`print(type(n))`，自己看看并玩弄一下。
- en: Have you noticed how we checked whether `n` wasn't empty with a simple `if n:`?
    This is because collection objects evaluate to `True` when non-empty, and otherwise
    `False` in Python. This is true for tuples, sets, lists, dictionaries, and so
    on.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到我们如何用简单的`if n:`检查`n`是否为空？这是因为在Python中，集合对象在非空时求值为`True`，否则为`False`。这对于元组、集合、列表、字典等都是成立的。
- en: One other thing to note is that we may want to throw an error when we call the
    function with no arguments, instead of silently doing nothing. In this context,
    we're not concerned about making this function robust, but in understanding variable
    positional arguments.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事需要注意的是，当我们调用函数时没有传递参数时，我们可能希望抛出一个错误，而不是默默地什么都不做。在这种情况下，我们不关心使这个函数健壮，而是要理解可变位置参数。
- en: 'Let''s make another example to show you two things that, in my experience,
    are confusing to those who are new to this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举个例子来展示两件事，根据我的经验，这对于新手来说是令人困惑的：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Take a good look at the last two lines of the preceding example. In the first
    one, we call `func` with one argument, a four-elements tuple. In the second example,
    by using the `*` syntax, we''re doing something called **unpacking**, which means
    that the four-elements tuple is unpacked, and the function is called with four
    arguments: `1, 3, -7, 9`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看一下前面例子的最后两行。在第一个例子中，我们用一个参数调用`func`，一个四元组。在第二个例子中，通过使用`*`语法，我们在做一种叫做**解包**的操作，这意味着四元组被解包，函数被调用时有四个参数：`1,
    3, -7, 9`。
- en: This behavior is part of the magic Python does to allow you to do amazing things
    when calling functions dynamically.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为是Python为了让你在动态调用函数时做一些惊人的事情而做的魔术的一部分。
- en: Variable keyword arguments
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变关键字参数
- en: 'Variable keyword arguments are very similar to variable positional arguments.
    The only difference is the syntax (`**` instead of `*`) and that they are collected
    in a dictionary. Collection and unpacking work in the same way, so let''s look
    at an example:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 可变关键字参数与可变位置参数非常相似。唯一的区别是语法（`**`而不是`*`）以及它们被收集在一个字典中。收集和解包的工作方式相同，让我们看一个例子：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: All the calls are equivalent in the preceding example. You can see that adding
    a `**` in front of the parameter name in the function definition tells Python
    to use that name to collect a variable number of keyword parameters. On the other
    hand, when we call the function, we can either pass `name=value` arguments explicitly,
    or unpack a dictionary using the same `**` syntax.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，所有的调用都是等价的。你可以看到，在函数定义中在参数名前面添加`**`告诉Python使用该名称来收集可变数量的关键字参数。另一方面，当我们调用函数时，我们可以显式传递`name=value`参数，或者使用相同的`**`语法解包字典。
- en: 'The reason why being able to pass a variable number of keyword parameters is
    so important may not be evident at the moment, so, how about a more realistic
    example? Let''s define a function that connects to a database. We want to connect
    to a default database by simply calling this function with no parameters. We also
    want to connect to any other database by passing the function the appropriate
    arguments. Before you read on, try to spend a couple of minutes figuring out a
    solution by yourself:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 能够传递可变数量的关键字参数的重要性可能目前还不明显，那么，来看一个更现实的例子如何？让我们定义一个连接到数据库的函数。我们希望通过简单调用这个函数而连接到默认数据库。我们还希望通过传递适当的参数来连接到任何其他数据库。在继续阅读之前，试着花几分钟时间自己想出一个解决方案：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Note that in the function, we can prepare a dictionary of connection parameters
    (`conn_params`) using default values as fallbacks, allowing them to be overwritten
    if they are provided in the function call. There are better ways to do this with
    fewer lines of code, but we''re not concerned with that right now. Running the
    preceding code yields the following result:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在函数中，我们可以准备一个连接参数的字典（`conn_params`），使用默认值作为回退，允许在函数调用中提供这些参数时覆盖它们。有更少行代码的更好的方法来做到这一点，但我们现在不关心这个。运行前面的代码产生了以下结果：
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note the correspondence between the function calls and the output. Notice how
    default values are overridden according to what was passed to the function.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意函数调用和输出之间的对应关系。注意默认值是如何根据传递给函数的内容被覆盖的。
- en: Keyword-only arguments
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仅限关键字参数
- en: 'Python 3 allows for a new type of parameter: the **keyword-only** parameter.
    We are going to study them only briefly as their use cases are not that frequent.
    There are two ways of specifying them, either after the variable positional arguments,
    or after a bare `*`. Let''s see an example of both:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3允许一种新类型的参数：**仅限关键字**参数。我们只会简要地研究它们，因为它们的使用情况并不那么频繁。有两种指定它们的方式，要么在可变位置参数之后，要么在一个裸的`*`之后。让我们看一下两种方式的例子：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As anticipated, the function, `kwo`, takes a variable number of positional arguments
    (`a`) and a keyword-only one, `c`. The results of the calls are straightforward
    and you can uncomment the third call to see what error Python returns.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，函数`kwo`接受可变数量的位置参数（`a`）和一个仅限关键字的参数`c`。调用的结果很直接，你可以取消注释第三个调用以查看Python返回的错误。
- en: The same applies to the function, `kwo2`, which differs from `kwo` in that it
    takes a positional argument, `a`, a keyword argument, `b`, and then a keyword-only
    one, `c`. You can uncomment the third call to see the error.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的规则适用于函数`kwo2`，它与`kwo`不同之处在于它接受一个位置参数`a`，一个关键字参数`b`，然后是一个仅限关键字参数`c`。你可以取消注释第三个调用以查看错误。
- en: Now that you know how to specify different types of input parameters, let's
    see how you can combine them in function definitions.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何指定不同类型的输入参数，让我们看看如何在函数定义中组合它们。
- en: Combining input parameters
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合输入参数
- en: 'You can combine input parameters, as long as you follow these ordering rules:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以组合输入参数，只要遵循这些顺序规则：
- en: When defining a function, normal positional arguments come first (`name`), then
    any default arguments (`name=value`), then the variable positional arguments (`*name` or
    simply `*`), then any keyword-only arguments (either `name` or `name=value` form
    is good), and then any variable keyword arguments (`**name`).
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在定义函数时，普通的位置参数首先出现（`name`），然后是任意的默认参数（`name=value`），然后是可变位置参数（`*name`或简单的`*`），然后是任意的仅限关键字参数（`name`或`name=value`形式都可以），最后是任意的可变关键字参数（`**name`）。
- en: 'On the other hand, when calling a function, arguments must be given in the
    following order: positional arguments first (`value`), then any combination of
    keyword arguments (`name=value`), variable positional arguments (`*name`), and
    then variable keyword arguments (`**name`).'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，在调用函数时，参数必须按照以下顺序给出：首先是位置参数（`value`），然后是任意组合的关键字参数（`name=value`），可变位置参数（`*name`），然后是可变关键字参数（`**name`）。
- en: 'Since this can be a bit tricky when left hanging in the theoretical world,
    let''s look at a couple of quick examples:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这在理论世界中留下来可能有点棘手，让我们看一些快速的例子：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Note the order of the parameters in the function definition, and that the two
    calls are equivalent. In the first one, we''re using the unpacking operators for
    iterables and dictionaries, while in the second one we''re using a more explicit
    syntax. The execution of this yields the following (I printed only the result
    of one call, the other one being the same):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意函数定义中参数的顺序，以及两个调用是等价的。在第一个调用中，我们使用了可迭代对象和字典的解包操作符，而在第二个调用中，我们使用了更明确的语法。执行这个代码产生了以下结果（我只打印了一个调用的结果，另一个是一样的）：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s now look at an example with keyword-only arguments:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一个带有仅限关键字参数的例子：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Note that I have highlighted the keyword-only arguments in the function declaration.
    They come after the `*args` variable positional argument, and it would be the
    same if they came right after a single `*` (in which case there wouldn''t be a
    variable positional argument). The execution of this yields the following (I printed
    only the result of one call):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我在函数声明中突出显示了仅限关键字参数。它们出现在`*args`变量位置参数之后，如果它们直接出现在单个`*`之后的话，情况也是一样的（在这种情况下就不会有变量位置参数了）。执行这个代码产生了以下结果（我只打印了一个调用的结果）：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: One other thing to note is the names I gave to the variable positional and keyword
    arguments. You're free to choose differently, but be aware that `args` and `kwargs`
    are the conventional names given to these parameters, at least generically.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的事情是我给变量位置和关键字参数的名称。你可以自由选择不同的名称，但要注意`args`和`kwargs`是至少在一般情况下给这些参数的常规名称。
- en: Additional unpacking generalizations
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外的解包概括
- en: 'One of the recent new features, introduced in Python 3.5, is the ability to
    extend the iterable (`*`) and dictionary (`**`) unpacking operators to allow unpacking
    in more positions, an arbitrary number of times, and in additional circumstances. I''ll
    present you with an example concerning function calls:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.5中引入的最近的新特性之一是能够扩展可迭代（`*`）和字典（`**`）解包操作符，以允许在更多位置、任意次数和额外情况下进行解包。我将给你一个关于函数调用的例子：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the previous example, we defined a simple function that prints its input
    arguments, `args` and `kwargs`. The new feature lies in the way we call this function.
    Notice how we can unpack multiple iterables and dictionaries, and they are correctly
    coalesced under `args` and `kwargs`. The reason why this feature is important
    is that it allows us not to have to merge `args1` with `args2`, and `kwargs1`
    with `kwargs2` in the code. Running the code produces:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们定义了一个简单的函数，打印它的输入参数`args`和`kwargs`。新特性在于我们调用这个函数的方式。注意我们如何解包多个可迭代对象和字典，并且它们在`args`和`kwargs`下正确地合并。这个特性之所以重要的原因是它允许我们不必在代码中合并`args1`和`args2`，以及`kwargs1`和`kwargs2`。运行代码会产生：
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Please refer to PEP 448 ([https://www.python.org/dev/peps/pep-0448/](https://www.python.org/dev/peps/pep-0448/)) to
    learn the full extent of this new feature and see further examples.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考PEP 448（[https://www.python.org/dev/peps/pep-0448/](https://www.python.org/dev/peps/pep-0448/)）了解这个新特性的全部内容，并查看更多例子。
- en: Avoid the trap! Mutable defaults
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免陷阱！可变默认值
- en: 'One thing to be very aware of with Python is that default values are created
    at `def` time, therefore, subsequent calls to the same function will possibly
    behave differently according to the mutability of their default values. Let''s
    look at an example:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中需要非常注意的一件事是，默认值是在`def`时创建的，因此，对同一个函数的后续调用可能会根据它们的默认值的可变性而有所不同。让我们看一个例子：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Both parameters have mutable default values. This means that, if you affect
    those objects, any modification will stick around in subsequent function calls.
    See if you can understand the output of those calls:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 两个参数都有可变的默认值。这意味着，如果你影响这些对象，任何修改都会在后续的函数调用中保留下来。看看你能否理解这些调用的输出：
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It''s interesting, isn''t it? While this behavior may seem very weird at first,
    it actually makes sense, and it''s very handy, for example, when using memoization
    techniques (Google an example of that, if you''re interested). Even more interesting
    is what happens when, between the calls, we introduce one that doesn''t use defaults,
    such as this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 很有趣，不是吗？虽然这种行为一开始可能看起来很奇怪，但实际上是有道理的，而且非常方便，例如，在使用记忆化技术时（如果你感兴趣的话，可以搜索一个例子）。更有趣的是，当我们在调用之间引入一个不使用默认值的调用时会发生什么，比如这样：
- en: '[PRE36]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When we run this code, this is the output:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这段代码时，输出如下：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This output shows us that the defaults are retained even if we call the function
    with other values. One question that comes to mind is, how do I get a fresh empty
    value every time? Well, the convention is the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出告诉我们，即使我们用其他值调用函数，默认值仍然保留。一个让人想到的问题是，我怎样才能每次都得到一个全新的空值呢？嗯，约定是这样的：
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note that, by using the preceding technique, if `a` isn't passed when calling
    the function, you always get a brand new, empty list.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通过使用前面的技术，如果在调用函数时没有传递`a`，你总是会得到一个全新的空列表。
- en: Okay, enough with the input, let's look at the other side of the coin, the output.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，输入就到此为止，让我们看看另一面，输出。
- en: Return values
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回值
- en: The return values of functions are one of those things where Python is ahead
    of most other languages. Functions are usually allowed to return one object (one
    value) but, in Python, you can return a tuple, and this implies that you can return
    whatever you want. This feature allows a coder to write software that would be
    much harder to write in any other language, or certainly more tedious. We've already
    said that to return something from a function we need to use the `return` statement,
    followed by what we want to return. There can be as many return statements as
    needed in the body of a function.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的返回值是Python领先于大多数其他语言的东西之一。通常函数只允许返回一个对象（一个值），但在Python中，你可以返回一个元组，这意味着你可以返回任何你想要的东西。这个特性允许程序员编写在其他语言中要难得多或者肯定更加繁琐的软件。我们已经说过，要从函数中返回一些东西，我们需要使用`return`语句，后面跟着我们想要返回的东西。在函数体中可以有多个return语句。
- en: On the other hand, if within the body of a function we don't return anything,
    or we invoke a bare `return` statement, the function will return `None`. This
    behavior is harmless and, even though I don't have the room here to go into detail
    explaining why Python was designed like this, let me just tell you that this feature
    allows for several interesting patterns, and confirms Python as a very consistent
    language.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果在函数体内部我们没有返回任何东西，或者我们调用一个裸的`return`语句，函数将返回`None`。这种行为是无害的，尽管我在这里没有足够的空间来详细解释为什么Python被设计成这样，但我只想告诉你，这个特性允许出现几种有趣的模式，并确认Python是一种非常一致的语言。
- en: 'I say it''s harmless because you are never forced to collect the result of
    a function call. I''ll show you what I mean with an example:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我说它是无害的，因为你从来不会被迫收集函数调用的结果。我会用一个例子来说明我的意思：
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that the whole body of the function is composed only of the `pass` statement.
    As the official documentation tells us, `pass` is a null operation. When it is
    executed, nothing happens. It is useful as a placeholder when a statement is required
    syntactically, but no code needs to be executed. In other languages, we would
    probably just indicate that with a pair of curly brackets (`{}`), which define
    an *empty scope*, but in Python, a scope is defined by indenting code, therefore
    a statement such as `pass` is necessary.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，函数的整个主体只由`pass`语句组成。正如官方文档告诉我们的那样，`pass`是一个空操作。当它被执行时，什么都不会发生。当语法上需要一个语句，但不需要执行任何代码时，它是有用的。在其他语言中，我们可能会用一对花括号（`{}`）来表示这一点，它定义了一个*空作用域*，但在Python中，作用域是通过缩进代码来定义的，因此`pass`这样的语句是必要的。
- en: Notice also that the first call of the `func` function returns a value (`None`)
    which we don't collect. As I said before, collecting the return value of a function
    call is not mandatory.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，`func`函数的第一个调用返回一个值（`None`），我们没有收集。正如我之前所说的，收集函数调用的返回值并不是强制性的。
- en: 'Now, that''s good but not very interesting so, how about we write an interesting
    function? Remember that in [Chapter 1](part0021.html#K0RQ0-2ddb708647cc4530a187c2c6c0e9acfe),
    *A Gentle Introduction to Python*, we talked about the factorial of a function.
    Let''s write our own here (for simplicity, I will assume the function is always
    called correctly with appropriate values so I won''t sanity-check the input argument):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这很好但不是很有趣，那么我们来写一个有趣的函数吧？记住，在[第1章](part0021.html#K0RQ0-2ddb708647cc4530a187c2c6c0e9acfe)中，*Python的初步介绍*，我们谈到了一个函数的阶乘。让我们在这里写一个（为简单起见，我将假设函数总是以适当的值正确调用，因此我不会对输入参数进行检查）：
- en: '[PRE40]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Note that we have two points of return. If `n` is either `0` or `1` (in Python
    it''s common to use the `in` type of check, as I did instead of the more verbose
    `if n == 0 or n == 1:`), we return `1`. Otherwise, we perform the required calculation
    and we return `result`. Let''s try to write this function a little bit more succinctly:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们有两个返回点。如果`n`是`0`或`1`（在Python中，通常使用`in`类型的检查，就像我所做的那样，而不是更冗长的`if n == 0 or
    n == 1:`），我们返回`1`。否则，我们执行所需的计算，然后返回`result`。让我们尝试以更简洁的方式编写这个函数：
- en: '[PRE41]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'I know what you''re thinking: one line? Python is elegant, and concise! I think
    this function is readable even if you have never seen `reduce` or `mul`, but if
    you can''t read it or understand it, set aside a few minutes and do some research
    on the Python documentation until its behavior is clear to you. Being able to
    look up functions in the documentation and understand code written by someone
    else is a task every developer needs to be able to perform, so take this as a
    challenge.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你在想什么：一行？Python是优雅而简洁的！我认为这个函数是可读的，即使你从未见过`reduce`或`mul`，但如果你不能读懂或理解它，花几分钟时间在Python文档中进行一些研究，直到它的行为对你清晰明了。能够在文档中查找函数并理解他人编写的代码是每个开发人员都需要执行的任务，所以把它当作一个挑战。
- en: To this end, make sure you look up the `help` function, which proves quite helpful
    when exploring with the console.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，请确保查找`help`函数，在控制台上探索时非常有帮助。
- en: Returning multiple values
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回多个值
- en: 'Unlike in most other languages, in Python it''s very easy to return multiple
    objects from a function. This feature opens up a whole world of possibilities
    and allows you to code in a style that is hard to reproduce with other languages.
    Our thinking is limited by the tools we use, therefore when Python gives you more
    freedom than other languages, it is actually boosting your own creativity as well.
    To return multiple values is very easy, you just use tuples (either explicitly
    or implicitly). Let''s look at a simple example that mimics the `divmod` built-in
    function:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数其他语言不同，在Python中很容易从函数中返回多个对象。这个特性打开了一个全新的可能性世界，并允许你以其他语言难以复制的风格编码。我们的思维受到我们使用的工具的限制，因此当Python给你比其他语言更多的自由时，实际上也在提高你自己的创造力。返回多个值非常容易，你只需使用元组（显式或隐式）。让我们看一个简单的例子，模仿`divmod`内置函数：
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: I could have wrapped the highlighted part in the preceding code in brackets,
    making it an explicit tuple, but there's no need for that. The preceding function
    returns both the result and the remainder of the division, at the same time.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我本可以将前面代码中的突出部分用括号括起来，使其成为一个显式元组，但没有必要。前面的函数同时返回除法的结果和余数。
- en: In the source code for this example, I have left a simple example of a test
    function to make sure my code is doing the correct calculation.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子的源代码中，我留下了一个简单的测试函数的例子，以确保我的代码进行了正确的计算。
- en: A few useful tips
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些建议
- en: 'When writing functions, it''s very useful to follow guidelines so that you
    write them well. I''ll quickly point some of them out:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写函数时，遵循指南非常有用，这样你就可以很好地编写它们。我会快速指出其中一些：
- en: '**Functions should do one thing**: Functions that do one thing are easy to
    describe in one short sentence. Functions that do multiple things can be split
    into smaller functions that do one thing. These smaller functions are usually
    easier to read and understand. Remember the data science example we saw a few
    pages ago.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数应该只做一件事**：只做一件事的函数很容易用一句简短的话来描述。做多件事的函数可以拆分成做一件事的小函数。这些小函数通常更容易阅读和理解。记住我们几页前看到的数据科学例子。'
- en: '**Functions should be small**: The smaller they are, the easier it is to test
    them and to write them so that they do one thing.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数应该小而精**：它们越小，测试它们和编写它们就越容易，以便它们只做一件事。'
- en: '**The fewer input parameters, the better**: Functions that take a lot of arguments
    quickly become harder to manage (among other issues).'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入参数越少越好**：需要大量参数的函数很快就变得难以管理（还有其他问题）。'
- en: '**Functions should be consistent in their return values**: Returning `False`
    or `None` is not the same thing, even if within a Boolean context they both evaluate
    to `False`. `False` means that we have information (`False`), while `None` means
    that there is no information. Try writing functions that return in a consistent
    way, no matter what happens in their body.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数在返回值上应该保持一致**：返回`False`或`None`并不相同，即使在布尔上下文中它们都评估为`False`。`False`意味着我们有信息（`False`），而`None`意味着没有信息。尝试编写函数，无论在函数体中发生什么，都以一致的方式返回。'
- en: '**Functions shouldn''t have side effects**: In other words, functions should
    not affect the values you call them with. This is probably the hardest statement
    to understand at this point, so I''ll give you an example using lists. In the
    following code, note how `numbers` is not sorted by the `sorted` function, which
    actually returns a sorted copy of `numbers`. Conversely, the `list.sort()` method
    is acting on the `numbers` object itself, and that is fine because it is a method
    (a function that belongs to an object and therefore has the rights to modify it):'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数不应该有副作用**：换句话说，函数不应该影响你调用它们时的值。这可能是最难理解的陈述，所以我会给你一个例子，使用列表。在下面的代码中，请注意`numbers`没有被`sorted`函数排序，实际上`sorted`函数返回的是`numbers`的排序副本。相反，`list.sort()`方法是作用于`numbers`对象本身的，这是可以的，因为它是一个方法（属于对象的函数，因此有权修改它）：'
- en: '[PRE43]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Follow these guidelines and you'll write better functions, which will serve
    you well.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这些准则，你将会写出更好的函数，这将对你有所帮助。
- en: '*Chapter 3*, *Functions* in *Clean Code* by Robert C. Martin, Prentice Hall
    is dedicated to functions and it''s probably the best set of guidelines I''ve
    ever read on the subject.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Robert C. Martin的《代码整洁之道》中的*第3章*，*函数*专门讲述了函数，这可能是我读过的关于这个主题的最好的一套准则。
- en: Recursive functions
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归函数
- en: When a function calls itself to produce a result, it is said to be **recursive**.
    Sometimes recursive functions are very useful in that they make it easier to write
    code. Some algorithms are very easy to write using the recursive paradigm, while
    others are not. There is no recursive function that cannot be rewritten in an
    iterative fashion, so it's usually up to the programmer to choose the best approach
    for the case at hand.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数调用自身来产生结果时，它被称为**递归**。有时递归函数非常有用，因为它们使编写代码变得更容易。有些算法使用递归范式编写起来非常容易，而其他一些则不是。没有递归函数不能以迭代方式重写，因此通常由程序员来选择最佳的方法来处理当前情况。
- en: 'The body of a recursive function usually has two sections: one where the return
    value depends on a subsequent call to itself, and one where it doesn''t (called
    a base case).'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数的主体通常有两个部分：一个是返回值取决于对自身的后续调用，另一个是不取决于对自身的调用（称为基本情况）。
- en: 'As an example, we can consider the (hopefully familiar by now) `factorial`
    function, *N!*. The base case is when *N* is either `0` or `1`. The function returns
    `1` with no need for further calculation. On the other hand, in the general case,
    *N!* returns the product *1 * 2 * ... * (N-1) * N*. If you think about it, *N!*
    can be rewritten like this: *N! = (N-1)! * N*. As a practical example, consider
    *5! = 1 * 2 * 3 * 4 * 5 = (1 * 2 * 3 * 4) * 5 = 4! * 5*.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，我们可以考虑（希望现在已经熟悉的）`factorial`函数，*N!*。基本情况是当*N*为`0`或`1`时。函数返回`1`，无需进一步计算。另一方面，在一般情况下，*N!*返回乘积*1
    * 2 * ... * (N-1) * N*。如果你仔细想一想，*N!*可以这样重写：*N! = (N-1)! * N*。作为一个实际的例子，考虑*5! =
    1 * 2 * 3 * 4 * 5 = (1 * 2 * 3 * 4) * 5 = 4! * 5*。
- en: 'Let''s write this down in code:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这个写成代码：
- en: '[PRE44]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: When writing recursive functions, always consider how many nested calls you
    make, since there is a limit. For further information on this, check out `sys.getrecursionlimit()`
    and `sys.setrecursionlimit()`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写递归函数时，始终要考虑你进行了多少嵌套调用，因为有一个限制。有关此信息，请查看`sys.getrecursionlimit()`和`sys.setrecursionlimit()`。
- en: Recursive functions are used a lot when writing algorithms and they can be really
    fun to write. As an exercise, try to solve a couple of simple problems using both
    a recursive and an iterative approach.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数在编写算法时经常使用，而且编写起来真的很有趣。作为练习，尝试使用递归和迭代方法解决一些简单的问题。
- en: Anonymous functions
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匿名函数
- en: One last type of functions that I want to talk about are **anonymous** functions.
    These functions, which are called **lambdas** in Python, are usually used when
    a fully-fledged function with its own name would be overkill, and all we want
    is a quick, simple one-liner that does the job.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我想谈谈的最后一种函数类型是**匿名**函数。这些函数在Python中被称为**lambda**，通常在需要一个完全成熟的函数及其自己的名称会显得过度的情况下使用，我们只需要一个快速、简单的一行代码来完成工作。
- en: 'Imagine that you want a list of all the numbers up to *N* that are multiples
    of five. Imagine that you want to filter those out using the `filter` function,
    which takes a function and an iterable and constructs a filter object that you
    can iterate on, from those elements of iterables for which the function returns
    `True`. Without using an anonymous function, you would do something like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要一个包含* N *的所有倍数的列表。假设你想使用`filter`函数来过滤掉那些元素，该函数接受一个函数和一个可迭代对象，并构造一个过滤器对象，你可以从中迭代，从可迭代对象中返回`True`的元素。如果不使用匿名函数，你可能会这样做：
- en: '[PRE45]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Note how we use `is_multiple_of_five` to filter the first `n` natural numbers.
    This seems a bit excessive, the task is simple and we don''t need to keep the
    `is_multiple_of_five` function around for anything else. Let''s rewrite it using
    a lambda function:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们如何使用`is_multiple_of_five`来过滤前`n`个自然数。这似乎有点多余，任务很简单，我们不需要保留`is_multiple_of_five`函数以供其他用途。让我们使用lambda函数重新编写它：
- en: '[PRE46]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The logic is exactly the same but the filtering function is now a lambda. Defining
    a lambda is very easy and follows this form: `func_name = lambda [parameter_list]:
    expression`. A function object is returned, which is equivalent to this: `def
    func_name([parameter_list]): return expression`.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '逻辑完全相同，但过滤函数现在是一个lambda。定义lambda非常容易，遵循这种形式：`func_name = lambda [parameter_list]:
    expression`。返回一个函数对象，等同于这个：`def func_name([parameter_list]): return expression`。'
- en: Note that optional parameters are indicated following the common syntax of wrapping
    them in square brackets.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，可选参数遵循常见的语法，用方括号括起来表示。
- en: 'Let''s look at another couple of examples of equivalent functions defined in
    the two forms:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看看两种形式定义的等效函数的另外一些例子：
- en: '[PRE47]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The preceding examples are very simple. The first one adds two numbers, and
    the second one produces the uppercase version of a string. Note that I assigned
    what is returned by the `lambda` expressions to a name (`adder_lambda`, `to_upper_lambda`),
    but there is no need for that when you use lambdas in the way we did in the `filter`
    example.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子非常简单。第一个例子是两个数字相加，第二个例子是产生字符串的大写版本。请注意，我将`lambda`表达式返回的内容赋给了一个名称（`adder_lambda`、`to_upper_lambda`），但当你像我们在`filter`示例中那样使用lambda时，没有必要这样做。
- en: Function attributes
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数属性
- en: 'Every function is a fully-fledged object and, as such, they have many attributes.
    Some of them are special and can be used in an introspective way to inspect the
    function object at runtime. The following script is an example that shows a part
    of them and how to display their value for an example function:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都是一个完整的对象，因此它们有许多属性。其中一些是特殊的，可以用内省的方式在运行时检查函数对象。以下脚本是一个示例，显示了其中一部分属性以及如何显示示例函数的值：
- en: '[PRE49]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'I used the built-in `getattr` function to get the value of those attributes.
    `getattr(obj, attribute)` is equivalent to `obj.attribute` and comes in handy
    when we need to get an attribute at runtime using its string name. Running this
    script yields:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了内置的`getattr`函数来获取这些属性的值。`getattr(obj, attribute)`等同于`obj.attribute`，在我们需要使用字符串名称在运行时获取属性时非常方便。运行这个脚本会产生：
- en: '[PRE50]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: I have omitted the value of the `__globals__` attribute, as it was too big.
    An explanation of the meaning of this attribute can be found in the *Callable **types*
    section of the *Python Data Model* documentation page ([https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy](https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy)).
    Should you want to see all the attributes of an object, just call `dir(object_name)`
    and you'll be given the list of all of its attributes.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我已省略了`__globals__`属性的值，因为它太大了。关于这个属性的含义解释可以在*Python数据模型*文档页面的*可调用**类型*部分找到（[https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy](https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy)）。如果你想要查看对象的所有属性，只需调用`dir(object_name)`，就会得到所有属性的列表。
- en: Built-in functions
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置函数
- en: Python comes with a lot of built-in functions. They are available anywhere and
    you can get a list of them by inspecting the `builtins` module with `dir(__builtins__)`,
    or by going to the official Python documentation. Unfortunately, I don't have
    the room to go through all of them here. We've already seen some of them, such
    as `any`, `bin`, `bool`, `divmod`, `filter`, `float`, `getattr`, `id`, `int`,
    `len`, `list`, `min`, `print`, `set`, `tuple`, `type`, and `zip`, but there are
    many more, which you should read at least once. Get familiar with them, experiment,
    write a small piece of code for each of them, and make sure you have them at your
    finger tips so that you can use them when you need them.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Python自带了许多内置函数。它们随处可用，你可以通过检查`builtins`模块的`dir(__builtins__)`来获取它们的列表，或者查看官方Python文档。不幸的是，我没有足够的空间在这里介绍它们所有。我们已经见过其中一些，比如`any`、`bin`、`bool`、`divmod`、`filter`、`float`、`getattr`、`id`、`int`、`len`、`list`、`min`、`print`、`set`、`tuple`、`type`和`zip`，但还有许多其他的，你至少应该阅读一次。熟悉它们，进行实验，为每一个编写一小段代码，并确保你能随时使用它们。
- en: One final example
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后一个例子
- en: Before we finish off this chapter, how about one last example? I was thinking
    we could write a function to generate a list of prime numbers up to a limit. We've
    already seen the code for this so let's make it a function and, to keep it interesting,
    let's optimize it a bit.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章之前，最后一个例子怎么样？我在想我们可以编写一个函数来生成一个小于某个限制的质数列表。我们已经看到了这个代码，所以让我们把它变成一个函数，并且为了保持趣味性，让我们对它进行优化一下。
- en: 'It turns out that you don''t need to divide it by all numbers from *2* to *N*-1
    to decide whether a number, *N*, is prime. You can stop at *√N*. Moreover, you
    don''t need to test the division for all numbers from *2* to *√N*, you can just
    use the primes in that range. I''ll leave it to you to figure out why this works,
    if you''re interested. Let''s see how the code changes:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 原来你不需要将*N*除以从*2*到*N*-1的所有数字来判断一个数*N*是否是质数。你可以停在*√N*。此外，你不需要测试从*2*到*√N*的所有数字的除法，你可以只使用该范围内的质数。如果你感兴趣，我会留给你去弄清楚为什么这样做有效。让我们看看代码如何改变：
- en: '[PRE52]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The code is the same as in the previous chapter. We have changed the division
    algorithm so that we only test divisibility using the previously calculated primes
    and we stopped once the testing divisor was greater than the root of the candidate.
    We used the `primelist` result list to get the primes for the division. We calculated
    the root value using a fancy formula, the integer value of the ceiling of the
    root of the candidate. While a simple `int(k ** 0.5) + 1` would have served our
    purpose as well, the formula I chose is cleaner and requires me to use a couple
    of imports, which I wanted to show you. Check out the functions in the `math`
    module, they are very interesting!
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码和上一章的代码是一样的。我们改变了除法算法，以便只使用先前计算的质数来测试可整除性，并且一旦测试除数大于候选数的平方根，我们就停止了。我们使用了`primelist`结果列表来获取除法的质数。我们使用了一个花哨的公式来计算根值，即候选数的根的天花板的整数值。虽然一个简单的`int(k
    ** 0.5) + 1`同样可以满足我们的目的，但我选择的公式更简洁，并且需要我使用一些导入，我想向你展示。查看`math`模块中的函数，它们非常有趣！
- en: Documenting your code
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码文档化
- en: I'm a big fan of code that doesn't need documentation. When you program correctly,
    choose the right names and take care of the details, your code should come out
    as self-explanatory and documentation should not be needed. Sometimes a comment
    is very useful though, and so is some documentation. You can find the guidelines
    for documenting Python in *PEP 257 - Docstring conventions* ([https://www.python.org/dev/peps/pep-0257/](https://www.python.org/dev/peps/pep-0257/)),
    but I'll show you the basics here.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常喜欢不需要文档的代码。当您正确编写程序，选择正确的名称并处理细节时，您的代码应该是不言自明的，不需要文档。有时注释非常有用，文档也是如此。您可以在*PEP
    257 - Docstring conventions*（[https://www.python.org/dev/peps/pep-0257/](https://www.python.org/dev/peps/pep-0257/)）中找到有关Python文档的指南，但我会在这里向您展示基础知识。
- en: 'Python is documented with strings, which are aptly called **docstrings**. Any
    object can be documented, and you can use either one-line or multiline docstrings.
    One-liners are very simple. They should not provide another signature for the
    function, but clearly state its purpose:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Python是用字符串记录的，这些字符串被称为**文档字符串**。任何对象都可以被记录，你可以使用单行或多行文档字符串。单行文档字符串非常简单。它们不应该为函数提供另一个签名，而是清楚地说明其目的。
- en: '[PRE53]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Using triple double-quoted strings allows you to expand easily later on. Use
    sentences that end in a period, and don't leave blank lines before or after.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三个双引号的字符串允许您以后轻松扩展。使用句子以句点结束，并且不要在之前或之后留下空行。
- en: 'Multiline comments are structured in a similar way. There should be a one-liner
    that briefly gives you the gist of what the object is about, and then a more verbose
    description. As an example, I have documented a fictitious `connect` function,
    using the Sphinx notation, in the following example:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释的结构方式类似。应该有一个简短的单行说明对象要点的一行，然后是更详细的描述。例如，我已经使用Sphinx符号对一个虚构的`connect`函数进行了文档记录，如下例所示：
- en: '[PRE54]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '**Sphinx** is probably the most widely used tool for creating Python documentation.
    In fact, the official Python documentation was written with it. It''s definitely
    worth spending some time checking it out.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**Sphinx**可能是创建Python文档最广泛使用的工具。事实上，官方Python文档就是用它编写的。值得花一些时间去了解它。'
- en: Importing objects
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入对象
- en: Now that you know a lot about functions, let's look at how to use them. The
    whole point of writing functions is to be able to reuse them later, and in Python,
    this translates to importing them into the namespace where you need them. There
    are many different ways to import objects into a namespace, but the most common
    ones are `import module_name` and `from module_name import function_name`. Of
    course, these are quite simplistic examples, but bear with me for the time being.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经对函数有了很多了解，让我们看看如何使用它们。编写函数的整个目的是以后能够重复使用它们，在Python中，这意味着将它们导入到需要它们的命名空间中。有许多不同的方法可以将对象导入到命名空间中，但最常见的是`import
    module_name`和`from module_name import function_name`。当然，这些都是相当简单的例子，但请暂时忍耐。
- en: The `import module_name` form finds the `module_name` module and defines a name
    for it in the local namespace where the `import` statement is executed. The `from
    module_name import identifier` form is a little bit more complicated than that,
    but basically does the same thing. It finds `module_name` and searches for an
    attribute (or a submodule) and stores a reference to `identifier` in the local
    namespace.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`import module_name`形式会找到`module_name`模块，并在执行`import`语句的本地命名空间中为其定义一个名称。`from
    module_name import identifier`形式比这略微复杂一些，但基本上做的是相同的事情。它找到`module_name`，并搜索属性（或子模块），并在本地命名空间中存储对`identifier`的引用。'
- en: 'Both forms have the option to change the name of the imported object using
    the `as` clause:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 两种形式都可以使用`as`子句更改导入对象的名称：
- en: '[PRE55]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Just to give you a flavor of what importing looks like, here''s an example
    from a test module of one of my projects (notice that the blank lines between
    blocks of imports follow the guidelines from PEP 8 at [https://www.python.org/dev/peps/pep-0008/#imports](https://www.python.org/dev/peps/pep-0008/#imports):
    standard library, third party, and local code):'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您了解导入的样子，这是我一个项目的测试模块的一个例子（请注意，导入块之间的空行遵循PEP 8的指南：标准库、第三方库和本地代码）：
- en: '[PRE56]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: When you have a structure of files starting in the root of your project, you
    can use the dot notation to get to the object you want to import into your current
    namespace, be it a package, a module, a class, a function, or anything else. The
    `from module import` syntax also allows a catch-all clause, `from module import
    *`, which is sometimes used to get all the names from a module into the current
    namespace at once, but it's frowned upon for several reasons, such as performance
    and the risk of silently shadowing other names. You can read all that there is
    to know about imports in the official Python documentation but, before we leave
    the subject, let me give you a better example.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当您拥有从项目根目录开始的文件结构时，您可以使用点表示法来获取要导入到当前命名空间的对象，无论是包、模块、类、函数还是其他任何东西。`from module
    import`语法还允许使用一个全捕子句`from module import *`，有时用于一次性将模块中的所有名称导入当前命名空间，但出于多种原因，如性能和潜在的静默屏蔽其他名称的风险，这是不被赞同的。您可以在官方Python文档中阅读有关导入的所有内容，但在我们离开这个主题之前，让我给您一个更好的例子。
- en: 'Imagine that you have defined a couple of functions: `square(n)` and `cube(n)`
    in a module, `funcdef.py`, which is in the `lib` folder. You want to use them
    in a couple of modules that are at the same level of the `lib` folder, called
    `func_import.py` and `func_from.py`. Showing the tree structure of that project
    produces something like this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经在一个名为`lib`的文件夹中定义了一对函数：`square(n)`和`cube(n)`，并且想要在`lib`文件夹的同一级别的一对模块`func_import.py`和`func_from.py`中使用它们。显示该项目的树结构会产生以下内容：
- en: '[PRE57]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Before I show you the code of each module, please remember that in order to
    tell Python that it is actually a package, we need to put a `__init__.py` module
    in it.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在我展示每个模块的代码之前，请记住，为了告诉Python它实际上是一个包，我们需要在其中放置一个`__init__.py`模块。
- en: There are two things to note about the `__init__.py` file. First of all, it
    is a fully-fledged Python module so you can put code into it as you would with
    any other module. Second, as of Python 3.3, its presence is no longer required
    to make a folder be interpreted as a Python package.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`__init__.py`文件有两点需要注意。首先，它是一个完整的Python模块，因此您可以像对待任何其他模块一样在其中放置代码。其次，从Python
    3.3开始，不再需要它的存在来使文件夹被解释为Python包。
- en: 'The code is as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '[PRE58]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Both these files, when executed, print `100` and `1000`. You can see how differently
    we then access the `square` and `cube` functions, according to how and what we
    imported in the current scope.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个文件在执行时都会打印出`100`和`1000`。您可以看到我们如何根据当前作用域中导入的内容以及导入的方式来访问`square`和`cube`函数的不同之处。
- en: Relative imports
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相对导入
- en: 'The imports we''ve seen so far are called **absolute**, that is, they define
    the whole path of the module that we want to import, or from which we want to
    import an object. There is another way of importing objects into Python, which
    is called a **relative import**. It''s helpful in situations where we want to
    rearrange the structure of large packages without having to edit sub-packages,
    or when we want to make a module inside a package able to import itself. Relative
    imports are done by adding as many leading dots in front of the module as the
    number of folders we need to backtrack, in order to find what we''re searching
    for. Simply put, it is something such as this:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的导入被称为**绝对**导入，即它们定义了我们要导入的模块的整个路径，或者我们要从中导入对象的模块。在Python中还有另一种导入对象的方式，称为**相对导入**。在需要重新排列大型包的结构而无需编辑子包的情况下，或者当我们希望使包内的模块能够自我导入时，相对导入非常有用。相对导入是通过在模块前面添加与我们需要回溯的文件夹数量相同的前导点来完成的，以便找到我们正在搜索的内容。简而言之，就是这样的：
- en: '[PRE59]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: For a complete explanation of relative imports, refer to PEP 328 ([https://www.python.org/dev/peps/pep-0328/](https://www.python.org/dev/peps/pep-0328/)).
    In later chapters, we'll create projects using different libraries and we'll use
    several different types of imports, including relative ones, so make sure you
    take a bit of time to read up about it in the official Python documentation.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 有关相对导入的完整解释，请参阅PEP 328（[https://www.python.org/dev/peps/pep-0328/](https://www.python.org/dev/peps/pep-0328/)）。在后面的章节中，我们将使用不同的库创建项目，并使用多种不同类型的导入，包括相对导入，因此请确保您花点时间在官方Python文档中了解相关内容。
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored the world of functions. They are extremely important
    and, from now on, we'll use them basically everywhere. We talked about the main
    reasons for using them, the most important of which are code reuse and implementation
    hiding.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探索了函数的世界。它们非常重要，从现在开始，我们基本上会在任何地方使用它们。我们讨论了使用它们的主要原因，其中最重要的是代码重用和实现隐藏。
- en: We saw that a function object is like a box that takes optional inputs and produces
    outputs. We can feed input values to a function in many different ways, using
    positional and keyword arguments, and using variable syntax for both types.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到函数对象就像一个接受可选输入并产生输出的盒子。我们可以以许多不同的方式向函数提供输入值，使用位置参数和关键字参数，并对两种类型都使用变量语法。
- en: Now you should know how to write a function, document it, import it into your
    code, and call it.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该知道如何编写函数、对其进行文档化、将其导入到您的代码中并调用它。
- en: The next chapter will force me to push my foot down on the throttle even more,
    so I suggest you take any opportunity you get to consolidate and enrich the knowledge
    you've gathered so far by putting your nose into the Python official documentation.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将迫使我更加加速，因此我建议您抓住任何机会，通过深入研究Python官方文档来巩固和丰富您迄今为止所获得的知识。
