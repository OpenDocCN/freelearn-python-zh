- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Building the Microservice Application
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建微服务应用程序
- en: Previously, we spent a lot of time building API services for various applications
    using the core features of FastAPI. We also started applying important design
    patterns such as **Inversion of Control** (**IoC**) and **Dependency Injection**
    (**DI**), which are essential for managing FastAPI container objects. External
    Python packages were installed and used to provide options on what containers
    to use in managing objects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，我们花费了大量时间使用FastAPI的核心功能为各种应用程序构建API服务。我们还开始应用重要的设计模式，如**控制反转**（**IoC**）和**依赖注入**（**DI**），这对于管理FastAPI容器对象至关重要。安装并使用了外部Python包来提供在管理对象时选择使用哪些容器的选项。
- en: These design patterns can help not only with managed objects in container but
    also when building scalable, enterprise-grade, and unconventionally complex applications.
    Most of these design patterns help break down monolithic architecture into loosely
    coupled components that are known as *microservices*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设计模式不仅可以帮助容器中的管理对象，还可以在构建可扩展的、企业级和非常复杂的应用程序时使用。大多数这些设计模式有助于将单体架构分解为松散耦合的组件，这些组件被称为*微服务*。
- en: In this chapter, we will explore some architectural design patterns and principles
    that can provide strategies and ways to initiate the building of our microservices
    from a monolithic application. Our focus will be on breaking the huge application
    into business units, creating a sole gateway to bundle these business units, applying
    domain modeling to each of the microservices, and managing other concerns such
    as logging and application configuration.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一些架构设计模式和原则，这些模式和原则可以提供策略和方法，从单体应用程序开始构建我们的微服务。我们的重点将放在将大型应用程序分解为业务单元，创建一个单独的网关来捆绑这些业务单元，将领域建模应用于每个微服务，以及管理其他关注点，如日志记录和应用程序配置。
- en: 'Aside from expounding the benefits and disadvantages of each design pattern,
    another objective is to apply these architectural patterns to our software specimen
    to show its effectiveness and feasibility. And to support these goals, the following
    topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 除了阐述每种设计模式的利弊之外，另一个目标是将这些架构模式应用于我们的软件样本，以展示其有效性和可行性。为了支持这些目标，本章将涵盖以下主题：
- en: Applying the decomposition pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用分解模式
- en: Creating a common gateway
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建通用网关
- en: Centralizing the logging mechanism
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集中日志机制
- en: Consuming the REST APIs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费REST API
- en: Applying the domain modeling approach
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用领域建模方法
- en: Managing a microservice’s configuration details
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理微服务的配置细节
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter uses a *university ERP system* prototype that focuses on the students,
    faculty, and library submodules, but more on student-library and faculty-library
    operations (for example, book borrowing and issuing). Each submodule has its administration,
    management, and transaction services, and they are independent of each other even
    though they are part of an ERP specification. Currently, this sample prototype
    does not use any database management system, so all the data is temporarily stored
    in Python containers. The code is all uploaded at [https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI](https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI)
    under the `ch04`, `ch04-student`, `ch04-faculty`, and `ch04-library` projects.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用了一个*大学ERP系统*原型，该原型专注于学生、教职员工和图书馆子模块，但更侧重于学生-图书馆和教职员工-图书馆操作（例如，借书和发放）。每个子模块都有自己的管理、管理和交易服务，尽管它们是ERP规范的一部分，但它们之间是独立的。目前，这个示例原型没有使用任何数据库管理系统，因此所有数据都临时存储在Python容器中。代码全部上传到[https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI](https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI)，在`ch04`、`ch04-student`、`ch04-faculty`和`ch04-library`项目中。
- en: Applying the decomposition pattern
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用分解模式
- en: If we apply the monolithic strategy used in building the prototypes presented
    in the previous chapters, building this ERP will not be cost-effective in terms
    of resources and effort. There will be features that might become too dependent
    on other functions, which will put the teams of developers in a difficult situation
    whenever transaction problems occur due to these tightly coupled features. The
    best way to implement our University ERP prototype is to decompose the whole specification
    into smaller modules before the implementation starts.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们应用在前面章节中展示的原型中使用的单体策略，那么在资源和工作量方面，构建这个ERP将不会具有成本效益。可能会有一些功能可能会过于依赖其他功能，这将在这些紧密耦合的功能因交易问题而出现时，使开发团队陷入困境。实现我们的大学ERP原型的最佳方式是在实施开始之前将整个规范分解成更小的模块。
- en: 'There are two appropriate ways in which to decompose our application prototype,
    namely decomposition by business units and decomposition by subdomains:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种合适的方法可以对我们的应用程序原型进行分解，即按业务单元分解和按子域分解：
- en: '*Decomposition by business units* is used when the breakdown of the monolithic
    application is based on organizational structures, architectural components, and
    structural units. Usually, its resulting modules have fixed and structured processes
    and functionality that are seldom enhanced or upgraded.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*按业务单元分解*用于当单体应用的分解基于组织结构、架构组件和结构单元时。通常，其结果模块具有固定和结构化的流程和功能，很少进行增强或升级。'
- en: '*Decomposition by subdomain* uses domain models and their corresponding business
    processes as the basis of the breakdown. Unlike the former, this decomposition
    strategy deals with modules that continuously evolve and change to capture the
    exact structure of the modules.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*按子域分解*使用领域模型及其相应的业务流程作为分解的基础。与前者不同，这种分解策略处理的是持续演变和变化的模块，以捕捉模块的确切结构。'
- en: 'Of the two options, decomposition by business units is the more practical decomposition
    strategy to use for our monolithic University ERP prototype. Since the information
    and business flow used by universities has been part of its foundation for years,
    we need to organize and breakdown its voluminous and compounded operations by
    colleges or departments. *Figure 4.1* shows the derivation of these submodules:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种选择中，按业务单元分解是我们用于单体大学ERP原型的更实用的分解策略。由于大学使用的信息和业务流程已经是其多年的基础，我们需要通过学院或部门对其庞大而复杂的操作进行组织和分解。*图4.1*显示了这些子模块的推导：
- en: '![Figure 4.1 – Decomposition by business units](img/Figure_4.1_B17975.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – 按业务单元分解](img/Figure_4.1_B17975.jpg)'
- en: Figure 4.1 – Decomposition by business units
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 按业务单元分解
- en: 'After determining the submodules, we can implement them as independent microservices
    using the FastAPI framework. We can call an implementation of a business unit
    or module a microservice if its services *can collectively stand as one component*.
    Also, it must be able to *collaborate with other microservices* through *interconnection*
    based on the URL address and port number. *Figure 4.2* shows the project directories
    of the faculty, library, and student management modules implemented as FastAPI
    microservice applications. [*Chapter 1*](B17975_01.xhtml#_idTextAnchor014)*, Setting
    Up FastAPI for Starters,* to [*Chapter 3*](B17975_03.xhtml#_idTextAnchor052)*,*
    *Investigating Dependency Injection*, gave us the foundation to build a FastAPI
    microservice:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 确定子模块后，我们可以使用FastAPI框架将它们实现为独立的微服务。如果一个业务单元或模块的服务*可以作为一个组件整体存在*，那么我们可以将其实现称为微服务。此外，它还必须能够通过基于URL地址和端口号的*互连*与其他微服务*协作*。*图4.2*显示了作为FastAPI微服务应用程序实现的学院、图书馆和学生管理模块的项目目录。[*第1章*](B17975_01.xhtml#_idTextAnchor014)*，为初学者设置FastAPI*，到[*第3章*](B17975_03.xhtml#_idTextAnchor052)*，*调查依赖注入*，为我们构建FastAPI微服务奠定了基础：
- en: '![Figure 4.2 – The faculty, library, and student microservice applications](img/Figure_4.2_B17975.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – 学院、图书馆和学生微服务应用程序](img/Figure_4.2_B17975.jpg)'
- en: Figure 4.2 – The faculty, library, and student microservice applications
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 学院、图书馆和学生微服务应用程序
- en: Each of these microservices is independent of the others in terms of its server
    instance and management. Starting and shutting down one of them will not affect
    the other two, as each can have a different context root and port. Each application
    can have a separate logging mechanism, dependency environment, container, configuration
    file, and any other aspect of a microservice, which will be discussed in the subsequent
    chapters.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器实例和管理方面，这些微服务彼此独立。启动和关闭其中一个不会影响其他两个，因为每个都可以有不同的上下文根和端口。每个应用程序都可以有独立的日志机制、依赖环境、容器、配置文件以及微服务的任何其他方面，这些将在后续章节中讨论。
- en: But FastAPI has another way of designing microservices using a *mount* sub-application.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但FastAPI还有另一种使用*挂载*子应用程序设计微服务的方法。
- en: Creating the sub-applications
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建子应用程序
- en: 'FastAPI allows you to build independent sub-applications inside the *main application*.
    Here, `main.py` serves as a gateway that provides a pathname to these mounted
    applications. It also creates the mounts specifying the context path mapped to
    the FastAPI instance of each sub-application. *Figure 4.3* shows a new university
    ERP implementation that has been built using mounts:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI允许你在*主应用程序*内部构建独立的子应用程序。在这里，`main.py`充当网关，为这些挂载的应用程序提供路径名。它还创建了挂载，指定映射到每个子应用程序FastAPI实例的上下文路径。*图
    4.3*显示了使用挂载构建的新大学ERP实现：
- en: '![Figure 4.3 – The main project with the mounts'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.3 – 带挂载的主项目'
- en: '](img/Figure_4.3_B17975.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.3_B17975.jpg)'
- en: Figure 4.3 – The main project with the mounts
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 带挂载的主项目
- en: 'Here, `faculty_mgt`, `library_mgt`, and `student_mgt` are typical independent
    microservice applications mounted into the `main.py` component, the top-level
    application. Each sub-application has a `main.py` component, such as `library_mgt`,
    which has its FastAPI instance created in its `library_main.py` setup, as shown
    in the following code snippet:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`faculty_mgt`、`library_mgt`和`student_mgt`是典型的独立微服务应用程序，被挂载到`main.py`组件，即顶级应用程序中。每个子应用程序都有一个`main.py`组件，例如`library_mgt`，它在`library_main.py`设置中创建了其FastAPI实例，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The student sub-application has a `student_main.py` setup that creates its
    FastAPI instance, as shown in the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 学生子应用程序有一个`student_main.py`设置，它创建其FastAPI实例，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Likewise, the faculty sub-application also has its `faculty_main.py` setup,
    as highlighted in the following code, for the same purpose, to build the microservice
    architecture:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，教师子应用程序也有其`faculty_main.py`设置，如下面的代码所示，出于相同的目的，构建微服务架构：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These sub-applications are typical FastAPI microservice applications containing
    all of the essential components such as routers, middleware exception handlers,
    and all the necessary packages to build REST API services. The only difference
    from the usual applications is that their context paths or URLs are defined and
    decided by the top-level application that handles them.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些子应用程序是典型的FastAPI微服务应用程序，包含所有基本组件，如路由器、中间件异常处理器以及构建REST API服务所需的所有必要包。与常规应用程序的唯一区别是，它们的上下文路径或URL由处理它们的顶级应用程序定义和决定。
- en: Important note
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Optionally, we can run the `library_mgt` sub-application independently from
    `main.py` through the `uvicorn main:library_app --port 8001` command, `faculty_mgt`
    through `uvicorn main:faculty_app --port 8082`, and `student_mgt` through `uvicorn
    main:student_app --port 8003`. The option of running them independently despite
    the mount explains why these mounted sub-applications are all microservices.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，我们可以通过`uvicorn main:library_app --port 8001`命令独立运行`library_mgt`子应用程序，通过`uvicorn
    main:faculty_app --port 8082`运行`faculty_mgt`，以及通过`uvicorn main:student_app --port
    8003`运行`student_mgt`。尽管它们被挂载，但可以独立运行，这解释了为什么这些挂载的子应用程序都是微服务。
- en: Mounting the submodules
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挂载子模块
- en: 'All the FastAPI decorators of each sub-application must be mounted in the `main.py`
    component of the top-level application for them to be accessed at runtime. The
    `mount()` function is invoked by the FastAPI decorator object of the top-level
    application, which adds all FastAPI instances of the sub-applications into the
    gateway application (`main.py`) and maps each with its corresponding URL context.
    The following script shows how the mounting of the *library*, *student*, and *faculty*
    subsystems is implemented in the `main.py` component of the University ERP top-level
    system:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子应用的所有 FastAPI 装饰器都必须挂载在顶层应用的 `main.py` 组件中，以便在运行时访问。顶层应用的 FastAPI 装饰器对象调用
    `mount()` 函数，将子应用的所有 FastAPI 实例添加到网关应用（`main.py`）中，并将每个实例与其对应的 URL 上下文进行映射。以下脚本展示了在大学
    ERP 顶层系统的 `main.py` 组件中如何实现 *图书馆*、*学生* 和 *教师* 子系统的挂载：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With this setup, the mounted `/ch04/student` URL will be used to access all
    the API services of the *student module* app, `/ch04/faculty` will be used for
    all the services of the *faculty module*, and `/ch04/library` will be used for
    the *library*-related REST services. These mounted paths become valid once they
    are declared in `mount()` because FastAPI automatically handles all of these paths
    through the `root_path` specification.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种设置下，挂载的 `/ch04/student` URL 将用于访问 *学生模块* 应用程序的所有 API 服务，`/ch04/faculty` 将用于
    *教师模块* 的所有服务，而 `/ch04/library` 将用于与 *图书馆* 相关的 REST 服务。一旦在 `mount()` 中声明，这些挂载路径就变得有效，因为
    FastAPI 会自动通过 `root_path` 规范处理所有这些路径。
- en: Since all three sub-applications of our *university ERP system* are independent
    microservices, now let us apply another design strategy that can help manage the
    requests to these applications just by using the main URL of the ERP system. Let
    us utilize the *main application* as a gateway to our sub-applications.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们 *大学 ERP 系统* 的所有三个子应用都是独立的微服务，现在让我们应用另一种设计策略，该策略可以通过使用 ERP 系统的主 URL 来管理对这些应用的请求。让我们利用
    *主应用程序* 作为子应用的网关。
- en: Creating a common gateway
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个公共网关
- en: It will be easier if we use the URL of the main application to manage the requests
    and redirect users to any of the three sub-applications. The *main application*
    can stand as a pseudo-reverse proxy or an entry point for user requests, which
    will always redirect user requests to any of the desired sub-applications. This
    kind of approach is based on a design pattern called *API Gateway*. Now, let us
    explore how we can apply this design to manage independent microservices mounted
    onto the main application using a workaround.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用主应用程序的 URL 来管理请求并将用户重定向到任何三个子应用程序之一，将会更容易。*主应用程序* 可以作为一个伪反向代理或用户请求的入口点，始终将用户请求重定向到任何所需的子应用程序。这种方法基于称为
    *API 网关* 的设计模式。现在，让我们探索如何应用这种设计来管理挂载到主应用程序上的独立微服务，并使用一种变通方法。
- en: Implementing the main endpoint
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现主端点
- en: 'There are so many solutions when it comes to implementing this gateway endpoint,
    and among them is having a simple REST API service in the top-level application
    with an integer path parameter that will identify the `ID` parameter of the microservice.
    If the `ID` parameter is invalid, the endpoint will only return the `{''message'':
    ''University ERP Systems''}` JSON string instead of an error. The following script
    is a straightforward implementation of this endpoint:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '在实现此网关端点时，有如此多的解决方案，其中之一是在顶层应用程序中有一个简单的 REST API 服务，该服务具有一个整数路径参数，用于识别微服务的
    `ID` 参数。如果 `ID` 参数无效，端点将只返回 `{''message'': ''University ERP Systems''}` JSON 字符串，而不是错误。以下脚本是这个端点的直接实现：'
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `access_portal` API endpoint is created as a GET path operation with `portal_id`
    as its path parameter. The `portal_id` parameter is essential to this process
    because it will determine which among the *Student*, *Faculty*, and *Library*
    microservices the user wants to access. Therefore, accessing the `/ch04/university/1`
    URL should lead the user to the student application, `/ch04/university/2` to the
    faculty microservice, and `/ch04/university/3` to the library application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`access_portal` API 端点是作为一个带有 `portal_id` 作为路径参数的 GET 路径操作创建的。`portal_id` 参数对于此过程至关重要，因为它将确定用户想要访问的
    *学生*、*教师* 和 *图书馆* 微服务中的哪一个。因此，访问 `/ch04/university/1` URL 应该将用户引导到学生应用程序，`/ch04/university/2`
    到教师微服务，而 `/ch04/university/3` 到图书馆应用程序。'
- en: Evaluating the microservice ID
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估微服务 ID
- en: 'The `portal_id` parameter will automatically be fetched and evaluated using
    a dependable function that is injected into the `APIRouter` instance where the
    API endpoint is implemented. As discussed in [*Chapter 3*](B17975_03.xhtml#_idTextAnchor052),
    *Investigating Dependency Injection*, a *dependable function* or *object* can
    serve as a filter or validator of all incoming requests of any services once injected
    into an `APIRouter` or `FastAPI` instance. The dependable function used in this
    ERP prototype, as shown in the following script, evaluates whether the `portal_id`
    parameter is `1`, `2`, or `3` only:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`portal_id` 参数将自动使用一个可信赖的函数获取并评估，该函数被注入到实现 API 端点的 `APIRouter` 实例中。正如在 [*第
    3 章*](B17975_03.xhtml#_idTextAnchor052)，*调查依赖注入* 中所讨论的，一个 *可信赖的函数* 或 *对象* 可以在注入到
    `APIRouter` 或 `FastAPI` 实例后作为所有服务的所有传入请求的过滤器或验证器。在以下脚本中，这个 ERP 原型中使用的可信赖函数评估 `portal_id`
    参数是否为 `1`、`2` 或 `3`：'
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The given solution is a feasible workaround to trigger a custom event since
    FastAPI has no built-in event handling except for the startup and shutdown event
    handlers, which are topics in [*Chapter 8*](B17975_08.xhtml#_idTextAnchor229),
    *Creating Coroutines, Events, and Message-Driven Transactions*. So, once `call_api_gateway()`
    finds `portal_id` to be a valid microservice ID, it will raise some custom exceptions.
    It will throw `RedirectStudentPortalException` if the user wants to access the
    *Student* microservice. On the other hand, the `RedirectFacultyPortalException`
    error will be raised if the user desires the *Faculty* microservice. Otherwise,
    the `RedirectLibraryPortalException` error will be triggered when the *Library*
    microservice is the one wanted by the user. But first, we need to inject `call_api_gateway()`
    into the `APIRouter` instance handling the gateway endpoint through the `main.py`
    component of the top-level ERP application. The following script shows you how
    it is injected into `university.router` using the concepts discussed earlier:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的解决方案是一个可行的解决方案，用于触发自定义事件，因为 FastAPI 除了启动和关闭事件处理器外没有内置的事件处理功能，这些是 [*第 8 章*](B17975_08.xhtml#_idTextAnchor229)，*创建协程、事件和消息驱动事务*
    的主题。因此，一旦 `call_api_gateway()` 发现 `portal_id` 是一个有效的微服务 ID，它将引发一些自定义异常。如果用户想要访问
    *Student* 微服务，它将抛出 `RedirectStudentPortalException`。另一方面，如果用户想要 *Faculty* 微服务，将引发
    `RedirectFacultyPortalException` 错误。否则，当用户想要 *Library* 微服务时，将触发 `RedirectLibraryPortalException`
    错误。但首先，我们需要通过顶级 ERP 应用程序的 `main.py` 组件将 `call_api_gateway()` 注入到处理网关端点的 `APIRouter`
    实例中。以下脚本展示了如何使用前面讨论的概念将其注入到 `university.router` 中：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: All of these raised exceptions require an exception handler that will listen
    to the throws and execute some of the tasks required to pursue the microservices.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些引发的异常都需要一个异常处理器来监听抛出并执行追求微服务所需的某些任务。
- en: Applying the exception handlers
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用异常处理器
- en: 'The exception handler does a redirection to the appropriate microservice. As
    you learned in [*Chapter 2*](B17975_02.xhtml#_idTextAnchor033), *Exploring the
    Core Features*, each thrown exception must have its corresponding exception handler
    to pursue the required response after the exception handling. Here are the exception
    handlers that will handle the custom exception thrown by `call_api_gateway()`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理器将重定向到适当的微服务。正如你在 [*第 2 章*](B17975_02.xhtml#_idTextAnchor033)，*探索核心功能* 中所学到的，每个抛出的异常都必须有一个相应的异常处理器，在异常处理之后追求所需响应。以下是处理
    `call_api_gateway()` 抛出的自定义异常的异常处理器：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, `exception_handler_student()` will redirect the user to the mount path
    of the *Student* microservice, while `exception_handler_faculty()` will redirect
    the user to the *Faculty* sub-application. Additionally, `exception_handler_library()`
    will let the user access the *Library* microservice. Exception handlers are the
    last component needed to complete the API Gateway architecture. The exceptions
    trigger the redirection to the independent microservices mounted on the FastAPI
    framework.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`exception_handler_student()` 将将用户重定向到 *Student* 微服务的挂载路径，而 `exception_handler_faculty()`
    将将用户重定向到 *Faculty* 子应用。此外，`exception_handler_library()` 将允许用户访问 *Library* 微服务。异常处理器是完成
    API 网关架构所需的最后一个组件。异常触发将用户重定向到安装在 FastAPI 框架上的独立微服务。
- en: Although there are other, better solutions to achieve the gateway architecture,
    our approach is still procedural and pragmatic without having to resort to external
    modules and tools, just the core components of FastAPI. [*Chapter 11*](B17975_11.xhtml#_idTextAnchor321),
    *Adding Other Microservices Features*, will discuss establishing an effective
    API Gateway architecture using Docker and NGINX.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有其他更好的解决方案来实现网关架构，但我们的方法仍然是通过不依赖外部模块和工具，仅使用FastAPI的核心组件来进行程序化和实用。[*第11章*](B17975_11.xhtml#_idTextAnchor321)，*添加其他微服务功能*，将讨论使用Docker和NGINX建立有效的API网关架构。
- en: Now, let us explore how to set up a centralized logging mechanism for this kind
    of microservices setup.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索如何为这种微服务设置设置集中式日志机制。
- en: Centralizing the logging mechanism
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集中式日志机制
- en: We have created an audit trail mechanism with middleware and Python file transactions
    in [*Chapter 2*](B17975_02.xhtml#_idTextAnchor033), *Exploring the Core Features*.
    We have found out that middleware, which can only be set up through the FastAPI
    decorator of the top-level application, can manage incoming Request and outgoing
    Response of any API services. This time, we will be using custom middleware to
    set up a centralized logging feature that will log all service transactions of
    the top-level application alongside its independent mounted microservices. Of
    the many approaches for integrating these logging concerns into the application
    without changing the API services, we will concentrate on the following pragmatic
    custom approach with the custom middleware and *Loguru* module.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第2章*](B17975_02.xhtml#_idTextAnchor033)，*探索核心功能*中创建了一个审计跟踪机制，使用了中间件和Python文件事务。我们发现，中间件只能通过顶级应用程序的FastAPI装饰器来设置，它可以管理任何API服务的传入请求和传出响应。这次，我们将使用自定义中间件来设置一个集中式日志功能，该功能将记录顶级应用程序及其独立挂载的微服务的所有服务事务。在许多将日志关注点集成到应用程序中而不更改API服务的方法中，我们将专注于以下具有自定义中间件和*Loguru*模块的实用自定义方法。
- en: Utilizing the Loguru module
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用Loguru模块
- en: An *application log* is essential to any enterprise-grade application. For monolithic
    applications deployed in a single server, logging means letting service transactions
    write their log messages to a single file. On the other hand, logging can be too
    complex and complicated to implement in an independent microservices setup, especially
    when these services are for deployment to different servers or Docker containers.
    Its logging mechanism could even cause runtime problems if the module used is
    not adaptable to asynchronous services.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*应用程序日志*对于任何企业级应用都是必不可少的。对于部署在单个服务器上的单体应用，日志意味着让服务事务将它们的日志消息写入单个文件。另一方面，在独立的微服务设置中，日志可能过于复杂和难以实现，尤其是在这些服务需要部署到不同的服务器或Docker容器时。如果使用的模块不适应异步服务，其日志机制甚至可能导致运行时问题。'
- en: 'For FastAPI instances that support both asynchronous and synchronous API services
    that run on an ASGI server, using Python’s logging module always generates the
    following error log:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于同时支持异步和同步API服务且运行在ASGI服务器上的FastAPI实例，使用Python的日志模块总是会生成以下错误日志：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Opting for another logging extension is the only solution to avoid the error
    generated by the `logging` module. The best option is one that can fully support
    the FastAPI framework, which is the `loguru` extension. But first, we need to
    install it using the `pip` command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 选择另一个日志扩展是避免由`logging`模块生成的错误的唯一解决方案。最佳选择是能够完全支持FastAPI框架的扩展，即`loguru`扩展。但首先，我们需要使用`pip`命令安装它：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Loguru is a straightforward and easy-to-use logging extension. We can immediately
    log using its default handler, the `sys.stderr` handler, even without adding much
    configurations. Since our application needs to place all messages in a log file,
    we need to add the following lines to the `main.py` component of the top-level
    application right after the instantiation of `FastAPI`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Loguru是一个简单易用的日志扩展。我们可以立即使用其默认处理器，即`sys.stderr`处理器进行日志记录，甚至无需添加太多配置。由于我们的应用程序需要将所有消息放置在日志文件中，我们需要在顶级应用程序的`main.py`组件中`FastAPI`实例化之后添加以下行：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that its `logger` instance has an `add()` method where we can register
    *sinks*. The first part of the *sinks* is the *handler* that decides whether to
    emit the logs in `sys.stdout` or the file. In our university ERP prototype, we
    need to have a global `info.log` file that contains all the log messages of the
    sub-applications.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，它的`logger`实例有一个`add()`方法，我们可以在这里注册*sinks*。*sinks*的第一部分是*handler*，它决定是否在`sys.stdout`或文件中输出日志。在我们大学的ERP原型中，我们需要有一个全局的`info.log`文件，其中包含所有子应用程序的日志消息。
- en: A crucial part of the log sink is the `level` type, which indicates the granularity
    of log messages that need to be managed and logged. If we set the `level` parameter
    of `add()` to `INFO`, it tells the logger to consider only those messages under
    the `INFO`, `SUCCESS`, `WARNING`, `ERROR`, and `CRITICAL` weights. The logger
    will bypass log messages outside these levels.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 日志汇聚器的一个重要部分是`level`类型，它表示需要管理和记录的日志消息的粒度。如果我们将`add()`函数的`level`参数设置为`INFO`，这告诉记录器只考虑那些在`INFO`、`SUCCESS`、`WARNING`、`ERROR`和`CRITICAL`权重下的消息。记录器将跳过这些级别之外的日志消息。
- en: Another part of the *sinks* is the `format` log, where we can create a custom
    log message layout to replace its default format. This format is just like a Python
    interpolated string without the *"f"* that contains placeholders such as `{time}`,
    `{level}`, `{message}`, and any custom placeholders that need to be replaced by
    `logger` at runtime.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*sinks*的另一部分是`format`日志，我们可以创建一个自定义的日志消息布局来替换其默认格式。这个格式就像一个没有`"f"`的Python插值字符串，其中包含占位符，如`{time}`、`{level}`、`{message}`以及任何需要在运行时由`logger`替换的自定义占位符。'
- en: In `log.file`, we want our logs to start with the `Log` keyword followed immediately
    by the custom-generated `log_id` parameter and then the time the logging happened,
    the level, and the message.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在`log.file`中，我们希望我们的日志以`Log`关键字开头，紧接着是自定义生成的`log_id`参数，然后是记录日志的时间、级别和消息。
- en: And to add support for asynchronous logging, the `add()` function has an `enqueue`
    parameter that we can enable anytime. In our case, this parameter is default to
    `True` just to prepare for any `async/await` execution.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加对异步日志的支持，`add()`函数有一个`enqueue`参数，我们可以在任何时候启用它。在我们的情况下，这个参数默认为`True`，只是为了准备任何`async/await`执行。
- en: There is a lot to explore with Loguru’s features and functionality. For instance,
    we can create additional handlers for loggers to emit where each of these handlers
    has different retention, rotation, and rendition types. Additionally, Loguru can
    allow us to add colors to our logs through some color markups such as `<red>`,
    `<blue>`, or `<cyan>`. It also has an `@catch()` decorator that can be applied
    to manage exceptions at runtime. All the logging features we need to set up our
    unified application log are in Loguru. Now that we have configured our Loguru
    in the top-level application, we need to let its logging mechanism work across
    the three sub-applications or microservices without modifying their code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Loguru的功能和特性有很多可以探索。例如，我们可以为记录器创建额外的处理程序，每个处理程序都有不同的保留、轮换和渲染类型。此外，Loguru还可以通过一些颜色标记，如`<red>`、`<blue>`或`<cyan>`，为我们添加颜色。它还有一个`@catch()`装饰器，可以在运行时管理异常。我们设置统一应用程序日志所需的所有日志功能都在Loguru中。现在我们已经配置了顶层应用程序中的Loguru，我们需要让它的日志机制在没有修改代码的情况下跨三个子应用程序或微服务工作。
- en: Building the logging middleware
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建日志中间件
- en: 'The core component of this centralized application log is the custom middleware
    that we must implement in the `main.py` component where we set up Loguru. FastAPI’s
    *mount* allows us to centralize some cross-cutting concerns such as logging without
    adding anything to the sub-applications. One middleware implementation in the
    `main.py` component of the top-level application is good enough to pursue logging
    across the independent microservices. The following is the middleware implementation
    for our specimen application:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个集中式应用程序日志的核心组件是我们必须在`main.py`组件中实现的自定义中间件。FastAPI的`*mount*`允许我们集中处理一些横切关注点，如日志，而不需要在子应用程序中添加任何内容。顶层应用程序的`main.py`组件中的一个中间件实现就足够了，可以用于跨独立的微服务进行日志记录。以下是我们示例应用程序的中间件实现：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'First, `log_middleware()` will generate a `log_id` parameter every time it
    intercepts any API services from the main app or the sub-applications. Then, the
    `log_id` parameter is injected into the `dict` of context information through
    Loguru’s `contextualize()` method since `log_id` is part of the log information,
    as indicated in our log format setup. Afterward, logging starts before the API
    service is executed and after its successful execution. When exceptions are encountered
    during the process, the logger will still generate a log message with the `Exception`
    message. So, whenever we access any API services anywhere from the ERP prototype,
    the following log messages will be written in `info.log`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`log_middleware()`每次拦截来自主应用或子应用的任何API服务时，都会生成一个`log_id`参数。然后，通过Loguru的`contextualize()`方法将`log_id`参数注入到上下文信息的`dict`中，因为`log_id`是日志信息的一部分，正如我们在日志格式设置中所示。之后，在API服务执行之前和执行成功之后开始记录日志。如果在过程中遇到异常，记录器仍然会生成带有`Exception`消息的日志消息。因此，无论何时我们从ERP原型访问任何API服务，以下日志消息都将写入`info.log`：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The given snapshot of log messages proves that we have a centralized setup because
    the middleware filters all API service execution and performs the logging transaction.
    It shows that the logging started from accessing the gateway down to executing
    the API services from the *faculty*, *student*, and *l**ibrary* sub-applications.
    Centralizing and managing cross-cutting concerns is one advantage that can be
    provided by using FastAPI’s *mounting* when building independent microservices.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的日志消息快照证明我们有一个集中式设置，因为中间件过滤了所有API服务的执行并执行了日志事务。它显示日志从访问网关开始，一直延伸到执行来自*教师*、*学生*和*图书馆*子应用的API服务。使用FastAPI的*挂载*功能构建独立微服务时，集中和管理横切关注点是它可以提供的一个优势。
- en: But when it comes to the interactions among these independent sub-applications,
    can mounting also be an advantage? Now, let us explore how independent microservices
    in our architecture can communicate by utilizing each other’s API resources.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当涉及到这些独立子应用之间的交互时，挂载是否也能成为优势？现在，让我们探索在我们的架构中，独立的微服务如何通过利用彼此的API资源进行通信。
- en: Consuming the REST API services
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消费REST API服务
- en: Just like in an unmounted microservices setup, mounted ones can also communicate
    by accessing each other’s API services. For instance, if a faculty member or student
    wants to borrow a book from the library, how can that setup be implemented seamlessly?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在未挂载的微服务设置中一样，挂载的微服务也可以通过访问彼此的API服务进行通信。例如，如果一位教师或学生想要从图书馆借书，如何无缝地实现这种设置？
- en: 'In *Figure 4.4*, we can see that interactions can be possible by establishing
    a client-server communication wherein one API service can serve as a resource
    provider, and the others are the clients:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图4.4*中，我们可以看到，通过建立客户端-服务器通信，可以实现交互，其中一个API服务可以作为资源提供者，而其他的是客户端：
- en: '![Figure 4.4 – Interaction with the faculty, student, and library microservices'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4 – 与教师、学生和图书馆微服务的交互'
- en: '](img/Figure_4.4_B17975.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4 – 与教师、学生和图书馆微服务的交互'
- en: Figure 4.4 – Interaction with the faculty, student, and library microservices
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – 与教师、学生和图书馆微服务的交互
- en: Consuming API resources in FastAPI can be straightforward using the `httpx`
    and `requests` external modules. The following discussions will focus on how these
    two modules can help our mounted services interact with each other.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在FastAPI中，使用`httpx`和`requests`外部模块消费API资源可以非常直接。以下讨论将重点介绍这两个模块如何帮助我们挂载的服务相互交互。
- en: Using the httpx module
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用httpx模块
- en: 'The `httpx` external module is a Python extension that can consume both asynchronous
    and synchronous REST APIs and has *HTTP/1.1* and *HTTP/2* support. It is a fast
    and multi-purpose toolkit that is used to access API services running on WSGI-based
    platforms, as well as, on ASGI, like the FastAPI services. But first, we need
    to install it using `pip`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`httpx`外部模块是一个Python扩展，可以消费异步和同步的REST API，并支持*HTTP/1.1*和*HTTP/2*。它是一个快速的多功能工具包，用于访问运行在基于WSGI平台上的API服务，以及像FastAPI服务这样的ASGI。但首先，我们需要使用`pip`安装它：'
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we can use it directly without further configuration to make two microservices
    interact, for instance, our *student* module submitting assignments to the *faculty*
    module:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以直接使用它，无需进一步配置，以使两个微服务交互，例如，我们的*学生*模块向*教师*模块提交作业：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `httpx` module can process the `GET`, `POST`, `PATCH`, `PUT`, and `DELETE`
    path operations. It can allow the passing of different request parameters to the
    requested API without so much complexity. The `post()` client operation, for instance,
    can accept headers, cookies, params, json, files, and model data as parameter
    values. We use the `with` context manager to directly manage the streams created
    by its `Client()` or `AsyncClient()` instances, which are closeable components.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`httpx` 模块可以处理 `GET`、`POST`、`PATCH`、`PUT` 和 `DELETE` 路径操作。它可以允许在不那么复杂的条件下向请求的
    API 传递不同的请求参数。例如，`post()` 客户端操作可以接受头信息、cookies、params、json、files 和模型数据作为参数值。我们使用
    `with` 上下文管理器直接管理由其 `Client()` 或 `AsyncClient()` 实例创建的流，这些流是可关闭的组件。'
- en: The preceding `list_assignments` service is a client that uses the `AsyncClient()`
    instance to pursue its GET request from an asynchronous `/ch04/faculty/assignments/list`
    API endpoint from the f*aculty* module. `AsyncClient` accesses the WSGI-based
    platform to execute any asynchronous services, not the synchronous ones, or else
    it will throw *Status Code 500*. It might require additional configuration details
    in its constructor for some complex cases, where it needs to further manage resource
    access through ASGI.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的 `list_assignments` 服务是一个客户端，它使用 `AsyncClient()` 实例从 `f*aculty*` 模块的异步
    `/ch04/faculty/assignments/list` API 端点发起 GET 请求。`AsyncClient` 访问基于 WSGI 的平台以执行任何异步服务，而不是同步服务，否则会抛出
    *状态码 500*。在某些复杂情况下，它可能需要在构造函数中提供额外的配置细节，以便进一步通过 ASGI 管理资源访问。
- en: On the other hand, the `submit_assignment` service is a synchronous client that
    accesses another synchronous endpoint, `ch04/faculty/assignments/student/submit`,
    which is a `POST` HTTP operation. In this case, the `Client()` instance is used
    to access the resource to submit an assignment to the *Faculty* module through
    a `POST` request. `AssignmentRequest` is a `BaseModel` object that needs to be
    filled up by the client for submission to the request endpoint. Unlike `params`
    and `json`, which are passed straightforwardly as `dict`, `data` is a model object
    that must be first converted into `dict` by `jsonable_encoder()` and `json.dumps()`
    to make the transport feasible across the HTTP. The new converted model becomes
    the argument value of the `data` parameter of the POST client operation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`submit_assignment` 服务是一个同步客户端，它访问另一个同步端点 `ch04/faculty/assignments/student/submit`，这是一个
    `POST` HTTP 操作。在这种情况下，使用 `Client()` 实例通过 `POST` 请求访问资源，将作业提交给 `*Faculty*` 模块。`AssignmentRequest`
    是一个 `BaseModel` 对象，客户端需要将其填充后提交到请求端点。与 `params` 和 `json` 不同，它们直接作为 `dict` 传递，而
    `data` 是一个模型对象，必须首先通过 `jsonable_encoder()` 和 `json.dumps()` 转换为 `dict`，以便在 HTTP
    上传输。新的转换后的模型成为 POST 客户端操作 `data` 参数的值。
- en: When it comes to the response of the client services, we can allow the response
    to be treated as a piece of text using the module’s `content` or as a JSON result
    using `json()`. It now depends on the requirement of the client service as to
    what response type to use for the application.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到客户端服务的响应时，我们可以允许响应被模块的 `content` 或 `json()` 处理为文本，或者作为 JSON 结果。现在这取决于客户端服务的需求，决定应用程序使用哪种响应类型。
- en: Using the requests module
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `requests` 模块
- en: 'Another option to establish client-server communication among microservices
    is the `requests` module. Although `httpx` and `requests` are almost compatible,
    the latter offers other features such as auto-redirection and explicit session
    handling. The only problem with `requests` is its non-direct support to asynchronous
    APIs and its slow performance when accessing resources. Despite its drawbacks,
    the `requests` module is still the standard way of consuming REST APIs in Python
    microservice development. First, we need to install it before we can use it:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务之间建立客户端-服务器通信的另一种选择是 `requests` 模块。尽管 `httpx` 和 `requests` 几乎兼容，但后者提供了其他功能，如自动重定向和显式会话处理。`requests`
    的唯一问题是它不支持异步 API，并且在访问资源时性能较慢。尽管有其缺点，`requests` 模块仍然是 Python 微服务开发中消费 REST API
    的标准方式。首先，我们需要安装它才能使用它：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In our ERP prototype, the `requests` extension was used by the *faculty* microservice
    to borrow books from the *library* module. Let’s look at the *Faculty* client
    services that show us how the `requests` module is used to access the synchronous
    API of *library*:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 ERP 原型中，`*faculty*` 微服务使用了 `requests` 扩展从 `*library*` 模块借书。让我们看看 `*Faculty*`
    客户端服务，它们展示了如何使用 `requests` 模块访问 `*library*` 的同步 API：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `requests` module has a `Session()` instance, which is equivalent to `Client()`
    in the `httpx` module. It provides all the necessary client operations that will
    consume the API endpoints from the FastAPI platform. Since `Session` is a closeable
    object, the context manager is, again, used here to handle the streams that will
    be utilized during the access of the resources and transport of some parameter
    values. Like in `httpx`, parameter details such as `params`, `json`, `header`,
    `cookies`, `files`, and `data` are also part of the `requests` module and are
    ready for transport through the client operation if needed by the API endpoints.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`requests` 模块有一个 `Session()` 实例，这在 `httpx` 模块中相当于 `Client()`。它提供了所有必要的客户端操作，这些操作将消耗
    FastAPI 平台上的 API 端点。由于 `Session` 是一个可关闭的对象，因此上下文管理器再次被用于处理在访问资源和传输某些参数值时将使用的流。就像在
    `httpx` 中一样，参数细节，如 `params`、`json`、`header`、`cookies`、`files` 和 `data`，也是 `requests`
    模块的一部分，并且如果需要通过客户端操作通过 API 端点传输，它们就准备好了。'
- en: From the preceding code, we can see that sessions are created to implement the
    `list_all_request` and `list_all_issuance` `GET` client services. Here, `request_borrow_book`
    is a `POST` client service that requests a book in the form of `BookRequestReq`
    from the `/ch04/library/book/request` API endpoint. Similar to `httpx`, `jsonable_encoder()`
    and `json.dumps()` must be used to convert the `BaseModel` object into `dict`
    in order to be transported as a `data` parameter value. The same approach is also
    applied to the `return_book` `POST` client service, which returns the book borrowed
    by the faculty. The responses of these client services can also be `content` or
    `json()` just like what we have in the `httpx` extension.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到创建了会话以实现 `list_all_request` 和 `list_all_issuance` 的 `GET` 客户端服务。在这里，`request_borrow_book`
    是一个 `POST` 客户端服务，它从 `/ch04/library/book/request` API 端点以 `BookRequestReq` 的形式请求一本书。类似于
    `httpx`，必须使用 `jsonable_encoder()` 和 `json.dumps()` 将 `BaseModel` 对象转换为 `dict`，以便作为
    `data` 参数值传输。同样的方法也应用于 `return_book` 的 `POST` 客户端服务，该服务返回由教师借阅的书籍。这些客户端服务的响应也可以是
    `content` 或 `json()`，就像我们在 `httpx` 扩展中看到的那样。
- en: Using the `requests` and `httpx` modules allows these mounted microservices
    to interact with each other based on some specification. Consuming exposed endpoints
    from other microservices minimizes tight coupling and strengthens the importance
    of the decomposition design pattern of building independent microservices.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `requests` 和 `httpx` 模块允许这些挂载的微服务根据某些规范相互交互。从其他微服务中消费公开的端点可以最小化紧密耦合并加强构建独立微服务的分解设计模式的重要性。
- en: The next technique gives you the option of managing components within a microservice
    using *domain modeling*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个技术为您提供使用 *领域建模* 管理微服务内组件的选项。
- en: Applying the domain modeling approach
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用领域建模方法
- en: Applications that are database-focused or built from core functionalities without
    collaborating with models are either not easy to manage when they scale up or
    not friendly when enhanced or bug-fixed. The reason behind this is the absence
    of the structure and flow of business logic to follow, study, and analyze. Understanding
    the behavior of an application and deriving the domain models with the business
    logic behind them encompasses the best approach when it comes to establishing
    and organizing a structure in an application. This principle is called the *domain
    modeling approach*, which we will now apply to our ERP specimen.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 专注于数据库的应用或由核心功能构建而不与模型协作的应用，在扩展时可能难以管理，或者在增强或修复错误时不够友好。背后的原因是缺乏遵循、研究和分析的业务逻辑结构和流程。理解应用程序的行为并推导出具有其背后业务逻辑的领域模型，在建立和组织应用程序结构时是最佳方法。这个原则被称为
    *领域建模方法*，我们现在将将其应用于我们的 ERP 示例。
- en: Creating the layers
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建层
- en: 'Layering is one implementation that is inevitable when applying domain-driven
    development. There is a dependency between *layers* that, sometimes, might pose
    problems when fixing bugs during development. But what are important in layered
    architectures are the concepts, structures, categories, functionalities, and roles
    that *layering* can create, which helps in understanding the specification of
    the application. *Figure 4.5* shows the *models*, *repositories*, *services*,
    and *controllers* of the sub-applications:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 分层是应用领域驱动开发时不可避免的一种实现方式。*层*之间存在依赖关系，有时在开发过程中修复错误时可能会带来问题。但在分层架构中重要的是*分层*可以创建的概念、结构、类别、功能以及角色，这有助于理解应用程序的规范。*图4.5*显示了子应用程序的*模型*、*存储库*、*服务*和*控制器*：
- en: '![Figure 4.5 – Layered architecture'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.5 – 分层架构'
- en: '](img/Figure_4.5_B17975.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.5_B17975.jpg)'
- en: Figure 4.5 – Layered architecture
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – 分层架构
- en: The most crucial layer is the `models` layer, which consists of the domain model
    classes that describe the domain and business processes involved in the application.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最关键的一层是`models`层，它由描述应用程序中涉及的领域和业务流程的领域模型类组成。
- en: Identifying the domain models
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别领域模型
- en: The *domain model layer* is the initial artifact of the application because
    it provides the contextual framework of the application. Business processes and
    transactions can be easily classified and managed if domains are first determined
    during the initial phase of the development. The code organization created by
    domain layering can provide code traceability, which can ease source code updates
    and debugging.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*领域模型层*是应用程序的初始工件，因为它提供了应用程序的上下文框架。如果在开发的初始阶段首先确定了领域，则可以轻松地对业务流程和交易进行分类和管理。由领域分层创建的代码组织可以提供代码可追溯性，这可以简化源代码更新和调试。'
- en: 'In our ERP specimen, these models are categorized into two: the *data* and
    *request* models. The data models are those used to capture and store data in
    its temporary data stores, while the request models are the `BaseModel` objects
    used in the API services.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的ERP示例中，这些模型分为两类：*数据*模型和*请求*模型。数据模型是用于在临时数据存储中捕获和存储数据的模型，而请求模型是API服务中使用的`BaseModel`对象。
- en: 'For instance, the *faculty* module has the following data models:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*教师*模块有以下数据模型：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: These data model classes always have their constructors implemented if constructor
    injection is needed during instantiation. Moreover, the `__repr__()` and `__str__()`
    dunder methods are optionally there to provide efficiency for developers when
    accessing, reading, and logging these objects.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据模型类在实例化时如果需要构造函数注入，其构造函数总是已实现。此外，`__repr__()`和`__str__()`魔术方法可选地存在，以提供开发者在访问、读取和记录这些对象时的效率。
- en: 'On the other hand, the request models are familiar because they were already
    discussed in the previous chapter. Additionally, the *faculty* module has the
    following request models:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，请求模型是熟悉的，因为它们已经在上一章中讨论过了。此外，*教师*模块还有以下请求模型：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The request models listed in the preceding snippet are just simple `BaseModel`
    types. For further details on how to create `BaseModel` classes, [*Chapter 1*](B17975_01.xhtml#_idTextAnchor014),
    *Setting Up FastAPI for Starters*, provides guidelines for creating different
    kinds of `BaseModel` classes to capture different requests from clients.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 前面片段中列出的请求模型只是简单的`BaseModel`类型。有关如何创建`BaseModel`类的更多详细信息，请参阅[*第1章*](B17975_01.xhtml#_idTextAnchor014)，*为初学者设置FastAPI*，它提供了创建不同类型的`BaseModel`类的指南，以捕获来自客户端的不同请求。
- en: Building the repository and service layers
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建存储库和服务层
- en: 'The two most popular domain modeling patterns that are crucial in building
    the layers of this approach are the *repository* and *service layer patterns*.
    The repository aims to create strategies for managing data access. Some repository
    layers only provide data connectivity to the data store like in our specimen here,
    but oftentimes, repository''s goal is to interact with the **Object Relational
    Model** (**ORM**) framework to optimize and manage data transactions. But aside
    from the access, this layer provides a high-level abstraction for the application
    so that the specific database technology or *dialect* used will not matter to
    the applications. It serves as an adapter to any database platform to pursue data
    transactions for the application, nothing else. The following is a repository
    class of the *faculty* module, which manages the domain for creating assignments
    for their students:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建这种方法的层级结构中至关重要的两个最流行的领域建模模式是 *仓库* 和 *服务层模式*。仓库旨在创建管理数据访问的策略。一些仓库层仅提供数据存储的数据连接，就像我们这里的示例一样，但通常，仓库的目标是与
    **对象关系模型**（**ORM**）框架交互以优化和管理数据事务。但除了访问之外，这一层还为应用程序提供了一个高级抽象，使得特定的数据库技术或 *方言*
    对应用程序来说并不重要。它充当任何数据库平台的适配器，以追求应用程序的数据事务，仅此而已。以下是一个 *教师* 模块的仓库类，它管理为他们的学生创建作业的领域：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, `AssignmentRepository` manages the `Assignment` domain object using its
    four repository transactions. Additionally, `insert_assignment()` creates a new
    `Assignment` entry in the `faculty_assignment_tbl` dictionary, and `update_assignment()`
    accepts new details or the corrected information of an existing assignment and
    updates it. On the other hand, `delete_assignment()` deletes an existing `Assignment`
    entry from the data store using its `assign_id` parameter. To retrieve all the
    created assignments, the repository class has `get_all_assignment()`, which returns
    all the entries of `faculty_assignments_tbl`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`AssignmentRepository` 使用其四个仓库事务管理 `Assignment` 领域对象。此外，`insert_assignment()`
    在 `faculty_assignment_tbl` 字典中创建一个新的 `Assignment` 条目，而 `update_assignment()` 接受现有作业的新细节或更正信息并更新它。另一方面，`delete_assignment()`
    使用其 `assign_id` 参数从数据存储中删除现有的 `Assignment` 条目。为了检索所有创建的作业，仓库类有 `get_all_assignment()`，它返回
    `faculty_assignments_tbl` 中的所有条目。
- en: 'The service layer pattern defines the algorithms, operations, and process flows
    of the applications. Oftentimes, it interacts with the repository to build the
    necessary business logic, management, and controls for the other components of
    the application, such as the API services or controllers. Usually, one service
    caters to one repository class or more depending on the specification of the project.
    The following code snippet is a service that interfaces a repository to provide
    additional tasks such as UUID generation for a student workbin:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 服务层模式定义了应用程序的算法、操作和流程。通常，它与仓库交互以构建应用程序其他组件（如API服务或控制器）所需的基本业务逻辑、管理和控制。通常，一个服务针对一个或多个仓库类，具体取决于项目的具体要求。以下是一个服务示例，它通过接口仓库提供额外的任务，例如为学生工作区生成UUID：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `AssignmentSubmissionService` cited in the preceding code has methods that
    utilize the `AssignmentSubmissionRepository` transactions. It provides them with
    parameters and returns the `bool` results for evaluation by other components.
    Other services might look more complicated than this sample because algorithms
    and tasks are usually added to pursue the requirements of the layers.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中引用的 `AssignmentSubmissionService` 有使用 `AssignmentSubmissionRepository`
    事务的方法。它为它们提供参数，并返回 `bool` 结果供其他组件评估。其他服务可能比这个示例更复杂，因为算法和任务通常被添加以满足层的要求。
- en: The successful wiring of a repository class to the service happens in the latter’s
    constructor. Usually, the repository class is instantiated just like in the preceding
    sample. Another fantastic option is to use DI, as discussed in [*Chapter 3*](B17975_03.xhtml#_idTextAnchor052).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库类与服务之间的成功连接发生在后者的构造函数中。通常，仓库类就像在先前的示例中那样被实例化。另一个绝佳的选择是使用前面讨论的 DI（依赖注入），见 [*第3章*](B17975_03.xhtml#_idTextAnchor052)。
- en: Using the factory method pattern
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用工厂方法模式
- en: The *factory method design pattern* is always a good approach for managing injectable
    classes and functions using the `Depends()` component. [*Chapter 3*](B17975_03.xhtml#_idTextAnchor052)
    showcased factory methods as mediums to inject the repository components into
    the service instead of instantiating them directly within the service. The design
    pattern provides loose coupling between components or layers. This approach is
    highly applicable to large applications wherein some modules and sub-components
    are reused and inherited.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*工厂方法设计模式*始终是使用`Depends()`组件管理可注入类和函数的一个好方法。[*第3章*](B17975_03.xhtml#_idTextAnchor052)展示了如何将工厂方法作为将存储库组件注入服务的中介，而不是直接在服务内部实例化它们。这种设计模式提供了组件或层之间的松耦合。这种方法非常适合大型应用程序，其中一些模块和子组件被重用和继承。'
- en: Now, let us look at how the top-level application can manage the different configuration
    details of these mounted and independent microservice applications.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看顶级应用程序如何管理这些挂载的和独立的微服务应用程序的不同配置细节。
- en: Managing a microservice’s configuration details
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理微服务的配置细节
- en: 'So far, this chapter has provided us with some popular design patterns and
    strategies that can give us a kickstart on how to provide our FastAPI microservices
    with the best structures and architecture. This time, let us explore how the FastAPI
    framework supports storing, assigning, and reading configuration details to mounted
    microservice applications such as database credentials, networking configuration
    data, application server information, and deployment details. First, we need to
    install `python-dotenv` using `pip`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章为我们提供了一些流行的设计模式和策略，这些模式和策略可以帮助我们了解如何为我们的FastAPI微服务提供最佳的结构和架构。这次，让我们探索FastAPI框架如何支持将存储、分配和读取配置细节到挂载的微服务应用程序中，例如数据库凭证、网络配置数据、应用程序服务器信息和部署细节。首先，我们需要使用`pip`安装`python-dotenv`：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: All of these settings are values that are external to the implementation of
    the microservice applications. Instead of hardcoding them into the code as variable
    data, usually, we store them in the *env*, *property*, or *INI* files. However,
    challenges arise when assigning these settings to different microservices.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些设置都是外部于微服务应用程序实现的值。我们通常将它们存储在*env*、*属性*或*INI*文件中，而不是将它们作为变量数据硬编码到代码中。然而，将这些设置分配给不同的微服务时会出现挑战。
- en: Frameworks that support the *externalized configuration design pattern* have
    an internal processing feature that fetches environment variables or settings
    without requiring additional parsing or decoding techniques. For instance, the
    FastAPI framework has built-in support for externalized settings through pydantic’s
    `BaseSettings` class.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 支持外部化配置设计模式的框架具有一个内部处理功能，可以获取环境变量或设置，而无需额外的解析或解码技术。例如，FastAPI框架通过pydantic的`BaseSettings`类内置了对外部化设置的
    支持。
- en: Storing settings as class attributes
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将设置存储为类属性
- en: 'In our architecture setup, it should be the top-level application that will
    manage the externalized values. One way is to store them in a `BaseSettings` class
    as attributes. The following are classes of the `BaseSettings` type with their
    respective application details:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的架构设置中，应该是顶级应用程序来管理外部化值。一种方法是将它们作为属性存储在`BaseSettings`类中。以下是与各自应用程序详情相关的`BaseSettings`类型的类：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, `FacultySettings` will be assigned to the *f**aculty* module since it
    carries some information regarding the module. `LibrarySettings` is for the *library*
    module to utilize, while `StudentSettings` is for the *student* module.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`FacultySettings`将被分配给*学院*模块，因为它携带有关模块的一些信息。`LibrarySettings`用于*图书馆*模块，而`StudentSettings`用于*学生*模块。
- en: 'To fetch the values, first, a component in a module must import the `BaseSettings`
    class from the main project’s `/configuration/config.py` module. Then, it needs
    an injectable function to instantiate it before injecting it into a component
    that needs to utilize the values. The following script is part of `/student_mgt/student_main.py`,
    where the settings need to be retrieved:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取值，首先，模块中的一个组件必须从主项目的`/configuration/config.py`模块中导入`BaseSettings`类。然后，它需要一个可注入的函数来在将其注入到需要利用这些值的组件之前实例化它。以下脚本是`/student_mgt/student_main.py`的一部分，其中需要检索设置：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, `build_config()` is an injectable function that injects the `StudentSettings`
    instance into the `/index` endpoint of the *s**tudent* microservice. After the
    DI, the application, webmaster, and created values will become accessible from
    the `config` wired object. These settings will appear on the browser right after
    calling the `/ch04/university/1` gateway URL.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`build_config()` 是一个可注入的函数，它将 `StudentSettings` 实例注入到 *学生* 微服务的 `/index`
    端点。在 DI 之后，应用程序、网站管理员和创建的值将可以通过 `config` 连接对象访问。这些设置将在调用 `/ch04/university/1`
    网关 URL 后立即出现在浏览器上。
- en: Storing settings in the properties file
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在属性文件中存储设置
- en: 'Another option is to store all these settings inside a physical file with an
    extension of `.env`, `.properties`, or `.ini`. For instance, this project has
    the `erp_settings.properties` file found in the `/configuration` folder, and it
    contains the following application server details in *key-value* pair format:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是将所有这些设置存储在一个扩展名为 `.env`、`.properties` 或 `.ini` 的物理文件中。例如，这个项目在 `/configuration`
    文件夹中有一个名为 `erp_settings.properties` 的文件，它以 *键值对* 格式包含以下应用程序服务器细节：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To fetch these details, the application needs another `BaseSettings` class
    implementation that declares the *key* of the *key-value* pair as attributes.
    The following class shows how `production_server`, `prod_port`, `development_server`,
    and `dev_port` are declared without any assigned values:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取这些细节，应用程序需要另一个 `BaseSettings` 类的实现，该实现声明 *键值对* 的 *键* 作为属性。以下类展示了如何声明 `production_server`、`prod_port`、`development_server`
    和 `dev_port` 而不分配任何值：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Aside from the class variable declaration, `BaseSetting` requires an implementation
    of an *inner class*, called `Config`, with a predefined `env_file` assigned to
    the current location of the properties file.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 除了类变量声明之外，`BaseSetting` 还需要一个实现一个 *内部类*，称为 `Config`，它将预定义的 `env_file` 分配给属性文件当前的位置。
- en: 'The same processes are involved when it comes to accessing the property details
    from the file. After importing `ServerSettings`, it needs an injectable function
    to inject its instance to the components that need the details. The following
    script is an updated version of `/student_mgt/student_main.py`, which includes
    access to the `development_server` and `development_port` settings:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到从文件访问属性细节时，涉及到的过程是相同的。在导入 `ServerSettings` 之后，它需要一个可注入的函数来注入其实例到需要这些细节的组件中。以下脚本是
    `/student_mgt/student_main.py` 的更新版本，其中包括对 `development_server` 和 `development_port`
    设置的访问：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Based on this enhanced script, running the `/ch04/university/1` URL will redirect
    the browser to a screen showing additional server details from the properties
    file. Managing configuration details in FastAPI is easy, as we either save them
    inside a class or inside a file. No external module is necessary, and no special
    coding effort is required to fetch all these settings, just the creation of the
    `BaseSettings` classes. This easy setup contributes to building flexible and adaptable
    microservice applications that can run on varying configuration details.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个增强的脚本，运行 `/ch04/university/1` URL 将会将浏览器重定向到一个显示来自属性文件的额外服务器详细信息的屏幕。在 FastAPI
    中管理配置细节非常简单，因为我们要么将它们保存在类内部，要么保存在文件内部。不需要外部模块，也不需要特殊的编码工作来获取所有这些设置，只需创建 `BaseSettings`
    类即可。这种简单的设置有助于构建灵活且适应性强的微服务应用程序，这些应用程序可以在不同的配置细节上运行。
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The chapter started with the decomposition pattern, which is useful for breaking
    down a monolithic application into granularized, independent, and scalable modules.
    The FastAPI application that implemented these modules exhibited some principles
    included in the *12-Factor Application principles* of a microservice, such as
    having independence, configuration files, logging systems, code bases, port binding,
    concurrency, and easy deployment.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从分解模式开始，这种模式对于将单体应用程序分解为粒度化、独立和可扩展的模块非常有用。实现了这些模块的 FastAPI 应用展示了包括在微服务 *12-Factor
    应用原则* 中的某些原则，例如具有独立性、配置文件、日志系统、代码库、端口绑定、并发性和易于部署。
- en: Alongside decomposition, this chapter also showcased the *mounting of different
    independent sub-applications* onto the FastAPI platform. Only FastAPI can group
    independent microservices using mounts and bind them into one port with their
    corresponding context roots. From this feature, we created a pseudo-API Gateway
    pattern that serves as a façade to the independent sub-applications.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 除了分解之外，本章还展示了将不同的独立子应用*安装*到FastAPI平台上的过程。只有FastAPI能够使用安装功能将独立的微服务分组，并将它们绑定到一个端口上，同时使用相应的上下文根。从这个特性中，我们创建了一个伪API网关模式，该模式作为独立子应用的门面。
- en: Despite the possible drawbacks, the chapter also highlighted domain modeling
    as an option for organizing components in a FastAPI microservice. The *domain*,
    *repository*, and *service* layers help manage the information flow and task distribution
    based on the project specification. Tracing, testing, and debugging are easy when
    domain layers are in place.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可能存在一些缺点，但本章还强调了领域建模作为在FastAPI微服务中组织组件的选项。*领域*、*存储库*和*服务*层有助于根据项目规范管理信息流和任务分配。当领域层就绪时，跟踪、测试和调试变得容易。
- en: In the next chapter, we will focus on integrating our microservice applications
    with a relational database platform. The focus is to establish database connectivity
    and utilize our data models to implement CRUD transactions within the repository
    layer.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将专注于将我们的微服务应用程序与关系型数据库平台集成。重点是建立数据库连接并利用我们的数据模型在存储库层实现CRUD事务。
- en: 'Part 2: Data-Centric and Communication-Focused Microservices Concerns and Issues'
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2部分：以数据为中心和以通信为重点的微服务关注点和问题
- en: In this part of the book, we will be exploring other FastAPI components and
    features to solve other design patterns that the API framework can build, looking
    at data, communication, messaging, reliability, and security. External modules
    will also be highlighted in order to pursue other behavior and frameworks, such
    as ORM and reactive programming.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，我们将探讨其他FastAPI组件和功能，以解决API框架可以构建的其他设计模式，包括数据、通信、消息、可靠性和安全性。外部模块也将被突出显示，以追求其他行为和框架，例如ORM和响应式编程。
- en: 'This part comprises the following chapters:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 5*](B17975_05.xhtml#_idTextAnchor107), Connecting to a Relational
    Database'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B17975_05.xhtml#_idTextAnchor107)，连接到关系型数据库'
- en: '[*Chapter 6*](B17975_06.xhtml#_idTextAnchor155), Using a Non-Relational Database'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B17975_06.xhtml#_idTextAnchor155)，使用非关系型数据库'
- en: '[*Chapter 7*](B17975_07.xhtml#_idTextAnchor190), Securing the REST APIs'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B17975_07.xhtml#_idTextAnchor190)，保护REST API的安全'
- en: '[*Chapter 8*](B17975_08.xhtml#_idTextAnchor229), Creating Coroutines, Events,
    and Message-Driven Transactions'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B17975_08.xhtml#_idTextAnchor229)，创建协程、事件和消息驱动的交易'
