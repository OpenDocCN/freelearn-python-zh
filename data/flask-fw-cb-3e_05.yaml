- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Web Forms with WTForms
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 WTForms 的 Web 表单
- en: Form handling is an integral part of any web application. There can be innumerable
    cases that make the presence of forms in any web app very important. Some cases
    may include situations where users need to log in or submit some data, or where
    applications might require input from users. As much as forms are important, their
    validation holds equal importance, if not more. Presenting this information to
    users in an interactive fashion adds a lot of value to the application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 表单处理是任何 Web 应用程序的一个基本组成部分。可能会有无数的情况使得在任何 Web 应用程序中存在表单非常重要。一些情况可能包括用户需要登录或提交某些数据，或者应用程序可能需要从用户那里获取输入。尽管表单很重要，但它们的验证同样重要，甚至更重要。以交互式方式向用户展示这些信息将为应用程序增添很多价值。
- en: There are various ways in which we can design and implement forms in a web application.
    As web applications have matured, form validation and communicating the correct
    messages to a user have become very important. Client-side validations can be
    implemented at the frontend using JavaScript and HTML5\. Server-side validations
    have a more important role in adding security to an application, rather than being
    user-interactive. Server-side validations prevent any incorrect data from going
    through to the database and, hence, curb fraud and attacks.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有各种方法可以在 Web 应用程序中设计和实现表单。随着 Web 应用的成熟，表单验证和向用户传达正确信息变得非常重要。客户端验证可以通过 JavaScript
    和 HTML5 在前端实现。服务器端验证在增加应用程序安全性方面扮演着更重要的角色，而不是用户交互。服务器端验证阻止任何错误数据进入数据库，从而遏制欺诈和攻击。
- en: WTForms provides many fields with server-side validation by default and, hence,
    increases development speed and decreases the overall effort required. It also
    provides the flexibility to write custom validations and custom fields as required.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: WTForms 默认提供许多带有服务器端验证的字段，因此提高了开发速度并减少了整体工作量。它还提供了灵活性，可以根据需要编写自定义验证和自定义字段。
- en: 'We will use a Flask extension in this chapter. This extension is called Flask-WTF
    ([https://flask-wtf.readthedocs.io/en/latest/](https://flask-wtf.readthedocs.io/en/latest/));
    it provides integration between WTForms and Flask, taking care of important and
    trivial stuff that we would have to otherwise reinvent in order to make our application
    secure and effective. We can install it using the following command:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用一个 Flask 扩展。这个扩展被称为 Flask-WTF ([https://flask-wtf.readthedocs.io/en/latest/](https://flask-wtf.readthedocs.io/en/latest/))；它提供了
    WTForms 和 Flask 之间的集成，负责处理重要和琐碎的事情，否则我们可能需要重新发明以使我们的应用程序安全有效。我们可以使用以下命令来安装它：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下菜谱：
- en: Representing SQLAlchemy model data as a form
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 SQLAlchemy 模型数据表示为表单
- en: Validating fields on the server side
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器端验证字段
- en: Creating a common form set
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个通用的表单集
- en: Creating custom fields and validations
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义字段和验证
- en: Creating a custom widget
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义小部件
- en: Uploading files via forms
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过表单上传文件
- en: Protecting applications from **cross-site request** **forgery** (**CSRF**)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护应用程序免受 **跨站请求伪造** （**CSRF**）的侵害
- en: Representing SQLAlchemy model data as a form
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 SQLAlchemy 模型数据表示为表单
- en: First, let’s build a form using a SQLAlchemy model. In this recipe, we will
    take the product model from our catalog application used previously in this book
    and add functionality, creating products from the frontend using a web form.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用 SQLAlchemy 模型构建一个表单。在本例中，我们将从本书之前使用的目录应用程序中获取产品模型，并添加功能，通过 Web 表单从前端创建产品。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will use our catalog application from [*Chapter 4*](B19111_04.xhtml#_idTextAnchor184),
    *Working with Views*, and we will develop a form for the `Product` model.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用来自 [*第 4 章*](B19111_04.xhtml#_idTextAnchor184) 的目录应用程序，*与视图一起工作*，并将为 `Product`
    模型开发一个表单。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'If you recall, the `Product` model looks like the following lines of code in
    the `models.py` file:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，`Product` 模型在 `models.py` 文件中的代码如下：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'First, we will create a `ProductForm` class in `models.py`; this will subclass
    the `FlaskForm` class, which is provided by `flask_wtf`, to represent the fields
    required on a web form:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在 `models.py` 中创建一个 `ProductForm` 类；这将继承 `FlaskForm` 类，它由 `flask_wtf`
    提供，以表示 Web 表单上所需的字段：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We import `FlaskForm` from the `flask-wtf` extension. Everything else, such
    as `fields` and `validators`, are imported from `wtforms` directly. The `Name`
    field is of the `StringField` type, as it requires text data, while `Price` is
    of the `DecimalField` type, which will parse the data to Python’s `Decimal` data
    type. We have kept `Category` as the `SelectField` type, which means that we can
    choose only from the categories created previously when creating a product.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`flask-wtf`扩展中导入`FlaskForm`。其他所有内容，如`fields`和`validators`，都直接从`wtforms`导入。`Name`字段是`StringField`类型，因为它需要文本数据，而`Price`是`DecimalField`类型，它将数据解析为Python的`Decimal`数据类型。我们将`Category`保持为`SelectField`类型，这意味着在创建产品时，我们只能从之前创建的类别中选择。
- en: Information
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Note that we have a parameter called `coerce` in the field definition for `Category`
    (which is a selection list); this means that the incoming data from the HTML form
    will be coerced to an integer value prior to validating or any other processing.
    Here, coercing simply means converting a value, provided in a specific data type,
    to a different data type.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在`Category`字段（这是一个选择列表）的定义中有一个名为`coerce`的参数；这意味着在验证或任何其他处理之前，来自HTML表单的传入数据将被强制转换为整数值。在这里，强制转换简单地说就是将特定数据类型中提供的值转换为不同的数据类型。
- en: 'The `create_product()` handler in `views.py` should now accommodate the form
    created earlier:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`views.py`中的`create_product()`处理程序现在应该适应之前创建的表单：'
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `create_product()` method accepts values from a form on a `POST` request.
    This method will render an empty form with the prefilled choices in the `Category`
    field on a `GET` request. On the `POST` request, the form data will be used to
    create a new product, and when the creation of the product is completed, the newly
    created product’s page will be displayed.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_product()`方法接受`POST`请求上的表单值。这个方法将在`GET`请求上渲染一个空表单，并在`Category`字段中预先填充选择。在`POST`请求上，表单数据将用于创建一个新的产品，当产品创建完成后，将显示新创建的产品页面。'
- en: Information
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: 'Note that while creating the `form` object as `form = ProductForm(meta={''csrf'':
    False})`, we set `csrf` to `False`. CSRF is an important part of any secure web
    application. We will talk about this in detail in the *Protecting applications
    from CSRF* recipe of this chapter.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，在创建`form`对象时，`form = ProductForm(meta={''csrf'': False})`，我们将`csrf`设置为`False`。CSRF是任何安全Web应用程序的重要组成部分。我们将在本章的*保护应用程序免受CSRF攻击*菜谱中详细讨论这一点。'
- en: 'The `templates/product-create.html` template also requires some modification.
    The `form` objects created by WTForms provide an easy way to create HTML forms
    and keep code readable:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`templates/product-create.html`模板也需要一些修改。WTForms创建的`form`对象提供了一个简单的方法来创建HTML表单并保持代码可读性：'
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'On a `GET` request – that is, upon opening `http://127.0.0.1:5000/product-create`
    – we will see a form similar to the one shown in the following screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个`GET`请求上——也就是说，在打开`http://127.0.0.1:5000/product-create`时——我们将看到一个类似于以下截图中的表单：
- en: '![Figure 5.1 – Product creation form using WTForms](img/B19111_05_1.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 - 使用WTForms创建产品表单](img/B19111_05_1.jpg)'
- en: Figure 5.1 – Product creation form using WTForms
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 - 使用WTForms创建产品表单
- en: You can fill in this form to create a new product.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以填写此表单以创建新产品。
- en: See also
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the following *Validating fields on the server side* recipe to understand
    how to validate the fields we just learned to create.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下*在服务器端验证字段*菜谱，了解如何验证我们刚刚学习创建的字段。
- en: Validating fields on the server side
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在服务器端验证字段
- en: We have created forms and fields, but we need to validate them in order to make
    sure that only the correct data goes through to the database and that errors are
    handled beforehand, rather than corrupting the database. These validations can
    also protect an application against **cross-site scripting** (**XSS**) and CSRF
    attacks. WTForms provides a whole lot of field types that, themselves, have validations
    written for them by default. Apart from these, there are a bunch of validators
    that can be used based on choice and need. In this recipe, we will use a few of
    them to understand the concept.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了表单和字段，但我们需要验证它们，以确保只有正确的数据通过到数据库，并且错误在之前得到处理，而不是破坏数据库。这些验证还可以保护应用程序免受**跨站脚本攻击**（**XSS**）和CSRF攻击。WTForms提供了一大堆字段类型，这些类型本身就有默认的验证。除此之外，还有一些可以根据选择和需要使用的验证器。在这个菜谱中，我们将使用其中的一些来理解这个概念。
- en: How to do it...
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: It is pretty easy to add validations to our WTForm fields. We just need to pass
    a `validators` parameter, which accepts a list of validators to be implemented.
    Each of the validators can have their own arguments, which enables us to control
    the validations to a great extent.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 向我们的 WTForm 字段添加验证非常简单。我们只需要传递一个 `validators` 参数，它接受要实现的验证器列表。每个验证器都可以有自己的参数，这使得我们能够极大地控制验证。
- en: 'Let’s modify our `ProductForm` object in the `models.py` class to have validations:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改 `models.py` 类中的 `ProductForm` 对象以包含验证：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we have the `InputRequired` validator on all three fields; this means
    that these fields are required, and the form will not be submitted unless we have
    values for these fields.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在所有三个字段上都有 `InputRequired` 验证器；这意味着这些字段是必需的，除非我们为这些字段提供了值，否则表单将不会提交。
- en: 'The `Price` field has an additional validator, `NumberRange`, with a `min`
    parameter set to `0.0`. This implies that we cannot have a value of less than
    `0` as the price of a product. To complement these changes, we will have to modify
    our `create_product()` method in `views.py`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`Price` 字段有一个额外的验证器 `NumberRange`，其 `min` 参数设置为 `0.0`。这意味着产品的价格不能小于 `0`。为了补充这些更改，我们还需要修改
    `views.py` 中的 `create_product()` 方法：'
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Tip
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: The flashing of `form.errors` will just display the errors in the form of a
    JSON object. This can be formatted to be shown in a pleasing format to a user.
    This is left for you to try yourself.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`form.errors` 的闪现将仅以 JSON 对象的形式显示错误。这可以被格式化以使用户看到令人愉悦的格式。这留给你自己尝试。'
- en: Here, we modified our `create_product()` method to validate the form for the
    input value when submitted. Some of the validations will be translated and applied
    to the frontend as well, just like the `InputRequired` validation will add a `required`
    property to the form field’s HTML. On a `POST` request, the form data will be
    validated first. If the validation fails for some reason, the same page will be
    rendered again, with error messages flashed on it. If the validation succeeds
    and the creation of the product is completed, the newly created product’s page
    will be displayed.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们修改了 `create_product()` 方法，以便在提交时验证表单的输入值。一些验证将被翻译并应用到前端，就像 `InputRequired`
    验证将添加一个 `required` 属性到表单字段的 HTML 中。在 `POST` 请求中，首先将验证表单数据。如果由于某些原因验证失败，将再次渲染相同的页面，并在其上闪现错误消息。如果验证成功并且产品创建完成，将显示新创建的产品页面。
- en: Note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Note the very convenient `validate_on_submit()` method. This will automatically
    check whether the request is `POST` and whether it is valid. It is essentially
    a combination of `request.method == 'POST'` and `form.validate()`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意非常方便的 `validate_on_submit()` 方法。这个方法会自动检查请求是否为 `POST` 以及其是否有效。它本质上是将 `request.method
    == 'POST'` 和 `form.validate()` 的组合。
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Now, try to submit the form without any field filled in – that is, an empty
    form. An alert message with an error will be shown as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试提交一个没有任何字段填写（即空表单）的表单。将显示一个带有错误信息的警告消息，如下所示：
- en: '![Figure 5.2 – In-built error handling in WTForms](img/B19111_05_2.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – WTForms 中的内置错误处理](img/B19111_05_2.jpg)'
- en: Figure 5.2 – In-built error handling in WTForms
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – WTForms 中的内置错误处理
- en: 'If you try to submit the form with a negative price value, the flashed error
    will look something like the following screenshot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试提交一个带有负价格值的表单，闪现的错误将类似于以下截图：
- en: '![Figure 5.3 – Custom error handling in WTForms](img/B19111_05_3.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – WTForms 中的自定义错误处理](img/B19111_05_3.jpg)'
- en: Figure 5.3 – Custom error handling in WTForms
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – WTForms 中的自定义错误处理
- en: Try different combinations of form submissions that will violate the defined
    validators, and note the different error messages that come up.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试不同的表单提交组合，这些组合将违反定义的验证器，并注意出现的不同错误消息。
- en: See also
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the previous recipe, *Representing SQLAlchemy model data as a form*,
    to understand basic form creation using WTForms.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 参考之前的配方，*将 SQLAlchemy 模型数据表示为表单*，以了解使用 WTForms 创建基本表单的方法。
- en: Creating a common form set
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建公共表单集
- en: An application can have many forms, depending on the design and purpose. Some
    of these forms will have common fields with common validators. You might think,
    “*Why not have common form parts and then reuse them as and when needed?*” In
    this recipe, we will see that this is certainly possible with the class structure
    for forms’ definition provided by WTForms.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序可以有多个表单，这取决于设计和目的。其中一些表单将具有共同的字段和共同的验证器。你可能会想，“*为什么不创建通用的表单部分并在需要时重用它们呢？*”在这个菜谱中，我们将看到使用
    WTForms 提供的表单定义类结构，这确实是可能的。
- en: How to do it...
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: In our catalog application, we can have two forms, one each for the `Product`
    and `Category` models. These forms will have a common field called `Name`. We
    can create a common form for this field, and then the separate forms for the `Product`
    and `Category` models can use this form, instead of having a `Name` field in each
    of them.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的目录应用程序中，我们可以有两个表单，每个分别对应 `Product` 和 `Category` 模型。这些表单将有一个共同的字段称为 `Name`。我们可以为这个字段创建一个通用的表单，然后
    `Product` 和 `Category` 模型的单独表单可以使用这个表单，而不是在每个模型中都有一个 `Name` 字段。
- en: 'This can be implemented as follows in `models.py`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在 `models.py` 中如下实现：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We created a common form called `NameForm`, and the other forms, `ProductForm`
    and `CategoryForm`, inherit from this form to have a field called `Name` by default.
    Then, we can add more fields as necessary.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `NameForm` 的通用表单，其他表单 `ProductForm` 和 `CategoryForm` 从这个表单继承，默认包含一个名为
    `Name` 的字段。然后，我们可以根据需要添加更多字段。
- en: 'We can modify the `create_category()` method in `views.py` to use `CategoryForm`
    to create categories:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以修改 `views.py` 中的 `create_category()` 方法，使用 `CategoryForm` 来创建分类：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A new template, `templates/category-create.html`, also needs to be added for
    category creation:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要添加一个新的模板，`templates/category-create.html`，用于创建分类：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Open the `http://127.0.0.1:5000/category-create` URL in your browser. The newly
    created category form will look like the following screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开 `http://127.0.0.1:5000/category-create` URL。新创建的分类表单将看起来像以下截图：
- en: '![Figure 5.4 – A common form used for category creation](img/B19111_05_4.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – 用于创建分类的通用表单](img/B19111_05_4.jpg)'
- en: Figure 5.4 – A common form used for category creation
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 用于创建分类的通用表单
- en: Tip
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: This is a very small example of how a common form set can be implemented. The
    actual benefits of this approach can be seen in e-commerce applications, where
    we can have common address forms, and then they can be expanded to have separate
    billing and shipping addresses.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个如何实现通用表单集的小例子。这种方法的实际好处可以在电子商务应用程序中看到，在那里我们可以有通用的地址表单，然后它们可以扩展为具有单独的账单和发货地址。
- en: Creating custom fields and validations
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义字段和验证
- en: Apart from providing a bunch of fields and validations, Flask and WTForms also
    provide you with the flexibility to create custom fields and validations. Sometimes,
    we might need to parse some form of data that cannot be processed using the available
    current fields. In such cases, we can implement our own fields.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供一系列字段和验证之外，Flask 和 WTForms 还提供了创建自定义字段和验证的灵活性。有时，我们可能需要解析一些无法使用当前可用字段处理的数据格式。在这种情况下，我们可以实现自己的字段。
- en: How to do it...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: In our catalog application, we used `SelectField` for the category, and we populated
    the values for this field in our `create_product()` method on a `GET` request
    by querying the `Category` model. It would be much more convenient if we did not
    concern ourselves with this and the population of this field took care of itself.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的目录应用程序中，我们使用 `SelectField` 来处理分类，并在 `GET` 请求中通过查询 `Category` 模型来填充这个字段的值。如果我们不需要关心这一点，并且这个字段的填充可以自动完成，那就方便多了。
- en: 'Now, let’s implement a custom field to do this in `models.py`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在 `models.py` 中实现一个自定义字段来完成这个功能：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`SelectField` implements a method called `iter_choices()`, which populates
    the values to the form using the list of values provided to the `choices` parameter.
    We overwrite the `iter_choices()` method to get the values of categories directly
    from the database, and this eliminates the need to populate this field every time
    we need to use this form.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`SelectField` 实现了一个名为 `iter_choices()` 的方法，它使用提供给 `choices` 参数的值列表来填充表单。我们重写了
    `iter_choices()` 方法，直接从数据库中获取分类的值，这样就消除了每次使用这个表单时都需要填充这个字段的必要性。'
- en: Information
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: The behavior created by `CategoryField` here can also be achieved using `QuerySelectField`.
    Refer to [https://wtforms-sqlalchemy.readthedocs.io/en/stable/wtforms_sqlalchemy/#wtforms_sqlalchemy.fields.QuerySelectField](https://wtforms-sqlalchemy.readthedocs.io/en/stable/wtforms_sqlalchemy/#wtforms_sqlalchemy.fields.QuerySelectField)
    for more information.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`CategoryField`在这里创建的行为也可以使用`QuerySelectField`实现。有关更多信息，请参阅[https://wtforms-sqlalchemy.readthedocs.io/en/stable/wtforms_sqlalchemy/#wtforms_sqlalchemy.fields.QuerySelectField](https://wtforms-sqlalchemy.readthedocs.io/en/stable/wtforms_sqlalchemy/#wtforms_sqlalchemy.fields.QuerySelectField)。'
- en: 'Due to the changes described in this section, our `create_product()` method
    in `views.py` will have to be modified. For this, just remove the following two
    statements that populated the categories in the form:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本节中描述的更改，我们的`views.py`中的`create_product()`方法将需要进行修改。为此，只需删除以下两个填充表单中类别的语句：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: There will not be any visual effect on the application. The only change will
    be in the way the categories are populated in the form, as explained in the previous
    section.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序上不会有任何视觉上的影响。唯一的变化将是类别在表单中的填充方式，如前节所述。
- en: There’s more...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'We just saw how to write custom fields. Similarly, we can write custom validations,
    too. Let’s assume that we do not want to allow duplicate categories. We can implement
    this in our models easily, but let’s do this using a custom validator on our form:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了如何编写自定义字段。同样，我们也可以编写自定义验证。假设我们不想允许重复的类别。我们可以在模型中轻松实现这一点，但让我们使用表单上的自定义验证器来完成：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: So, we created our validator in a factory style, where we can get separate validation
    results based on whether we want a case-sensitive comparison. We can even write
    a class-based design, which makes the validator much more generic and flexible,
    but I will leave that for you to explore.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们以工厂模式创建了我们的验证器，这样我们就可以根据是否需要大小写敏感的比较来获取单独的验证结果。我们甚至可以编写基于类的设计，这使得验证器更加通用和灵活，但我会把这个留给你去探索。
- en: 'Now, if you try to create a new category with the same name as the one that
    already exists, the following error will be shown:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你尝试创建一个与已存在的类别同名的新类别，将会显示以下错误：
- en: "![Figure 5.5 – An error on the duplicate ca\uFEFFtegory creation](img/B19111_05_5.jpg)"
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图5.5 – 创建重复类别时的错误](img/B19111_05_5.jpg)'
- en: Figure 5.5 – An error on the duplicate category creation
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – 创建重复类别时的错误
- en: Creating a custom widget
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义组件
- en: Just like we can create custom fields and validators, we can also create custom
    widgets. These widgets allow us to control how our fields will look on the frontend.
    Each field type has a widget associated with it, and WTForms, by itself, provides
    a lot of basic and HTML5 widgets. In this recipe, to understand how to write a
    custom widget, we will convert our custom selection field for `Category` into
    a radio field. I agree with those of you who would argue that we can directly
    use the radio field provided by WTForms. Here, we are just trying to understand
    how to do it ourselves.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们可以创建自定义字段和验证器一样，我们也可以创建自定义组件。这些组件允许我们控制字段在前端显示的方式。每个字段类型都关联着一个组件，WTForms本身提供了大量的基本和HTML5组件。在本例中，为了理解如何编写自定义组件，我们将我们的自定义选择字段`Category`转换为单选字段。我同意那些认为我们可以直接使用WTForms提供的单选字段的人。在这里，我们只是在尝试理解如何自己完成它。
- en: Information
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: The widgets provided by default by WTForms can be found at [https://wtforms.readthedocs.io/en/3.0.x/widgets/](https://wtforms.readthedocs.io/en/3.0.x/widgets/).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: WTForms默认提供的组件可以在[https://wtforms.readthedocs.io/en/3.0.x/widgets/](https://wtforms.readthedocs.io/en/3.0.x/widgets/)找到。
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In our previous recipe, we created `CategoryField`. This field used the `Select`
    widget, which was provided by the `Select` superclass. Let’s replace the `Select`
    widget with a radio input in `models.py`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的示例中，我们创建了`CategoryField`。这个字段使用了`Select`组件，它是由`Select`超类提供的。让我们在`models.py`中将`Select`组件替换为单选输入：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we added a class attribute called `widget` to our `CategoryField` class.
    This widget points to `CustomCategoryInput`, which takes care of HTML code generation
    for the field to be rendered. This class has a `__call__()` method, which is overwritten
    to return radio inputs corresponding to the values provided by the `iter_choices()`
    method of `CategoryField`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们向`CategoryField`类添加了一个名为`widget`的类属性。这个组件指向`CustomCategoryInput`，它负责生成要渲染的字段的HTML代码。这个类有一个`__call__()`方法，它被重写以返回与`CategoryField`的`iter_choices()`方法提供的值相对应的单选输入。
- en: How it works...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'When you open the product creation page, `http://127.0.0.1:5000/product-create`,
    it will look like the following screenshot:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开产品创建页面，`http://127.0.0.1:5000/product-create`，它看起来如下所示：
- en: "![Figure 5.6 – A custom widget for \uFEFFcategory selection](img/B19111_05_6.jpg)"
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 用于类别选择的自定义小部件](img/B19111_05_6.jpg)'
- en: Figure 5.6 – A custom widget for category selection
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 用于类别选择的自定义小部件
- en: See also
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the previous recipe, *Creating custom fields and validation*, to understand
    more about the level of customization that can be done to the components of WTForms.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 参考之前的菜谱，*创建自定义字段和验证*，以了解可以对 WTForms 的组件进行多少定制。
- en: Uploading files via forms
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过表单上传文件
- en: Uploading files via forms, and doing it properly, is usually a matter of concern
    for many web frameworks. In this recipe, we will see how Flask and WTForms handle
    this for us in a simple and streamlined manner.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过表单上传文件，并且正确地做这件事，通常是许多网络框架关注的问题。在这个菜谱中，我们将看到 Flask 和 WTForms 如何以简单和流畅的方式为我们处理这个问题。
- en: How to do it...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this recipe, we will implement a feature to store product images while creating
    products. First, we will start with the configuration bit. We need to provide
    a parameter to our application configuration – that is, `UPLOAD_FOLDER`. This
    parameter tells Flask about the location where our uploaded files will be stored.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将实现一个在创建产品时存储产品图片的功能。首先，我们将从配置部分开始。我们需要向应用程序配置提供一个参数——即 `UPLOAD_FOLDER`。这个参数告诉
    Flask 我们上传的文件将被存储的位置。
- en: Tip
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: One way to store product images can be to store images in a binary-type field
    in our database, but this method is highly inefficient and never recommended in
    any application. We should always store images and other uploads in a filesystem,
    and store their locations in a database using a `string` field.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 存储产品图片的一种方法是将图片存储在数据库的二进制类型字段中，但这种方法效率非常低，在任何应用程序中都不推荐使用。我们应该始终在文件系统中存储图片和其他上传文件，并使用
    `string` 字段在数据库中存储它们的路径。
- en: 'Add the following statements to the configuration in `my_app/__init__.py`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下语句添加到 `my_app/__init__.py` 的配置中：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note the `app.config['UPLOAD_FOLDER']` statement, where we store the images
    inside a subfolder in the `static` folder itself. This will make the process of
    rendering images easier. Also, note the `ALLOWED_EXTENSIONS` statement, which
    is used to make sure that only files of a specific format go through. The list
    here is actually for demonstration purposes only, and for image types, we can
    filter this list even more. Make sure the folder path specified in the `app.config['UPLOAD_FOLDER']`
    statement exists; otherwise, the application will error out.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `app.config['UPLOAD_FOLDER']` 语句，我们在 `static` 文件夹内的一个子文件夹中存储图片。这将使渲染图片的过程更加容易。同时，注意
    `ALLOWED_EXTENSIONS` 语句，它用于确保只有特定格式的文件通过。这里的列表实际上只是为了演示目的，对于图像类型，我们还可以进一步过滤这个列表。确保在
    `app.config['UPLOAD_FOLDER']` 语句中指定的文件夹路径存在；否则，应用程序将出错。
- en: 'In the `models` file – that is, `my_app/catalog/models.py` – add the following
    highlighted statements to their designated places:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `models` 文件中——即 `my_app/catalog/models.py` ——在其指定位置添加以下突出显示的语句：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Check `FileField` for `image` in `ProductForm` and the field for `image_path`
    to the `Product` model. Here, the uploaded file will be stored on the filesystem
    at the path defined in the config, and the path generated will be stored in the
    database.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ProductForm` 中检查 `image` 的 `FileField` 和 `Product` 模型的 `image_path` 字段。在这里，上传的文件将被存储在配置中定义的路径上的文件系统中，生成的路径将被存储在数据库中。
- en: 'Now, modify the `create_product()` method to save the file in `my_app/catalog/views.py`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，修改 `create_product()` 方法，将文件保存在 `my_app/catalog/views.py` 中的 `my_app/catalog/views.py`：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the new field to the product create form in `template templates/product-create.html`.
    Modify the `form` tag definition to include the `enctype` parameter, and add the
    field for the image before the **Submit** button (or wherever you feel it is necessary
    inside the form):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 将新字段添加到 `template templates/product-create.html` 中的产品创建表单。修改 `form` 标签定义以包含
    `enctype` 参数，并在 **提交** 按钮之前（或您认为表单内任何必要的位置）添加字段：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The form should have the `enctype="multipart/form-data"` statement to tell the
    application that the form input will have multipart data.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 表单应该有 `enctype="multipart/form-data"` 语句来告诉应用程序表单输入将包含多部分数据。
- en: 'Rendering the image is very easy, as we are storing the files in the `static`
    folder itself. Just add the `img` tag wherever the image needs to be displayed
    in `templates/product.html`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染图像非常简单，因为我们把文件存储在 `static` 文件夹本身。只需在 `templates/product.html` 中需要显示图像的地方添加
    `img` 标签：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The field to upload the image will look something like the following screenshot:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 上传图像的字段看起来可能如下面的截图所示：
- en: '![Figure 5.7 – Uploading files for the product image](img/B19111_05_7.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7 – 上传产品图像](img/B19111_05_7.jpg)'
- en: Figure 5.7 – Uploading files for the product image
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – 上传产品图像的文件
- en: 'Following the creation of the product, the image will be displayed, as shown
    in the following screenshot:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建产品后，图像将显示，如下面的截图所示：
- en: "![Figure 5.8 – The product page \uFEFFwith the uploaded file](img/B19111_05_8.jpg)"
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8 – 上传文件的产品页面](img/B19111_05_8.jpg)'
- en: Figure 5.8 – The product page with the uploaded file
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – 上传文件的产品页面
- en: Protecting applications from CSRF
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护应用程序免受 CSRF 攻击
- en: In the first recipe of this chapter, we learned that CSRF is an important part
    of web form security. We will now talk about this in detail. CSRF basically means
    that someone can hack into the request that carries a cookie and use this to trigger
    a destructive action. We won’t be discussing CSRF in detail here, since ample
    resources are available on the internet to learn about it. We will talk about
    how WTForms helps us to prevent CSRF. Flask does not provide any security against
    CSRF by default, as this has to be handled at the form-validation level, which
    is not a core feature of Flask as a framework. However, in this recipe, we will
    see how this can be done for us by using the Flask-WTF extension.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一个配方中，我们了解到 CSRF 是网络表单安全的重要组成部分。现在我们将详细讨论这个问题。CSRF基本上意味着有人可以黑入携带 cookie
    的请求并使用它来触发破坏性操作。我们不会在这里详细讨论 CSRF，因为互联网上有大量资源可以学习它。我们将讨论 WTForms 如何帮助我们防止 CSRF。Flask
    默认不提供 CSRF 的安全措施，因为这需要在表单验证级别处理，而这不是 Flask 作为框架的核心功能。然而，在本配方中，我们将看到 Flask-WTF
    扩展如何为我们完成这项工作。
- en: Information
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: More information about CSRF can be found at [https://owasp.org/www-community/attacks/csrf](https://owasp.org/www-community/attacks/csrf).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 CSRF 的信息可以在 [https://owasp.org/www-community/attacks/csrf](https://owasp.org/www-community/attacks/csrf)
    找到。
- en: How to do it...
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Flask-WTF, by default, provides a form that is CSRF-protected. If we have a
    look at the recipes so far, we can see that we have explicitly told our form to
    *not be CSRF-protected*. We just have to remove the corresponding statement to
    enable CSRF.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Flask-WTF 默认提供的是一个 CSRF-受保护的表单。如果我们查看到目前为止的配方，我们可以看到我们已经明确告诉我们的表单不要进行 CSRF-保护。我们只需要移除相应的语句来启用
    CSRF。
- en: 'So, `form = ProductForm(meta={''csrf'': False})` will become `form =` `ProductForm()`.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，`form = ProductForm(meta={''csrf'': False})` 将变为 `form = ProductForm()`。'
- en: 'Some configuration bits also need to be done in our application:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一些配置位也需要在我们的应用程序中进行设置：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: By default, the CSRF key is the same as our application’s secret key.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，CSRF 密钥与我们的应用程序的密钥相同。
- en: 'With CSRF enabled, we will have to provide an additional field in our forms;
    this is a hidden field and contains the CSRF token. WTForms takes care of the
    hidden field for us, and we just have to add `{{ form.csrf_token }}` to our form:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 CSRF 后，我们将在我们的表单中提供一个额外的字段；这是一个隐藏字段，包含 CSRF 令牌。WTForms 会为我们处理隐藏字段，我们只需要在我们的表单中添加
    `{{ form.csrf_token }}`：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: That was easy! Now, this is not the only type of form submission that we do.
    We also submit AJAX form posts; this actually happens a lot more than normal forms
    since the advent of JavaScript-based web applications, which are replacing traditional
    web applications.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单！现在，这并不是我们唯一提交的表单提交类型。我们还提交 AJAX 表单帖子；自从基于 JavaScript 的网络应用程序出现以来，这实际上比普通表单发生得更多，因为它们正在取代传统的网络应用程序。
- en: 'For this, we need to include another step in our application’s configuration:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要在我们的应用程序配置中包含另一个步骤：
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding configuration will allow us to access the CSRF token using `{{
    csrf_token() }}` anywhere in our templates. Now, there are two ways to add a CSRF
    token to AJAX `POST` requests.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的配置将允许我们在模板的任何地方使用 `{{ csrf_token() }}` 访问 CSRF 令牌。现在，有两种方法可以将 CSRF 令牌添加到
    AJAX `POST` 请求中。
- en: 'One way is to fetch the CSRF token in our `script` tag and use it in the `POST`
    request:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是在我们的 `script` 标签中获取 CSRF 令牌并在 `POST` 请求中使用它：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Another way is to render the token in a `meta` tag and use it whenever required:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是在 `meta` 标签中渲染令牌并在需要时使用它：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The difference between the two approaches is that the first approach may have
    to be repeated in multiple places, depending on the number of `script` tags in
    the application.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法之间的区别在于，第一种方法可能需要根据应用程序中 `script` 标签的数量在多个地方重复。
- en: 'Now, to add the CSRF token to the AJAX `POST` request, we have to add the `X-CSRFToken`
    attribute to it. This attribute’s value can be taken from either of the two approaches
    stated here. We will take the second one for our example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了将 CSRF 令牌添加到 AJAX `POST` 请求中，我们必须向其中添加 `X-CSRFToken` 属性。此属性的值可以从这里提到的两种方法中的任何一种获取。我们将采用第二种方法作为我们的示例：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This will make sure that a CSRF token is added to all the AJAX `POST` requests
    that go out.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保 CSRF 令牌被添加到所有发出的 AJAX `POST` 请求中。
- en: How it works...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The following screenshot shows what the CSRF token added by WTForms in our
    form looks like:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 WTForms 在我们的表单中添加的 CSRF 令牌的外观：
- en: '![Figure 5.9 – The CSRF token](img/B19111_05_9.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9 – CSRF 令牌](img/B19111_05_9.jpg)'
- en: Figure 5.9 – The CSRF token
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 – CSRF 令牌
- en: The token is completely random and different for all the requests. There are
    multiple ways of implementing CSRF token generation, but this is beyond the scope
    of this book, although I encourage you to explore some alternative implementations
    on your own to understand how it’s done.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌是完全随机的，对于所有请求都是不同的。有多种实现 CSRF 令牌生成的方法，但这超出了本书的范围，尽管我鼓励你自己探索一些替代实现来了解它是如何完成的。
