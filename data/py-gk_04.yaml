- en: '*Chapter 3*: Advanced Object-Oriented Python Programming'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：高级面向对象Python编程'
- en: Python can be used as a declarative modular programming language such as C,
    as well as being used for imperative programming or full **object-oriented programming**
    (**OOP**) with programming languages such as Java. **Declarative programming**
    is a paradigm in which we focus on what we want to implement, while **imperative
    programming** is where we describe the exact steps of how to implement what we
    want. Python is suitable for both types of programming paradigms. OOP is a form
    of imperative programming in which we bundle the properties and behaviors of real-world
    objects into programs. Moreover, OOP also addresses the relations between different
    types of real-world objects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python可以用作类似于C的声明性模块化编程语言，也可以用于使用Java等编程语言进行命令式编程或完整的**面向对象编程（OOP**）。**声明性编程**是一种范式，其中我们关注我们想要实现的内容，而**命令式编程**是我们描述实现我们想要的内容的确切步骤。Python适合这两种编程范式。OOP是一种命令式编程形式，其中我们将现实世界对象的属性和行为捆绑到程序中。此外，OOP还解决了不同类型现实世界对象之间的关系。
- en: In this chapter, we will explore how the advanced concepts of OOP can be implemented
    using Python. We are assuming that you are familiar with general concepts such
    as classes, objects, and instances and have basic knowledge of inheritance between
    objects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何使用Python实现面向对象编程（OOP）的高级概念。我们假设你已经熟悉类、对象和实例等一般概念，并且对对象之间的继承有基本了解。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Introducing classes and objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍类和对象
- en: Understanding OOP principles
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解OOP原则
- en: Using composition as an alternative design approach
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用组合作为替代设计方法
- en: Introducing duck typing in Python
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中介绍鸭子类型
- en: Learning when not to use OOP in Python
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习何时在Python中不使用OOP
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'These are the technical requirements for this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是本章的技术要求：
- en: You need to have Python 3.7 or later installed on your computer.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要在您的计算机上安装Python 3.7或更高版本。
- en: The sample code for this chapter can be found at [https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter03](https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter03).
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的示例代码可以在[https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter03](https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter03)找到。
- en: Introducing classes and objects
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍类和对象
- en: A class is a blueprint for how something should be defined. It doesn't actually
    contain any data—it is a template that is used to create instances as per the
    specifications defined in a template or a blueprint.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 类是一个定义如何定义某物的蓝图。它实际上不包含任何数据——它是一个模板，用于根据模板或蓝图中的规范创建实例。
- en: An object of a class is an instance that is built from a class, and that is
    why it is also called an instance of a class. For the rest of this chapter and
    this book, we will refer to *object* and *instance* synonymously. Objects in OOP
    are occasionally represented by physical objects such as tables, chairs, or books.
    On most occasions, the objects in a software program represent abstracted entities
    that may not be physical, such as accounts, names, addresses, and payments.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 类的对象是一个从类构建的实例，这也是为什么它也被称为类的实例。在本章和本书的其余部分，我们将同义地使用*对象*和*实例*。在OOP中，对象有时可以用物理对象如桌子、椅子或书籍来表示。在大多数情况下，软件程序中的对象代表抽象实体，这些实体可能不是物理的，如账户、名称、地址和支付。
- en: To refresh ourselves with basic concepts of classes and objects, we will define
    these terminologies with code examples.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们对类和对象的基本概念有更清晰的认识，我们将通过代码示例来定义这些术语。
- en: Distinguishing between class attributes and instance attributes
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 区分类属性和实例属性
- en: '**Class attributes** are defined as part of the class definition, and their
    values are meant to be the same across all instances created from that class.
    The class attributes can be accessed using the class name or instance name, although
    it is recommended to use a class name to access these attributes (for reading
    or updating). The state or data of an object is provided by **instance attributes**.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**类属性**是在类定义的一部分中定义的，并且它们的值意味着在从该类创建的所有实例中都是相同的。可以通过类名或实例名来访问类属性，尽管建议使用类名来访问这些属性（用于读取或更新）。对象的状态或数据由**实例属性**提供。'
- en: 'Defining a class in Python is simply done by using the `class` keyword. As
    discussed in [*Chapter 1*](B17189_01_Final_PG_ePub.xhtml#_idTextAnchor013), *Optimal
    Python Development Life Cycle,* the name of the class should be CamelCase. The
    following code snippet creates a `Car` class:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中定义一个类很简单，只需使用`class`关键字。如[*第1章*](B17189_01_Final_PG_ePub.xhtml#_idTextAnchor013)中讨论的，*最佳Python开发生命周期*，类的名称应该是驼峰式。以下代码片段创建了一个`Car`类：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This class has no attributes and methods. It is an empty class, and you may
    think this class is useless until we add more components to it. Not exactly! In
    Python, you can add attributes on the fly without defining them in the class.
    The following snippet is a valid example of code in which we add attributes to
    a class instance at runtime:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类没有任何属性和方法。它是一个空类，你可能会认为这个类没有用，直到我们向它添加更多组件。但并非如此！在Python中，你可以在运行时动态地添加属性，而无需在类中定义它们。以下是一个有效的代码示例，展示了我们如何在运行时向类实例添加属性：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this extended example, we created an instance (`car`) of our `Car` class
    and then added two attributes to this instance: `color` and `miles`. Note that
    the attributes added using this approach are instance attributes.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个扩展示例中，我们创建了一个`Car`类的实例（`car`），然后向这个实例添加了两个属性：`color`和`miles`。请注意，使用这种方法添加的属性是实例属性。
- en: 'Next, we will add class attributes and instance attributes using a constructor
    method (`__init__`), which is loaded at the time of object creation. A code snippet
    with two instance attributes (`color` and `miles`) and the `init` method is shown
    next:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用构造方法（`__init__`）添加类属性和实例属性，该方法在对象创建时加载。以下是一个包含两个实例属性（`color`和`miles`）和`init`方法的代码片段：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this program, we did the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们做了以下操作：
- en: We created a `Car` class with a `c_mileage_units` class attribute and two instance
    variables, `i_color` and `i_mileage`.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个具有`c_mileage_units`类属性和两个实例变量`i_color`和`i_mileage`的`Car`类。
- en: We created an instance (`car`) of the `Car` class.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个`Car`类的实例（`car`）。
- en: We printed out the instance attributes using the `car` instance variable.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`car`实例变量打印出了实例属性。
- en: We printed out the class attribute using the `car` instance variable as well
    as the `Car` class name. The console output is the same for both cases.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`car`实例变量以及`Car`类名打印出了类属性。两种情况下的控制台输出是相同的。
- en: Important note
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: '`self` is a reference to the instance that is being created. Use of `self`
    is common in Python to access the instance attributes and methods within the instance
    method, including the `init` method. `self` is not a keyword, and it is not mandatory
    to use the word `self`. It can be anything such as `this` or `blah`, except that
    it has to be the first parameter to the instance methods, but the convention of
    using `self` as the argument name is too strong.'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`self`是对正在创建的实例的引用。在Python中，`self`的使用很常见，用于在实例方法中访问实例属性和方法，包括`init`方法。`self`不是一个关键字，使用`self`这个词不是强制的。它可以是指`this`或`blah`等任何名称，但必须作为实例方法的第一个参数，但使用`self`作为参数名称的约定非常强烈。'
- en: 'We can update the class attributes using an instance variable or class name,
    but the outcome can be different. When we update a class attribute using the class
    name, it is updated for all the instances of that class. But if we update a class
    attribute using an instance variable, it will be updated only for that particular
    instance. This is demonstrated in the following code snippet, which is using the
    `Car` class:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用实例变量或类名来更新类属性，但结果可能不同。当我们使用类名更新类属性时，它将更新该类的所有实例。但如果我们使用实例变量更新类属性，它将只更新那个特定的实例。以下代码片段展示了这一点，它使用了`Car`类：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The console output of this program can be analyzed as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的输出可以通过以下方式进行分析：
- en: The first set of `print` statements will output the default value of the class
    attribute, which is `Mi`.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一组`print`语句将输出类属性的默认值，即`Mi`。
- en: After executing the `car1.c_mileage_units = "km"` statement, the value of the
    class attribute will be the same (`Mi`) for the `car2` instance and the class-level
    attribute.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行了`car1.c_mileage_units = "km"`语句之后，类属性值对于`car2`实例和类级别的属性将是相同的（`Mi`）。
- en: After executing the `Car.c_mileage_units = "NP"` statement, the value of the
    class attribute for `car2` and the class level will change to `NP,` but it will
    stay the same (`km`) for `car1` as it was explicitly set by us.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行了`Car.c_mileage_units = "NP"`语句之后，`car2`和类级别的属性值将变为`NP`，但对于`car1`来说，由于我们明确设置了它，所以它将保持不变（`km`）。
- en: Important note
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: Attribute names start with `c` and `i` to indicate that they are class and instance
    variables, respectively, and not regular local or global variables. The name of
    non-public instance attributes must start with a single or double underscore to
    make them protected or private. This will be discussed later in the chapter.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 属性名以`c`和`i`开头，分别表示它们是类变量和实例变量，而不是常规的局部或全局变量。非公共实例属性的名字必须以单个或双下划线开头，以使它们成为受保护的或私有的。这一点将在本章后面讨论。
- en: Using constructors and destructors with classes
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在类中使用构造函数和析构函数
- en: 'As with any other OOP language, Python also has constructors and destructors,
    but the naming convention is different. The purpose of having constructors in
    a class is to initialize or assign values to the class- or instance-level attributes
    (mainly instance attributes) whenever an instance of a class is being created.
    In Python, the `__init__` method is known as the constructor and is always executed
    when a new instance is created. There are three types of constructors supported
    in Python, listed as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他面向对象编程语言一样，Python也有构造函数和析构函数，但命名约定不同。在类中拥有构造函数的目的是在创建类的实例时初始化或分配类或实例级别的属性（主要是实例属性）。在Python中，`__init__`方法被称为构造函数，并且总是在创建新实例时执行。Python支持三种类型的构造函数，如下所示：
- en: '`__init__` method) in a class or forget to declare it, then that class will
    use a default constructor that is empty. The constructor does nothing other than
    initialize the instance of a class.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在类中忘记声明`__init__`方法，那么该类将使用一个默认的空构造函数。构造函数除了初始化类的实例之外，不做任何事情。
- en: '`Name:` class:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Name:` 类：'
- en: '[PRE4]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`Name` class will be updated with a parameterized constructor, as follows:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Name`类将更新为带参数的构造函数，如下所示：'
- en: '[PRE5]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Destructors are the opposite of constructors—they are executed when an instance
    is deleted or destroyed. In Python, destructors are hardly used because Python
    has a garbage collector that handles the deletion of the instances that are no
    longer referenced by any other instance or program. If we need to add logic inside
    a destructor method, we can implement it by using a special `__del__` method.
    It is automatically called when all references of an instance are deleted. Here
    is the syntax of how to define a destructor method in Python:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数与构造函数相反——它们在实例被删除或销毁时执行。在Python中，析构函数几乎不使用，因为Python有一个垃圾回收器，它会处理那些不再被任何其他实例或程序引用的实例的删除。如果我们需要在析构函数方法中添加逻辑，我们可以通过使用特殊的`__del__`方法来实现。当实例的所有引用都被删除时，它会自动调用。下面是如何在Python中定义析构函数的语法：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Distinguishing between class methods and instance methods
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 区分类方法和实例方法
- en: 'In Python, we can define three types of methods in a class, which are described
    next:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们可以在类中定义三种类型的方法，下面将进行描述：
- en: '`self`) and can read and update the state of the instance. `__init__`, which
    is a constructor method, is an example of an instance method.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self`（实例本身）并可以读取和更新实例的状态。`__init__`方法，即构造函数方法，是实例方法的例子。'
- en: '`@classmethod` decorator. These methods don''t need a class instance for execution.
    For this method, the class reference (`cls` is used as a convention) will be automatically
    sent as the first argument.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@classmethod`装饰器。这些方法不需要类实例来执行。对于这个方法，类引用（`cls`是惯例）将自动作为第一个参数发送。'
- en: '`@staticmethod` decorator. They don''t have access to `cls` or `self` objects.
    Static methods are like utility functions that take certain arguments and provide
    the output based on the arguments'' values—for example, if we need to evaluate
    certain input data or parse data for processing, we can write static methods to
    achieve these goals. Static methods work like regular functions that we define
    in modules but are available in the context of the class''s namespace.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@staticmethod`装饰器。它们没有访问`cls`或`self`对象的能力。静态方法类似于我们定义在模块中的实用函数，它们根据参数的值提供输出——例如，如果我们需要评估某些输入数据或解析数据以进行处理，我们可以编写静态方法来实现这些目标。静态方法的工作方式与我们在模块中定义的常规函数类似，但它们在类的命名空间上下文中可用。'
- en: 'To illustrate how these methods can be defined and then used in Python, we
    created a simple program, which is shown next:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这些方法如何在Python中定义并使用，我们创建了一个简单的程序，下面将展示：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this program, we did the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们做了以下几件事情：
- en: We created a `Car` class with a class attribute (`c_mileage_units`), a class
    method (`print_units`), a static method (`print_hello`), instance attributes (`i_color`
    and `i_mileage`), an instance method (`print_color`), and a constructor method
    `(__init__)`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个`Car`类，其中包含类属性（`c_mileage_units`）、类方法（`print_units`）、静态方法（`print_hello`）、实例属性（`i_color`和`i_mileage`）、实例方法（`print_color`）和构造方法`(__init__)`。
- en: We created an instance of the `Car` class using its constructor as `car`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用构造函数创建了`Car`类的实例，将其命名为`car`。
- en: Using the instance variable (`car` in this example), we called the instance
    method, the class method, and the static method.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用实例变量（在这个例子中是`car`），我们调用了实例方法、类方法和静态方法。
- en: Using the class name (`Car` in this example), we again triggered the instance
    method, the class method, and the static method. Note that we can trigger the
    instance method using the class name, but we need to pass the instance variable
    as a first argument (this also explains why we need the `self` argument for each
    instance method).
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用类名（在这个例子中是`Car`），我们再次触发了实例方法、类方法和静态方法。请注意，我们可以使用类名来触发实例方法，但我们需要将实例变量作为第一个参数传递（这也解释了为什么每个实例方法都需要`self`参数）。
- en: 'The console output of this program is shown next for reference:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的程序控制台输出如下，仅供参考：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Special methods
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊方法
- en: 'When we define a class in Python and try to print one of its instances using
    a `print` statement, we will get a string containing the class name and the reference
    of the object instance, which is the object''s memory address. There is no default
    implementation of the `to string` functionality available with an instance or
    object. The code snippet showing this behavior is presented here:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Python中定义一个类并尝试使用`print`语句打印其实例时，我们将得到一个包含类名和对象实例引用的字符串，即对象的内存地址。实例或对象没有默认的`to
    string`功能实现。下面展示了这种行为的一个代码片段：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will get console output similar to the following, which is not what is expected
    from a `print` statement:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到类似于以下内容的控制台输出，这不是`print`语句预期的结果：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To get something meaningful from a `print` statement, we need to implement
    a special `__str__` method that will return a string with information about the
    instance and that can be customized as needed. Here is a code snippet showing
    the `carexample4.py` file with the `__str__` method:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要从`print`语句中获得有意义的内容，我们需要实现一个特殊的`__str__`方法，该方法将返回包含实例信息的字符串，并且可以根据需要自定义。下面是一个代码片段，展示了包含`__str__`方法的`carexample4.py`文件：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And the console output of the `print` statement is shown here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 下面展示了`print`语句的控制台输出：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With a proper `__str__` implementation, we can use a `print` statement without
    implementing special functions such as `to_string()`. It is the Pythonic way to
    control the string conversion. Another popular method used for similar reasons
    is `__repr__`, which is used by a Python interpreter for inspecting an object.
    The `__repr__` method is more for debugging purposes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过适当的`__str__`实现，我们可以使用`print`语句而不需要实现特殊的函数，如`to_string()`。这是Python控制字符串转换的Pythonic方式。出于类似原因，另一个流行的方法是`__repr__`，它被Python解释器用于检查对象。`__repr__`方法主要用于调试目的。
- en: These methods (and a few more) are called special methods or **dunders**, as
    they always start and end with double underscores. Normal methods should not use
    this convention. These methods are also known as magic **methods** in some literature,
    but it is not the official terminology. There are several dozen special methods
    available for implementation with a class. A comprehensive list of special methods
    is available with the official Python 3 documentation at https://docs.python.org/3/reference/datamodel.html#specialnames.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法（以及一些其他方法）被称为特殊方法或**双下划线方法**，因为它们总是以双下划线开始和结束。普通方法不应使用此约定。在某些文献中，这些方法也被称为**魔法方法**，但这不是官方术语。类实现中有几十种特殊方法可供使用。官方Python
    3文档中提供了特殊方法的完整列表，网址为https://docs.python.org/3/reference/datamodel.html#specialnames。
- en: We reviewed the classes and the objects with code examples in this section.
    In the next section, we will study different object-oriented principles available
    in Python.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们通过代码示例回顾了类和对象。在下一节中，我们将研究Python中可用的不同面向对象原则。
- en: Understanding OOP principles
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解面向对象原则
- en: 'OOP is a way of bundling properties and behavior into a single entity, which
    we call objects. To make this bundling more efficient and modular, there are several
    principles available in Python, outlined as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）是将属性和行为捆绑到单个实体中的方法，我们称之为对象。为了使这种捆绑更高效和模块化，Python中有几个原则可用，如下所述：
- en: Encapsulation of data
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据封装
- en: Inheritance
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承
- en: Polymorphism
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态
- en: Abstraction
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象
- en: In the next subsections, we will study each of these principles in detail.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的小节中，我们将详细研究这些原则。
- en: Encapsulation of data
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据封装
- en: 'Encapsulation is a fundamental concept in OOP and is also sometimes referred
    to as abstraction. But in reality, the encapsulation is more than the abstraction.
    In OOP, bundling of data and the actions associated with the data into a single
    unit is known as encapsulation. Encapsulation is actually more than just bundling
    data and the associated actions. We can enumerate three main objectives of encapsulation
    here, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 封装是面向对象编程中的基本概念，有时也被称为抽象。但在现实中，封装不仅仅是抽象。在面向对象编程中，将数据及其相关动作捆绑到单个单元中称为封装。封装实际上不仅仅是捆绑数据和相关的动作。我们在这里可以列举封装的三个主要目标，如下所示：
- en: Encompass data and associated actions in a single unit.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据和相关的动作封装在一个单元中。
- en: Hide the internal structure and implementation details of the object.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏对象的内部结构和实现细节。
- en: Restrict access to certain components (attributes or methods) of the object.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制对对象某些组件（属性或方法）的访问。
- en: Encapsulation simplifies the use of the objects without knowing internal details
    on how it is implemented, and it also helps to control updates to the state of
    the object.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 封装简化了对象的使用，无需了解其内部实现的细节，并且还有助于控制对象状态更新的更新。
- en: In the next subsections, we will discuss these objectives in detail.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的小节中，我们将详细讨论这些目标。
- en: Encompassing data and actions
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封装数据和动作
- en: 'To encompass data and actions in one init, we define attributes and methods
    in a class. A class in Python can have the following types of elements:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在一个初始化中包含数据和动作，我们在类中定义属性和方法。Python中的类可以有以下类型的元素：
- en: Constructor and destructor
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数和析构函数
- en: Class methods and attributes
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类方法和属性
- en: Instance methods and attributes
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例方法和属性
- en: '**Nested** classes'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**嵌套**类'
- en: We have discussed these class elements already in the previous section, except
    nested or **inner** classes. We already provided the Python code examples to illustrate
    the implementation of constructors and destructors. We have used instance attributes
    to encapsulate data in our instances or objects. We have also discussed the class
    methods, static methods, and class attributes with code examples in the previous
    section.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上一节中讨论了这些类元素，除了嵌套或**内部**类。我们已经提供了Python代码示例来展示构造函数和析构函数的实现。我们已经在上一节中通过实例属性封装了数据在我们的实例或对象中。我们还讨论了类方法、静态方法和类属性，并提供了代码示例。
- en: 'To complete the topic, we will discuss the following Python code snippet with
    a nested class. Let''s take an example of our `Car` class and an `Engine` inner
    class within it. Every car needs an engine, so it makes sense to make it a nested
    or inner class:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个主题，我们将使用嵌套类的Python代码片段进行讨论。让我们以我们的`Car`类及其内部的`Engine`内部类为例。每辆车都需要一个引擎，因此将其作为嵌套或内部类是有意义的：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this example, we defined an `Engine` inner class inside our regular `Car`
    class. The `Engine` class has only one attribute—`i_size`, the constructor method
    (`__init__)`, and the `__str__` method. For the `Car` class, we updated the following
    as compared to our previous examples:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在常规的`Car`类内部定义了一个`Engine`内部类。`Engine`类只有一个属性—`i_size`，构造方法（`__init__`）和`__str__`方法。与之前的示例相比，我们对`Car`类进行了以下更新：
- en: The `__init__` method includes a new attribute for engine size, and a new line
    has been added to create a new instance of `Engine` associated with the `Car`
    instance.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__`方法包括一个新的引擎尺寸属性，并添加了一行来创建与`Car`实例关联的`Engine`实例的新实例。'
- en: The `__str__` method of the `Car` class includes the `i_size` inner class attributes
    in it.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Car`类的`__str__`方法包括`i_size`内部类属性。'
- en: 'The main program is using a `print` statement on the `Car` instance and also
    has a line to print the value of the `i_size` attribute of the `Engine` class.
    The console output of this program will be similar to what is shown here:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 主程序在`Car`实例上使用`print`语句，并且还有一行用于打印`Engine`类的`i_size`属性值。该程序的控制台输出将类似于以下内容：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The console output of the main program shows that we have access to the inner
    class from within the class implementation and we can access the inner class attributes
    from outside.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 主程序的控制台输出显示，我们可以在类实现内部访问内部类，并且我们可以从外部访问内部类的属性。
- en: In the next subsection, we will discuss how we can hide some of the attributes
    and methods to not be accessible or visible from outside the class.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，我们将讨论如何隐藏一些属性和方法，以便它们在类外部不可访问或不可见。
- en: Hiding information
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐藏信息
- en: 'We have seen in our previous code examples that we have access to all class-level
    as well as instance-level attributes without any restrictions. Such an approach
    led us to a flat design, and the class will simply become a wrapper around the
    variables and methods. A better object-oriented design approach is to hide some
    of the instance attributes and make only the necessary attributes visible to the
    outside world. To discuss how this is achieved in Python, we introduce two terms:
    **private** and **protected**.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的代码示例中，我们已经看到我们可以无限制地访问所有类级别以及实例级别的属性。这种做法导致我们采用了扁平化设计，类将简单地成为变量和方法的包装器。更好的面向对象设计方法是将一些实例属性隐藏起来，只让必要的属性对外部世界可见。为了讨论在Python中如何实现这一点，我们引入了两个术语：**私有**和**保护**。
- en: Private variables and methods
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 私有变量和方法
- en: A private **variable** or attribute can be defined by using a double *underscore*
    as a prefix before a variable name. In Python, there is no keyword such as *private,*
    as we have in other programming languages. Both class and instance variables can
    be marked as private.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在变量名前使用双下划线作为前缀来定义一个私有变量或属性。在Python中，没有像其他编程语言中那样的*private*关键字。类和实例变量都可以标记为私有。
- en: A private **method** can also be defined by using a double *underscore* before
    a method name. A private method can only be called within the class and is not
    available outside the class.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在方法名前使用双下划线来定义一个私有方法。私有方法只能在类内部调用，且在类外部不可用。
- en: Whenever we define an attribute or a method as private, the Python interpreter
    doesn't allow access for such an attribute or a method outside of the class definition.
    The restriction also applies to subclasses; therefore, only the code within a
    class can access such attributes and methods.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们定义一个属性或方法为私有时，Python解释器不允许在类定义外部访问这样的属性或方法。这种限制也适用于子类；因此，只有类内部的代码可以访问这些属性和方法。
- en: Protected variables and methods
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 受保护的变量和方法
- en: A `i_color` attribute from a public to a protected attribute, we just need to
    change its name to `_i_color`. The Python interpreter does not enforce this usage
    of the protected elements within a class or subclass. It is more to honor the
    naming convention and use or access the attribute or methods as per the definition
    of the protected variables and methods.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 将`i_color`属性从公共属性更改为保护属性，我们只需将其名称更改为`_i_color`。Python解释器不会在类或子类内部强制执行这种保护元素的用法。这更多的是为了遵守命名约定，并按照保护变量和方法定义使用或访问属性或方法。
- en: 'By using private and protected variables and methods, we can hide some of the
    details of the implementation of an object. This is helpful, enabling us to have
    a tight and clean source code inside a large-sized class without exposing everything
    to the outside world. Another reason for hiding attributes is to control the way
    they can be accessed or updated. This is a topic for the next subsection. To conclude
    this section, we will discuss an updated version of our `Car` class with private
    and protected variables and a private method, which is shown next:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用私有和保护变量和方法，我们可以隐藏对象实现的一些细节。这有助于我们在大型类内部拥有紧密和干净的源代码，而不将一切暴露给外部世界。隐藏属性的另一个原因是为了控制它们可以如何被访问或更新。这是下一小节的主题。为了总结本节，我们将讨论一个带有私有和保护变量以及私有方法的`Car`类的更新版本，如下所示：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this updated `Car` class, we have updated or added the following as per
    the previous example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个更新的`Car`类中，我们根据之前的示例更新或添加了以下内容：
- en: A private `__max_speed` class variable with a default value
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有默认值的私有类变量`__max_speed`
- en: A private `__no_doors` instance variable with a default value inside the `__init__`
    constructor method
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`__init__`构造方法内部有一个默认值的私有实例变量`__no_doors`
- en: A `_model` protected instance variable, added for illustration purposes only
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅用于说明目的的受保护实例变量`_model`
- en: A `__doors()` private instance method to get the number of doors
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于获取门数的私有实例方法`__doors()`
- en: The `__str__` method is updated to get the door by using the `__doors()` private
    method
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__str__` 方法已更新，通过使用 `__doors()` 私有方法来获取门'
- en: The console output of this program works as expected, but if we try to access
    any of the private methods or private variables from the main program, it is not
    available, and the Python interpreter will throw an error. This is as per the
    design, as the intended purpose of these private variables and private methods
    is to be only available within a class.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的控制台输出按预期工作，但如果尝试从主程序访问任何私有方法或私有变量，则不可用，Python 解释器将抛出错误。这是按照设计，因为这些私有变量和私有方法的目的仅限于在类内部使用。
- en: Important note
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Python does not really make the variables and methods private, but it pretends
    to make them private. Python actually mangles the variable names with the class
    name so that they are not easily visible outside the class that contains them.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Python 并没有真正使变量和方法成为私有的，但它假装使它们成为私有的。Python 实际上通过将类名与变量名混合来打乱变量名，这样它们就不容易在包含它们的类外部可见。
- en: For the `Car` class example, we can access the private variables and private
    methods. Python provides access to these attributes and methods outside of the
    class definition with a different attribute name that is composed of a leading
    underscore, followed by the class name, and then a private attribute name. In
    the same way, we can access the private methods as well.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Car` 类的示例，我们可以访问私有变量和私有方法。Python 通过使用一个以单下划线开头，后跟类名，然后是私有属性名的不同属性名，在类定义之外提供对这些属性和方法访问。同样，我们也可以访问私有方法。
- en: 'The following lines of codes are valid but not encouraged and are against the
    definition of private and protected:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行是有效的，但不推荐，并且违反了私有和受保护的定义：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we can see, `_Car` is appended before the actual private variable name. This
    is done to minimize the conflicts with variables in inner classes as well.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`_Car` 被附加到实际的私有变量名之前。这样做是为了最小化与内部类中变量的冲突。
- en: Protecting the data
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护数据
- en: We have seen in our previous code examples that we can access the instance attributes
    without any restrictions. We also implemented instance methods and we have no
    restriction on the use of these. We emulate to define them as private or protected,
    which works to hide the data and actions from the outside world.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的代码示例中，我们看到了我们可以无限制地访问实例属性。我们还实现了实例方法，对这些方法的使用没有限制。我们模拟定义它们为私有或受保护的，这样可以隐藏数据和行为对外部世界。
- en: 'But in real-world problems, we need to provide access to the variables in a
    way that is controllable and easy to maintain. This is achieved in many object-oriented
    languages through **access modifiers** such as getters and setters, which are
    defined next:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 但在现实世界的问题中，我们需要以可控和易于维护的方式提供对变量的访问。这在许多面向对象的语言中通过 **访问修饰符**（如获取器和设置器）来实现，这些将在下面定义：
- en: '**Getters**: These are methods used to access the private attributes from a
    class or its instance'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取器**：这些是用于从类或其实例访问私有属性的方法'
- en: '**Setters**: These are methods used to set the private attributes of a class
    or its instance.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置器**：这些是用于设置类或其实例的私有属性的方法。'
- en: 'Getters and setters methods can also be used to implement additional logic
    of accessing or setting the attributes, and it is convenient to maintain such
    an additional logic in one place. There are two ways to implement the getters
    and setters methods: a *traditional way* and a *decorative* way.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 获取器和设置器方法也可以用来实现访问或设置属性的额外逻辑，并且在一个地方维护这样的额外逻辑是方便的。实现获取器和设置器方法有两种方式：一种 *传统方式*
    和一种 *装饰性方式*。
- en: Using traditional getters and setters
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用传统获取器和设置器
- en: 'Traditionally, we write the instance methods with a `get` and `set` prefix,
    followed by the underscore and the variable name. We can transform our `Car` class
    to use the getter and setter methods for instance attributes, as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，我们使用 `get` 和 `set` 前缀编写实例方法，后跟下划线和变量名。我们可以将我们的 `Car` 类转换为使用实例属性的获取器和设置器方法，如下所示：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this updated `Car` class, we added the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个更新的 `Car` 类中，我们添加了以下内容：
- en: '`color` and `mileage` instance attributes were added as private variables.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`color` 和 `mileage` 实例属性被添加为私有变量。'
- en: Getter methods for `color` and `mileage` instance attributes.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`color` 和 `mileage` 实例属性的获取器方法。'
- en: A setter method only for the `mileage` attribute because `color` usually doesn't
    change once it is set at the time of object creation.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅针对`mileage`属性设置setter方法，因为`color`属性通常在对象创建时设置后不会改变。
- en: In the main program, we get data for the newly created instance of the class
    using getter methods. Next, we updated the mileage using a setter method, and
    then we got data again for the `color` and `mileage` attributes.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主程序中，我们使用getter方法获取新创建的类的实例数据。接下来，我们使用setter方法更新里程数，然后再次获取`color`和`mileage`属性的数据。
- en: The console output of each statement in this example is trivial and as per expectations.
    As mentioned, we did not define a setter for each attribute, but only for those
    attributes where it makes sense and the design demands. Using getters and setters
    is a best practice in OOP, but they are not very popular in Python. The culture
    of Python developers (also known as the Pythonic way) is still to access attributes
    directly.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，每个语句的控制台输出都是微不足道的，符合预期。正如提到的，我们没有为每个属性定义setter，而只为那些有意义的属性和设计要求定义了setter。在面向对象编程（OOP）中，使用getter和setter是一种最佳实践，但在Python中并不十分流行。Python开发者的文化（也称为Pythonic方式）仍然是直接访问属性。
- en: Using property decorators
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用属性装饰器
- en: Using a **decorator** to define getters and setters is a modern approach that
    helps to achieve the Python way of programming.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**装饰器**来定义getter和setter是一种现代方法，有助于实现Python编程方式。
- en: 'If you are into using decorators, then we have a `@property` decorator in Python
    to make the code simpler and cleaner. The `Car` class with traditional getters
    and setters is updated with decorators, and here is a code snippet showing this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢使用装饰器，那么Python中有一个`@property`装饰器，可以使代码更简洁、更清晰。传统的带有getter和setter的`Car`类通过装饰器进行了更新，以下是一个代码片段，展示了这一点：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this updated class definition, we updated or added the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个更新的类定义中，我们更新或添加了以下内容：
- en: Instance attributes as private variables
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例属性作为私有变量
- en: Getter methods for `color` and `mileage` by using the name of the attribute
    as the method name and using `@property`
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性名作为方法名和`@property`来为`color`和`mileage`设置getter方法
- en: Setter methods for `mileage` using the `@mileage.setter` decorator, giving the
    method the same name as the name of the attribute
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`@mileage.setter`装饰器为`mileage`设置setter方法，使方法名与属性名相同
- en: In the main script, we access the color and the mileage attributes by using
    the instance name followed by a dot and the attribute name (the Pythonic way).
    This makes the code syntax concise and readable. The use of decorators also makes
    the name of the methods simpler.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在主脚本中，我们通过使用实例名称后跟一个点和属性名称（Pythonic方式）来访问颜色和里程数属性。这使得代码语法简洁易读。装饰器的使用也使得方法名称更简单。
- en: In conclusion, we discussed all aspects of encapsulation in Python, using classes
    for the bundling of data and actions, hiding unnecessary information from the
    outside world of a class, and how to protect data in a class using getters, setters,
    and property features of Python. In the next section, we will discuss how inheritance
    is implemented in Python.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们讨论了Python中封装的所有方面，包括使用类来捆绑数据和动作，隐藏类外部世界中的不必要信息，以及如何使用Python的getter、setter和属性特性来保护类中的数据。在下一节中，我们将讨论Python中继承的实现方式。
- en: Extending classes with inheritance
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用继承扩展类
- en: The concept of inheritance in OOP is similar to the concept of inheritance in
    the real world, where children inherit some of the characteristics from their
    parents on top of their own characteristics.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）中的继承概念与现实生活中继承的概念相似，即子女在拥有自己特征的基础上，从父母那里继承了一些特征。
- en: 'Similarly, a class can inherit elements from another class. These elements
    include attributes and methods. The class from which we inherit another class
    is commonly known as a parent class, a **superclass**, or a **base** class. The
    class we inherit from another class is called a **derived** **class**, a **child**
    **class**, or a **subclass**. The following screenshot shows a simple relationship
    between a parent class and a child class:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，一个类可以继承另一个类的元素。这些元素包括属性和方法。我们从其中继承另一个类的类通常被称为父类、**超类**或**基类**。从另一个类继承的类被称为**派生类**、**子类**或**子类**。以下截图显示了父类和子类之间简单的关系：
- en: '![Figure 3.1 – Parent-and-child class relationship'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1 – 父类和子类关系'
- en: '](img/B17189_03_01.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17189_03_01.jpg)'
- en: Figure 3.1 – Parent-and-child class relationship
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 父类和子类关系
- en: In Python, when a class inherits from another class, it typically inherits all
    the elements that compose the parent class, but this can be controlled by using
    naming conventions (such as double underscore) and access modifiers.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，当一个类从另一个类继承时，它通常会继承构成父类的所有元素，但可以通过使用命名约定（如双下划线）和访问修饰符来控制这一点。
- en: 'Inheritance can be of two types: **simple** or **multiple**. We will discuss
    these in the next sections.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 继承可以分为两种类型：**简单**或**多重**。我们将在下一节中讨论这些内容。
- en: Simple inheritance
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单继承
- en: 'In simple or basic inheritance, a class is derived from a single parent. This
    is a commonly used inheritance form in OOP and is closer to the family tree of
    human beings. The syntax of a parent class and a child class using simple inheritance
    is shown next:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单或基本继承中，一个类是从单个父类派生出来的。这是面向对象编程中常用的一种继承形式，更接近人类的家谱。使用简单继承的父类和子类的语法如下所示：
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For this simple inheritance, we will modify our example of the `Car` class
    so that it is derived from a `Vehicle` parent class. We will also add a `Truck`
    child class to elaborate on the concept of inheritance. Here is the code with
    modifications:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种简单继承，我们将修改我们的`Car`类示例，使其从`Vehicle`父类派生。我们还将添加一个`Truck`子类来阐述继承的概念。以下是修改后的代码：
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this example, we created a `Vehicle` parent class with one `i_color` attribute
    and one `print_vehicle_info` method. Both the elements are a candidate for inheritance.
    Next, we created two child classes, `Car` and `Truck`. Each child class has one
    additional attribute (`i_seats` and `i_capacity`) and one additional method (`print_me`).
    In the `print_me` methods in each child class, we access the parent class instance
    attribute as well as child class instance attributes.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个具有一个`i_color`属性和一个`print_vehicle_info`方法的`Vehicle`父类。这两个元素都是继承的候选者。接下来，我们创建了两个子类，`Car`和`Truck`。每个子类都有一个额外的属性（`i_seats`和`i_capacity`）和一个额外的属性（`print_me`）。在每个子类的`print_me`方法中，我们访问父类实例属性以及子类实例属性。
- en: This design was intentional, to elaborate the idea of inheriting some elements
    from the parent class and adding some elements of its own in a child class. The
    two child classes are used in this example to demonstrate the role of inheritance
    toward reusability.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计是有意为之，为了阐述从父类继承一些元素并在子类中添加一些元素的想法。在这个例子中，使用两个子类来演示继承在可重用性方面的作用。
- en: 'In our main program, we created `Car` and `Truck` instances and tried to access
    the parent method as well as the instance method. The console output of this program
    is as expected and is shown next:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主程序中，我们创建了`Car`和`Truck`实例，并尝试访问父类方法以及实例方法。该程序的控制台输出符合预期，如下所示：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Multiple inheritance
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多重继承
- en: In multiple inheritance, a child class can be derived from multiple parents.
    The concept of multiple inheritance is applicable in advanced object-oriented
    designs where the objects have relationships with multiple objects, but we must
    be careful when inheriting from multiple classes, especially if those classes
    are inherited from a common superclass. This can lead us to problems such as the
    diamond problem. The diamond problem is a situation when we create an `X` class
    by inheriting from two classes, `Y` and `Z`, and the `Y` and `Z` classes are inherited
    from a common class, `A`. The `X` class will have ambiguity about the common code
    of the `A` class, which it inherits from classes `Y` and `Z`.  Multiple inheritance
    is not encouraged because of the possible issues it can bring with it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在多重继承中，一个子类可以从多个父类派生。多重继承的概念适用于高级面向对象设计，其中对象与多个对象有关联，但当我们从多个类继承时，我们必须小心，尤其是如果这些类是从一个共同的超类继承的。这可能导致诸如菱形问题等问题。菱形问题是在我们通过从两个类`Y`和`Z`继承来创建一个`X`类的情况下出现的，而`Y`和`Z`类又是从共同的类`A`继承的。`X`类将对其从类`Y`和`Z`继承的`A`类的公共代码产生歧义。由于多重继承可能带来的问题，我们不鼓励使用多重继承。
- en: 'To illustrate the concept, we will modify our `Vehicle` and `Car` classes and
    we will add an `Engine` class as one of the parents. The complete code with multiple
    inheritance of classes is shown in the following snippet:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个概念，我们将修改我们的`Vehicle`和`Car`类，并添加一个`Engine`类作为其中一个父类。以下是一个包含类多重继承的完整代码片段：
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this multiple inheritance example, we created two parent classes as a parent:
    `Vehicle` and `Engine`. The `Vehicle` parent class is the same as in the previous
    example. The `Engine` class has one attribute (`i_size`) and one method (`print_engine_info`).
    The `Car` class is derived from both `Vehicle` and `Engine` and adds one additional
    attribute (`i_seats`) and one additional method (`print_car_info`). In the instance
    method, we can access instance attributes of both parent classes.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个多重继承的例子中，我们创建了两个父类作为父类：`Vehicle`和`Engine`。`Vehicle`父类与前面的例子相同。`Engine`类有一个属性（`i_size`）和一个方法（`print_engine_info`）。`Car`类从`Vehicle`和`Engine`继承而来，并添加了一个额外的属性（`i_seats`）和一个额外的方法（`print_car_info`）。在实例方法中，我们可以访问父类的实例属性。
- en: 'In the main program, we created an instance of the `Car` class. With this instance,
    we can access the instance methods of parent classes as well as child classes.
    The console output of the main program is shown here and is as expected:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在主程序中，我们创建了`Car`类的一个实例。使用这个实例，我们可以访问父类以及子类的实例方法。以下是主程序的控制台输出，如图所示，符合预期：
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this section, we introduced inheritance and its types as simple and multiple.
    Next, we will study the concept of polymorphism in Python.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了继承及其类型，即简单继承和多重继承。接下来，我们将研究 Python 中的多态概念。
- en: Polymorphism
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态
- en: In its literal meaning, a process of having multiple forms is called polymorphism.
    In OOP, **polymorphism** is the ability of an instance to behave in multiple ways
    and a way to use the same method with the same name and the same arguments, to
    behave differently in accordance with the class it belongs to.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在其字面意义上，具有多种形式的过程称为多态。在面向对象编程（OOP）中，**多态**是指实例能够以多种方式表现的能力，以及使用具有相同名称和相同参数的相同方法，根据所属的类以不同的方式表现。
- en: 'Polymorphism can be implemented in two ways: **method overloading** and **method**
    **overriding**. We will discuss each in the next subsections.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 多态可以通过两种方式实现：**方法重载**和**方法重写**。我们将在下一小节中分别讨论。
- en: Method overloading
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法重载
- en: Method overloading is a way to achieve polymorphism by having multiple methods
    with the same name, but with a different type or number of arguments. There is
    no clean way to implement method overloading in Python. Two methods cannot have
    the same name in Python. In Python, everything is an object, including classes
    and methods. When we write methods for a class, they are in fact attributes of
    a class from the namespace perspective and thus cannot have the same name. If
    we write two methods with the same name, there will be no syntax error, and the
    second one will simply replace the first one.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 方法重载是通过拥有多个具有相同名称但具有不同类型或参数数量来达到多态的一种方式。在 Python 中实现方法重载没有干净利落的方法。Python 中两个方法不能有相同的名称。在
    Python 中，一切都是对象，包括类和方法。当我们为类编写方法时，实际上它们是从命名空间的角度来看的类的属性，因此不能有相同的名称。如果我们编写两个具有相同名称的方法，将不会出现语法错误，第二个方法将简单地替换第一个方法。
- en: 'Inside a class, a method can be overloaded by setting the default value to
    the arguments. This is not the perfect way of implementing method overloading,
    but it works. Here is an example of method overloading inside a class in Python:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在类内部，可以通过设置参数的默认值来重载方法。这不是实现方法重载的完美方式，但它是可行的。以下是在 Python 类内部实现方法重载的示例：
- en: '[PRE24]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In this example, we add a `print_me` method with an argument that has a default
    value. The default value will be used when no parameter will be passed. When no
    parameter is passed to the `print_me` method, the console output will only provide
    the color of the `Car` instance. When an argument is passed to this method (regardless
    of the value), we have a different behavior of this method, which is providing
    both the color and the number of seats of the `Car` instance. Here is the console
    output of this program for reference:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们添加了一个具有默认值的参数的`print_me`方法。如果没有传递参数，将使用默认值。当没有传递参数给`print_me`方法时，控制台输出将只提供`Car`实例的颜色。当传递参数给此方法（无论值如何）时，我们将有此方法的不同行为，即提供`Car`实例的颜色和座位数。以下是此程序的参考控制台输出：
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Important note
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: There are third-party libraries (for example, `overload`) available that can
    be used to implement method overloading in a cleaner way.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有可用的第三方库（例如，`overload`），可以用来以更干净的方式实现方法重载。
- en: Method overriding
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法重写
- en: Having the same method name in a child class as in a parent class is known as
    method overriding. The implementation of a method in a parent class and a child
    class is expected to be different. When we call an overriding method on an instance
    of a child class, the Python interpreter looks for the method in the child class
    definition, which is the overridden method. The interpreter executes the child
    class-level method. If the interpreter does not find a method at a child instance
    level, it looks for it in a parent class. If we have to specifically execute a
    method in a parent class that is overridden in a child class using the child class
    instance, we can use the `super()` method to access the parent class-level method.
    This is a more popular polymorphism concept in Python as it goes hand in hand
    with inheritance and is one of the powerful ways of implementing inheritance.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在子类和父类中拥有相同的方法名称被称为方法重写。父类和子类中方法的实现预期应该是不同的。当我们对一个子类的实例调用重写方法时，Python解释器会在子类定义中查找该方法，即被重写的方法。解释器会执行子类级别的该方法。如果解释器在子类实例级别找不到方法，它会在父类中查找。如果我们必须使用子类实例来特别执行在子类中被重写的父类方法，我们可以使用`super()`方法来访问父类级别的该方法。这是Python中更受欢迎的多态概念之一，因为它与继承紧密相关，并且是实现继承的强大方式之一。
- en: 'To illustrate how to implement method overriding, we will update the `inhertance1.py`
    snippet by renaming the `print_vehicle_info` method name as `print_me`. As we
    know, `print_me` methods are already in the two child classes with different implementations.
    Here is the updated code with the changes highlighted:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何实现方法重写，我们将通过将`print_vehicle_info`方法名称重命名为`print_me`来更新`inhertance1.py`代码片段。正如我们所知，`print_me`方法已经在两个子类中存在，并且有不同的实现。以下是带有更改高亮的更新代码：
- en: '[PRE26]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In this example, we override the `print_me` method in the child classes. When
    we create three different instances of `Vehicle`, `Car`, and `Truck` classes and
    execute the same method, we get different behavior. Here is the console output
    as a reference:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在子类中重写了`print_me`方法。当我们创建三个不同实例的`Vehicle`、`Car`和`Truck`类，并执行相同的方法时，我们得到不同的行为。以下是作为参考的控制台输出：
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Method overriding has many practical applications in real-world problems—for
    example, we can inherit the built-in `list` class and can override its methods
    to add our functionality. Introducing a custom *sorting* approach is an example
    of method overriding for a `list` object. We will cover a few examples of method
    overriding in the next chapters.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 方法重写在现实世界问题中有许多实际应用——例如，我们可以继承内置的`list`类，并可以重写其方法以添加我们的功能。引入自定义的*排序*方法是一个对`list`对象进行方法重写的例子。我们将在下一章中介绍方法重写的几个示例。
- en: Abstraction
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象
- en: Abstraction is another powerful feature of OOP and is mainly related to hide
    the details of the implementation and show only the essential or high-level features
    of an object. A real-world example is a car that we derive with the main features
    available to us as a driver, without knowing the real details of how the feature
    works and which other objects are involved to provide these features.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象是面向对象编程（OOP）的另一个强大特性，主要与隐藏实现细节和仅展示对象的本质或高级特性相关。一个现实世界的例子是我们通过抽象得到的汽车，作为驾驶员，我们拥有作为驾驶员可用的主要功能，而不需要知道这些功能是如何工作的真实细节以及哪些其他对象参与提供这些功能。
- en: Abstraction is a concept that is related to encapsulation and inheritance together,
    and that is why we have kept this topic till the end to understand encapsulation
    and inheritance first. Another reason for having this as a separate topic is to
    emphasize the use of abstract classes in Python.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象是一个与封装和继承相关的概念，这也是为什么我们将这个主题留到最后的理由，以便首先理解封装和继承。将这个主题作为一个独立主题的另一个原因是强调在Python中使用抽象类。
- en: Abstract classes in Python
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python中的抽象类
- en: An abstract class acts like a blueprint for other classes. An abstract class
    allows you to create a set of abstract methods (empty) that are to be implemented
    by a child class. In simple terms, a class that contains one or more abstract
    methods is called an abstract **class**. On the other hand, an abstract **method**
    is one that only has a declaration but no implementation.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类就像其他类的蓝图。抽象类允许你创建一组抽象方法（空方法），这些方法需要子类来实现。简单来说，包含一个或多个抽象方法的类被称为抽象**类**。另一方面，抽象**方法**是指只有声明而没有实现的方法。
- en: There can be methods in an abstract class that are already implemented and that
    can be leveraged by a child class (*as is*) using inheritance. The concept of
    abstract classes is useful to implement common interfaces such as **application
    programming interfaces** (**APIs**) and also to define a common code base in one
    place that can be reused by child classes.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类中可以有已经实现的方法，这些方法可以通过继承被子类（*如原样*）利用。抽象类的概念对于实现常见的接口，如**应用程序编程接口**（**API**），以及定义一个可以在子类中重用的公共代码库非常有用。
- en: Tip
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Abstract classes cannot be instantiated.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类不能被实例化。
- en: 'An abstract class can be implemented using a Python built-in module called
    `abc` package. The `abc` package also includes the `Abstractmethod` module, which
    utilizes decorators to declare the abstract methods. A simple Python example with
    the use of the `ABC` module and the `abstractmethod` decorator is shown next:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类可以使用Python的一个内置模块`abc`包来实现。`abc`包还包括`Abstractmethod`模块，它使用装饰器来声明抽象方法。下面是一个简单的Python示例，展示了使用`ABC`模块和`abstractmethod`装饰器的用法：
- en: '[PRE28]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In this example, we did the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们做了以下操作：
- en: We made the `Vehicle` class abstract by inheriting it from the `ABC` class and
    also by declaring one of the methods (`print_me`) as an abstract method. We used
    the `@abstractmethod` decorator to declare an abstract method.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过从`ABC`类继承并声明其中一个方法（`print_me`）为抽象方法，使`Vehicle`类成为抽象类。我们使用`@abstractmethod`装饰器来声明抽象方法。
- en: Next, we updated our famous `Car` class by implementing the `print_me` method
    in it and keeping the rest of the code the same as in the previous example.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们通过在它中实现`print_me`方法并保持其余代码与上一个示例相同，更新了我们著名的`Car`类。
- en: In the main part of the program, we attempted to create an instance of the `Vehicle`
    class (code commented in the illustration). We created an instance of the `Car`
    class and executed the `print_me` and `hello` methods.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在程序的主要部分，我们尝试创建`Vehicle`类的一个实例（如图所示中的注释代码）。我们创建了一个`Car`类的实例并执行了`print_me`和`hello`方法。
- en: 'When we attempt to create an instance of the `Vehicle` class, it gives us an
    error like this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试创建`Vehicle`类的一个实例时，它会给我们一个如下错误：
- en: '[PRE29]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Also, if we try to not implement the `print_me` method in the `Car` child class,
    we get an error. For an instance of the `Car` class, we get the expected console
    output from the `print_me` and `hello` methods.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们尝试不在`Car`子类中实现`print_me`方法，我们会得到一个错误。对于`Car`类的一个实例，我们从`print_me`和`hello`方法得到预期的控制台输出。
- en: Using composition as an alternative design approach
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用组合作为替代的设计方法
- en: 'Composition is another popular concept in OOP that is again somewhat relevant
    to encapsulation. In simple words, composition means to include one or more objects
    inside an object to form a real-world object. A class that includes other class
    objects is called a **composite** class, and the classes whose objects are included
    in a composite class are known as **component** classes. In the following screenshot,
    we show an example of a composite class that has three component class objects,
    **A**, **B**, and **C**:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 组合是面向对象编程中另一个流行的概念，它再次与封装有些相关。简单来说，组合意味着在一个对象内部包含一个或多个对象以形成一个现实世界的对象。包含其他类对象的类被称为**组合类**，而其对象包含在组合类中的类被称为**组件类**。在下面的屏幕截图中，我们展示了一个具有三个组件类对象**A**、**B**和**C**的组合类示例：
- en: '![Figure 3.2 – Relationship between a composite class and its component classes](img/B17189_03_02.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – 组合类与其组件类之间的关系](img/B17189_03_02.jpg)'
- en: Figure 3.2 – Relationship between a composite class and its component classes
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 组合类与其组件类之间的关系
- en: Composition is considered an alternative approach to inheritance. Both design
    approaches are meant to establish a relationship between objects. In the case
    of inheritance, the objects are tightly coupled because any changes in parent
    classes can break the code in child classes. On the other hand, the objects are
    loosely coupled in the case of composition, which facilitates changes in one class
    without breaking our code in another class. Because of the flexibility, the composition
    approach is quite popular, but this does not mean it is the right choice for every
    problem. How, then, can we determine which one to use for which problem? There
    is a rule of thumb for this. When we have an *is a* relationship between objects,
    inheritance is the right choice—for example, a car *is a* vehicle, and a cat *is
    an* animal. In the case of inheritance, a child class is an extension of a parent
    class, with additional functionality and the ability to reuse parent class functionality.
    If the relation between objects is that one object *has* another object, then
    it is better to use composition—for example, a car *has* a battery.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 组合被认为是继承的替代方法。这两种设计方法都是为了在对象之间建立关系。在继承的情况下，对象之间是紧密耦合的，因为父类中的任何更改都可能导致子类中的代码出错。另一方面，在组合的情况下，对象之间是松散耦合的，这有助于在一个类中进行更改而不会破坏另一个类中的代码。由于灵活性，组合方法相当受欢迎，但这并不意味着它是每个问题的正确选择。那么，我们如何确定在哪个问题中使用哪个呢？这里有一个经验法则。当我们有对象之间的“是一个”关系时，继承是正确的选择——例如，汽车“是一个”车辆，猫“是一个”动物。在继承的情况下，子类是父类的扩展，具有额外的功能以及重用父类功能的能力。如果对象之间的关系是一个对象“有”另一个对象，那么最好使用组合——例如，汽车“有”一个电池。
- en: We will take our previous example of the `Car` class and the `Engine` class.
    In the example code for multiple inheritance, we implemented the `Car` class as
    a child of the `Engine` class, which is not really a good use case of inheritance.
    It's time to use composition by implementing the `Car` class with the `Engine`
    object inside the `Car` class. We can have another class for `Seat` and we can
    include it inside the `Car` class as well.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前关于`Car`类和`Engine`类的示例。在多重继承的示例代码中，我们将`Car`类实现为`Engine`类的子类，这并不是继承的一个很好的用例。现在是时候通过在`Car`类中实现`Engine`对象来使用组合了。我们还可以有一个`Seat`类，并将其包含在`Car`类中。
- en: 'We will illustrate this concept further in the following example, in which
    we build a `Car` class by including `Engine` and `Seat` classes in it:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下示例中进一步阐述这个概念，其中我们将通过在它内部包含`Engine`和`Seat`类来构建`Car`类：
- en: '[PRE30]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can analyze this example code as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下分析这个示例代码：
- en: 'We defined `Engine` and `Seat` classes with one attribute in each class: `i_size`
    for the `Engine` class and `i_type` for the `Seat` class.'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了`Engine`和`Seat`类，每个类中有一个属性：`Engine`类的`i_size`和`Seat`类的`i_type`。
- en: Later, we defined a `Car` class by adding the `i_color` attribute, an `Engine`
    instance, and a `Seat` instance in it. The `Engine` and `Seat` instances were
    created at the time of creating a `Car` instance.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们通过添加`i_color`属性、一个`Engine`实例和一个`Seat`实例来定义了一个`Car`类。`Engine`和`Seat`实例是在创建`Car`实例时创建的。
- en: 'In this main program, we created an instance of `Car` and performed the following
    actions:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个主程序中，我们创建了一个`Car`实例并执行了以下操作：
- en: 'a) `car.print_me`: This accesses the `print_me` method on the `Car` instance.'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'a) `car.print_me`: 这将访问`Car`实例上的`print_me`方法。'
- en: 'b) `print(car.engine`): This executes the `__str__` method of the `Engine`
    class.'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'b) `print(car.engine`): 这将执行`Engine`类的`__str__`方法。'
- en: 'c) `print(car.seat)`: This executes the `__str__` method of the `Seat` class.'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'c) `print(car.seat)`: 这将执行`Seat`类的`__str__`方法。'
- en: 'd) `print(car.i_color)`: This accesses the `i_color` attribute of the `Car`
    instance.'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'd) `print(car.i_color)`: 这将访问`Car`实例的`i_color`属性。'
- en: 'e) `print(car.engine.i_size)`: This accesses the `i_size` attribute of the
    `Engine` instance inside the `Car` instance.'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'e) `print(car.engine.i_size)`: 这将访问`Car`实例内部的`Engine`实例的`i_size`属性。'
- en: 'f) `print(car.seat.i_type)`: This accesses the `i_type` attribute of the `Seat`
    instance inside the `Car` instance'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'f) `print(car.seat.i_type)`: 这将访问`Car`实例内部的`Seat`实例的`i_type`属性'
- en: 'The console output of this program is shown here:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的控制台输出如下所示：
- en: '[PRE31]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Next, we will discuss duck typing, which is an alternative to polymorphism.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论鸭子类型，它是多态的替代方案。
- en: Introducing duck typing in Python
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Python中引入鸭子类型
- en: '**Duck typing**, sometimes referred to as **dynamic typing**, is mostly adopted
    in programming languages that support dynamic typing, such as Python and JavaScript.
    The name *duck typing* is borrowed based on the following quote:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**鸭子类型**，有时也称为**动态类型**，主要在支持动态类型的编程语言中采用，如Python和JavaScript。这个名字“鸭子类型”是基于以下引用借用的：'
- en: '"*If it looks like a duck, swims like a duck, and quacks like a duck, then
    it probably is a duck.*"'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: “如果它看起来像鸭子，游泳像鸭子，呱呱叫像鸭子，那么它可能就是一只鸭子。”
- en: This means that if a bird is behaving like a duck, it will likely be a duck.
    The point of mentioning this quote is that it is possible to identify an object
    by its behavior, which is the core principle of duck typing in Python.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果一个鸟儿表现得像一只鸭子，它很可能就是一只鸭子。提到这个引用的目的是，我们可以通过对象的行为来识别对象，这是Python中鸭子类型的核心原则。
- en: In duck typing, the type of class of an object is less important than the method
    (behavior) it defines. Using duck typing, the types of the object are not checked,
    but the method that is expected is executed.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在鸭子类型中，对象的类类型不如它定义的方法（行为）重要。使用鸭子类型，不会检查对象的类型，但会执行期望的方法。
- en: 'To illustrate this concept, we take a simple example with three classes, `Car`,
    `Cycle`, and `Horse`, and we try to implement a `start` method in each of them.
    In the `Horse` class, instead of naming the method `start`, we call it `push`.
    Here is a code snippet with all three classes and the main program at the end:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个概念，我们用一个包含三个类`Car`、`Cycle`和`Horse`的简单例子，并尝试在每个类中实现一个`start`方法。在`Horse`类中，我们不是将方法命名为`start`，而是将其命名为`push`。以下是包含所有三个类和末尾主程序的代码片段：
- en: '[PRE32]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the main program, we try to iterate the instances of these classes dynamically
    and call the `start` method. As expected, the `obj.start()` line failed for the
    `Horse` object because the class does not have any such method. As we can see
    in this example, we can put different class or instance types in one statement
    and execute the methods across them.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在主程序中，我们尝试动态地迭代这些类的实例并调用`start`方法。正如预期的那样，对于`Horse`对象，`obj.start()`这一行失败了，因为该类没有这样的方法。正如我们在这个例子中所看到的，我们可以在一个语句中放入不同的类或实例类型，并执行它们的方法。
- en: If we change the method named `push` to `start` inside the `Horse` class, the
    main program will execute without any error. Duck typing has many use cases, where
    it simplifies the solutions. Use of the `len` method in many objects and the use
    of iterators are a couple of many examples. We will explore iterators in detail
    in the next chapter.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`Horse`类中的名为`push`的方法改为`start`，主程序将无错误地执行。鸭子类型有许多用例，它可以简化解决方案。在许多对象中使用`len`方法和使用迭代器是一些例子。我们将在下一章详细探讨迭代器。
- en: So far, we have reviewed different object-oriented concepts and principles and
    their benefits. In the next section, we will also discuss briefly when it is not
    very beneficial to use OOP.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经回顾了不同的面向对象概念和原则及其好处。在下一节中，我们还将简要讨论何时使用面向对象编程并不非常有益。
- en: Learning when not to use OOP in Python
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习何时在Python中不使用面向对象编程
- en: Python has the flexibility to develop programs using either OOP languages such
    as Java or using declarative programming such as C. OOP is always appealing to
    developers because it provides powerful tools such as encapsulation, abstraction,
    inheritance, and polymorphism, but these tools may not fit every scenario and
    use case. These tools are more beneficial when used to build a large and complex
    application, especially one that involves **user interfaces** (**UIs**) and user
    interactions.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Python具有使用面向对象语言（如Java）或使用声明性编程（如C）来开发程序的灵活性。面向对象编程总是对开发者有吸引力，因为它提供了封装、抽象、继承和多态等强大工具，但这些工具可能并不适合每个场景和用例。当用于构建大型且复杂的应用程序时，特别是涉及**用户界面**（**UIs**）和用户交互的应用程序时，这些工具更有益。
- en: 'If your program is more like a script that has to execute certain tasks and
    there is no need to keep the state of objects, using OOP is overkill. Data science
    applications and intensive data processing are examples where it is less important
    to use OOP but more important to define how to execute tasks in a certain order
    to achieve goals. A real-world example is writing client programs for executing
    data-intensive jobs on a cluster of nodes, such as Apache Spark for parallel processing.
    We will cover these types of applications in later chapters. Here are a few more
    scenarios where using OOP is not necessary:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的程序更像是一个需要执行特定任务且不需要保持对象状态的脚本，那么使用面向对象编程就过度了。数据科学应用和密集型数据处理就是那些使用面向对象编程不那么重要，而定义如何按特定顺序执行任务以实现目标更为重要的例子。一个现实世界的例子是为在节点集群上执行数据密集型工作编写客户端程序，例如
    Apache Spark 用于并行处理。我们将在后面的章节中介绍这些类型的程序。以下是一些使用面向对象编程不是必要的场景：
- en: Reading a file, applying logic, and writing back to a new file is a type of
    program that is easier to implement using functions in a module rather than using
    OOP.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取文件、应用逻辑并将结果写回新文件是那种更适合使用模块中的函数而不是面向对象编程来实现的程序类型。
- en: Configuring devices using Python is very popular and it is another candidate
    to be done using regular functions.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Python 配置设备非常流行，这也是另一个可以使用常规函数完成的候选方案。
- en: Parsing and transforming data from one format to another format is also a use
    case that can be programmed by using declarative programming rather than OOP.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析和转换数据从一个格式到另一个格式也是可以通过使用声明式编程而不是面向对象编程来编程的用例。
- en: Porting an old code base to a new one with OOP is not a good idea. We need to
    remember that the old code may not be built using OOP design patterns and we may
    end up with non-OOP functions wrapped in classes and objects that are hard to
    maintain and extend.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将旧代码库移植到使用面向对象编程的新代码库不是一个好主意。我们需要记住，旧代码可能不是使用面向对象设计模式构建的，我们最终可能会得到难以维护和扩展的封装在类和对象中的非面向对象函数。
- en: In short, it is important to analyze the problem statement and requirements
    first before choosing whether to use OOP or not. It also depends on which third-party
    libraries you will be using with your program. If you are required to extend classes
    from third-party libraries, you will have to go along with OOP in that case.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，在决定是否使用面向对象编程之前，首先分析问题陈述和需求是很重要的。这也取决于你将与你程序一起使用的第三方库。如果你需要从第三方库扩展类，那么在这种情况下，你将不得不使用面向对象编程。
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we learned the concept of classes and objects in Python and
    we also discussed how to build classes and use them to create objects and instances.
    Later, we deep-dived into the four pillars of OOP: encapsulation, inheritance,
    polymorphism, and abstraction. We also worked through simple and clear code examples
    to make it easier for readers to grasp the concepts of OOP. These four pillars
    are fundamental to using OOP in Python.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 Python 中的类和对象的概念，并讨论了如何构建类以及如何使用它们来创建对象和实例。随后，我们深入探讨了面向对象编程的四个支柱：封装、继承、多态和抽象。我们还通过简单明了的代码示例来帮助读者掌握面向对象编程的概念。这四个支柱是使用
    Python 进行面向对象编程的基础。
- en: In the later sections, we also covered duck typing, which is important for clarifying
    its non-dependency on classes, before ending the chapter by reviewing when it
    is not significantly beneficial to use OOP.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的章节中，我们还介绍了鸭子类型，这对于阐明其不依赖于类的重要性至关重要，在回顾完何时使用面向对象编程并不显著有益后结束本章。
- en: By going through this chapter, you not only refreshed your knowledge of the
    main concepts of OOP but also learned how to apply the concepts using Python syntax.
    We will review a few Python libraries for advanced programming in the next chapter.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 通过学习本章，你不仅更新了你对面向对象编程主要概念的知识，还学会了如何使用 Python 语法应用这些概念。我们将在下一章回顾一些用于高级编程的 Python
    库。
- en: Questions
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are a class and an object?
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是类和对象？
- en: What are dunders?
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是双下划线方法（dunder methods）？
- en: Does Python support inheriting a class from multiple classes?
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python 是否支持从多个类继承？
- en: Can we create an instance of an abstract class?
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们能否创建一个抽象类的实例？
- en: 'The type of a class is important in duct typing: true or false?'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在鸭子类型中，类的类型很重要：对还是错？
- en: Further reading
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Modular Programming with Python*, by *Erik Westra*'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Python 模块化编程》*，作者 *Erik Westra*'
- en: '*Python 3 Object-Oriented Programming*, by *Dusty Phillips*'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Python 3 面向对象编程》*，作者 *Dusty Phillips*'
- en: '*Learning Object-Oriented Programming*, by *Gaston C. Hillar*'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《学习面向对象编程》*，作者 *Gaston C. Hillar*'
- en: '*Python for Everyone – Third edition*, by *Cay Horstmann* and *Rance Necaise*'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Python 从入门到实践》第三版*，由 *凯·霍斯特曼* 和 *兰斯·内塞* 著'
- en: Answers
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: A class is a blueprint or a template to tell the Python interpreter how something
    needs to be defined. An object is an instance that is built from a class based
    on what is defined in that class.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类是一个蓝图或模板，用于告诉 Python 解释器如何定义某个事物。对象是根据类中定义的内容从该类构建的一个实例。
- en: Dunders are special methods that always start and end with double underscores.
    There are a few dozen special methods available to be implemented with every class.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双下划线方法（Dunders）是始终以双下划线开始和结束的特殊方法。每个类都可以实现几十个特殊方法。
- en: Yes—Python supports inheriting a class from multiple classes.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的——Python 支持从多个类中继承一个类。
- en: No—we can't create an instance of an abstract class.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不可以——我们不能创建一个抽象类的实例。
- en: False. It is the methods that are more important than the class.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误。比类更重要的是方法。
