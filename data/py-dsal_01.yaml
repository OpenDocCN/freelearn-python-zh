- en: Python Objects, Types, and Expressions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 对象、类型和表达式
- en: Python is the language of choice for many advanced data tasks for a very good
    reason. Python is one of the easiest advanced programming languages to learn.
    Intuitive structures and semantics mean that for people who are not computer scientists,
    but maybe biologists, statisticians, or the directors of a start-up, Python is
    a straightforward way to perform a wide variety of data tasks. It is not just
    a scripting language, but a full-featured object-oriented programming language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是许多高级数据任务的优选语言，这有一个非常好的原因。Python 是最容易学习的高级编程语言之一。直观的结构和语义意味着对于不是计算机科学家的人来说，比如生物学家、统计学家或初创公司的负责人，Python
    是执行各种数据任务的直接途径。它不仅仅是一种脚本语言，而是一种功能齐全的面向对象编程语言。
- en: In Python, there are many useful data structures and algorithms built in to
    the language. Also, because Python is an object-based language, it is relatively
    easy to create custom data objects. In this book, we will examine both Python
    internal libraries, some of the external libraries, as well as learning how to
    build your own data objects from first principles.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，有许多有用的数据结构和算法内置在语言中。此外，由于 Python 是一种基于对象的编程语言，因此相对容易创建自定义数据对象。在本书中，我们将检查
    Python 的内部库，一些外部库，以及如何从第一原理构建自己的数据对象。
- en: This book does assume that you know Python. However, if you are a bit rusty,
    coming from another language, or do not know Python at all, don't worry, this
    first chapter should get you quickly up to speed. If not, then visit [https://docs.python.org/3/tutorial/index.html](https://docs.python.org/3/tutorial/index.html),
    and also you can find the documentation at [https://www.python.org/doc/](https://www.python.org/doc/).
    These are all excellent resources to easily learn this programming language.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书假设您已经了解 Python。然而，如果您对 Python 有点生疏，来自其他语言，或者根本不知道 Python，请不要担心，第一章应该能迅速让您跟上进度。如果不行，请访问
    [https://docs.python.org/3/tutorial/index.html](https://docs.python.org/3/tutorial/index.html)，您也可以在
    [https://www.python.org/doc/](https://www.python.org/doc/) 找到文档。这些都是学习这种编程语言的极好资源。
- en: 'In this chapter, we will look at the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Obtaining a general working knowledge of data structures and algorithms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获得数据结构和算法的一般工作知识
- en: Understanding core data types and their functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解核心数据类型及其功能
- en: Exploring the object-oriented aspects of the Python programming language
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Python 编程语言的面向对象特性
- en: Understanding data structures and algorithms
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解数据结构和算法
- en: 'Algorithms and data structures are the most fundamental concepts in computing.
    They are the building blocks from which complex software is built. Having an understanding
    of these foundation concepts is hugely important in software design and this involves
    the following three characteristics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 算法和数据结构是计算中最基本的概念。它们是构建复杂软件的基石。对这些基础概念的理解在软件设计中至关重要，这涉及到以下三个特征：
- en: How algorithms manipulate information contained within data structures
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法如何操作数据结构中包含的信息
- en: How data is arranged in memory
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据在内存中的排列方式
- en: What the performance characteristics of particular data structures are
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定数据结构的性能特征是什么
- en: In this book, we will examine this topic from several perspectives. Firstly,
    we will look at the fundamentals of the Python programming language from the perspective
    of data structures and algorithms. Secondly, it is important that we have the
    correct mathematical tools. We need to understand some fundamental concepts of
    computer science and for this we need mathematics. By taking a heuristics approach,
    developing some guiding principles means that, in general, we do not need any
    more than high school mathematics to understand the principles of these key ideas.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将从多个角度探讨这个主题。首先，我们将从数据结构和算法的角度来看 Python 编程语言的基础。其次，拥有正确的数学工具非常重要。我们需要理解一些计算机科学的基本概念，而这需要数学知识。通过采用启发式方法，制定一些指导原则意味着，通常情况下，我们不需要超过高中数学水平就能理解这些关键思想的原则。
- en: Another important aspect is evaluation. Measuring an algorithms performance
    involves understanding how each increase in data size affects operations on that
    data. When we are working on large datasets or real-time applications, it is essential
    that our algorithms and structures are as efficient as they can be.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要方面是评估。衡量算法性能涉及理解数据大小每增加一次如何影响该数据上的操作。当我们处理大型数据集或实时应用时，我们的算法和结构尽可能高效是至关重要的。
- en: Finally, we need a sound experimental design strategy. Being able to conceptually
    translate a real-world problem into the algorithms and data structures of a programming
    language involves being able to understand the important elements of a problem
    and a methodology for mapping these elements to programming structures.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个合理的实验设计策略。能够将现实世界问题概念性地转化为编程语言的算法和数据结构，涉及到理解问题的关键要素以及将这些要素映射到编程结构的方法。
- en: 'To give us some insight into algorithmic thinking, let''s consider a real-world
    example. Imagine we are at an unfamiliar market and we are given the task of purchasing
    a list of items. We assume that the market is laid out randomly, and each vendor
    sells a random subset of items, some of which may be on our list. Our aim is to
    minimize the price we pay for each item as well as minimize the time spent at
    the market. One way to approach this is to write an algorithm like the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们对算法思维有所了解，让我们考虑一个现实世界的例子。想象我们在一个不熟悉的市场，并被分配购买一系列项目的任务。我们假设市场布局是随机的，每个供应商销售的项目子集是随机的，其中一些可能在我们列表上。我们的目标是尽量减少每个项目的价格以及尽量减少在市场花费的时间。一种方法是编写如下算法：
- en: 'Repeat for each vendor:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对每个供应商重复：
- en: Does the vendor have items on my list and is the cost less than a predicted
    cost for the item?
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 供应商是否有我列表上的项目，并且成本是否低于该项目的预测成本？
- en: If yes, buy and remove from list; if no, move on to the next vendor.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是，购买并从列表中删除；如果不是，转到下一个供应商。
- en: If no more vendors, end.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有更多的供应商，结束。
- en: This is a simple iterator, with a decision and an action. If we were to implement
    this, we would need data structures to define both the list of items we want to
    buy as well as the list of items of each vendor. We would need to determine the
    best way of matching items in each list and we need some sort of logic to decide
    whether to purchase or not.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的迭代器，包含决策和动作。如果我们实现这个功能，我们需要数据结构来定义我们想要购买的项目列表以及每个供应商的项目列表。我们需要确定匹配每个列表中项目的最佳方式，并且需要某种逻辑来决定是否购买。
- en: There are several observations that we can make regarding this algorithm. Firstly,
    since the cost calculation is based on a prediction, we don't know what the real
    average cost is; if we underpredict the cost of an item, we come to the end of
    the market with items remaining on our list. Therefore, we need an efficient way
    to backtrack to the vendor with the lowest cost.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个算法，我们可以做出几个观察。首先，由于成本计算基于预测，我们不知道实际的平均成本是多少；如果我们低估了某个项目的成本，我们会在市场结束时发现列表上还有剩余的项目。因此，我们需要一种有效的方法来回溯到成本最低的供应商。
- en: Also, we need to understand what happens to the time it takes to compare items
    on our shopping list with items sold by each vendor as the number of items on
    our shopping list, or the number of items sold by each vendor, increases. The
    order in which we search through items and the shape of the data structures can
    make a big difference to the time it takes to do a search. Clearly, we would like
    to arrange our list, as well as the order we visit each vendor, in such a way
    that we minimize search time.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们需要了解当我们的购物列表上的项目数量或每个供应商销售的项目数量增加时，比较购物列表上的项目与每个供应商销售的项目所需的时间会发生什么变化。我们搜索项目的顺序和数据结构的形式可以大大影响搜索所需的时间。显然，我们希望以这种方式安排我们的列表，以及我们访问每个供应商的顺序，以最小化搜索时间。
- en: Also, consider what happens when we change the buy condition to purchase at
    the *cheapest* price, not just the below average price. This changes the problem
    entirely. Instead of sequentially going from one vendor to the next, we need to
    traverse the market once and, with this knowledge, we can order our shopping list
    with regards to the vendors we want to visit.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，考虑当我们改变购买条件为以*最低*价格购买，而不仅仅是低于平均价格时会发生什么。这完全改变了问题。我们不再按顺序从一个供应商走到下一个供应商，我们需要遍历市场一次，并利用这些知识，我们可以根据我们想要访问的供应商来排序我们的购物列表。
- en: Obviously, there are many more subtleties involved in translating a real-world
    problem into an abstract construct such as a programming language. For example,
    as we progress through the market, our knowledge of the cost of a product improves,
    so our predicted average price variable becomes more accurate until, by the last
    stall, our knowledge of the market is perfect. Assuming any kind of backtracking
    algorithm incurs a cost, we can see cause to review our entire strategy. Conditions
    such as high price variability, the size and shape of our data structures, and
    the cost of backtracking all determine the most appropriate solution.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，将现实世界问题转化为编程语言等抽象结构涉及许多细微之处。例如，随着我们在市场的进展，我们对产品成本的了解不断改进，因此我们的预测平均价格变量变得更加准确，直到最后摊位，我们对市场的了解变得完美。假设任何类型的回溯算法都会产生成本，我们可以看到有必要审查我们的整个策略。诸如高价格变异性、我们的数据结构的大小和形状以及回溯的成本等因素都决定了最合适的解决方案。
- en: Python for data
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python用于数据
- en: Python has several built-in data structures, including lists, dictionaries,
    and sets, that we use to build customized objects. In addition, there are a number
    of internal libraries, such as collections and the `math` object, which allow
    us to create more advanced structures as well as perform calculations on those
    structures. Finally, there are the external libraries such as those found in the
    `SciPy` packages. These allow us to perform a range of advanced data tasks such
    as logistic and linear regression, visualization, and mathematical calculations
    such as operations on matrixes and vectors. External libraries can be very useful
    for an *out-of-the-box* solution. However, we must also be aware that there is
    often a performance penalty compared to building customized objects from the ground
    up. By learning how to code these objects ourselves, we can target them to specific
    tasks, making them more efficient. This is not to exclude the role of external
    libraries and we will look at this in [Chapter 12](f1986aa3-0229-4480-8496-d25a2a9dae46.xhtml)*,
    Design Techniques and Strategies**.*
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Python具有几个内置的数据结构，包括列表、字典和集合，我们使用它们来构建自定义对象。此外，还有一些内部库，如collections和`math`对象，允许我们创建更高级的结构以及在这些结构上执行计算。最后，还有外部库，如`SciPy`包中找到的库。这些库允许我们执行一系列高级数据任务，如逻辑回归和线性回归、可视化以及矩阵和向量的数学计算等。外部库对于“即用型”解决方案非常有用。然而，我们也必须意识到，与从头开始构建自定义对象相比，通常会有性能上的损失。通过学习如何自己编写这些对象，我们可以针对特定任务进行优化，使它们更高效。这并不是要排除外部库的作用，我们将在[第12章](f1986aa3-0229-4480-8496-d25a2a9dae46.xhtml)*设计技术和策略**中探讨这一点*。
- en: To begin, we will take an overview of some of the key language features that
    make Python such a great choice for data programming.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将概述一些关键语言特性，这些特性使Python成为数据编程的绝佳选择。
- en: The Python environment
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python环境
- en: A feature of the Python environment is its interactive console allowing you
    to both use Python as a desktop programmable calculator and also as an environment
    to write and test snippets of code. The **read-evaluate-print** loop of the console
    is a very convenient way to interact with a larger code base, such as to run functions
    and methods or to create instances of classes. This is one of the major advantages
    of Python over compiled languages such as C/C++ or Java, where the **write-compile-test-recompile**
    cycle can increase development time considerably compared to Python's read - evaluate
    - print loop. Being able to type in expressions and get an immediate response
    can greatly speed up data science tasks.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Python环境的特性之一是其交互式控制台，它允许你既可以将Python用作桌面可编程计算器，也可以用作编写和测试代码片段的环境。控制台的**读取-评估-打印**循环是一种与大型代码库交互的非常方便的方式，例如运行函数和方法或创建类的实例。这是Python相对于C/C++或Java等编译语言的主要优势之一，在Python的读取-评估-打印循环中，**编写-编译-测试-重新编译**的周期可以显著增加开发时间。能够输入表达式并获得即时响应可以大大加快数据科学任务的速度。
- en: There are some excellent distributions of Python apart from the official CPython
    version. Two of the most popular are Anaconda ([https://www.continuum.io/downloads](https://www.continuum.io/downloads))
    and Canopy ([https://www.enthought.com/products/canopy/](https://www.enthought.com/products/canopy/)).
    Most distributions come with their own developer environments. Both Canopy and
    Anaconda include libraries for scientific, machine learning, and other data applications.
    Most distributions come with an editor.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 除了官方的 CPython 版本之外，还有一些优秀的 Python 发行版。其中最受欢迎的两个是 Anaconda ([https://www.continuum.io/downloads](https://www.continuum.io/downloads))
    和 Canopy ([https://www.enthought.com/products/canopy/](https://www.enthought.com/products/canopy/))。大多数发行版都附带自己的开发环境。Canopy
    和 Anaconda 都包括用于科学、机器学习和其他数据应用的库。大多数发行版都附带一个编辑器。
- en: There are also a number of implementations of the Python console, apart from
    the CPython version. Most notable amongst these is the Ipython/Jupyter platform
    that includes a web-based computational environment.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 CPython 版本之外，还有许多 Python 控制台的实现。其中最值得注意的是 Ipython/Jupyter 平台，它包括一个基于网络的计算环境。
- en: Variables and expressions
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量和表达式
- en: 'To translate a real-world problem into one that can be solved by an algorithm,
    there are two interrelated tasks. Firstly, select the variables, and secondly,
    find the expressions that relate to these variables. Variables are labels attached
    to objects; they are not the object itself. They are not containers for objects
    either. A variable does not contain the object, rather it acts as a pointer or
    reference to an object. For example, consider the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 将现实世界的问题转化为算法可以解决的问题，有两个相互关联的任务。首先，选择变量，其次，找到与这些变量相关的表达式。变量是附加到对象上的标签；它们不是对象本身。它们也不是对象的容器。变量不包含对象，而是作为对象指针或引用。例如，考虑以下代码：
- en: '![](img/image_01_001.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_01_001.png)'
- en: Here we have created a variable, `a`, which points to a list object. We create
    another variable, `b`, which points to this same list object. When we append an
    element to this list object, this change is reflected in both `a` and `b`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个变量 `a`，它指向一个列表对象。我们创建了另一个变量 `b`，它指向这个相同的列表对象。当我们向这个列表对象添加一个元素时，这个变化会在
    `a` 和 `b` 中都反映出来。
- en: 'Python is a dynamically typed language. Variable names can be bound to different
    values and types during program execution. Each value is of a type, a string,
    or integer for example; however, the name that points to this value does not have
    a specific type. This is different from many languages such as C and Java where
    a name represents a fixed size, type, and location in memory. This means when
    we initialize variables in Python, we do not need to declare a type. Also, variables,
    or more specifically the objects they point to, can change type depending on the
    values assigned to them, for example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种动态类型语言。在程序执行期间，变量名可以绑定到不同的值和类型。每个值都有其类型，例如字符串或整数；然而，指向这个值的名称并没有特定的类型。这与许多语言（如
    C 和 Java）不同，在这些语言中，名称代表固定的大小、类型和内存中的位置。这意味着当我们初始化 Python 中的变量时，我们不需要声明类型。此外，变量，或者更具体地说，它们指向的对象，可以根据分配给它们的值改变类型，例如：
- en: '![](img/image_01_002.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_01_002.png)'
- en: Variable scope
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量作用域
- en: 'It is important to understand the scoping rules of variables inside functions.
    Each time a function executes, a new local namespace is created. This represents
    a local environment that contains the names of the parameters and variables that
    are assigned by the function. To resolve a namespace when a function is called,
    the Python interpreter first searches the local namespace (that is, the function
    itself) and if no match is found, it searches the global namespace. This global
    namespace is the module in which the function was defined. If the name is still
    not found, it searches the built-in namespace. Finally, if this fails then the
    interpreter raises a `NameError` exception. Consider the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 理解函数内部变量的作用域规则非常重要。每次函数执行时，都会创建一个新的局部命名空间。这代表了一个包含函数分配的参数和变量名称的局部环境。当函数被调用时，Python
    解释器首先搜索局部命名空间（即函数本身），如果找不到匹配项，它将搜索全局命名空间。这个全局命名空间是定义函数的模块。如果名称仍然没有找到，它将搜索内置命名空间。最后，如果这还失败，解释器将引发一个
    `NameError` 异常。考虑以下代码：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is the output of the preceding code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前面代码的输出：
- en: '![](img/image_01_003.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_01_003.png)'
- en: In the preceding code, we define two global variables. We need to tell the interpreter,
    using the keyword `global`, that inside the function, we are referring to a global
    variable. When we change this variable to `11`, these changes are reflected in
    the global scope. However, the variable `b` we set to `21` is local to the function,
    and any changes made to it inside the function are not reflected in the global
    scope. When we run the function and print `b`, we see that it retains its global
    value.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了两个全局变量。我们需要使用关键字`global`告诉解释器，在函数内部，我们正在引用一个全局变量。当我们将其更改为`11`时，这些更改将在全局范围内反映出来。然而，我们设置为`21`的变量`b`是局部于函数的，并且在该函数内部对其所做的任何更改都不会反映在全局范围内。当我们运行该函数并打印`b`时，我们看到它保留了其全局值。
- en: Flow control and iteration
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流程控制和迭代
- en: Python programs consist of a sequence of statements. The interpreter executes
    each statement in order until there are no more statements. This is true if both
    files run as the main program as well as files that are loaded via `import`. All
    statements, including variable assignment, function definitions, class definitions,
    and module imports, have equal status. There are no special statements that have
    higher priority than any other and every statement can be placed anywhere in a
    program. There are two main ways of controlling the flow of program execution,
    conditional statements and loops.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Python程序由一系列语句组成。解释器按顺序执行每个语句，直到没有更多语句为止。这适用于既作为主程序运行，也通过`import`加载的文件。所有语句，包括变量赋值、函数定义、类定义和模块导入，都具有相同的状态。没有比其他语句具有更高优先级的特殊语句，每个语句都可以放置在程序中的任何位置。有两种主要方式来控制程序执行的流程，即条件语句和循环。
- en: 'The `if`, `else`, and `elif` statements control the conditional execution of
    statements. The general format is a series of `if` and `elif` statements followed
    by a final `else` statement:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`、`else`和`elif`语句控制语句的条件执行。一般格式是一系列`if`和`elif`语句，后跟一个最终的`else`语句：'
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note the use of the `==` operator to test for the same values. This returns
    `true` if the values are equal; it returns `false` otherwise. Note also that setting
    `x` to a string will return *something else* rather than generate a type error
    as may happen in languages that are not dynamically typed. Dynamically typed languages
    such as Python allow flexible assignment of objects with different types.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用`==`运算符来测试相同的值。如果值相等，则返回`true`；否则返回`false`。还要注意，将`x`设置为字符串将返回*其他内容*，而不是像在非动态类型语言中可能发生的那样生成类型错误。动态类型语言，如Python，允许灵活地为不同类型的对象分配。
- en: 'The other way of controlling program flow is with loops. They are created using
    the `while` or `for` statements, for example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 控制程序流程的另一种方式是使用循环。它们是通过`while`或`for`语句创建的，例如：
- en: '![](img/image_01_004.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_01_004.png)'
- en: Overview of data types and objects
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型和对象概述
- en: Python contains 12 built-in data types. These include four numeric types (`int`,
    `float`, `complex`, `bool`), four sequence types (`str`, `list`, `tuple`, `range`),
    one mapping type (`dict`), and two set types. It is also possible to create user-defined
    objects such as functions or classes. We will look at the `string` and the `list`
    data types in this chapter and the remaining built-in types in the next chapter.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Python包含12种内置数据类型。这些包括四种数值类型（`int`、`float`、`complex`、`bool`）、四种序列类型（`str`、`list`、`tuple`、`range`）、一种映射类型（`dict`）和两种集合类型。还可以创建用户定义的对象，如函数或类。我们将在本章中查看`string`和`list`数据类型，并在下一章中查看剩余的内置类型。
- en: All data types in Python are **objects**. In fact, pretty much everything is
    an object in Python, including modules, classes, and functions, as well as literals
    such as strings and integers. Each object in Python has a **type**, a **value,**
    and an **identity**. When we write `greet = "hello world"` we are creating an
    instance of a string object with the value `"hello world"` and the identity of
    `greet`. The identity of an object acts as a pointer to the object's location
    in memory. The type of an object, also known as the object's class, describes
    the object's internal representation as well as the methods and operations it
    supports. Once an instance of an object is created, its identity and type cannot
    be changed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的所有数据类型都是 **对象**。实际上，在 Python 中几乎一切都是对象，包括模块、类和函数，以及字符串和整数等字面量。Python
    中的每个对象都有一个 **类型**、一个 **值** 和一个 **身份**。当我们编写 `greet = "hello world"` 时，我们正在创建一个具有值
    `"hello world"` 和身份 `greet` 的字符串对象。对象的身份充当指向对象在内存中位置的指针。对象类型，也称为对象的类，描述了对象的内部表示以及它支持的方法和操作。一旦创建了对象的一个实例，其身份和类型就不能更改。
- en: We can get the identity of an object by using the built-in function `id()`.
    This returns an identifying integer and on most systems this refers to its memory
    location, although you should not rely on this in any of your code.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用内置函数 `id()` 来获取对象的身份。这个函数返回一个标识整数，在大多数系统中这指的是它的内存位置，尽管你不应该在代码中依赖这一点。
- en: 'Also, there are a number of ways to compare objects, for example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有许多比较对象的方法，例如：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: An important distinction needs to be made between **mutable** and **immutable**
    objects. Mutable object's such as lists can have their values changed. They have
    methods, such as `insert()` or `append()`, that change an objects value. Immutable
    objects, such as strings, cannot have their values changed, so when we run their methods,
    they simply return a value rather than change the value of an underlying object.
    We can, of course, use this value by assigning it to a variable or using it as
    an argument in a function.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 需要在 **可变** 和 **不可变** 对象之间做出重要区分。可变对象，如列表，可以更改其值。它们有 `insert()` 或 `append()`
    等方法可以更改对象的值。不可变对象，如字符串，不能更改其值，因此当我们运行它们的方法时，它们只是返回一个值，而不是更改底层对象的值。当然，我们可以通过将其赋值给变量或用作函数参数来使用这个值。
- en: Strings
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: Strings are immutable sequence objects, with each character representing an
    element in the sequence. As with all objects, we use methods to perform operations.
    Strings, being immutable, do not change the instance; each method simply returns
    a value. This value can be stored as another variable or given as an argument
    to a function or method.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是不可变序列对象，每个字符代表序列中的一个元素。与所有对象一样，我们使用方法来执行操作。字符串是不可变的，不会改变实例；每个方法只是返回一个值。这个值可以存储为另一个变量，或者作为函数或方法的参数。
- en: 'The following table is a list of some of the most commonly used string methods
    and their descriptions:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了一些最常用的字符串方法和它们的描述：
- en: '| **Methods** | **Descriptions** |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `s.count(substring, [start,end])` | Counts the occurrences of a substring
    with optional start and end parameters. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `s.count(substring, [start,end])` | 计算具有可选起始和结束参数的子串出现的次数。|'
- en: '| `s.expandtabs([tabsize])` | Replaces tabs with spaces. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `s.expandtabs([tabsize])` | 将制表符替换为空格。|'
- en: '| `s.find(substring, [start, end])` | Returns the index of the first occurrence
    of a substring or returns `-1` if the substring is not found. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `s.find(substring, [start, end])` | 返回子串首次出现的索引，如果未找到子串，则返回 `-1`。|'
- en: '| `s.isalnum()` | Returns `True` if all characters are alphanumeric, returns
    `False` otherwise. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `s.isalnum()` | 如果所有字符都是字母数字，则返回 `True`，否则返回 `False`。|'
- en: '| `s.isalpha()` | Returns `True` if all characters are alphabetic, returns
    `False` otherwise. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `s.isalpha()` | 如果所有字符都是字母，则返回 `True`，否则返回 `False`。|'
- en: '| `s.isdigit()` | Returns `True` if all characters are digits, returns `False`
    otherwise. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `s.isdigit()` | 如果所有字符都是数字，则返回 `True`，否则返回 `False`。|'
- en: '| `s.join(t)` | Joins the strings in sequence `t`. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `s.join(t)` | 将序列 `t` 中的字符串连接起来。|'
- en: '| `s.lower()` | Converts the string to all lowercase. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `s.lower()` | 将字符串转换为全小写。|'
- en: '| `s.replace(old, new [maxreplace])` | Replaces old substring with new substring.
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `s.replace(old, new [maxreplace])` | 将旧子串替换为新子串。|'
- en: '| `s.strip([characters])` | Removes whitespace or optional characters. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `s.strip([characters])` | 移除空白字符或可选字符。|'
- en: '| `s.split([separator], [maxsplit])` | Splits a string separated by whitespace
    or an optional separator. Returns a list. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `s.split([separator], [maxsplit])` | 按空白字符或可选分隔符拆分字符串。返回列表。|'
- en: 'Strings, like all sequence types, support indexing and slicing. We can retrieve
    any character from a string by using its index `s[i]`. We can retrieve a slice
    of a string by using `s[i:j]`, where `i` and `j` are the start and end points
    of the slice. We can return an extended slice by using a stride, as in the following: `s[i:j:stride]`.
    The following code should make this clear:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串，像所有序列类型一样，支持索引和切片。我们可以通过使用其索引`s[i]`来检索字符串中的任何字符。我们可以通过使用`s[i:j]`来检索字符串的切片，其中`i`和`j`是切片的起始和结束点。我们可以通过使用步长来返回扩展切片，如下所示：`s[i:j:stride]`。以下代码应该会使这一点变得清晰：
- en: '![](img/image_01_005.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_01_005.png)'
- en: The first two examples are pretty straightforward, returning the character located
    at index `1` and the first seven characters of the string, respectively. Notice
    that indexing begins at `0`. In the third example, we are using a stride of `2`.
    This results in every second character being returned. In the final example, we
    omit the end index and the slice returns every second character in the entire
    string.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个例子相当直接，分别返回字符串中索引为`1`的字符和字符串的前七个字符。请注意，索引从`0`开始。在第三个例子中，我们使用了步长`2`。这导致返回每个第二个字符。在最后一个例子中，我们省略了结束索引，切片返回整个字符串中的每个第二个字符。
- en: 'You can use any expression, variable, or operator as an index as long as the
    value is an integer, for example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用任何表达式、变量或运算符作为索引，只要值是整数即可，例如：
- en: '![](img/image_01_006.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_01_006.png)'
- en: 'Another common operation is traversing through a string with a loop, for example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的操作是使用循环遍历字符串，例如：
- en: '![](img/image_01_007.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_01_007.png)'
- en: 'Given that strings are immutable, a common question that arises is how we perform
    operations such inserting values. Rather than changing a string, we need to think
    of ways to build new string objects for the results we need. For example, if we
    wanted to insert a word into our greeting, we could assign a variable to the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字符串是不可变的，一个常见的问题是我们在插入值时如何操作。我们不是改变字符串，而是需要考虑构建新的字符串对象以获得所需的结果。例如，如果我们想在问候语中插入一个单词，我们可以将变量分配给以下内容：
- en: '![](img/image_01_008.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_01_008.png)'
- en: 'As this code shows, we use the slice operator to split the string at index
    position `5` and use `+` to concatenate. Python never interprets the contents
    of a string as a number. If we need to perform mathematical operations on a string,
    we need to first convert them to a numeric type, for example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如此代码所示，我们使用切片运算符在索引位置`5`处拆分字符串，并使用`+`进行连接。Python永远不会将字符串的内容解释为数字。如果我们需要对字符串进行数学运算，我们需要首先将它们转换为数值类型，例如：
- en: '![](img/image_01_009.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_01_009.png)'
- en: Lists
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: 'Lists are probably the most used built-in data structures in Python because
    they can be composed of any number of other data types. They are a simple representation
    of arbitrary objects. Like strings, they are indexed by integers starting with
    zero. The following table contains the most commonly used list methods and their
    descriptions:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 列表可能是Python中最常用的内置数据结构，因为它们可以由任意数量的其他数据类型组成。它们是任意对象的简单表示。像字符串一样，它们从零开始的整数进行索引。以下表格包含最常用的列表方法和它们的描述：
- en: '| **Method** | **Description** |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `list(s)` | Returns a list of the sequence `s`. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `list(s)` | 返回序列`s`的列表。|'
- en: '| `s.append(x)` | Appends element `x` to the end of `s`. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `s.append(x)` | 将元素`x`追加到`s`的末尾。|'
- en: '| `s.extend(x)` | Appends the list `x` to `s`. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `s.extend(x)` | 将列表`x`追加到`s`。|'
- en: '| `s.count(x)` | Counts the occurrence of `x` in `s`. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `s.count(x)` | 统计`s`中`x`出现的次数。|'
- en: '| `s.index(x, [start], [stop])` | Returns the smallest index, `i`, where `s[i]
    ==x`. Can include optional start and stop index for the search. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `s.index(x, [start], [stop])` | 返回最小的索引`i`，其中`s[i] == x`。搜索可以包括可选的起始和停止索引。|'
- en: '| `s.insert(i,e)` | Inserts `x` at index `i`. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `s.insert(i,e)` | 在索引`i`处插入`x`。|'
- en: '| `s.pop(i)` | Returns the element `i` and removes it from the list. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `s.pop(i)` | 返回元素`i`并从列表中删除它。|'
- en: '| `s.remove(x)` | Removes `x` from `s`. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `s.remove(x)` | 从`s`中删除`x`。|'
- en: '| `s.reverse()` | Reverses the order of `s`. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `s.reverse()` | 反转`s`的顺序。|'
- en: '| `s.sort(key ,[reverse])` | Sorts `s` with optional key and reverse. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `s.sort(key ,[reverse])` | 使用可选的键和逆序对`s`进行排序。|'
- en: 'When we are working with lists, and other *container* objects, it is important
    to understand the internal mechanism that Python uses to copy them. Python creates
    real copies only if it has to. When we assign the value of a variable to another
    variable, both of these variables point to the same memory location. A new slot
    in memory will only be allocated if one of the variables changes. This has important
    consequences for mutable compound objects such as lists. Consider the following
    code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理列表和其他*容器*对象时，了解Python用于复制它们的内部机制非常重要。Python仅在必要时才创建真正的副本。当我们把一个变量的值赋给另一个变量时，这两个变量都指向相同的内存位置。只有当其中一个变量发生变化时，才会分配新的内存槽位。这对于列表等可变复合对象有重要的影响。考虑以下代码：
- en: '![](img/image_01_010.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_01_010.png)'
- en: Here, both the `list1` and `list2` variables point to the same slot in memory.
    When we change the `y` variable to `4`, we are changing the same `y` variable
    that `list1` is pointing to.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`list1`和`list2`变量都指向内存中的同一个槽位。当我们把`y`变量改为`4`时，我们是在改变`list1`指向的同一个`y`变量。
- en: 'An important feature of list''s is that they can contain nested structures,
    that is, other lists, for example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的一个重要特性是它们可以包含嵌套结构，即其他列表，例如：
- en: '![](img/image_01_011.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_01_011.png)'
- en: 'We can access the lists values using the bracket operators and since lists
    are mutable, they are copied in place. The following example demonstrates how
    we can use this to update elements; for example, here we are raising the price
    of flour by 20 percent:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用方括号运算符来访问列表的值，由于列表是可变的，它们是在原地复制的。以下示例演示了我们可以如何使用这种方法来更新元素；例如，在这里我们提高了面粉的价格20%：
- en: '![](img/image_01_012.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_01_012.png)'
- en: 'A common and very intuitive way to create lists from expressions is using **list
    comprehensions.** This allows us to create a list by writing an expression directly
    into the list, for example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 创建列表的一种常见且直观的方法是使用**列表推导**。这允许我们通过直接将表达式写入列表来创建列表，例如：
- en: '![](img/image_01_013.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_01_013.png)'
- en: 'List comprehensions can be quite flexible; for example, consider the following
    code. It essentially shows two different ways to performs a function composition,
    where we apply one function (`x * 4`) to another (`x * 2`). The following code
    prints out two lists representing the function composition of `f1` and `f2` calculated
    first using a `for` loop and then using a list comprehension:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导非常灵活；例如，考虑以下代码。它本质上展示了两种不同的函数组合方式，其中我们将一个函数（`x * 4`）应用到另一个函数（`x * 2`）上。以下代码打印出两个列表，分别表示使用`for`循环和列表推导计算出的`f1`和`f2`的函数组合：
- en: '[PRE3]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The first line of output is from the for loop construct. The second is from
    the list comprehension expression:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第一行来自`for`循环结构。第二行来自列表推导表达式：
- en: '![](img/image_01_014.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_01_014.png)'
- en: 'List comprehensions can also be used to replicate the action of nested loops
    in a more compact form. For example, we multiply each of the elements contained
    within `list1` with each other:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导也可以用来以更紧凑的形式复制嵌套循环的动作。例如，我们将`list1`中包含的每个元素相互相乘：
- en: '![](img/image_01_015.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_01_015.png)'
- en: 'We can also use list comprehensions with other objects such as strings, to
    build more complex structures. For example, the following code creates a list
    of words and their letter count:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用列表推导与其他对象（如字符串）一起使用，以构建更复杂的数据结构。例如，以下代码创建了一个包含单词及其字母计数的列表：
- en: '![](img/image_01_016.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_01_016.png)'
- en: As we will see, lists form the foundation of many of the data structures we
    will look at. Their versatility, ease of creation, and use enables them to build
    more specialized and complex data structures.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将看到的，列表是我们将要查看的许多数据结构的基础。它们的灵活性、创建和使用简便性使它们能够构建更专业和复杂的数据结构。
- en: Functions as first class objects
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数作为一等对象
- en: 'In Python, it is not only data types that are treated as objects. Both functions
    and classes are what are known as first class objects, allowing them to be manipulated
    in the same ways as built-in data types. By definition, first class objects are:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，不仅数据类型被视为对象。函数和类都是一等对象，允许它们以与内置数据类型相同的方式进行操作。根据定义，一等对象是：
- en: Created at runtime
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时创建
- en: Assigned as a variable or in a data structure
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为变量或数据结构中的赋值
- en: Passed as an argument to a function
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为函数的参数传递
- en: Returned as the result of a function
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为函数的结果返回
- en: In Python, the term **first class object** is a bit of a misnomer since it implies
    some sort of hierarchy, whereas all Python objects are essentially first class.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，术语**一等对象**有点误导，因为它暗示了一种某种层次结构，而所有Python对象本质上都是一等对象。
- en: 'To have a look at how this works, let''s define a simple function:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这是如何工作的，让我们定义一个简单的函数：
- en: '[PRE4]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Since user-defined functions are objects, we can do things such as include
    them in other objects, such as lists:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用户定义的函数是对象，我们可以做诸如将它们包含在其他对象中（如列表）之类的事情：
- en: '![](img/image_01_017.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片2](img/image_01_017.png)'
- en: 'Functions can also be used as arguments for other functions. For example, we
    can define the following function:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也可以用作其他函数的参数。例如，我们可以定义以下函数：
- en: '![](img/image_01_018.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/image_01_018.png)'
- en: Here, `callf()` takes a function as an argument, sets a language variable to
    `'eng'`, and then calls the function with the language variable as its argument.
    We could see how this would be useful if, for example, we wanted to produce a
    program that returns specific sentences in a variety of languages, perhaps for
    some sort of natural language application. Here we have a central place to set
    the language. As well as our `greeting` function, we could create similar functions
    that return different sentences. By having one point where we set the language,
    the rest of the program logic does not have to worry about this. If we want to
    change the language, we simply change the language variable and we can keep everything
    else the same.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`callf()`接受一个函数作为参数，设置一个语言变量为`'eng'`，然后使用语言变量作为参数调用该函数。例如，如果我们想创建一个返回多种语言的特定句子的程序，这可能用于某种自然语言应用，我们可以看到这将是有用的。在这里，我们有一个设置语言的中心位置。除了我们的`greeting`函数外，我们还可以创建返回不同句子的类似函数。通过在设置语言的一个点上，程序的其他逻辑就不必担心这一点。如果我们想更改语言，我们只需更改语言变量，就可以保持其他一切不变。
- en: Higher order functions
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶函数
- en: 'Functions that take other functions as arguments, or that return functions,
    are called **higher order functions**. Python 3 contains two built-in higher order
    functions, `filter()` and `map()`. Note that in earlier versions of Python, these
    functions returned lists; in Python 3, they return an iterator, making them much
    more efficient. The `map()` function provides an easy way to transform each item
    into an iterable object. For example, here is an efficient, compact way to perform
    an operation on a sequence. Note the use of the `lambda` anonymous function:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 将其他函数作为参数或返回函数的函数称为**高阶函数**。Python 3 包含两个内置的高阶函数，`filter()`和`map()`。请注意，在Python的早期版本中，这些函数返回列表；在Python
    3中，它们返回一个迭代器，这使得它们更加高效。`map()`函数提供了一个简单的方法将每个项转换为一个可迭代的对象。例如，这是一个高效、紧凑地对序列执行操作的方法。注意使用`lambda`匿名函数：
- en: '![](img/image_01_019.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片5](img/image_01_019.png)'
- en: 'Similarly, we can use the `filter` built-in function to filter items in a list:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以使用内置的`filter`函数来过滤列表中的项：
- en: '![](img/image_01_020.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片4](img/image_01_020.png)'
- en: Note that both `map` and `filter` perform the identical function as to what
    can be achieved by list comprehensions. There does not seem to be a great deal
    of difference in the performance characteristics apart from a slight performance
    advantage when using the in built functions `map` and `filter` without the `lambda`
    operator, compared to list comprehensions. Despite this, most style guides recommend
    the use of list comprehensions over built-in functions, possibly because they
    tend to be easier to read.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`map`和`filter`在实现上与列表推导式所能达到的功能相同。除了使用内置函数`map`和`filter`而不使用`lambda`运算符时，性能略有优势之外，似乎在性能特征上没有很大的差异。尽管如此，大多数风格指南推荐使用列表推导式而不是内置函数，这可能是由于它们通常更容易阅读。
- en: 'Creating our own higher order functions is one of the hallmarks of functional
    programming style. A practical example of how higher order functions can be useful
    is demonstrated by the following. Here we are passing the `len` function as the
    key to the `sort` function. This way, we can sort a list of words by length:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 创建我们自己的高阶函数是函数式编程风格的一个显著特点。以下是如何使用高阶函数的一个实际示例。在这里，我们将`len`函数作为键传递给`sort`函数。这样，我们可以根据长度对单词列表进行排序：
- en: '![](img/image_01_021.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片6](img/image_01_021.png)'
- en: 'Here is another example for case-insensitive sorting:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个不区分大小写的排序示例：
- en: '![](img/image_01_022.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片3](img/image_01_022.png)'
- en: Note the difference between the `list.sort()` method and the `sorted` built-in
    function. `list.sort()`, a method of the `list` object, sorts the existing instance
    of a list without copying it. This method changes the target object and returns
    `None`. It is an important convention in Python that functions or methods that
    change the object return `None` to make it clear that no new object was created
    and that the object itself was changed.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`list.sort()`方法和内置的`sorted`函数之间的区别。`list.sort()`是`list`对象的一个方法，它对列表的现有实例进行排序而不进行复制。此方法改变目标对象并返回`None`。在Python中，这是一个重要的约定，即改变对象的函数或方法返回`None`，以清楚地表明没有创建新对象，而是改变了对象本身。
- en: On the other hand, the sorted built-in function returns a new list. It actually
    accepts any iterable object as an argument, but it will always return a list.
    Both `list sort` and `sorted` take two optional keyword arguments as key.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，内置的`sorted`函数返回一个新的列表。它实际上接受任何可迭代对象作为参数，但它总是返回一个列表。`list sort`和`sorted`都接受两个可选的关键字参数作为键。
- en: 'A simple way to sort more complex structures is to use the index of the element
    to sort using the `lambda` operator, for example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`lambda`运算符通过元素的索引对更复杂的数据结构进行排序是一种简单的方法，例如：
- en: '![](img/image_01_023.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_01_023.png)'
- en: Here we have sorted the items by price.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们根据价格对项目进行了排序。
- en: Recursive functions
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归函数
- en: Recursion is one of the most fundamental concepts of computer science. In Python,
    we can implement a recursive function simply by calling it within its own function
    body. To stop a recursive function turning into an infinite loop, we need at least
    one argument that tests for a terminating case to end the recursion. This is sometimes
    called the base case. It should be pointed out that recursion is different from
    iteration. Although both involve repetition, iteration loops through a sequence
    of operations, whereas recursion repeatedly calls a function. Both need a selection
    statement to end. Technically, recursion is a special case of iteration known
    as tail iteration, and it is usually always possible to convert an iterative function
    to a recursive function and vice versa. The interesting thing about recursive
    functions is that they are able to describe an infinite object within a finite
    statement.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是计算机科学中最基本的概念之一。在Python中，我们可以通过在其自身函数体内调用它来实现递归函数。为了防止递归函数变成无限循环，我们需要至少一个测试终止情况的参数来结束递归。这有时被称为基本情况。应该指出的是，递归与迭代不同。尽管两者都涉及重复，迭代通过一系列操作进行循环，而递归则反复调用函数。两者都需要选择语句来结束。技术上，递归是迭代的一个特殊案例，称为尾递归，并且通常总是可以将迭代函数转换为递归函数，反之亦然。关于递归函数有趣的是，它们能够在有限语句中描述无限对象。
- en: 'The following code should demonstrate the difference between recursion and
    iteration. Both these functions simply print out numbers between `low` and `high`,
    the first one using iteration and the second using recursion:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码应该演示递归和迭代的区别。这两个函数简单地打印出`low`和`high`之间的数字，第一个使用迭代，第二个使用递归：
- en: '![](img/image_01_024.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_01_024.png)'
- en: Notice, `iterTest`, the iteration example, we use a `while` statement to test
    for the condition, then call the `print` method, and finally increment the `low`
    value. The recursive example tests for the condition, prints, then calls itself,
    incrementing the `low` variable in its argument. In general, iteration is more
    efficient; however, recursive functions are often easier to understand and write.
    Recursive functions are also useful for manipulating recursive data structures
    such as linked lists and trees, as we will see.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在迭代示例`iterTest`中，我们使用`while`语句测试条件，然后调用`print`方法，最后增加`low`值。递归示例测试条件，打印，然后调用自身，在其参数中增加`low`变量。一般来说，迭代更有效；然而，递归函数通常更容易理解和编写。递归函数也适用于操作递归数据结构，如链表和树，正如我们将看到的。
- en: Generators and co-routines
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器和协程
- en: 'We can create functions that do not just return one result, but rather an entire
    sequence of results, by using the `yield` statement. These functions are called
    **generators.** Python contains generator functions, which are an easy way to
    create iterators and they are especially useful as a replacement for unworkably
    long lists. A generator yields items rather than build lists. For example, the
    following code shows why we might choose to use a generator as opposed to creating
    a list:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`yield`语句来创建不仅返回一个结果，而是返回整个结果序列的函数。这些函数被称为**生成器**。Python包含生成器函数，这是一种创建迭代器的简单方法，并且它们特别适用于替代无法工作的长列表。生成器产生项目而不是构建列表。例如，以下代码展示了为什么我们可能选择使用生成器而不是创建列表：
- en: '[PRE5]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This prints out the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出以下内容：
- en: '![](img/image_01_025.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_01_025.png)'
- en: As we can see, building a list to do this calculation takes significantly longer.
    The performance improvement as a result of using generators is because the values
    are generated on demand, rather than saved as a list in memory. A calculation
    can begin before all the elements have been generated and elements are generated
    only when they are needed.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，构建一个列表来完成这个计算需要更长的时间。使用生成器带来的性能提升是因为值是在需要时生成的，而不是作为列表保存在内存中。计算可以在所有元素生成之前开始，并且只有在需要时才会生成元素。
- en: In the preceding example, the `sum` method loads each number into memory when
    it is needed for the calculation. This is achieved by the generator object repeatedly
    calling the `__next__()` special method. Generators never return a value other
    than `None`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`sum`方法在需要用于计算时将每个数字加载到内存中。这是通过生成器对象反复调用`__next__()`特殊方法来实现的。生成器永远不会返回除`None`之外的其他值。
- en: 'Typically, generator objects are used in `for` loops. For example, we can make
    use of the `oddcount` generator function created in the preceding code to print
    out odd integers between `1` and `10`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，生成器对象用于`for`循环中。例如，我们可以利用前面代码中创建的`oddcount`生成器函数来打印出`1`到`10`之间的奇数：
- en: '[PRE6]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can also create a **generator expression,** which, apart from replacing
    square brackets with parentheses, uses the same syntax and carries out the same
    operation as list comprehensions. Generator expressions, however, do not create
    a list, they create a **generator object**. This object does not create the data,
    but rather creates that data on demand. This means that generator objects do not
    support sequence methods such as `append()` and `insert()`. You can, however,
    change a generator into a list using the `list()` function:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建一个**生成器表达式**，它除了将方括号替换为圆括号外，使用相同的语法并执行与列表推导式相同的操作。然而，生成器表达式并不创建列表，而是创建一个**生成器对象**。这个对象并不创建数据，而是在需要时创建数据。这意味着生成器对象不支持如`append()`和`insert()`之类的序列方法。但是，你可以使用`list()`函数将生成器转换为列表：
- en: '![](img/image_01_026.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_01_026.png)'
- en: Classes and object programming
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类和面向对象编程
- en: Classes are a way to create new kinds of objects and they are central to object-oriented
    programming. A class defines a set of attributes that are shared across instances
    of that class. Typically, classes are sets of functions, variables, and properties.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 类是创建新类型对象的一种方式，它们是面向对象编程的核心。类定义了一组属性，这些属性在类的各个实例之间共享。通常，类是一组函数、变量和属性的集合。
- en: The object-oriented paradigm is compelling because it gives us a concrete way
    to think about and represent the core functionality of our programs. By organizing
    our programs around objects and data rather than actions and logic, we have a
    robust and flexible way to build complex applications. The actions and logic are
    still present of course, but by embodying them in objects, we have a way to encapsulate
    functionality, allowing objects to change in very specific ways. This makes our
    code less error-prone, easier to extend and maintain, and able to model real-world
    objects.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象范式非常有吸引力，因为它为我们提供了一个具体的方式来思考和表示程序的核心功能。通过围绕对象和数据而不是动作和逻辑来组织我们的程序，我们有一个强大且灵活的方式来构建复杂的应用程序。当然，动作和逻辑仍然存在，但通过将它们体现在对象中，我们有了封装功能的方法，允许对象以非常具体的方式改变。这使得我们的代码更不容易出错，更容易扩展和维护，并且能够模拟现实世界的对象。
- en: 'Classes are created in Python using the `class` statement. This defines a set
    of shared attributes associated with a collection of class instances. A class
    usually consists of a number of methods, class variables, and computed properties.
    It is important to understand that defining a class does not, by itself, create
    any instances of that class. To create an instance, a variable must be assigned
    to a class. The class body consists of a series of statements that execute during
    the class definition. The functions defined inside a class are called **instance
    methods.** They apply some operations to the class instance by passing an instance
    of that class as the first argument. This argument is called `self` by convention,
    but it can be any legal identifier. Here is a simple example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，使用 `class` 语句创建类。这定义了一组与类实例集合相关的共享属性。一个类通常包含多个方法、类变量和计算属性。重要的是要理解，定义一个类本身并不会创建该类的任何实例。要创建一个实例，必须将一个变量分配给一个类。类体由一系列在类定义期间执行的语句组成。在类内部定义的函数称为**实例方法**。它们通过传递该类的实例作为第一个参数来对类实例执行一些操作。这个参数传统上被称为
    `self`，但它可以是任何合法的标识符。以下是一个简单的例子：
- en: '[PRE7]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Class variables, such as `numEmployee`, share values among all the instances
    of the class. In this example, `numEmployee` is used to count the number of employee
    instances. Note that the `Employee` class implements the `__init__` and `__del__` special
    methods, which we will discuss in the next section.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 类变量，如 `numEmployee`，在类的所有实例之间共享值。在这个例子中，`numEmployee` 用于计算员工实例的数量。请注意，`Employee`
    类实现了 `__init__` 和 `__del__` 特殊方法，我们将在下一节讨论。
- en: 'We can create instances of the `Employee` objects, run methods, and return
    class and instance variables by doing the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式创建 `Employee` 对象的实例，运行方法，并返回类和实例变量：
- en: '![](img/image_01_027.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_01_027.png)'
- en: Special methods
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特殊方法
- en: We can use the `dir(object)` function to get a list of attributes of a particular
    object. The methods that begin and end with two underscores are called **special
    methods.** Apart from the following exception**,** special method, are generally
    called by the Python interpreter rather than the programmer; for example, when
    we use the `+` operator, we are actually invoking a call to `__add__()`. For example,
    rather than using `my_object.__len__()` we can use `len(my_object)` using `len()`
    on a string object is actually much faster because it returns the value representing
    the object's size in memory, rather than making a call to the object's `__len__`
    method. The only special method we actually call in our programs, as common practice,
    is the `__init__` method, to invoke the initializer of the superclass in our own
    class definitions. It is strongly advised not to use the double underscore syntax
    for your own objects because of potential current or future conflicts with Python's
    own special methods.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `dir(object)` 函数获取特定对象的属性列表。以两个下划线开头和结尾的方法称为**特殊方法**。除了以下例外**，特殊方法通常由
    Python 解释器而不是程序员调用；例如，当我们使用 `+` 运算符时，我们实际上是在调用 `__add__()`。例如，我们不必使用 `my_object.__len__()`，而是可以使用
    `len(my_object)`。在字符串对象上使用 `len()` 实际上要快得多，因为它返回表示对象在内存中大小的值，而不是调用对象的 `__len__`
    方法。我们实际上在程序中调用的唯一特殊方法是 `__init__` 方法，用于在类定义中调用超类初始化器。强烈建议不要在自己的对象中使用双下划线语法，因为可能会与
    Python 的特殊方法产生当前或未来的冲突。
- en: 'We may, however, want to implement special methods in custom objects, to give
    them some of the behavior of built-in types. In the following code, we create
    a class that implements the `__repr__` method. This method creates a string representation
    of our object that is useful for inspection purposes:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可能想在自定义对象中实现特殊方法，以赋予它们一些内置类型的某些行为。在下面的代码中，我们创建了一个实现了 `__repr__` 方法的类。该方法创建了一个字符串表示，这对于检查目的很有用：
- en: '[PRE8]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When we create an instance of this object and inspect it, we can see we get
    our customized string representation. Notice the use of the `%r` format placeholder
    to return the standard representation of the object. This is useful and best practice,
    because, in this case, it shows us that the `greet` object is a string indicated
    by the quotation marks:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建这个对象的实例并检查它时，我们可以看到我们得到了定制的字符串表示。注意使用了 `%r` 格式占位符来返回对象的规范表示。这很有用，是最佳实践，因为在这种情况下，它显示
    `greet` 对象是一个由引号指示的字符串：
- en: '![](img/image_01_028.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_01_028.png)'
- en: Inheritance
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: 'It is possible to create a new class that modifies the behavior of an existing
    class through inheritance. This is done by passing the inherited class as an argument
    in the class definition. It is often used to modify the behavior of existing methods,
    for example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通过继承，可以创建一个新的类来修改现有类的行为。这是通过在类定义中将继承的类作为参数来实现的。这通常用于修改现有方法的行为，例如：
- en: '[PRE9]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: An instance of the `specialEmployee` class is identical to an `Employee` instance
    except for the changed `hours()` method.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`specialEmployee` 类的实例与 `Employee` 实例相同，除了更改了 `hours()` 方法。'
- en: 'For a subclass to define new class variables, it needs to define an `__init__()`
    method, as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使子类定义新的类变量，它需要定义一个 `__init__()` 方法，如下所示：
- en: '[PRE10]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that the methods of the base class are not automatically invoked and
    it is necessary for the derived class to call them. We can test for class membership
    using the built-in function `isintance(obj1, obj2)`. This returns true if `obj1`
    belongs to the class of `obj2` or any class derived from `obj2`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，基类的方 法不是自动调用的，并且派生类需要调用它们。我们可以使用内置函数 `isinstance(obj1, obj2)` 来测试类成员资格。如果
    `obj1` 属于 `obj2` 的类或从 `obj2` 派生的任何类，则返回 true。
- en: Within a class definition, it is assumed that all methods operate on the instance,
    but this is not a requirement. There are, however, other types of methods: **static
    methods** and **class methods**. A static method is just an ordinary function
    that just happens to be defined in a class. It does not perform any operations
    on the instance and it is defined using the `@staticmethod` class decorator. Static
    methods cannot access the attributes of an instance, so their most common usage
    is as a convenience to group utility functions together.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在类定义中，假设所有方法都操作实例，但这不是必需的。然而，还有其他类型的方 法：**静态方法**和**类方法**。静态方法只是一个恰好定义在类中的普通函数。它不对实例执行任何操作，并且使用
    `@staticmethod` 类装饰器定义。静态方法不能访问实例的属性，因此它们最常用的用途是将实用函数分组在一起。
- en: Class methods operate on the class itself, not the instance, in the same way
    that class variables are associated with the classes rather than instances of
    that class. They are defined using the `@classmethod` decorator, and are distinguished
    from instance methods in that the class is passed as the first argument. This
    is named `cls` by convention.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法操作的是类本身，而不是实例，就像类变量与类相关而不是与该类的实例相关一样。它们使用 `@classmethod` 装饰器定义，并且与实例方法区分开来，因为类作为第一个参数传递。按照惯例，这个参数命名为
    `cls`。
- en: '[PRE11]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The class `Bexp` inherits from the `Aexp` class and changes the base class
    variable to `3`. We can run the parent class''s `exp()` method as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `Bexp` 从 `Aexp` 类继承，并将基类变量更改为 `3`。我们可以如下运行父类的 `exp()` 方法：
- en: '![](img/image_01_029.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_01_029.png)'
- en: Although this example is a little contrived, there are several reasons why class
    methods may be useful. For example, because a subclass inherits all the same features
    of its parent, there is the potential for it to break inherited methods. Using
    class methods is a way to define exactly what methods are run.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个例子有点牵强，但有几个原因说明类方法可能很有用。例如，因为子类继承了其父类的所有相同功能，所以它有可能破坏继承的方法。使用类方法是一种定义确切运行哪些方法的方式。
- en: Data encapsulation and properties
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据封装和属性
- en: Unless otherwise specified, all attributes and methods are accessible without
    restriction. This also means that everything defined in a base class is accessible
    from a derived class. This may cause problems when we are building object-oriented
    applications where we may want to hide the internal implementation of an object.
    This can lead to namespace conflicts between objects defined in derived classes
    with the base class. To prevent this, the methods we define private attributes
    with have a double underscore, such as `__privateMethod()`. These method names
    are automatically changed to `_Classname__privateMethod()` to prevent name conflicts
    with methods defined in base classes. Be aware that this does not strictly hide
    private attributes, rather it just provides a mechanism for preventing name conflicts.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 除非另有说明，否则所有属性和方法都可以无限制地访问。这也意味着在基类中定义的任何内容都可以从派生类中访问。这可能导致我们在构建面向对象的应用程序时遇到问题，我们可能希望隐藏对象的内部实现。这可能导致派生类中定义的对象与基类定义的方法之间出现命名空间冲突。为了防止这种情况，我们定义私有属性的方法具有双下划线，例如`__privateMethod()`。这些方法名会自动更改为`_Classname__privateMethod()`，以防止与基类中定义的方法发生名称冲突。请注意，这并不严格地隐藏私有属性，而只是提供了一种防止名称冲突的机制。
- en: 'It is recommended to use private attributes when using a class **property**
    to define mutable attributes. A property is a kind of attribute that rather than
    returning a stored value, computes its value when called. For example, we could
    redefine the `exp()` property with the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 建议在使用类**属性**定义可变属性时使用私有属性。属性是一种属性，它不是返回存储的值，而是在调用时计算其值。例如，我们可以用以下方式重新定义`exp()`属性：
- en: '[PRE12]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this chapter, we have looked at some of the fundamentals of the Python programming
    language, from basic operations to functions, classes, and objects in Python.
    In the next chapter, we will examine, in detail, the built-in data structures
    of Python.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Python编程语言的一些基础知识，从基本操作到Python中的函数、类和对象。在下一章中，我们将详细探讨Python的内置数据结构。
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has given us a good foundation and introduction into Python programming.
    We covered the use of variables, lists, a couple of control structures, and learned
    how to use conditionals statement. The various kinds of objects were discussed,
    together with some materials on the object-oriented aspects of the Python language.
    We created our own objects and inherited from them.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为我们提供了Python编程的良好基础和入门。我们涵盖了变量的使用、列表、几个控制结构，并学习了如何使用条件语句。讨论了各种类型的对象，以及Python语言面向对象方面的相关材料。我们创建了自定义对象并从它们继承。
- en: There is still more that Python offers. As we prepare to examine the later chapters
    on some implementations of algorithms, the next chapter will focus on numbers,
    sequences, maps, and sets. These are also data types in Python that prove useful
    when organizing data for a series of operations.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Python还有更多功能。随着我们准备检查关于算法实现的一些后续章节，下一章将专注于数字、序列、映射和集合。这些也是Python中的数据类型，在组织数据以进行一系列操作时非常有用。
