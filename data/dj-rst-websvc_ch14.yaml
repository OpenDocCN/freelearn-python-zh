- en: Using Generalized Behavior from the APIView Class
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 APIView 类的泛化行为
- en: 'In this chapter, we will improve our simple RESTful Web Service. We will make
    it possible for it to work with diverse content types without writing a huge amount
    of code. We will take advantage of advanced features and generalized behaviors
    included in the Django REST framework to enable multiple parsers and renderers.
    We will gain an understanding of:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将改进我们的简单 RESTful Web 服务。我们将使其能够与各种内容类型一起工作，而无需编写大量代码。我们将利用 Django REST
    framework 中的高级功能和泛化行为，以启用多个解析器和渲染器。我们将了解：
- en: Taking advantage of model serializers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用模型序列化器
- en: Understanding accepted and returned content types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解接受和返回的内容类型
- en: Making unsupported HTTP OPTIONS requests with command-line tools
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令行工具发送不支持的 HTTP OPTIONS 请求
- en: Understanding decorators that work as wrappers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解作为包装器的装饰器
- en: Using decorators to enable different parsers and renderers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用装饰器启用不同的解析器和渲染器
- en: Taking advantage of content negotiation classes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用内容协商类
- en: Making supported HTTP OPTIONS requests with command-line tools
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令行工具发送支持的 HTTP OPTIONS 请求
- en: Working with different content types
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与不同内容类型一起工作
- en: Sending HTTP requests with unsupported HTTP verbs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不支持的 HTTP 动词发送 HTTP 请求
- en: Taking advantage of model serializers
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用模型序列化器
- en: In [Chapter 1](dj-rst-websvc_ch11.html), *Installing the Required Software and
    Tools*, we created the toy model (the `Toy` class) and its serializer (the `ToySerializer`
    class). When we wrote the code for the `ToySerializer` class, we had to declare
    many attributes with the same names that we used in the `Toy` class. The `ToySerializer`
    class is a subclass of the `rest_framework.serializers.Serializer` superclass;
    it declares attributes that we manually mapped to the appropriate types, and overrides
    the `create` and `update` methods. However, we repeated a lot of code and information
    that was already included in the toy model, such as the types and the `max_length`
    values that specify the maximum length for each string field.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 1 章](dj-rst-websvc_ch11.html)，*安装所需的软件和工具*中，我们创建了玩具模型（`Toy` 类）及其序列化器（`ToySerializer`
    类）。当我们编写 `ToySerializer` 类的代码时，我们必须声明许多与 `Toy` 类中使用的相同名称的属性。`ToySerializer` 类是
    `rest_framework.serializers.Serializer` 超类的子类；它声明了我们将手动映射到适当类型的属性，并覆盖了 `create`
    和 `update` 方法。然而，我们重复了很多已经在玩具模型中包含的代码和信息，例如指定每个字符串字段最大长度的 `types` 和 `max_length`
    值。
- en: Now, we will take advantage of model serializers to simplify code and to avoid
    repeating information that is already included in the model. We will create a
    new version of the existing `ToySerializer` class that will inherit from the `rest_framework.serializers.ModelSerializer`
    superclass instead of inheriting from the `rest_framework.serializers.ModelSerializer`
    superclass.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将利用模型序列化器来简化代码并避免重复模型中已经包含的信息。我们将创建一个新的 `ToySerializer` 类版本，它将继承自 `rest_framework.serializers.ModelSerializer`
    超类，而不是继承自 `rest_framework.serializers.ModelSerializer` 超类。
- en: The `ModelSerializer` class automatically populates a set of default fields
    and default validators by retrieving metadata from the related model class that
    we must specify. In addition, the `ModelSerializer` class provides default implementations
    for the `create` and `update` methods. In this case, we will take advantage of
    these default implementations because they will be suitable to provide our necessary
    `create` and `update` methods.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`ModelSerializer` 类通过从我们必须指定的相关模型类检索元数据来自动填充一组默认字段和默认验证器。此外，`ModelSerializer`
    类为 `create` 和 `update` 方法提供了默认实现。在这种情况下，我们将利用这些默认实现，因为它们将适合提供我们需要的 `create` 和
    `update` 方法。'
- en: 'Go to the `restful01/toys` folder and open the `serializers.py` file. The code
    file for the sample is included in the `hillar_django_restful_04_01` folder, in
    the `restful01/toys/serializers.py` file. Replace the code in this file with the
    following code that declares the new version of the `ToySerializer` class:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 `restful01/toys` 文件夹并打开 `serializers.py` 文件。示例代码文件包含在 `hillar_django_restful_04_01`
    文件夹中的 `restful01/toys/serializers.py` 文件中。将此文件中的代码替换为以下声明新版本 `ToySerializer` 类的代码：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The new version of the `ToySerializer` class declares a `Meta` inner class
    that declares the following two attributes:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本的 `ToySerializer` 类声明了一个 `Meta` 内部类，该类声明了以下两个属性：
- en: '`model`: This attribute specifies the model related to the serializer, that
    is, the `Toy` class'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`model`: 此属性指定与序列化器相关的模型，即 `Toy` 类'
- en: '`fields`: This attribute specifies a tuple of `string` whose values indicate
    the field names that we want to include in the serialization from the related
    model (the `Toy` class)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields`：此属性指定了一个包含`string`值的元组，这些值指示我们想要包含在从相关模型（`Toy`类）序列化中的字段名称'
- en: The new version of the `ToySerializer` class doesn't need to override either
    the `create` or `update` methods because the generic behavior provided by the
    `ModelSerializer` class will be enough in this case. The `ModelSerializer` superclass
    provides implementations for both methods.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 新版的`ToySerializer`类不需要重写`create`或`update`方法，因为`ModelSerializer`类提供的通用行为在这种情况下就足够了。`ModelSerializer`超类为这两个方法提供了实现。
- en: With the changes we have made, we removed a nice amount of code from the `ToySerializer`
    class. In the new version, we just had to specify the related model and the desired
    set of fields in a tuple. Now, the types and `max_length` values related to the
    toy fields are only included in the `Toy` class.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们所做的更改，我们从`ToySerializer`类中移除了一大块代码。在新版本中，我们只需在元组中指定相关的模型和所需的字段集。现在，与玩具字段相关的类型和`max_length`值仅包含在`Toy`类中。
- en: If you have previous experience with the Django Web framework, you will realize
    that the `Serializer` and `ModelSerializer` classes in the Django REST framework
    are similar to the `Form` and `ModelForm` classes in Django.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有使用Django Web框架的先前经验，您会意识到Django REST框架中的`Serializer`和`ModelSerializer`类与Django中的`Form`和`ModelForm`类相似。
- en: You can press *Ctrl* + *C* to quit Django's development server and execute the
    command that we learned in [Chapter 3](dj-rst-websvc_ch13.html), *Creating API
    Views*, to run the server to start it again. In this case, we just edited one
    file, and in case you didn't stop the development server, Django will detect the
    changes when we save the changes to the file and it will automatically restart
    the server.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按*Ctrl* + *C*来退出Django的开发服务器并执行我们在[第3章](dj-rst-websvc_ch13.html)，*创建API视图*，中学到的命令，以重新启动服务器。在这种情况下，我们只编辑了一个文件，如果您没有停止开发服务器，当我们将更改保存到文件时，Django将检测到这些更改，并自动重新启动服务器。
- en: 'The following lines show sample output that you will see after you save the
    changes in the edited Python file. The lines indicate that Django has restarted
    the development server and successfully performed a system check that identified
    no issues:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了在您保存编辑后的Python文件更改后将会看到的示例输出。这些行表明Django已重新启动开发服务器并成功执行了系统检查，没有发现任何问题：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can use the command-line and GUI tools we used in [Chapter 3](dj-rst-websvc_ch13.html),
    *Creating API Views*, to test the new version of our RESTful Web Service that
    takes advantage of model serializers. The behavior will be the same as in the
    previous version. However, we definitely have less code to maintain and we have
    removed duplicated data.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用我们在[第3章](dj-rst-websvc_ch13.html)中使用的命令行和GUI工具，*创建API视图*，来测试我们利用模型序列化器优势的新版RESTful
    Web Service。其行为将与上一版本相同。然而，我们确实减少了需要维护的代码量，并去除了重复的数据。
- en: Understanding accepted and returned content types
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解接受和返回的内容类型
- en: 'So far, our RESTful Web Service has been working with JSON for the response
    body. The code we wrote in the `toys/views.py` file in [Chapter 3](https://cdp.packtpub.com/django_restful_web_services__/wp-admin/post.php?post=61&action=edit#post_56), *Creating
    API Views*, declares a `JSONResponse` class and two function-based views. These
    functions return a `JSONResponse` when it is necessary to return JSON data and
    a `django.Http.Response.HttpResponse` instance when the response is just an HTTP
    status code. No matter the accepted content type specified in the HTTP request
    header, the view functions always provide the same content in the response body:
    JSON.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的RESTful Web Service一直使用JSON作为响应体。我们在[第3章](https://cdp.packtpub.com/django_restful_web_services__/wp-admin/post.php?post=61&action=edit#post_56)，*创建API视图*，中`toys/views.py`文件编写的代码声明了一个`JSONResponse`类和两个基于函数的视图。这些函数在需要返回JSON数据时返回`JSONResponse`，在响应只是一个HTTP状态码时返回`django.Http.Response.HttpResponse`实例。无论HTTP请求头中指定的接受内容类型如何，视图函数始终在响应体中提供相同的内容：JSON。
- en: 'Run the following command to retrieve all the toys with the `Accept` request
    header key set to `text/html`. Remember that the virtual environment we have created
    in [Chapter 3](https://cdp.packtpub.com/django_restful_web_services__/wp-admin/post.php?post=61&action=edit#post_56), *Creating
    API Views*, must be activated in order to run the next `http` command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以检索所有玩具，并将 `Accept` 请求头键设置为 `text/html`。请记住，我们创建的虚拟环境（[第 3 章](https://cdp.packtpub.com/django_restful_web_services__/wp-admin/post.php?post=61&action=edit#post_56)，*创建
    API 视图*）必须激活，以便运行下一个 `http` 命令：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The previous commands will compose and send the following HTTP request: `GET
    http://localhost:8000/toys/`. These commands specify the `text/html` value for
    the `Accept` key in the request header. This way, the HTTP request indicates that
    it accepts a response of `text/html`.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组合并发送以下 HTTP 请求：`GET http://localhost:8000/toys/`。这些命令指定请求头中的 `Accept`
    键的值为 `text/html`。这样，HTTP 请求表明它接受 `text/html` 格式的响应。
- en: 'The header response for the request will include the following line:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请求的响应头将包括以下行：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, run the following command to retrieve all the toys with different values
    with the `Accept` request header key set to `text/html`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行以下命令以检索所有玩具，并将 `Accept` 请求头键设置为不同的值，即 `text/html`。
- en: 'Run the following command to retrieve all the toys with the `Accept` request
    header key set to `application/json`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以检索所有玩具，并将 `Accept` 请求头键设置为 `application/json`：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The previous commands will compose and send the following HTTP request: `GET
    http://localhost:8000/toys/`. These commands specify the `application/json` value
    for the `Accept` key in the request header. This way, the HTTP request indicates
    that it accepts a response of `application/json`.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组合并发送以下 HTTP 请求：`GET http://localhost:8000/toys/`。这些命令指定请求头中的 `Accept`
    键的值为 `application/json`。这样，HTTP 请求表明它接受 `application/json` 格式的响应。
- en: 'The header response for the request will include the following line:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请求的响应头将包括以下行：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first group of commands defined the `text/html` value for the `Accept` request
    header key. The second group of commands defined the `application/json` value
    for the `Accept` request header key. However, both produced the same results and
    the responses were always in the JSON format. The view functions don't take into
    account the value specified for the `Accept` request header key in the HTTP requests.
    No matter the value indicated for the `Accept` request header key, the response
    is always in the JSON format.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组命令为 `Accept` 请求头键定义了 `text/html` 值。第二组命令为 `Accept` 请求头键定义了 `application/json`
    值。然而，它们都产生了相同的结果，并且响应始终是 JSON 格式。视图函数没有考虑到 HTTP 请求中指定的 `Accept` 请求头键的值。无论 `Accept`
    请求头键的值是什么，响应始终是 JSON 格式。
- en: We want to provide support for other formats. However, we don't want to write
    a huge amount of code to do so. Thus, we will take advantage of additional features
    included in the Django REST framework that will make it easy for us to support
    additional formats for our RESTful Web Service.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望提供对其他格式的支持。然而，我们不想为此编写大量的代码。因此，我们将利用 Django REST 框架中包含的额外功能，这将使我们能够轻松地为我们的
    RESTful Web 服务支持额外的格式。
- en: Making unsupported HTTP OPTIONS requests with command-line tools
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用命令行工具发送不支持的 HTTP OPTIONS 请求
- en: Sometimes, we don't know which are the HTTP methods or verbs that a resource
    or resource collection supports in a RESTful Web Service. In order to provide
    a solution to this problem, we can compose and send an HTTP request with the `OPTIONS`
    HTTP verb and the URL for the resource or the resource collection.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们不知道在 RESTful Web 服务中，资源或资源集合支持哪些 HTTP 方法或动词。为了解决这个问题，我们可以组合并发送一个使用 `OPTIONS`
    HTTP 动词和资源或资源集合的 URL 的 HTTP 请求。
- en: If the RESTful Web Service implements the `OPTIONS` HTTP verb for a resource
    or resource collection, it will build a response with an `Allow` key in the response
    header. The value for this key will include a comma-separated list of HTTP verbs
    or methods that it supports. In addition, the response header will include additional
    information about other supported options, such as the content type it is capable
    of parsing from the request and the content type it is capable of rendering in
    the response.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 RESTful 网络服务为资源或资源集合实现了 `OPTIONS` HTTP 动词，它将在响应头部中构建一个带有 `Allow` 键的响应。此键的值将包括一个以逗号分隔的
    HTTP 动词或方法列表，它支持这些动词或方法。此外，响应头部还将包括有关其他支持选项的附加信息，例如它能够从请求中解析的内容类型以及它能够在响应中呈现的内容类型。
- en: 'For example, if we want to know which HTTP verbs the toys collection supports,
    we can run the following command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想知道玩具收藏支持哪些 HTTP 动词，我们可以运行以下命令：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that the command will generate an error in the Django development server.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，该命令将在 Django 开发服务器中生成错误。
- en: 'The following is the equivalent curl command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的命令是等效的 curl 命令：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The previous command will compose and send the following HTTP request: `OPTIONS
    http://localhost:8000/toys/`. The request specifies `/toys/`, and therefore, it
    will match the `''^toys/$''` regular expression and run the `views.toy_list` function,
    that is, the `toy_list` function declared within the `toys/views.py` file. This
    function only runs code when the `request.method` is equal to either `''GET''`
    or `''POST''`. In this case, `request.method` is equal to `''OPTIONS''`, and therefore,
    the function won''t run any code. The function won''t return the expected `HttpResponse`
    instance.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组合并发送以下 HTTP 请求：`OPTIONS http://localhost:8000/toys/`。请求指定了 `/toys/`，因此它将匹配
    `'^toys/$'` 正则表达式，并运行 `views.toy_list` 函数，即 `toys/views.py` 文件中声明的 `toy_list`
    函数。该函数仅在 `request.method` 等于 `'GET'` 或 `'POST'` 时运行代码。在这种情况下，`request.method`
    等于 `'OPTIONS'`，因此该函数不会运行任何代码。该函数不会返回预期的 `HttpResponse` 实例。
- en: 'The lack of the expected `HttpResponse` instance generates an internal server
    error in Django''s development server. The console output for the development
    server will display details about the internal server error and a traceback similar
    to the one shown in the next screenshot. The last lines indicate that there is
    a `ValueError` because the `toys_list` function didn''t return an `HttpResponse`
    instance and returned `None` instead:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 缺少预期的 `HttpResponse` 实例会在 Django 开发服务器中生成内部服务器错误。开发服务器的控制台输出将显示关于内部服务器错误的详细信息以及类似于下一张截图中的跟踪回溯。最后几行表明存在一个
    `ValueError`，因为 `toys_list` 函数没有返回 `HttpResponse` 实例，而是返回了 `None`：
- en: '![](img/55ab16b6-55f0-468f-9018-5fb984162f02.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/55ab16b6-55f0-468f-9018-5fb984162f02.png)'
- en: 'The following lines show the header for the output displayed as a result of
    the HTTP request. The response also includes a detailed HTML document with a huge
    amount of information about the error because the debug mode is activated for
    Django. We receive an HTTP `500 Internal Server Error` status code. Obviously,
    we don''t want all this information to be provided in a production-ready web service,
    in which we will deactivate the debug mode:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了作为 HTTP 请求结果显示的输出头部。由于 Django 的调试模式被激活，响应还包括一个详细的 HTML 文档，其中包含大量关于错误的详细信息。我们收到
    HTTP `500 内部服务器错误` 状态码。显然，我们不想在准备好的生产级网络服务中提供所有这些信息，我们将禁用调试模式：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We don't want our web service to provide a response with an HTTP `500 Internal
    Server Error status` code when we receive a request with the `OPTIONS` verb to
    either a valid resource or resource collection. Obviously, we want to provide
    a more consistent web service and we want to provide an accurate response when
    we receive a request with the `OPTIONS` verbs, for either a toy resource or the
    toys collection.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望我们的网络服务在接收到 `OPTIONS` 动词的请求时，无论是针对有效资源还是资源集合，都返回 HTTP `500 内部服务器错误状态码`。显然，我们希望提供一个更一致的
    Web 服务，并且当接收到带有 `OPTIONS` 动词的请求时，无论是针对玩具资源还是玩具收藏，我们都希望提供一个准确的响应。
- en: If we compose and send an HTTP request with the `OPTIONS` verb for an existing
    toy resource, we will see the same error in the console output for the development
    server and a similar response with the HTTP `500 Internal Server Error status`
    code. The `views.toy_detail` function only runs code when the `request.method`
    is equal to `'GET'`, `'PUT',` or `'DELETE'`. Thus, as happened with the previous
    case, the `toys_detail` function won't return an `HttpResponse` instance and it
    will return `None` instead.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`OPTIONS`动词对一个现有的玩具资源进行组合和发送HTTP请求，我们将在开发服务器的控制台输出中看到相同的错误，以及一个带有HTTP
    `500 Internal Server Error`状态码的类似响应。`views.toy_detail`函数仅在`request.method`等于`'GET'`、`'PUT'`或`'DELETE'`时运行代码。因此，就像上一个案例一样，`toys_detail`函数不会返回`HttpResponse`实例，而是返回`None`。
- en: 'The following commands will produce the explained error when we try to see
    the options offered for the toy resource whose `id` or primary key is equal to
    `2`. Make sure you replace `2` with a primary key value of an existing toy in
    your configuration:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将在我们尝试查看ID或主键等于`2`的玩具资源提供的选项时产生所解释的错误。确保将`2`替换为配置中现有玩具的主键值：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following is the equivalent curl command:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的curl命令：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following screenshot shows the details of the internal server error and
    a traceback displayed in the console output for the development server after we
    run the previous HTTP request:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在运行之前的HTTP请求后，开发服务器控制台输出中显示的内部服务器错误详情和跟踪回溯：
- en: '![](img/a26ced03-ebeb-4d84-ae13-0a5cdc08ec29.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a26ced03-ebeb-4d84-ae13-0a5cdc08ec29.png)'
- en: Understanding decorators that work as wrappers
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解作为包装器的装饰器
- en: Now, we will make a few changes to the code in the `toys/views.py` file to provide
    support for the `OPTIONS` verb in our RESTful Web Service. Specifically, we will
    take advantage of a decorator provided by the Django REST framework.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将对`toys/views.py`文件中的代码进行一些修改，以提供对RESTful Web Service中`OPTIONS`动词的支持。具体来说，我们将利用Django
    REST framework提供的装饰器。
- en: 'We will use the `@api_view` decorator that is declared in the `rest_framework.decorators`
    module. We will apply this decorator to our function-based views: `toys_list`
    and `toys_detail`.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用在`rest_framework.decorators`模块中声明的`@api_view`装饰器。我们将把这个装饰器应用到我们的基于函数的视图上：`toys_list`和`toys_detail`。
- en: The `@api_view` decorator allows us to specify which are the HTTP verbs that
    the function to which it is applied can process. If the request that has been
    routed to the view function has an HTTP verb that isn't included in the string
    list specified as the `http_method_names` argument for the `@api_view` decorator,
    the default behavior returns a response with an HTTP `405 Method Not Allowed`
    status code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`@api_view`装饰器允许我们指定应用该装饰器的函数可以处理哪些HTTP动词。如果路由到视图函数的请求包含的HTTP动词不在作为`@api_view`装饰器的`http_method_names`参数指定的字符串列表中，默认行为会返回一个带有HTTP
    `405 Method Not Allowed`状态码的响应。'
- en: This way, we make sure that whenever the RESTful Web Service receives an HTTP
    verb that isn't considered within our function views, we won't generate an unexpected
    and undesired error in Django. The decorator generates the appropriate response
    for the unsupported HTTP verbs or methods. In addition, by reading the declaration
    of our function views, we can easily understand which HTTP verbs are handled by
    the function.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们确保每当RESTful Web Service收到一个不在我们函数视图考虑范围内的HTTP动词时，我们不会在Django中生成意外和不受欢迎的错误。装饰器为不支持的HTTP动词或方法生成适当的响应。此外，通过阅读我们的函数视图声明，我们可以轻松理解哪些HTTP动词由该函数处理。
- en: It is very important to understand what happens under the hood whenever we use
    the `@api_view` decorator. This decorator is a wrapper that converts a function-based
    view into a subclass of the `rest_framework.views.APIView` class. This class is
    the base class for all the views in the Django REST framework.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用`@api_view`装饰器时，理解底层发生的事情非常重要。这个装饰器是一个包装器，它将基于函数的视图转换为`rest_framework.views.APIView`类的子类。这个类是Django
    REST框架中所有视图的基类。
- en: We will work with class-based views in the forthcoming examples and we will
    have the same benefits we have analyzed for the function-based views that use
    the decorator.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，我们将使用基于类的视图，并且我们将获得我们已经分析过的基于装饰器的函数视图相同的益处。
- en: In addition, the decorator uses the string list we specify with the supported
    HTTP verbs to build the response for a request with the `OPTIONS` HTTP verb. The
    automatically generated response includes the supported method, and the parser
    and the render capabilities. In other words, the response includes the format
    that the function is capable of understanding and the format that the function
    can generate for the response.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，装饰器使用我们指定的支持 HTTP 动词的字符串列表来构建具有 `OPTIONS` HTTP 动词的请求的响应。自动生成的响应包括支持的方法、解析器和渲染能力。换句话说，响应包括函数能够理解的数据格式以及函数可以生成用于响应的数据格式。
- en: As previously explained, the current version of our RESTful Web Service is only
    capable of rendering JSON as its output. The usage of the decorator makes sure
    that we always receive an instance of the `rest_framework.request.Request` class
    in the `request` argument when Django calls our view function. In addition, the
    decorator handles the `ParserError` exceptions when our function views access
    the `request.data` attribute and there are parsing problems.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们当前版本的 RESTful Web 服务只能将 JSON 作为其输出格式。装饰器的使用确保了当 Django 调用我们的视图函数时，我们总是在
    `request` 参数中接收到 `rest_framework.request.Request` 类的实例。此外，装饰器处理当我们的函数视图访问 `request.data`
    属性并且存在解析问题时抛出的 `ParserError` 异常。
- en: Using decorators to enable different parsers and renderers
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用装饰器启用不同的解析器和渲染器
- en: We will make changes to just one file. After you save the changes, Django's
    development server will automatically restart. However, you can decide to stop
    Django's development server and start it again after you finish all the necessary
    changes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只修改一个文件。保存更改后，Django 开发服务器将自动重启。然而，您可以选择在完成所有必要的更改后停止 Django 开发服务器并重新启动。
- en: We will make the necessary changes to use the previously introduced `@api_view`
    decorator to make it possible for the RESTful Web Service to work with different
    parsers and renderers, by taking advantage of generalized behaviors provided by
    the `APIView` class.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进行必要的更改，使用之前引入的 `@api_view` 装饰器，利用 `APIView` 类提供的通用行为，使 RESTful Web 服务能够与不同的解析器和渲染器一起工作。
- en: 'Now, go to the `restful01/toys` folder and open the `views.py` file. Replace
    the code in this file with the following lines. However, take into account that
    many lines have been removed, such as the lines that declared the `JSONResponse`
    class. The code file for the sample is included in the `hillar_django_restful_04_02`
    folder, in the `restful01/toys/views.py` file:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，前往 `restful01/toys` 文件夹并打开 `views.py` 文件。将此文件中的代码替换为以下行。然而，请注意，已经删除了许多行，例如声明
    `JSONResponse` 类的行。示例代码文件包含在 `hillar_django_restful_04_02` 文件夹中，位于 `restful01/toys/views.py`
    文件：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The new code applies the `@api_view` decorator for the two functions: `toy_list`
    and `toy_detail`. In addition, the new code removes the `JSONResponse` class and
    uses the more generic `rest_framework.response.Response` class.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 新代码为两个函数 `toy_list` 和 `toy_detail` 应用了 `@api_view` 装饰器。此外，新代码删除了 `JSONResponse`
    类并使用了更通用的 `rest_framework.response.Response` 类。
- en: 'We had to remove the usage of the `rest_framework.parsers.JSONParser` class
    in the functions to make it possible to work with different parsers. This way,
    we stopped working with a parser that only works with JSON. In the older version
    of the code, the `toy_list` function executed the following two lines when the
    `request.method` attribute was equal to `''POST''`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不得不从函数中删除对 `rest_framework.parsers.JSONParser` 类的使用，以便能够使用不同的解析器。这样，我们就停止了只与
    JSON 一起工作的解析器。在旧版本的代码中，当 `request.method` 属性等于 `'POST'` 时，`toy_list` 函数执行以下两行：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the new code, we removed the first line that called the `JSONParser().parse`
    method that was only capable of parsing JSON content. The new code replaces the
    two previous lines with the following single line that passes `request.data` as
    the `data` argument to create a new `ToySerializer` instance:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在新代码中，我们删除了调用 `JSONParser().parse` 方法的第一行，该方法只能解析 JSON 内容。新代码用以下单行替换了之前的两行，该行将
    `request.data` 作为 `data` 参数传递以创建一个新的 `ToySerializer` 实例：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the older version of the code, the `toy_detail` function executed the following
    two lines when the `request.method` attribute was equal to `''PUT''`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧版本的代码中，当 `request.method` 属性等于 `'PUT'` 时，`toy_detail` 函数执行以下两行：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We made edits that are similar to the changes done for the code in the `toy_list`
    function. We removed the first line that called the `JSONParser().parse` method
    that was only capable of parsing JSON content. The new code replaces the two previous
    lines with the following single line that passes `toy` as the first argument and
    `request.data` as the `data` argument to create a new `ToySerializer` instance:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 `toy_list` 函数中的代码进行了类似的编辑。我们删除了调用 `JSONParser().parse` 方法的第一行，该方法只能解析 JSON
    内容。新代码用以下单行替换了之前的两行，该行将 `toy` 作为第一个参数，将 `request.data` 作为 `data` 参数传递，以创建一个新的
    `ToySerializer` 实例：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Taking advantage of content negotiation classes
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用内容协商类
- en: The `APIView` class defines default settings for each view that we can override
    by specifying the desired values in the settings module, that is, the `restful01/settings.py`
    file. It is also possible to override the class attributes in subclasses. In this
    case, we won't make changes in the settings module, but we have to understand
    which are the default settings that the `APIView` class uses. We added the  `@api_view`
    decorator, and it automatically makes the `APIView` use these settings.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`APIView` 类为每个视图定义了默认设置，我们可以通过在设置模块中指定所需的值来覆盖这些设置，即 `restful01/settings.py`
    文件。还可能在子类中覆盖类属性。在这种情况下，我们不会在设置模块中进行更改，但我们必须了解 `APIView` 类使用的默认设置。我们添加了 `@api_view`
    装饰器，它自动使 `APIView` 使用这些设置。'
- en: 'The value for the `DEFAULT_PARSER_CLASSES` setting key specifies a tuple of
    string whose values indicate the default classes that we want to use for parsing
    backends. The following lines show the default values:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`DEFAULT_PARSER_CLASSES` 设置键的值指定了一个字符串元组，其值表示我们想要用于解析后端的默认类。以下行显示了默认值：'
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When we use the `@api_view` decorator, the RESTful Web Service will be able
    to handle any of the following content types through the appropriate parsers.
    Thus, we will be able to work with the `request.data` attribute to retrieve the
    keys and values for each of these content types:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `@api_view` 装饰器时，RESTful Web 服务将能够通过适当的解析器处理以下任何内容类型。因此，我们将能够使用 `request.data`
    属性来检索这些内容类型的键和值：
- en: '`application/json`: Parsed by the `rest_framework.parsers.JSONParser` class'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application/json`: 由 `rest_framework.parsers.JSONParser` 类解析'
- en: '`application/x-www-form-urlencoded`: Parsed by the `rest_framework.parsers.FormParser`
    class'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application/x-www-form-urlencoded`: 由 `rest_framework.parsers.FormParser`
    类解析'
- en: '`multipart/form-data`: Parsed by the `rest_framework.parsers.MultiPartParser`
    class'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`multipart/form-data`: 由 `rest_framework.parsers.MultiPartParser` 类解析'
- en: When we access the `request.data` attribute in the functions, the Django REST
    framework examines the value for the `Content-Type` header in the incoming request
    and determines the appropriate parser to parse the request content. If we use
    the previously explained default values, the Django REST Framework will be able
    to parse all of the previously listed content types. Notice that the request must
    specify the appropriate value for the `Content-Type` key in the request header.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在函数中访问 `request.data` 属性时，Django REST 框架检查传入请求中的 `Content-Type` 头部的值，并确定适当的解析器来解析请求内容。如果我们使用之前解释的默认值，Django
    REST 框架将能够解析之前列出的所有内容类型。请注意，请求必须在请求头中指定 `Content-Type` 键的适当值。
- en: 'The value for the `DEFAULT_RENDERER_CLASSES` setting key specifies a tuple
    of string whose values indicate the default classes that we want to use for rendering
    backends. The following lines show the default values:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`DEFAULT_RENDERER_CLASSES` 设置键的值指定了一个字符串元组，其值表示我们想要用于渲染后端的默认类。以下行显示了默认值：'
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When we use the `@api_view` decorator, the RESTful Web Service will be able
    to render any of the following content types through the appropriate renderers.
    We made the necessary changes to work with a `rest_framework.response.Response`
    instance to be able to work with these content types:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `@api_view` 装饰器时，RESTful Web 服务将能够通过适当的渲染器渲染以下任何内容类型。我们进行了必要的更改，以便与 `rest_framework.response.Response`
    实例一起工作，以便能够处理这些内容类型：
- en: '`application/json`: Rendered by the `rest_framework.response.JSONRenderer`
    class'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application/json`: 由 `rest_framework.response.JSONRenderer` 类渲染'
- en: '`text/html`: Rendered by the `rest_framework.response.BrowsableAPIRenderer`
    class'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text/html`: 由 `rest_framework.response.BrowsableAPIRenderer` 类渲染'
- en: So far, we understand the default settings for parsers and renderers. There
    is an additional part of this puzzle that must select the appropriate renderer
    for the response based on the requirements specified in the incoming request.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们了解了解析器和渲染器的默认设置。这个谜题的另一个部分必须根据传入请求中指定的要求选择适当的渲染器。
- en: By default, the value for the `DEFAULT_CONTENT_NEGOTIATION_CLASS` is the `rest_framework.negotiation.DefaultContentNegotiation`
    class. When we use the decorator, the web service will use this content negotiation
    class to select the appropriate renderer for the response, based on the incoming
    request. This way, when a request specifies that it will accept `text/html`, the
    content negotiation class selects the `rest_framework.renderers.BrowsableAPIRenderer`
    to render the response and generate `text/html` instead of `application/json`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`DEFAULT_CONTENT_NEGOTIATION_CLASS` 的值是 `rest_framework.negotiation.DefaultContentNegotiation`
    类。当我们使用装饰器时，网络服务将使用这个内容协商类来根据传入请求选择适当的渲染器。这样，当一个请求指定它将接受 `text/html` 时，内容协商类会选择
    `rest_framework.renderers.BrowsableAPIRenderer` 来渲染响应并生成 `text/html` 而不是 `application/json`。
- en: In the old version of the code, we used the `JSONResponse` and `HttpResponse`
    classes in the functions. The new version replaced the usages of both classes
    with the `rest_framework.response.Response` class. This way, the code takes advantage
    of the content negotiation features. The `Response` class renders the provided
    data into the appropriate content type and returns it to the client that made
    the request.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧版本的代码中，我们在函数中使用了 `JSONResponse` 和 `HttpResponse` 类。新版本用 `rest_framework.response.Response`
    类替换了这两个类的使用。这样，代码就利用了内容协商功能。`Response` 类将提供的数据渲染成适当的内容类型，并将其返回给发起请求的客户端。
- en: Making supported HTTP OPTIONS requests with command-line tools
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用命令行工具发送支持的 HTTP OPTIONS 请求
- en: Now, we will take advantage of all the changes we've made in the code and we
    will compose and send HTTP requests to make our RESTful Web Service work with
    different content types. Make sure you've saved all the changes. In case you stopped
    Django's development server, you will have to start it again as we learned in
    [Chapter 3](dj-rst-websvc_ch13.html), *Creating API Views*, in the section *Launching
    Django's development server*, to start running the Django development server.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将利用我们在代码中所做的所有更改，并将组合并发送 HTTP 请求，使我们的 RESTful 网络服务能够与不同的内容类型一起工作。确保你已经保存了所有更改。如果你停止了
    Django 的开发服务器，你将不得不再次启动它，就像我们在第 3 章 [创建 API 视图](dj-rst-websvc_ch13.html)中学习的那样，在
    *启动 Django 开发服务器* 部分中，以启动 Django 开发服务器。
- en: 'We want to know which HTTP verbs the toys, collection supports, that is, we
    want to take advantage of the `OPTIONS` verb. Run the following command. This
    time, the command won''t produce errors. Remember that the virtual environment
    we have created in the previous chapters must be activated in order to run the
    next `http` command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想知道玩具集合支持哪些 HTTP 动词，也就是说，我们想利用 `OPTIONS` 动词。运行以下命令。这次，命令不会产生错误。记住，我们之前章节中创建的虚拟环境必须激活，才能运行下一个
    `http` 命令：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The previous command will compose and send the following HTTP request: `OPTIONS
    http://localhost:8000/toys/`. The request will end up running the `views.toy_list`
    function, that is, the `toy_list` function declared within the `toys/views.py`
    file. We added the `@api_view` decorator to this function, and therefore, the
    function is capable of determining the supported HTTP verbs, the enabled parsing
    and rendering options. The following lines show the output:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组合并发送以下 HTTP 请求：`OPTIONS http://localhost:8000/toys/`。该请求最终将运行 `views.toy_list`
    函数，即 `toys/views.py` 文件中声明的 `toy_list` 函数。我们给这个函数添加了 `@api_view` 装饰器，因此该函数能够确定支持的
    HTTP 动词、启用的解析和渲染选项。以下行显示了输出：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The response header includes an `Allow` key with a comma-separated list of
    HTTP verbs supported by the resource collection as its value: `POST, OPTIONS,
    GET`. Our request didn''t specify the allowed content type, and therefore, the
    function rendered the response with the default `application/json` content type.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 响应头包括一个 `Allow` 键，其值为逗号分隔的 HTTP 动词列表，表示资源集合支持的 HTTP 动词：`POST, OPTIONS, GET`。我们的请求没有指定允许的内容类型，因此函数使用默认的
    `application/json` 内容类型渲染响应。
- en: The response body specifies the `Content-type` that the resource collection
    is capable of parsing in the values for the `"parses"` key and the `Content-type`
    that the resource collection is capable of rendering in the values for the `"renders"`
    key.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 响应体指定资源集合能够解析的`Content-type`，在`"parses"`键的值中，以及资源集合能够渲染的`Content-type`，在`"renders"`键的值中。
- en: 'Run the following command to compose and send an HTTP request with the `OPTIONS`
    verb for a toy resource. Don''t forget to replace `2` with a primary key value
    of an existing toy in your configuration:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以使用`OPTIONS`动词为玩具资源编写并发送HTTP请求。别忘了将`2`替换为你配置中现有玩具的主键值：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following is the equivalent curl command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与curl等效的命令：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The previous command will compose and send the following HTTP request: `OPTIONS
    http://localhost:8000/toys/2`. The request will end up running the `views.toy_detail`
    function, that is, the `toy_detail` function declared within the `toys/views.py`
    file. We also added the `@api_view` decorator to this function, and therefore,
    it is capable of determining the supported HTTP verbs, the enabled parsing and
    rendering options. The following lines show a sample output:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将编写并发送以下HTTP请求：`OPTIONS http://localhost:8000/toys/2`。请求最终将运行`views.toy_detail`函数，即`toys/views.py`文件中声明的`toy_detail`函数。我们还向这个函数添加了`@api_view`装饰器，因此它能够确定支持的HTTP动词、启用的解析和渲染选项。以下是一些示例输出：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The response header includes an `Allow` key with a comma-separated list of
    HTTP verbs supported by the resource as its value: `DELETE, PUT, OPTIONS, GET`.
    The response body specifies the `Content-type` that the resource is capable of
    parsing in the values for the `"parses"` key and the `Content-type` that the resource
    collection is capable of rendering in the values for the `"renders"` key. The
    resource and the resource collection can parse and render the same content types
    because everything is handled by the decorator and the `APIView` class.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 响应头包括一个`Allow`键，其值为以逗号分隔的HTTP动词列表，表示资源支持的HTTP动词：`DELETE, PUT, OPTIONS, GET`。响应体指定资源能够解析的`Content-type`，在`"parses"`键的值中，以及资源集合能够渲染的`Content-type`，在`"renders"`键的值中。由于一切由装饰器和`APIView`类处理，资源及其资源集合可以解析和渲染相同的内容类型。
- en: Working with different content types
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理不同的内容类型
- en: 'In [Chapter 3](dj-rst-websvc_ch13.html)*, Creating API Views*, when we composed
    and sent `POST` and `PUT` commands, we had to use the use the `-H "Content-Type:
    application/json"` option to indicate curl to send the data specified after the
    `-d` option as `application/json`. We had to use this option because the default
    content-type in curl is `application/x-www-form-urlencoded`.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '在[第3章](dj-rst-websvc_ch13.html)*创建API视图*中，当我们编写并发送`POST`和`PUT`命令时，我们必须使用`-H
    "Content-Type: application/json"`选项来指示curl将`-d`选项之后指定的数据作为`application/json`发送。我们必须使用此选项，因为curl的默认内容类型是`application/x-www-form-urlencoded`。'
- en: Now, our RESTful Web Service goes beyond JSON and it can also parse `application/x-www-form-urlencoded`
    and `multipart/form-data` data specified in the `POST` and `PUT` requests. Hence,
    we can compose and send a `POST` command that sends the data as `application/x-www-form-urlencoded`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的RESTful Web服务不仅支持JSON，还可以解析`POST`和`PUT`请求中指定的`application/x-www-form-urlencoded`和`multipart/form-data`数据。因此，我们可以编写并发送一个发送数据为`application/x-www-form-urlencoded`的`POST`命令。
- en: We will compose and send an HTTP request to create a new toy. In this case,
    we will use the `-f` option for HTTP.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写并发送一个HTTP请求来创建一个新的玩具。在这种情况下，我们将使用HTTP的`-f`选项。
- en: 'This option serializes data items from the command line as form fields and
    sets the `Content-Type` header key to the `application/x-www-form-urlencoded`
    value. Run the next command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项将命令行中的数据项序列化为表单字段，并将`Content-Type`头键设置为`application/x-www-form-urlencoded`值。运行下一个命令：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following is the equivalent curl command that creates a new toy. Notice
    that we don''t use the `-H` option and curl will send the data in the default
    `application/x-www-form-urlencoded`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与创建新玩具等效的curl命令。请注意，我们没有使用`-H`选项，curl将使用默认的`application/x-www-form-urlencoded`发送数据：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The previous commands will compose and send the following HTTP request: `POST
    http://localhost:8000/toys/` with the `Content-Type` header key set to the `application/x-www-form-urlencoded`
    value and the following data:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将编写并发送以下HTTP请求：`POST http://localhost:8000/toys/`，其中`Content-Type`头键设置为`application/x-www-form-urlencoded`值，并包含以下数据：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The request specifies `/toys/`, and therefore, it will match the `'^toys/$'`
    regular expression and Django will run the `views.toy_list` function, that is,
    the updated `toy_detail` function declared within the `toys/views.py` file. The
    HTTP verb for the request is `POST`, and therefore, the `request.method` property
    is equal to `'POST'`. The function will execute the code that creates a `ToySerializer`
    instance and passes `request.data` as the `data` argument to create the new instance.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请求指定 `/toys/`，因此，它将匹配 `'^toys/$'` 正则表达式，Django 将运行 `views.toy_list` 函数，即 `toys/views.py`
    文件中声明的更新后的 `toy_detail` 函数。请求的 HTTP 动词是 `POST`，因此，`request.method` 属性等于 `'POST'`。该函数将执行创建
    `ToySerializer` 实例的代码，并将 `request.data` 作为 `data` 参数传递以创建新实例。
- en: 'The `rest_framework.parsers.FormParser` class will parse the data received
    in the request, the code creates a new `Toy` and, if the data is valid, it saves
    the new `Toy`. If the new `Toy` instance was successfully persisted in the database,
    the function returns an HTTP `201 Created` status code and the recently persisted
    `Toy` serialized to JSON in the response body. The following lines show an example
    response for the HTTP request, with the new `Toy` object in the JSON response:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`rest_framework.parsers.FormParser` 类将解析请求中接收到的数据，代码创建一个新的 `Toy` 对象，如果数据有效，则保存新的
    `Toy`。如果新的 `Toy` 实例成功持久化到数据库中，则函数返回 HTTP `201 Created` 状态码，并在响应体中将最近持久化的 `Toy`
    序列化为 JSON。以下行显示了 HTTP 请求的示例响应，其中包含 JSON 响应中的新 `Toy` 对象：'
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Sending HTTP requests with unsupported HTTP verbs
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用不受支持的 HTTP 动词发送 HTTP 请求
- en: 'Now, we will compose and send HTTP requests with an HTTP verb that isn''t supported
    for the toys resource collection. Run the following command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用不支持玩具资源集合的 HTTP 动词来组合和发送 HTTP 请求。运行以下命令：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令：
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The previous command will compose and send the following HTTP request: `PATCH
    http://localhost:8000/toys/`. The request will try to run the `views.toy_list`
    function, that is, the `toy_list` function declared within the `toys/views.py`
    file. The `@api_view` decorator we added to this function doesn''t include `''PATCH''`
    in the string list with the allowed HTTP verbs. The default behavior when this
    happens in the `APIView` class is to return an HTTP `405 Method Not Allowed` status
    code. The following lines show a sample output with the response from the previous
    request. A JSON content provides a `detail` key with a string value that indicates
    the `PATCH` method is not allowed in the response body:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组合和发送以下 HTTP 请求：`PATCH http://localhost:8000/toys/`。请求将尝试运行 `views.toy_list`
    函数，即 `toys/views.py` 文件中声明的 `toy_list` 函数。我们添加到该函数的 `@api_view` 装饰器不包括 `'PATCH'`
    在允许的 HTTP 动词的字符串列表中。当在 `APIView` 类中发生这种情况时，默认行为是返回 HTTP `405 Method Not Allowed`
    状态码。以下行显示了之前请求的示例输出。JSON 内容提供了一个 `detail` 键，其字符串值指示响应体中不允许 `PATCH` 方法：
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Test your knowledge
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: 'Let''s see whether you can answer the following questions correctly:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否能正确回答以下问题：
- en: 'The `@api_view` decorator declared in the `rest_framework.decorators` module
    allows you to:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `rest_framework.decorators` 模块中声明的 `@api_view` 装饰器允许您：
- en: Specify which is the model related to the function based view
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定与基于函数视图相关的模型
- en: Specify which are the HTTP verbs that the function based view to which it is
    applied can process
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定应用于基于函数视图的 HTTP 动词可以处理哪些
- en: Specify which is the serializer related to the function based view
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定与基于函数视图相关的序列化器
- en: 'The `@api_view` decorator is a wrapper that converts a function based view
    into a subclass of which of the following classes:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@api_view` 装饰器是一个包装器，它将基于函数的视图转换为以下类之一的子类：'
- en: '`django.Http.Response.HttpResponse`'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`django.Http.Response.HttpResponse`'
- en: '`rest_framework.views.APIView`'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rest_framework.views.APIView`'
- en: '`rest_framework.serializers.Serializer`'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rest_framework.serializers.Serializer`'
- en: 'Which of the following settings key in the REST_FRAMEWORK dictionary allows
    you to override the global setting with a tuple of string whose values indicate
    the default classes that you want to use for parsing backends:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 REST_FRAMEWORK 字典中，以下哪个设置键允许您使用一个表示您想要用于解析后端的默认类的字符串值的元组来覆盖全局设置：
- en: '`''DEFAULT_PARSER_CLASSES''`'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`''DEFAULT_PARSER_CLASSES''`'
- en: '`''GLOBAL_PARSER_CLASSES''`'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`''GLOBAL_PARSER_CLASSES''`'
- en: '`''REST_FRAMEWORK_PARSING_CLASSES''`'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`''REST_FRAMEWORK_PARSING_CLASSES''`'
- en: 'Which of the following classes is able to parse application/json content type
    when we work with the `@api_view` decorator and its default settings:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们使用 `@api_view` 装饰器和其默认设置工作时，以下哪个类能够解析 application/json 内容类型：
- en: '`django.parsers.JSONParser`'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`django.parsers.JSONParser`'
- en: '`rest_framework.classes.JSONParser`'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rest_framework.classes.JSONParser`'
- en: '`rest_framework.parsers.JSONParser`'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rest_framework.parsers.JSONParser`'
- en: 'Which of the following classes is able to parse application/x-www-form-urlencoded
    content type when we work with the `@api_view` decorator and its default settings:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们使用 `@api_view` 装饰器和其默认设置工作时，以下哪个类能够解析 application/x-www-form-urlencoded 内容类型：
- en: '`django.parsers.XWWWUrlEncodedParser`'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`django.parsers.XWWWUrlEncodedParser`'
- en: '`rest_framework.classes.XWWWUrlEncodedParser`'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rest_framework.classes.XWWWUrlEncodedParser`'
- en: '`rest_framework.parsers.FormParser`'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rest_framework.parsers.FormParser`'
- en: The rights answers are included in the [Appendix](https://cdp.packtpub.com/django_restful_web_services__/wp-admin/post.php?post=44&action=edit#post_454), *Solutions*.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 正确答案包含在[附录](https://cdp.packtpub.com/django_restful_web_services__/wp-admin/post.php?post=44&action=edit#post_454)，*解决方案*中。
- en: Summary
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we improved our simple Django RESTful Web Service. We took
    advantage of many features included in the Django REST framework to remove duplicate
    code and to add many features for the web service. We just needed to edit a few
    lines of code to enable an important amount of features.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们改进了我们的简单 Django RESTful Web 服务。我们利用了 Django REST 框架中包含的许多特性来删除重复代码并为
    Web 服务添加了许多功能。我们只需编辑几行代码就能启用大量功能。
- en: First, we took advantage of model serializers. Then, we understood the different
    accepted and returned content types and the importance of providing accurate responses
    to the HTTP OPTIONS requests.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们利用了模型序列化器。然后，我们了解了接受的和返回的不同内容类型以及向 HTTP OPTIONS 请求提供准确响应的重要性。
- en: We incorporated the `@api_view` decorator and made the necessary changes to
    the existing code to enable diverse parsers and renderers. We understood how things
    worked under the hood in the Django REST framework. We worked with different content
    types and noticed the improvement of the RESTful Web Service compared with its
    previous versions.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了 `@api_view` 装饰器并对现有代码进行了必要的修改，以启用不同的解析器和渲染器。我们理解了 Django REST 框架内部的工作原理。我们处理了不同的内容类型，并注意到了与之前版本相比
    RESTful Web 服务的改进。
- en: 'Now that we understand how easy it is to work with different content types
    with the Django REST framework, we will work with one of the most interesting
    and powerful features: the browsable API. We will cover this topic in [Chapter
    5](dj-rst-websvc_ch15.html), *Understanding and Customizing the Browsable API
    Feature*.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了使用 Django REST 框架处理不同内容类型是多么容易，我们将探讨其中一个最有趣且强大的特性：可浏览的 API。我们将在[第 5
    章](dj-rst-websvc_ch15.html)中介绍这个主题，*理解和自定义可浏览 API 功能*。
