- en: Data Science
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据科学
- en: '"If we have data, let''s look at data. If all we have are opinions, let''s
    go with mine."– Jim Barksdale, former Netscape CEO'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “如果我们有数据，让我们看看数据。如果我们只有意见，那就听我的。”- Jim Barksdale，前网景公司CEO
- en: '**Data science** is a very broad term and can assume several different meanings
    based on context, understanding, tools, and so on. There are countless books on
    this subject, which is not suitable for the faint-hearted.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据科学**是一个非常广泛的术语，根据上下文、理解、工具等可以有几种不同的含义。关于这个主题有无数的书籍，这对心脏脆弱的人来说并不适合。'
- en: In order to do proper data science, you need to, at the very least, know mathematics
    and statistics. Then, you may want to dig into other subjects, such as pattern
    recognition and machine learning and, of course, there is a plethora of languages
    and tools you can choose from.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做好数据科学，你至少需要了解数学和统计学。然后，你可能想深入研究其他学科，比如模式识别和机器学习，当然，你可以选择各种语言和工具。
- en: I won't be able to talk about everything here. Therefore, in order to render
    this chapter meaningful, we're going to work on a cool project together instead.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我无法在这里讨论所有内容。因此，为了使本章有意义，我们将一起做一个很酷的项目。
- en: Around the year 2012/2013, I was working for a top-tier social media company
    in London. I stayed there for two years, and I was privileged to work with several
    people whose brilliance I can only start to describe. We were the first in the
    world to have access to the Twitter Ads API, and we were partners with Facebook
    as well. That means a lot of data.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 大约在2012/2013年，我在伦敦一家顶级社交媒体公司工作。我在那里呆了两年，很荣幸能和一些非常聪明的人一起工作，他们的才华令我只能开始描述。我们是世界上第一个可以访问Twitter广告API的公司，我们也是Facebook的合作伙伴。这意味着有大量的数据。
- en: Our analysts were dealing with a huge number of campaigns and they were struggling
    with the amount of work they had to do, so the development team I was a part of
    tried to help by introducing them to Python and to the tools Python gives you
    to deal with data. It was a very interesting journey that led me to mentor several
    people in the company and eventually took me to Manila where, for two weeks, I
    gave intensive training in Python and data science to the analysts over there.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的分析师们处理了大量的活动，并且他们为了完成工作而苦苦挣扎，所以我所在的开发团队尝试通过介绍Python和Python提供的处理数据的工具来帮助他们。这是一段非常有趣的旅程，让我在公司里指导了几个人，最终带我去了马尼拉，在那里我为分析师们进行了为期两周的Python和数据科学密集培训。
- en: The project we're going to do in this chapter is a lightweight version of the
    final example I presented to my students in Manila. I have rewritten it to a size
    that will fit this chapter, and made a few adjustments here and there for teaching
    purposes, but all the main concepts are there, so it should be fun and instructional
    for you.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中要做的项目是我在马尼拉向学生展示的最终示例的轻量级版本。我已经重新编写了它，使其适合本章的篇幅，并对一些地方进行了一些调整，但所有主要概念都在其中，所以对你来说应该是有趣和有教育意义的。
- en: 'Specifically, we are going to explore the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将探讨以下内容：
- en: The Jupyter Notebook
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jupyter Notebook
- en: 'Pandas and NumPy: main libraries for data science in Python'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pandas和NumPy：Python中的数据科学主要库
- en: A few concepts around Pandas's `DataFrame` class
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pandas的`DataFrame`类的一些概念
- en: Creating and manipulating a dataset
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和操作数据集
- en: Let's start by talking about Roman gods.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先谈谈罗马神话中的神祗。
- en: IPython and Jupyter Notebook
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPython和Jupyter Notebook
- en: In 2001, Fernando Perez was a graduate student in physics at CU Boulder, and
    was trying to improve the Python shell so that he could have the niceties he was
    used to when he was working with tools such as Mathematica and Maple. The result
    of that effort took the name **IPython**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在2001年，Fernando Perez是科罗拉多大学博尔德分校的物理学研究生，他试图改进Python shell，以便在使用类似Mathematica和Maple等工具时能够获得他习惯的便利。这一努力的结果被命名为**IPython**。
- en: In a nutshell, that small script began as an enhanced version of the Python
    shell and, through the effort of other coders and eventually with proper funding
    from several different companies, it became the wonderful and successful project
    it is today. Some 10 years after its birth, a Notebook environment was created,
    powered by technologies such as WebSockets, the Tornado web server, jQuery, CodeMirror,
    and MathJax. The ZeroMQ library was also used to handle the messages between the
    Notebook interface and the Python core that lies behind it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，那个小脚本最初是Python shell的增强版本，通过其他编码人员的努力，最终得到了来自不同公司的适当资金支持，成为了今天的出色和成功的项目。它诞生10年后，一个Notebook环境被创建，由WebSockets、Tornado
    web服务器、jQuery、CodeMirror和MathJax等技术提供支持。ZeroMQ库也被用来处理Notebook界面和其背后的Python核心之间的消息。
- en: The IPython Notebook has become so popular and widely used that, over time,
    all sorts of goodies have been added to it. It can handle widgets, parallel computing,
    all sorts of media formats, and much, much more. Moreover, at some point, it became
    possible to code in languages other than Python from within the Notebook.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: IPython Notebook变得如此受欢迎和广泛使用，随着时间的推移，各种好东西都被添加进去。它可以处理小部件、并行计算、各种媒体格式等等。而且，在某个时候，甚至可以在Notebook内部使用Python以外的语言进行编码。
- en: 'This has led to a huge project that at some stage has been split into two:
    IPython has been stripped down to focus more on the kernel part and the shell,
    while the Notebook has become a brand new project called **Jupyter**. Jupyter
    allows interactive scientific computations to be made in more than 40 languages.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了一个庞大的项目，曾经被分成两部分：IPython被精简以更专注于内核部分和shell，而Notebook已经成为一个名为**Jupyter**的全新项目。Jupyter允许以40多种语言进行交互式科学计算。
- en: This chapter's project will all be coded and run in a Jupyter Notebook, so let
    me explain in a few words what a Notebook is.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目将全部在Jupyter Notebook中编写和运行，所以让我简单解释一下Notebook是什么。
- en: A Notebook environment is a web page that exposes a simple menu and the cells
    in which you can run Python code. Even though the cells are separate entities
    that you can run individually, they all share the same Python kernel. This means
    that all the names that you define in a cell (the variables, functions, and so
    on) will be available in any other cell.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记本环境是一个网页，它公开了一个简单的菜单和可以运行Python代码的单元格。尽管单元格是可以单独运行的独立实体，但它们都共享相同的Python内核。这意味着您在一个单元格中定义的所有名称（变量、函数等）将在任何其他单元格中都可用。
- en: Simply put, a Python kernel is a process in which Python is running. The Notebook
    web page is, therefore, an interface exposed to the user for driving this kernel.
    The web page communicates to it using a very fast messaging system.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Python内核是Python正在运行的进程。因此，笔记本网页是向用户公开的用于驱动此内核的接口。网页使用非常快速的消息传递系统与内核进行通信。
- en: Apart from all the graphical advantages, the beauty of having such an environment
    lies in the ability to run a Python script in chunks, and this can be a tremendous
    advantage. Take a script that is connecting to a database to fetch data and then
    manipulate that data. If you do it in the conventional way, with a Python script,
    you have to fetch the data every time you want to experiment with it. Within a
    Notebook environment, you can fetch the data in a cell and then manipulate and
    experiment with it in other cells, so fetching it every time is not necessary.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有图形优势之外，拥有这样的环境之美在于能够以块的方式运行Python脚本，这可能是一个巨大的优势。拿一个连接到数据库以获取数据然后操作该数据的脚本来说。如果您以常规方式进行，使用Python脚本，您必须每次想要对其进行实验时都获取数据。在笔记本环境中，您可以在一个单元格中获取数据，然后在其他单元格中操作和实验，因此不必每次都获取数据。
- en: The Notebook environment is also extremely helpful for data science because
    it allows for step-by-step introspection. You do one chunk of work and then verify
    it. You then do another chunk and verify again, and so on.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记本环境对于数据科学也非常有帮助，因为它允许逐步的内省。您完成一部分工作，然后进行验证。然后再做另一部分并再次验证，依此类推。
- en: It's also invaluable for prototyping because the results are there, right in
    front of your eyes, immediately available.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于原型设计也是非常宝贵的，因为结果就在你眼前，立即可用。
- en: If you want to know more about these tools, please check out [ipython.org](https://ipython.org/) and
    [jupyter.org](http://jupyter.org/).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于这些工具的信息，请访问[ipython.org](https://ipython.org/)和[jupyter.org](http://jupyter.org/)。
- en: 'I have created a very simple example Notebook with a `fibonacci` function that
    gives you the list of all the Fibonacci numbers smaller than a given `N`. In my
    browser, it looks like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了一个非常简单的示例笔记本，其中包含一个`fibonacci`函数，该函数为您提供了小于给定`N`的所有斐波那契数的列表。在我的浏览器中，它看起来像这样：
- en: '![](../images/00018.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00018.jpeg)'
- en: Every cell has an In [] label. If there's nothing between the brackets, it means
    that a cell has never been executed. If there is a number, it means that the cell
    has been executed, and the number represents the order in which the cell was executed.
    Finally, a * means that the cell is currently being executed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单元格都有一个In []标签。如果方括号之间没有任何内容，这意味着单元格从未被执行过。如果有一个数字，这意味着单元格已被执行，并且该数字表示单元格被执行的顺序。最后，*表示该单元格当前正在执行。
- en: You can see in the picture that in the first cell I have defined the `fibonacci`
    function, and I have executed it. This has the effect of placing the `fibonacci`
    name in the global frame associated with the Notebook, therefore the `fibonacci`
    function is now available to the other cells as well. In fact, in the second cell,
    I can run `fibonacci(100)` and see the results in Out [2]. In the third cell,
    I have shown you one of the several magic functions you can find in a Notebook
    in the second cell. %timeit runs the code several times and provides you with
    a nice benchmark for it. All the measurements for the list comprehensions and
    generators I did in [Chapter 5](part0142.html#47DFS0-2ddb708647cc4530a187c2c6c0e9acfe),
    *Saving Time and Memory*, were carried out with this nice feature.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到图片中，在第一个单元格中我定义了`fibonacci`函数，并执行了它。这样做的效果是将`fibonacci`名称放在与笔记本关联的全局框架中，因此`fibonacci`函数现在也可以在其他单元格中使用。实际上，在第二个单元格中，我可以运行`fibonacci(100)`并在Out
    [2]中看到结果。在第三个单元格中，我向您展示了笔记本中的几个魔术函数之一。%timeit多次运行代码并为您提供一个很好的基准。我在[第5章](part0142.html#47DFS0-2ddb708647cc4530a187c2c6c0e9acfe)中进行的所有列表理解和生成器的测量都是使用这个很好的功能进行的，*节省时间和内存*。
- en: You can execute a cell as many times as you want, and change the order in which
    you run them. Cells are very malleable, you can also put in markdown text or render
    them as headers.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以执行单元格任意次数，并更改运行它们的顺序。单元格非常灵活，您还可以放入Markdown文本或将其呈现为标题。
- en: '**Markdown** is a lightweight markup language with plain text formatting syntax
    designed so that it can be converted to HTML and many other formats.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**Markdown**是一种轻量级标记语言，具有纯文本格式化语法，设计成可以转换为HTML和许多其他格式。'
- en: Also, whatever you place in the last row of a cell will be automatically printed
    for you. This is very handy because you're not forced to write `print(...)` explicitly.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，无论您将什么放在单元格的最后一行，都将自动为您打印出来。这非常方便，因为您不必明确地编写`print(...)`。
- en: Feel free to explore the Notebook environment; once you're friends with it,
    it's a long-lasting relationship, I promise.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 随时探索笔记本环境；一旦您熟悉它，我保证这将是一段持久的关系。
- en: Installing the required libraries
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装所需的库
- en: In order to run the Notebook, you have to install a handful of libraries, each
    of which collaborates with the others to make the whole thing work. Alternatively,
    you can just install Jupyter and it will take care of everything for you. For
    this chapter, there are a few other dependencies that we need to install. You
    can find them listed in `requirements/requirements.data.science.in`. To install
    them, please take a look at `README.rst` in the root folder of the project, and
    you will find instructions specifically for this chapter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行笔记本，您必须安装一些库，每个库都与其他库合作以使整个系统工作。或者，您可以只安装Jupyter，它会为您处理一切。对于本章，我们需要安装一些其他依赖项。您可以在项目的根文件夹中的`requirements/requirements.data.science.in`中找到它们的列表。要安装它们，请查看`README.rst`，您将在其中找到专门针对本章的说明。
- en: Using Anaconda
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Anaconda
- en: Sometimes installing data science libraries can be extremely painful. If you
    are struggling to install the libraries for this chapter in your virtual environment,
    an alternative choice you have is to install Anaconda. Anaconda is a free and
    open source distribution of the Python and R programming languages for data science
    and machine-learning-related applications that aims to simplify package management
    and deployment. You can download it from the [anaconda.org](https://anaconda.org/)
    website. Once you have installed it in your system, take a peek at the various
    requirements for this chapter and install them through Anaconda.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '有时安装数据科学库可能非常痛苦。如果您在虚拟环境中为本章安装库而苦苦挣扎，您的另一个选择是安装Anaconda。Anaconda是Python和R编程语言的免费开源发行版，用于数据科学和机器学习相关应用，旨在简化软件包管理和部署。您可以从[anaconda.org](https://anaconda.org/)网站下载它。安装在系统中后，查看本章的各种要求，并通过Anaconda安装它们。 '
- en: Starting a Notebook
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始笔记本
- en: 'Once you have all the required libraries installed, you can either start a
    Notebook with the following command or by using the Anaconda interface:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您安装了所有必需的库，您可以使用以下命令启动笔记本，或者使用Anaconda界面：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You will have an open page in your browser at this address (the port might
    be different): `http://localhost:8888/`. Go to that page and create a new Notebook
    using the menu. When you feel comfortable with it, you''re ready to go. I strongly
    encourage you to try and get a Jupyter environment running, before you proceed
    reading on. It is an excellent exercise sometimes to have to deal with difficult
    dependencies.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在浏览器中打开此地址（端口可能不同）：`http://localhost:8888/`。转到该页面并使用菜单创建一个新的笔记本。当您感到舒适时，您已经准备好了。我强烈建议您在继续阅读之前尝试并运行Jupyter环境。有时不得不处理困难的依赖关系是一个很好的练习。
- en: Our project will take place in a Notebook, therefore I will tag each code snippet
    with the cell number it belongs to, so that you can easily reproduce the code
    and follow along.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目将在笔记本中进行，因此我将使用单元格编号标记每个代码片段，以便您可以轻松地复制代码并跟随操作。
- en: If you familiarize yourself with the keyboard shortcuts (look in the Notebook's
    Help section), you will be able to move between cells and handle their content
    without having to reach for the mouse. This will make you more proficient and
    way faster when you work in a Notebook.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉键盘快捷键（查看笔记本的帮助部分），您将能够在单元格之间移动并处理它们的内容，而无需使用鼠标。这将使您在笔记本中工作时更加熟练和更快。
- en: 'Let''s now move on and talk about the most interesting part of this chapter:
    data.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续讨论本章最有趣的部分：数据。
- en: Dealing with data
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理数据
- en: 'Typically, when you deal with data, this is the path you go through: you fetch
    it, you clean and manipulate it, and then you inspect it, and present results
    as values, spreadsheets, graphs, and so on. I want you to be in charge of all
    three steps of the process without having any external dependency on a data provider,
    so we''re going to do the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当您处理数据时，您会经历以下路径：获取数据，清理和操作数据，然后检查数据，并将结果呈现为值，电子表格，图形等。我希望您能够独立完成这个过程的所有三个步骤，而不依赖于外部数据提供者，因此我们将进行以下操作：
- en: We're going to create the data, simulating the fact that it comes in a format
    that is not perfect or ready to be worked on
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建数据，模拟数据以一种不完美或不准备好被处理的格式
- en: We're going to clean it and feed it to the main tool we'll use in the project
    such as `DataFrame` from the `pandas` library
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将对其进行清理并将其提供给项目中将使用的主要工具，如`pandas`库中的`DataFrame`
- en: We're going to manipulate the data in `DataFrame`
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在`DataFrame`中操作数据
- en: We're going to save `DataFrame` to a file in different formats
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将以不同格式将`DataFrame`保存到文件中
- en: We're going to inspect the data and get some results out of it
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将检查数据并从中获取一些结果
- en: Setting up the Notebook
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置笔记本
- en: 'First things first, let''s produce the data. We start from the `ch13-dataprep` Notebook:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们生成数据。我们从`ch13-dataprep`笔记本开始：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Cell `#1` takes care of the imports. We have already encountered them, apart
    from `faker`. You can use this module to prepare fake data. It's very useful in
    tests, when you prepare your fixtures, to get all sorts of things such as names,
    email addresses, phone numbers, and credit card details. It is all fake, of course.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 单元格`＃1`负责导入。我们已经遇到过它们，除了`faker`。您可以使用此模块准备虚假数据。在测试中非常有用，当您准备您的固定装置时，可以获得各种各样的东西，如姓名，电子邮件地址，电话号码和信用卡详细信息。当然，这都是假的。
- en: Preparing the data
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备数据
- en: 'We want to achieve the following data structure: we''re going to have a list
    of user objects. Each user object will be linked to a number of campaign objects.
    In Python, everything is an object, so I''m using this term in a generic way.
    The user object may be a string, a dictionary, or something else.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望实现以下数据结构：我们将拥有一个用户对象列表。每个用户对象将与多个活动对象相关联。在Python中，一切都是对象，所以我以一种通用的方式使用这个术语。用户对象可以是字符串，字典或其他东西。
- en: 'A **campaign** in the social media world is a promotional campaign that a media
    agency runs on social media networks on behalf of a client. Remember that we''re
    going to prepare this data so that it''s not in perfect shape (but it won''t be
    that bad either...):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在社交媒体世界中，**广告系列**是媒体机构代表客户在社交媒体网络上运行的促销活动。请记住，我们将准备这些数据，使其不是完美的（但也不会太糟糕...）：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Firstly, we instantiate the `Faker` that we''ll use to create the data:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们实例化`Faker`，我们将用它来创建数据：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then we need usernames. I want 1,000 unique usernames, so I loop over the length
    of the `usernames` set until it has 1,000 elements. A `set` method doesn''t allow
    duplicated elements, therefore uniqueness is guaranteed:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要用户名。我想要1,000个唯一的用户名，所以我循环遍历`用户名`集合的长度，直到它有1,000个元素。`set`方法不允许重复元素，因此确保了唯一性：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we create a list of `users`. Each `username` has now been augmented to
    a full-blown `user` dictionary, with other details such as `name`, `gender`, and
    `email`. Each `user` dictionary is then dumped to JSON and added to the list.
    This data structure is not optimal, of course, but we're simulating a scenario
    where users come to us like that.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个`用户`列表。每个`用户名`现在已经增加到一个完整的`用户`字典中，其中包括`姓名`，`性别`和`电子邮件`等其他细节。然后将每个`用户`字典转储为JSON并添加到列表中。当然，这种数据结构并不是最佳的，但我们正在模拟用户以这种方式来到我们这里的情况。
- en: Note the skewed use of `random.random()` to make 60% of users female. The rest
    of the logic should be very easy for you to understand.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到了`random.random()`的偏斜使用，使60%的用户为女性。其余的逻辑应该对你来说非常容易理解。
- en: 'Note also the last line. Each cell automatically prints what''s on the last
    line; therefore, the output of `#4` is a list with the first three `users`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意最后一行。每个单元格都会自动打印最后一行的内容；因此，`＃4`的输出是一个包含前三个`用户`的列表：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: I hope you're following along with your own Notebook. If you are, please note
    that all data is generated using random functions and values; therefore, you will
    see different results. They will change every time you execute the Notebook.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你正在用自己的笔记本跟着做。如果是的话，请注意所有数据都是使用随机函数和值生成的；因此，你会看到不同的结果。每次执行笔记本时都会发生变化。
- en: 'In the following code `#5` is the logic to generate a campaign name:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，`＃5`是生成广告系列名称的逻辑：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Analysts use spreadsheets all the time, and they come up with all sorts of coding
    techniques to compress as much information as possible into the campaign names.
    The format I chose is a simple example of that technique—there is a code that
    tells us the campaign type, then the start and end dates, then the target `age`
    and `gender`, and finally the currency. All values are separated by an underscore.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 分析师们经常使用电子表格，并想出各种编码技术，以尽可能多地压缩信息到广告系列名称中。我选择的格式是这种技术的一个简单示例——有一个代码告诉我们广告系列类型，然后是开始和结束日期，然后是目标`年龄`和`性别`，最后是货币。所有值都用下划线分隔。
- en: In the `get_type` function, I use `random.choice()` to get one value randomly
    out of a collection. Probably more interesting is `get_start_end_dates`. First,
    I get the duration for the campaign, which goes from one day to two years (randomly),
    then I get a random offset in time which I subtract from today's date in order
    to get the start date. Given that an offset is a random number between -365 and
    365, would anything be different if I added it to today's date instead of subtracting
    it?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在`get_type`函数中，我使用`random.choice()`从集合中随机获取一个值。也许更有趣的是`get_start_end_dates`。首先，我得到了广告系列的持续时间，从一天到两年（随机），然后我得到了一个随机的时间偏移，我从今天的日期中减去它以获得开始日期。鉴于偏移是-365到365之间的随机数，如果我将它添加到今天的日期而不是减去它，会有什么不同吗？
- en: When I have both the start and end dates, I return a stringified version of
    them, joined by an underscore.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我有开始和结束日期时，我会返回它们的字符串版本，用下划线连接起来。
- en: Then, we have a bit of modular trickery going on with the age calculation. I
    hope you remember the modulo operator (`%`) from [Chapter 2](part0056.html#1LCVG0-2ddb708647cc4530a187c2c6c0e9acfe),
    *Built-in Data Types*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们对年龄计算进行了一些模块化的技巧。我希望你还记得[第2章](part0056.html#1LCVG0-2ddb708647cc4530a187c2c6c0e9acfe)中的取模运算符（`％`）。
- en: What happens here is that I want a date range that has multiples of five as
    extremes. So, there are many ways to do it, but what I do is to get a random number
    between `20` and `45` for the left extreme, and remove the remainder of the division
    by `5`. So, if, for example, I get *28*, I will remove *28 % 5 = 3* from it, getting
    *25*. I could have just used `random.randrange()`, but it's hard to resist modular
    division.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的是，我想要一个具有五的倍数作为极端的日期范围。因此，有很多方法可以做到这一点，但我做的是从`20`到`45`之间获取一个随机数，然后去除除以`5`的余数。因此，例如，如果我得到*28*，我将从中去除*28％5
    = 3*，得到*25*。我本来可以使用`random.randrange()`，但很难抵制模块化除法。
- en: 'The rest of the functions are just some other applications of `random.choice()`
    and the last one, `get_campaign_name`, is nothing more than a collector for all
    these puzzle pieces that returns the final campaign name:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的函数只是`random.choice()`的一些其他应用，最后一个`get_campaign_name`只是一个收集所有这些拼图块的收集器，返回最终的广告系列名称：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In `#6`, we write a function that creates a complete campaign object. I used
    a few different functions from the `random` module. `random.randint()` gives you
    an integer between two extremes. The problem with it is that it follows a uniform
    probability distribution, which means that any number in the interval has the
    same probability of coming up.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在`＃6`中，我们编写了一个创建完整广告系列对象的函数。我使用了`random`模块中的一些不同函数。`random.randint()`给出了两个极端之间的整数。它的问题在于它遵循均匀概率分布，这意味着区间内的任何数字出现的概率都是相同的。
- en: Therefore, when dealing with a lot of data, if you distribute your fixtures
    using a uniform distribution, the results you get will all look similar. For this
    reason, I chose to use `triangular` and `gauss`, for `clicks` and `impressions`.
    They use different probability distributions so that we'll have something more
    interesting to see in the end.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当处理大量数据时，如果你使用均匀分布来分发你的固定值，你得到的结果将会看起来很相似。因此，我选择使用`triangular`和`gauss`，对于`clicks`和`impressions`。它们使用不同的概率分布，这样我们最终会有一些更有趣的东西。
- en: 'Just to make sure we''re on the same page with the terminology: `clicks` represents
    the number of clicks on a campaign advertisement, `budget` is the total amount
    of money allocated for the campaign, `spent` is how much of that money has already
    been spent, and `impressions` is the number of times the campaign has been fetched,
    as a resource, from its source, regardless of the number of clicks that were performed
    on the campaign. Normally, the amount of `impressions` is greater than the number
    of `clicks`.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们对术语的理解是一致的：`clicks`代表对活动广告的点击次数，`budget`是分配给活动的总金额，`spent`是已经花费的金额，`impressions`是活动从其来源获取的次数，无论点击了多少次活动。通常，`impressions`的数量大于`clicks`的数量。
- en: 'Now that we have the data, it''s time to put it all together:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了数据，是时候把它们整合在一起了：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, each item in `data` is a dictionary with a `user` and a list
    of campaigns that are associated with that `user`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`data`中的每个项目都是一个带有`user`和与该`user`相关的一系列活动的字典。
- en: Cleaning the data
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理数据
- en: 'Let''s start cleaning the data:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始清理数据：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We simulate fetching the data from a source and then inspect it. The Notebook
    is the perfect tool for inspecting your steps. You can vary the granularity to
    your needs. The first item in `rough_data` looks like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们模拟从源获取数据然后检查它。笔记本是检查你的步骤的完美工具。你可以根据需要调整粒度。`rough_data`中的第一项看起来像这样：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So, we now start working on it:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们现在开始处理它：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The first thing we need to do in order to be able to feed `DataFrame` with
    this `data` is to denormalize it. This means transforming `data` into a list whose
    items are campaign dictionaries, augmented with their relative `user` dictionary.
    Users will be duplicated in each campaign they belong to. The first item in `data`
    looks like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够用这个`data`来填充`DataFrame`，我们需要做的第一件事是对其进行去规范化。这意味着将`data`转换为一个列表，其项是活动字典，附加上它们的相关`user`字典。用户将在他们所属的每个活动中被复制。`data`中的第一项看起来像这样：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can see that the `user` object has been brought into the campaign dictionary,
    which was repeated for each campaign.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`user`对象已经被带入了活动字典中，这对于每个活动都是重复的。
- en: 'Now, I would like to help you and offer a deterministic second part of the
    chapter, so I''m going to save the data I generated here so that I (and you, too)
    will be able to load it from the next Notebook, and we should then have the same
    results:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我想帮助你并提供本章的确定性第二部分，所以我将保存我在这里生成的数据，这样我（以及你）就可以从下一个笔记本中加载它，然后我们应该有相同的结果：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You should find the `data.json` file in the source code for the book. Now we
    are done with `ch13-dataprep`, so we can close it, and open up `ch13`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在书的源代码中找到`data.json`文件。现在我们已经完成了`ch13-dataprep`，所以我们可以关闭它，然后打开`ch13`。
- en: Creating the DataFrame
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建DataFrame
- en: 'First, we have another round of imports:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有另一轮导入：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `json` and `calendar` libraries come from the standard library. `numpy`
    is the NumPy library, the fundamental package for scientific computing with Python. NumPy
    stands for Numeric Python, and it is one of the most widely-used libraries in
    the data science environment. I'll say a few words about it later on in this chapter.
    `pandas` is the very core upon which the whole project is based. **Pandas** stands
    for **Python Data Analysis Library**. Among many other things, it provides `DataFrame`,
    a matrix-like data structure with advanced processing capabilities. It's customary
    to import `DataFrame` separately and then to `import pandas as pd`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`json`和`calendar`库来自标准库。`numpy`是NumPy库，用于科学计算的基本包。NumPy代表Numeric Python，它是数据科学环境中最广泛使用的库之一。我稍后会在本章中谈到它。`pandas`是整个项目的核心。**Pandas**代表**Python数据分析库**。除了许多其他功能外，它提供了`DataFrame`，这是一种类似矩阵的数据结构，具有高级处理能力。习惯上，单独导入`DataFrame`，然后`import
    pandas as pd`。'
- en: '`arrow` is a nice third-party library that speeds up dealing with dates dramatically.
    Technically, we could do it with the standard library, but I see no reason not
    to expand the range of the example and show you something different.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`arrow`是一个很好的第三方库，可以极大地加快处理日期的速度。从技术上讲，我们可以使用标准库来做到这一点，但我认为没有理由不扩展示例的范围并向你展示一些不同的东西。'
- en: 'After the imports, we load the `data` as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入之后，我们将`data`加载如下：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And finally, it''s time to create `DataFrame`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是时候创建`DataFrame`了：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can inspect the first five rows using the `head` method of `DataFrame`.
    You should see something like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`DataFrame`的`head`方法来检查前五行。你应该会看到类似这样的东西：
- en: '![](../images/00019.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00019.jpeg)'
- en: Jupyter renders the output of the `df.head()` call as HTML automatically. In
    order to have a text-based output, simply wrap `df.head()` in a `print` call.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Jupyter会自动将`df.head()`调用的输出呈现为HTML。为了获得基于文本的输出，只需将`df.head()`包装在`print`调用中。
- en: The `DataFrame` structure is very powerful. It allows us to manipulate a lot
    of its contents. You can filter by rows, columns, aggregate on data, and many
    other operations. You can operate with rows or columns without suffering the time
    penalty you would have to pay if you were working on data with pure Python. This
    happens because, under the covers, `pandas` is harnessing the power of the NumPy
    library, which itself draws its incredible speed from the low-level implementation
    of its core.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataFrame`结构非常强大。它允许我们操纵许多内容。您可以按行、列进行过滤，对数据进行聚合以及许多其他操作。您可以在不受纯Python数据的时间惩罚的情况下操作行或列。这是因为在幕后，`pandas`利用了NumPy库的强大功能，而NumPy库本身又从其核心的低级实现中获得了令人难以置信的速度。'
- en: Using `DataFrame` allows us to couple the power of NumPy with spreadsheet-like
    capabilities so that we'll be able to work on our data in a fashion that is similar
    to what an analyst could do. Only, we do it with code.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`DataFrame`允许我们将NumPy的强大功能与类似电子表格的功能相结合，这样我们就能够以类似分析师的方式处理我们的数据。只是，我们用代码来做。
- en: 'But let''s go back to our project. Let''s see two ways to quickly get a bird''s
    eye view of the data:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们回到我们的项目。让我们看看两种快速了解数据的方法：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`count` yields a count of all the non-empty cells in each column. This is good
    to help you understand how sparse your data can be. In our case, we have no missing
    values, so the output is:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`count`返回每列中所有非空单元格的计数。这有助于您了解数据有多稀疏。在我们的情况下，我们没有缺失值，因此输出是：'
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Nice! We have 5,037 rows, and the data type is integers (`dtype: int64` means
    long integers because they take 64 bits each). Given that we have 1,000 users
    and the amount of campaigns per user is a random number between 2 and 8, we''re
    exactly in line with what I was expecting:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '太好了！我们有5,037行数据，数据类型是整数（`dtype: int64`表示长整数，因为每个整数占用64位）。考虑到我们有1,000个用户，每个用户的活动数量是2到8之间的随机数，我们正好符合我的预期：'
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `describe` method is a nice, quick way to introspect a bit further:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe`方法是一个不错的、快速的深入了解的方法：'
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, it gives us several measures, such as `count`, `mean`, `std`
    (standard deviation), `min`, and `max`, and shows how data is distributed in the
    various quadrants. Thanks to this method, we already have a rough idea of how
    our data is structured.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，它为我们提供了几个度量，如`count`、`mean`、`std`（标准偏差）、`min`和`max`，并显示数据在各个象限中的分布情况。由于这种方法，我们已经对我们的数据结构有了一个大致的了解。
- en: 'Let''s see which are the three campaigns with the highest and lowest budgets:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看哪三个活动的预算最高和最低：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This gives the following output:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了以下输出：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And a call to tail shows us the ones with the lowest budgets:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`tail`会显示出预算最低的活动：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Unpacking the campaign name
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解开活动名称
- en: Now it's time to increase the complexity. First of all, we want to get rid of
    that horrible campaign name (`cmp_name`). We need to explode it into parts and
    put each part in one dedicated column. In order to do this, we'll use the `apply`
    method of the `Series` object.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候增加复杂性了。首先，我们想摆脱那个可怕的活动名称（`cmp_name`）。我们需要将其分解为部分，并将每个部分放入一个专用列中。为了做到这一点，我们将使用`Series`对象的`apply`方法。
- en: 'The `pandas.core.series.Series` class is basically a powerful wrapper around
    an array (think of it as a list with augmented capabilities). We can extrapolate
    a `Series` object from `DataFrame` by accessing it in the same way we do with
    a key in a dictionary, and we can call `apply` on that `Series` object, which
    will run a function feeding each item in the `Series` to it. We compose the result
    into a new `DataFrame`, and then join that `DataFrame` with `df`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas.core.series.Series`类基本上是一个数组的强大包装器（将其视为具有增强功能的列表）。我们可以通过与字典中的键相同的方式从`DataFrame`中提取`Series`对象，并且我们可以在该`Series`对象上调用`apply`，这将运行一个函数将`Series`中的每个项目传递给它。我们将结果组合成一个新的`DataFrame`，然后将该`DataFrame`与`df`连接：'
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Within `unpack_campaign_name`, we split the campaign `name` in parts. We use
    `arrow.get()` to get a proper `date` object out of those strings (`arrow` makes
    it really easy to do it, doesn''t it?), and then we return the objects. A quick
    peek at the last line reveals:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在`unpack_campaign_name`中，我们将活动`name`分成几部分。我们使用`arrow.get()`从这些字符串中获取一个合适的`date`对象（`arrow`使这变得非常容易，不是吗？），然后我们返回这些对象。快速查看最后一行显示：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Nice! One important thing: even if the dates appear as strings, they are just
    the representation of the real `date` objects that are hosted in `DataFrame`.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！一个重要的事情：即使日期显示为字符串，它们只是托管在`DataFrame`中的真实`date`对象的表示。
- en: 'Another very important thing: when joining two `DataFrame` instances, it''s
    imperative that they have the same `index`, otherwise `pandas` won''t be able
    to know which rows go with which. Therefore, when we create `campaign_df`, we
    set its `index` to the one from `df`. This enables us to join them. When creating
    this `DataFrame`, we also pass the column''s names:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件非常重要的事情：当连接两个`DataFrame`实例时，它们必须具有相同的`index`，否则`pandas`将无法知道哪些行与哪些行配对。因此，当我们创建`campaign_df`时，我们将其`index`设置为`df`的`index`。这使我们能够将它们连接起来。在创建此`DataFrame`时，我们还传递了列的名称：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And after `join`, we take a peek, hoping to see matching data:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在`join`之后，我们做了一个快速查看，希望看到匹配的数据：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The truncated output of the preceding code snippet is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段的截断输出如下：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, `join` was successful; the campaign name and the separate columns
    expose the same data. Did you see what we did there? We're accessing `DataFrame` using
    the square brackets syntax, and we pass a list of column names. This will produce
    a brand new `DataFrame`, with those columns (in the same order), on which we then
    call the `head()` method.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`join`是成功的；活动名称和单独的列显示了相同的数据。您看到我们在那里做了什么吗？我们使用方括号语法访问`DataFrame`，并传递一个列名的列表。这将产生一个全新的`DataFrame`，其中包含这些列（顺序相同），然后我们调用`head()`方法。
- en: Unpacking the user data
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解开用户数据
- en: 'We now do the exact same thing for each piece of `user` JSON data. We call
    `apply` on the `user` series, running the `unpack_user_json` function, which takes
    a JSON `user` object and transforms it into a list of its fields, which we can
    then inject into a brand new `DataFrame`, `user_df`. After that, we''ll join `user_df`
    back with `df`, like we did with `campaign_df`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对每个`user` JSON数据的每一部分做完全相同的事情。我们在`user`系列上调用`apply`，运行`unpack_user_json`函数，该函数接受一个JSON
    `user`对象并将其转换为其字段的列表，然后我们可以将其注入到全新的`DataFrame` `user_df`中。之后，我们将`user_df`与`df`重新连接，就像我们对`campaign_df`所做的那样：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Very similar to the previous operation, isn''t it? We should also note here
    that, when creating `user_df`, we need to instruct `DataFrame` about the column
    names and the `index`. Let''s join and take a quick peek:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前的操作非常相似，不是吗？我们还需要注意，在创建`user_df`时，我们需要指示`DataFrame`关于列名和`index`。让我们加入并快速查看一下：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output shows us that everything went well. We''re good, but we''re not
    done yet. If you call `df.columns` in a cell, you''ll see that we still have ugly
    names for our columns. Let''s change that:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 输出向我们展示了一切都进行得很顺利。我们很好，但我们还没有完成。如果你在一个单元格中调用`df.columns`，你会看到我们的列名仍然很丑陋。让我们来改变一下：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Good! Now, with the exception of `'cmp_name'` and `'user'`, we only have nice
    names.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 好了！现在，除了`'cmp_name'`和`'user'`之外，我们只有漂亮的名称。
- en: 'Completing the `datasetNext` step will be to add some extra columns. For each
    campaign, we have the numbers of clicks and impressions, and we have the amounts
    spent. This allows us to introduce three measurement ratios: **CTR**, **CPC**,
    and **CPI**. They stand for **Click Through Rate**, **Cost Per Click**, and **Cost
    Per Impression**, respectively.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 完成`datasetNext`步骤将是添加一些额外的列。对于每个活动，我们有点击次数和展示次数，还有花费金额。这使我们能够引入三个测量比率：**CTR**，**CPC**和**CPI**。它们分别代表**点击通过率**，**每次点击成本**和**每次展示成本**。
- en: 'The last two are straightforward, but CTR is not. Suffice it to say that it
    is the ratio between clicks and impressions. It gives you a measure of how many
    clicks were performed on a campaign advertisement per impression—the higher this
    number, the more successful the advertisement is in attracting users to click
    on it:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个很简单，但CTR不是。简而言之，它是点击次数和展示次数之间的比率。它为您提供了一个指标，即有多少次点击是在广告活动上每次展示中进行的-这个数字越高，广告吸引用户点击的成功性就越高：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: I wrote this as a function, but I could have just written the code in the cell.
    It's not important. What I want you to notice here is that we're adding those
    three columns with one line of code each, but `DataFrame` applies the operation
    automatically (the division, in this case) to each pair of cells from the appropriate
    columns. So, even if they are masked as three divisions, these are actually *5037
    * 3* divisions, because they are performed for each row. Pandas does a lot of
    work for us, and also does a very good job of hiding the complexity of it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我将其写成一个函数，但我也可以直接在单元格中编写代码。这不重要。我想让你注意到的是，我们只需每行代码添加这三列，但`DataFrame`会自动应用操作（在这种情况下是除法）到适当列的每对单元格。因此，即使它们被掩盖为三个除法，这实际上是*5037
    * 3*个除法，因为它们是针对每一行执行的。Pandas为我们做了很多工作，并且很好地隐藏了其复杂性。
- en: The function, `calculate_extra_columns`, takes `DataFrame`, and works directly
    on it. This mode of operation is called **in-place**. Do you remember how `list.sort()`
    was sorting the list? It is the same deal. You could also say that this function
    is not pure, which means it has side effects, as it modifies the mutable object
    it is passed as an argument.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`calculate_extra_columns`接受`DataFrame`，并直接在其上运行。这种操作模式称为**原地**。你还记得`list.sort()`是如何对列表进行排序的吗？它是一样的。你也可以说这个函数不是纯的，这意味着它具有副作用，因为它修改了作为参数传递的可变对象。
- en: 'We can take a look at the results by filtering on the relevant columns and
    calling `head`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过过滤相关列并调用`head`来查看结果：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This shows us that the calculations were performed correctly on each row:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这向我们展示了每一行上的计算都是正确执行的：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, I want to verify the accuracy of the results manually for the first row:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我想手动验证第一行的结果的准确性：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This yields the following output:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了以下输出：
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is exactly what we saw in the previous output. Of course, I wouldn't normally
    need to do this, but I wanted to show you how can you perform calculations this
    way. You can access `Series` (a column) by passing its name to `DataFrame`, in
    square brackets, and then you access each row by its position, exactly as you
    would with a regular list or tuple.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们在先前的输出中看到的。当然，我通常不需要这样做，但我想向你展示如何以这种方式执行计算。你可以通过将其名称传递给`DataFrame`的方括号来访问`Series`（一列），然后通过其位置访问每一行，就像你使用常规列表或元组一样。
- en: 'We''re almost done with our `DataFrame`. All we are missing now is a column
    that tells us the duration of the campaign and a column that tells us which `day`
    of the week corresponds to the start date of each campaign. This allows me to
    expand on how to play with `date` objects:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`DataFrame`几乎完成了。我们现在缺少的只是一个列，告诉我们活动的持续时间，以及一个列，告诉我们每个活动的开始日期对应的是一周中的哪一天。这使我能够扩展如何使用`date`对象进行操作：
- en: '[PRE38]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We used two different techniques here but first, the code.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了两种不同的技术，但首先是代码。
- en: '`get_day_of_the_week` takes a `date` object. If you cannot understand what
    it does, please take a few moments to try to understand for yourself before reading
    the explanation. Use the inside-out technique like we''ve done a few times before.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_day_of_the_week`接受一个`date`对象。如果你不明白它的作用，请花点时间自己尝试理解一下，然后再阅读解释。使用我们之前做过几次的从内到外的技术。'
- en: So, as I'm sure you know by now, if you put `calendar.day_name` in a `list`
    call, you get `['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday',
    'Sunday']`. This means that, if we enumerate `calendar.day_name` starting from
    `1`, we get pairs such as `(1, 'Monday')`, `(2, 'Tuesday')`, and so on. If we
    feed these pairs to a dictionary, we get a mapping between the days of the week
    as numbers (1, 2, 3, ...) and their names. When the mapping is created, in order
    to get the name of a day, we just need to know its number. To get it, we call
    `date.isoweekday()`, which tells us which day of the week that date is (as a number).
    You feed that into the mapping and, boom! You have the name of the day.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我相信你现在已经知道了，如果你将`calendar.day_name`放在`list`调用中，你会得到`['Monday', 'Tuesday',
    'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']`。这意味着，如果我们从`1`开始枚举`calendar.day_name`，我们会得到诸如`(1,
    'Monday')`，`(2, 'Tuesday')`等等的对。如果我们将这些对传递给一个字典，我们就得到了一种将星期几与它们的名称相对应的映射关系。当映射创建完成后，为了得到一天的名称，我们只需要知道它的数字。为了得到它，我们调用`date.isoweekday()`，这告诉我们那一天是一周的第几天（作为一个数字）。你将这个数字传递给映射，嘭！你就得到了这一天的名称。
- en: '`get_duration` is interesting as well. First, notice it takes an entire row,
    not just a single value. What happens in its body is that we perform a subtraction
    between a campaign''s end and start dates. When you subtract `date` objects, the
    result is a `timedelta` object, which represents a given amount of time. We take
    the value of its `.days` property. It is as simple as that.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_duration` 也很有趣。首先，注意它接受整行数据，而不仅仅是单个值。在函数体内部发生的是我们计算活动结束日期和开始日期之间的差值。当你对`date`对象进行减法运算时，结果是一个`timedelta`对象，它代表了一定的时间量。我们取它的`.days`属性的值。就是这么简单。'
- en: Now, we can introduce the fun part, the application of those two functions.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以介绍有趣的部分，应用这两个函数。
- en: The first application is performed on a `Series` object, like we did before
    for `'user'` and `'cmp_name'`; there is nothing new here.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个应用是在`Series`对象上执行的，就像我们之前对`'user'`和`'cmp_name'`做的那样；这里没有什么新的。
- en: The second one is applied to the whole `DataFrame` and, in order to instruct
    `pandas` to perform that operation on the rows, we pass `axis=1`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个应用于整个`DataFrame`，为了指示`pandas`在行上执行该操作，我们传递`axis=1`。
- en: 'We can verify the results very easily, as shown here:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地验证结果，如下所示：
- en: '[PRE39]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The preceding code yields the following output:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码产生了以下输出：
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: So, we now know that between the 24^(th) of March, 2019 and the 6^(th) of November,
    2020 there are 593 days, and that the 24^(th) of March, 2019 is a Sunday.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们现在知道在2019年3月24日和2020年11月6日之间有593天，2019年3月24日是星期日。
- en: If you're wondering what the purpose of this is, I'll provide an example. Imagine
    that you have a campaign that is tied to a sports event that usually takes place
    on a Sunday. You may want to inspect your data according to the days so that you
    can correlate them to the various measurements you have. We're not going to do
    it in this project, but it was useful to see, if only for the different way of
    calling `apply()` on `DataFrame`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道这样做的目的是什么，我会举个例子。想象一下，你有一个与通常在星期日举行的体育赛事相关联的活动。你可能想根据日期检查你的数据，以便将它们与你拥有的各种测量结果相关联。我们在这个项目中不打算这样做，但是看到这种方式在`DataFrame`上调用`apply()`是很有用的。
- en: Cleaning everything up
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理一切
- en: 'Now that we have everything we want, it''s time to do the final cleaning; remember
    we still have the `''cmp_name''` and `''user''` columns. Those are useless now,
    so they have to go. Also, I want to reorder the columns in `DataFrame` so that
    it is more relevant to the data it now contains. In order to do this, we just
    need to filter `df` on the column list we want. We''ll get back a brand new `DataFrame`
    that we can reassign to `df` itself:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经得到了我们想要的一切，是时候进行最后的清理了；记住我们仍然有`'cmp_name'`和`'user'`列。现在它们没有用了，所以它们必须离开。另外，我想重新排列`DataFrame`中的列，使其更相关于它现在包含的数据。为了做到这一点，我们只需要根据我们想要的列列表对`df`进行过滤。我们将得到一个全新的`DataFrame`，我们可以重新分配给`df`本身：
- en: '[PRE41]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: I have grouped the campaign information at the beginning, then the measurements,
    and finally the user data at the end. Now our `DataFrame` is clean and ready for
    us to inspect.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我将活动信息分组放在前面，然后是测量数据，最后是用户数据。现在我们的`DataFrame`已经干净，可以供我们检查。
- en: Before we start going crazy with graphs, what about taking a snapshot of `DataFrame`
    so that we can easily reconstruct it from a file, rather than having to redo all
    the steps we did to get here. Some analysts may want to have it in spreadsheet
    form, to do a different kind of analysis than the one we want to do, so let's
    see how to save `DataFrame` to a file. It's easier done than said.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始用图表疯狂之前，怎么样先对`DataFrame`进行快照，这样我们就可以很容易地从文件中重新构建它，而不必重新做到这里的所有步骤。一些分析师可能希望以电子表格形式保存它，以进行与我们想要进行的不同类型的分析，所以让我们看看如何将`DataFrame`保存到文件。这比说起来更容易。
- en: Saving the DataFrame to a file
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将DataFrame保存到文件
- en: We can save `DataFrame` in many different ways. You can type `df.to_` and then
    press *Tab* to make autocompletion pop up, to see all the possible options.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以许多不同的方式保存`DataFrame`。你可以输入`df.to_`，然后按下*Tab*键，使自动补全弹出，以查看所有可能的选项。
- en: 'We''re going to save `DataFrame` in three different formats, just for fun.
    First, CSV:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以三种不同的格式保存`DataFrame`，只是为了好玩。首先是CSV：
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then JSON:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是JSON：
- en: '[PRE43]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'And finally, in an Excel spreadsheet:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在Excel电子表格中：
- en: '[PRE44]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The CSV file looks like this (output truncated):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: CSV文件如下（输出截断）：
- en: '[PRE45]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'And the JSON one looks like this (again, output truncated):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: JSON的输出如下（同样，输出截断）：
- en: '[PRE46]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'So, it''s extremely easy to save `DataFrame` in many different formats, and
    the good news is that the reverse is also true: it''s very easy to load a spreadsheet
    into `DataFrame`. The programmers behind `pandas` went a long way to ease our
    tasks, something to be grateful for.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，将`DataFrame`以许多不同的格式保存是非常容易的，好消息是反之亦然：将电子表格加载到`DataFrame`中也非常容易。`pandas`背后的程序员们为了简化我们的任务走了很长的路，这是值得感激的。
- en: Visualizing the results
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化结果
- en: Finally, the juicy bits. In this section, we're going to visualize some results.
    From a data science perspective, I'm not very interested in going deep into analysis,
    especially because the data is completely random, but still, this code will get
    you started with graphs and other features.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，精彩的部分。在本节中，我们将可视化一些结果。从数据科学的角度来看，我对深入分析并不感兴趣，特别是因为数据是完全随机的，但是，这段代码将帮助您开始使用图形和其他功能。
- en: Something I learned in my life, and this may come as a surprise to you, is that—*looks
    also count*, so it's very important that when you present your results, you do
    your best to *make them pretty*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我在生活中学到的一件事，也许这会让您感到惊讶，那就是—*外表也很重要*，因此当您呈现您的结果时，您应该尽力*使它们漂亮*。
- en: 'First, we tell `pandas` to render graphs in the cell output frame, which is
    convenient. We do it with the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们告诉`pandas`在单元格输出框中呈现图形，这很方便。我们用以下方法做到这一点：
- en: '[PRE47]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then, we proceed with some styling:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们进行一些样式处理：
- en: '[PRE48]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Its purpose is to make the graphs we will look at in this section a little bit
    prettier. You can also instruct the Notebook to do this when you start it from
    the console by passing a parameter, but I wanted to show you this way too since
    it can be annoying to have to restart the Notebook just because you want to plot
    something. In this way, you can do it on the fly and then keep working.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 它的目的是让我们在本节中查看的图形看起来更漂亮一些。您也可以在从控制台启动笔记本时传递参数来指示笔记本执行此操作，但我也想向您展示这种方式，因为如果您想绘制某些东西就必须重新启动笔记本可能会很烦人。通过这种方式，您可以即时执行，然后继续工作。
- en: We also use `pylab` to set the `font.family` to `serif`. This might not be necessary
    on your system. Try to comment it out and execute the Notebook, and see whether
    anything changes.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用`pylab`来将`font.family`设置为`serif`。这在您的系统上可能并不是必要的。尝试将其注释掉并执行笔记本，看看是否有任何变化。
- en: 'Now that `DataFrame` is complete, let''s run `df.describe()` (`#26`) again.
    The results should look something like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`DataFrame`完成了，让我们再次运行`df.describe()`（`#26`）。结果应该看起来像这样：
- en: '![](../images/00020.jpeg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00020.jpeg)'
- en: This kind of quick result is perfect for satisfying those managers who have
    20 seconds to dedicate to you and just want rough numbers.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这种快速结果非常适合满足那些只有20秒时间来关注你并且只想要粗略数字的经理们。
- en: Once again, please keep in mind that our campaigns have different currencies,
    so these numbers are actually meaningless. The point here is to demonstrate the
    `DataFrame` capabilities, not to get to a correct or detailed analysis of real
    data.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，请记住我们的广告系列有不同的货币，因此这些数字实际上是没有意义的。这里的重点是演示`DataFrame`的功能，而不是进行正确或详细的真实数据分析。
- en: 'Alternatively, a graph is usually much better than a table with numbers because
    it''s much easier to read it and it gives you immediate feedback. So, let''s graph
    out the four pieces of information we have on each campaign—`''Budget''`, `''Spent''`,
    `''Clicks''`, and `''Impressions''`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，图表通常比带有数字的表格要好得多，因为它更容易阅读，并且可以立即给出反馈。因此，让我们绘制出每个广告系列的四个信息—`'Budget'`、`'Spent'`、`'Clicks'`和`'Impressions'`：
- en: '[PRE49]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We extrapolate those four columns (this will give us another `DataFrame` made
    with only those columns) and call the histogram `hist()` method on it. We give
    some measurements on the bins and figure sizes, but basically, everything is done
    automatically.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们推断这四列（这将给我们另一个只由这些列组成的`DataFrame`）并在其上调用直方图`hist()`方法。我们对箱子和图形大小进行了一些测量，但基本上一切都是自动完成的。
- en: 'One important thing: since this instruction is the only one in this cell (which
    also means, it''s the last one), the Notebook will print its result before drawing
    the graph. To suppress this behavior and have only the graph drawn with no printing,
    just add a semicolon at the end (you thought I was reminiscing about Java, didn''t
    you?). Here are the graphs:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的事情：由于这个指令是这个单元格中唯一的指令（这也意味着，它是最后一个），笔记本会在绘制图形之前打印其结果。要抑制这种行为，只绘制图形而不打印任何内容，只需在末尾加上一个分号（你以为我在怀念Java，不是吗？）。这里是图形：
- en: '![](../images/00021.jpeg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00021.jpeg)'
- en: 'They are beautiful, aren''t they? Did you notice the serif font? How about
    the meaning of those figures? If you go back and take a look at the way we generate
    the data, you will see that all these graphs make perfect sense:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 它们很漂亮，不是吗？您有没有注意到衬线字体？这些数字的含义如何？如果您回过头看一下我们生成数据的方式，您会发现所有这些图形都是完全合理的：
- en: Budget is simply a random integer in an interval, therefore we were expecting
    a uniform distribution, and there we have it; it's practically a constant line.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预算只是一个在间隔内的随机整数，因此我们预期是均匀分布，而我们确实有；它几乎是一条恒定的线。
- en: Spent is a uniform distribution as well, but the high end of its interval is
    the budget, which is moving. This means we should expect something such as a quadratic
    hyperbole that decreases to the right. And there it is as well.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花费也是均匀分布，但其间隔的高端是预算，而预算是在变化的。这意味着我们应该期望类似于向右减少的二次双曲线。而它也在那里。
- en: Clicks was generated with a triangular distribution with a mean roughly 20%
    of the interval size, and you can see that the peak is right there, at about 20%
    to the left.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击是用三角形分布生成的，平均值大约是间隔大小的20%，您可以看到峰值就在那里，大约向左20%。
- en: Impressions was a Gaussian distribution, which is the one that assumes the famous
    bell shape. The mean was exactly in the middle and we had a standard deviation
    of 2\. You can see that the graph matches those parameters.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 印象是一个高斯分布，这是假设著名的钟形曲线的分布。平均值恰好在中间，标准偏差为2。您可以看到图形符合这些参数。
- en: 'Good! Let''s plot out the measures we calculated:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 好了！让我们绘制出我们计算的测量值：
- en: '[PRE50]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Here is the plot representation:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这是图形表示：
- en: '![](../images/00022.jpeg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00022.jpeg)'
- en: We can see that the CPC is highly skewed to the left, meaning that most of the
    CPC values are very low. The CPI has a similar shape, but is less extreme.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到CPC向左高度倾斜，这意味着大多数CPC值非常低。CPI形状类似，但不那么极端。
- en: 'Now, all this is nice, but if you wanted to analyze only a particular segment
    of the data, how would you do it? We can apply a mask to `DataFrame` so that we
    get another one with only the rows that satisfy the mask condition. It''s like
    applying a global, row-wise `if` clause:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这一切都很好，但如果你只想分析数据的特定部分，你该怎么做呢？我们可以对`DataFrame`应用一个掩码，这样我们就可以得到另一个只包含满足掩码条件的行的`DataFrame`。这就像应用全局的、逐行的`if`子句一样：
- en: '[PRE51]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In this case, I prepared `mask` to filter out all the rows for which the amount
    spent is less than or equal to 75% of the budget. In other words, we'll include
    only those campaigns for which we have spent at least three-quarters of the budget.
    Notice that in `mask`, I am showing you an alternative way of asking for a `DataFrame`
    column, by using direct property access (`object.property_name`), instead of dictionary-like
    access (`object['property_name']`). If `property_name` is a valid Python name,
    you can use both ways interchangeably (JavaScript works like this as well).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我准备了`mask`，以过滤掉花费金额少于或等于预算的所有行。换句话说，我们只包括那些花费至少达到预算四分之三的广告系列。请注意，在`mask`中，我向你展示了一种请求`DataFrame`列的替代方式，即使用直接属性访问（`object.property_name`），而不是类似字典的访问（`object['property_name']`）。如果`property_name`是一个有效的Python名称，你可以交替使用这两种方式（JavaScript也是这样工作的）。
- en: '`mask` is applied in the same way that we access a dictionary with a key. When
    you apply `mask` to `DataFrame`, you get back another one and we select only the
    relevant columns on this and call `hist()` again. This time, just for fun, we
    want the results to be green:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`mask`的应用方式类似于我们访问带有键的字典。当你将`mask`应用到`DataFrame`上时，你会得到另一个`DataFrame`，然后我们只选择相关的列，并再次调用`hist()`。这一次，只是为了好玩，我们希望结果是绿色的：'
- en: '![](../images/00023.jpeg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00023.jpeg)'
- en: Note that the shapes of the graphs haven't changed much, apart from the Spent
    graph,  which is quite different. The reason for this is that we've asked only
    for the rows where the amount spent is at least 75% of the budget. This means
    that we're including only the rows where the amount spent is close to the budget.
    The budget numbers come from a uniform distribution. Therefore, it is quite obvious
    that the Spent graph is now assuming that kind of shape. If you make the boundary
    even tighter and ask for 85% or more, you'll see the Spent graph become more and
    more like the Budget one.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，图形的形状除了'花费'图形之外，基本没有改变，'花费'图形非常不同。原因是我们只要求包括花费金额至少达到预算的行。这意味着我们只包括了花费接近预算的行。预算数字来自均匀分布。因此，很明显，'花费'图形现在呈现出这种形状。如果你把边界设得更紧，要求达到85%或更多，你会看到'花费'图形越来越像预算图形。
- en: 'Let''s now ask for something different. How about the measure of `''Spent''`,
    `''Clicks''`, and `''Impressions''` grouped by day of the week:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看不同的东西。如何按星期几分组测量'花费'、'点击'和'展示'的指标：
- en: '[PRE52]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The first line creates a new `DataFrame`, `df_weekday`, by asking for a grouping
    by `'Day of Week'` on `df`. The function used to aggregate the data is an addition.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行通过在`df`上按照'星期几'分组来创建一个新的`DataFrame`，`df_weekday`。用于聚合数据的函数是加法。
- en: 'The second line gets a slice of `df_weekday` using a list of column names,
    something we''re accustomed to by now. On the result, we call `plot()`, which
    is a bit different to `hist()`. The `subplots=True` option makes `plot` draw three
    independent graphs:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行使用列名列表获取`df_weekday`的一个切片，这是我们现在习惯的做法。然后我们调用`plot()`，这和`hist()`有点不同。`subplots=True`选项使`plot`绘制三个独立的图形：
- en: '![](../images/00024.jpeg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00024.jpeg)'
- en: Interestingly enough, we can see that most of the action happens on Sundays
    and Wednesdays. If this were meaningful data, this would potentially be important
    information to give to our clients, which is why I'm showing you this example.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我们可以看到大部分活动发生在星期日和星期三。如果这是有意义的数据，这可能是向客户提供重要信息的原因，这就是为什么我向你展示这个例子。
- en: Note that the days are sorted alphabetically, which scrambles them up a bit.
    Can you think of a quick solution that would fix the issue? I'll leave it to you
    as an exercise to come up with something.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，日期按字母顺序排序，这有点混乱。你能想到一个快速的解决方案来解决这个问题吗？我把这个问题留给你作为一个练习来解决。
- en: 'Let''s finish this presentation section with a couple more things. First, a
    simple aggregation. We want to aggregate on `''Target Gender''` and `''Target
    Age''`, and show `''Impressions''` and `''Spent''`. For both, we want to see `''mean''`
    and the standard deviation (`''std''`):'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用几个简单的聚合来结束这个演示部分。我们想在'Target Gender'和'Target Age'上进行聚合，并显示'Impressions'和'Spent'。对于这两个指标，我们想看到'平均值'和标准差（'std'）：
- en: '[PRE53]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'It''s very easy to do. We will prepare a dictionary that we''ll use as a configuration.
    Then, we perform a grouping on the `''Target Gender''` and `''Target Age''` columns,
    and we pass our configuration dictionary to the `agg()` method. The result is
    truncated and rearranged a little bit to make it fit, and shown here:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易做。我们将准备一个字典作为配置。然后，我们对'Target Gender'和'Target Age'列进行分组，并将我们的配置字典传递给`agg()`方法。结果被截断和重新排列了一点，以使其适应，并在这里显示：
- en: '[PRE54]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This is the textual representation, of course, but you can also have the HTML
    one.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是文本表示，但你也可以有HTML表示。
- en: 'Let''s do one more thing before we wrap this chapter up. I want to show you
    something called a **pivot table**. It''s kind of a buzzword in the data environment,
    so an example such as this one, albeit very simple, is a must:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章之前，让我们做一件事。我想向你展示一个叫做**数据透视表**的东西。在数据环境中，这是一个流行词，所以这样一个简单的例子是必不可少的：
- en: '[PRE55]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We create a pivot table that shows us the correlation between `'Target Age'`
    and `'Impressions'`, `'Clicks'`, and `'Spent'`. These last three will be subdivided
    according to `'Target Gender'`. The aggregation function (`aggfunc`) used to calculate
    the results is the `numpy.sum` function (`numpy.mean` would be the default, had
    I not specified anything).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个数据透视表，显示了“目标年龄”和“展示次数”、“点击次数”和“花费”之间的相关性。最后三个将根据“目标性别”进行细分。用于计算结果的聚合函数（aggfunc）是numpy.sum函数（如果我没有指定任何内容，numpy.mean将是默认值）。
- en: 'After creating the pivot table, we simply print it with the last line in the
    cell, and here''s a crop of the result:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了数据透视表之后，我们只需用单元格中的最后一行打印它，这里是结果的一部分：
- en: '![](../images/00025.jpeg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00025.jpeg)'
- en: It's pretty clear and provides very useful information when the data is meaningful.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据有意义时，它非常清晰并提供非常有用的信息。
- en: That's it! I'll leave you to discover more about the wonderful world of IPython,
    Jupyter, and data science. I strongly encourage you to get comfortable with the
    Notebook environment. It's much better than a console, it's extremely practical
    and fun to use, and you can even create slides and documents with it.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我会让你自己去探索IPython、Jupyter和数据科学的美妙世界。我强烈建议你熟悉Notebook环境。它比控制台好得多，非常实用和有趣，你甚至可以用它创建幻灯片和文档。
- en: Where do we go from here?
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来我们去哪里？
- en: 'Data science is indeed a fascinating subject. As I said in the introduction,
    those who want to delve into its meanders need to be well-trained in mathematics
    and statistics. Working with data that has been interpolated incorrectly renders
    any result about it useless. The same goes for data that has been extrapolated
    incorrectly or sampled with the wrong frequency. To give you an example, imagine
    a population of individuals that are aligned in a queue. If for some reason, the
    gender of that population alternated between male and female, the queue would
    be something like this: F-M-F-M-F-M-F-M-F...'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学确实是一个迷人的课题。正如我在介绍中所说的，那些想要深入研究它的人需要在数学和统计学方面接受良好的训练。与插值不正确的数据一起工作会使得任何关于它的结果变得毫无意义。同样，对于不正确外推或以错误频率采样的数据也是如此。举个例子，想象一群排队的人，如果由于某种原因，这群人的性别在男女之间交替，那么排队就会是这样：F-M-F-M-F-M-F-M-F...
- en: If you sampled it taking only the even elements, you would draw the conclusion
    that the population was made up only of males, while sampling the odd ones would
    tell you exactly the opposite.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只取偶数元素进行采样，你会得出结论说这个群体只由男性组成，而采样奇数元素会告诉你完全相反的结论。
- en: Of course, this was just a silly example, I know, but it's very easy to make
    mistakes in this field, especially when dealing with big data where sampling is
    mandatory and therefore, the quality of the introspection you make depends, first
    and foremost, on the quality of the sampling itself.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是一个愚蠢的例子，我知道，但在这个领域很容易犯错，特别是在处理大数据时，采样是强制性的，因此，你所做的内省的质量首先取决于采样本身的质量。
- en: 'When it comes to data science and Python, these are the main tools you want
    to look at:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据科学和Python方面，这些是你想要了解的主要工具：
- en: '**NumPy** ([http://www.numpy.org/](http://www.numpy.org/)): This is the main
    package for scientific computing with Python. It contains a powerful N-dimensional
    array object, sophisticated (broadcasting) functions, tools for integrating C/C++
    and Fortran code, useful linear algebra, the Fourier transform, random number
    capabilities, and much more.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy（http://www.numpy.org/）：这是用Python进行科学计算的主要包。它包含一个强大的N维数组对象，复杂的（广播）函数，用于集成C/C++和Fortran代码的工具，有用的线性代数，傅里叶变换，随机数功能等等。
- en: '**Scikit-Learn** ([http://scikit-learn.org/](http://scikit-learn.org/)): This
    is probably the most popular machine learning library in Python. It has simple
    and efficient tools for data mining and data analysis, accessible to everybody,
    and reusable in various contexts. It''s built on NumPy, SciPy, and Matplotlib.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scikit-Learn（http://scikit-learn.org/）：这可能是Python中最流行的机器学习库。它具有简单高效的数据挖掘和数据分析工具，适用于所有人，并且可以在各种环境中重复使用。它构建在NumPy、SciPy和Matplotlib之上。
- en: '**Pandas** ([http://pandas.pydata.org/](http://pandas.pydata.org/)): This is
    an open source, BSD-licensed library providing high-performance, easy-to-use data
    structures, and data analysis tools. We''ve used it throughout this chapter.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pandas（http://pandas.pydata.org/）：这是一个开源的、BSD许可的库，提供高性能、易于使用的数据结构和数据分析工具。我们在本章中一直在使用它。
- en: '**IPython** ([http://ipython.org/](http://ipython.org/))/**Jupyter** ([http://jupyter.org/](http://jupyter.org/)):
    These provide a rich architecture for interactive computing.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPython（http://ipython.org/）/Jupyter（http://jupyter.org/）：这提供了丰富的交互式计算架构。
- en: '**Matplotlib** ([http://matplotlib.org/](http://matplotlib.org/)): This is
    a Python 2-D plotting library that produces publication-quality figures in a variety
    of hard-copy formats and interactive environments across platforms. Matplotlib
    can be used in Python scripts, the Python and IPython shell, Jupyter Notebook,
    web application servers, and four graphical user interface toolkits.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Matplotlib（http://matplotlib.org/）：这是一个Python 2-D绘图库，可以在各种硬拷贝格式和交互式环境中生成出版质量的图形。Matplotlib可以在Python脚本、Python和IPython
    shell、Jupyter Notebook、Web应用程序服务器和四个图形用户界面工具包中使用。
- en: '**Numba** ([http://numba.pydata.org/](http://numba.pydata.org/)): This gives
    you the power to speed up your applications with high-performance functions written
    directly in Python. With a few annotations, array-oriented and math-heavy Python
    code can be just-in-time compiled to native machine instructions, similar in performance
    to C, C++, and Fortran, without having to switch languages or Python interpreters.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Numba（http://numba.pydata.org/）：这使您能够通过直接在Python中编写高性能函数来加速应用程序。通过一些注释，面向数组和数学密集型的Python代码可以即时编译为本机机器指令，性能类似于C、C++和Fortran，而无需切换语言或Python解释器。
- en: '**Bokeh** ([http://bokeh.pydata.org/](https://bokeh.pydata.org/)): This is
    a Python-interactive visualization library that targets modern web browsers for
    presentation. Its goal is to provide elegant, concise construction of novel graphics
    in the style of D3.js, but also deliver this capability with high-performance
    interactivity over very large or streaming datasets.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bokeh** ([http://bokeh.pydata.org/](https://bokeh.pydata.org/))：这是一个Python交互式可视化库，旨在面向现代网络浏览器进行演示。它的目标是以D3.js的风格提供优雅、简洁的新图形构建，同时在非常大或流式数据集上提供高性能的交互能力。'
- en: Other than these single libraries, you can also find ecosystems, such as **SciPy**
    ([http://scipy.org/](http://scipy.org/)) and the aforementioned **Anaconda** ([https://anaconda.org/](https://anaconda.org/)),
    that bundle several different packages in order to give you something that just
    works in an "out-of-the-box" fashion.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些单一的库之外，你还可以找到生态系统，比如**SciPy** ([http://scipy.org/](http://scipy.org/)) 和前面提到的**Anaconda**
    ([https://anaconda.org/](https://anaconda.org/))，它们捆绑了几个不同的软件包，以便为您提供一个“开箱即用”的解决方案。
- en: Installing all these tools and their several dependencies is hard on some systems,
    so I suggest that you try out ecosystems as well to see whether you are comfortable
    with them. It may be worth it.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些系统上安装所有这些工具及其多个依赖项是很困难的，所以我建议你也尝试一下生态系统，看看你是否对它们感到舒适。这可能是值得的。
- en: Summary
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we talked about data science. Rather than attempting to explain
    anything about this extremely wide subject, we delved into a project. We familiarized
    ourselves with the Jupyter Notebook, and with different libraries, such as Pandas,
    Matplotlib, and NumPy.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们谈到了数据科学。我们并没有试图解释这个极其广泛的主题，而是深入了一个项目。我们熟悉了Jupyter Notebook，以及不同的库，比如Pandas、Matplotlib和NumPy。
- en: Of course, having to compress all this information into one single chapter means
    I could only touch briefly on the subjects I presented. I hope the project we've
    gone through together has been comprehensive enough to give you an idea of what
    could potentially be the workflow you might follow when working in this field.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，不得不把所有这些信息压缩到一个章节中意味着我只能简要地涉及我提出的主题。我希望我们一起经历的项目足够全面，让你对在这个领域工作时可能遵循的工作流程有所了解。
- en: The next chapter is dedicated to web development. So, make sure you have a browser
    ready and let's go!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章专门讨论网页开发。所以，请确保你已经准备好浏览器，让我们开始吧！
