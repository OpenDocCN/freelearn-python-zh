- en: Testing Your Serverless Microservice
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试您的无服务器微服务
- en: In the previous chapter, we created a fully functional serverless data API using
    API Gateway, Lambda, and DynamoDB, and we deployed it to the AWS CLI. The testing
    we showed was performed in the AWS Management Console and browser, which is fine
    for small amounts of simple code development as a proof of concept, but is not
    recommended for development or production systems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用API Gateway、Lambda和DynamoDB创建了一个完全功能的无服务器数据API，并将其部署到了AWS CLI。我们展示的测试是在AWS管理控制台和浏览器中进行的，这对于少量简单代码开发作为概念验证是可以的，但不建议用于开发或生产系统。
- en: It is much more efficient for a developer to first develop and test locally,
    and it is essential for continuous delivery to have automated tests. This chapter
    is all about testing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发人员来说，首先在本地开发和测试要高效得多，对于持续交付来说，自动化测试至关重要。本章就是关于测试的。
- en: Testing could easily cover a whole book, but we will keep things very practical
    and focused on testing your serverless code and the data API we deployed in [Chapter
    3](559653f9-3f81-4443-badd-77796dceb0c0.xhtml), *Deploying Your Serverless Stack*.
    This will include unit testing, mocking, local debugging, integration testing,
    running the Lambda or serverless APIs with an HTTP server locally in a Docker
    container, and load testing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可能很容易覆盖整本书，但我们将保持非常实用的方式，并专注于测试您的无服务器代码和我们在[第3章](559653f9-3f81-4443-badd-77796dceb0c0.xhtml)中部署的数据API，*部署您的无服务器堆栈*。这将包括单元测试、模拟、本地调试、集成测试，在Docker容器中本地运行Lambda或无服务器API的HTTP服务器，以及负载测试。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Unit testing your Python Lambda code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对Python Lambda代码进行单元测试
- en: Running and debugging your AWS Lambda code locally
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地运行和调试您的AWS Lambda代码
- en: Integration testing using real test data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用真实测试数据进行集成测试
- en: The AWS **Serverless Application Model** (**SAM**) CLI
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS **无服务器应用程序模型**（**SAM**）CLI
- en: Loading and end-to-end testing at scale
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规模化加载和端到端测试
- en: Strategies to reduce the API's latency
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少API延迟的策略
- en: Cleaning up
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理
- en: Unit testing your Python Lambda code
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对Python Lambda代码进行单元测试
- en: In this section, we are going to look at why testing is important, as well as
    the sample data we can use for testing, unit testing, and mocking.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论为什么测试很重要，以及我们可以用于测试、单元测试和模拟的示例数据。
- en: Why is testing important?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么测试很重要？
- en: Think about the **collaboration and teamwork** taking place in large, distributed
    teams of developers in different countries, and imagine they want to collaborate
    on the same source code repository and check code changes at different times.
    It's very important for these teams to understand the code and be able to test
    it locally to see how it works, whether their changes will impact existing services,
    and whether the code is still working as expected.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 想想在不同国家的大型分布式开发团队中进行的协作和团队合作，想象一下他们想要在同一个源代码仓库上进行协作，并在不同的时间检查代码更改。对于这些团队来说，理解代码并能够在本地测试以查看其工作原理非常重要，他们的更改是否会影响现有服务，以及代码是否仍然按预期工作。
- en: Testing is important to ensure we have **quality** in the delivery or user experience.
    By having lots of tests, you can identify defects early and fix them. For example,
    if there are major bugs detected, you could decide not to release the recent update
    and fix the issues before doing the release.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 测试对于确保交付或用户体验中有**质量**很重要。通过进行大量测试，您可以及早发现缺陷并加以修复。例如，如果检测到了重大错误，您可以决定不发布最近的更新，并在发布之前修复问题。
- en: Another major point is **usability**. For example, your client might have performance
    or non-functional requirements. Imagine an e-commerce website, for example, where
    you could add items and would have to wait a whole minute for them to be added
    to the basket. In most cases, that would be unacceptable and the user would lose
    trust in the platform. Ideally, you would have a testing process to make sure
    that the latency is still low and the website is responsive. Other examples that
    require testing would be features that are not working as expected or user interface
    defects that prevent the users from completing the tasks they want to do.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的点是**可用性**。例如，您的客户可能有性能或非功能性要求。例如，想象一个电子商务网站，您可以在其中添加商品，但必须等待整整一分钟才能将其添加到购物篮中。在大多数情况下，这是不可接受的，用户会失去对平台的信任。理想情况下，您将有一个测试流程，以确保延迟仍然很低，网站响应迅速。需要测试的其他示例包括不按预期工作的功能或用户界面缺陷，这些缺陷会阻止用户完成他们想要做的任务。
- en: It is important to have **shorter release cycles**. Using automation, you can
    run a thousand tests automatically and consistently, without needing a human to
    test different parts of the site manually, test the APIs manually, or rigorously
    inspect the code before any release. Before every release into production, you
    run those thousand tests, making you much more confident that everything is working
    as expected, and if you do spot an issue those thousand tests missed in production,
    you can fix it and add a new test for that scenario too.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有**更短的发布周期**很重要。使用自动化，您可以自动且一致地运行一千次测试，而不需要人工手动测试站点的不同部分，手动测试API，或在任何发布之前严格检查代码。在每次发布到生产环境之前，您都会运行这一千次测试，这样您就会更有信心，一切都按预期工作，如果您在生产中发现了这一千次测试忽略的问题，您可以修复它并为该场景添加一个新的测试。
- en: Types of testing
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试类型
- en: Testing can be done manually, as we have done with the AWS Management Console,
    which is prone to error and not scalable. Generally, tests are automated using
    test suites, which are written in advance and are essential for continuous integration
    and continuous delivery.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可以手动完成，就像我们在AWS管理控制台中所做的那样，这容易出错且不可扩展。通常，测试是使用预先编写的测试套件自动化的，并且对于持续集成和持续交付至关重要。
- en: 'There are many definitions and types of software testing available; it could
    take a whole book to cover them all. Here, we will focus on the three main ones
    that are relevant for our serverless stacks:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多可用的软件测试定义和类型；涵盖它们可能需要整本书。在这里，我们将专注于对我们的无服务器堆栈相关的三种主要类型：
- en: '**Unit testing:** The low-level testing of individual software modules in isolation,
    typically done by the developers and used in **test-driven development** (**TDD**).
    These types of tests are usually quick to execute.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：对单个软件模块进行低级别测试，通常由开发人员完成，并在**测试驱动开发**（**TDD**）中使用。这些类型的测试通常执行速度很快。'
- en: '**Integration testing**: Verifies that all combined services after integration
    are working correctly. These are generally more expensive to run as many services
    need to be running.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：验证集成后所有组合服务是否正常工作。这些通常更昂贵，因为需要运行许多服务。'
- en: '**Load testing**: This is non-functional testing used to check how the system
    performs under a heavy load. It is sometimes also called performance or stress
    testing as it helps to understand the availability and reliability of a platform.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载测试**：这是一种非功能性测试，用于检查系统在重负载下的性能。有时也被称为性能或压力测试，因为它有助于了解平台的可用性和可靠性。'
- en: Unit testing Lambda Python code
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试Lambda Python代码
- en: It is not easy to debug in AWS Management Console; it's much more constructive
    to debug code locally and later automate the process.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在AWS管理控制台中进行调试并不容易；在本地调试代码并稍后自动化该过程要更有建设性。
- en: We know from previous chapters that the Lambda event source is an API Gateway
    `GET` request. As we are only looking at a subset of the data, this full JSON
    payload can be simulated with a few lines of Python code too.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从之前的章节中知道，Lambda事件源是API Gateway的`GET`请求。由于我们只关注数据的一个子集，因此完整的JSON有效负载也可以用几行Python代码模拟出来。
- en: The sample test data
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样本测试数据
- en: Here, we have a test case with a `setUp()` method that is run once at the start
    of the test suite and a `tearDown()` method that is run at the end.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个带有`setUp()`方法的测试用例，该方法在测试套件开始时运行一次，以及一个`tearDown()`方法，在测试结束时运行。
- en: 'Here is a subset of the contents linked to the test setup and teardown at the
    top of `serverless-microservice-data-api/test/test_dynamo_get.py`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在`serverless-microservice-data-api/test/test_dynamo_get.py`顶部的测试设置和拆卸的内容的子集：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'I created four different JSON Python dictionaries:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了四个不同的JSON Python字典：
- en: '`self.validJsonDataNoStartDate`: A valid `GET` request with no `StartDate`
    filter'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.validJsonDataNoStartDate`: 没有`StartDate`过滤器的有效`GET`请求'
- en: '`self.validJsonDataStartDate`: A valid `GET` request with a `StartDate` filter'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.validJsonDataStartDate`: 具有`StartDate`过滤器的有效`GET`请求'
- en: '`self.invalidJsonUserIdData`: An invalid `UserId` that is not a number'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.invalidJsonUserIdData`: 一个无效的`UserId`，不是一个数字'
- en: '`self.invalidJsonData`: Invalid JSON that cannot be parsed'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.invalidJsonData`: 无法解析的无效JSON'
- en: The unit test
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'Here are the units tests that can be found in the middle of `serverless-microservice-data-api/test/test_dynamo_get.py`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以在`serverless-microservice-data-api/test/test_dynamo_get.py`中找到的单元测试：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'I''m using a prefix of `test` so Python test suites can automatically detect
    them as unit tests, and I''m using the triplet unit test naming convention for
    the test methods: the method name, the state under test, and the expected behavior.
    The test methods are as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了`test`的前缀，这样Python测试套件可以自动检测它们作为单元测试，并且我使用了三元单元测试命名约定来命名测试方法：方法名、测试状态和预期行为。测试方法如下：
- en: '`test_validparameters_parseparameters_pass()`: Checks that the parameters are
    parsed correctly.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_validparameters_parseparameters_pass()`: 检查参数是否被正确解析。'
- en: '`test_emptybody_parsebody_nonebody()`: We are not using a body in the `GET`
    method, so we want to make sure that it still works if none is provided.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_emptybody_parsebody_nonebody()`: 在`GET`方法中我们没有使用body，所以我们希望确保如果没有提供body，它仍然可以正常工作。'
- en: '`test_invalidjson_getrecord_notfound404()`: Check how the Lambda will react
    with an invalid JSON payload.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_invalidjson_getrecord_notfound404()`: 检查Lambda对无效的JSON有效负载的反应。'
- en: '`test_invaliduserid_getrecord_invalididerror()`: Check how the Lambda will
    react to an invalid non-number `userId`.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_invaliduserid_getrecord_invalididerror()`: 检查Lambda对无效的非数字`userId`的反应。'
- en: The preceding does not query DynamoDB for the records. If we want to do so,
    we should have DynamoDB running, use the new DynamoDB Local ([https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBLocal.html](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBLocal.html)),
    or we can mock the DynamoDB calls, which is what we will look at next.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的内容并不查询DynamoDB记录。如果我们想要这样做，我们应该让DynamoDB运行起来，使用新的DynamoDB本地（[https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBLocal.html](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBLocal.html)），或者我们可以模拟DynamoDB调用，这是我们接下来要看的。
- en: Mocking
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟
- en: There is a Python AWS mocking framework called Moto ([http://docs.getmoto.org/en/latest/](http://docs.getmoto.org/en/latest/)),
    but I prefer to use a generic one called `mock`, which is much more widely supported
    in the Python community and from Python 3.3 is included in the Python standard
    library.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为Moto的Python AWS模拟框架（[http://docs.getmoto.org/en/latest/](http://docs.getmoto.org/en/latest/)），但我更喜欢使用一个名为`mock`的通用框架，它在Python社区得到了更广泛的支持，并且从Python
    3.3开始已经包含在Python标准库中。
- en: 'The following mocking code can be found at the bottom of `serverless-microservice-data-api/test/test_dynamo_get.py`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下模拟代码可以在`serverless-microservice-data-api/test/test_dynamo_get.py`底部找到：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The key observations from this code are as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码中得出的关键观察结果如下：
- en: '`@mock.patch.object()` is a decorator for the `query_by_partition_key()` or
    `query_by_partition_and_sort_key()` method we are mocking from the `DynamoRepository()`
    class.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@mock.patch.object()`是一个装饰器，用于对我们从`DynamoRepository()`类中模拟的`query_by_partition_key()`或`query_by_partition_and_sort_key()`方法。'
- en: '`test_validid_checkstatus_status200()`: We mock the calls to `query_by_partition_key()`.
    If the query is valid, we get a `''200''` status code back.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_validid_checkstatus_status200()`: 我们模拟对`query_by_partition_key()`的调用。如果查询有效，我们会得到一个`''200''`状态码。'
- en: '`test_validid_getrecords_validparamcall()`: We mock the calls to `query_by_partition_key()`
    and check the method is called with the correct parameters. Note that don''t need
    to check that the lower-level `boto3` `self.db_table.query()` method works.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_validid_getrecords_validparamcall()`: 我们模拟对`query_by_partition_key()`的调用，并检查该方法是否使用了正确的参数进行调用。请注意，我们不需要检查较低级别的`boto3`
    `self.db_table.query()`方法是否有效。'
- en: '`test_validid_getrecordsdate_validparamcall()`: We mock the calls to `query_by_partition_and_sort_key()`
    and check that the method is called with the correct parameters.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_validid_getrecordsdate_validparamcall()`: 我们模拟对`query_by_partition_and_sort_key()`的调用，并检查该方法是否使用正确的参数进行了调用。'
- en: You are not here to test existing third-party libraries or Boto3, but your code
    and integration with them. Mocking allows you to replace parts of the code under
    test with mock objects and make an assertion about the method or attributes.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您不是在这里测试现有的第三方库或Boto3，而是测试您的代码和与它们的集成。模拟允许您用模拟对象替换测试中的代码部分，并对方法或属性进行断言。
- en: Running the unit test
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行单元测试
- en: 'Now that we have all the test suites, rather than run them in your IDE, such
    as PyCharm, you can run the tests from the root folder using the following bash
    command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了所有的测试套件，而不是在IDE（如PyCharm）中运行它们，您可以使用以下bash命令从根文件夹运行测试：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`unittest` automatically detects that all of the test files must be modules
    or packages importable from the top-level directory of the project. Here, we just
    want to run the tests from the test folder that begin with the `test_` prefix.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest`会自动检测所有测试文件必须是项目顶层目录可导入的模块或包。在这里，我们只想从以`test_`为前缀的测试文件夹中运行测试。'
- en: 'I have created a shell script under `serverless-microservice-data-api/bash/apigateway-lambda-dynamodb/unit-test-lambda.sh`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我在`serverless-microservice-data-api/bash/apigateway-lambda-dynamodb/unit-test-lambda.sh`下创建了一个shell脚本：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Code coverage
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码覆盖率
- en: We won't discuss it in depth, but code coverage is another important measure
    used in software engineering. Code coverage measures the degree of code that your
    test suites cover. The main idea is that the higher the coverage percentage, the
    more code is covered by tests, so the less likely you are to create undetected
    bugs and the service should behave as intended. These reports can help developers
    come up with additional tests or scenarios to increase the coverage percentage.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入讨论，但代码覆盖率是软件工程中使用的另一个重要度量标准。代码覆盖率衡量了测试套件覆盖的代码程度。主要思想是，覆盖率百分比越高，测试覆盖的代码就越多，因此创建未检测到的错误的可能性就越小，服务应该按预期运行。这些报告可以帮助开发人员提出额外的测试或场景，以增加覆盖率百分比。
- en: 'Test-coverage-related Python packages include `coverage`, `nose`, and the more
    recent `nose2`, which can provide coverage reports. For example, you can run the
    following to get a test-coverage analysis report of your Lambda code with `nose`
    or `nose2`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与测试覆盖率相关的Python包包括`coverage`、`nose`和较新的`nose2`，它们可以提供覆盖率报告。例如，您可以运行以下命令，使用`nose`或`nose2`获取Lambda代码的测试覆盖分析报告：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When we commence with writing our own tests, we have an option to use an additional
    set of tools to do so. Such tools are known as code coverage tools. Codecov and
    Coveralls are examples of such tools. When we want to analyze the code that is
    written via hosting services such as GitHub, these tools are very helpful as they
    provided a complete breakdown of whether the lines are tested.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始编写自己的测试时，我们可以选择使用一组额外的工具来进行测试。这些工具被称为代码覆盖工具。Codecov和Coveralls就是这样的工具的例子。当我们想要分析通过GitHub等托管服务编写的代码时，这些工具非常有用，因为它们提供了完整的分析，以确定哪些行已经进行了测试。
- en: Running and debugging your AWS Lambda code locally
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本地运行和调试AWS Lambda代码
- en: Sometimes you want to simulate an API Gateway payload with a local Lambda against
    a real instance of remote DynamoDB hosted in AWS. This allows you to debug and
    build up unit tests with real data. In addition, we will see how these can later
    be used in the integration test.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您希望使用本地Lambda模拟API Gateway负载，针对AWS中托管的真实远程DynamoDB进行调试。这样可以使用真实数据进行调试和构建单元测试。此外，我们将看到这些稍后可以用于集成测试。
- en: Batch-loading data into DynamoDB
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 批量加载数据到DynamoDB
- en: 'We will first discuss how to batch-load data into DynamoDB from a **comma-separated
    values** (**CSV**) file called `sample_data/dynamodb-sample-data.txt`. Rather
    than insert an individual statement for each item, this is a much more efficient
    process, as the data file is decoupled from the Python code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先讨论如何从名为`sample_data/dynamodb-sample-data.txt`的**逗号分隔值**（**CSV**）文件中批量加载数据到DynamoDB。与为每个项目插入单个语句不同，这是一个更高效的过程，因为数据文件与Python代码是解耦的。
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Add another method, called `update_dynamo_event_counter()`, that updates DynamoDB
    records using the `DynamoRepository` class.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 添加另一个名为`update_dynamo_event_counter()`的方法，该方法使用`DynamoRepository`类更新DynamoDB记录。
- en: 'Here are the contents of the `serverless-microservice-data-api/aws_dynamo/dynamo_insert_items_from_file.py` Python
    script:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`serverless-microservice-data-api/aws_dynamo/dynamo_insert_items_from_file.py`
    Python脚本的内容：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we have a `DynamoRepository` class that instantiates a connection to DynamoDB
    in `__init__()` and an `update_dynamo_event_counter()` method that updates the
    DynamoDB records if they exist, or adds a new one if they don't using the passed-in
    parameters. This is done in one atomic action.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个`DynamoRepository`类，在`__init__()`中实例化了与DynamoDB的连接，并且有一个`update_dynamo_event_counter()`方法，如果记录存在则更新DynamoDB记录，如果不存在则使用传入的参数添加新记录。这是一个原子操作。
- en: 'Here''s the second half of the `serverless-microservice-data-api/aws_dynamo/dynamo_insert_items_from_file.py` Python
    script:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`serverless-microservice-data-api/aws_dynamo/dynamo_insert_items_from_file.py`
    Python脚本的后半部分：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This Python code opens the CSV, extracts the header row, and parses each row
    while writing it to the DynamoDB table called `user-visits-sam`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这段Python代码打开CSV文件，提取标题行，并解析每一行，同时将其写入名为`user-visits-sam`的DynamoDB表中。
- en: Now that we have loaded some data rows into the DynamoDB table, we will query
    the table by debugging a local Lambda function.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将一些数据行加载到DynamoDB表中，我们将通过调试本地Lambda函数来查询表。
- en: Running the Lambda locally
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本地运行Lambda
- en: 'Here is a full example API Gateway request, `serverless-microservice-data-api/sample_data/request-api-gateway-valid-date.json`,
    that a proxy Lambda function would receive as an event. These can be generated
    by printing the real API Gateway JSON event, which the Lambda gets as an event
    source into CloudWatch logs:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个完整的API网关请求示例，`serverless-microservice-data-api/sample_data/request-api-gateway-valid-date.json`，代理Lambda函数将作为事件接收。这些可以通过打印Lambda作为事件源传递给CloudWatch日志的真实API网关JSON事件来生成：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Rather than relying on another third-party framework for local debugging (such
    as the SAM CLI), you can debug a Lambda function directly by calling it with the
    JSON `Dict` event. This means that you don't need any additional libraries to
    run and it's native Python.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 与依赖于另一个第三方框架进行本地调试（例如SAM CLI）不同，您可以通过使用JSON `Dict`事件直接调用Lambda函数来直接调试Lambda函数。这意味着您无需任何额外的库来运行，而且它是本机Python。
- en: 'The contents of `serverless-microservice-data-api/test/run_local_api_gateway_lambda_dynamo.py`
    are an example of debugging a Lambda function locally with services such as DynamoDB
    in AWS:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`serverless-microservice-data-api/test/run_local_api_gateway_lambda_dynamo.py`的内容是使用AWS中的服务（例如DynamoDB）本地调试Lambda函数的示例。'
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We open the sample `GET` file, parse the JSON into `Dict`, and then pass it
    as an argument to `lambda_query_dynamo.lambda_handler()`. As we have not mocked
    DynamoDB, it will query the table specified in the `table_name = ''user-visits-sam''` Lambda
    function. It will then capture the output response, which could look like the
    following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打开样本`GET`文件，将JSON解析为`Dict`，然后将其作为参数传递给`lambda_query_dynamo.lambda_handler()`。由于我们没有模拟DynamoDB，它将查询`table_name
    = 'user-visits-sam'`Lambda函数中指定的表。然后它将捕获输出响应，可能如下所示：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The body is the same as we saw in the browser in [Chapter 3](559653f9-3f81-4443-badd-77796dceb0c0.xhtml),
    *Deploying Your Serverless Stack*. As such, you can debug different integration
    scenarios directly with real data and build more complete test suites as you step
    though the Lambda code with real data.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正文与我们在[第3章](559653f9-3f81-4443-badd-77796dceb0c0.xhtml)中在浏览器中看到的内容相同，*部署您的无服务器堆栈*。因此，您可以直接使用真实数据调试不同的集成场景，并在使用真实数据的Lambda代码中构建更完整的测试套件。
- en: Integration testing using real test data
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用真实测试数据进行集成测试
- en: 'Now that we understand the real test data, we will look at how we can test
    a deployed Lambda function. First, you will need to install and set up the AWS
    CLI and configure the AWS Credentials as shown at the end of [Chapter 1](669eac03-68f5-4097-83fb-0f0ecce5ef42.xhtml),
    *Serverless Microservices Architectures and Patterns*:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了真实测试数据，我们将看看如何测试已部署的Lambda函数。首先，您需要安装和设置AWS CLI，并按照[第1章](669eac03-68f5-4097-83fb-0f0ecce5ef42.xhtml)末尾显示的方式配置AWS凭据：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will redeploy the serverless microservice stack we deployed in [Chapter
    3](559653f9-3f81-4443-badd-77796dceb0c0.xhtml), *Deploying Your Serverless Stack*,
    so that we can test it. Use the following commands:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重新部署在[第3章](559653f9-3f81-4443-badd-77796dceb0c0.xhtml)中部署的无服务器微服务堆栈，*部署您的无服务器堆栈*，以便我们可以测试它。使用以下命令：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will rebuild the Lambda ZIP package as the code if there have been any
    changes. Then it will package and deploy the code and SAM configuration. Finally,
    it will create the API Gateway, Lambda function, and DynamoDB table.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这将重新构建Lambda ZIP包作为代码（如果有任何更改）。然后它将打包和部署代码和SAM配置。最后，它将创建API网关、Lambda函数和DynamoDB表。
- en: For testing, we will be using the AWS CLI, which can invoke all of the AWS-managed
    services. Here we are interested in the `<code>lambda</code>` ([https://docs.aws.amazon.com/cli/latest/reference/lambda/index.html](https://docs.aws.amazon.com/cli/latest/reference/lambda/index.html))
    and `<code>apigateway</code>` ([https://docs.aws.amazon.com/cli/latest/reference/apigateway/index.html](https://docs.aws.amazon.com/cli/latest/reference/apigateway/index.html))
    services.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于测试，我们将使用AWS CLI，它可以调用所有AWS托管的服务。在这里，我们对`lambda` ([https://docs.aws.amazon.com/cli/latest/reference/lambda/index.html](https://docs.aws.amazon.com/cli/latest/reference/lambda/index.html))和`apigateway`
    ([https://docs.aws.amazon.com/cli/latest/reference/apigateway/index.html](https://docs.aws.amazon.com/cli/latest/reference/apigateway/index.html))服务感兴趣。
- en: Testing that a Lambda has been deployed correctly
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试Lambda是否已正确部署
- en: 'To test a deployed Lambda, you can run the following command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 测试部署的Lambda，您可以运行以下命令：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To automate it, we can put the following code into a shell script, `serverless-microservice-data-api/bash/apigateway-lambda-dynamodb/invoke-lambda.sh`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自动化，我们可以将以下代码放入一个shell脚本，`serverless-microservice-data-api/bash/apigateway-lambda-dynamodb/invoke-lambda.sh`：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We invoke the Lambda, but also check the response given in the `outputfile.tmp`
    file using the `grep` command. We return an exit code of `1` if an error is detected,
    and `0` otherwise. This allows you to chain logic when involved by other tools
    or by CI/CD steps.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用Lambda，但也使用`grep`命令检查`outputfile.tmp`文件中的响应。如果检测到错误，则返回退出代码`1`，否则返回`0`。这允许您在其他工具或CI/CD步骤中链接逻辑。
- en: Testing that API Gateway has been deployed correctly
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试API网关是否已正确部署
- en: We also want to be able to test that the serverless microservice API is working
    correctly after it is deployed. I use a mix of Python and bash to make it easier.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望在部署后能够测试无服务器微服务API是否正常工作。我使用Python和bash混合使用，以使其更容易。
- en: 'A Python script called `serverless-microservice-data-api/bash/apigateway-lambda-dynamodb/get_apigateway_endpoint.py`
    is first used to query AWS API Gateway to get the full endpoint and return a code
    `0` if it succeeds:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先使用名为`serverless-microservice-data-api/bash/apigateway-lambda-dynamodb/get_apigateway_endpoint.py`的Python脚本查询AWS
    API Gateway以获取完整的端点，并在成功时返回代码`0`：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Then we use a shell script to call the Python script. The Python script returns
    the API endpoint, which is used in the curl with the sample `GET` request. We
    then look to see whether we get a valid status code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用一个shell脚本来调用Python脚本。Python脚本返回API端点，该端点在curl中与样本`GET`请求一起使用。然后我们查看是否获得有效的状态码。
- en: 'Here is the full script for `serverless-microservice-data-api/bash/apigateway-lambda-dynamodb/curl-api-gateway.sh`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`serverless-microservice-data-api/bash/apigateway-lambda-dynamodb/curl-api-gateway.sh`的完整脚本：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Having these scripts set up in this way allows us to easily automate these integrations
    tests.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式设置这些脚本使我们能够轻松地自动化这些集成测试。
- en: '**Functions as a Service** (**FaaS**) is still a relatively new area. There
    are still many discussions on the types of integration tests that should be used.
    One view is that we should do the full suite of testing in a different AWS account,
    especially the ones that would write or update a data store, such as `POST` or
    `PUT` requests.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数即服务**（**FaaS**）仍然是一个相对较新的领域。关于应该使用哪种类型的集成测试仍然有很多讨论。有一种观点是，我们应该在不同的AWS账户中进行全套测试，特别是那些会写入或更新数据存储的测试，比如`POST`或`PUT`请求。'
- en: I've included `--profile` and `aws_account_id` if you want to do this. In addition,
    with API Gateway, you can use a wide range of test suites that already exist around
    the HTTP endpoints, but testing other AWS services integration with Lambdas, such
    as objects being created in S3 that trigger a Lambda, needs a little bit more
    work and thought. In my view, serverless integration tests are still less mature,
    but I have already shown how they can be achieved by invoking the Lambda function
    directly with AWS CLI and Lambda with a JSON event source payload or invoking
    the API Gateway endpoint directly with a `curl` command.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想这样做，我已经包括了`--profile`和`aws_account_id`。此外，使用API Gateway，您可以使用一系列已经存在的围绕HTTP端点的测试套件，但是测试Lambdas与其他AWS服务的集成，比如在S3中创建触发Lambda的对象，需要更多的工作和思考。在我看来，无服务器集成测试仍然不够成熟，但我已经展示了如何通过使用AWS
    CLI直接调用Lambda函数以及使用JSON事件源负载调用API Gateway端点来实现它们。
- en: Next we will look at how the SAM CLI can also be used for local testing.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看SAM CLI如何用于本地测试。
- en: The AWS Serverless Application Model CLI
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS无服务器应用程序模型CLI
- en: 'In this section, we will walk through different features of SAM Local with
    fully-working examples. For local testing, you can use Python and bash like I
    have shown or you can also use the SAM CLI ([https://github.com/awslabs/aws-sam-cli](https://github.com/awslabs/aws-sam-cli)),
    which at the time of writing is still in beta. It uses Docker and is based on
    open source `docker-lambda` ([https://github.com/lambci/docker-lambda](https://github.com/lambci/docker-lambda))
    Docker images. If you are using Windows 10 Home, I recommend you upgrade to Pro
    or Enterprise as it''s harder to get Docker working on the Home edition. There
    are also some hardware requirements, such as virtualization, to be aware of. We
    need to perform the following steps:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过完全可用的示例演示SAM Local的不同功能。对于本地测试，您可以像我展示的那样使用Python和bash，也可以使用SAM CLI
    ([https://github.com/awslabs/aws-sam-cli](https://github.com/awslabs/aws-sam-cli))，在撰写本文时仍处于测试阶段。它使用Docker，并且基于开源`docker-lambda`
    ([https://github.com/lambci/docker-lambda](https://github.com/lambci/docker-lambda))
    Docker镜像。如果您使用的是Windows 10 Home，我建议您升级到Pro或Enterprise，因为在Home版上更难使Docker工作。还有一些硬件要求，比如虚拟化，需要注意。我们需要执行以下步骤：
- en: Install the AWS CLI ([https://docs.aws.amazon.com/cli/latest/userguide/installing.html](https://docs.aws.amazon.com/cli/latest/userguide/installing.html)).
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装AWS CLI ([https://docs.aws.amazon.com/cli/latest/userguide/installing.html](https://docs.aws.amazon.com/cli/latest/userguide/installing.html))。
- en: Install Docker CE ([https://docs.docker.com/install/](https://docs.docker.com/install/)).
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Docker CE ([https://docs.docker.com/install/](https://docs.docker.com/install/))。
- en: Install the AWS SAM CLI ([https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html](https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html)).
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装AWS SAM CLI ([https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html](https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html))。
- en: 'For Linux, you can run the following:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于Linux，您可以运行以下命令：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For Windows, you can install AWS SAM CLI using an MSI.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于Windows，您可以使用MSI安装AWS SAM CLI。
- en: 'Create a new SAM Python 3.6 project, `sam-app`, and `docker pull` the images
    (this should happen automatically but I needed to do `pull` to get it to work):'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的SAM Python 3.6项目，`sam-app`，并`docker pull`镜像（这应该会自动发生，但我需要执行`pull`才能使其工作）：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Invoke the following function:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用以下函数：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You will get the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得以下内容：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This can be used to add automated testing.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用于添加自动化测试。
- en: 'Start the local Lambda endpoint:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动本地Lambda端点：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This starts a Docker container that emulates AWS Lambda with an HTTP server
    locally, which you can use to automate the testing of your Lambda functions from
    the AWS CLI or Boto3.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个模拟AWS Lambda的Docker容器，并在本地启动一个HTTP服务器，您可以使用它来自动化测试AWS CLI或Boto3中的Lambda函数。
- en: 'Start an API and test it using the following:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动API并使用以下进行测试：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This starts a Docker container with an HTTP server locally, which you can use
    to automate the testing of the API you can use with `curl`, Postman, or your web
    browser.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在本地启动一个带有HTTP服务器的Docker容器，您可以使用它来自动化测试与`curl`、Postman或您的Web浏览器一起使用的API。
- en: 'One way to generate sample events is to print out the event from a Lambda,
    and copy it from CloudWatch logs (my preference). Another way is to use `sam local`,
    which can generate some examples events. For example, you can run the following:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成示例事件的一种方法是从Lambda中打印出事件，并从CloudWatch日志中复制它（这是我的首选）。另一种方法是使用`sam local`，它可以生成一些示例事件。例如，您可以运行以下命令：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Personally, I haven't used the SAM CLI extensively as it is very new, needs
    Docker installed, and is still in beta. But it does look promising, and as another
    tool to test your serverless stack, it's useful that it can simulate a Lambda
    in Docker container that exposes an endpoint, and I expect more features to be
    added in the future.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 就我个人而言，我并没有广泛使用SAM CLI，因为它非常新，需要安装Docker，并且仍处于测试阶段。但它看起来很有前途，作为测试无服务器堆栈的另一个工具，它很有用，因为它可以在Docker容器中模拟Lambda并公开端点，我期望未来会添加更多功能。
- en: Perhaps less usefully, it also wraps some of the existing command's serverless
    package and deployment commands as an alias for the CloudFormation ones. I think
    this is done to keep them all in one place.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 也许不太有用的是，它还将一些现有命令的无服务器打包和部署命令包装为CloudFormation命令的别名。我认为这样做是为了将它们都放在一个地方。
- en: 'Here is an example of the SAM CLI `package` and `deploy` commands:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是SAM CLI `package`和`deploy`命令的示例：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'CloudFormation with SAM to `package` and `deploy` commands:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SAM的CloudFormation进行`package`和`deploy`命令：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Loading and end-to-end testing at scale
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载和规模化的端到端测试
- en: Next, we are going to take a look at Locust, which is a Python tool for performance
    and load testing. Then we are going to talk about strategies to reduce the API's
    latency and improve the response time of the API, and using Locust will show us
    the performance improvements.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一下Locust，这是一个用于性能和负载测试的Python工具。然后我们将讨论减少API延迟和改善API响应时间的策略，使用Locust将向我们展示性能改进。
- en: Load testing your serverless microservice
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对您的无服务器微服务进行负载测试
- en: First, you need to have a serverless microservice stack running with `./build-package-deploy-lambda-dynamo-data-api.sh`,
    and have loaded data into the DynamoDB table using the `python3 dynamo_insert_items_from_file.py` Python
    script.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要运行一个带有`./build-package-deploy-lambda-dynamo-data-api.sh`的无服务器微服务堆栈，并使用`python3
    dynamo_insert_items_from_file.py` Python脚本将数据加载到DynamoDB表中。
- en: 'Then install Locust, if it hasn''t already been installed with the other packages
    in `requirements.txt`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后安装Locust，如果它尚未与`requirements.txt`中的其他软件包一起安装：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Locust ([https://docs.locust.io](https://docs.locust.io)) is an easy-to-use
    load-testing tool with a web metrics and monitoring interface. It allows you to
    define user behavior using Python code and can be used to simulate millions of
    users over multiple machines.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Locust ([https://docs.locust.io](https://docs.locust.io))是一个易于使用的负载测试工具，具有Web指标和监控界面。它允许您使用Python代码定义用户行为，并可用于在多台机器上模拟数百万用户。
- en: 'To use Locust, you first need to create a Locust Python file where you define
    the Locust tasks. The `HttpLocust` class adds a client attribute that is used
    to make the HTTP request. A `TaskSet` class defines a set of tasks that a Locust
    user will execute. The `@task` decorator declares the tasks for `TaskSet`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Locust，您首先需要创建一个Locust Python文件，在其中定义Locust任务。`HttpLocust`类添加了一个客户端属性，用于发出HTTP请求。`TaskSet`类定义了Locust用户将执行的一组任务。`@task`装饰器声明了`TaskSet`的任务：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: To test the `GET` method with different resources and parameters, we are selecting
    three different paths randomly from a paths list, where one of the IDs does not
    exist in DynamoDB. The main idea is that we could easily scale this out to simulate
    millions of different queries if we had loaded their corresponding rows from a
    file into DynamoDB. Locust supports much more complex behaviors, including processing
    responses, simulating user logins, sequencing, and event hooks, but this script
    is a good start.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试`GET`方法与不同的资源和参数，我们从路径列表中随机选择三个不同的路径，其中一个ID在DynamoDB中不存在。主要思想是，如果我们已经将相应的行从文件加载到DynamoDB中，我们可以轻松地扩展到模拟数百万个不同的查询。Locust支持更复杂的行为，包括处理响应、模拟用户登录、排序和事件挂钩，但这个脚本是一个很好的开始。
- en: 'To run Locust, we need to get the API Gateway ID, which looks like `abcdefgh12`,
    to create the full hostname used for load testing. Here, I wrote a Python script
    called `serverless-microservice-data-api/bash/apigateway-lambda-dynamodbget_apigateway_id.py`
    that can do so based on the API name:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行Locust，我们需要获取API Gateway ID，看起来像`abcdefgh12`，以创建用于负载测试的完整主机名。在这里，我编写了一个名为`serverless-microservice-data-api/bash/apigateway-lambda-dynamodbget_apigateway_id.py`的Python脚本，可以根据API名称执行此操作：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Run the following commands to launch Locust:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令启动Locust：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Alternatively, I also have this `locust` run commands as a shell script you
    can run under the `test` folder `serverless-microservice-data-api/bash/apigateway-lambda-dynamodb/run_locus.sh`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我还有这个`locust`运行命令，可以作为一个shell脚本运行，在`test`文件夹`serverless-microservice-data-api/bash/apigateway-lambda-dynamodb/run_locus.sh`下：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You should now see Locust start in the Terminal and perform the following steps:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该在终端中看到Locust启动并执行以下步骤：
- en: Navigate to `http://localhost:8089/` in your web browser to access the Locust
    web-monitoring and -testing interface.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Web浏览器中导航到`http://localhost:8089/`，以访问Locust Web监控和测试界面。
- en: 'In the Start New Locust swarm, enter the following:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始新的Locust群中，输入以下内容：
- en: '`10` for **Number of users** to simulate'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模拟的用户数量**为`10`'
- en: '`5` for Hatch rate (users spawned/second)'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`5`用于Hatch速率（每秒生成的用户）'
- en: Leave the tool running on the Statistics tab for a few minutes.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在统计选项卡上让工具运行几分钟。
- en: 'You will get something like this in the Statistics tab:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在统计选项卡中，您将得到类似以下的内容：
- en: '![](img/4c3715e8-f782-4920-bab7-04b091154bb0.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4c3715e8-f782-4920-bab7-04b091154bb0.png)'
- en: 'And on the Charts tab, you should get something similar to the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在图表选项卡上，您应该会得到类似以下的内容：
- en: '![](img/43fbaf5b-6abd-45ec-bd3f-4e1f816cdc5d.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/43fbaf5b-6abd-45ec-bd3f-4e1f816cdc5d.png)'
- en: In the Response Times (ms) chart, the orange line represents the 95^(th) percentile,
    and green is for the median response times.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应时间（毫秒）图表中，橙色线代表95^(th)百分位数，绿色代表中位数响应时间。
- en: 'Here are some observations about the preceding charts:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是有关前面图表的一些观察：
- en: The maximum request time is 2,172 milliseconds or about 2.1 seconds, which is
    really slow—this is linked to what is known as a cold start, which is the slower
    way to first launch a Lambda.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大请求时间为2,172毫秒，约为2.1秒，这非常慢——这与所谓的冷启动有关，这是首次启动Lambda的较慢方式。
- en: 'The number of fails also goes up after about a minute—this is because DynamoDB
    permits some burst reads before it starts to throttle the read requests. If you
    log onto the AWS Management Console and look at the DynamoDB table metrics, you
    will see that this is happening:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大约一分钟后，失败的次数也会增加——这是因为DynamoDB在开始限制读取请求之前允许一些突发读取。如果您登录到AWS管理控制台并查看DynamoDB表指标，您将看到正在发生这种情况：
- en: '![](img/4704d163-b694-4510-ba67-6a57890ee1a7.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4704d163-b694-4510-ba67-6a57890ee1a7.png)'
- en: Strategies to reduce the API's latency
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少API延迟的策略
- en: 'There are many strategies to reduce latency. We will look at two, both of which
    are set in the SAM template:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多减少延迟的策略。我们将看两种，这两种都在SAM模板中设置：
- en: '**Increasing the Lambda RAM size**: Currently, it is set to the minimum of
    128 MB'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增加Lambda RAM大小**：目前设置为最小的128 MB'
- en: '**Increasing the DynamoDB Read Capacity**: Currently, it is set to the smallest
    value of 1 unit'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增加DynamoDB读取容量**：目前设置为最小值1个单位'
- en: What I really like about DynamoDB is that you can change the capacity per table,
    and change the write capacity independently of the read capacity. This is very
    interesting and cost-effective for me in read-heavy use cases, where I can set
    the read capacity higher than the write capacity. There are even options to have
    the table autoscale based on the read/write utilization, or have the capacity
    purely based **on demand**, where you pay per read/write request.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我真的很喜欢DynamoDB的一点是，您可以更改每个表的容量，并且可以独立更改写入容量和读取容量。这对于我来说在读取密集型用例中非常有趣和划算，我可以将读取容量设置得比写入容量更高。甚至还有选项可以根据读/写利用率自动调整表的容量，或者完全基于需求，按照每次读/写请求付费。
- en: We will start by increasing the DynamoDB read capacity for the table from 1
    to 500 read units (keep the write capacity at 1 units). The cost was $0.66/month,
    but it will now increase to $55.24/month.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从1增加DynamoDB表的读取容量到500个读取单位（保持写入容量为1个单位）。费用原本是每月$0.66，但现在将增加到每月$55.24。
- en: 'Edit the `lambda-dynamo-data-api.yaml` SAM YAML template file and increase `ReadCapacityUnits`
    from `1` to `500`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`lambda-dynamo-data-api.yaml` SAM YAML模板文件，并将`ReadCapacityUnits`从`1`增加到`500`：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Run `./build-package-deploy-lambda-dynamo-data-api.sh` to deploy the serverless
    stack with the DynamoDB table changes.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`./build-package-deploy-lambda-dynamo-data-api.sh`来部署带有DynamoDB表更改的无服务器堆栈。
- en: 'Now run Locust again with 10 users with a hatch rate of 5:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在以5的孵化速率再次使用10个用户运行Locust：
- en: '![](img/c7010d83-294f-4e89-b8c5-a71631f1822e.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7010d83-294f-4e89-b8c5-a71631f1822e.png)'
- en: 'And on the Charts tab, you should get something similar to the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在图表选项卡上，您应该会得到类似以下的结果：
- en: '![](img/5820f3fb-b465-4722-8e28-596a7a4c6559.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5820f3fb-b465-4722-8e28-596a7a4c6559.png)'
- en: 'Here are some observations about the preceding charts:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于前述图表的一些观察：
- en: There are zero faults
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有故障
- en: The average response time is 64 milliseconds, which is excellent
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平均响应时间为64毫秒，这非常好
- en: We get these results because the DynamoDB table read capacity was increased,
    that is, the requests are no longer getting throttled.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到这些结果是因为增加了DynamoDB表的读取容量，也就是说，请求不再被限制。
- en: 'Now increase the RAM available in the Lambda function:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在增加Lambda函数中可用的RAM：
- en: 'Modify the `lambda-dynamo-data-api.yaml` SAM YAML file by changing MemorySize:
    128 to MemorySize: 1536.'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '通过将MemorySize: 128更改为MemorySize: 1536来修改`lambda-dynamo-data-api.yaml` SAM YAML文件。'
- en: Run `./build-package-deploy-lambda-dynamo-data-api.sh` to deploy the serverless
    stack with the Lambda RAM changes.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`./build-package-deploy-lambda-dynamo-data-api.sh`来部署带有Lambda RAM更改的无服务器堆栈。
- en: 'Here are some observations that we''ve made the preceding changes:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们对前述更改所做的一些观察：
- en: There are zero faults
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有故障
- en: The average response time is 60 milliseconds, which is slightly better, especially
    considering this is a round trip of API Gateway to Lambda to DynamoDB and back
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平均响应时间为60毫秒，这稍微好一些，特别是考虑到这是API Gateway到Lambda到DynamoDB再返回的一个往返。
- en: 'With 100 users with a hatch rate of 10, we get the following results:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用10的孵化速率和100个用户，我们得到以下结果：
- en: There are zero faults
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有故障
- en: The average response time is 66 milliseconds, with a max of 1,057 milliseconds
    at the start of the load test
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平均响应时间为66毫秒，负载测试开始时最大为1,057毫秒
- en: 'With 250 users with a hatch rate of 50, we get the following results:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用50的孵化速率和250个用户，我们得到以下结果：
- en: There are zero faults
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有故障
- en: The average response time is 81 ms, with a max of 1,153 milliseconds at the
    start of the load test
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平均响应时间为81毫秒，负载测试开始时最大为1,153毫秒。
- en: You can test with a higher number of concurrent users as well, such as 1,000,
    and it will still work without faults even if the response time will be much higher
    to due to other bottlenecks. If you want to scale out further, I recommend you
    consider a different architecture. It is still impressive to have a serverless
    microservice scale up so easily, with just a couple of parameter changes in a
    config file!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以测试更高数量的并发用户，比如1,000个，即使响应时间会因其他瓶颈而大大增加，但系统仍然可以正常工作。如果您想进一步扩展规模，我建议您考虑不同的架构。仅仅通过在配置文件中更改几个参数，就能如此轻松地扩展无服务器微服务，仍然令人印象深刻！
- en: This gives you a very good idea of how you can reduce the latency of your API.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这让您对如何减少API的延迟有了很好的了解。
- en: Cleaning up
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理
- en: 'Run the following shell script with `./delete-stack.sh` to delete the serverless
    stack:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`./delete-stack.sh`运行以下shell脚本来删除无服务器堆栈：
- en: '[PRE33]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored many types of testing, including unit tests with
    mocks, integration testing with Lambda and API Gateway, debugging a Lambda locally,
    making a local endpoint available, and load testing. This is something that we
    will build upon in the rest of this book.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了许多类型的测试，包括使用模拟进行单元测试，使用Lambda和API Gateway进行集成测试，本地调试Lambda，提供本地端点以及负载测试。这是我们将在本书的其余部分继续构建的内容。
- en: In the next chapter, we will look at serverless, distributed data management
    patterns and architectures that you can apply within your organization.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨无服务器的分布式数据管理模式和架构，您可以在组织中应用这些模式。
